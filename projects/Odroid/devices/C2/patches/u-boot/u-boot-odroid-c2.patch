diff --git a/Makefile b/Makefile
index 36a9a28..1da09c2 100644
--- a/Makefile
+++ b/Makefile
@@ -12,7 +12,7 @@ NAME =
 
 # Do not use make's built-in rules and variables
 # (this increases performance and avoids hard-to-debug behaviour);
-MAKEFLAGS += -rR
+MAKEFLAGS += -rR --no-print-directory
 
 # Avoid funny character set dependencies
 unexport LC_ALL
@@ -118,6 +118,8 @@ ifeq ($(KBUILD_SRC),)
 # Do we want to locate output files in a separate directory?
 ifeq ("$(origin O)", "command line")
   KBUILD_OUTPUT := $(O)
+else
+  KBUILD_OUTPUT := build
 endif
 
 # That's our default target when none is given on the command line
@@ -156,7 +158,7 @@ ifeq ($(skip-makefile),)
 # Do not print "Entering directory ...",
 # but we want to display it when entering to the output directory
 # so that IDEs/editors are able to understand relative filenames.
-MAKEFLAGS += --no-print-directory
+#MAKEFLAGS += --no-print-directory
 
 # Call a source code checker (by default, "sparse") as part of the
 # C compilation.
@@ -210,9 +212,12 @@ objtree		:= .
 src		:= $(srctree)
 obj		:= $(objtree)
 
+buildsrc	:= $(abspath $(srctree))
+buildtree	:= $(abspath $(CURDIR)/$(KBUILD_OUTPUT))
+
 VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
 
-export srctree objtree VPATH
+export srctree objtree VPATH KBUILD_OUTPUT buildtree buildsrc
 
 # Make sure CDPATH settings don't interfere
 unexport CDPATH
@@ -239,6 +244,12 @@ export	HOSTARCH HOSTOS
 # set default to nothing for native builds
 ifeq ($(HOSTARCH),$(ARCH))
 CROSS_COMPILE ?=
+else
+ifeq ($(CROSS_COMPILE),)
+CROSS_COMPILE = /opt/toolchains/gcc-linaro-aarch64-none-elf-4.9-2014.09_linux/bin/aarch64-none-elf-
+export CROSS_COMPILE
+endif
+
 endif
 
 KCONFIG_CONFIG	?= .config
@@ -582,6 +593,7 @@ include $(srctree)/scripts/Makefile.extrawarn
 KBUILD_CPPFLAGS += $(KCPPFLAGS)
 KBUILD_AFLAGS += $(KAFLAGS)
 KBUILD_CFLAGS += $(KCFLAGS)
+KBUILD_CFLAGS += -Werror
 
 # Use UBOOTINCLUDE when you must reference the include/ directory.
 # Needed to be compatible with the O= option
@@ -616,6 +628,7 @@ libs-y += drivers/gpio/
 libs-y += drivers/i2c/
 libs-y += drivers/mmc/
 libs-y += drivers/mtd/
+libs-$(CONFIG_AML_NAND) += drivers/nand/
 libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/
 libs-y += drivers/mtd/onenand/
 libs-$(CONFIG_CMD_UBI) += drivers/mtd/ubi/
@@ -709,7 +722,8 @@ endif
 
 # Always append ALL so that arch config.mk's can add custom ones
 ALL-y += u-boot.srec u-boot.bin System.map binary_size_check
-
+ALL-y += u-boot.hex
+ALL-y += fip.bin boot.bin
 ALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin
 ifeq ($(CONFIG_SPL_FSL_PBL),y)
 ALL-$(CONFIG_RAMBOOT_PBL) += u-boot-with-spl-pbl.bin
@@ -819,7 +833,7 @@ binary_size_check: u-boot.bin FORCE
 
 u-boot.bin: u-boot FORCE
 	$(call if_changed,objcopy)
-	$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE))
+	@$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE))
 	$(BOARD_SIZE_CHECK)
 
 u-boot.ldr:	u-boot
@@ -834,6 +848,47 @@ OBJCOPYFLAGS_u-boot.ldr.srec := -I binary -O srec
 u-boot.ldr.hex u-boot.ldr.srec: u-boot.ldr FORCE
 	$(call if_changed,objcopy)
 
+.PHONY: u-boot-comp.bin
+u-boot-comp.bin:u-boot.bin
+	#tools/uclpack $< $@
+	cp $< $@
+#	$(objtree)/tools/uclpack $< $@
+
+FUSING_FOLDER := $(srctree)/sd_fuse
+FIP_FOLDER := $(srctree)/fip
+FIP_FOLDER_SOC := $(FIP_FOLDER)/$(SOC)
+FIP_ARGS += --bl30 $(FIP_FOLDER_SOC)/bl30.bin
+ifeq ($(CONFIG_NEED_BL301), y)
+FIP_ARGS += --bl301 $(FIP_FOLDER_SOC)/bl301.bin
+endif
+FIP_ARGS += --bl31 $(FIP_FOLDER_SOC)/bl31.bin
+ifeq ($(CONFIG_NEED_BL32), y)
+FIP_ARGS += --bl32 $(FIP_FOLDER_SOC)/bl32.bin
+endif
+FIP_ARGS += --bl33 $(FIP_FOLDER_SOC)/bl33.bin
+
+.PHONY: fip.bin
+fip.bin: tools prepare
+	$(Q)cp u-boot.bin $(FIP_FOLDER_SOC)/bl33.bin
+	$(Q)$(FIP_FOLDER)/fip_create ${FIP_ARGS} $(FIP_FOLDER_SOC)/fip.bin
+	$(Q)$(FIP_FOLDER)/fip_create --dump $(FIP_FOLDER_SOC)/fip.bin
+
+.PHONY : boot.bin
+boot.bin: fip.bin
+	$(Q)cat $(FIP_FOLDER_SOC)/bl2.package  $(FIP_FOLDER_SOC)/fip.bin > $(FIP_FOLDER_SOC)/boot_new.bin
+	$(Q)$(FIP_FOLDER_SOC)/aml_encrypt_$(SOC) --bootsig --input $(FIP_FOLDER_SOC)/boot_new.bin --output $(FIP_FOLDER_SOC)/u-boot.bin
+ifeq ($(CONFIG_AML_CRYPTO_UBOOT), y)
+	$(Q)$(FIP_FOLDER_SOC)/aml_encrypt_$(SOC) --bootsig --input $(FIP_FOLDER_SOC)/boot_new.bin --amluserkey $(srctree)/board/$(BOARDDIR)/aml-user-key.sig --aeskey enable --output $(FIP_FOLDER_SOC)/u-boot.bin.encrypt
+endif
+ifeq ($(CONFIG_AML_CRYPTO_IMG), y)
+	$(Q)$(FIP_FOLDER_SOC)/aml_encrypt_$(SOC) --imgsig --input $(srctree)/board/$(BOARDDIR)/boot.img --amluserkey $(srctree)/board/$(BOARDDIR)/aml-user-key.sig --output $(FIP_FOLDER_SOC)/boot.img.encrypt
+	@cp -f $(FIP_FOLDER_SOC)/boot.img.encrypt $(FIP_FOLDER)/boot.img.encrypt
+endif
+	@cp -f $(FIP_FOLDER_SOC)/u-boot.* $(FIP_FOLDER)/
+	$(Q)dd if=$(FIP_FOLDER)/u-boot.bin of=$(FUSING_FOLDER)/u-boot.bin bs=512 skip=96
+	@rm -f $(FIP_FOLDER_SOC)/boot_new.bin
+	@echo '$(FIP_FOLDER_SOC)/u-boot.bin build done!'
+
 #
 # U-Boot entry point, needed for booting of full-blown U-Boot
 # from the SPL U-Boot version.
@@ -1335,9 +1390,19 @@ distclean: mrproper
 		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
 		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
 		-o -name '.*.rej' -o -name '*%' -o -name 'core' \
-		-o -name '*.pyc' \) \
+		-o -name '*.o' \) \
 		-type f -print | xargs rm -f
 	@rm -f boards.cfg
+	@rm -rf $(buildtree)/*
+	@rm -f $(FIP_FOLDER_SOC)/bl33.bin
+	@rm -f $(FIP_FOLDER_SOC)/fip.bin
+	@rm -f $(FIP_FOLDER_SOC)/boot.bin
+	@rm -f $(FIP_FOLDER_SOC)/boot_sd.bin
+	@rm -f $(FIP_FOLDER_SOC)/u-boot.bin
+	@rm -f $(FIP_FOLDER_SOC)/u-boot.bin.* $(FIP_FOLDER_SOC)/*.encrypt
+	@rm -f $(FIP_FOLDER)/u-boot.bin.* $(FIP_FOLDER)/*.bin $(FIP_FOLDER)/*.encrypt
+	@rm -f $(srctree)/fip/aml_encrypt_gxb
+	@rm -f $(FUSING_FOLDER)/u-boot.bin
 
 backup:
 	F=`basename $(srctree)` ; cd .. ; \
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 5eb1d03..91e1d21 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -732,6 +732,10 @@ config TARGET_LS2085A_SIMU
 	bool "Support ls2085a_simu"
 	select ARM64
 
+config TARGET_MESON_GX
+	bool "Support meson gx-series 64bit"
+	select ARM64
+
 config TARGET_LS1021AQDS
 	bool "Support ls1021aqds"
 	select CPU_V7
@@ -984,6 +988,10 @@ source "board/woodburn/Kconfig"
 source "board/xaeniax/Kconfig"
 source "board/zipitz2/Kconfig"
 
+source "board/amlogic/Kconfig"
+
+source "board/hardkernel/Kconfig"
+
 source "arch/arm/Kconfig.debug"
 
 endmenu
diff --git a/arch/arm/cpu/armv8/Makefile b/arch/arm/cpu/armv8/Makefile
index 0c10223..2b3cf99 100644
--- a/arch/arm/cpu/armv8/Makefile
+++ b/arch/arm/cpu/armv8/Makefile
@@ -16,3 +16,4 @@ obj-y	+= tlb.o
 obj-y	+= transition.o
 
 obj-$(CONFIG_FSL_LSCH3) += fsl-lsch3/
+obj-$(CONFIG_AML_MESON) += $(SOC)/
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/cache_v8.c b/arch/arm/cpu/armv8/cache_v8.c
index 9dbcdf2..741a4db 100644
--- a/arch/arm/cpu/armv8/cache_v8.c
+++ b/arch/arm/cpu/armv8/cache_v8.c
@@ -25,7 +25,7 @@ void set_pgtable_section(u64 *page_table, u64 index, u64 section,
 /* to activate the MMU we need to set up virtual memory */
 static void mmu_setup(void)
 {
-	int i, j, el;
+	u64 i, j, el;
 	bd_t *bd = gd->bd;
 	u64 *page_table = (u64 *)gd->arch.tlb_addr;
 
@@ -38,7 +38,12 @@ static void mmu_setup(void)
 	/* Setup an identity-mapping for all RAM space */
 	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
 		ulong start = bd->bi_dram[i].start;
+		/* plus CONFIG_SYS_MEM_TOP_HIDE, for all ddr need cached */
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+		ulong end = bd->bi_dram[i].start + bd->bi_dram[i].size + CONFIG_SYS_MEM_TOP_HIDE;
+#else
 		ulong end = bd->bi_dram[i].start + bd->bi_dram[i].size;
+#endif
 		for (j = start >> SECTION_SHIFT;
 		     j < end >> SECTION_SHIFT; j++) {
 			set_pgtable_section(page_table, j, j << SECTION_SHIFT,
@@ -126,7 +131,8 @@ void dcache_disable(void)
 
 	set_sctlr(sctlr & ~(CR_C|CR_M));
 
-	flush_dcache_all();
+	__asm_flush_dcache_all();
+	flush_l3_cache();
 	__asm_invalidate_tlb_all();
 }
 
diff --git a/arch/arm/cpu/armv8/gxb/Makefile b/arch/arm/cpu/armv8/gxb/Makefile
new file mode 100644
index 0000000..83756c5
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/Makefile
@@ -0,0 +1,9 @@
+
+obj-y	:= clock.o sdio.o gpio.o
+obj-y	+= usb.o
+obj-y   += bl31_apis.o
+obj-y	+= watchdog.o
+obj-$(CONFIG_AML_HDMITX20) += hdmitx20/
+obj-y	+= timer.o
+obj-y	+= mailbox.o
+obj-y   += gate_init.o
diff --git a/arch/arm/cpu/armv8/gxb/bl31_apis.c b/arch/arm/cpu/armv8/gxb/bl31_apis.c
new file mode 100644
index 0000000..992742b
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/bl31_apis.c
@@ -0,0 +1,321 @@
+/*
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Trustzone API
+ *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * Author: Platform-BJ@amlogic.com
+ *
+ */
+
+#include <asm/arch/io.h>
+#include <asm/arch/efuse.h>
+#include <asm/cache.h>
+/* #include <asm/system.h> */
+#include <asm/arch/bl31_apis.h>
+
+static long sharemem_input_base;
+static long sharemem_output_base;
+
+long get_sharemem_info(unsigned long function_id)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: "+r" (function_id));
+
+	return function_id;
+}
+
+#ifdef CONFIG_EFUSE
+int32_t meson_trustzone_efuse(struct efuse_hal_api_arg *arg)
+{
+	int ret;
+	unsigned cmd, offset, size;
+	unsigned long *retcnt = (unsigned long *)(arg->retcnt_phy);
+
+	if (!sharemem_input_base)
+		sharemem_input_base =
+			get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+
+	if (arg->cmd == EFUSE_HAL_API_READ)
+		cmd = EFUSE_READ;
+	else if (arg->cmd == EFUSE_HAL_API_WRITE)
+		cmd = EFUSE_WRITE;
+	else
+		cmd = EFUSE_WRITE_PATTERN;
+	offset = arg->offset;
+	size = arg->size;
+
+	if (arg->cmd == EFUSE_HAL_API_WRITE)
+		memcpy((void *)sharemem_input_base,
+		       (const void *)arg->buffer_phy, size);
+		asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = cmd;
+	register uint64_t x1 asm("x1") = offset;
+	register uint64_t x2 asm("x2") = size;
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2));
+	} while (0);
+	ret = x0;
+	*retcnt = x0;
+
+	if ((arg->cmd == EFUSE_HAL_API_READ) && (ret != 0))
+		memcpy((void *)arg->buffer_phy,
+		       (const void *)sharemem_output_base, ret);
+
+	if (!ret)
+		return -1;
+	else
+		return 0;
+}
+
+int32_t meson_trustzone_efuse_get_max(struct efuse_hal_api_arg *arg)
+{
+	int32_t ret;
+	unsigned cmd;
+
+	if (arg->cmd == EFUSE_HAL_API_USER_MAX)
+		cmd = EFUSE_USER_MAX;
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = cmd;
+
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0));
+	} while (0);
+	ret = x0;
+
+	if (!ret)
+		return -1;
+	else
+		return ret;
+}
+
+ssize_t meson_trustzone_efuse_writepattern(const char *buf, size_t count)
+{
+	struct efuse_hal_api_arg arg;
+	unsigned long retcnt;
+
+	if (count != EFUSE_BYTES)
+		return 0;	/* Past EOF */
+
+	arg.cmd = EFUSE_HAL_API_WRITE_PATTERN;
+	arg.offset = 0;
+	arg.size = count;
+	arg.buffer_phy = (unsigned long)buf;
+	arg.retcnt_phy = (unsigned long)&retcnt;
+	int ret;
+	ret = meson_trustzone_efuse(&arg);
+	return ret;
+}
+
+#endif
+
+
+
+
+uint64_t meson_trustzone_efuse_check(unsigned char *addr)
+{
+	uint64_t ret = 0;
+	struct sram_hal_api_arg arg = {};
+
+	arg.cmd = SRAM_HAL_API_CHECK_EFUSE;
+	arg.req_len = 0x1000000;
+	arg.res_len = 0;
+	arg.req_phy_addr = (unsigned long)addr;
+	arg.res_phy_addr = (unsigned long)NULL;
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = CALL_TRUSTZONE_HAL_API;
+	register uint64_t x1 asm("x1") = TRUSTZONE_HAL_API_SRAM;
+	register uint64_t x2 asm("x2") = (unsigned long)(&arg);
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    "smc #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2));
+	} while (0);
+
+	ret = x0;
+
+	return ret;
+}
+
+void debug_efuse_cmd(unsigned long cmd)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: : "r" (cmd));
+}
+
+
+void bl31_debug_efuse_write_pattern(const char *buf)
+{
+	if (!sharemem_input_base)
+		sharemem_input_base =
+			get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+	memcpy((void *)sharemem_input_base, (const void *)buf, 512);
+
+	debug_efuse_cmd(DEBUG_EFUSE_WRITE_PATTERN);
+}
+
+void bl31_debug_efuse_read_pattern(char *buf)
+{
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+	debug_efuse_cmd(DEBUG_EFUSE_READ_PATTERN);
+
+	memcpy((void *)buf, (const void *)sharemem_output_base, 512);
+}
+
+void aml_set_jtag_state(unsigned state, unsigned select)
+{
+	uint64_t command;
+	if (state == JTAG_STATE_ON)
+		command = JTAG_ON;
+	else
+		command = JTAG_OFF;
+	asm __volatile__("" : : : "memory");
+
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		"smc    #0\n"
+		: : "r" (command), "r"(select));
+}
+
+unsigned aml_get_reboot_reason(void)
+{
+	unsigned reason;
+	uint64_t ret;
+
+	register uint64_t x0 asm("x0") = GET_REBOOT_REASON;
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc #0\n"
+		:"+r"(x0));
+		ret = x0;
+		reason = (unsigned)(ret&0xffffffff);
+		return reason;
+}
+
+unsigned aml_reboot(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2)
+{
+	register long x0 asm("x0") = function_id;
+	register long x1 asm("x1") = arg0;
+	register long x2 asm("x2") = arg1;
+	register long x3 asm("x3") = arg2;
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			__asmeq("%2", "x2")
+			__asmeq("%3", "x3")
+			"smc	#0\n"
+		: "+r" (x0)
+		: "r" (x1), "r" (x2), "r" (x3));
+
+	return function_id;
+}
+
+unsigned long aml_sec_boot_check(unsigned long nType,
+	unsigned long pBuffer,
+	unsigned long nLength,
+	unsigned long nOption)
+{
+	uint64_t ret = 1;
+
+//#define AML_SECURE_LOG_TE
+
+#if defined(AML_SECURE_LOG_TE)
+	#define AML_GET_TE(a) do{a = *((volatile unsigned int*)0xc1109988);}while(0);
+	unsigned nT1,nT2,nT3;
+#else
+	#define AML_GET_TE(...)
+#endif
+
+	AML_GET_TE(nT1);
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = AML_DATA_PROCESS;
+	register uint64_t x1 asm("x1") = nType;
+	register uint64_t x2 asm("x2") = pBuffer;
+	register uint64_t x3 asm("x3") = nLength;
+	register uint64_t x4 asm("x4") = nOption;
+
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    __asmeq("%4", "x3")
+		    __asmeq("%5", "x4")
+		    "smc #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2),"r"(x3),"r"(x4));
+	} while (0);
+
+	ret = x0;
+
+	AML_GET_TE(nT2);;
+
+	flush_dcache_range((unsigned long )pBuffer, (unsigned long )pBuffer+nLength);
+
+	AML_GET_TE(nT3);
+
+#if defined(AML_SECURE_LOG_TE)
+	printf("aml log : dec use %d(us) , flush cache used %d(us)\n",
+		nT2 - nT1, nT3 - nT2);
+#endif
+
+	return ret;
+
+}
+
+void set_usb_boot_function(unsigned long command)
+{
+	register long x0 asm("x0") = SET_USB_BOOT_FUNC;
+	register long x1 asm("x1") = command;
+
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			"smc	#0\n"
+		: "+r" (x0)
+		: "r" (x1));
+}
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/gxb/clock.c b/arch/arm/cpu/armv8/gxb/clock.c
new file mode 100644
index 0000000..0dfebb4
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/clock.c
@@ -0,0 +1,163 @@
+
+/*
+ * arch/arm/cpu/armv8/gxb/clock.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+//#include <asm/arch/io.h>
+#include <asm/arch/register.h>
+#include <asm/arch/clock.h>
+
+/*  !!must use nonzero value as default value. Otherwise it linked to bss segment,
+    but this segment not cleared to zero while running "board_init_f" */
+#define CLK_UNKNOWN (0xffffffff)
+
+__u32 get_rate_xtal(void)
+{
+	unsigned long clk;
+	clk = (readl(P_PREG_CTLREG0_ADDR) >> 4) & 0x3f;
+	clk = clk * 1000 * 1000;
+	return clk;
+}
+
+
+__u32 get_cpu_clk(void)
+{
+    static __u32 sys_freq=CLK_UNKNOWN;
+    if (sys_freq == CLK_UNKNOWN)
+    {
+        sys_freq=(clk_util_clk_msr(SYS_PLL_CLK)*1000000);
+    }
+    return sys_freq;
+}
+__u32 get_clk81(void)
+{
+	static __u32 clk81_freq=CLK_UNKNOWN;
+	if (clk81_freq == CLK_UNKNOWN)
+	{
+	    clk81_freq=(clk_util_clk_msr(CLK81)*1000000);
+	}
+    return clk81_freq;
+}
+__u32 get_clk_ddr(void)
+{
+   static __u32 freq=CLK_UNKNOWN;
+	if (freq == CLK_UNKNOWN)
+	{
+	    freq=(clk_util_clk_msr(DDR_PLL_CLK)*1000000);
+	}
+    return freq;
+}
+
+__u32 get_clk_ethernet_pad(void)
+{
+    static __u32 freq=CLK_UNKNOWN;
+    if (freq == CLK_UNKNOWN)
+    {
+        freq=(clk_util_clk_msr(MOD_ETH_CLK50_I)*1000000);
+    }
+    return freq;
+}
+
+__u32 get_clk_cts_eth_rmii(void)
+{
+    static __u32 freq=CLK_UNKNOWN;
+    if (freq == CLK_UNKNOWN)
+    {
+        freq=(clk_util_clk_msr(CTS_ETH_RMII)*1000000);
+    }
+    return freq;
+}
+
+__u32 get_misc_pll_clk(void)
+{
+    static __u32 freq=CLK_UNKNOWN;
+    if (freq == CLK_UNKNOWN)
+    {
+        freq=(clk_util_clk_msr(MISC_PLL_CLK)*1000000);
+    }
+    return freq;
+}
+
+unsigned long    clk_util_clk_msr( unsigned long   clk_mux )
+{
+
+	writel(0,P_MSR_CLK_REG0);
+    // Set the measurement gate to 64uS
+	clrsetbits_le32(P_MSR_CLK_REG0,0xffff,64-1);
+    // Disable continuous measurement
+    // disable interrupts
+    clrbits_le32(P_MSR_CLK_REG0,((1 << 18) | (1 << 17)));
+	clrsetbits_le32(P_MSR_CLK_REG0,(0xf<<20),(clk_mux<<20)|(1<<19)|(1<<16));
+
+	readl(P_MSR_CLK_REG0);
+    // Wait for the measurement to be done
+    while ( readl(P_MSR_CLK_REG0) & (1 << 31))  {};
+    // disable measuring
+	clrbits_le32(P_MSR_CLK_REG0,(1 << 16));
+	__u32 msr=(readl(P_MSR_CLK_REG2)+31)&0x000FFFFF;
+    // Return value in MHz*measured_val
+    return (msr>>6);
+}
+struct __clk_rate{
+    unsigned clksrc;
+    __u32 (*get_rate)(void);
+};
+struct __clk_rate clkrate[]={
+    {
+        .clksrc=SYS_PLL_CLK,
+        .get_rate=get_cpu_clk,
+    },
+    {
+        .clksrc=CLK81,
+        .get_rate=get_clk81,
+    },
+    {
+        .clksrc=DDR_PLL_CLK,
+        .get_rate=get_clk_ddr,
+    },
+    {
+        .clksrc=MOD_ETH_CLK50_I,
+        .get_rate=get_clk_ethernet_pad,
+    },
+    {
+        .clksrc=CTS_ETH_RMII,
+        .get_rate=get_clk_cts_eth_rmii,
+    },
+    {
+        .clksrc=MISC_PLL_CLK,
+        .get_rate=get_misc_pll_clk,
+    }
+};
+
+int clk_get_rate(unsigned clksrc)
+{
+	int i;
+	for (i = 0; i < sizeof(clkrate)/sizeof(clkrate[0]); i++)
+	{
+		  if (clksrc == clkrate[i].clksrc)
+			return clkrate[i].get_rate();
+   }
+	 return -1;
+}
+
+
+
diff --git a/arch/arm/cpu/armv8/gxb/gate_init.c b/arch/arm/cpu/armv8/gxb/gate_init.c
new file mode 100644
index 0000000..a0c922f
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/gate_init.c
@@ -0,0 +1,356 @@
+#include "power_gate.h"
+
+#define SECUREBOOT_FLAG_ADDR 0xc8100228
+
+#ifdef CONFIG_AML_CVBS
+extern unsigned int cvbs_mode;
+#endif
+void ee_gate_off(void)
+{
+	printf("ee_gate_off ...\n");
+
+/*	int secureboot = readl(SECUREBOOT_FLAG_ADDR)&(1<<5);*/
+
+#ifdef CONFIG_AML_CVBS
+	unsigned int cvbs_opened = 0;
+#endif
+
+#ifdef CONFIG_AML_CVBS
+	if ((cvbs_mode == 0) || (cvbs_mode == 1))
+		cvbs_opened = 1;
+#endif
+
+	/*
+	//if close , audio maybe have noise
+	CLK_GATE_OFF(AUD);
+	CLK_GATE_OFF(AUD2);
+	CLK_GATE_OFF(AUD_CLK_2);
+	CLK_GATE_OFF(AUD_CLK_3);
+	*/
+	CLK_GATE_OFF(AUD_IN);
+	CLK_GATE_OFF(AIU_AUD_MIXER);
+	CLK_GATE_OFF(SANA);
+
+	/*kernel will reopen */
+	CLK_GATE_OFF(CTS_ENCL);
+	/* CLK_GATE_OFF(CTS_ENCT); */
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0)
+		CLK_GATE_OFF(CTS_ENCI);
+#else
+	CLK_GATE_OFF(CTS_ENCI);
+#endif
+	/* CLK_GATE_OFF(CTS_ENCP); */
+
+	/*close cvbs clock*/
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0) {
+		CLK_GATE_OFF(DAC_CLK);
+		CLK_GATE_OFF(CTS_VDAC);
+	}
+#else
+	CLK_GATE_OFF(DAC_CLK);
+	CLK_GATE_OFF(CTS_VDAC);
+#endif
+
+	/* usb clock close */
+	CLK_GATE_OFF(USB0);
+	CLK_GATE_OFF(USB1);
+	CLK_GATE_OFF(USB_CLK);
+	CLK_GATE_OFF(MISC_USB0_TO_DDR);
+	CLK_GATE_OFF(MISC_USB1_TO_DDR);
+
+	/* uarts close */
+	CLK_GATE_OFF(UART0);
+	CLK_GATE_OFF(UART1);
+	CLK_GATE_OFF(UART2);
+	CLK_GATE_OFF(UART3);
+
+	CLK_GATE_OFF(VCLK2_VENCP);
+	CLK_GATE_OFF(VCLK2_VENCT);
+	CLK_GATE_OFF(VCLK2_VENCT1);
+	CLK_GATE_OFF(VCLK2_OTHER);
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0) {
+		CLK_GATE_OFF(VCLK2_VENCI);
+		CLK_GATE_OFF(VCLK2_VENCI1);
+	}
+#else
+	CLK_GATE_OFF(VCLK2_VENCI);
+	CLK_GATE_OFF(VCLK2_VENCI1);
+#endif
+	CLK_GATE_OFF(VCLK2_VENCL);
+	CLK_GATE_OFF(VCLK2_OTHER1);
+
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0)
+		CLK_GATE_OFF(VCLK2_ENCI);
+#else
+	CLK_GATE_OFF(VCLK2_ENCI);
+#endif
+	CLK_GATE_OFF(VCLK2_ENCL);
+	CLK_GATE_OFF(VCLK2_ENCT);
+
+	CLK_GATE_OFF(VDEC_CLK_1);
+	CLK_GATE_OFF(VDEC_CLK_2);
+	CLK_GATE_OFF(VDEC2_CLK_1);
+	CLK_GATE_OFF(VDEC2_CLK_2);
+	CLK_GATE_OFF(HCODEC_CLK_1);
+	CLK_GATE_OFF(HCODEC_CLK_2);
+	/* CLK_GATE_OFF(HEVC_CLK_1 ); */
+	/* CLK_GATE_OFF(HEVC_CLK_2 ); */
+
+	CLK_GATE_OFF(MMC_A_PCLK);
+	CLK_GATE_OFF(MMC_B_PCLK);
+	CLK_GATE_OFF(MMC_C_PCLK);
+
+	CLK_GATE_OFF(LCD_AN_PHY2);
+	CLK_GATE_OFF(LCD_AN_PHY3);
+
+	CLK_GATE_OFF(ETHERNET);
+	CLK_GATE_OFF(ETH_CLK);
+
+	CLK_GATE_OFF(GE2D);
+	CLK_GATE_OFF(GEN_CLK);
+	CLK_GATE_OFF(PCM_MCLK);
+	CLK_GATE_OFF(PCM_SCLK);
+
+
+	CLK_GATE_OFF(HIU_PARSER_TOP);
+
+
+	/* can not off nand_clk */
+	/* CLK_GATE_OFF(NAND_CLK); */
+	/*
+	//HDMI no output
+	CLK_GATE_OFF(VCLK2_VENCP1);
+	CLK_GATE_OFF(VCLK2_ENCP);
+	*/
+
+	/*
+	//if OFF, HDMI will report error!
+	CLK_GATE_OFF(HDMI_PCLK);
+	CLK_GATE_OFF(HDMI_PLL_CNTL);
+	CLK_GATE_OFF(HDMITX_CLK);
+	*/
+
+	/*
+	//PWM B used for VCCK,PWM D used for VDDEE,ignoring
+	CLK_GATE_OFF(PWM_A_CLK);
+	CLK_GATE_OFF(PWM_B_CLK);
+	CLK_GATE_OFF(PWM_C_CLK);
+	CLK_GATE_OFF(PWM_D_CLK);
+	CLK_GATE_OFF(PWM_E_CLK);
+	CLK_GATE_OFF(PWM_F_CLK);
+	*/
+
+
+	/*  can not close
+	    CLK_GATE_OFF(VPU_CLK_1);
+	    CLK_GATE_OFF(VPU_CLK_2);
+	    CLK_GATE_OFF(VPU_CLKB);
+	    CLK_GATE_OFF(MALI_CLK_1);
+	    CLK_GATE_OFF(MALI_CLK_2);
+	    CLK_GATE_OFF(ATV_DEMO_VDAC);
+	    CLK_GATE_OFF(EMMC_A);
+	    CLK_GATE_OFF(EMMC_B);
+	    CLK_GATE_OFF(EMMC_C);
+	    CLK_GATE_OFF(EMMC_A_CLK);
+	    CLK_GATE_OFF(EMMC_B_CLK);
+
+	    CLK_GATE_OFF(MSR_CLK);
+	    CLK_GATE_OFF(MSR_HS_CLK);
+	    CLK_GATE_OFF(32K_CLK);
+	    CLK_GATE_OFF(VAPB_CLK_1);
+	    CLK_GATE_OFF(VAPB_CLK_2);
+	    CLK_GATE_OFF(GIC);
+	    CLK_GATE_OFF(I2C_AO); //no close for to use
+	    CLK_GATE_OFF(AO_CPU);
+	    CLK_GATE_OFF(ASSIST_MISC);
+	    CLK_GATE_OFF(HIU_PARSER);
+	    CLK_GATE_OFF(PERIPHS_TOP);
+	    CLK_GATE_OFF(PL310_CBUS);
+	    CLK_GATE_OFF(ISA);
+	    CLK_GATE_OFF(SECURE_AHP_APB3);
+	    CLK_GATE_OFF(VPU_INTR);
+	    CLK_GATE_OFF(MMC_PCLK); //can not close
+	    CLK_GATE_OFF(AIU_PCLK);
+	//can not connect pc
+	CLK_GATE_OFF(USB_GENERAL);
+	CLK_GATE_OFF(AHB_DATA_BUS);
+	CLK_GATE_OFF(AHB_CONTROL_BUS);
+	CLK_GATE_OFF(HDMI_INTR_SYNC); //should open
+	//can't suspend @ 2nd time
+	//CLK_GATE_OFF(RESET);
+
+	// close rom
+	//disable this bit will make other cpu can not be booted.
+	//CLK_GATE_OFF(ROM_CLK);
+
+*/
+	/*************************/
+	CLK_GATE_OFF(AHB_ARB0);
+	CLK_GATE_OFF(ASYNC_FIFO);
+	CLK_GATE_OFF(STREAM);
+	CLK_GATE_OFF(RANDOM_NUM_GEN);
+	CLK_GATE_OFF(RANDOM_NUM_GEN1);
+	CLK_GATE_OFF(SMART_CARD_MPEG_DOMAIN);
+	CLK_GATE_OFF(I2C);
+	CLK_GATE_OFF(SPI);
+	CLK_GATE_OFF(SPICC);
+	CLK_GATE_OFF(DOS);
+	CLK_GATE_OFF(SAR_ADC);
+	CLK_GATE_OFF(MISC_DVIN);
+	CLK_GATE_OFF(BT656);
+	CLK_GATE_OFF(BT656_2);
+	CLK_GATE_OFF(PDM);
+
+	/* close AIU */
+	CLK_GATE_OFF(AIU_IEC958);
+	CLK_GATE_OFF(AIU_ICE958_AMCLK);
+
+	CLK_GATE_OFF(AIU_AMCLK_MEASURE);
+	CLK_GATE_OFF(AIU_AIFIFO2);
+	CLK_GATE_OFF(AIU_MIXER_REG);
+	CLK_GATE_OFF(AIU_ADC);
+	CLK_GATE_OFF(AIU_TOP_LEVEL);
+	CLK_GATE_OFF(AIU_AOCLK);
+	CLK_GATE_OFF(AIU_AI_TOP_GLUE);
+	CLK_GATE_OFF(AIU_I2S_OUT);
+
+	CLK_GATE_OFF(ENC480P);
+
+	CLK_GATE_OFF(DEMUX);
+/*
+*	EFUSE/BLK_MOV clock gate must be on,
+	kernel storage ops depend on them.
+	it can be reference PD#112732
+*/
+/*
+	if (secureboot) {
+		printf("secure boot ignore [ BLK_MOV, efuse ] clk gate\n");
+	} else {
+		CLK_GATE_OFF(EFUSE);
+		CLK_GATE_OFF(BLK_MOV);
+	}
+*/
+}
+
+void ee_gate_on(void)
+{
+
+	printf("ee_gate_on ...\n");
+
+	/*
+	//if close , audio maybe have noise
+	CLK_GATE_ON(AUD);
+	CLK_GATE_ON(AUD2);
+	CLK_GATE_ON(AUD_CLK_2);
+	CLK_GATE_ON(AUD_CLK_3);
+	*/
+	CLK_GATE_ON(AUD_IN);
+	CLK_GATE_ON(AIU_AUD_MIXER);
+	CLK_GATE_ON(SANA);
+
+	/*kernel will reopen */
+	CLK_GATE_ON(CTS_ENCL);
+	/* CLK_GATE_ON(CTS_ENCT); */
+	CLK_GATE_ON(CTS_ENCI);
+	/* CLK_GATE_ON(CTS_ENCP); */
+
+	/*close cvbs clock*/
+	CLK_GATE_ON(DAC_CLK);
+	CLK_GATE_ON(CTS_VDAC);
+
+	/* usb clock close */
+	CLK_GATE_ON(USB0);
+	CLK_GATE_ON(USB1);
+	CLK_GATE_ON(USB_CLK);
+	CLK_GATE_ON(MISC_USB0_TO_DDR);
+	CLK_GATE_ON(MISC_USB1_TO_DDR);
+
+	/* uarts close */
+	CLK_GATE_ON(UART0);
+	CLK_GATE_ON(UART1);
+	CLK_GATE_ON(UART2);
+	CLK_GATE_ON(UART3);
+
+	CLK_GATE_ON(VCLK2_VENCP);
+	CLK_GATE_ON(VCLK2_VENCT);
+	CLK_GATE_ON(VCLK2_VENCT1);
+	CLK_GATE_ON(VCLK2_OTHER);
+	CLK_GATE_ON(VCLK2_VENCI);
+	CLK_GATE_ON(VCLK2_VENCI1);
+	CLK_GATE_ON(VCLK2_VENCL);
+	CLK_GATE_ON(VCLK2_OTHER1);
+
+
+	CLK_GATE_ON(VCLK2_ENCI);
+	CLK_GATE_ON(VCLK2_ENCL);
+	CLK_GATE_ON(VCLK2_ENCT);
+
+	CLK_GATE_ON(VDEC_CLK_1);
+	CLK_GATE_ON(VDEC_CLK_2);
+	CLK_GATE_ON(VDEC2_CLK_1);
+	CLK_GATE_ON(VDEC2_CLK_2);
+	CLK_GATE_ON(HCODEC_CLK_1);
+	CLK_GATE_ON(HCODEC_CLK_2);
+	/* CLK_GATE_ON(HEVC_CLK_1 ); */
+	/* CLK_GATE_ON(HEVC_CLK_2 ); */
+
+	CLK_GATE_ON(MMC_A_PCLK);
+	CLK_GATE_ON(MMC_B_PCLK);
+	CLK_GATE_ON(MMC_C_PCLK);
+
+	CLK_GATE_ON(LCD_AN_PHY2);
+	CLK_GATE_ON(LCD_AN_PHY3);
+
+	CLK_GATE_ON(ETHERNET);
+	CLK_GATE_ON(ETH_CLK);
+
+	CLK_GATE_ON(GE2D);
+	CLK_GATE_ON(GEN_CLK);
+	CLK_GATE_ON(PCM_MCLK);
+	CLK_GATE_ON(PCM_SCLK);
+
+
+	CLK_GATE_ON(HIU_PARSER_TOP);
+
+	/*************************/
+	CLK_GATE_ON(AHB_ARB0);
+	CLK_GATE_ON(ASYNC_FIFO);
+	CLK_GATE_ON(STREAM);
+	CLK_GATE_ON(RANDOM_NUM_GEN);
+	CLK_GATE_ON(RANDOM_NUM_GEN1);
+	CLK_GATE_ON(SMART_CARD_MPEG_DOMAIN);
+	CLK_GATE_ON(I2C);
+	CLK_GATE_ON(SPI);
+	CLK_GATE_ON(SPICC);
+	CLK_GATE_ON(DOS);
+	CLK_GATE_ON(SAR_ADC);
+	CLK_GATE_ON(MISC_DVIN);
+	CLK_GATE_ON(BT656);
+	CLK_GATE_ON(BT656_2);
+	CLK_GATE_ON(PDM);
+
+	/* close AIU */
+	CLK_GATE_ON(AIU_IEC958);
+	CLK_GATE_ON(AIU_ICE958_AMCLK);
+
+	CLK_GATE_ON(AIU_AMCLK_MEASURE);
+	CLK_GATE_ON(AIU_AIFIFO2);
+	CLK_GATE_ON(AIU_MIXER_REG);
+	CLK_GATE_ON(AIU_ADC);
+	CLK_GATE_ON(AIU_TOP_LEVEL);
+	CLK_GATE_ON(AIU_AOCLK);
+	CLK_GATE_ON(AIU_AI_TOP_GLUE);
+	CLK_GATE_ON(AIU_I2S_OUT);
+
+	CLK_GATE_ON(ENC480P);
+
+	CLK_GATE_ON(DEMUX);
+
+	CLK_GATE_ON(EFUSE);
+	CLK_GATE_ON(BLK_MOV);
+}
+
diff --git a/arch/arm/cpu/armv8/gxb/gpio.c b/arch/arm/cpu/armv8/gxb/gpio.c
new file mode 100644
index 0000000..28b0fde
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/gpio.c
@@ -0,0 +1,258 @@
+
+/*
+ * arch/arm/cpu/armv8/gxb/gpio.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <dm.h>
+#include <linux/compiler.h>
+#include <aml_gpio.h>
+#include <asm/arch/gpio.h>
+
+#define NE 0xffffffff
+#define PK(reg, bit) ((reg<<5)|bit)
+/*AO REG */
+#define AO 0x10
+#define AO2 0x11
+
+static unsigned int gpio_to_pin[][6] = {
+	[PIN_GPIOX_0] = {PK(8, 5), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_1] = {PK(8, 4), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_2] = {PK(8, 3), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_3] = {PK(8, 2), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_4] = {PK(8, 1), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_5] = {PK(8, 0), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_6] = {PK(3, 9), PK(3, 17), NE, NE, NE, NE,},
+	[PIN_GPIOX_7] = {PK(8, 11), PK(3, 8), PK(3, 18), NE, NE, NE,},
+	[PIN_GPIOX_8] = {PK(3, 10), PK(4, 7), PK(3, 30), NE, NE, NE,},
+	[PIN_GPIOX_9] = {PK(3, 7), PK(4, 6), PK(3, 29), NE, NE, NE,},
+	[PIN_GPIOX_10] = {PK(3, 13), PK(3, 28), NE, NE, NE, NE,},
+	[PIN_GPIOX_11] = {PK(3, 12), PK(3, 27), NE, NE, NE, NE,},
+	[PIN_GPIOX_12] = {PK(4, 13), PK(4, 17), PK(3, 12), NE, NE, NE,},
+	[PIN_GPIOX_13] = {PK(4, 12), PK(4, 16), PK(3, 12), NE, NE, NE,},
+	[PIN_GPIOX_14] = {PK(4, 11), PK(4, 15), PK(3, 12), NE, NE, NE,},
+	[PIN_GPIOX_15] = {PK(4, 10), PK(4, 14), PK(3, 12), NE, NE, NE,},
+	[PIN_GPIOX_16] = {PK(2, 25), PK(3, 12), PK(4, 2), NE, NE, NE,},
+	[PIN_GPIOX_17] = {PK(2, 24), PK(3, 12), PK(4, 3), NE, NE, NE,},
+	[PIN_GPIOX_18] = {PK(2, 23), PK(3, 16), PK(2, 31), NE, NE, NE,},
+	[PIN_GPIOX_19] = {PK(2, 22), PK(3, 15), PK(2, 30), NE, NE, NE,},
+	[PIN_GPIOX_20] = {PK(3, 14), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_21] = {PK(3, 24), NE, NE, NE, NE, NE,},
+	[PIN_GPIOX_22] = {PK(3, 6), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_0] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_1] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_2] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_3] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_4] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_5] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_6] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_7] = {PK(4, 30), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_8] = {PK(4, 26), PK(4, 18), NE, NE, NE, NE,},
+	[PIN_BOOT_9] = {PK(4, 27), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_10] = {PK(4, 25), PK(4, 19), NE, NE, NE, NE,},
+	[PIN_BOOT_11] = {PK(4, 24), PK(5, 1), NE, NE, NE, NE,},
+	[PIN_BOOT_12] = {PK(4, 23), PK(5, 3), NE, NE, NE, NE,},
+	[PIN_BOOT_13] = {PK(4, 22), PK(5, 2), NE, NE, NE, NE,},
+	[PIN_BOOT_14] = {PK(4, 21), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_15] = {PK(4, 20), PK(4, 31), PK(5, 0), NE, NE, NE,},
+	[PIN_BOOT_16] = {PK(4, 28), NE, NE, NE, NE, NE,},
+	[PIN_BOOT_17] = {PK(4, 29), NE, NE, NE, NE, NE,},
+	[PIN_GPIOH_0] = {PK(1, 26), NE, NE, NE, NE, NE,},
+	[PIN_GPIOH_1] = {PK(1, 25), NE, NE, NE, NE, NE,},
+	[PIN_GPIOH_2] = {PK(1, 24), NE, NE, NE, NE, NE,},
+	[PIN_GPIOH_3] = {NE, NE, NE, NE, NE, NE,},
+	[PIN_GPIOZ_0] = {PK(6, 0), PK(5, 5), NE, NE, NE, NE,},
+	[PIN_GPIOZ_1] = {PK(6, 1), PK(5, 6), NE, NE, NE, NE,},
+	[PIN_GPIOZ_2] = {PK(6, 13), NE, NE, NE, NE, NE,},
+	[PIN_GPIOZ_3] = {PK(6, 12), PK(5, 7), NE, NE, NE, NE,},
+	[PIN_GPIOZ_4] = {PK(6, 11), PK(5, 4), NE, NE, NE, NE,},
+	[PIN_GPIOZ_5] = {PK(6, 10), PK(5, 4), NE, NE, NE, NE,},
+	[PIN_GPIOZ_6] = {PK(6, 9), PK(5, 4), PK(5, 27), PK(4, 9), NE, NE,},
+	[PIN_GPIOZ_7] = {PK(6, 8), PK(5, 4), PK(5, 26), PK(4, 8), NE, NE,},
+	[PIN_GPIOZ_8] = {PK(6, 7), PK(5, 4), NE, NE, NE, NE,},
+	[PIN_GPIOZ_9] = {PK(6, 6), PK(5, 4), NE, NE, NE, NE,},
+	[PIN_GPIOZ_10] = {PK(6, 5), PK(5, 4), NE, NE, NE, NE,},
+	[PIN_GPIOZ_11] = {PK(6, 4), PK(5, 4), NE, NE, NE, NE,},
+	[PIN_GPIOZ_12] = {PK(6, 3), PK(5, 28), NE, NE, NE, NE,},
+	[PIN_GPIOZ_13] = {PK(6, 2), PK(5, 29), NE, NE, NE, NE,},
+	[PIN_GPIOZ_14] = {NE, NE, NE, NE, NE, NE,},
+	[PIN_GPIOZ_15] = {PK(6, 15), NE, NE, NE, NE, NE,},
+	[PIN_GPIODV_0] = {PK(0, 0), PK(0, 8), PK(5, 15), PK(7, 0),
+		PK(0, 18), NE,},
+	[PIN_GPIODV_1] = {PK(0, 0), PK(0, 8), PK(7, 1), PK(2, 0),
+		PK(0, 18), NE,},
+	[PIN_GPIODV_2] = {PK(0, 1), PK(0, 8), PK(7, 2), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_3] = {PK(0, 1), PK(0, 8), PK(7, 3), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_4] = {PK(0, 1), PK(0, 8), PK(7, 4), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_5] = {PK(0, 1), PK(0, 8), PK(7, 5), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_6] = {PK(0, 1), PK(0, 8), PK(7, 6), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_7] = {PK(0, 1), PK(0, 8), PK(7, 7), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_8] = {PK(0, 2), PK(0, 8), PK(5, 14), PK(7, 8),
+		PK(0, 18), NE,},
+	[PIN_GPIODV_9] = {PK(0, 2), PK(0, 8), PK(3, 19), PK(7, 9),
+		PK(0, 18), NE,},
+	[PIN_GPIODV_10] = {PK(0, 3), PK(0, 8), PK(7, 10), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_11] = {PK(0, 3), PK(0, 8), PK(7, 11), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_12] = {PK(0, 3), PK(0, 8), PK(7, 12), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_13] = {PK(0, 3), PK(0, 8), PK(7, 13), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_14] = {PK(0, 3), PK(0, 8), PK(7, 14), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_15] = {PK(0, 3), PK(0, 8), PK(7, 15), PK(0, 18), NE, NE,},
+	[PIN_GPIODV_16] = {PK(0, 4), PK(0, 8), PK(5, 13), PK(2, 1),
+		PK(0, 17), NE,},
+	[PIN_GPIODV_17] = {PK(0, 4), PK(0, 8), PK(2, 2), PK(0, 16), NE, NE,},
+	[PIN_GPIODV_18] = {PK(0, 5), PK(0, 8), PK(2, 5), NE, NE, NE,},
+	[PIN_GPIODV_19] = {PK(0, 5), PK(0, 8), PK(2, 4), NE, NE, NE,},
+	[PIN_GPIODV_20] = {PK(0, 5), PK(0, 8), PK(2, 3), NE, NE, NE,},
+	[PIN_GPIODV_21] = {PK(0, 5), PK(0, 8), PK(2, 6), NE, NE, NE,},
+	[PIN_GPIODV_22] = {PK(0, 5), PK(0, 8), PK(2, 7), NE, NE, NE,},
+	[PIN_GPIODV_23] = {PK(0, 5), PK(0, 8), PK(2, 8), NE, NE, NE,},
+	[PIN_GPIODV_24] = {PK(0, 7), PK(0, 12), PK(5, 12), PK(7, 26),
+		PK(2, 29), NE,},
+	[PIN_GPIODV_25] = {PK(0, 6), PK(0, 11), PK(5, 11), PK(7, 27),
+		PK(2, 28), NE,},
+	[PIN_GPIODV_26] = {PK(0, 10), PK(5, 10), PK(7, 24), PK(2, 27), NE, NE,},
+	[PIN_GPIODV_27] = {PK(0, 9), PK(5, 9), PK(5, 8), PK(7, 25),
+		PK(2, 26), NE,},
+	[PIN_GPIODV_28] = {PK(3, 20), PK(7, 22), NE, NE, NE, NE,},
+	[PIN_GPIODV_29] = {PK(3, 22), PK(3, 21), PK(7, 23), NE, NE, NE,},
+	[GPIOAO_0] = {PK(AO, 12), PK(AO, 26), NE, NE, NE, NE,},
+	[GPIOAO_1] = {PK(AO, 11), PK(AO, 25), NE, NE, NE, NE,},
+	[GPIOAO_2] = {PK(AO, 10), PK(AO, 8), NE, NE, NE, NE,},
+	[GPIOAO_3] = {PK(AO, 9), PK(AO, 7), PK(AO, 22), NE, NE, NE,},
+	[GPIOAO_4] = {PK(AO, 24), PK(AO, 6), PK(AO, 2), NE, NE, NE,},
+	[GPIOAO_5] = {PK(AO, 25), PK(AO, 5), PK(AO, 1), NE, NE, NE,},
+	[GPIOAO_6] = {PK(AO, 18), PK(AO, 16), NE, NE, NE, NE,},
+	[GPIOAO_7] = {PK(AO, 0), PK(AO, 21), NE, NE, NE, NE,},
+	[GPIOAO_8] = {PK(AO, 30), NE, NE, NE, NE, NE,},
+	[GPIOAO_9] = {PK(AO, 29), NE, NE, NE, NE, NE,},
+	[GPIOAO_10] = {PK(AO, 28), NE, NE, NE, NE, NE,},
+	[GPIOAO_11] = {PK(AO, 27), PK(AO, 15), PK(AO, 14), PK(AO, 17),
+		PK(AO2, 0), NE,},
+	[GPIOAO_13] = {PK(AO, 31), PK(AO, 3), PK(AO, 4), PK(AO2, 1),
+		PK(AO, 19), PK(AO2, 2),},
+	[PIN_CARD_0] = {PK(2, 14), NE, NE, NE, NE, NE,},
+	[PIN_CARD_1] = {PK(2, 15), NE, NE, NE, NE, NE,},
+	[PIN_CARD_2] = {PK(2, 11), NE, NE, NE, NE, NE,},
+	[PIN_CARD_3] = {PK(2, 10), NE, NE, NE, NE, NE,},
+	[PIN_CARD_4] = {PK(2, 12), PK(8, 10), PK(8, 18), NE, NE, NE,},
+	[PIN_CARD_5] = {PK(2, 13), PK(8, 17), PK(8, 9), NE, NE, NE,},
+	[PIN_CARD_6] = {NE, NE, NE, NE, NE, NE,},
+	[PIN_GPIOY_0] = {PK(2, 19), PK(3, 2), PK(1, 0), NE, NE, NE,},
+	[PIN_GPIOY_1] = {PK(2, 18), PK(3, 1), PK(1, 1), NE, NE, NE,},
+	[PIN_GPIOY_2] = {PK(2, 17), PK(3, 0), NE, NE, NE, NE,},
+	[PIN_GPIOY_3] = {PK(2, 16), PK(3, 4), PK(1, 2), NE, NE, NE,},
+	[PIN_GPIOY_4] = {PK(2, 16), PK(3, 5), PK(1, 12), NE, NE, NE,},
+	[PIN_GPIOY_5] = {PK(2, 16), PK(3, 5), PK(1, 13), NE, NE, NE,},
+	[PIN_GPIOY_6] = {PK(2, 16), PK(3, 5), PK(1, 3), NE, NE, NE,},
+	[PIN_GPIOY_7] = {PK(2, 16), PK(3, 5), PK(1, 4), NE, NE, NE,},
+	[PIN_GPIOY_8] = {PK(2, 16), PK(3, 5), PK(1, 5), NE, NE, NE,},
+	[PIN_GPIOY_9] = {PK(2, 16), PK(3, 5), PK(1, 6), NE, NE, NE,},
+	[PIN_GPIOY_10] = {PK(2, 16), PK(3, 5), PK(1, 7), NE, NE, NE,},
+	[PIN_GPIOY_11] = {PK(3, 3), PK(1, 19), PK(1, 8), NE, NE, NE,},
+	[PIN_GPIOY_12] = {PK(1, 18), PK(1, 9), NE, NE, NE, NE,},
+	[PIN_GPIOY_13] = {PK(1, 17), PK(1, 10), NE, NE, NE, NE,},
+	[PIN_GPIOY_14] = {PK(1, 16), PK(1, 11), NE, NE, NE, NE,},
+	[PIN_GPIOY_15] = {PK(2, 20), PK(1, 20), PK(1, 22), NE, NE, NE,},
+	[PIN_GPIOY_16] = {PK(2, 21), PK(1, 21), NE, NE, NE, NE,},
+	[PIN_GPIO_TEST_N] = {PK(AO, 19), PK(AO2, 2), NE, NE, NE, NE,},
+};
+
+#define BANK(n, f, l, per, peb, pr, pb, dr, db, or, ob, ir, ib)		\
+	{								\
+		.name	= n,						\
+		.first	= f,						\
+		.last	= l,						\
+		.regs	= {						\
+			[REG_PULLEN]	= { (0xc8834120 + (per<<2)), peb },			\
+			[REG_PULL]	= { (0xc88344e8 + (pr<<2)), pb },			\
+			[REG_DIR]	= { (0xc8834430 + (dr<<2)), db },			\
+			[REG_OUT]	= { (0xc8834430 + (or<<2)), ob },			\
+			[REG_IN]	= { (0xc8834430 + (ir<<2)), ib },			\
+		},							\
+	 }
+#define AOBANK(n, f, l, per, peb, pr, pb, dr, db, or, ob, ir, ib)		\
+	{								\
+		.name	= n,						\
+		.first	= f,						\
+		.last	= l,						\
+		.regs	= {						\
+			[REG_PULLEN]	= { (0xc810002c + (per<<2)), peb },			\
+			[REG_PULL]	= { (0xc810002c + (pr<<2)), pb },			\
+			[REG_DIR]	= { (0xc8100024 + (dr<<2)), db },			\
+			[REG_OUT]	= { (0xc8100024 + (or<<2)), ob },			\
+			[REG_IN]	= { (0xc8100024 + (ir<<2)), ib },			\
+		},							\
+	 }
+
+static struct meson_bank mesongxbb_banks[] = {
+	/*   name    first         last
+	 *   pullen  pull     dir     out     in  */
+	BANK("GPIOX_",    PIN_GPIOX_0,  PIN_GPIOX_22,
+	     4,  0,  4,  0,  12,  0,  13,  0,  14,  0),
+	BANK("GPIOY_",    PIN_GPIOY_0,  PIN_GPIOY_16,
+	     1,  0,  1,  0,  3,  0,  4,  0,  5,  0),
+	BANK("GPIODV_",  PIN_GPIODV_0, PIN_GPIODV_29,
+	     0,  0,  0,  0,  0,  0,  1,  0,  2,  0),
+	BANK("GPIOH_",    PIN_GPIOH_0,  PIN_GPIOH_3,
+	    1, 20,  1, 20,  3, 20, 4, 20, 5, 20),
+	BANK("GPIOZ_",    PIN_GPIOZ_0,  PIN_GPIOZ_15,
+	     3,  0,  3,  0,  9, 0,  10, 0,  11, 0),
+	BANK("CARD_", PIN_CARD_0,   PIN_CARD_6,
+	     2, 20,  2, 20,  6, 20,  7, 20,  8, 20),
+	BANK("BOOT_", PIN_BOOT_0,   PIN_BOOT_17,
+	     2,  0,  2,  0,  6,  0, 7,  0, 8,  0),
+	BANK("GPIOCLK_", PIN_GPIOCLK_0,   PIN_GPIOCLK_3,
+	     3,  28,  3,  28,  9,  28, 10,  28, 11,  28),
+	AOBANK("GPIOAO_",   GPIOAO_0, GPIOAO_13,
+	     0,  0,  0, 16,  0,  0,  0, 16,  1,  0),
+};
+
+U_BOOT_DEVICES(gxbb_gpios) = {
+	{ "gpio_aml", &mesongxbb_banks[0] },
+	{ "gpio_aml", &mesongxbb_banks[1] },
+	{ "gpio_aml", &mesongxbb_banks[2] },
+	{ "gpio_aml", &mesongxbb_banks[3] },
+	{ "gpio_aml", &mesongxbb_banks[4] },
+	{ "gpio_aml", &mesongxbb_banks[5] },
+	{ "gpio_aml", &mesongxbb_banks[6] },
+	{ "gpio_aml", &mesongxbb_banks[7] },
+	{ "gpio_aml", &mesongxbb_banks[8] },
+};
+static unsigned long domain[]={
+	[0] = 0xc88344b0,
+	[1] = 0xc8100014,
+};
+int  clear_pinmux(unsigned int pin)
+{
+	unsigned int *gpio_reg =  &gpio_to_pin[pin][0];
+	int i, dom, reg, bit;
+	for (i = 0;
+	     i < sizeof(gpio_to_pin[pin])/sizeof(gpio_to_pin[pin][0]); i++) {
+		if (gpio_reg[i] != NE) {
+			reg = GPIO_REG(gpio_reg[i])&0xf;
+			bit = GPIO_BIT(gpio_reg[i]);
+			dom = GPIO_REG(gpio_reg[i])>>4;
+			regmap_update_bits(domain[dom]+reg*4,BIT(bit),0);
+		}
+	}
+	return 0;
+
+}
+
+
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/Makefile b/arch/arm/cpu/armv8/gxb/hdmitx20/Makefile
new file mode 100644
index 0000000..1ee4930
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/Makefile
@@ -0,0 +1,11 @@
+#
+# (C) Copyright 2015
+#
+
+#EXTRA_CFLAGS = -Idrivers/video/include/
+
+obj-$(CONFIG_AML_HDMITX20) += hdmitx20.o
+
+hdmitx20-y := reg_ops.o hdmitx_set.o hdmitx_tvenc.o enc_clk_config.o
+#aml_hdmitx20-$(CONFIG_AML_HDMITX20_HDCP) += hdmitx_hdcp.o
+
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/enc_clk_config.c b/arch/arm/cpu/armv8/gxb/hdmitx20/enc_clk_config.c
new file mode 100644
index 0000000..1c06586
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/enc_clk_config.c
@@ -0,0 +1,351 @@
+#include <common.h>
+#include <amlogic/enc_clk_config.h>
+#include <asm/arch/io.h>
+#include <asm/io.h>
+#include "hw_enc_clk_config.h"
+#include "mach_reg.h"
+#include <amlogic/hdmi.h>
+
+#define msleep(i) udelay(i*1000)
+
+#define check_clk_config(para)\
+	if (para == -1)\
+		return;
+
+#define check_div() \
+	if (div == -1)\
+		return ;\
+	switch (div) {\
+	case 1:\
+		div = 0; break;\
+	case 2:\
+		div = 1; break;\
+	case 4:\
+		div = 2; break;\
+	case 6:\
+		div = 3; break;\
+	case 12:\
+		div = 4; break;\
+	default:\
+		break;\
+	}
+
+#define WAIT_FOR_PLL_LOCKED(reg)                        \
+	do {                                                \
+		unsigned int cnt = 10;                          \
+		unsigned int time_out = 0;                      \
+		while (cnt --) {                                 \
+		time_out = 0;                               \
+		while ((!(hd_read_reg(reg) & (1 << 31)))\
+			& (time_out < 10000))               \
+			time_out ++;                            \
+		}                                               \
+		if (cnt < 9)                                     \
+			printk("pll[0x%x] reset %d times\n", reg, 9 - cnt);\
+	} while(0);
+
+// viu_channel_sel: 1 or 2
+// viu_type_sel: 0: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT.
+int set_viu_path(unsigned viu_channel_sel, enum viu_type viu_type_sel)
+{
+	if ((viu_channel_sel > 2) || (viu_channel_sel == 0))
+		return -1;
+	if (viu_channel_sel == 1)
+		hd_set_reg_bits(P_VPU_VIU_VENC_MUX_CTRL, viu_type_sel, 0, 2);
+	else
+		//viu_channel_sel ==2
+		hd_set_reg_bits(P_VPU_VIU_VENC_MUX_CTRL, viu_type_sel, 2, 2);
+	return 0;
+}
+
+static void set_hdmitx_sys_clk(void)
+{
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 0, 9, 3);
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 0, 0, 7);
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 1, 8, 1);
+}
+
+static void set_hpll_clk_out(unsigned clk)
+{
+	check_clk_config(clk);
+	printk("config HPLL = %d\n", clk);
+	switch (clk) {
+	case 5940:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800027b);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4c00, 0, 16); // div_frac
+		break;
+	case 2970:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800023d);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4e00, 0, 16); // div_frac
+		break;
+    case 4320:
+	hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000259);
+	hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+	hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
+	hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+	hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+	hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+	hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
+	WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+	hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4800025a);
+	printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+        break;
+    case 2448:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 14, 1); // div mode
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0xe00, 0, 12); // div_frac
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486b00);    //5940 0x71c86900      // 0x71486900 2970
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x00000266);
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x5, 28, 3);  //reset hpll
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
+        printk("waiting HPLL lock\n");
+        WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+        break;
+    case 1080:
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5000022d);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00890000);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+        // P_HHI_HDMI_PLL_CNTL5
+        // 0x71c86900 for div2 disable inside PLL2 of HPLL
+        // 0x71486900 for div2s enable inside PLL2 of HPLL
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71c86b00);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000022d);
+        printk("waiting HPLL lock\n");
+        WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+        break;
+    default:
+        printk("error hpll clk: %d\n", clk);
+        break;
+    }
+    printk("config HPLL done\n");
+}
+
+static void set_hpll_od1(unsigned div)
+{
+    switch (div) {
+    case 1:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 16, 2);
+        break;
+    case 2:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 16, 2);
+        break;
+    case 4:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 16, 2);
+        break;
+    case 8:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 16, 2);
+        break;
+    default:
+        break;
+    }
+}
+
+static void set_hpll_od2(unsigned div)
+{
+    switch (div) {
+    case 1:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 22, 2);
+        break;
+    case 2:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 22, 2);
+        break;
+    case 4:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 22, 2);
+        break;
+    case 8:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 22, 2);
+        break;
+    default:
+        break;
+    }
+}
+
+static void set_hpll_od3(unsigned div)
+{
+    switch (div) {
+    case 1:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 18, 2);
+        break;
+    case 2:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 18, 2);
+        break;
+    case 4:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 18, 2);
+        break;
+    case 8:
+        hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 18, 2);
+        break;
+    default:
+        break;
+    }
+}
+
+// --------------------------------------------------
+//              clocks_set_vid_clk_div
+// --------------------------------------------------
+// wire            clk_final_en    = control[19];
+// wire            clk_div1        = control[18];
+// wire    [1:0]   clk_sel         = control[17:16];
+// wire            set_preset      = control[15];
+// wire    [14:0]  shift_preset    = control[14:0];
+static void set_hpll_od3_clk_div(int div_sel)
+{
+    int shift_val = 0;
+    int shift_sel = 0;
+
+    printk("%s[%d] div = %d\n", __func__, __LINE__, div_sel);
+    // Disable the output clock
+    hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+    hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+    switch (div_sel) {
+    case CLK_UTIL_VID_PLL_DIV_1:      shift_val = 0xFFFF; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_2:      shift_val = 0x0aaa; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_3:      shift_val = 0x0db6; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_3p5:    shift_val = 0x36cc; shift_sel = 1; break;
+    case CLK_UTIL_VID_PLL_DIV_3p75:   shift_val = 0x6666; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_4:      shift_val = 0x0ccc; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_5:      shift_val = 0x739c; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_6:      shift_val = 0x0e38; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_6p25:   shift_val = 0x0000; shift_sel = 3; break;
+    case CLK_UTIL_VID_PLL_DIV_7:      shift_val = 0x3c78; shift_sel = 1; break;
+    case CLK_UTIL_VID_PLL_DIV_7p5:    shift_val = 0x78f0; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_12:     shift_val = 0x0fc0; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_14:     shift_val = 0x3f80; shift_sel = 1; break;
+    case CLK_UTIL_VID_PLL_DIV_15:     shift_val = 0x7f80; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_2p5:    shift_val = 0x5294; shift_sel = 2; break;
+    default:
+        printk("Error: clocks_set_vid_clk_div:  Invalid parameter\n");
+        break;
+    }
+
+    if (shift_val == 0xffff ) {      // if divide by 1
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+    } else {
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
+        hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+    }
+    // Enable the final output clock
+    hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+}
+
+static void set_vid_clk_div(unsigned div)
+{
+    check_clk_config(div);
+    if (div == 0)
+        div = 1;
+    hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 0, 16, 3);   // select vid_pll_clk
+    hd_set_reg_bits(P_HHI_VID_CLK_DIV, div-1, 0, 8);
+    hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 7, 0, 3);
+}
+
+static void set_hdmi_tx_pixel_div(unsigned div)
+{
+    check_div();
+    hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, div, 16, 4);
+    hd_set_reg_bits(P_HHI_VID_CLK_CNTL2, 1, 5, 1);   //enable gate
+}
+static void set_encp_div(unsigned div)
+{
+    check_div();
+    hd_set_reg_bits(P_HHI_VID_CLK_DIV, div, 24, 4);
+    hd_set_reg_bits(P_HHI_VID_CLK_CNTL2, 1, 2, 1);   //enable gate
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);
+}
+
+static void set_enci_div(unsigned div)
+{
+    check_div();
+    hd_set_reg_bits(P_HHI_VID_CLK_DIV, div, 28, 4);
+    hd_set_reg_bits(P_HHI_VID_CLK_CNTL2, 1, 0, 1);   //enable gate
+}
+
+// mode viu_path viu_type hpll_clk_out od1 od2 od3
+// vid_pll_div vid_clk_div hdmi_tx_pixel_div encp_div enci_div
+static hw_enc_clk_val_t setting_enc_clk_val[] = {
+    {HDMI_720x480i60_16x9, 1, VIU_ENCI, 4320, 4, 4, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, -1, 2},
+    {HDMI_720x576i50_16x9, 1, VIU_ENCI, 4320, 4, 4, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, -1, 2},
+    {HDMI_720x576p50_16x9, 1, VIU_ENCP, 4320, 4, 4, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+    {HDMI_720x480p60_16x9, 1, VIU_ENCP, 4320, 4, 4, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+    {HDMI_1280x720p50_16x9, 1, VIU_ENCP, 2970, 4, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+    {HDMI_1280x720p60_16x9, 1, VIU_ENCP, 2970, 4, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+    {HDMI_1920x1080i60_16x9, 1, VIU_ENCP, 2970, 4, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+    {HDMI_1920x1080i50_16x9, 1, VIU_ENCP, 2970, 4, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+    {HDMI_1920x1080p60_16x9, 1, VIU_ENCP, 2970, 1, 2, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+    {HDMI_1920x1080p50_16x9, 1, VIU_ENCP, 2970, 1, 2, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+    {HDMI_1920x1080p24_16x9, 1, VIU_ENCP, 2970, 2, 2, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+    {HDMI_3840x2160p30_16x9, 1, VIU_ENCP, 2970, 1, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 2, 1, 1, -1},
+    {HDMI_3840x2160p25_16x9, 1, VIU_ENCP, 2970, 1, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 2, 1, 1, -1},
+    {HDMI_3840x2160p24_16x9, 1, VIU_ENCP, 2970, 1, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 2, 1, 1, -1},
+    {HDMI_4096x2160p24_256x135, 1, VIU_ENCP, 2970, 1, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 2, 1, 1, -1},
+    {HDMI_3840x2160p60_16x9, 1, VIU_ENCP, 5940, 1, 1, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+    {HDMI_3840x2160p50_16x9, 1, VIU_ENCP, 5940, 1, 1, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+};
+
+void set_hdmitx_clk(enum hdmi_vic vic)
+{
+    int i = 0;
+    int j = 0;
+    hw_enc_clk_val_t *p_enc =NULL;
+
+    p_enc=&setting_enc_clk_val[0];
+    i = sizeof(setting_enc_clk_val) / sizeof(hw_enc_clk_val_t);
+
+    for (j = 0; j < i; j++) {
+        if (vic == p_enc[j].vic)
+            break;
+    }
+	if (j == i) {
+		printf("Not find VIC = %d for hpll setting\n", vic);
+		return;
+	}
+    set_viu_path(p_enc[j].viu_path, p_enc[j].viu_type);
+    set_hdmitx_sys_clk();
+    set_hpll_clk_out(p_enc[j].hpll_clk_out);
+    set_hpll_od1(p_enc[j].od1);
+    set_hpll_od2(p_enc[j].od2);
+    set_hpll_od3(p_enc[j].od3);
+    set_hpll_od3_clk_div(p_enc[j].vid_pll_div);
+	printk("j = %d  vid_clk_div = %d\n", j, p_enc[j].vid_clk_div);
+    set_vid_clk_div(p_enc[j].vid_clk_div);
+    set_hdmi_tx_pixel_div(p_enc[j].hdmi_tx_pixel_div);
+    set_encp_div(p_enc[j].encp_div);
+    set_enci_div(p_enc[j].enci_div);
+}
+
+void set_hdmitx_clk_420(void)
+{
+	/* HPLL VCO output 5.94GHz */
+	printf("reset clk for 420 mode\n");
+	hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 16, 2);
+	hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 22, 2);
+	hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 18, 2);
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 1, 1, 1);
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 1, 16, 4);
+}
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_hdcp.c b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_hdcp.c
new file mode 100644
index 0000000..1e56bcb
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_hdcp.c
@@ -0,0 +1,81 @@
+/*
+ * Amlogic MX
+ * frame buffer driver-----------HDMI_TX
+ * Copyright (C) 2010 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/arch/io.h>
+#include <common.h>
+#include "hdmi_tx_reg.h"
+
+// if the following bits are 0, then access HDMI IP Port will cause system hungup
+#define GATE_NUM    2
+
+static struct Hdmi_Gate_s{
+    unsigned short cbus_addr;
+    unsigned char gate_bit;
+}hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
+                            {HHI_GCLK_MPEG2   , 4},
+                            };
+
+// In order to prevent system hangup, add check_cts_hdmi_sys_clk_status() to check
+static void check_cts_hdmi_sys_clk_status(void)
+{
+    int i;
+
+    for (i = 0; i < GATE_NUM; i++) {
+        if (!(READ_CBUS_REG(hdmi_gate[i].cbus_addr) & (1<<hdmi_gate[i].gate_bit))) {
+//            printf("HDMI Gate Clock is off, turn on now\n");
+            WRITE_CBUS_REG_BITS(hdmi_gate[i].cbus_addr, 1, hdmi_gate[i].gate_bit, 1);
+        }
+    }
+}
+
+unsigned long hdmi_hdcp_rd_reg(unsigned long addr)
+{
+    unsigned long data;
+    check_cts_hdmi_sys_clk_status();
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+
+    data = READ_APB_REG(HDMI_DATA_PORT);
+
+    return (data);
+}
+
+void hdmi_hdcp_wr_reg(unsigned long addr, unsigned long data)
+{
+    check_cts_hdmi_sys_clk_status();
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+
+    WRITE_APB_REG(HDMI_DATA_PORT, data);
+}
+
+#define TX_HDCP_KSV_OFFSET          0x540
+#define TX_HDCP_KSV_SIZE            5
+// Must be done by system init
+// In kenrel hdmi driver, it will get AKSV value
+// If equals to 0, then kernel won't enable HDCP
+extern int hdmi_hdcp_clear_ksv_ram(void);
+int hdmi_hdcp_clear_ksv_ram(void)
+{
+    int i;
+    for (i = 0; i < TX_HDCP_KSV_SIZE; i++) {
+        hdmi_hdcp_wr_reg(TX_HDCP_KSV_OFFSET + i, 0x00);
+    }
+    printf("clr h-ram\n");
+    return 0;
+}
+
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_reg.h b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_reg.h
new file mode 100644
index 0000000..075dd9e
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_reg.h
@@ -0,0 +1,1006 @@
+/*
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef _HDMI_TX_REG_H
+#define _HDMI_TX_REG_H
+
+/* Use the following functions to access the on-chip HDMITX modules
+ * by default
+ */
+void hdmitx_wr_reg(unsigned int addr, unsigned int data);
+void hdmitx_poll_reg(unsigned int addr, unsigned int val,
+	unsigned long timeout);
+void hdmitx_set_reg_bits(unsigned int addr, unsigned int value,
+	unsigned int offset, unsigned int len);
+unsigned int hdmitx_rd_reg(unsigned int addr);
+void hdmitx_rd_check_reg (unsigned long addr, unsigned long exp_data,
+	unsigned long mask);
+unsigned long aocec_rd_reg(unsigned long addr);
+void aocec_wr_reg(unsigned long addr, unsigned long data);
+
+/* TOP-level wrapper registers addresses */
+/* bit24: 1 means secure access */
+/* bit28: 1 means DWC, 0 means TOP */
+#define SEC_OFFSET           (0x1UL << 24)
+#define TOP_OFFSET_MASK      (0x0UL << 24)
+#define TOP_SEC_OFFSET_MASK  ((TOP_OFFSET_MASK) | (SEC_OFFSET))
+#define DWC_OFFSET_MASK      (0x10UL << 24)
+#define DWC_SEC_OFFSET_MASK  ((DWC_OFFSET_MASK) | (SEC_OFFSET))
+
+/* Bit 7 RW Reserved. Default 1. */
+/* Bit 6 RW Reserved. Default 1. */
+/* Bit 5 RW Reserved. Default 1. */
+/* Bit 4 RW sw_reset_phyif: PHY interface. 1=Apply reset; 0=Release from reset.
+ *     Default 1. */
+/* Bit 3 RW sw_reset_intr:  interrupt module. 1=Apply reset;
+ *     0=Release from reset. Default 1. */
+/* Bit 2 RW sw_reset_mem:   KSV/REVOC mem. 1=Apply reset; 0=Release from reset.
+ *     Default 1. */
+/* Bit 1 RW sw_reset_rnd:   random number interface to HDCP. 1=Apply reset;
+ *     0=Release from reset. Default 1. */
+/* Bit 0 RW sw_reset_core: connects to IP's ~irstz. 1=Apply reset;
+ *     0=Release from reset. Default 1. */
+#define HDMITX_TOP_SW_RESET                     (TOP_OFFSET_MASK + 0x000)
+
+/* Bit 12 RW i2s_ws_inv:1=Invert i2s_ws; 0=No invert. Default 0. */
+/* Bit 11 RW i2s_clk_inv: 1=Invert i2s_clk; 0=No invert. Default 0. */
+/* Bit 10 RW spdif_clk_inv: 1=Invert spdif_clk; 0=No invert. Default 0. */
+/* Bit 9 RW tmds_clk_inv: 1=Invert tmds_clk; 0=No invert. Default 0. */
+/* Bit 8 RW pixel_clk_inv: 1=Invert pixel_clk; 0=No invert. Default 0. */
+/* Bit 4 RW cec_clk_en: 1=enable cec_clk; 0=disable. Default 0. */
+/* Bit 3 RW i2s_clk_en: 1=enable i2s_clk; 0=disable. Default 0. */
+/* Bit 2 RW spdif_clk_en: 1=enable spdif_clk; 0=disable. Default 0. */
+/* Bit 1 RW tmds_clk_en: 1=enable tmds_clk;  0=disable. Default 0. */
+/* Bit 0 RW pixel_clk_en: 1=enable pixel_clk; 0=disable. Default 0. */
+#define HDMITX_TOP_CLK_CNTL                     (TOP_OFFSET_MASK + 0x001)
+
+/* Bit 11: 0 RW hpd_valid_width: filter out width <= M*1024.    Default 0. */
+/* Bit 15:12 RW hpd_glitch_width: filter out glitch <= N.       Default 0. */
+#define HDMITX_TOP_HPD_FILTER                   (TOP_OFFSET_MASK + 0x002)
+
+/* intr_maskn: MASK_N, one bit per interrupt source.
+ *     1=Enable interrupt source; 0=Disable interrupt source. Default 0.
+ * [  4] hdcp22_rndnum_err
+ * [  3] nonce_rfrsh_rise
+ * [  2] hpd_fall_intr
+ * [  1] hpd_rise_intr
+ * [  0] core_intr
+ */
+#define HDMITX_TOP_INTR_MASKN                   (TOP_OFFSET_MASK + 0x003)
+
+/* Bit 30: 0 RW intr_stat: For each bit, write 1 to manually set the interrupt
+ *     bit, read back the interrupt status. */
+/* Bit    31 R  IP interrupt status */
+/* Bit     2 RW hpd_fall */
+/* Bit     1 RW hpd_rise */
+/* Bit     0 RW IP interrupt */
+#define HDMITX_TOP_INTR_STAT                    (TOP_OFFSET_MASK + 0x004)
+
+/* [4]	  hdcp22_rndnum_err */
+/* [3]	  nonce_rfrsh_rise */
+/* [2]	  hpd_fall */
+/* [1]	  hpd_rise */
+/* [0]	  core_intr_rise */
+#define HDMITX_TOP_INTR_STAT_CLR                (TOP_OFFSET_MASK + 0x005)
+
+/* Bit 14:12 RW tmds_sel: 3'b000=Output zero; 3'b001=Output normal TMDS data;
+ *     3'b010=Output PRBS data; 3'b100=Output shift pattern.         Default 0.
+ * Bit 11: 9 RW shift_pttn_repeat: 0=New pattern every clk cycle; 1=New pattern
+ *     every 2 clk cycles; ...; 7=New pattern every 8 clk cycles.  Default 0.
+ * Bit 8 RW shift_pttn_en: 1= Eanble shift pattern generator; 0=Disable.
+ *     Default 0.
+ * Bit 4: 3 RW prbs_pttn_mode: 0=PRBS11; 1=PRBS15; 2=PRBS7; 3=PRBS31. Default 0.
+ * Bit 2: 1 RW prbs_pttn_width: 0=idle; 1=output 8-bit pattern;
+ *     2=Output 1-bit pattern; 3=output 10-bit pattern. Default 0.
+ * Bit 0 RW prbs_pttn_en: 1=Enable PRBS generator; 0=Disable. Default 0.
+ */
+#define HDMITX_TOP_BIST_CNTL                    (TOP_OFFSET_MASK + 0x006)
+
+/* Bit 29:20 RW shift_pttn_data[59:50]. Default 0. */
+/* Bit 19:10 RW shift_pttn_data[69:60]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[79:70]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_012               (TOP_OFFSET_MASK + 0x007)
+
+/* Bit 29:20 RW shift_pttn_data[29:20]. Default 0. */
+/* Bit 19:10 RW shift_pttn_data[39:30]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[49:40]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_345               (TOP_OFFSET_MASK + 0x008)
+
+/* Bit 19:10 RW shift_pttn_data[ 9: 0]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[19:10]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_67                (TOP_OFFSET_MASK + 0x009)
+
+/* Bit 25:16 RW tmds_clk_pttn[19:10]. Default 0. */
+/* Bit  9: 0 RW tmds_clk_pttn[ 9: 0]. Default 0. */
+#define HDMITX_TOP_TMDS_CLK_PTTN_01             (TOP_OFFSET_MASK + 0x00A)
+
+/* Bit 25:16 RW tmds_clk_pttn[39:30]. Default 0. */
+/* Bit  9: 0 RW tmds_clk_pttn[29:20]. Default 0. */
+#define HDMITX_TOP_TMDS_CLK_PTTN_23             (TOP_OFFSET_MASK + 0x00B)
+
+/* Bit 1 RW shift_tmds_clk_pttn:1=Enable shifting clk pattern,
+ * used when TMDS CLK rate = TMDS character rate /4.    Default 0.
+ * Bit 0 R  Reserved. Default 0.
+ */
+/* [	1] shift_tmds_clk_pttn */
+/* [	0] load_tmds_clk_pttn */
+#define HDMITX_TOP_TMDS_CLK_PTTN_CNTL           (TOP_OFFSET_MASK + 0x00C)
+
+/* Bit 0 RW revocmem_wr_fail: Read back 1 to indicate Host write REVOC MEM
+ * failure, write 1 to clear the failure flag.  Default 0.
+ */
+#define HDMITX_TOP_REVOCMEM_STAT                (TOP_OFFSET_MASK + 0x00D)
+
+/* Bit     0 R  filtered HPD status. */
+#define HDMITX_TOP_STAT0                        (TOP_OFFSET_MASK + 0x00E)
+#define HDMITX_TOP_SKP_CNTL_STAT                (TOP_SEC_OFFSET_MASK + 0x010)
+#define HDMITX_TOP_NONCE_0                      (TOP_SEC_OFFSET_MASK + 0x011)
+#define HDMITX_TOP_NONCE_1                      (TOP_SEC_OFFSET_MASK + 0x012)
+#define HDMITX_TOP_NONCE_2                      (TOP_SEC_OFFSET_MASK + 0x013)
+#define HDMITX_TOP_NONCE_3                      (TOP_SEC_OFFSET_MASK + 0x014)
+#define HDMITX_TOP_PKF_0                        (TOP_SEC_OFFSET_MASK + 0x015)
+#define HDMITX_TOP_PKF_1                        (TOP_SEC_OFFSET_MASK + 0x016)
+#define HDMITX_TOP_PKF_2                        (TOP_SEC_OFFSET_MASK + 0x017)
+#define HDMITX_TOP_PKF_3                        (TOP_SEC_OFFSET_MASK + 0x018)
+#define HDMITX_TOP_DUK_0                        (TOP_SEC_OFFSET_MASK + 0x019)
+#define HDMITX_TOP_DUK_1                        (TOP_SEC_OFFSET_MASK + 0x01A)
+#define HDMITX_TOP_DUK_2                        (TOP_SEC_OFFSET_MASK + 0x01B)
+#define HDMITX_TOP_DUK_3                        (TOP_SEC_OFFSET_MASK + 0x01C)
+/* [26:24] infilter_ddc_intern_clk_divide */
+/* [23:16] infilter_ddc_sample_clk_divide */
+/* [10: 8] infilter_cec_intern_clk_divide */
+/* [ 7: 0] infilter_cec_sample_clk_divide */
+#define HDMITX_TOP_INFILTER                     (TOP_OFFSET_MASK + 0x01D)
+#define HDMITX_TOP_NSEC_SCRATCH                 (TOP_OFFSET_MASK + 0x01E)
+#define HDMITX_TOP_SEC_SCRATCH                  (TOP_SEC_OFFSET_MASK + 0x01F)
+
+#define HDMITX_TOP_DONT_TOUCH0                  (TOP_OFFSET_MASK + 0x0FE)
+#define HDMITX_TOP_DONT_TOUCH1                  (TOP_OFFSET_MASK + 0x0FF)
+
+/* DWC_HDMI_TX Controller registers addresses */
+
+/* Identification Registers */
+#define HDMITX_DWC_DESIGN_ID                    (DWC_OFFSET_MASK + 0x0000)
+#define HDMITX_DWC_REVISION_ID                  (DWC_OFFSET_MASK + 0x0001)
+#define HDMITX_DWC_PRODUCT_ID0                  (DWC_OFFSET_MASK + 0x0002)
+#define HDMITX_DWC_PRODUCT_ID1                  (DWC_OFFSET_MASK + 0x0003)
+#define HDMITX_DWC_CONFIG0_ID                   (DWC_OFFSET_MASK + 0x0004)
+#define HDMITX_DWC_CONFIG1_ID                   (DWC_OFFSET_MASK + 0x0005)
+#define HDMITX_DWC_CONFIG2_ID                   (DWC_OFFSET_MASK + 0x0006)
+#define HDMITX_DWC_CONFIG3_ID                   (DWC_OFFSET_MASK + 0x0007)
+
+/* Interrupt Registers */
+#define HDMITX_DWC_IH_FC_STAT0                  (DWC_OFFSET_MASK + 0x0100)
+#define HDMITX_DWC_IH_FC_STAT1                  (DWC_OFFSET_MASK + 0x0101)
+#define HDMITX_DWC_IH_FC_STAT2                  (DWC_OFFSET_MASK + 0x0102)
+#define HDMITX_DWC_IH_AS_STAT0                  (DWC_OFFSET_MASK + 0x0103)
+#define HDMITX_DWC_IH_PHY_STAT0                 (DWC_OFFSET_MASK + 0x0104)
+#define HDMITX_DWC_IH_I2CM_STAT0                (DWC_OFFSET_MASK + 0x0105)
+#define HDMITX_DWC_IH_CEC_STAT0                 (DWC_OFFSET_MASK + 0x0106)
+#define HDMITX_DWC_IH_VP_STAT0                  (DWC_OFFSET_MASK + 0x0107)
+#define HDMITX_DWC_IH_I2CMPHY_STAT0             (DWC_OFFSET_MASK + 0x0108)
+#define HDMITX_DWC_IH_DECODE                    (DWC_OFFSET_MASK + 0x0170)
+/* [  7] mute_AUDI */
+/* [  6] mute_ACP */
+/* [  5] mute_HBR */
+/* [  4] mute_MAS */
+/* [  3] mute_NVBI */
+/* [  2] mute_AUDS */
+/* [  1] mute_ACR */
+/* [  0] mute_NULL */
+#define HDMITX_DWC_IH_MUTE_FC_STAT0             (DWC_OFFSET_MASK + 0x0180)
+/* [  7] mute_GMD */
+/* [  6] mute_ISRC1 */
+/* [  5] mute_ISRC2 */
+/* [  4] mute_VSD */
+/* [  3] mute_SPD */
+/* [  2] mute_AMP */
+/* [  1] mute_AVI */
+/* [  0] mute_GCP */
+#define HDMITX_DWC_IH_MUTE_FC_STAT1             (DWC_OFFSET_MASK + 0x0181)
+/* [  1] mute_LowPriority_fifo_full */
+/* [  0] mute_HighPriority_fifo_full */
+#define HDMITX_DWC_IH_MUTE_FC_STAT2             (DWC_OFFSET_MASK + 0x0182)
+/* [  4] mute_aud_fifo_underrun */
+/* [  3] mute_aud_fifo_overrun */
+/* [  2] mute_aud_fifo_empty_thr. oififoemptythr tied to 0. */
+/* [  1] mute_aud_fifo_empty */
+/* [  0] mute_aud_fifo_full */
+#define HDMITX_DWC_IH_MUTE_AS_STAT0             (DWC_OFFSET_MASK + 0x0183)
+#define HDMITX_DWC_IH_MUTE_PHY_STAT0            (DWC_OFFSET_MASK + 0x0184)
+/* [  2] mute_scdc_readreq */
+/* [  1] mute_edid_i2c_master_done */
+/* [  0] mute_edid_i2c_master_error */
+#define HDMITX_DWC_IH_MUTE_I2CM_STAT0           (DWC_OFFSET_MASK + 0x0185)
+/* [  6] cec_wakeup */
+/* [  5] cec_error_follower */
+/* [  4] cec_error_initiator */
+/* [  3] cec_arb_lost */
+/* [  2] cec_nack */
+/* [  1] cec_eom */
+/* [  0] cec_done */
+#define HDMITX_DWC_IH_MUTE_CEC_STAT0            (DWC_OFFSET_MASK + 0x0186)
+#define HDMITX_DWC_IH_MUTE_VP_STAT0             (DWC_OFFSET_MASK + 0x0187)
+#define HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0        (DWC_OFFSET_MASK + 0x0188)
+/* [  1] mute_wakeup_interrupt */
+/* [  0] mute_all_interrupt */
+#define HDMITX_DWC_IH_MUTE                      (DWC_OFFSET_MASK + 0x01FF)
+
+/* Video Sampler Registers */
+/* [  7] internal_de_generator */
+/* [4:0] video_mapping */
+#define HDMITX_DWC_TX_INVID0                    (DWC_OFFSET_MASK + 0x0200)
+/* [  2] bcbdata_stuffing */
+/* [  1] rcrdata_stuffing */
+/* [  0] gydata_stuffing */
+#define HDMITX_DWC_TX_INSTUFFING                (DWC_OFFSET_MASK + 0x0201)
+#define HDMITX_DWC_TX_GYDATA0                   (DWC_OFFSET_MASK + 0x0202)
+#define HDMITX_DWC_TX_GYDATA1                   (DWC_OFFSET_MASK + 0x0203)
+#define HDMITX_DWC_TX_RCRDATA0                  (DWC_OFFSET_MASK + 0x0204)
+#define HDMITX_DWC_TX_RCRDATA1                  (DWC_OFFSET_MASK + 0x0205)
+#define HDMITX_DWC_TX_BCBDATA0                  (DWC_OFFSET_MASK + 0x0206)
+#define HDMITX_DWC_TX_BCBDATA1                  (DWC_OFFSET_MASK + 0x0207)
+
+/* Video Packetizer Registers */
+#define HDMITX_DWC_VP_STATUS                    (DWC_OFFSET_MASK + 0x0800)
+/* [3:0] desired_pr_factor */
+#define HDMITX_DWC_VP_PR_CD                     (DWC_OFFSET_MASK + 0x0801)
+/* [  5] default_phase */
+/* [  2] ycc422_stuffing */
+/* [  1] pp_stuffing */
+/* [  0] pr_stuffing */
+#define HDMITX_DWC_VP_STUFF                     (DWC_OFFSET_MASK + 0x0802)
+#define HDMITX_DWC_VP_REMAP                     (DWC_OFFSET_MASK + 0x0803)
+#define HDMITX_DWC_VP_CONF                      (DWC_OFFSET_MASK + 0x0804)
+/* [  7] mask_int_full_prpt */
+/* [  6] mask_int_empty_prpt */
+/* [  5] mask_int_full_ppack */
+/* [  4] mask_int_empty_ppack */
+/* [  3] mask_int_full_remap */
+/* [  2] mask_int_empty_remap */
+/* [  1] mask_int_full_byp */
+/* [  0] mask_int_empty_byp */
+#define HDMITX_DWC_VP_MASK                      (DWC_OFFSET_MASK + 0x0807)
+
+/* Frmae Composer Registers */
+/* [  7] HDCP_keepout */
+/* [  6] vs_in_pol: 0=active low; 1=active high. */
+/* [  5] hs_in_pol: 0=active low; 1=active high. */
+/* [  4] de_in_pol: 0=active low; 1=active high. */
+/* [  3] dvi_modez: 0=dvi; 1=hdmi. */
+/* [  1] r_v_blank_in_osc */
+/* [  0] in_I_P: 0=progressive; 1=interlaced. */
+#define HDMITX_DWC_FC_INVIDCONF                 (DWC_OFFSET_MASK + 0x1000)
+/* [7:0] H_in_active[7:0] */
+#define HDMITX_DWC_FC_INHACTV0                  (DWC_OFFSET_MASK + 0x1001)
+/* [5:0] H_in_active[13:8] */
+#define HDMITX_DWC_FC_INHACTV1                  (DWC_OFFSET_MASK + 0x1002)
+/* [7:0] H_in_blank[7:0] */
+#define HDMITX_DWC_FC_INHBLANK0                 (DWC_OFFSET_MASK + 0x1003)
+/* [4:0] H_in_blank[12:8] */
+#define HDMITX_DWC_FC_INHBLANK1                 (DWC_OFFSET_MASK + 0x1004)
+/* [7:0] V_in_active[7:0] */
+#define HDMITX_DWC_FC_INVACTV0                  (DWC_OFFSET_MASK + 0x1005)
+/* [4:0] V_in_active[12:8] */
+#define HDMITX_DWC_FC_INVACTV1                  (DWC_OFFSET_MASK + 0x1006)
+/* [7:0] V_in_blank */
+#define HDMITX_DWC_FC_INVBLANK                  (DWC_OFFSET_MASK + 0x1007)
+/* [7:0] H_in_delay[7:0] */
+#define HDMITX_DWC_FC_HSYNCINDELAY0             (DWC_OFFSET_MASK + 0x1008)
+/* [4:0] H_in_delay[12:8] */
+#define HDMITX_DWC_FC_HSYNCINDELAY1             (DWC_OFFSET_MASK + 0x1009)
+/* [7:0] H_in_width[7:0] */
+#define HDMITX_DWC_FC_HSYNCINWIDTH0             (DWC_OFFSET_MASK + 0x100A)
+/* [1:0] H_in_width[9:8] */
+#define HDMITX_DWC_FC_HSYNCINWIDTH1             (DWC_OFFSET_MASK + 0x100B)
+/* [7:0] V_in_delay */
+#define HDMITX_DWC_FC_VSYNCINDELAY              (DWC_OFFSET_MASK + 0x100C)
+/* [5:0] V_in_width */
+#define HDMITX_DWC_FC_VSYNCINWIDTH              (DWC_OFFSET_MASK + 0x100D)
+#define HDMITX_DWC_FC_INFREQ0                   (DWC_OFFSET_MASK + 0x100E)
+#define HDMITX_DWC_FC_INFREQ1                   (DWC_OFFSET_MASK + 0x100F)
+#define HDMITX_DWC_FC_INFREQ2                   (DWC_OFFSET_MASK + 0x1010)
+#define HDMITX_DWC_FC_CTRLDUR                   (DWC_OFFSET_MASK + 0x1011)
+#define HDMITX_DWC_FC_EXCTRLDUR                 (DWC_OFFSET_MASK + 0x1012)
+#define HDMITX_DWC_FC_EXCTRLSPAC                (DWC_OFFSET_MASK + 0x1013)
+#define HDMITX_DWC_FC_CH0PREAM                  (DWC_OFFSET_MASK + 0x1014)
+#define HDMITX_DWC_FC_CH1PREAM                  (DWC_OFFSET_MASK + 0x1015)
+#define HDMITX_DWC_FC_CH2PREAM                  (DWC_OFFSET_MASK + 0x1016)
+/* [3:2] YQ */
+/* [1:0] CN */
+#define HDMITX_DWC_FC_AVICONF3                  (DWC_OFFSET_MASK + 0x1017)
+/* [  2] default_phase */
+/* [  1] set_avmute */
+/* [  0] clear_avmute */
+#define HDMITX_DWC_FC_GCP                       (DWC_OFFSET_MASK + 0x1018)
+/* [  7] rgb_ycc_indication[2] */
+/* [  6] active_format_present */
+/* [5:4] scan_information */
+/* [3:2] bar_information */
+/* [1:0] rgb_ycc_indication[1:0] */
+#define HDMITX_DWC_FC_AVICONF0                  (DWC_OFFSET_MASK + 0x1019)
+/* [7:6] colorimetry */
+/* [5:4] picture_aspect_ratio */
+/* [3:0] active_aspect_ratio */
+#define HDMITX_DWC_FC_AVICONF1                  (DWC_OFFSET_MASK + 0x101A)
+/* [  7] IT_content */
+/* [6:4] extended_colorimetry */
+/* [3:2] quantization_range */
+/* [1:0] non_uniform_picture_scaling */
+#define HDMITX_DWC_FC_AVICONF2                  (DWC_OFFSET_MASK + 0x101B)
+#define HDMITX_DWC_FC_AVIVID                    (DWC_OFFSET_MASK + 0x101C)
+#define HDMITX_DWC_FC_AVIETB0                   (DWC_OFFSET_MASK + 0x101D)
+#define HDMITX_DWC_FC_AVIETB1                   (DWC_OFFSET_MASK + 0x101E)
+#define HDMITX_DWC_FC_AVISBB0                   (DWC_OFFSET_MASK + 0x101F)
+#define HDMITX_DWC_FC_AVISBB1                   (DWC_OFFSET_MASK + 0x1020)
+#define HDMITX_DWC_FC_AVIELB0                   (DWC_OFFSET_MASK + 0x1021)
+#define HDMITX_DWC_FC_AVIELB1                   (DWC_OFFSET_MASK + 0x1022)
+#define HDMITX_DWC_FC_AVISRB0                   (DWC_OFFSET_MASK + 0x1023)
+#define HDMITX_DWC_FC_AVISRB1                   (DWC_OFFSET_MASK + 0x1024)
+/* [3:0] CT: coding type */
+#define HDMITX_DWC_FC_AUDICONF0                 (DWC_OFFSET_MASK + 0x1025)
+/* [5:4] SS: sampling size */
+/* [2:0] SF: sampling frequency */
+#define HDMITX_DWC_FC_AUDICONF1                 (DWC_OFFSET_MASK + 0x1026)
+/* CA: channel allocation */
+#define HDMITX_DWC_FC_AUDICONF2                 (DWC_OFFSET_MASK + 0x1027)
+/* [6:5] LFEPBL: LFE playback info */
+/* [  4] DM_INH: down mix enable */
+/* [3:0] LSv: Level shift value */
+#define HDMITX_DWC_FC_AUDICONF3                 (DWC_OFFSET_MASK + 0x1028)
+#define HDMITX_DWC_FC_VSDIEEEID0                (DWC_OFFSET_MASK + 0x1029)
+#define HDMITX_DWC_FC_VSDSIZE                   (DWC_OFFSET_MASK + 0x102A)
+#define HDMITX_DWC_FC_VSDIEEEID1                (DWC_OFFSET_MASK + 0x1030)
+#define HDMITX_DWC_FC_VSDIEEEID2                (DWC_OFFSET_MASK + 0x1031)
+#define HDMITX_DWC_FC_VSDPAYLOAD0               (DWC_OFFSET_MASK + 0x1032)
+#define HDMITX_DWC_FC_VSDPAYLOAD1               (DWC_OFFSET_MASK + 0x1033)
+#define HDMITX_DWC_FC_VSDPAYLOAD2               (DWC_OFFSET_MASK + 0x1034)
+#define HDMITX_DWC_FC_VSDPAYLOAD3               (DWC_OFFSET_MASK + 0x1035)
+#define HDMITX_DWC_FC_VSDPAYLOAD4               (DWC_OFFSET_MASK + 0x1036)
+#define HDMITX_DWC_FC_VSDPAYLOAD5               (DWC_OFFSET_MASK + 0x1037)
+#define HDMITX_DWC_FC_VSDPAYLOAD6               (DWC_OFFSET_MASK + 0x1038)
+#define HDMITX_DWC_FC_VSDPAYLOAD7               (DWC_OFFSET_MASK + 0x1039)
+#define HDMITX_DWC_FC_VSDPAYLOAD8               (DWC_OFFSET_MASK + 0x103A)
+#define HDMITX_DWC_FC_VSDPAYLOAD9               (DWC_OFFSET_MASK + 0x103B)
+#define HDMITX_DWC_FC_VSDPAYLOAD10              (DWC_OFFSET_MASK + 0x103C)
+#define HDMITX_DWC_FC_VSDPAYLOAD11              (DWC_OFFSET_MASK + 0x103D)
+#define HDMITX_DWC_FC_VSDPAYLOAD12              (DWC_OFFSET_MASK + 0x103E)
+#define HDMITX_DWC_FC_VSDPAYLOAD13              (DWC_OFFSET_MASK + 0x103F)
+#define HDMITX_DWC_FC_VSDPAYLOAD14              (DWC_OFFSET_MASK + 0x1040)
+#define HDMITX_DWC_FC_VSDPAYLOAD15              (DWC_OFFSET_MASK + 0x1041)
+#define HDMITX_DWC_FC_VSDPAYLOAD16              (DWC_OFFSET_MASK + 0x1042)
+#define HDMITX_DWC_FC_VSDPAYLOAD17              (DWC_OFFSET_MASK + 0x1043)
+#define HDMITX_DWC_FC_VSDPAYLOAD18              (DWC_OFFSET_MASK + 0x1044)
+#define HDMITX_DWC_FC_VSDPAYLOAD19              (DWC_OFFSET_MASK + 0x1045)
+#define HDMITX_DWC_FC_VSDPAYLOAD20              (DWC_OFFSET_MASK + 0x1046)
+#define HDMITX_DWC_FC_VSDPAYLOAD21              (DWC_OFFSET_MASK + 0x1047)
+#define HDMITX_DWC_FC_VSDPAYLOAD22              (DWC_OFFSET_MASK + 0x1048)
+#define HDMITX_DWC_FC_VSDPAYLOAD23              (DWC_OFFSET_MASK + 0x1049)
+#define HDMITX_DWC_FC_SPDVENDORNAME0            (DWC_OFFSET_MASK + 0x104A)
+#define HDMITX_DWC_FC_SPDVENDORNAME1            (DWC_OFFSET_MASK + 0x104B)
+#define HDMITX_DWC_FC_SPDVENDORNAME2            (DWC_OFFSET_MASK + 0x104C)
+#define HDMITX_DWC_FC_SPDVENDORNAME3            (DWC_OFFSET_MASK + 0x104D)
+#define HDMITX_DWC_FC_SPDVENDORNAME4            (DWC_OFFSET_MASK + 0x104E)
+#define HDMITX_DWC_FC_SPDVENDORNAME5            (DWC_OFFSET_MASK + 0x104F)
+#define HDMITX_DWC_FC_SPDVENDORNAME6            (DWC_OFFSET_MASK + 0x1050)
+#define HDMITX_DWC_FC_SPDVENDORNAME7            (DWC_OFFSET_MASK + 0x1051)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME0           (DWC_OFFSET_MASK + 0x1052)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME1           (DWC_OFFSET_MASK + 0x1053)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME2           (DWC_OFFSET_MASK + 0x1054)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME3           (DWC_OFFSET_MASK + 0x1055)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME4           (DWC_OFFSET_MASK + 0x1056)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME5           (DWC_OFFSET_MASK + 0x1057)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME6           (DWC_OFFSET_MASK + 0x1058)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME7           (DWC_OFFSET_MASK + 0x1059)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME8           (DWC_OFFSET_MASK + 0x105A)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME9           (DWC_OFFSET_MASK + 0x105B)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME10          (DWC_OFFSET_MASK + 0x105C)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME11          (DWC_OFFSET_MASK + 0x105D)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME12          (DWC_OFFSET_MASK + 0x105E)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME13          (DWC_OFFSET_MASK + 0x105F)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME14          (DWC_OFFSET_MASK + 0x1060)
+#define HDMITX_DWC_FC_SPDPRODUCTNAME15          (DWC_OFFSET_MASK + 0x1061)
+#define HDMITX_DWC_FC_SPDDEVICEINF              (DWC_OFFSET_MASK + 0x1062)
+/* [7:4] aud_packet_sampflat */
+/* [  0] aud_packet_layout */
+#define HDMITX_DWC_FC_AUDSCONF                  (DWC_OFFSET_MASK + 0x1063)
+#define HDMITX_DWC_FC_AUDSSTAT                  (DWC_OFFSET_MASK + 0x1064)
+/* [  7] V3r */
+/* [  6] V2r */
+/* [  5] V1r */
+/* [  4] V0r */
+/* [  3] V3l */
+/* [  2] V2l */
+/* [  1] V1l */
+/* [  0] V0l */
+#define HDMITX_DWC_FC_AUDSV                     (DWC_OFFSET_MASK + 0x1065)
+#define HDMITX_DWC_FC_AUDSU                     (DWC_OFFSET_MASK + 0x1066)
+#define HDMITX_DWC_FC_AUDSCHNLS0                (DWC_OFFSET_MASK + 0x1067)
+#define HDMITX_DWC_FC_AUDSCHNLS1                (DWC_OFFSET_MASK + 0x1068)
+#define HDMITX_DWC_FC_AUDSCHNLS2                (DWC_OFFSET_MASK + 0x1069)
+#define HDMITX_DWC_FC_AUDSCHNLS3                (DWC_OFFSET_MASK + 0x106A)
+#define HDMITX_DWC_FC_AUDSCHNLS4                (DWC_OFFSET_MASK + 0x106B)
+#define HDMITX_DWC_FC_AUDSCHNLS5                (DWC_OFFSET_MASK + 0x106C)
+#define HDMITX_DWC_FC_AUDSCHNLS6                (DWC_OFFSET_MASK + 0x106D)
+#define HDMITX_DWC_FC_AUDSCHNLS7                (DWC_OFFSET_MASK + 0x106E)
+#define HDMITX_DWC_FC_AUDSCHNLS8                (DWC_OFFSET_MASK + 0x106F)
+#define HDMITX_DWC_FC_DATACH0FILL               (DWC_OFFSET_MASK + 0x1070)
+#define HDMITX_DWC_FC_DATACH1FILL               (DWC_OFFSET_MASK + 0x1071)
+#define HDMITX_DWC_FC_DATACH2FILL               (DWC_OFFSET_MASK + 0x1072)
+#define HDMITX_DWC_FC_CTRLQHIGH                 (DWC_OFFSET_MASK + 0x1073)
+#define HDMITX_DWC_FC_CTRLQLOW                  (DWC_OFFSET_MASK + 0x1074)
+#define HDMITX_DWC_FC_ACP0                      (DWC_OFFSET_MASK + 0x1075)
+#define HDMITX_DWC_FC_ACP16                     (DWC_OFFSET_MASK + 0x1082)
+#define HDMITX_DWC_FC_ACP15                     (DWC_OFFSET_MASK + 0x1083)
+#define HDMITX_DWC_FC_ACP14                     (DWC_OFFSET_MASK + 0x1084)
+#define HDMITX_DWC_FC_ACP13                     (DWC_OFFSET_MASK + 0x1085)
+#define HDMITX_DWC_FC_ACP12                     (DWC_OFFSET_MASK + 0x1086)
+#define HDMITX_DWC_FC_ACP11                     (DWC_OFFSET_MASK + 0x1087)
+#define HDMITX_DWC_FC_ACP10                     (DWC_OFFSET_MASK + 0x1088)
+#define HDMITX_DWC_FC_ACP9                      (DWC_OFFSET_MASK + 0x1089)
+#define HDMITX_DWC_FC_ACP8                      (DWC_OFFSET_MASK + 0x108A)
+#define HDMITX_DWC_FC_ACP7                      (DWC_OFFSET_MASK + 0x108B)
+#define HDMITX_DWC_FC_ACP6                      (DWC_OFFSET_MASK + 0x108C)
+#define HDMITX_DWC_FC_ACP5                      (DWC_OFFSET_MASK + 0x108D)
+#define HDMITX_DWC_FC_ACP4                      (DWC_OFFSET_MASK + 0x108E)
+#define HDMITX_DWC_FC_ACP3                      (DWC_OFFSET_MASK + 0x108F)
+#define HDMITX_DWC_FC_ACP2                      (DWC_OFFSET_MASK + 0x1090)
+#define HDMITX_DWC_FC_ACP1                      (DWC_OFFSET_MASK + 0x1091)
+#define HDMITX_DWC_FC_ISCR1_0                   (DWC_OFFSET_MASK + 0x1092)
+#define HDMITX_DWC_FC_ISCR1_16                  (DWC_OFFSET_MASK + 0x1093)
+#define HDMITX_DWC_FC_ISCR1_15                  (DWC_OFFSET_MASK + 0x1094)
+#define HDMITX_DWC_FC_ISCR1_14                  (DWC_OFFSET_MASK + 0x1095)
+#define HDMITX_DWC_FC_ISCR1_13                  (DWC_OFFSET_MASK + 0x1096)
+#define HDMITX_DWC_FC_ISCR1_12                  (DWC_OFFSET_MASK + 0x1097)
+#define HDMITX_DWC_FC_ISCR1_11                  (DWC_OFFSET_MASK + 0x1098)
+#define HDMITX_DWC_FC_ISCR1_10                  (DWC_OFFSET_MASK + 0x1099)
+#define HDMITX_DWC_FC_ISCR1_9                   (DWC_OFFSET_MASK + 0x109A)
+#define HDMITX_DWC_FC_ISCR1_8                   (DWC_OFFSET_MASK + 0x109B)
+#define HDMITX_DWC_FC_ISCR1_7                   (DWC_OFFSET_MASK + 0x109C)
+#define HDMITX_DWC_FC_ISCR1_6                   (DWC_OFFSET_MASK + 0x109D)
+#define HDMITX_DWC_FC_ISCR1_5                   (DWC_OFFSET_MASK + 0x109E)
+#define HDMITX_DWC_FC_ISCR1_4                   (DWC_OFFSET_MASK + 0x109F)
+#define HDMITX_DWC_FC_ISCR1_3                   (DWC_OFFSET_MASK + 0x10A0)
+#define HDMITX_DWC_FC_ISCR1_2                   (DWC_OFFSET_MASK + 0x10A1)
+#define HDMITX_DWC_FC_ISCR1_1                   (DWC_OFFSET_MASK + 0x10A2)
+#define HDMITX_DWC_FC_ISCR0_15                  (DWC_OFFSET_MASK + 0x10A3)
+#define HDMITX_DWC_FC_ISCR0_14                  (DWC_OFFSET_MASK + 0x10A4)
+#define HDMITX_DWC_FC_ISCR0_13                  (DWC_OFFSET_MASK + 0x10A5)
+#define HDMITX_DWC_FC_ISCR0_12                  (DWC_OFFSET_MASK + 0x10A6)
+#define HDMITX_DWC_FC_ISCR0_11                  (DWC_OFFSET_MASK + 0x10A7)
+#define HDMITX_DWC_FC_ISCR0_10                  (DWC_OFFSET_MASK + 0x10A8)
+#define HDMITX_DWC_FC_ISCR0_9                   (DWC_OFFSET_MASK + 0x10A9)
+#define HDMITX_DWC_FC_ISCR0_8                   (DWC_OFFSET_MASK + 0x10AA)
+#define HDMITX_DWC_FC_ISCR0_7                   (DWC_OFFSET_MASK + 0x10AB)
+#define HDMITX_DWC_FC_ISCR0_6                   (DWC_OFFSET_MASK + 0x10AC)
+#define HDMITX_DWC_FC_ISCR0_5                   (DWC_OFFSET_MASK + 0x10AD)
+#define HDMITX_DWC_FC_ISCR0_4                   (DWC_OFFSET_MASK + 0x10AE)
+#define HDMITX_DWC_FC_ISCR0_3                   (DWC_OFFSET_MASK + 0x10AF)
+#define HDMITX_DWC_FC_ISCR0_2                   (DWC_OFFSET_MASK + 0x10B0)
+#define HDMITX_DWC_FC_ISCR0_1                   (DWC_OFFSET_MASK + 0x10B1)
+#define HDMITX_DWC_FC_ISCR0_0                   (DWC_OFFSET_MASK + 0x10B2)
+/* [  4] spd_auto */
+/* [  3] vsd_auto */
+/* [  2] isrc2_auto */
+/* [  1] isrc1_auto */
+/* [  0] acp_auto */
+#define HDMITX_DWC_FC_DATAUTO0                  (DWC_OFFSET_MASK + 0x10B3)
+#define HDMITX_DWC_FC_DATAUTO1                  (DWC_OFFSET_MASK + 0x10B4)
+#define HDMITX_DWC_FC_DATAUTO2                  (DWC_OFFSET_MASK + 0x10B5)
+#define HDMITX_DWC_FC_DATMAN                    (DWC_OFFSET_MASK + 0x10B6)
+/* [  5] nvbi_auto: insert on Vsync */
+/* [  4] amp_auto: insert on Vsync */
+/* [  3] avi_auto: insert on Vsync */
+/* [  2] gcp_auto: insert on Vsync */
+/* [  1] audi_auto: insert on Vsync */
+/* [  0] acr_auto: insert on CTS update. Assert this bit later to avoid
+ * inital packets with false CTS value
+ */
+#define HDMITX_DWC_FC_DATAUTO3                  (DWC_OFFSET_MASK + 0x10B7)
+#define HDMITX_DWC_FC_RDRB0                     (DWC_OFFSET_MASK + 0x10B8)
+#define HDMITX_DWC_FC_RDRB1                     (DWC_OFFSET_MASK + 0x10B9)
+#define HDMITX_DWC_FC_RDRB2                     (DWC_OFFSET_MASK + 0x10BA)
+#define HDMITX_DWC_FC_RDRB3                     (DWC_OFFSET_MASK + 0x10BB)
+#define HDMITX_DWC_FC_RDRB4                     (DWC_OFFSET_MASK + 0x10BC)
+#define HDMITX_DWC_FC_RDRB5                     (DWC_OFFSET_MASK + 0x10BD)
+#define HDMITX_DWC_FC_RDRB6                     (DWC_OFFSET_MASK + 0x10BE)
+#define HDMITX_DWC_FC_RDRB7                     (DWC_OFFSET_MASK + 0x10BF)
+#define HDMITX_DWC_FC_RDRB8                     (DWC_OFFSET_MASK + 0x10C0)
+#define HDMITX_DWC_FC_RDRB9                     (DWC_OFFSET_MASK + 0x10C1)
+#define HDMITX_DWC_FC_RDRB10                    (DWC_OFFSET_MASK + 0x10C2)
+#define HDMITX_DWC_FC_RDRB11                    (DWC_OFFSET_MASK + 0x10C3)
+/* [  7] AUDI_int_mask */
+/* [  6] ACP_int_mask */
+/* [  5] HBR_int_mask */
+/* [  2] AUDS_int_mask */
+/* [  1] ACR_int_mask */
+/* [  0] NULL_int_mask */
+#define HDMITX_DWC_FC_MASK0                     (DWC_OFFSET_MASK + 0x10D2)
+/* [  7] GMD_int_mask */
+/* [  6] ISRC1_int_mask */
+/* [  5] ISRC2_int_mask */
+/* [  4] VSD_int_mask */
+/* [  3] SPD_int_mask */
+/* [  1] AVI_int_mask */
+/* [  0] GCP_int_mask */
+#define HDMITX_DWC_FC_MASK1                     (DWC_OFFSET_MASK + 0x10D6)
+/* [  1] LowPriority_fifo_full */
+/* [  0] HighPriority_fifo_full */
+#define HDMITX_DWC_FC_MASK2                     (DWC_OFFSET_MASK + 0x10DA)
+/* [7:4] incoming_pr_factor */
+/* [3:0] output_pr_factor */
+#define HDMITX_DWC_FC_PRCONF                    (DWC_OFFSET_MASK + 0x10E0)
+/* [  4] scrambler_ucp_line */
+/* [  0] scrambler_en. Only update this bit once we've sent SCDC message*/
+#define HDMITX_DWC_FC_SCRAMBLER_CTRL            (DWC_OFFSET_MASK + 0x10E1)
+#define HDMITX_DWC_FC_MULTISTREAM_CTRL          (DWC_OFFSET_MASK + 0x10E2)
+/* [  6] nvbi_tx_en */
+/* [  5] amp_tx_en */
+/* [  4] aut_tx_en */
+/* [  3] audi_tx_en */
+/* [  2] avi_tx_en */
+/* [  1] gcp_tx_en */
+/* [  0] acr_tx_en */
+#define HDMITX_DWC_FC_PACKET_TX_EN              (DWC_OFFSET_MASK + 0x10E3)
+/* [  1] actspc_hdlr_tgl */
+/* [  0] actspc_hdlr_en */
+#define HDMITX_DWC_FC_ACTSPC_HDLR_CFG           (DWC_OFFSET_MASK + 0x10E8)
+#define HDMITX_DWC_FC_INVACT_2D_0               (DWC_OFFSET_MASK + 0x10E9)
+/* [3:0] fc_invact_2d_0[11:8] */
+/* [7:0] fc_invact_2d_0[7:0] */
+#define HDMITX_DWC_FC_INVACT_2D_1               (DWC_OFFSET_MASK + 0x10EA)
+
+#define HDMITX_DWC_FC_GMD_STAT                  (DWC_OFFSET_MASK + 0x1100)
+#define HDMITX_DWC_FC_GMD_EN                    (DWC_OFFSET_MASK + 0x1101)
+#define HDMITX_DWC_FC_GMD_UP                    (DWC_OFFSET_MASK + 0x1102)
+#define HDMITX_DWC_FC_GMD_CONF                  (DWC_OFFSET_MASK + 0x1103)
+#define HDMITX_DWC_FC_GMD_HB                    (DWC_OFFSET_MASK + 0x1104)
+#define HDMITX_DWC_FC_GMD_PB0                   (DWC_OFFSET_MASK + 0x1105)
+#define HDMITX_DWC_FC_GMD_PB1                   (DWC_OFFSET_MASK + 0x1106)
+#define HDMITX_DWC_FC_GMD_PB2                   (DWC_OFFSET_MASK + 0x1107)
+#define HDMITX_DWC_FC_GMD_PB3                   (DWC_OFFSET_MASK + 0x1108)
+#define HDMITX_DWC_FC_GMD_PB4                   (DWC_OFFSET_MASK + 0x1109)
+#define HDMITX_DWC_FC_GMD_PB5                   (DWC_OFFSET_MASK + 0x110A)
+#define HDMITX_DWC_FC_GMD_PB6                   (DWC_OFFSET_MASK + 0x110B)
+#define HDMITX_DWC_FC_GMD_PB7                   (DWC_OFFSET_MASK + 0x110C)
+#define HDMITX_DWC_FC_GMD_PB8                   (DWC_OFFSET_MASK + 0x110D)
+#define HDMITX_DWC_FC_GMD_PB9                   (DWC_OFFSET_MASK + 0x110E)
+#define HDMITX_DWC_FC_GMD_PB10                  (DWC_OFFSET_MASK + 0x110F)
+#define HDMITX_DWC_FC_GMD_PB11                  (DWC_OFFSET_MASK + 0x1110)
+#define HDMITX_DWC_FC_GMD_PB12                  (DWC_OFFSET_MASK + 0x1111)
+#define HDMITX_DWC_FC_GMD_PB13                  (DWC_OFFSET_MASK + 0x1112)
+#define HDMITX_DWC_FC_GMD_PB14                  (DWC_OFFSET_MASK + 0x1113)
+#define HDMITX_DWC_FC_GMD_PB15                  (DWC_OFFSET_MASK + 0x1114)
+#define HDMITX_DWC_FC_GMD_PB16                  (DWC_OFFSET_MASK + 0x1115)
+#define HDMITX_DWC_FC_GMD_PB17                  (DWC_OFFSET_MASK + 0x1116)
+#define HDMITX_DWC_FC_GMD_PB18                  (DWC_OFFSET_MASK + 0x1117)
+#define HDMITX_DWC_FC_GMD_PB19                  (DWC_OFFSET_MASK + 0x1118)
+#define HDMITX_DWC_FC_GMD_PB20                  (DWC_OFFSET_MASK + 0x1119)
+#define HDMITX_DWC_FC_GMD_PB21                  (DWC_OFFSET_MASK + 0x111A)
+#define HDMITX_DWC_FC_GMD_PB22                  (DWC_OFFSET_MASK + 0x111B)
+#define HDMITX_DWC_FC_GMD_PB23                  (DWC_OFFSET_MASK + 0x111C)
+#define HDMITX_DWC_FC_GMD_PB24                  (DWC_OFFSET_MASK + 0x111D)
+#define HDMITX_DWC_FC_GMD_PB25                  (DWC_OFFSET_MASK + 0x111E)
+#define HDMITX_DWC_FC_GMD_PB26                  (DWC_OFFSET_MASK + 0x111F)
+#define HDMITX_DWC_FC_GMD_PB27                  (DWC_OFFSET_MASK + 0x1120)
+
+/* Audio Metadata Packet Registers */
+#define HDMITX_DWC_FC_AMP_HB01                  (DWC_OFFSET_MASK + 0x1128)
+#define HDMITX_DWC_FC_AMP_HB02                  (DWC_OFFSET_MASK + 0x1129)
+#define HDMITX_DWC_FC_AMP_PB00                  (DWC_OFFSET_MASK + 0x112A)
+#define HDMITX_DWC_FC_AMP_PB01                  (DWC_OFFSET_MASK + 0x112B)
+#define HDMITX_DWC_FC_AMP_PB02                  (DWC_OFFSET_MASK + 0x112C)
+#define HDMITX_DWC_FC_AMP_PB03                  (DWC_OFFSET_MASK + 0x112D)
+#define HDMITX_DWC_FC_AMP_PB04                  (DWC_OFFSET_MASK + 0x112E)
+#define HDMITX_DWC_FC_AMP_PB05                  (DWC_OFFSET_MASK + 0x112F)
+#define HDMITX_DWC_FC_AMP_PB06                  (DWC_OFFSET_MASK + 0x1130)
+#define HDMITX_DWC_FC_AMP_PB07                  (DWC_OFFSET_MASK + 0x1131)
+#define HDMITX_DWC_FC_AMP_PB08                  (DWC_OFFSET_MASK + 0x1132)
+#define HDMITX_DWC_FC_AMP_PB09                  (DWC_OFFSET_MASK + 0x1133)
+#define HDMITX_DWC_FC_AMP_PB10                  (DWC_OFFSET_MASK + 0x1134)
+#define HDMITX_DWC_FC_AMP_PB11                  (DWC_OFFSET_MASK + 0x1135)
+#define HDMITX_DWC_FC_AMP_PB12                  (DWC_OFFSET_MASK + 0x1136)
+#define HDMITX_DWC_FC_AMP_PB13                  (DWC_OFFSET_MASK + 0x1137)
+#define HDMITX_DWC_FC_AMP_PB14                  (DWC_OFFSET_MASK + 0x1138)
+#define HDMITX_DWC_FC_AMP_PB15                  (DWC_OFFSET_MASK + 0x1139)
+#define HDMITX_DWC_FC_AMP_PB16                  (DWC_OFFSET_MASK + 0x113A)
+#define HDMITX_DWC_FC_AMP_PB17                  (DWC_OFFSET_MASK + 0x113B)
+#define HDMITX_DWC_FC_AMP_PB18                  (DWC_OFFSET_MASK + 0x113C)
+#define HDMITX_DWC_FC_AMP_PB19                  (DWC_OFFSET_MASK + 0x113D)
+#define HDMITX_DWC_FC_AMP_PB20                  (DWC_OFFSET_MASK + 0x113E)
+#define HDMITX_DWC_FC_AMP_PB21                  (DWC_OFFSET_MASK + 0x113F)
+#define HDMITX_DWC_FC_AMP_PB22                  (DWC_OFFSET_MASK + 0x1140)
+#define HDMITX_DWC_FC_AMP_PB23                  (DWC_OFFSET_MASK + 0x1141)
+#define HDMITX_DWC_FC_AMP_PB24                  (DWC_OFFSET_MASK + 0x1142)
+#define HDMITX_DWC_FC_AMP_PB25                  (DWC_OFFSET_MASK + 0x1143)
+#define HDMITX_DWC_FC_AMP_PB26                  (DWC_OFFSET_MASK + 0x1144)
+#define HDMITX_DWC_FC_AMP_PB27                  (DWC_OFFSET_MASK + 0x1145)
+
+/* NTSC VBI Packet Registers */
+#define HDMITX_DWC_FC_NVBI_HB01                 (DWC_OFFSET_MASK + 0x1148)
+#define HDMITX_DWC_FC_NVBI_HB02                 (DWC_OFFSET_MASK + 0x1149)
+#define HDMITX_DWC_FC_NVBI_PB01                 (DWC_OFFSET_MASK + 0x114A)
+#define HDMITX_DWC_FC_NVBI_PB02                 (DWC_OFFSET_MASK + 0x114B)
+#define HDMITX_DWC_FC_NVBI_PB03                 (DWC_OFFSET_MASK + 0x114C)
+#define HDMITX_DWC_FC_NVBI_PB04                 (DWC_OFFSET_MASK + 0x114D)
+#define HDMITX_DWC_FC_NVBI_PB05                 (DWC_OFFSET_MASK + 0x114E)
+#define HDMITX_DWC_FC_NVBI_PB06                 (DWC_OFFSET_MASK + 0x114F)
+#define HDMITX_DWC_FC_NVBI_PB07                 (DWC_OFFSET_MASK + 0x1150)
+#define HDMITX_DWC_FC_NVBI_PB08                 (DWC_OFFSET_MASK + 0x1151)
+#define HDMITX_DWC_FC_NVBI_PB09                 (DWC_OFFSET_MASK + 0x1152)
+#define HDMITX_DWC_FC_NVBI_PB10                 (DWC_OFFSET_MASK + 0x1153)
+#define HDMITX_DWC_FC_NVBI_PB11                 (DWC_OFFSET_MASK + 0x1154)
+#define HDMITX_DWC_FC_NVBI_PB12                 (DWC_OFFSET_MASK + 0x1155)
+#define HDMITX_DWC_FC_NVBI_PB13                 (DWC_OFFSET_MASK + 0x1156)
+#define HDMITX_DWC_FC_NVBI_PB14                 (DWC_OFFSET_MASK + 0x1157)
+#define HDMITX_DWC_FC_NVBI_PB15                 (DWC_OFFSET_MASK + 0x1158)
+#define HDMITX_DWC_FC_NVBI_PB16                 (DWC_OFFSET_MASK + 0x1159)
+#define HDMITX_DWC_FC_NVBI_PB17                 (DWC_OFFSET_MASK + 0x115A)
+#define HDMITX_DWC_FC_NVBI_PB18                 (DWC_OFFSET_MASK + 0x115B)
+#define HDMITX_DWC_FC_NVBI_PB19                 (DWC_OFFSET_MASK + 0x115C)
+#define HDMITX_DWC_FC_NVBI_PB20                 (DWC_OFFSET_MASK + 0x115D)
+#define HDMITX_DWC_FC_NVBI_PB21                 (DWC_OFFSET_MASK + 0x115E)
+#define HDMITX_DWC_FC_NVBI_PB22                 (DWC_OFFSET_MASK + 0x115F)
+#define HDMITX_DWC_FC_NVBI_PB23                 (DWC_OFFSET_MASK + 0x1160)
+#define HDMITX_DWC_FC_NVBI_PB24                 (DWC_OFFSET_MASK + 0x1161)
+#define HDMITX_DWC_FC_NVBI_PB25                 (DWC_OFFSET_MASK + 0x1162)
+#define HDMITX_DWC_FC_NVBI_PB26                 (DWC_OFFSET_MASK + 0x1163)
+#define HDMITX_DWC_FC_NVBI_PB27                 (DWC_OFFSET_MASK + 0x1164)
+
+#define HDMITX_DWC_FC_DBGFORCE                  (DWC_OFFSET_MASK + 0x1200)
+#define HDMITX_DWC_FC_DBGAUD0CH0                (DWC_OFFSET_MASK + 0x1201)
+#define HDMITX_DWC_FC_DBGAUD1CH0                (DWC_OFFSET_MASK + 0x1202)
+#define HDMITX_DWC_FC_DBGAUD2CH0                (DWC_OFFSET_MASK + 0x1203)
+#define HDMITX_DWC_FC_DBGAUD0CH1                (DWC_OFFSET_MASK + 0x1204)
+#define HDMITX_DWC_FC_DBGAUD1CH1                (DWC_OFFSET_MASK + 0x1205)
+#define HDMITX_DWC_FC_DBGAUD2CH1                (DWC_OFFSET_MASK + 0x1206)
+#define HDMITX_DWC_FC_DBGAUD0CH2                (DWC_OFFSET_MASK + 0x1207)
+#define HDMITX_DWC_FC_DBGAUD1CH2                (DWC_OFFSET_MASK + 0x1208)
+#define HDMITX_DWC_FC_DBGAUD2CH2                (DWC_OFFSET_MASK + 0x1209)
+#define HDMITX_DWC_FC_DBGAUD0CH3                (DWC_OFFSET_MASK + 0x120A)
+#define HDMITX_DWC_FC_DBGAUD1CH3                (DWC_OFFSET_MASK + 0x120B)
+#define HDMITX_DWC_FC_DBGAUD2CH3                (DWC_OFFSET_MASK + 0x120C)
+#define HDMITX_DWC_FC_DBGAUD0CH4                (DWC_OFFSET_MASK + 0x120D)
+#define HDMITX_DWC_FC_DBGAUD1CH4                (DWC_OFFSET_MASK + 0x120E)
+#define HDMITX_DWC_FC_DBGAUD2CH4                (DWC_OFFSET_MASK + 0x120F)
+#define HDMITX_DWC_FC_DBGAUD0CH5                (DWC_OFFSET_MASK + 0x1210)
+#define HDMITX_DWC_FC_DBGAUD1CH5                (DWC_OFFSET_MASK + 0x1211)
+#define HDMITX_DWC_FC_DBGAUD2CH5                (DWC_OFFSET_MASK + 0x1212)
+#define HDMITX_DWC_FC_DBGAUD0CH6                (DWC_OFFSET_MASK + 0x1213)
+#define HDMITX_DWC_FC_DBGAUD1CH6                (DWC_OFFSET_MASK + 0x1214)
+#define HDMITX_DWC_FC_DBGAUD2CH6                (DWC_OFFSET_MASK + 0x1215)
+#define HDMITX_DWC_FC_DBGAUD0CH7                (DWC_OFFSET_MASK + 0x1216)
+#define HDMITX_DWC_FC_DBGAUD1CH7                (DWC_OFFSET_MASK + 0x1217)
+#define HDMITX_DWC_FC_DBGAUD2CH7                (DWC_OFFSET_MASK + 0x1218)
+#define HDMITX_DWC_FC_DBGTMDS0                  (DWC_OFFSET_MASK + 0x1219)
+#define HDMITX_DWC_FC_DBGTMDS1                  (DWC_OFFSET_MASK + 0x121A)
+#define HDMITX_DWC_FC_DBGTMDS2                  (DWC_OFFSET_MASK + 0x121B)
+
+/* HDMI Source PHY Registers */
+#define HDMITX_DWC_PHY_CONF0                    (DWC_OFFSET_MASK + 0x3000)
+#define HDMITX_DWC_PHY_TST0                     (DWC_OFFSET_MASK + 0x3001)
+#define HDMITX_DWC_PHY_TST1                     (DWC_OFFSET_MASK + 0x3002)
+#define HDMITX_DWC_PHY_TST2                     (DWC_OFFSET_MASK + 0x3003)
+#define HDMITX_DWC_PHY_STAT0                    (DWC_OFFSET_MASK + 0x3004)
+#define HDMITX_DWC_PHY_INT0                     (DWC_OFFSET_MASK + 0x3005)
+#define HDMITX_DWC_PHY_MASK0                    (DWC_OFFSET_MASK + 0x3006)
+#define HDMITX_DWC_PHY_POL0                     (DWC_OFFSET_MASK + 0x3007)
+
+/* I2C Master PHY Registers */
+#define HDMITX_DWC_I2CM_PHY_SLAVE               (DWC_OFFSET_MASK + 0x3020)
+#define HDMITX_DWC_I2CM_PHY_ADDRESS             (DWC_OFFSET_MASK + 0x3021)
+#define HDMITX_DWC_I2CM_PHY_DATAO_1             (DWC_OFFSET_MASK + 0x3022)
+#define HDMITX_DWC_I2CM_PHY_DATAO_0             (DWC_OFFSET_MASK + 0x3023)
+#define HDMITX_DWC_I2CM_PHY_DATAI_1             (DWC_OFFSET_MASK + 0x3024)
+#define HDMITX_DWC_I2CM_PHY_DATAI_0             (DWC_OFFSET_MASK + 0x3025)
+#define HDMITX_DWC_I2CM_PHY_OPERATION           (DWC_OFFSET_MASK + 0x3026)
+#define HDMITX_DWC_I2CM_PHY_INT                 (DWC_OFFSET_MASK + 0x3027)
+#define HDMITX_DWC_I2CM_PHY_CTLINT              (DWC_OFFSET_MASK + 0x3028)
+#define HDMITX_DWC_I2CM_PHY_DIV                 (DWC_OFFSET_MASK + 0x3029)
+#define HDMITX_DWC_I2CM_PHY_SOFTRSTZ            (DWC_OFFSET_MASK + 0x302A)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302B)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x302C)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x302D)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x302E)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302F)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x3030)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x3031)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x3032)
+#define HDMITX_DWC_I2CM_PHY_SDA_HOLD            (DWC_OFFSET_MASK + 0x3033)
+
+/* Audio Sampler Registers */
+
+  /* [  7] sw_audio_fifo_rst */
+  /* [  5] 0=select SPDIF; 1=select I2S. */
+  /* [3:0] i2s_in_en: enable it later in test.c */
+
+#define HDMITX_DWC_AUD_CONF0                    (DWC_OFFSET_MASK + 0x3100)
+/* [4:0] i2s_width */
+/* [7:5] i2s_mode: 0=standard I2S mode */
+#define HDMITX_DWC_AUD_CONF1                    (DWC_OFFSET_MASK + 0x3101)
+/* [  3] fifo_empty_mask: 0=enable int; 1=mask int. */
+/* [  2] fifo_full_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_INT                      (DWC_OFFSET_MASK + 0x3102)
+  /* [  1] NLPCM */
+#define HDMITX_DWC_AUD_CONF2                    (DWC_OFFSET_MASK + 0x3103)
+
+/* [  4] fifo_overrun_mask: 0=enable int; 1=mask int.
+ * Enable it later when audio starts.
+ */
+#define HDMITX_DWC_AUD_INT1                     (DWC_OFFSET_MASK + 0x3104)
+
+#define HDMITX_DWC_AUD_N1                       (DWC_OFFSET_MASK + 0x3200)
+#define HDMITX_DWC_AUD_N2                       (DWC_OFFSET_MASK + 0x3201)
+#define HDMITX_DWC_AUD_N3                       (DWC_OFFSET_MASK + 0x3202)
+#define HDMITX_DWC_AUD_CTS1                     (DWC_OFFSET_MASK + 0x3203)
+#define HDMITX_DWC_AUD_CTS2                     (DWC_OFFSET_MASK + 0x3204)
+#define HDMITX_DWC_AUD_CTS3                     (DWC_OFFSET_MASK + 0x3205)
+#define HDMITX_DWC_AUD_INPUTCLKFS               (DWC_OFFSET_MASK + 0x3206)
+/* [  7] sw_audio_fifo_rst */
+#define HDMITX_DWC_AUD_SPDIF0                   (DWC_OFFSET_MASK + 0x3300)
+/* [4:0] spdif_width */
+/* [  7] setnlpcm */
+#define HDMITX_DWC_AUD_SPDIF1                   (DWC_OFFSET_MASK + 0x3301)
+/* [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int. */
+/* [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_SPDIFINT                 (DWC_OFFSET_MASK + 0x3302)
+/* [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_SPDIFINT1                (DWC_OFFSET_MASK + 0x3303)
+
+/* Generic Parallel Audio Interface Registers   (DWC_OFFSET_MASK + 0x3500) */
+/* Audio DMA Registers                          (DWC_OFFSET_MASK + 0x3600) */
+
+/* Main Controller Registers */
+/* [  6] hdcpclk_disable */
+/* [  5] cecclk_disable */
+/* [  4] cscclk_disable */
+/* [  3] audclk_disable */
+/* [  2] prepclk_disable */
+/* [  1] tmdsclk_disable */
+/* [  0] pixelclk_disable */
+#define HDMITX_DWC_MC_CLKDIS                    (DWC_OFFSET_MASK + 0x4001)
+/*
+ * [  7] gpaswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  6] cecswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  4] spdifswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  3] i2sswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  2] prepswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  1] tmdsswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  0] pixelswrst_req: 0=generate reset pulse; 1=no reset.
+ */
+#define HDMITX_DWC_MC_SWRSTZREQ                 (DWC_OFFSET_MASK + 0x4002)
+#define HDMITX_DWC_MC_OPCTRL                    (DWC_OFFSET_MASK + 0x4003)
+/* [  0] CSC enable */
+#define HDMITX_DWC_MC_FLOWCTRL                  (DWC_OFFSET_MASK + 0x4004)
+#define HDMITX_DWC_MC_PHYRSTZ                   (DWC_OFFSET_MASK + 0x4005)
+#define HDMITX_DWC_MC_LOCKONCLOCK               (DWC_OFFSET_MASK + 0x4006)
+
+/* Color Space Converter Registers */
+/* [  7] csc_limit */
+#define HDMITX_DWC_CSC_CFG                      (DWC_OFFSET_MASK + 0x4100)
+#define HDMITX_DWC_CSC_SCALE                    (DWC_OFFSET_MASK + 0x4101)
+#define HDMITX_DWC_CSC_COEF_A1_MSB              (DWC_OFFSET_MASK + 0x4102)
+#define HDMITX_DWC_CSC_COEF_A1_LSB              (DWC_OFFSET_MASK + 0x4103)
+#define HDMITX_DWC_CSC_COEF_A2_MSB              (DWC_OFFSET_MASK + 0x4104)
+#define HDMITX_DWC_CSC_COEF_A2_LSB              (DWC_OFFSET_MASK + 0x4105)
+#define HDMITX_DWC_CSC_COEF_A3_MSB              (DWC_OFFSET_MASK + 0x4106)
+#define HDMITX_DWC_CSC_COEF_A3_LSB              (DWC_OFFSET_MASK + 0x4107)
+#define HDMITX_DWC_CSC_COEF_A4_MSB              (DWC_OFFSET_MASK + 0x4108)
+#define HDMITX_DWC_CSC_COEF_A4_LSB              (DWC_OFFSET_MASK + 0x4109)
+#define HDMITX_DWC_CSC_COEF_B1_MSB              (DWC_OFFSET_MASK + 0x410A)
+#define HDMITX_DWC_CSC_COEF_B1_LSB              (DWC_OFFSET_MASK + 0x410B)
+#define HDMITX_DWC_CSC_COEF_B2_MSB              (DWC_OFFSET_MASK + 0x410C)
+#define HDMITX_DWC_CSC_COEF_B2_LSB              (DWC_OFFSET_MASK + 0x410D)
+#define HDMITX_DWC_CSC_COEF_B3_MSB              (DWC_OFFSET_MASK + 0x410E)
+#define HDMITX_DWC_CSC_COEF_B3_LSB              (DWC_OFFSET_MASK + 0x410F)
+#define HDMITX_DWC_CSC_COEF_B4_MSB              (DWC_OFFSET_MASK + 0x4110)
+#define HDMITX_DWC_CSC_COEF_B4_LSB              (DWC_OFFSET_MASK + 0x4111)
+#define HDMITX_DWC_CSC_COEF_C1_MSB              (DWC_OFFSET_MASK + 0x4112)
+#define HDMITX_DWC_CSC_COEF_C1_LSB              (DWC_OFFSET_MASK + 0x4113)
+#define HDMITX_DWC_CSC_COEF_C2_MSB              (DWC_OFFSET_MASK + 0x4114)
+#define HDMITX_DWC_CSC_COEF_C2_LSB              (DWC_OFFSET_MASK + 0x4115)
+#define HDMITX_DWC_CSC_COEF_C3_MSB              (DWC_OFFSET_MASK + 0x4116)
+#define HDMITX_DWC_CSC_COEF_C3_LSB              (DWC_OFFSET_MASK + 0x4117)
+#define HDMITX_DWC_CSC_COEF_C4_MSB              (DWC_OFFSET_MASK + 0x4118)
+#define HDMITX_DWC_CSC_COEF_C4_LSB              (DWC_OFFSET_MASK + 0x4119)
+#define HDMITX_DWC_CSC_LIMIT_UP_MSB             (DWC_OFFSET_MASK + 0x411A)
+#define HDMITX_DWC_CSC_LIMIT_UP_LSB             (DWC_OFFSET_MASK + 0x411B)
+#define HDMITX_DWC_CSC_LIMIT_DN_MSB             (DWC_OFFSET_MASK + 0x411C)
+#define HDMITX_DWC_CSC_LIMIT_DN_LSB             (DWC_OFFSET_MASK + 0x411D)
+
+/* HDCP Encryption Engine Registers */
+#define HDMITX_DWC_A_HDCPCFG0                   (DWC_SEC_OFFSET_MASK + 0x5000)
+/* [  4] hdcp_lock */
+/* [  3] dissha1check */
+/* [  2] ph2upshiftenc */
+/* [  1] encryptiondisable */
+/* [  0] swresetn. Write 0 to activate, self-clear to 1. */
+#define HDMITX_DWC_A_HDCPCFG1                   (DWC_SEC_OFFSET_MASK + 0x5001)
+#define HDMITX_DWC_A_HDCPOBS0                   (DWC_OFFSET_MASK + 0x5002)
+#define HDMITX_DWC_A_HDCPOBS1                   (DWC_OFFSET_MASK + 0x5003)
+#define HDMITX_DWC_A_HDCPOBS2                   (DWC_OFFSET_MASK + 0x5004)
+#define HDMITX_DWC_A_HDCPOBS3                   (DWC_OFFSET_MASK + 0x5005)
+#define HDMITX_DWC_A_APIINTCLR                  (DWC_OFFSET_MASK + 0x5006)
+#define HDMITX_DWC_A_APIINTSTAT                 (DWC_OFFSET_MASK + 0x5007)
+/* [  7] hdcp_engaged_int_mask */
+/* [  6] hdcp_failed_int_mask */
+/* [  4] i2c_nack_int_mask */
+/* [  3] lost_arbitration_int_mask */
+/* [  2] keepout_error_int_mask */
+/* [  1] ksv_sha1_calc_int_mask */
+/* [  0] ksv_access_int_mask */
+#define HDMITX_DWC_A_APIINTMSK                  (DWC_OFFSET_MASK + 0x5008)
+/* [6:5] unencryptconf */
+/* [  4] dataenpol */
+/* [  3] vsyncpol */
+/* [  1] hsyncpol */
+#define HDMITX_DWC_A_VIDPOLCFG                  (DWC_OFFSET_MASK + 0x5009)
+#define HDMITX_DWC_A_OESSWCFG                   (DWC_OFFSET_MASK + 0x500A)
+#define HDMITX_DWC_A_COREVERLSB                 (DWC_OFFSET_MASK + 0x5014)
+#define HDMITX_DWC_A_COREVERMSB                 (DWC_OFFSET_MASK + 0x5015)
+/* [  3] sha1_fail */
+/* [  2] ksv_ctrl_update */
+/* [  1] Rsvd for read-only ksv_mem_access */
+/* [  0] ksv_mem_request */
+#define HDMITX_DWC_A_KSVMEMCTRL                 (DWC_OFFSET_MASK + 0x5016)
+
+#define HDMITX_DWC_HDCP_BSTATUS_0               (DWC_OFFSET_MASK + 0x5020)
+#define HDMITX_DWC_HDCP_BSTATUS_1               (DWC_OFFSET_MASK + 0x5021)
+#define HDMITX_DWC_HDCP_M0_0                    (DWC_OFFSET_MASK + 0x5022)
+#define HDMITX_DWC_HDCP_M0_1                    (DWC_OFFSET_MASK + 0x5023)
+#define HDMITX_DWC_HDCP_M0_2                    (DWC_OFFSET_MASK + 0x5024)
+#define HDMITX_DWC_HDCP_M0_3                    (DWC_OFFSET_MASK + 0x5025)
+#define HDMITX_DWC_HDCP_M0_4                    (DWC_OFFSET_MASK + 0x5026)
+#define HDMITX_DWC_HDCP_M0_5                    (DWC_OFFSET_MASK + 0x5027)
+#define HDMITX_DWC_HDCP_M0_6                    (DWC_OFFSET_MASK + 0x5028)
+#define HDMITX_DWC_HDCP_M0_7                    (DWC_OFFSET_MASK + 0x5029)
+#define HDMITX_DWC_HDCP_KSV                     (DWC_OFFSET_MASK + 0x502A)
+#define HDMITX_DWC_HDCP_VH                      (DWC_OFFSET_MASK + 0x52A5)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_0            (DWC_OFFSET_MASK + 0x52B9)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_1            (DWC_OFFSET_MASK + 0x52BA)
+#define HDMITX_DWC_HDCP_REVOC_LIST              (DWC_OFFSET_MASK + 0x52BB)
+
+/* HDCP BKSV Registers */
+#define HDMITX_DWC_HDCPREG_BKSV0                (DWC_OFFSET_MASK + 0x7800)
+#define HDMITX_DWC_HDCPREG_BKSV1                (DWC_OFFSET_MASK + 0x7801)
+#define HDMITX_DWC_HDCPREG_BKSV2                (DWC_OFFSET_MASK + 0x7802)
+#define HDMITX_DWC_HDCPREG_BKSV3                (DWC_OFFSET_MASK + 0x7803)
+#define HDMITX_DWC_HDCPREG_BKSV4                (DWC_OFFSET_MASK + 0x7804)
+
+/* HDCP AN Registers */
+#define HDMITX_DWC_HDCPREG_ANCONF               (DWC_OFFSET_MASK + 0x7805)
+#define HDMITX_DWC_HDCPREG_AN0                  (DWC_OFFSET_MASK + 0x7806)
+#define HDMITX_DWC_HDCPREG_AN1                  (DWC_OFFSET_MASK + 0x7807)
+#define HDMITX_DWC_HDCPREG_AN2                  (DWC_OFFSET_MASK + 0x7808)
+#define HDMITX_DWC_HDCPREG_AN3                  (DWC_OFFSET_MASK + 0x7809)
+#define HDMITX_DWC_HDCPREG_AN4                  (DWC_OFFSET_MASK + 0x780A)
+#define HDMITX_DWC_HDCPREG_AN5                  (DWC_OFFSET_MASK + 0x780B)
+#define HDMITX_DWC_HDCPREG_AN6                  (DWC_OFFSET_MASK + 0x780C)
+#define HDMITX_DWC_HDCPREG_AN7                  (DWC_OFFSET_MASK + 0x780D)
+#define HDMITX_DWC_HDCPREG_RMLCTL               (DWC_OFFSET_MASK + 0x780E)
+
+/* Encrypted DPK Embedded Storage Registers */
+#define HDMITX_DWC_HDCPREG_RMLSTS               (DWC_OFFSET_MASK + 0x780F)
+#define HDMITX_DWC_HDCPREG_SEED0                (DWC_SEC_OFFSET_MASK + 0x7810)
+#define HDMITX_DWC_HDCPREG_SEED1                (DWC_SEC_OFFSET_MASK + 0x7811)
+#define HDMITX_DWC_HDCPREG_DPK0                 (DWC_SEC_OFFSET_MASK + 0x7812)
+#define HDMITX_DWC_HDCPREG_DPK1                 (DWC_SEC_OFFSET_MASK + 0x7813)
+#define HDMITX_DWC_HDCPREG_DPK2                 (DWC_SEC_OFFSET_MASK + 0x7814)
+#define HDMITX_DWC_HDCPREG_DPK3                 (DWC_SEC_OFFSET_MASK + 0x7815)
+#define HDMITX_DWC_HDCPREG_DPK4                 (DWC_SEC_OFFSET_MASK + 0x7816)
+#define HDMITX_DWC_HDCPREG_DPK5                 (DWC_SEC_OFFSET_MASK + 0x7817)
+#define HDMITX_DWC_HDCPREG_DPK6                 (DWC_SEC_OFFSET_MASK + 0x7818)
+
+/* HDCP22 Registers */
+#define HDMITX_DWC_HDCP22REG_ID                 (DWC_OFFSET_MASK + 0x7900)
+#define HDMITX_DWC_HDCP22REG_CTRL               (DWC_SEC_OFFSET_MASK + 0x7904)
+#define HDMITX_DWC_HDCP22REG_CTRL1              (DWC_OFFSET_MASK + 0x7905)
+#define HDMITX_DWC_HDCP22REG_STS                (DWC_OFFSET_MASK + 0x7908)
+#define HDMITX_DWC_HDCP22REG_MASK               (DWC_OFFSET_MASK + 0x790C)
+#define HDMITX_DWC_HDCP22REG_STAT               (DWC_OFFSET_MASK + 0x790D)
+#define HDMITX_DWC_HDCP22REG_MUTE               (DWC_OFFSET_MASK + 0x790E)
+
+
+/* ********** CEC related ********** */
+
+/* CEC 2.0 Engine Registers */
+#define HDMITX_DWC_CEC_CTRL                     (DWC_OFFSET_MASK + 0x7D00)
+#define HDMITX_DWC_CEC_INTR_MASK                (DWC_OFFSET_MASK + 0x7D02)
+#define HDMITX_DWC_CEC_LADD_LOW                 (DWC_OFFSET_MASK + 0x7D05)
+#define HDMITX_DWC_CEC_LADD_HIGH                (DWC_OFFSET_MASK + 0x7D06)
+#define HDMITX_DWC_CEC_TX_CNT                   (DWC_OFFSET_MASK + 0x7D07)
+#define HDMITX_DWC_CEC_RX_CNT                   (DWC_OFFSET_MASK + 0x7D08)
+#define HDMITX_DWC_CEC_TX_DATA00                (DWC_OFFSET_MASK + 0x7D10)
+#define HDMITX_DWC_CEC_TX_DATA01                (DWC_OFFSET_MASK + 0x7D11)
+#define HDMITX_DWC_CEC_TX_DATA02                (DWC_OFFSET_MASK + 0x7D12)
+#define HDMITX_DWC_CEC_TX_DATA03                (DWC_OFFSET_MASK + 0x7D13)
+#define HDMITX_DWC_CEC_TX_DATA04                (DWC_OFFSET_MASK + 0x7D14)
+#define HDMITX_DWC_CEC_TX_DATA05                (DWC_OFFSET_MASK + 0x7D15)
+#define HDMITX_DWC_CEC_TX_DATA06                (DWC_OFFSET_MASK + 0x7D16)
+#define HDMITX_DWC_CEC_TX_DATA07                (DWC_OFFSET_MASK + 0x7D17)
+#define HDMITX_DWC_CEC_TX_DATA08                (DWC_OFFSET_MASK + 0x7D18)
+#define HDMITX_DWC_CEC_TX_DATA09                (DWC_OFFSET_MASK + 0x7D19)
+#define HDMITX_DWC_CEC_TX_DATA10                (DWC_OFFSET_MASK + 0x7D1A)
+#define HDMITX_DWC_CEC_TX_DATA11                (DWC_OFFSET_MASK + 0x7D1B)
+#define HDMITX_DWC_CEC_TX_DATA12                (DWC_OFFSET_MASK + 0x7D1C)
+#define HDMITX_DWC_CEC_TX_DATA13                (DWC_OFFSET_MASK + 0x7D1D)
+#define HDMITX_DWC_CEC_TX_DATA14                (DWC_OFFSET_MASK + 0x7D1E)
+#define HDMITX_DWC_CEC_TX_DATA15                (DWC_OFFSET_MASK + 0x7D1F)
+#define HDMITX_DWC_CEC_RX_DATA00                (DWC_OFFSET_MASK + 0x7D20)
+#define HDMITX_DWC_CEC_RX_DATA01                (DWC_OFFSET_MASK + 0x7D21)
+#define HDMITX_DWC_CEC_RX_DATA02                (DWC_OFFSET_MASK + 0x7D22)
+#define HDMITX_DWC_CEC_RX_DATA03                (DWC_OFFSET_MASK + 0x7D23)
+#define HDMITX_DWC_CEC_RX_DATA04                (DWC_OFFSET_MASK + 0x7D24)
+#define HDMITX_DWC_CEC_RX_DATA05                (DWC_OFFSET_MASK + 0x7D25)
+#define HDMITX_DWC_CEC_RX_DATA06                (DWC_OFFSET_MASK + 0x7D26)
+#define HDMITX_DWC_CEC_RX_DATA07                (DWC_OFFSET_MASK + 0x7D27)
+#define HDMITX_DWC_CEC_RX_DATA08                (DWC_OFFSET_MASK + 0x7D28)
+#define HDMITX_DWC_CEC_RX_DATA09                (DWC_OFFSET_MASK + 0x7D29)
+#define HDMITX_DWC_CEC_RX_DATA10                (DWC_OFFSET_MASK + 0x7D2A)
+#define HDMITX_DWC_CEC_RX_DATA11                (DWC_OFFSET_MASK + 0x7D2B)
+#define HDMITX_DWC_CEC_RX_DATA12                (DWC_OFFSET_MASK + 0x7D2C)
+#define HDMITX_DWC_CEC_RX_DATA13                (DWC_OFFSET_MASK + 0x7D2D)
+#define HDMITX_DWC_CEC_RX_DATA14                (DWC_OFFSET_MASK + 0x7D2E)
+#define HDMITX_DWC_CEC_RX_DATA15                (DWC_OFFSET_MASK + 0x7D2F)
+#define HDMITX_DWC_CEC_LOCK_BUF                 (DWC_OFFSET_MASK + 0x7D30)
+#define HDMITX_DWC_CEC_WAKEUPCTRL               (DWC_OFFSET_MASK + 0x7D31)
+
+/* I2C Master Registers(E-DDC/SCDC) */
+#define HDMITX_DWC_I2CM_SLAVE                   (DWC_OFFSET_MASK + 0x7E00)
+#define HDMITX_DWC_I2CM_ADDRESS                 (DWC_OFFSET_MASK + 0x7E01)
+#define HDMITX_DWC_I2CM_DATAO                   (DWC_OFFSET_MASK + 0x7E02)
+#define HDMITX_DWC_I2CM_DATAI                   (DWC_OFFSET_MASK + 0x7E03)
+#define HDMITX_DWC_I2CM_OPERATION               (DWC_OFFSET_MASK + 0x7E04)
+/* [  2] done_mask */
+/* [  6] read_req_mask */
+#define HDMITX_DWC_I2CM_INT                     (DWC_OFFSET_MASK + 0x7E05)
+/* [  6] nack_mask */
+/* [  2] arbitration_error_mask */
+#define HDMITX_DWC_I2CM_CTLINT                  (DWC_OFFSET_MASK + 0x7E06)
+/* [  3] i2c_fast_mode: 0=standard mode; 1=fast mode. */
+#define HDMITX_DWC_I2CM_DIV                     (DWC_OFFSET_MASK + 0x7E07)
+#define HDMITX_DWC_I2CM_SEGADDR                 (DWC_OFFSET_MASK + 0x7E08)
+#define HDMITX_DWC_I2CM_SOFTRSTZ                (DWC_OFFSET_MASK + 0x7E09)
+#define HDMITX_DWC_I2CM_SEGPTR                  (DWC_OFFSET_MASK + 0x7E0A)
+/* I2CM_SS_SCL_HCNT = RndUp(min_ss_scl_htime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_SS_SCL_LCNT = RndUp(min_ss_scl_ltime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_FS_SCL_HCNT = RndUp(min_fs_scl_htime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_FS_SCL_LCNT = RndUp(min_fs_scl_ltime*Freq(sfrclkInMHz)/1000) */
+/* Where Freq(sfrclkInMHz)=24; */
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0B)
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E0C)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E0D)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E0E)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0F)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E10)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E11)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E12)
+#define HDMITX_DWC_I2CM_SDA_HOLD                (DWC_OFFSET_MASK + 0x7E13)
+/* [  5] updt_rd_vsyncpoll_en */
+/* [  4] read_request_en */
+/* [  0] read_update */
+#define HDMITX_DWC_I2CM_SCDC_UPDATE             (DWC_OFFSET_MASK + 0x7E14)
+#define HDMITX_DWC_I2CM_READ_BUFF0              (DWC_OFFSET_MASK + 0x7E20)
+#define HDMITX_DWC_I2CM_READ_BUFF1              (DWC_OFFSET_MASK + 0x7E21)
+#define HDMITX_DWC_I2CM_READ_BUFF2              (DWC_OFFSET_MASK + 0x7E22)
+#define HDMITX_DWC_I2CM_READ_BUFF3              (DWC_OFFSET_MASK + 0x7E23)
+#define HDMITX_DWC_I2CM_READ_BUFF4              (DWC_OFFSET_MASK + 0x7E24)
+#define HDMITX_DWC_I2CM_READ_BUFF5              (DWC_OFFSET_MASK + 0x7E25)
+#define HDMITX_DWC_I2CM_READ_BUFF6              (DWC_OFFSET_MASK + 0x7E26)
+#define HDMITX_DWC_I2CM_READ_BUFF7              (DWC_OFFSET_MASK + 0x7E27)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE0            (DWC_OFFSET_MASK + 0x7E30)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE1            (DWC_OFFSET_MASK + 0x7E31)
+
+#endif  /* __HDMI_TX_REG_H_ */
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_set.c b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_set.c
new file mode 100644
index 0000000..0d7ed0a
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_set.c
@@ -0,0 +1,2224 @@
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/register.h>
+#include <amlogic/hdmi.h>
+#include "hdmitx_reg.h"
+#include "hdmitx_tvenc.h"
+#include "mach_reg.h"
+#include "hw_enc_clk_config.h"
+
+struct hdmitx_dev hdmitx_device;
+
+static void hdmi_tvenc_set(enum hdmi_vic vic);
+extern void _udelay(unsigned int us);
+
+#define HSYNC_POLARITY      1                       // HSYNC polarity: active high
+#define VSYNC_POLARITY      1                       // VSYNC polarity: active high
+
+#define TX_COLOR_DEPTH          HDMI_COLOR_DEPTH_24B    // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+#define TX_INPUT_COLOR_FORMAT   HDMI_COLOR_FORMAT_444   // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+#define TX_OUTPUT_COLOR_FORMAT  HDMI_COLOR_FORMAT_444   // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+#define TX_INPUT_COLOR_RANGE    HDMI_COLOR_RANGE_LIM    // Pixel range: 0=limited; 1=full.
+#define TX_OUTPUT_COLOR_RANGE   HDMI_COLOR_RANGE_LIM    // Pixel range: 0=limited; 1=full.
+
+// TODO  Delete later
+#define CLK_UTIL_VID_PLL_DIV_1      0
+#define CLK_UTIL_VID_PLL_DIV_2      1
+#define CLK_UTIL_VID_PLL_DIV_3      2
+#define CLK_UTIL_VID_PLL_DIV_3p5    3
+#define CLK_UTIL_VID_PLL_DIV_3p75   4
+#define CLK_UTIL_VID_PLL_DIV_4      5
+#define CLK_UTIL_VID_PLL_DIV_5      6
+#define CLK_UTIL_VID_PLL_DIV_6      7
+#define CLK_UTIL_VID_PLL_DIV_6p25   8
+#define CLK_UTIL_VID_PLL_DIV_7      9
+#define CLK_UTIL_VID_PLL_DIV_7p5    10
+#define CLK_UTIL_VID_PLL_DIV_12     11
+#define CLK_UTIL_VID_PLL_DIV_14     12
+#define CLK_UTIL_VID_PLL_DIV_15     13
+
+static void hdelay(int us)
+{
+	int i;
+	while (us--) {
+		i = 10000;
+		while (i--) ;
+	}
+}
+
+#define mdelay(i)   hdelay(i)
+#define msleep(i)   hdelay(i)
+
+static void hdmitx_set_hw(struct hdmitx_dev *hdev);
+
+// Internal functions:
+static void hdmitx_csc_config (unsigned char input_color_format,
+                        unsigned char output_color_format,
+                        unsigned char color_depth);
+
+static void dump_regs(void)
+{
+	unsigned int reg_adr;
+	unsigned int reg_val;
+	unsigned int ladr;
+	for (reg_adr = 0x0000; reg_adr < 0x0100; reg_adr ++) {
+                ladr = 0xc883c000 + (reg_adr << 2);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x]=0x%08x\n", ladr, reg_val);
+	}
+#define VPU_REG_ADDR(reg) (0xd0100000 + (reg << 2))
+	for (reg_adr = 0x1b00; reg_adr < 0x1c00; reg_adr ++) {
+		ladr = VPU_REG_ADDR(reg_adr);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x]=0x%08x\n", ladr, reg_val);
+	}
+	for (reg_adr = 0x1c30; reg_adr < 0x1c40; reg_adr ++) {
+		ladr = VPU_REG_ADDR(reg_adr);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x]=0x%08x\n", ladr, reg_val);
+	}
+	for (reg_adr = 0x2700; reg_adr < 0x2780; reg_adr ++) {
+		ladr = VPU_REG_ADDR(reg_adr);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x]=0x%08x\n", ladr, reg_val);
+	}
+	for (reg_adr = HDMITX_TOP_SW_RESET; reg_adr < HDMITX_TOP_STAT0 + 1; reg_adr ++) {
+		reg_val = hdmitx_rd_reg(reg_adr);
+		printk("TOP[0x%x]: 0x%x\n", reg_adr, reg_val);
+	}
+	for (reg_adr = HDMITX_DWC_DESIGN_ID; reg_adr < HDMITX_DWC_I2CM_SCDC_UPDATE1 + 1; reg_adr ++) {
+		if ((reg_adr > HDMITX_DWC_HDCP_BSTATUS_0 -1) && (reg_adr < HDMITX_DWC_HDCPREG_BKSV0)) {
+            //hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x1);
+//            hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1<<1), 2 * HZ);
+			reg_val = 0;//hdmitx_rd_reg(reg_adr);
+		} else {
+			reg_val = hdmitx_rd_reg(reg_adr);
+		}
+		if (reg_val) {
+			// excluse HDCP regisiters
+			if ((reg_adr < HDMITX_DWC_A_HDCPCFG0) || (reg_adr > HDMITX_DWC_CEC_CTRL))
+				printk("DWC[0x%x]: 0x%x\n", reg_adr, reg_val);
+		}
+	}
+}
+
+static int hdmitx_get_hpd_state(void)
+{
+	int st = 0;
+
+	st = !!(hd_read_reg(P_PREG_PAD_GPIO1_I) & (1 << 20));
+	return st;
+}
+
+static void hdmitx_hw_init(void)
+{
+	static int hw_init_flag;
+
+	if (hw_init_flag)
+		return;
+	else
+		hw_init_flag = 1;
+
+	/* Enable clocks and bring out of reset */
+
+	/* Enable hdmitx_sys_clk */
+	/* .clk0 ( cts_oscin_clk ), */
+	/* .clk1 ( fclk_div4 ), */
+	/* .clk2 ( fclk_div3 ), */
+	/* .clk3 ( fclk_div5 ), */
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 0x0100, 0, 16);
+
+	/* Enable clk81_hdmitx_pclk */
+	hd_set_reg_bits(P_HHI_GCLK_MPEG2, 1, 4, 1);
+
+	/* wire	wr_enable = control[3]; */
+	/* wire	fifo_enable = control[2]; */
+	/* assign phy_clk_en = control[1]; */
+	/* Enable tmds_clk */
+	/* Bring HDMITX MEM output of power down */
+	hd_set_reg_bits(P_HHI_MEM_PD_REG0, 0, 8, 8);
+	/* reset HDMITX APB & TX & PHY */
+	hd_set_reg_bits(P_RESET0_REGISTER, 1, 19, 1);
+	hd_set_reg_bits(P_RESET2_REGISTER, 1, 15, 1);
+	hd_set_reg_bits(P_RESET2_REGISTER, 1,  2, 1);
+	// Enable APB3 fail on error
+	hd_set_reg_bits(P_HDMITX_CTRL_PORT, 1, 15, 1);
+	hd_set_reg_bits((P_HDMITX_CTRL_PORT + 0x10), 1, 15, 1);
+	/* Bring out of reset */
+	hdmitx_wr_reg(HDMITX_TOP_SW_RESET,  0);
+	_udelay(200);
+	/* Enable internal pixclk, tmds_clk, spdif_clk, i2s_clk, cecclk */
+	hdmitx_wr_reg(HDMITX_TOP_CLK_CNTL,  0x0000003f);
+	hdmitx_wr_reg(HDMITX_DWC_MC_LOCKONCLOCK, 0xff);
+
+	hdmitx_wr_reg(HDMITX_DWC_MC_CLKDIS, 0x00);
+}
+
+/*
+ * Note: read 8 Bytes of EDID data every time
+ */
+static int read_edid_8bytes(unsigned char *rx_edid, unsigned char addr)
+{
+	unsigned int timeout = 0;
+	unsigned int i = 0;
+	// Program SLAVE/SEGMENT/ADDR
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, 0x50);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR, 0x30);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, addr & 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 3);
+	timeout = 0;
+	while ((!(hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 1))) && (timeout < 3)) {
+		mdelay(2);
+		timeout ++;
+	}
+	if (timeout == 3) {
+		printk("ddc timeout\n");
+		return 0;
+	}
+	hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0, 1 << 1);        // clear INT
+	// Read back 8 bytes
+	for (i = 0; i < 8; i ++) {
+		rx_edid[i] = hdmitx_rd_reg(HDMITX_DWC_I2CM_READ_BUFF0 + i);
+	}
+	return 1;
+}
+
+static void ddc_init(void)
+{
+	static int ddc_init_flag;
+	unsigned int data32 = 0;
+
+
+	if (ddc_init_flag)
+		return;
+	else
+		ddc_init_flag = 1;
+
+//--------------------------------------------------------------------------
+// Configure E-DDC interface
+//--------------------------------------------------------------------------
+	hd_set_reg_bits(P_PAD_PULL_UP_EN_REG1, 0, 19, 2);    // Disable GPIOH_3/4 pull-up/down
+	hd_set_reg_bits(P_PAD_PULL_UP_REG1, 0, 19, 2);
+	hd_set_reg_bits(P_PREG_PAD_GPIO1_EN_N, 3, 2, 2);     // GPIOH_3/4 input
+	hd_set_reg_bits(P_PERIPHS_PIN_MUX_1, 3, 24, 2);      // Mux DDC SDA/SCL
+
+	data32  = 0;
+	data32 |= (0    << 6);  // [  6] read_req_mask
+	data32 |= (0    << 2);  // [  2] done_mask
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_INT,      data32);
+
+	data32  = 0;
+	data32 |= (0    << 6);  // [  6] nack_mask
+	data32 |= (0    << 2);  // [  2] arbitration_error_mask
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_CTLINT,   data32);
+
+	data32  = 0;
+	data32 |= (0    << 3);  // [  3] i2c_fast_mode: 0=standard mode; 1=fast mode.
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_DIV,      data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_HCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_HCNT_0, 0x67);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_LCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_LCNT_0, 0x78);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_HCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_HCNT_0, 0x0f);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_LCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_LCNT_0, 0x20);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SDA_HOLD,	0x08);
+
+	data32  = 0;
+	data32 |= (0    << 5);  // [  5] updt_rd_vsyncpoll_en
+	data32 |= (0    << 4);  // [  4] read_request_en  // scdc
+	data32 |= (0    << 0);  // [  0] read_update
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SCDC_UPDATE,  data32);
+}
+
+static int hdmitx_read_edid(unsigned char *buf, unsigned char addr, unsigned char size)
+{
+	ddc_init();
+	if ((addr + size) > 256)
+		return 0;
+	return read_edid_8bytes(buf, addr);
+}
+
+static void scdc_rd_sink(unsigned char adr, unsigned char *val)
+{
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, 0x54);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, adr);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1);
+	_udelay(2000);
+	*val = (unsigned char)hdmitx_rd_reg(HDMITX_DWC_I2CM_DATAI);
+}
+
+static void scdc_wr_sink(unsigned char adr, unsigned char val)
+{
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, 0x54);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, adr);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_DATAO, val);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 0x10);
+	_udelay(2000);
+}
+
+static void scdc_prepare(void)
+{
+	unsigned char rx_ver = 0;
+
+	scdc_rd_sink(SINK_VER, &rx_ver);
+	if (rx_ver != 1)
+		scdc_rd_sink(SINK_VER, &rx_ver);	/* Recheck */
+	printf("hdmirx version is %s\n", (rx_ver == 1) ? "2.0" : "1.4 or below");
+	if (rx_ver == 1) {
+		scdc_wr_sink(SOURCE_VER, 0x1);
+		scdc_wr_sink(SOURCE_VER, 0x1);
+		scdc_wr_sink(TMDS_CFG, 0x3); /* TMDS 1/40 & Scramble */
+		scdc_wr_sink(TMDS_CFG, 0x3); /* TMDS 1/40 & Scramble */
+	}
+}
+
+static void hdmitx_turnoff(void)
+{
+        /* Close HDMITX PHY */
+        hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0);
+        hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0);
+        /* Disable HPLL */
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0);
+}
+
+static struct hdmi_support_mode gxbb_modes[] = {
+	{HDMI_1920x1080p60_16x9, "1080p60hz", 0},
+	{HDMI_1920x1080p50_16x9, "1080p50hz", 0},
+	{HDMI_1920x1080p24_16x9, "1080p24hz", 0},
+	{HDMI_3840x2160p30_16x9, "2160p30hz", 0},
+	{HDMI_3840x2160p60_16x9, "2160p60hz", 0},
+	{HDMI_3840x2160p50_16x9, "2160p50hz", 0},
+	{HDMI_3840x2160p60_16x9, "2160p60hz420", 1},
+	{HDMI_3840x2160p50_16x9, "2160p50hz420", 1},
+	{HDMI_3840x2160p25_16x9, "2160p25hz", 0},
+	{HDMI_3840x2160p24_16x9, "2160p24hz", 0},
+	{HDMI_4096x2160p24_256x135, "smpte24hz", 0},
+	{HDMI_1920x1080i60_16x9, "1080i60hz", 0},
+	{HDMI_1920x1080i50_16x9, "1080i50hz", 0},
+	{HDMI_1280x720p60_16x9, "720p60hz", 0},
+	{HDMI_1280x720p50_16x9, "720p50hz", 0},
+	{HDMI_720x480p60_16x9, "480p60hz", 0},
+	{HDMI_720x480i60_16x9, "480i60hz", 0},
+	{HDMI_720x576p50_16x9, "576p50hz", 0},
+	{HDMI_720x576i50_16x9, "576i50hz", 0},
+};
+
+static void hdmitx_list_support_modes(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(gxbb_modes); i++)
+		printf("%s\n", gxbb_modes[i].sname);
+}
+
+static void hdmitx_test_bist(unsigned int mode)
+{
+	switch (mode) {
+	case 1:
+	case 2:
+	case 3:
+		hd_set_reg_bits(P_ENCP_VIDEO_MODE_ADV, 0, 3, 1);
+		hd_write_reg(P_VENC_VIDEO_TST_EN, 1);
+		hd_write_reg(P_VENC_VIDEO_TST_MDSEL, mode);
+		break;
+	case 0:
+	default:
+		hd_set_reg_bits(P_ENCP_VIDEO_MODE_ADV, 1, 3, 1);
+		hd_write_reg(P_VENC_VIDEO_TST_EN, 0);
+		break;
+	}
+}
+
+void hdmi_tx_init(void)
+{
+	hdmitx_device.HWOp.get_hpd_state = hdmitx_get_hpd_state;
+	hdmitx_device.HWOp.read_edid = hdmitx_read_edid;
+	hdmitx_device.HWOp.turn_off = hdmitx_turnoff;
+	hdmitx_device.HWOp.list_support_modes = hdmitx_list_support_modes;
+	hdmitx_device.HWOp.dump_regs = dump_regs;
+	hdmitx_device.HWOp.test_bist = hdmitx_test_bist;
+}
+
+void hdmi_tx_set(struct hdmitx_dev *hdev)
+{
+	hdmitx_hw_init();
+	hdmitx_debug();
+	ddc_init();
+	switch (hdev->vic) {
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_3840x2160p50_16x9:
+		if (hdev->mode420 == 0)
+			scdc_prepare();
+		break;
+	default:
+		break;
+	}
+	hdmitx_set_hw(hdev);
+	hdmitx_debug();
+	return;
+
+#if 0
+	hdmi_tx_gate(vic);
+	hdmi_tx_clk(vic);
+	hdmi_tx_misc(vic);
+	hdmi_tx_enc(vic);
+	hdmi_tx_set_vend_spec_infofram(vic);
+	hdmi_tx_phy(vic);
+#endif
+}
+
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+static void hdcp14_init(void)
+{
+	register long x0 asm("x0") = 0x82000012;
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc #0\n"
+		: : "r"(x0)
+	);
+}
+
+#define NUM_INT_VSYNC   INT_VEC_VIU1_VSYNC
+
+static unsigned long modulo(unsigned long a, unsigned long b);
+static signed int to_signed(unsigned int a);
+
+static void config_hdmi20_tx ( enum hdmi_vic vic, struct hdmi_format_para *para,
+                        unsigned char   color_depth,            // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+                        unsigned char   input_color_format,     // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                        unsigned char   input_color_range,      // Pixel range: 0=limited; 1=full.
+                        unsigned char   output_color_format,    // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                        unsigned char   output_color_range     // Pixel range: 0=limited; 1=full.
+                    )          // 0:TMDS_CLK_rate=TMDS_Character_rate; 1:TMDS_CLK_rate=TMDS_Character_rate/4, for TMDS_Character_rate>340Mcsc.
+{
+	struct hdmi_cea_timing *t = &para->timing;
+	unsigned long   data32;
+	unsigned char   vid_map;
+	unsigned char   csc_en;
+	unsigned char   default_phase = 0;
+
+#define GET_TIMING(name)      (t->name)
+
+	hdmitx_hw_init();
+
+	/* Enable normal output to PHY */
+
+	switch (vic) {
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+		para->tmds_clk_div40 = 1;
+		break;
+	default:
+		break;
+	}
+
+	data32  = 0;
+	data32 |= (1 << 12);
+	data32 |= (0 << 8);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_TOP_BIST_CNTL, data32);
+
+	/* Configure video */
+
+    // Configure video sampler
+
+    vid_map = ( input_color_format == HDMI_COLOR_FORMAT_RGB )?  ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x01    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x03    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_36B)? 0x05    :
+                                                                                                        0x07)   :
+              ((input_color_format == HDMI_COLOR_FORMAT_444) ||
+               (input_color_format == HDMI_COLOR_FORMAT_420))?  ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x09    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x0b    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_36B)? 0x0d    :
+                                                                                                        0x0f)   :
+                                                                ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x16    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x14    :
+                                                                                                        0x12);
+
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (vid_map << 0);
+	hdmitx_wr_reg(HDMITX_DWC_TX_INVID0, data32);
+
+	data32  = 0;
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_TX_INSTUFFING, data32);
+	hdmitx_wr_reg(HDMITX_DWC_TX_GYDATA0, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_GYDATA1, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_RCRDATA0, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_RCRDATA1, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_BCBDATA0, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_BCBDATA1, 0x00);
+
+	/* Configure Color Space Converter */
+
+	csc_en  = (input_color_format != output_color_format) ? 1 : 0;
+
+	data32  = 0;
+	data32 |= (csc_en   << 0);
+	hdmitx_wr_reg(HDMITX_DWC_MC_FLOWCTRL, data32);
+
+    data32  = 0;
+    data32 |= ((((input_color_format ==HDMI_COLOR_FORMAT_422) &&
+                 (output_color_format!=HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 4);  // [5:4] intmode
+    data32 |= ((((input_color_format !=HDMI_COLOR_FORMAT_422) &&
+                 (output_color_format==HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 0);  // [1:0] decmode
+	hdmitx_wr_reg(HDMITX_DWC_CSC_CFG, data32);
+
+	hdmitx_csc_config(input_color_format, output_color_format, color_depth);
+
+	/* Configure video packetizer */
+
+	/* Video Packet color depth and pixel repetition */
+	data32  = 0;
+    data32 |= (((output_color_format==HDMI_COLOR_FORMAT_422)? HDMI_COLOR_DEPTH_24B : color_depth)   << 4);  // [7:4] color_depth
+	data32 |= (0 << 0);
+	if ((data32 & 0xf0) == 0x40 )
+		data32 &= ~(0xf << 4);
+	hdmitx_wr_reg(HDMITX_DWC_VP_PR_CD,  data32);
+
+	/* Video Packet Stuffing */
+	data32  = 0;
+	data32 |= (default_phase << 5);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_VP_STUFF,  data32);
+
+	/* Video Packet YCC color remapping */
+	data32  = 0;
+	data32 |= (((color_depth == HDMI_COLOR_DEPTH_30B)? 1 :
+                (color_depth == HDMI_COLOR_DEPTH_36B)? 2 : 0)   << 0);  // [1:0] ycc422_size
+	hdmitx_wr_reg(HDMITX_DWC_VP_REMAP, data32);
+
+	/* Video Packet configuration */
+	data32  = 0;
+	data32 |= ((((output_color_format != HDMI_COLOR_FORMAT_422) &&
+                 (color_depth         == HDMI_COLOR_DEPTH_24B))? 1 : 0) << 6);  // [  6] bypass_en
+	data32 |= ((((output_color_format == HDMI_COLOR_FORMAT_422) ||
+                 (color_depth         == HDMI_COLOR_DEPTH_24B))? 0 : 1) << 5);  // [  5] pp_en
+	data32 |= (0                                                        << 4);  // [  4] pr_en
+	data32 |= (((output_color_format == HDMI_COLOR_FORMAT_422)?  1 : 0) << 3);  // [  3] ycc422_en
+	data32 |= (1                                                        << 2);  // [  2] pr_bypass_select
+	data32 |= (((output_color_format == HDMI_COLOR_FORMAT_422)? 1 :
+                (color_depth         == HDMI_COLOR_DEPTH_24B)?  2 : 0)  << 0);  // [1:0] output_selector: 0=pixel packing; 1=YCC422 remap; 2/3=8-bit bypass
+	hdmitx_wr_reg(HDMITX_DWC_VP_CONF,   data32);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_VP_MASK, data32);
+
+	/* Configure audio */
+	/* I2S Sampler config */
+
+	data32  = 0;
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT, data32);
+
+	data32  = 0;
+	data32 |= (1 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,  data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_MULTISTREAM_CTRL, 0);
+
+/* if enable it now, fifo_overrun will happen, because packet don't get
+ * sent out until initial DE detected.
+ */
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (1 << 5);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF0, data32);
+
+	data32  = 0;
+	data32 |= (0 << 5);
+	data32 |= (24   << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF1, data32);
+
+	data32  = 0;
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF2, data32);
+
+	/* spdif sampler config */
+
+	data32  = 0;
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT,  data32);
+
+	data32  = 0;
+	data32 |= (0 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT1, data32);
+
+	data32  = 0;
+	data32 |= (0 << 7);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF0,	data32);
+
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (0 << 6);
+	data32 |= (24 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF1,	data32);
+
+	/* Frame Composer configuration */
+
+	/* Video definitions, as per output video(for packet gen/schedulling) */
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (GET_TIMING(vsync_polarity) << 6);
+	data32 |= (GET_TIMING(hsync_polarity) << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (!(para->progress_mode) << 1);
+	data32 |= (!(para->progress_mode) << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVIDCONF,  data32);
+
+	data32  = GET_TIMING(h_active)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV0,   data32);
+	data32  = (GET_TIMING(h_active)>>8) & 0x3f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV1,   data32);
+
+	data32  = GET_TIMING(h_blank) & 0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK0,  data32);
+	data32  = (GET_TIMING(h_blank)>>8)&0x1f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK1,  data32);
+
+	data32  = GET_TIMING(v_active)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV0,   data32);
+	data32  = (GET_TIMING(v_active)>>8)&0x1f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV1,   data32);
+
+	data32  = GET_TIMING(v_blank)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVBLANK,   data32);
+
+	data32  = GET_TIMING(h_front)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY0,  data32);
+	data32  = (GET_TIMING(h_front)>>8)&0x1f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY1,  data32);
+
+	data32  = GET_TIMING(h_sync)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH0,  data32);
+	data32  = (GET_TIMING(h_sync)>>8)&0x3;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH1,  data32);
+
+	data32  = GET_TIMING(v_front)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINDELAY,   data32);
+
+	data32  = GET_TIMING(v_sync)&0x3f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINWIDTH,   data32);
+
+	/* control period duration (typ 12 tmds periods) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_CTRLDUR,	12);
+	/* extended control period duration (typ 32 tmds periods) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_EXCTRLDUR,  32);
+	/* max interval betwen extended control period duration (typ 50) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_EXCTRLSPAC, 1);
+	/* preamble filler */
+	hdmitx_wr_reg(HDMITX_DWC_FC_CH0PREAM, 0x0b);
+	hdmitx_wr_reg(HDMITX_DWC_FC_CH1PREAM, 0x16);
+	hdmitx_wr_reg(HDMITX_DWC_FC_CH2PREAM, 0x21);
+
+	/* write GCP packet configuration */
+	data32  = 0;
+	data32 |= (default_phase << 2);
+	data32 |= (0 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_GCP, data32);
+
+	/* write AVI Infoframe packet configuration */
+
+	data32  = 0;
+	data32 |= (((output_color_format>>2)&0x1) << 7);
+	data32 |= (1 << 6);
+	data32 |= (0 << 4);
+	data32 |= (0 << 2);
+	data32 |= (0x2 << 0);    /* FIXED YCBCR 444 */
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF0, data32);
+
+	data32  = 0;
+	data32 |= (0 << 6);
+	data32 |= (0 << 4);
+	data32 |= (8 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF1, data32);
+
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (0 << 4);
+	data32 |= (0 << 2);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF2, data32);
+
+	data32  = 0;
+	data32 |= (((output_color_range == HDMI_COLOR_RANGE_FUL)?1:0)   << 2);  // [3:2] YQ
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF3,   data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, para->vic);
+
+/* the audio setting bellow are only used for I2S audio IEC60958-3 frame
+ * insertion
+ */
+
+
+	/* packet queue priority (auto mode) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_CTRLQHIGH,  15);
+	hdmitx_wr_reg(HDMITX_DWC_FC_CTRLQLOW, 3);
+
+	/* packet scheduller configuration for SPD, VSD, ISRC1/2, ACP. */
+	data32  = 0;
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO0, data32);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO2, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATMAN, 0);
+
+	/* packet scheduller configuration for AVI, GCP, AUDI, ACR. */
+	data32  = 0;
+	data32 |= (0 << 5);
+	data32 |= (0 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO3, data32);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB0,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB1,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB2,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB3,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB4,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB5,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB6,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB7,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB8,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB9,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB10, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB11, 0);
+
+	/* Packet transmission enable */
+	data32  = 0;
+	data32 |= (0 << 6);
+	data32 |= (0 << 5);
+	data32 |= (0 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_PACKET_TX_EN, data32);
+
+	/* For 3D video */
+	data32  = 0;
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_ACTSPC_HDLR_CFG, data32);
+
+	data32  = GET_TIMING(v_active)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACT_2D_0,	data32);
+	data32  = (GET_TIMING(v_active)>>8)&0xf;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACT_2D_1,	data32);
+
+	/* Do not enable these interrupt below, we can check them at RX side. */
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_MASK0,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_MASK1,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_MASK2,  data32);
+
+	/* Pixel repetition ratio the input and output video */
+	data32  = 0;
+	data32 |= ((para->pixel_repetition_factor+1) << 4);
+	data32 |= (para->pixel_repetition_factor << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_PRCONF, data32);
+
+	/* Scrambler control */
+	data32  = 0;
+	data32 |= (0 << 4);
+	data32 |= (para->scrambler_en << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_SCRAMBLER_CTRL, data32);
+
+	/* Configure HDCP */
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (0 << 6);
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_A_APIINTMSK, data32);
+
+	data32  = 0;
+	data32 |= (0 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 1);
+	hdmitx_wr_reg(HDMITX_DWC_A_VIDPOLCFG,   data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_A_OESSWCFG,    0x40);
+
+	hdcp14_init();
+
+	/* Interrupts */
+	/* Clear interrupts */
+	hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT0,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT1,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT2,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_AS_STAT0,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_PHY_STAT0, 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0,	0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_CEC_STAT0, 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_VP_STAT0,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_I2CMPHY_STAT0, 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_STAT, 0xff);
+
+	hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR,	0x0000001f);
+
+	/* Selectively enable/mute interrupt sources */
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT0,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT1,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT2,  data32);
+
+	data32  = 0;
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_AS_STAT0,  data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_PHY_STAT0, 0x3f);
+
+	data32  = 0;
+	data32 |= (0 << 2);
+	data32 |= (1 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CM_STAT0, data32);
+
+	data32  = 0;
+	data32 |= (0 << 6);
+	data32 |= (0 << 5);
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_CEC_STAT0, data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_VP_STAT0,  0xff);
+
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0, 0x03);
+
+	data32  = 0;
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE, data32);
+
+	data32  = 0;
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_TOP_INTR_MASKN, data32);
+
+	/* Reset pulse */
+	hdmitx_rd_check_reg(HDMITX_DWC_MC_LOCKONCLOCK, 0xff, 0x9f);
+	hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, 0);
+	mdelay(10);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (0 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, data32);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINWIDTH,
+		hdmitx_rd_reg(HDMITX_DWC_FC_VSYNCINWIDTH));
+
+} /* config_hdmi20_tx */
+
+/* Set TV encoder for HDMI */
+static void hdmitx_enc(enum hdmi_vic vic)
+{
+	set_vmode_enc_hw(vic);
+	hdmi_tvenc_set(vic);
+	return;
+}
+
+static void hdmitx_set_pll(struct hdmitx_dev *hdev)
+{
+        set_hdmitx_clk(hdev->vic);
+        if (hdev->mode420 == 1)
+                set_hdmitx_clk_420();
+}
+
+static void hdmitx_set_phy(struct hdmitx_dev *hdev)
+{
+	if (!hdev)
+		return;
+
+	switch (hdev->vic) {
+        case HDMI_3840x2160p50_16x9:
+        case HDMI_3840x2160p60_16x9:
+        case HDMI_4096x2160p50_256x135:
+        case HDMI_4096x2160p60_256x135:
+                if (hdev->mode420 == 1) {
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33634283);
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0xb000115b);
+                } else {
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33353245);
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2100115b);
+                }
+                break;
+        case HDMI_3840x2160p24_16x9:
+        case HDMI_3840x2160p25_16x9:
+        case HDMI_3840x2160p30_16x9:
+        case HDMI_4096x2160p24_256x135:
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33634283);
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0xb000115b);
+                break;
+        case HDMI_1920x1080p60_16x9:
+        default:
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33632122);
+                hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2000115b);
+        break;
+	}
+/* P_HHI_HDMI_PHY_CNTL1	bit[1]: enable clock	bit[0]: soft reset */
+#define RESET_HDMI_PHY() \
+do { \
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xf, 0, 4); \
+	mdelay(2); \
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xe, 0, 4); \
+	mdelay(2); \
+} while (0)
+
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0390, 16, 16);
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x1, 17, 1);
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0, 0, 4);
+	RESET_HDMI_PHY();
+	RESET_HDMI_PHY();
+	RESET_HDMI_PHY();
+#undef RESET_HDMI_PHY
+
+	printk("hdmitx phy setting done\n");
+}
+
+/*
+ * mode: 1 means Progressive;  0 means interlaced
+ */
+static void enc_vpu_bridge_reset(int mode)
+{
+    unsigned int wr_clk = 0;
+
+    printk("%s[%d]\n", __func__, __LINE__);
+    wr_clk = (hd_read_reg(P_VPU_HDMI_SETTING) & 0xf00) >> 8;
+    if (mode) {
+        hd_write_reg(P_ENCP_VIDEO_EN, 0);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 0, 2);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 8, 4);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        mdelay(1);
+        hd_write_reg(P_ENCP_VIDEO_EN, 1);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, wr_clk, 8, 4);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 2, 0, 2);  // [    0] src_sel_enci: Enable ENCP output to HDMI
+    } else {
+        hd_write_reg(P_ENCI_VIDEO_EN, 0);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 0, 2);  // [    0] src_sel_enci: Disable ENCI output to HDMI
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 8, 4);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        mdelay(1);
+        hd_write_reg(P_ENCI_VIDEO_EN, 1);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, wr_clk, 8, 4);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 2);  // [    0] src_sel_enci: Enable ENCI output to HDMI
+    }
+}
+
+static void hdmi_tvenc1080i_set(enum hdmi_vic vic)
+{
+	unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2;
+	unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+	unsigned FRONT_PORCH = 88, HSYNC_PIXELS = 0, ACTIVE_LINES = 0,
+		INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0,
+		VSYNC_LINES = 0;
+	unsigned LINES_F0 = 0, LINES_F1 = 563, BACK_PORCH = 0;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0,
+		vs_bline_odd = 0, vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+	if (vic == HDMI_1920x1080i60_16x9) {
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 562;
+		LINES_F1 = 563;
+		FRONT_PORCH = 88;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 15;
+	} else if (vic == HDMI_1920x1080i50_16x9) {
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 562;
+		LINES_F1 = 563;
+		FRONT_PORCH = 528;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 15;
+	}
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+	TOTAL_LINES = (LINES_F0+(LINES_F1*INTERLACE_MODE));
+
+	total_pixels_venc = (TOTAL_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	hsync_pixels_venc =
+		(HSYNC_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
+
+	hd_write_reg(P_ENCP_VIDEO_MODE, hd_read_reg(P_ENCP_VIDEO_MODE)|(1<<14));
+
+	/* Program DE timing */
+	de_h_begin = modulo(hd_read_reg(P_ENCP_VIDEO_HAVON_BEGIN) +
+		VFIFO2VD_TO_HDMI_LATENCY, total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DE_H_BEGIN, de_h_begin);
+	hd_write_reg(P_ENCP_DE_H_END, de_h_end);
+	/* Program DE timing for even field */
+	de_v_begin_even = hd_read_reg(P_ENCP_VIDEO_VAVON_BLINE);
+	de_v_end_even  = de_v_begin_even + ACTIVE_LINES;
+	hd_write_reg(P_ENCP_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCP_DE_V_END_EVEN,  de_v_end_even);
+	/* Program DE timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		de_v_begin_odd = to_signed((
+			hd_read_reg(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4)
+			+ de_v_begin_even + (TOTAL_LINES-1)/2;
+		de_v_end_odd = de_v_begin_odd + ACTIVE_LINES;
+		hd_write_reg(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);/* 583 */
+		hd_write_reg(P_ENCP_DE_V_END_ODD, de_v_end_odd);  /* 1123 */
+	}
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 0;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
+	hd_write_reg(P_ENCP_DVI_HSO_END, hs_end);
+
+	/* Program Vsync timing for even field */
+	if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust))
+		vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES
+			- (1-vs_adjust);
+	else
+		vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES
+			- VSYNC_LINES - (1-vs_adjust);
+
+	vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   /* 0 */
+	hd_write_reg(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   /* 5 */
+	vso_begin_evn = hs_begin; /* 2 */
+	hd_write_reg(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  /* 2 */
+	hd_write_reg(P_ENCP_DVI_VSO_END_EVN, vso_begin_evn);  /* 2 */
+	/* Program Vsync timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+		vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_END_ODD, vso_begin_odd);
+	}
+
+	hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+		(0 << 1) |
+		(HSYNC_POLARITY << 2) |
+		(VSYNC_POLARITY << 3) |
+		(0 << 4) |
+		(4 << 5) |
+		(0 << 8) |
+		(0 << 12)
+	);
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+
+}
+
+static void hdmi_tvenc4k2k_set(enum hdmi_vic vic)
+{
+	unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2;
+	unsigned long TOTAL_PIXELS = 4400, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 3840;
+	unsigned FRONT_PORCH = 1020, HSYNC_PIXELS = 0, ACTIVE_LINES = 2160,
+		INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0,
+		VSYNC_LINES = 0;
+	unsigned LINES_F0 = 2250, LINES_F1 = 2250, BACK_PORCH = 0;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0, vs_bline_odd = 0,
+		vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+	if ((vic == HDMI_3840x2160p30_16x9) ||
+		(vic == HDMI_3840x2160p60_16x9)) {
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (3840*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 176;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+	} else if ((vic == HDMI_3840x2160p25_16x9) ||
+		(vic == HDMI_3840x2160p50_16x9)) {
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (3840*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 1056;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+	} else if (vic == HDMI_3840x2160p24_16x9) {
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (3840*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 1276;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+	} else if (vic == HDMI_4096x2160p24_256x135) {
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (4096*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 1020;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+	}
+
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+	TOTAL_LINES = (LINES_F0+(LINES_F1*INTERLACE_MODE));
+
+	total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+
+	de_h_begin = modulo(hd_read_reg(P_ENCP_VIDEO_HAVON_BEGIN) +
+		VFIFO2VD_TO_HDMI_LATENCY, total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DE_H_BEGIN, de_h_begin);
+	hd_write_reg(P_ENCP_DE_H_END, de_h_end);
+	/* Program DE timing for even field */
+	de_v_begin_even = hd_read_reg(P_ENCP_VIDEO_VAVON_BLINE);
+	de_v_end_even  = modulo(de_v_begin_even + ACTIVE_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCP_DE_V_END_EVEN,  de_v_end_even);
+	/* Program DE timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		de_v_begin_odd = to_signed(
+			(hd_read_reg(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4)
+			+ de_v_begin_even + (TOTAL_LINES-1)/2;
+		de_v_end_odd = modulo(de_v_begin_odd + ACTIVE_LINES,
+			TOTAL_LINES);
+		hd_write_reg(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
+		hd_write_reg(P_ENCP_DE_V_END_ODD, de_v_end_odd);
+	}
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 1;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
+	hd_write_reg(P_ENCP_DVI_HSO_END, hs_end);
+
+	/* Program Vsync timing for even field */
+	if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust))
+		vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES
+			- (1-vs_adjust);
+	else
+		vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES
+			- VSYNC_LINES - (1-vs_adjust);
+	vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);
+	hd_write_reg(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);
+	vso_begin_evn = hs_begin;
+	hd_write_reg(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);
+	hd_write_reg(P_ENCP_DVI_VSO_END_EVN, vso_begin_evn);
+	/* Program Vsync timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+		vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_END_ODD, vso_begin_odd);
+	}
+	hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+			(0 << 1) |
+			(HSYNC_POLARITY << 2) |
+			(VSYNC_POLARITY << 3) |
+			(0 << 4) |
+			(4 << 5) |
+			(0 << 8) |
+			(0 << 12)
+	);
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+	hd_write_reg(P_ENCP_VIDEO_EN, 1);
+}
+
+static void hdmi_tvenc480i_set(enum hdmi_vic vic)
+{
+	unsigned long VFIFO2VD_TO_HDMI_LATENCY = 1;
+	unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+	unsigned FRONT_PORCH = 38, HSYNC_PIXELS = 124, ACTIVE_LINES = 0,
+		INTERLACE_MODE = 0, VSYNC_LINES = 0;
+	unsigned LINES_F0 = 262, LINES_F1 = 263, BACK_PORCH = 114,
+		EOF_LINES = 2;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0,
+		vs_bline_odd = 0, vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+	hd_set_reg_bits(P_HHI_GCLK_OTHER, 1, 8, 1);
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 1;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (480/(1+INTERLACE_MODE));
+		LINES_F0 = 262;
+		LINES_F1 = 263;
+		FRONT_PORCH = 38;
+		HSYNC_PIXELS = 124;
+		BACK_PORCH = 114;
+		EOF_LINES = 4;
+		VSYNC_LINES = 3;
+                break;
+	case HDMI_720x576i50_16x9:
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 1;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (576/(1+INTERLACE_MODE));
+		LINES_F0 = 312;
+		LINES_F1 = 313;
+		FRONT_PORCH = 24;
+		HSYNC_PIXELS = 126;
+		BACK_PORCH = 138;
+		EOF_LINES = 2;
+		VSYNC_LINES = 3;
+		break;
+	default:
+		break;
+	}
+
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+
+	total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC); /* 1716 / 2 * 2 = 1716 */
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC); /* 38   / 2 * 2 = 38 */
+	hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC); /* 124  / 2 * 2 = 124 */
+
+	de_h_begin = modulo(hd_read_reg(P_ENCI_VFIFO2VD_PIXEL_START) +
+		VFIFO2VD_TO_HDMI_LATENCY, total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCI_DE_H_BEGIN, de_h_begin);	/* 235 */
+	hd_write_reg(P_ENCI_DE_H_END, de_h_end);	 /* 1675 */
+
+	de_v_begin_even = hd_read_reg(P_ENCI_VFIFO2VD_LINE_TOP_START);
+	de_v_end_even  = de_v_begin_even + ACTIVE_LINES;
+	de_v_begin_odd = hd_read_reg(P_ENCI_VFIFO2VD_LINE_BOT_START);
+	de_v_end_odd = de_v_begin_odd + ACTIVE_LINES;
+	hd_write_reg(P_ENCI_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCI_DE_V_END_EVEN,  de_v_end_even);
+	hd_write_reg(P_ENCI_DE_V_BEGIN_ODD, de_v_begin_odd);
+	hd_write_reg(P_ENCI_DE_V_END_ODD, de_v_end_odd);
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 0;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCI_DVI_HSO_BEGIN,  hs_begin);  /* 1713 */
+	hd_write_reg(P_ENCI_DVI_HSO_END, hs_end);	/* 121 */
+
+	/* Program Vsync timing for even field */
+	if (de_v_end_odd-1 + EOF_LINES + vs_adjust >= LINES_F1) {
+		vs_bline_evn = de_v_end_odd-1 + EOF_LINES + vs_adjust
+			- LINES_F1;
+		vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn);
+		/* vso_bline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+		/* vso_eline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_EVN, hs_begin);
+		hd_write_reg(P_ENCI_DVI_VSO_END_EVN, hs_begin);
+	} else {
+		vs_bline_odd = de_v_end_odd-1 + EOF_LINES + vs_adjust;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		/* vso_bline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_ODD, hs_begin);
+	if (vs_bline_odd + VSYNC_LINES >= LINES_F1) {
+		vs_eline_evn = vs_bline_odd + VSYNC_LINES - LINES_F1;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+		/* vso_eline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_EVN, hs_begin);
+	} else {
+		vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		/* vso_eline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_ODD, hs_begin);
+	}
+	}
+	/* Program Vsync timing for odd field */
+	if (de_v_end_even-1 + EOF_LINES + 1 >= LINES_F0) {
+		vs_bline_odd = de_v_end_even-1 + EOF_LINES + 1 - LINES_F0;
+		vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		/* vso_bline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		/* vso_eline_odd_reg_wr_cnt ++; */
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCI_DVI_VSO_END_ODD, vso_begin_odd);
+	} else {
+		vs_bline_evn = de_v_end_even-1 + EOF_LINES + 1;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn); /* 261 */
+		/* vso_bline_evn_reg_wr_cnt ++; */
+		vso_begin_evn  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_EVN, vso_begin_evn);
+	if (vs_bline_evn + VSYNC_LINES >= LINES_F0) {
+		vs_eline_odd = vs_bline_evn + VSYNC_LINES - LINES_F0;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		/* vso_eline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_ODD, vso_begin_evn);
+	} else {
+		vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+		/* vso_eline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_EVN, vso_begin_evn);
+	}
+	}
+
+	hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+			(0 << 1) |
+			(0 << 2) |
+			(0 << 3) |
+			(0 << 4) |
+			(4 << 5) |
+			(1 << 8) |
+			(1 << 12)
+	);
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 1);
+}
+
+static void hdmi_tvenc_set_def(enum hdmi_vic vic)
+{
+        unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2;
+	unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+	unsigned FRONT_PORCH = 0, HSYNC_PIXELS = 0, ACTIVE_LINES = 0,
+		INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0,
+		VSYNC_LINES = 0;
+	unsigned LINES_F0 = 0, LINES_F1 = 0, BACK_PORCH = 0;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0,
+		vs_bline_odd = 0, vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+        hdmitx_debug();
+	switch (vic) {
+	case HDMI_720x480p60_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (480/(1+INTERLACE_MODE));
+		LINES_F0 = 525;
+		LINES_F1 = 525;
+		FRONT_PORCH = 16;
+		HSYNC_PIXELS = 62;
+		BACK_PORCH = 60;
+		VSYNC_LINES = 6;
+		SOF_LINES = 30;
+		break;
+	case HDMI_720x576p50_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (576/(1+INTERLACE_MODE));
+		LINES_F0 = 625;
+		LINES_F1 = 625;
+		FRONT_PORCH = 12;
+		HSYNC_PIXELS = 64;
+		BACK_PORCH = 68;
+		VSYNC_LINES = 5;
+		SOF_LINES = 39;
+		break;
+	case HDMI_1280x720p60_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (1280*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (720/(1+INTERLACE_MODE));
+		LINES_F0 = 750;
+		LINES_F1 = 750;
+		FRONT_PORCH = 110;
+		HSYNC_PIXELS = 40;
+		BACK_PORCH = 220;
+		VSYNC_LINES = 5;
+		SOF_LINES = 20;
+		break;
+	case HDMI_1280x720p50_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (1280*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (720/(1+INTERLACE_MODE));
+		LINES_F0 = 750;
+		LINES_F1 = 750;
+		FRONT_PORCH = 440;
+		HSYNC_PIXELS = 40;
+		BACK_PORCH = 220;
+		VSYNC_LINES = 5;
+		SOF_LINES = 20;
+		break;
+	case HDMI_1920x1080p50_16x9:
+		INTERLACE_MODE	= 0;
+		PIXEL_REPEAT_VENC  = 0;
+		PIXEL_REPEAT_HDMI  = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 1125;
+		LINES_F1 = 1125;
+		FRONT_PORCH = 528;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 36;
+		break;
+	case HDMI_1920x1080p24_16x9:
+		INTERLACE_MODE	= 0;
+		PIXEL_REPEAT_VENC  = 0;
+		PIXEL_REPEAT_HDMI  = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 1125;
+		LINES_F1 = 1125;
+		FRONT_PORCH = 638;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 36;
+		break;
+	case HDMI_1920x1080p60_16x9:
+	case HDMI_1920x1080p30_16x9:
+		INTERLACE_MODE	= 0;
+		PIXEL_REPEAT_VENC  = 0;
+		PIXEL_REPEAT_HDMI  = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 1125;
+		LINES_F1 = 1125;
+		FRONT_PORCH = 88;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 36;
+		break;
+	default:
+		break;
+	}
+
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+	TOTAL_LINES = (LINES_F0+(LINES_F1*INTERLACE_MODE));
+
+	total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+
+	hd_write_reg(P_ENCP_VIDEO_MODE, hd_read_reg(P_ENCP_VIDEO_MODE)|(1<<14));
+	/* Program DE timing */
+	de_h_begin = modulo(hd_read_reg(P_ENCP_VIDEO_HAVON_BEGIN) +
+		VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DE_H_BEGIN, de_h_begin);	/* 220 */
+	hd_write_reg(P_ENCP_DE_H_END, de_h_end);	 /* 1660 */
+	/* Program DE timing for even field */
+	de_v_begin_even = hd_read_reg(P_ENCP_VIDEO_VAVON_BLINE);
+	de_v_end_even  = de_v_begin_even + ACTIVE_LINES;
+	hd_write_reg(P_ENCP_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCP_DE_V_END_EVEN,  de_v_end_even);	/* 522 */
+	/* Program DE timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		de_v_begin_odd = to_signed(
+			(hd_read_reg(P_ENCP_VIDEO_OFLD_VOAV_OFST)
+			& 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
+		de_v_end_odd = de_v_begin_odd + ACTIVE_LINES;
+		hd_write_reg(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
+		hd_write_reg(P_ENCP_DE_V_END_ODD, de_v_end_odd);
+	}
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 0;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
+	hd_write_reg(P_ENCP_DVI_HSO_END, hs_end);
+
+	/* Program Vsync timing for even field */
+	if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust))
+		vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES -
+			(1-vs_adjust);
+	else
+		vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES -
+			VSYNC_LINES - (1-vs_adjust);
+	vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   /* 5 */
+	hd_write_reg(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   /* 11 */
+	vso_begin_evn = hs_begin; /* 1692 */
+	hd_write_reg(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  /* 1692 */
+	hd_write_reg(P_ENCP_DVI_VSO_END_EVN, vso_begin_evn);  /* 1692 */
+	/* Program Vsync timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+		vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_END_ODD, vso_begin_odd);
+	}
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(0 << 2) |
+				(0 << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(1 << 8) |
+				(1 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 1);
+		break;
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(HSYNC_POLARITY << 2) |
+				(VSYNC_POLARITY << 3) |
+				(0 << 4) |
+				(((TX_INPUT_COLOR_FORMAT == 0) ? 1 : 0) << 5) |
+				(1 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		break;
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+			(0 << 1) |
+			(HSYNC_POLARITY << 2) |
+			(VSYNC_POLARITY << 3) |
+			(0 << 4) |
+			(4 << 5) |
+			(0 << 8) |
+			(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		hd_write_reg(P_ENCP_VIDEO_EN, 1); /* Enable VENC */
+		break;
+	case HDMI_720x480p60_16x9:
+	case HDMI_720x576p50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(0 << 2) |
+				(0 << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(1 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		break;
+	case HDMI_1280x720p60_16x9:
+	case HDMI_1280x720p50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(HSYNC_POLARITY << 2) |
+				(VSYNC_POLARITY << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(1 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		break;
+	default:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) | /* [	1] src_sel_encp */
+				(HSYNC_POLARITY << 2) |
+				(VSYNC_POLARITY << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(0 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+	}
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+}
+
+static void hdmi_tvenc_set(enum hdmi_vic vic)
+{
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		hdmi_tvenc480i_set(vic);
+		break;
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		hdmi_tvenc1080i_set(vic);
+		break;
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+		hdmi_tvenc4k2k_set(vic);
+		break;
+	default:
+		hdmi_tvenc_set_def(vic);
+                break;
+	}
+
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (1                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 1);  // [    0] src_sel_enci: Enable ENCI output to HDMI
+		break;
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		break;
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                  << 0) | // [    0] src_sel_enci
+                     (0                                 << 1) | // [    1] src_sel_encp
+                     (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                     (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                     (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                     (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                //                          0=output CrYCb(BRG);
+                                                                //                          1=output YCbCr(RGB);
+                                                                //                          2=output YCrCb(RBG);
+                                                                //                          3=output CbCrY(GBR);
+                                                                //                          4=output CbYCr(GRB);
+                                                                //                          5=output CrCbY(BGR);
+                                                                //                          6,7=Rsrv.
+                     (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                     (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		hd_write_reg(P_ENCP_VIDEO_EN, 1); // Enable VENC
+		break;
+	case HDMI_720x480p60_16x9:
+	case HDMI_720x576p50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		break;
+	case HDMI_1280x720p60_16x9:
+	case HDMI_1280x720p50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		break;
+	default:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+	}
+}
+
+static void mode420_half_horizontal_para(void)
+{
+	unsigned int hactive = 0;
+	unsigned int hblank = 0;
+	unsigned int hfront = 0;
+	unsigned int hsync = 0;
+
+	printk("%s[%d]\n", __func__, __LINE__);
+	hactive  =  hdmitx_rd_reg(HDMITX_DWC_FC_INHACTV0);
+	hactive += (hdmitx_rd_reg(HDMITX_DWC_FC_INHACTV1) & 0x3f) << 8;
+	hblank  =  hdmitx_rd_reg(HDMITX_DWC_FC_INHBLANK0);
+	hblank += (hdmitx_rd_reg(HDMITX_DWC_FC_INHBLANK1) & 0x1f) << 8;
+	hfront  =  hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINDELAY0);
+	hfront += (hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINDELAY1) & 0x1f) << 8;
+	hsync  =  hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINWIDTH0);
+	hsync += (hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINWIDTH1) & 0x3) << 8;
+
+	hactive = hactive / 2;
+	hblank = hblank / 2;
+	hfront = hfront / 2;
+	hsync = hsync / 2;
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV0, (hactive & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV1, ((hactive >> 8) & 0x3f));
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK0, (hblank  & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK1, ((hblank >> 8) & 0x1f));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY0, (hfront & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY1, ((hfront >> 8) & 0x1f));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH0, (hsync & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH1, ((hsync >> 8) & 0x3));
+}
+
+static void set_tmds_clk_div40(unsigned int div40)
+{
+	if (div40 == 1) {
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, 0);		  // [25:16] tmds_clk_pttn[19:10]  [ 9: 0] tmds_clk_pttn[ 9: 0]
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, 0x03ff03ff); // [25:16] tmds_clk_pttn[39:30]  [ 9: 0] tmds_clk_pttn[29:20]
+	}
+	else {
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, 0x001f001f);
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, 0x001f001f);
+	}
+
+	hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x1);			// 0xc
+	msleep(10);
+	hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x2);            // 0xc
+}
+
+static void hdmitx_set_vsi_pkt(enum hdmi_vic vic)
+{
+	/* convert to HDMI_VIC */
+	if (vic == HDMI_3840x2160p30_16x9)
+		vic = 1;
+	else if (vic == HDMI_3840x2160p25_16x9)
+		vic = 2;
+	else if (vic == HDMI_3840x2160p24_16x9)
+		vic = 3;
+	else
+		vic = 4;
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID0, 0x03);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID1, 0x0c);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID2, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD0, 0x20);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, vic);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDSIZE, 5);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO0, 1, 3, 1);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO2, 0x10);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 4, 1);
+}
+
+/* record HDMITX current format */
+/* ISA_DEBUG_REG0 0x2600
+ * bit[11]: Y420
+ * bit[10:8]: HDMI VIC
+ * bit[7:0]: CEA VIC
+ */
+static void save_hdmitx_format(enum hdmi_vic vic, int y420)
+{
+	unsigned int data32;
+
+	data32 = vic & 0xff;
+	data32 |= (hdmitx_rd_reg(HDMITX_DWC_FC_VSDPAYLOAD1) & 0x7) << 8;
+	data32 |= (!!y420) << 11;
+	hd_write_reg(P_ISA_DEBUG_REG0, data32);
+}
+
+static void hdmitx_set_vdac(unsigned int enable)
+{
+	if (0 == enable)
+	{
+		hd_write_reg(P_HHI_VDAC_CNTL0, 0);
+		hd_write_reg(P_HHI_VDAC_CNTL1, 8);
+	}
+	else if (1 == enable)
+	{
+		hd_write_reg(P_HHI_VDAC_CNTL0, 1);
+		hd_write_reg(P_HHI_VDAC_CNTL1, 0);
+	}
+
+	return ;
+}
+
+static void hdmitx_set_hw(struct hdmitx_dev* hdev)
+{
+	struct hdmi_format_para *para = NULL;
+
+	para = hdmi_get_fmt_paras(hdev->vic);
+	if (para == NULL) {
+		printk("error at %s[%d]\n", __func__, __LINE__);
+		return;
+	}
+
+	hdmitx_set_pll(hdev);
+	hdmitx_set_phy(hdev);
+	hdmitx_enc(hdev->vic);
+	hdmitx_set_vdac(0);
+
+	// --------------------------------------------------------
+	// Set up HDMI
+	// --------------------------------------------------------
+	config_hdmi20_tx(hdev->vic, para,                     // pixel_repeat,
+		TX_COLOR_DEPTH,                        // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+		TX_INPUT_COLOR_FORMAT,                 // input_color_format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+		TX_INPUT_COLOR_RANGE,                  // input_color_range: 0=limited; 1=full.
+		TX_OUTPUT_COLOR_FORMAT,                // output_color_format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+		TX_OUTPUT_COLOR_RANGE                 // output_color_range: 0=limited; 1=full.
+		);
+
+	/* switch HDMI_VIC for 2160p30/25/24hz */
+	switch (hdev->vic) {
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_4096x2160p24_256x135:
+		hdmitx_set_vsi_pkt(hdev->vic);
+		break;
+	default:
+		break;
+	}
+
+	/* Using ISA_DEBUG_REG0 to record HDMITX current format */
+	save_hdmitx_format(hdev->vic, hdev->mode420);
+
+	hd_write_reg(P_VPU_HDMI_FMT_CTRL,(((TX_INPUT_COLOR_FORMAT==HDMI_COLOR_FORMAT_420)?2:0)  << 0) | // [ 1: 0] hdmi_vid_fmt. 0=444; 1=convert to 422; 2=convert to 420.
+						 (2													 << 2) | // [ 3: 2] chroma_dnsmp. 0=use pixel 0; 1=use pixel 1; 2=use average.
+						 (0													 << 4) | // [	4] dith_en. 1=enable dithering before HDMI TX input.
+						 (0													 << 5) | // [	5] hdmi_dith_md: random noise selector.
+						 (0													 << 6)); // [ 9: 6] hdmi_dith10_cntl.
+	if (hdev->mode420 == 1) {
+		hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 2, 0, 2);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 4, 4);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 8, 1);
+		hdmitx_wr_reg(HDMITX_DWC_FC_SCRAMBLER_CTRL, 0);
+	}
+	switch (hdev->vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		enc_vpu_bridge_reset(0);
+		break;
+	default:
+		enc_vpu_bridge_reset(1);
+		break;
+	}
+
+	//hdmi_hw_reset(hdev, param);
+	// move hdmitx_set_pll() to the end of this function.
+	// hdmitx_set_pll(param);
+
+	if (hdev->mode420 == 1) {
+		hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF0, 0x43);	// change AVI packet
+		mode420_half_horizontal_para();
+	}
+	if (((hdev->vic == HDMI_3840x2160p50_16x9) || (hdev->vic == HDMI_3840x2160p60_16x9))
+	   && (hdev->mode420 != 1)){
+		set_tmds_clk_div40(1);
+	} else {
+		set_tmds_clk_div40(0);
+	}
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 0, 3, 1);
+	msleep(1);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 3, 1);
+}
+
+// Use this self-made function rather than %, because % appears to produce wrong
+// value for divisor which are not 2's exponential.
+static unsigned long modulo(unsigned long a, unsigned long b)
+{
+	if (a >= b) {
+		return(a-b);
+	} else {
+		return(a);
+	}
+}
+
+static signed int to_signed(unsigned int a)
+{
+	if (a <= 7) {
+		return(a);
+	} else {
+		return(a-16);
+	}
+}
+
+// TODO
+static void hdmitx_csc_config (unsigned char input_color_format,
+                        unsigned char output_color_format,
+                        unsigned char color_depth)
+{
+	unsigned char   conv_en;
+	unsigned long   csc_coeff_a1, csc_coeff_a2, csc_coeff_a3, csc_coeff_a4;
+	unsigned long   csc_coeff_b1, csc_coeff_b2, csc_coeff_b3, csc_coeff_b4;
+	unsigned long   csc_coeff_c1, csc_coeff_c2, csc_coeff_c3, csc_coeff_c4;
+	unsigned char   csc_scale;
+	unsigned long   data32;
+
+	conv_en = (((input_color_format  == HDMI_COLOR_FORMAT_RGB) ||
+                (output_color_format == HDMI_COLOR_FORMAT_RGB)) &&
+               ( input_color_format  != output_color_format))? 1 : 0;
+
+	if (conv_en) {
+		if (output_color_format == HDMI_COLOR_FORMAT_RGB) {
+			csc_coeff_a1    = 0x2000;
+			csc_coeff_a2    = 0x6926;
+			csc_coeff_a3    = 0x74fd;
+			csc_coeff_a4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x010e :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x043b :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x10ee :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x10ee : 0x010e;
+			csc_coeff_b1    = 0x2000;
+			csc_coeff_b2    = 0x2cdd;
+			csc_coeff_b3    = 0x0000;
+			csc_coeff_b4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x7e9a :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x7a65 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x6992 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x6992 : 0x7e9a;
+			csc_coeff_c1    = 0x2000;
+			csc_coeff_c2    = 0x0000;
+			csc_coeff_c3    = 0x38b4;
+			csc_coeff_c4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x7e3b :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x78ea :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x63a6 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x63a6 : 0x7e3b;
+			csc_scale       = 1;
+		} else {    // input_color_format == HDMI_COLOR_FORMAT_RGB
+			csc_coeff_a1    = 0x2591;
+			csc_coeff_a2    = 0x1322;
+			csc_coeff_a3    = 0x074b;
+			csc_coeff_a4    = 0x0000;
+			csc_coeff_b1    = 0x6535;
+			csc_coeff_b2    = 0x2000;
+			csc_coeff_b3    = 0x7acc;
+			csc_coeff_b4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x0200 :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x0800 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x2000 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x2000 : 0x0200;
+			csc_coeff_c1    = 0x6acd;
+			csc_coeff_c2    = 0x7534;
+			csc_coeff_c3    = 0x2000;
+			csc_coeff_c4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x0200 :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x0800 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x2000 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x2000 : 0x0200;
+			csc_scale       = 0;
+		}
+	} else {
+		csc_coeff_a1    = 0x2000;
+		csc_coeff_a2    = 0x0000;
+		csc_coeff_a3    = 0x0000;
+		csc_coeff_a4    = 0x0000;
+		csc_coeff_b1    = 0x0000;
+		csc_coeff_b2    = 0x2000;
+		csc_coeff_b3    = 0x0000;
+		csc_coeff_b4    = 0x0000;
+		csc_coeff_c1    = 0x0000;
+		csc_coeff_c2    = 0x0000;
+		csc_coeff_c3    = 0x2000;
+		csc_coeff_c4    = 0x0000;
+		csc_scale       = 1;
+	}
+
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A1_MSB,   (csc_coeff_a1>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A1_LSB,	csc_coeff_a1&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A2_MSB,   (csc_coeff_a2>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A2_LSB,	csc_coeff_a2&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A3_MSB,   (csc_coeff_a3>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A3_LSB,	csc_coeff_a3&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A4_MSB,   (csc_coeff_a4>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A4_LSB,	csc_coeff_a4&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B1_MSB,   (csc_coeff_b1>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B1_LSB,	csc_coeff_b1&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B2_MSB,   (csc_coeff_b2>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B2_LSB,	csc_coeff_b2&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B3_MSB,   (csc_coeff_b3>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B3_LSB,	csc_coeff_b3&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B4_MSB,   (csc_coeff_b4>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B4_LSB,	csc_coeff_b4&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C1_MSB,   (csc_coeff_c1>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C1_LSB,	csc_coeff_c1&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C2_MSB,   (csc_coeff_c2>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C2_LSB,	csc_coeff_c2&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C3_MSB,   (csc_coeff_c3>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C3_LSB,	csc_coeff_c3&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C4_MSB,   (csc_coeff_c4>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C4_LSB,	csc_coeff_c4&0xff	  );
+
+	data32  = 0;
+	data32 |= (color_depth  << 4);  // [7:4] csc_color_depth
+	data32 |= (csc_scale	<< 0);  // [1:0] cscscale
+	hdmitx_wr_reg(HDMITX_DWC_CSC_SCALE,         data32);
+}   /* hdmitx_csc_config */
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_tvenc.c b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_tvenc.c
new file mode 100644
index 0000000..abb17f0
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_tvenc.c
@@ -0,0 +1,584 @@
+#include "mach_reg.h"
+#include "hdmitx_tvenc.h"
+
+#define MREG_END_MARKER 0xFFFF
+
+static const struct reg_t tvregs_720p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+
+	{P_VENC_DVI_SETTING, 0x2029},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_YFP1_HTIME, 648},
+	{P_ENCP_VIDEO_YFP2_HTIME, 3207},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3299},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 80},
+	{P_ENCP_VIDEO_HSPULS_END, 240},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 80},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 688},
+	{P_ENCP_VIDEO_VSPULS_END, 3248},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 4},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 8},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 648},
+	{P_ENCP_VIDEO_HAVON_END, 3207},
+	{P_ENCP_VIDEO_VAVON_BLINE, 29},
+	{P_ENCP_VIDEO_VAVON_ELINE, 748},
+	{P_ENCP_VIDEO_HSO_BEGIN, 256},
+	{P_ENCP_VIDEO_HSO_END, 168},
+	{P_ENCP_VIDEO_VSO_BEGIN, 168},
+	{P_ENCP_VIDEO_VSO_END, 256},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_MAX_LNCNT, 749},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x000a},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_720p_50hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x202d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3959},
+	{P_ENCP_VIDEO_MAX_LNCNT, 749},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 80},
+	{P_ENCP_VIDEO_HSPULS_END, 240},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 80},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 648},
+	{P_ENCP_VIDEO_HAVON_END, 3207},
+	{P_ENCP_VIDEO_HSO_BEGIN, 128},
+	{P_ENCP_VIDEO_HSO_END, 208},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 688},
+	{P_ENCP_VIDEO_VSPULS_END, 3248},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 4},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 8},
+	{P_ENCP_VIDEO_VAVON_BLINE, 29},
+	{P_ENCP_VIDEO_VAVON_ELINE, 748},
+	{P_ENCP_VIDEO_VSO_BEGIN, 128},
+	{P_ENCP_VIDEO_VSO_END, 128},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 648},
+	{P_ENCP_VIDEO_YFP2_HTIME, 3207},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x407},
+	{P_ENCP_VIDEO_YC_DLY, 0},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x000a},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_480i[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCI_CFILT_CTRL, 0x12},
+	{P_ENCI_CFILT_CTRL2, 0x12},
+	{P_VENC_DVI_SETTING, 0},
+	{P_ENCI_VIDEO_MODE, 0},
+	{P_ENCI_VIDEO_MODE_ADV, 0},
+	{P_ENCI_SYNC_HSO_BEGIN, 5},
+	{P_ENCI_SYNC_HSO_END, 129},
+	{P_ENCI_SYNC_VSO_EVNLN, 0x0003},
+	{P_ENCI_SYNC_VSO_ODDLN, 0x0104},
+	{P_ENCI_MACV_MAX_AMP, 0x810b},
+	{P_VENC_VIDEO_PROG_MODE, 0xf0},
+	{P_ENCI_VIDEO_MODE, 0x08},
+	{P_ENCI_VIDEO_MODE_ADV, 0x26},
+	{P_ENCI_VIDEO_SCH, 0x20},
+	{P_ENCI_SYNC_MODE, 0x07},
+	{P_ENCI_DBG_PX_RST, 0},
+	{P_ENCI_VFIFO2VD_CTL, 0x4e01},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x0005},
+	{P_ENCI_DACSEL_0, 0x0011},
+	{P_ENCI_DACSEL_1, 0x87},
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_480p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x2052},
+	{P_VENC_DVI_SETTING, 0x21},
+	{P_ENCP_VIDEO_MODE, 0x4000},
+	{P_ENCP_VIDEO_MODE_ADV, 9},
+	{P_ENCP_VIDEO_YFP1_HTIME, 244},
+	{P_ENCP_VIDEO_YFP2_HTIME, 1630},
+	{P_ENCP_VIDEO_MAX_PXCNT, 1715},
+	{P_ENCP_VIDEO_MAX_LNCNT, 524},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 0x22},
+	{P_ENCP_VIDEO_HSPULS_END, 0xa0},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 0},
+	{P_ENCP_VIDEO_VSPULS_END, 1589},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 5},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 249},
+	{P_ENCP_VIDEO_HAVON_END, 1689},
+	{P_ENCP_VIDEO_VAVON_BLINE, 42},
+	{P_ENCP_VIDEO_VAVON_ELINE, 521},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x07},
+	{P_VENC_VIDEO_PROG_MODE, 0x0},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x3},
+	{P_ENCP_VIDEO_HSO_END, 0x5},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x3},
+	{P_ENCP_VIDEO_VSO_END, 0x5},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_SY_VAL, 8},
+	{P_ENCP_VIDEO_SY2_VAL, 0x1d8},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x000a},
+	{P_ENCP_DACSEL_0, 0x3102},
+	{P_ENCP_DACSEL_1, 0x0054},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_576i[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0},
+	{P_ENCI_VIDEO_MODE, 0},
+	{P_ENCI_VIDEO_MODE_ADV, 0},
+	{P_ENCI_SYNC_HSO_BEGIN, 3},
+	{P_ENCI_SYNC_HSO_END, 129},
+	{P_ENCI_SYNC_VSO_EVNLN, 0x0003},
+	{P_ENCI_SYNC_VSO_ODDLN, 0x0104},
+	{P_ENCI_MACV_MAX_AMP, 0x8107},
+	{P_VENC_VIDEO_PROG_MODE, 0xff},
+	{P_ENCI_VIDEO_MODE, 0x13},
+	{P_ENCI_VIDEO_MODE_ADV, 0x26},
+	{P_ENCI_VIDEO_SCH, 0x28},
+	{P_ENCI_SYNC_MODE, 0x07},
+	{P_ENCI_YC_DELAY, 0x333},
+	{P_ENCI_VFIFO2VD_PIXEL_START, 0x010b},
+	{P_ENCI_VFIFO2VD_PIXEL_END, 0x06ab},
+	{P_ENCI_VFIFO2VD_LINE_TOP_START, 0x0016},
+	{P_ENCI_VFIFO2VD_LINE_TOP_END, 0x0136},
+	{P_ENCI_VFIFO2VD_LINE_BOT_START, 0x0017},
+	{P_ENCI_VFIFO2VD_LINE_BOT_END, 0x0137},
+	{P_ENCI_DBG_PX_RST, 0},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x0005},
+	{P_ENCI_DACSEL_0, 0x0011},
+	{P_ENCI_DACSEL_1, 0x87},
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_576p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x52},
+	{P_VENC_DVI_SETTING, 0x21},
+	{P_ENCP_VIDEO_MODE, 0x4000},
+	{P_ENCP_VIDEO_MODE_ADV, 9},
+	{P_ENCP_VIDEO_YFP1_HTIME, 235},
+	{P_ENCP_VIDEO_YFP2_HTIME, 1674},
+	{P_ENCP_VIDEO_MAX_PXCNT, 1727},
+	{P_ENCP_VIDEO_MAX_LNCNT, 624},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 0},
+	{P_ENCP_VIDEO_HSPULS_END, 0x80},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 0},
+	{P_ENCP_VIDEO_VSPULS_END, 1599},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 235},
+	{P_ENCP_VIDEO_HAVON_END, 1674},
+	{P_ENCP_VIDEO_VAVON_BLINE, 44},
+	{P_ENCP_VIDEO_VAVON_ELINE, 619},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x07},
+	{P_VENC_VIDEO_PROG_MODE, 0x0},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x80},
+	{P_ENCP_VIDEO_HSO_END, 0x0},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x0},
+	{P_ENCP_VIDEO_VSO_END, 0x5},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_SY_VAL, 8},
+	{P_ENCP_VIDEO_SY2_VAL, 0x1d8},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x000a},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080i[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x2029},
+	{P_ENCP_VIDEO_MAX_PXCNT, 4399},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 88},
+	{P_ENCP_VIDEO_HSPULS_END, 264},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 516},
+	{P_ENCP_VIDEO_HAVON_END, 4355},
+	{P_ENCP_VIDEO_HSO_BEGIN, 264},
+	{P_ENCP_VIDEO_HSO_END, 176},
+	{P_ENCP_VIDEO_EQPULS_BEGIN, 2288},
+	{P_ENCP_VIDEO_EQPULS_END, 2464},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 440},
+	{P_ENCP_VIDEO_VSPULS_END, 2200},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_EQPULS_BLINE, 0},
+	{P_ENCP_VIDEO_EQPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 20},
+	{P_ENCP_VIDEO_VAVON_ELINE, 559},
+	{P_ENCP_VIDEO_VSO_BEGIN, 88},
+	{P_ENCP_VIDEO_VSO_END, 88},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 516},
+	{P_ENCP_VIDEO_YFP2_HTIME, 4355},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_OFLD_VOAV_OFST, 0x11},
+	{P_ENCP_VIDEO_MODE, 0x5ffc},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x207},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080i_50hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x202d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 5279},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 88},
+	{P_ENCP_VIDEO_HSPULS_END, 264},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 526},
+	{P_ENCP_VIDEO_HAVON_END, 4365},
+	{P_ENCP_VIDEO_HSO_BEGIN, 142},
+	{P_ENCP_VIDEO_HSO_END, 230},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 440},
+	{P_ENCP_VIDEO_VSPULS_END, 2200},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 20},
+	{P_ENCP_VIDEO_VAVON_ELINE, 559},
+	{P_ENCP_VIDEO_VSO_BEGIN, 142},
+	{P_ENCP_VIDEO_VSO_END, 142},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 526},
+	{P_ENCP_VIDEO_YFP2_HTIME, 4365},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_OFLD_VOAV_OFST, 0x11},
+	{P_ENCP_VIDEO_MODE, 0x5ffc},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x7},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1052},
+	{P_VENC_DVI_SETTING, 0x0001},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0018},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 2060},
+	{P_ENCP_VIDEO_MAX_PXCNT, 2199},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 2067},
+	{P_ENCP_VIDEO_VAVON_BLINE, 41},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1120},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100},
+	{P_ENCP_VIDEO_VSO_END, 2164},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x000a},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080p_50hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x000d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 2639},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 44},
+	{P_ENCP_VIDEO_HSPULS_END, 132},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 271},
+	{P_ENCP_VIDEO_HAVON_END, 2190},
+	{P_ENCP_VIDEO_HSO_BEGIN, 79},
+	{P_ENCP_VIDEO_HSO_END, 123},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 220},
+	{P_ENCP_VIDEO_VSPULS_END, 2140},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_EQPULS_BLINE, 0},
+	{P_ENCP_VIDEO_EQPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 41},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1120},
+	{P_ENCP_VIDEO_VSO_BEGIN, 79},
+	{P_ENCP_VIDEO_VSO_END, 79},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 271},
+	{P_ENCP_VIDEO_YFP2_HTIME, 2190},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0018},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x7},
+	{P_ENCP_VIDEO_YC_DLY, 0},
+	{P_ENCP_VIDEO_RGB_CTRL, 2},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x000a},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080p_24hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1052},
+	{P_VENC_DVI_SETTING, 0x000d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 2749},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 44},
+	{P_ENCP_VIDEO_HSPULS_END, 132},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 271},
+	{P_ENCP_VIDEO_HAVON_END, 2190},
+	{P_ENCP_VIDEO_HSO_BEGIN, 79},
+	{P_ENCP_VIDEO_HSO_END, 123},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 220},
+	{P_ENCP_VIDEO_VSPULS_END, 2140},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_EQPULS_BLINE, 0},
+	{P_ENCP_VIDEO_EQPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 41},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1120},
+	{P_ENCP_VIDEO_VSO_BEGIN, 79},
+	{P_ENCP_VIDEO_VSO_END, 79},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 271},
+	{P_ENCP_VIDEO_YFP2_HTIME, 2190},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0018},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x7},
+	{P_ENCP_VIDEO_YC_DLY, 0},
+	{P_ENCP_VIDEO_RGB_CTRL, 2},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x000a},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_30hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3840+560-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_25hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3840+1440-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_24hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3840+1660-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_smpte[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840+256},
+	{P_ENCP_VIDEO_MAX_PXCNT, 4096+1404-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987+256},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920+256},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920+256},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920+256},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+struct vic_tvregs_set {
+	enum hdmi_vic vic;
+	const struct reg_t *reg_setting;
+};
+
+/* Using tvmode as index */
+static struct vic_tvregs_set tvregsTab[] = {
+	{HDMI_720x480i60_16x9, tvregs_480i},
+	{HDMI_2880x480i60_16x9, tvregs_480i},
+	{HDMI_720x480p60_16x9, tvregs_480p},
+	{HDMI_2880x240p60_16x9, tvregs_480p},
+	{HDMI_720x576i50_16x9, tvregs_576i},
+	{HDMI_2880x576i50_16x9, tvregs_576i},
+	{HDMI_720x576p50_16x9, tvregs_576p},
+	{HDMI_2880x576p50_16x9, tvregs_576p},
+	{HDMI_1280x720p60_16x9, tvregs_720p},
+	{HDMI_1920x1080i60_16x9, tvregs_1080i},
+	{HDMI_1920x1080p60_16x9, tvregs_1080p},
+	{HDMI_1280x720p50_16x9, tvregs_720p_50hz},
+	{HDMI_1920x1080i50_16x9, tvregs_1080i_50hz},
+	{HDMI_1920x1080p50_16x9, tvregs_1080p_50hz},
+	{HDMI_1920x1080p24_16x9, tvregs_1080p_24hz},
+	{HDMI_3840x2160p30_16x9, tvregs_4k2k_30hz},
+	{HDMI_3840x2160p25_16x9, tvregs_4k2k_25hz},
+	{HDMI_3840x2160p24_16x9, tvregs_4k2k_24hz},
+	{HDMI_4096x2160p24_256x135, tvregs_4k2k_smpte},
+	{HDMI_3840x2160p60_16x9, tvregs_4k2k_30hz},
+	{HDMI_3840x2160p50_16x9, tvregs_4k2k_25hz},
+};
+
+static inline void setreg(const struct reg_t *r)
+{
+	hd_write_reg(r->reg, r->val);
+	/* printk("[0x%x] = 0x%x\n", r->reg, r->val); */
+}
+
+static const struct reg_t *tvregs_setting_mode(enum hdmi_vic vic)
+{
+	int i = 0;
+	for (i = 0; i < ARRAY_SIZE(tvregsTab); i++) {
+		if (vic == tvregsTab[i].vic)
+			return tvregsTab[i].reg_setting;
+	}
+	return NULL;
+}
+
+void set_vmode_enc_hw(enum hdmi_vic vic)
+{
+	const struct reg_t *s = tvregs_setting_mode(vic);
+
+	if (s) {
+		pr_info("hdmitx: set enc for VIC: %d\n", vic);
+		while (MREG_END_MARKER != s->reg)
+			setreg(s++);
+	} else
+		pr_info("hdmitx: not find VIC: %d\n", vic);
+}
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_tvenc.h b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_tvenc.h
new file mode 100644
index 0000000..c5d1cb3
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_tvenc.h
@@ -0,0 +1,24 @@
+#ifndef __HDMI_TX_TVENC_H__
+#define __HDMI_TX_TVENC_H__
+
+#include <common.h>
+#include <amlogic/hdmi.h>
+
+struct reg_t {
+	unsigned int reg;
+	unsigned int val;
+};
+
+struct enc_reg_set {
+	unsigned int addr;
+	unsigned int val;
+};
+
+struct enc_reg_map {
+	enum hdmi_vic vic;
+	struct enc_reg_set *set;
+};
+
+void set_vmode_enc_hw(enum hdmi_vic vic);
+
+#endif
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/hw_enc_clk_config.h b/arch/arm/cpu/armv8/gxb/hdmitx20/hw_enc_clk_config.h
new file mode 100644
index 0000000..0860933
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/hw_enc_clk_config.h
@@ -0,0 +1,48 @@
+#ifndef __HW_ENC_CLK_CONFIG_H__
+#define __HW_ENC_CLK_CONFIG_H__
+#include <amlogic/hdmi.h>
+
+//#include <linux/amlogic/vout/enc_clk_config.h>
+
+#define CLK_UTIL_VID_PLL_DIV_1      0
+#define CLK_UTIL_VID_PLL_DIV_2      1
+#define CLK_UTIL_VID_PLL_DIV_3      2
+#define CLK_UTIL_VID_PLL_DIV_3p5    3
+#define CLK_UTIL_VID_PLL_DIV_3p75   4
+#define CLK_UTIL_VID_PLL_DIV_4      5
+#define CLK_UTIL_VID_PLL_DIV_5      6
+#define CLK_UTIL_VID_PLL_DIV_6      7
+#define CLK_UTIL_VID_PLL_DIV_6p25   8
+#define CLK_UTIL_VID_PLL_DIV_7      9
+#define CLK_UTIL_VID_PLL_DIV_7p5    10
+#define CLK_UTIL_VID_PLL_DIV_12     11
+#define CLK_UTIL_VID_PLL_DIV_14     12
+#define CLK_UTIL_VID_PLL_DIV_15     13
+#define CLK_UTIL_VID_PLL_DIV_2p5    14
+
+enum viu_type {
+    VIU_ENCL = 0,
+    VIU_ENCI,
+    VIU_ENCP,
+    VIU_ENCT,
+};
+
+typedef struct{
+    enum hdmi_vic vic;
+    unsigned viu_path;
+    enum viu_type viu_type;
+    unsigned hpll_clk_out;
+    unsigned od1;
+    unsigned od2;
+    unsigned od3;
+    unsigned vid_pll_div;
+    unsigned vid_clk_div;
+    unsigned hdmi_tx_pixel_div;
+    unsigned encp_div;
+    unsigned enci_div;
+}hw_enc_clk_val_t;
+
+void set_hdmitx_clk(enum hdmi_vic vic);
+void set_hdmitx_clk_420(void);
+
+#endif
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/mach_reg.h b/arch/arm/cpu/armv8/gxb/hdmitx20/mach_reg.h
new file mode 100644
index 0000000..233fb86
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/mach_reg.h
@@ -0,0 +1,806 @@
+/*
+ * drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __MACH_REG_H__
+#define __MACH_REG_H__
+
+#include <common.h>
+
+#define OFFSET	24
+#define nCBUS_REG_ADDR(reg) (0xc8834400 + (reg << 2))
+#define VCBUS_REG_ADDR(reg) (0xd0100000 + (reg << 2))
+
+unsigned long hd_read_reg(unsigned long addr);
+void hd_write_reg(unsigned long addr, unsigned long val);
+void hd_set_reg_bits(unsigned long addr, unsigned long value, unsigned long offset,
+	unsigned long len);
+void sec_reg_write(unsigned *addr, unsigned value);
+unsigned sec_reg_read(unsigned *addr);
+
+#define P_PREG_PAD_GPIO6_EN_N nCBUS_REG_ADDR(0x08)
+#define P_PREG_PAD_GPIO6_O    nCBUS_REG_ADDR(0x09)
+#define P_PREG_PAD_GPIO6_I    nCBUS_REG_ADDR(0x0a)
+#define P_PREG_JTAG_GPIO_ADDR nCBUS_REG_ADDR(0x0b)
+#define P_PREG_PAD_GPIO0_EN_N nCBUS_REG_ADDR(0x0c)
+#define P_PREG_PAD_GPIO0_O    nCBUS_REG_ADDR(0x0d)
+#define P_PREG_PAD_GPIO0_I    nCBUS_REG_ADDR(0x0e)
+#define P_PREG_PAD_GPIO1_EN_N nCBUS_REG_ADDR(0x0f)
+#define P_PREG_PAD_GPIO1_O    nCBUS_REG_ADDR(0x10)
+#define P_PREG_PAD_GPIO1_I    nCBUS_REG_ADDR(0x11)
+#define P_PREG_PAD_GPIO2_EN_N nCBUS_REG_ADDR(0x12)
+#define P_PREG_PAD_GPIO2_O    nCBUS_REG_ADDR(0x13)
+#define P_PREG_PAD_GPIO2_I    nCBUS_REG_ADDR(0x14)
+#define P_PREG_PAD_GPIO3_EN_N nCBUS_REG_ADDR(0x15)
+#define P_PREG_PAD_GPIO3_O    nCBUS_REG_ADDR(0x16)
+#define P_PREG_PAD_GPIO3_I    nCBUS_REG_ADDR(0x17)
+#define P_PREG_PAD_GPIO4_EN_N nCBUS_REG_ADDR(0x18)
+#define P_PREG_PAD_GPIO4_O    nCBUS_REG_ADDR(0x19)
+#define P_PREG_PAD_GPIO4_I    nCBUS_REG_ADDR(0x1a)
+#define P_PREG_PAD_GPIO5_EN_N nCBUS_REG_ADDR(0x1b)
+#define P_PREG_PAD_GPIO5_O    nCBUS_REG_ADDR(0x1c)
+#define P_PREG_PAD_GPIO5_I    nCBUS_REG_ADDR(0x1d)
+#define PERIPHS_PIN_MUX_0 0x2c	/* register.h:419 */
+#define P_PERIPHS_PIN_MUX_0 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_0)
+#define PERIPHS_PIN_MUX_1 0x2d	/* register.h:420 */
+#define P_PERIPHS_PIN_MUX_1 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
+#define PERIPHS_PIN_MUX_2 0x2e	/* register.h:421 */
+#define P_PERIPHS_PIN_MUX_2 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
+#define PERIPHS_PIN_MUX_3 0x2f	/* register.h:422 */
+#define P_PERIPHS_PIN_MUX_3 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_3)
+#define PERIPHS_PIN_MUX_4 0x30	/* register.h:423 */
+#define P_PERIPHS_PIN_MUX_4 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_4)
+#define PERIPHS_PIN_MUX_5 0x31	/* register.h:424 */
+#define P_PERIPHS_PIN_MUX_5 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define PERIPHS_PIN_MUX_6 0x32	/* register.h:425 */
+#define P_PERIPHS_PIN_MUX_6 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_6)
+#define PERIPHS_PIN_MUX_7 0x33	/* register.h:426 */
+#define P_PERIPHS_PIN_MUX_7 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_7)
+#define PERIPHS_PIN_MUX_8 0x34	/* register.h:427 */
+#define P_PERIPHS_PIN_MUX_8 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_8)
+#define PERIPHS_PIN_MUX_9 0x35	/* register.h:428 */
+#define P_PERIPHS_PIN_MUX_9 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_9)
+#define PERIPHS_PIN_MUX_10 0x36	/* register.h:429 */
+#define P_PERIPHS_PIN_MUX_10 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_10)
+#define PERIPHS_PIN_MUX_11 0x37	/* register.h:430 */
+#define P_PERIPHS_PIN_MUX_11 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_11)
+#define PERIPHS_PIN_MUX_12 0x38	/* register.h:431 */
+#define P_PERIPHS_PIN_MUX_12 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_12)
+
+#define PAD_PULL_UP_REG0 0x3a
+#define P_PAD_PULL_UP_REG0 nCBUS_REG_ADDR(PAD_PULL_UP_REG0)
+#define PAD_PULL_UP_REG1 0x3d
+#define P_PAD_PULL_UP_REG1 nCBUS_REG_ADDR(PAD_PULL_UP_REG1)
+#define PAD_PULL_UP_REG2 0x3c
+#define P_PAD_PULL_UP_REG2 nCBUS_REG_ADDR(PAD_PULL_UP_REG2)
+#define PAD_PULL_UP_REG3 0x3d
+#define P_PAD_PULL_UP_REG3 nCBUS_REG_ADDR(PAD_PULL_UP_REG3)
+#define PAD_PULL_UP_REG4 0x3d
+#define P_PAD_PULL_UP_REG4 nCBUS_REG_ADDR(PAD_PULL_UP_REG4)
+#define PAD_PULL_UP_EN_REG0 0x48
+#define P_PAD_PULL_UP_EN_REG0 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG0)
+#define PAD_PULL_UP_EN_REG1 0x49
+#define P_PAD_PULL_UP_EN_REG1 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG1)
+#define PAD_PULL_UP_EN_REG2 0x4a
+#define P_PAD_PULL_UP_EN_REG2 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG2)
+#define PAD_PULL_UP_EN_REG3 0x4b
+#define P_PAD_PULL_UP_EN_REG3 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG3)
+#define PAD_PULL_UP_EN_REG4 0x4c
+#define P_PAD_PULL_UP_EN_REG4 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG4)
+
+#define P_HHI_MEM_PD_REG0 (0xc883c000 + (0x40 << 2))
+#define P_HHI_VPU_MEM_PD_REG0 (0xc883c000 + (0x41 << 2))
+#define P_HHI_VPU_MEM_PD_REG1 (0xc883c000 + (0x42 << 2))
+#define P_HHI_AUD_DAC_CTRL (0xc883c000 + (0x44 << 2))
+#define P_HHI_VIID_CLK_DIV (0xc883c000 + (0x4a << 2))
+/* [19] -enable clk_div0 */
+/* [18:16] - cntl_clk_in_sel */
+#define P_HHI_VIID_CLK_CNTL (0xc883c000 + (0x4b << 2))
+#define P_HHI_VIID_DIVIDER_CNTL (0xc883c000 + (0x4c << 2))
+
+/*
+//========================================================================
+//  Global Control Registers			    (12'h000 - 12'h0ff)
+//
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  RESET_CBUS_BASE = 0x11
+// -----------------------------------------------
+*/
+#define P_VERSION_CTRL ((0x00  << 2) + 0xc1104400)
+#define P_RESET0_REGISTER ((0x01  << 2) + 0xc1104400)
+#define P_RESET1_REGISTER ((0x02  << 2) + 0xc1104400)
+#define P_RESET2_REGISTER ((0x03  << 2) + 0xc1104400)
+#define P_RESET3_REGISTER ((0x04  << 2) + 0xc1104400)
+#define P_RESET4_REGISTER ((0x05  << 2) + 0xc1104400)
+#define P_RESET5_REGISTER ((0x06  << 2) + 0xc1104400)
+#define P_RESET6_REGISTER ((0x07  << 2) + 0xc1104400)
+#define P_RESET7_REGISTER ((0x08  << 2) + 0xc1104400)
+#define P_RESET0_MASK ((0x10  << 2) + 0xc1104400)
+#define P_RESET1_MASK ((0x11  << 2) + 0xc1104400)
+#define P_RESET2_MASK ((0x12  << 2) + 0xc1104400)
+#define P_RESET3_MASK ((0x13  << 2) + 0xc1104400)
+#define P_RESET4_MASK ((0x14  << 2) + 0xc1104400)
+#define P_RESET5_MASK ((0x15  << 2) + 0xc1104400)
+#define P_RESET6_MASK ((0x16  << 2) + 0xc1104400)
+
+/* Gated clock enables.
+ * There are 64 enables for the MPEG clocks and 32 enables for other
+ * clock domains.
+ */
+#define P_HHI_GCLK_MPEG0 (0xc883c000 + (0x50 << 2))
+#define P_HHI_GCLK_MPEG1 (0xc883c000 + (0x51 << 2))
+#define P_HHI_GCLK_MPEG2 (0xc883c000 + (0x52 << 2))
+#define P_HHI_GCLK_OTHER (0xc883c000 + (0x54 << 2))
+#define P_HHI_GCLK_AO (0xc883c000 + (0x55 << 2))
+#define P_HHI_SYS_OSCIN_CNTL (0xc883c000 + (0x56 << 2))
+#define P_HHI_SYS_CPU_CLK_CNTL1 (0xc883c000 + (0x57 << 2))
+#define P_HHI_SYS_CPU_RESET_CNTL (0xc883c000 + (0x58 << 2))
+/* [7:0]   - cntl_xd0 */
+#define P_HHI_VID_CLK_DIV (0xc883c000 + (0x59 << 2))
+#define P_HHI_MPEG_CLK_CNTL (0xc883c000 + (0x5d << 2))
+#define P_HHI_AUD_CLK_CNTL (0xc883c000 + (0x5e << 2))
+/* [18:16] - cntl_clk_in_sel */
+#define P_HHI_VID_CLK_CNTL (0xc883c000 + (0x5f << 2))
+#define P_HHI_WIFI_CLK_CNTL (0xc883c000 + (0x60 << 2))
+#define P_HHI_WIFI_PLL_CNTL (0xc883c000 + (0x61 << 2))
+#define P_HHI_WIFI_PLL_CNTL2 (0xc883c000 + (0x62 << 2))
+#define P_HHI_WIFI_PLL_CNTL3 (0xc883c000 + (0x63 << 2))
+#define P_HHI_AUD_CLK_CNTL2 (0xc883c000 + (0x64 << 2))
+#define P_HHI_VID_CLK_CNTL2 (0xc883c000 + (0x65 << 2))
+#define P_HHI_VID_DIVIDER_CNTL (0xc883c000 + (0x66 << 2))
+#define P_HHI_SYS_CPU_CLK_CNTL (0xc883c000 + (0x67 << 2))
+#define P_HHI_VID_PLL_CLK_DIV (0xc883c000 + (0x68 << 2))
+#define P_HHI_AUD_CLK_CNTL3 (0xc883c000 + (0x69 << 2))
+#define P_HHI_MALI_CLK_CNTL (0xc883c000 + (0x6c << 2))
+#define P_HHI_MIPI_PHY_CLK_CNTL (0xc883c000 + (0x6e << 2))
+#define P_HHI_VPU_CLK_CNTL (0xc883c000 + (0x6f << 2))
+#define P_HHI_OTHER_PLL_CNTL (0xc883c000 + (0x70 << 2))
+#define P_HHI_OTHER_PLL_CNTL2 (0xc883c000 + (0x71 << 2))
+#define P_HHI_OTHER_PLL_CNTL3 (0xc883c000 + (0x72 << 2))
+#define P_HHI_HDMI_CLK_CNTL (0xc883c000 + (0x73 << 2))
+#define P_HHI_DEMOD_CLK_CNTL (0xc883c000 + (0x74 << 2))
+#define P_HHI_SATA_CLK_CNTL (0xc883c000 + (0x75 << 2))
+#define P_HHI_ETH_CLK_CNTL (0xc883c000 + (0x76 << 2))
+#define P_HHI_CLK_DOUBLE_CNTL (0xc883c000 + (0x77 << 2))
+#define P_HHI_VDEC_CLK_CNTL (0xc883c000 + (0x78 << 2))
+#define P_HHI_VDEC2_CLK_CNTL (0xc883c000 + (0x79 << 2))
+#define P_HHI_VDEC3_CLK_CNTL (0xc883c000 + (0x7a << 2))
+#define P_HHI_VDEC4_CLK_CNTL (0xc883c000 + (0x7b << 2))
+#define P_HHI_HDCP22_CLK_CNTL (0xc883c000 + (0x7c << 2))
+#define P_HHI_VAPBCLK_CNTL (0xc883c000 + (0x7d << 2))
+#define P_HHI_VP9DEC_CLK_CNTL (0xc883c000 + (0x7e << 2))
+#define P_HHI_HDMI_AFC_CNTL (0xc883c000 + (0x7f << 2))
+#define P_HHI_HDMIRX_CLK_CNTL (0xc883c000 + (0x80 << 2))
+#define P_HHI_HDMIRX_AUD_CLK_CNTL (0xc883c000 + (0x81 << 2))
+#define P_HHI_EDP_APB_CLK_CNTL (0xc883c000 + (0x82 << 2))
+#define P_HHI_VPU_CLKB_CNTL (0xc883c000 + (0x83 << 2))
+#define P_HHI_VID_PLL_MOD_CNTL0 (0xc883c000 + (0x84 << 2))
+#define P_HHI_VID_PLL_MOD_LOW_TCNT (0xc883c000 + (0x85 << 2))
+#define P_HHI_VID_PLL_MOD_HIGH_TCNT (0xc883c000 + (0x86 << 2))
+#define P_HHI_VID_PLL_MOD_NOM_TCNT (0xc883c000 + (0x87 << 2))
+#define P_HHI_USB_CLK_CNTL (0xc883c000 + (0x88 << 2))
+#define P_HHI_32K_CLK_CNTL (0xc883c000 + (0x89 << 2))
+#define P_HHI_GEN_CLK_CNTL (0xc883c000 + (0x8a << 2))
+#define P_HHI_GEN_CLK_CNTL2 (0xc883c000 + (0x8b << 2))
+#define P_HHI_JTAG_CONFIG (0xc883c000 + (0x8e << 2))
+#define P_HHI_VAFE_CLKXTALIN_CNTL (0xc883c000 + (0x8f << 2))
+#define P_HHI_VAFE_CLKOSCIN_CNTL (0xc883c000 + (0x90 << 2))
+#define P_HHI_VAFE_CLKIN_CNTL (0xc883c000 + (0x91 << 2))
+#define P_HHI_TVFE_AUTOMODE_CLK_CNTL (0xc883c000 + (0x92 << 2))
+#define P_HHI_VAFE_CLKPI_CNTL (0xc883c000 + (0x93 << 2))
+#define P_HHI_VDIN_MEAS_CLK_CNTL (0xc883c000 + (0x94 << 2))
+#define P_HHI_PCM_CLK_CNTL (0xc883c000 + (0x96 << 2))
+#define P_HHI_NAND_CLK_CNTL (0xc883c000 + (0x97 << 2))
+#define P_HHI_ISP_LED_CLK_CNTL (0xc883c000 + (0x98 << 2))
+#define P_HHI_SD_EMMC_CLK_CNTL (0xc883c000 + (0x99 << 2))
+#define P_HHI_EDP_TX_PHY_CNTL0 (0xc883c000 + (0x9c << 2))
+#define P_HHI_EDP_TX_PHY_CNTL1 (0xc883c000 + (0x9d << 2))
+#define P_HHI_MPLL_CNTL (0xc883c000 + (0xa0 << 2))
+#define P_HHI_MPLL_CNTL2 (0xc883c000 + (0xa1 << 2))
+#define P_HHI_MPLL_CNTL3 (0xc883c000 + (0xa2 << 2))
+#define P_HHI_MPLL_CNTL4 (0xc883c000 + (0xa3 << 2))
+#define P_HHI_MPLL_CNTL5 (0xc883c000 + (0xa4 << 2))
+#define P_HHI_MPLL_CNTL6 (0xc883c000 + (0xa5 << 2))
+#define P_HHI_MPLL_CNTL7 (0xc883c000 + (0xa6 << 2))
+#define P_HHI_MPLL_CNTL8 (0xc883c000 + (0xa7 << 2))
+#define P_HHI_MPLL_CNTL9 (0xc883c000 + (0xa8 << 2))
+#define P_HHI_MPLL_CNTL10 (0xc883c000 + (0xa9 << 2))
+#define P_HHI_ADC_PLL_CNTL (0xc883c000 + (0xaa << 2))
+#define P_HHI_ADC_PLL_CNTL2 (0xc883c000 + (0xab << 2))
+#define P_HHI_ADC_PLL_CNTL3 (0xc883c000 + (0xac << 2))
+#define P_HHI_ADC_PLL_CNTL4 (0xc883c000 + (0xad << 2))
+#define P_HHI_ADC_PLL_CNTL_I (0xc883c000 + (0xae << 2))
+#define P_HHI_AUDCLK_PLL_CNTL (0xc883c000 + (0xb0 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL2 (0xc883c000 + (0xb1 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL3 (0xc883c000 + (0xb2 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL4 (0xc883c000 + (0xb3 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL5 (0xc883c000 + (0xb4 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL6 (0xc883c000 + (0xb5 << 2))
+#define P_HHI_L2_DDR_CLK_CNTL (0xc883c000 + (0xb6 << 2))
+#define P_HHI_MPLL3_CNTL0 (0xc883c000 + (0xb8 << 2))
+#define P_HHI_MPLL3_CNTL1 (0xc883c000 + (0xb9 << 2))
+#define P_HHI_VDAC_CNTL0 (0xc883c000 + (0xbd << 2))
+#define P_HHI_VDAC_CNTL1 (0xc883c000 + (0xbe << 2))
+#define P_HHI_SYS_PLL_CNTL (0xc883c000 + (0xc0 << 2))
+#define P_HHI_SYS_PLL_CNTL2 (0xc883c000 + (0xc1 << 2))
+#define P_HHI_SYS_PLL_CNTL3 (0xc883c000 + (0xc2 << 2))
+#define P_HHI_SYS_PLL_CNTL4 (0xc883c000 + (0xc3 << 2))
+#define P_HHI_SYS_PLL_CNTL5 (0xc883c000 + (0xc4 << 2))
+#define P_HHI_DPLL_TOP_I (0xc883c000 + (0xc6 << 2))
+#define P_HHI_DPLL_TOP2_I (0xc883c000 + (0xc7 << 2))
+#define P_HHI_HDMI_PLL_CNTL (0xc883c000 + (0xc8 << 2))
+#define P_HHI_HDMI_PLL_CNTL2 (0xc883c000 + (0xc9 << 2))
+#define P_HHI_HDMI_PLL_CNTL3 (0xc883c000 + (0xca << 2))
+#define P_HHI_HDMI_PLL_CNTL4 (0xc883c000 + (0xcb << 2))
+#define P_HHI_HDMI_PLL_CNTL5 (0xc883c000 + (0xcc << 2))
+#define P_HHI_HDMI_PLL_CNTL6 (0xc883c000 + (0xcd << 2))
+#define P_HHI_HDMI_PLL_CNTL_I (0xc883c000 + (0xce << 2))
+#define P_HHI_HDMI_PLL_CNTL7 (0xc883c000 + (0xcf << 2))
+#define P_HHI_DSI_LVDS_EDP_CNTL0 (0xc883c000 + (0xd1 << 2))
+#define P_HHI_DSI_LVDS_EDP_CNTL1 (0xc883c000 + (0xd2 << 2))
+#define P_HHI_CSI_PHY_CNTL0 (0xc883c000 + (0xd3 << 2))
+#define P_HHI_CSI_PHY_CNTL1 (0xc883c000 + (0xd4 << 2))
+#define P_HHI_CSI_PHY_CNTL2 (0xc883c000 + (0xd5 << 2))
+#define P_HHI_CSI_PHY_CNTL3 (0xc883c000 + (0xd6 << 2))
+#define P_HHI_CSI_PHY_CNTL4 (0xc883c000 + (0xd7 << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL0 (0xc883c000 + (0xd8 << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL1 (0xc883c000 + (0xd9 << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL2 (0xc883c000 + (0xda << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL3 (0xc883c000 + (0xdb << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL4 (0xc883c000 + (0xdc << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL5 (0xc883c000 + (0xdd << 2))
+#define P_HHI_LVDS_TX_PHY_CNTL0 (0xc883c000 + (0xde << 2))
+#define P_HHI_LVDS_TX_PHY_CNTL1 (0xc883c000 + (0xdf << 2))
+#define P_HHI_VID2_PLL_CNTL (0xc883c000 + (0xe0 << 2))
+#define P_HHI_VID2_PLL_CNTL2 (0xc883c000 + (0xe1 << 2))
+#define P_HHI_VID2_PLL_CNTL3 (0xc883c000 + (0xe2 << 2))
+#define P_HHI_VID2_PLL_CNTL4 (0xc883c000 + (0xe3 << 2))
+#define P_HHI_VID2_PLL_CNTL5 (0xc883c000 + (0xe4 << 2))
+#define P_HHI_VID2_PLL_CNTL_I (0xc883c000 + (0xe5 << 2))
+#define P_HHI_HDMI_PHY_CNTL0 (0xc883c000 + (0xe8 << 2))
+#define P_HHI_HDMI_PHY_CNTL1 (0xc883c000 + (0xe9 << 2))
+#define P_HHI_HDMI_PHY_CNTL2 (0xc883c000 + (0xea << 2))
+#define P_HHI_HDMI_PHY_CNTL3 (0xc883c000 + (0xeb << 2))
+#define P_HHI_VID_LOCK_CLK_CNTL (0xc883c000 + (0xf2 << 2))
+#define P_HHI_ATV_DMD_SYS_CLK_CNTL (0xc883c000 + (0xf3 << 2))
+#define P_HHI_BT656_CLK_CNTL (0xc883c000 + (0xf5 << 2))
+#define P_HHI_SAR_CLK_CNTL (0xc883c000 + (0xf6 << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL (0xc883c000 + (0xf8 << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL2 (0xc883c000 + (0xf9 << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL3 (0xc883c000 + (0xfa << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL4 (0xc883c000 + (0xfb << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL5 (0xc883c000 + (0xfc << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL6 (0xc883c000 + (0xfd << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL_I (0xc883c000 + (0xfe << 2))
+
+#define AIU_HDMI_CLK_DATA_CTRL 0x152a	/* register.h:2466 */
+#define P_AIU_HDMI_CLK_DATA_CTRL CBUS_REG_ADDR(AIU_HDMI_CLK_DATA_CTRL)
+
+#define ISA_DEBUG_REG0 0x2600
+#define P_ISA_DEBUG_REG0 CBUS_REG_ADDR(ISA_DEBUG_REG0)
+
+#define VENC_DVI_SETTING 0x1b62	/* register.h:8014 */
+#define P_VENC_DVI_SETTING VCBUS_REG_ADDR(VENC_DVI_SETTING)
+
+#define VENC_VIDEO_TST_EN 0x1b70
+#define P_VENC_VIDEO_TST_EN VCBUS_REG_ADDR(VENC_VIDEO_TST_EN)
+#define VENC_VIDEO_TST_MDSEL 0x1b71
+#define P_VENC_VIDEO_TST_MDSEL VCBUS_REG_ADDR(VENC_VIDEO_TST_MDSEL)
+#define VENC_VIDEO_TST_Y 0x1b72
+#define P_VENC_VIDEO_TST_Y VCBUS_REG_ADDR(VENC_VIDEO_TST_Y)
+#define VENC_VIDEO_TST_CB 0x1b73
+#define P_VENC_VIDEO_TST_CB VCBUS_REG_ADDR(VENC_VIDEO_TST_CB)
+#define VENC_VIDEO_TST_CR 0x1b74
+#define P_VENC_VIDEO_TST_CR VCBUS_REG_ADDR(VENC_VIDEO_TST_CR)
+#define VENC_VIDEO_TST_CLRBAR_STRT 0x1b75
+#define P_VENC_VIDEO_TST_CLRBAR_STRT VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_STRT)
+#define VENC_VIDEO_TST_CLRBAR_WIDTH 0x1b76
+#define P_VENC_VIDEO_TST_CLRBAR_WIDTH VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_WIDTH)
+#define VENC_VIDEO_TST_VDCNT_STSET 0x1b77
+#define P_VENC_VIDEO_TST_VDCNT_STSET VCBUS_REG_ADDR(VENC_VIDEO_TST_VDCNT_STSET)
+#define ENCP_VIDEO_EN 0x1b80	/* register.h:8078 */
+#define P_ENCP_VIDEO_EN VCBUS_REG_ADDR(ENCP_VIDEO_EN)
+#define ENCP_VIDEO_SYNC_MODE 0x1b81	/* register.h:8079 */
+#define P_ENCP_VIDEO_SYNC_MODE VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_MODE)
+#define ENCP_MACV_EN 0x1b82	/* register.h:8080 */
+#define P_ENCP_MACV_EN VCBUS_REG_ADDR(ENCP_MACV_EN)
+#define ENCP_VIDEO_Y_SCL 0x1b83	/* register.h:8081 */
+#define P_ENCP_VIDEO_Y_SCL VCBUS_REG_ADDR(ENCP_VIDEO_Y_SCL)
+#define ENCP_VIDEO_PB_SCL 0x1b84	/* register.h:8082 */
+#define P_ENCP_VIDEO_PB_SCL VCBUS_REG_ADDR(ENCP_VIDEO_PB_SCL)
+#define ENCP_VIDEO_PR_SCL 0x1b85	/* register.h:8083 */
+#define P_ENCP_VIDEO_PR_SCL VCBUS_REG_ADDR(ENCP_VIDEO_PR_SCL)
+#define ENCP_VIDEO_SYNC_SCL 0x1b86	/* register.h:8084 */
+#define P_ENCP_VIDEO_SYNC_SCL VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_SCL)
+#define ENCP_VIDEO_MACV_SCL 0x1b87	/* register.h:8085 */
+#define P_ENCP_VIDEO_MACV_SCL VCBUS_REG_ADDR(ENCP_VIDEO_MACV_SCL)
+#define ENCP_VIDEO_Y_OFFST 0x1b88	/* register.h:8086 */
+#define P_ENCP_VIDEO_Y_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_Y_OFFST)
+#define ENCP_VIDEO_PB_OFFST 0x1b89	/* register.h:8087 */
+#define P_ENCP_VIDEO_PB_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_PB_OFFST)
+#define ENCP_VIDEO_PR_OFFST 0x1b8a	/* register.h:8088 */
+#define P_ENCP_VIDEO_PR_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_PR_OFFST)
+#define ENCP_VIDEO_SYNC_OFFST 0x1b8b	/* register.h:8089 */
+#define P_ENCP_VIDEO_SYNC_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_OFFST)
+#define ENCP_VIDEO_MACV_OFFST 0x1b8c	/* register.h:8090 */
+#define P_ENCP_VIDEO_MACV_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_MACV_OFFST)
+#define ENCP_VIDEO_MODE 0x1b8d	/* register.h:8092 */
+#define P_ENCP_VIDEO_MODE VCBUS_REG_ADDR(ENCP_VIDEO_MODE)
+#define ENCP_VIDEO_MODE_ADV 0x1b8e	/* register.h:8093 */
+#define P_ENCP_VIDEO_MODE_ADV VCBUS_REG_ADDR(ENCP_VIDEO_MODE_ADV)
+#define ENCP_DBG_PX_RST 0x1b90	/* register.h:8095 */
+#define P_ENCP_DBG_PX_RST VCBUS_REG_ADDR(ENCP_DBG_PX_RST)
+#define ENCP_DBG_LN_RST 0x1b91	/* register.h:8096 */
+#define P_ENCP_DBG_LN_RST VCBUS_REG_ADDR(ENCP_DBG_LN_RST)
+#define ENCP_DBG_PX_INT 0x1b92	/* register.h:8097 */
+#define P_ENCP_DBG_PX_INT VCBUS_REG_ADDR(ENCP_DBG_PX_INT)
+#define ENCP_DBG_LN_INT 0x1b93	/* register.h:8098 */
+#define P_ENCP_DBG_LN_INT VCBUS_REG_ADDR(ENCP_DBG_LN_INT)
+#define ENCP_VIDEO_YFP1_HTIME 0x1b94	/* register.h:8100 */
+#define P_ENCP_VIDEO_YFP1_HTIME VCBUS_REG_ADDR(ENCP_VIDEO_YFP1_HTIME)
+#define ENCP_VIDEO_YFP2_HTIME 0x1b95	/* register.h:8101 */
+#define P_ENCP_VIDEO_YFP2_HTIME VCBUS_REG_ADDR(ENCP_VIDEO_YFP2_HTIME)
+#define ENCP_VIDEO_YC_DLY 0x1b96	/* register.h:8102 */
+#define P_ENCP_VIDEO_YC_DLY VCBUS_REG_ADDR(ENCP_VIDEO_YC_DLY)
+#define ENCP_VIDEO_MAX_PXCNT 0x1b97	/* register.h:8103 */
+#define P_ENCP_VIDEO_MAX_PXCNT VCBUS_REG_ADDR(ENCP_VIDEO_MAX_PXCNT)
+#define ENCP_VIDEO_HSPULS_BEGIN 0x1b98	/* register.h:8104 */
+#define P_ENCP_VIDEO_HSPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_BEGIN)
+#define ENCP_VIDEO_HSPULS_END 0x1b99	/* register.h:8105 */
+#define P_ENCP_VIDEO_HSPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_END)
+#define ENCP_VIDEO_HSPULS_SWITCH 0x1b9a	/* register.h:8106 */
+#define P_ENCP_VIDEO_HSPULS_SWITCH VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_SWITCH)
+#define ENCP_VIDEO_VSPULS_BEGIN 0x1b9b	/* register.h:8107 */
+#define P_ENCP_VIDEO_VSPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_BEGIN)
+#define ENCP_VIDEO_VSPULS_END 0x1b9c	/* register.h:8108 */
+#define P_ENCP_VIDEO_VSPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_END)
+#define ENCP_VIDEO_VSPULS_BLINE 0x1b9d	/* register.h:8109 */
+#define P_ENCP_VIDEO_VSPULS_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_BLINE)
+#define ENCP_VIDEO_VSPULS_ELINE 0x1b9e	/* register.h:8110 */
+#define P_ENCP_VIDEO_VSPULS_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_ELINE)
+#define ENCP_VIDEO_EQPULS_BEGIN 0x1b9f	/* register.h:8111 */
+#define P_ENCP_VIDEO_EQPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_BEGIN)
+#define ENCP_VIDEO_EQPULS_END 0x1ba0	/* register.h:8112 */
+#define P_ENCP_VIDEO_EQPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_END)
+#define ENCP_VIDEO_EQPULS_BLINE 0x1ba1	/* register.h:8113 */
+#define P_ENCP_VIDEO_EQPULS_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_BLINE)
+#define ENCP_VIDEO_EQPULS_ELINE 0x1ba2	/* register.h:8114 */
+#define P_ENCP_VIDEO_EQPULS_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_ELINE)
+#define ENCP_VIDEO_HAVON_END 0x1ba3	/* register.h:8115 */
+#define P_ENCP_VIDEO_HAVON_END VCBUS_REG_ADDR(ENCP_VIDEO_HAVON_END)
+#define ENCP_VIDEO_HAVON_BEGIN 0x1ba4	/* register.h:8116 */
+#define P_ENCP_VIDEO_HAVON_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HAVON_BEGIN)
+#define ENCP_VIDEO_VAVON_ELINE 0x1baf	/* register.h:8117 */
+#define P_ENCP_VIDEO_VAVON_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VAVON_ELINE)
+#define ENCP_VIDEO_VAVON_BLINE 0x1ba6	/* register.h:8118 */
+#define P_ENCP_VIDEO_VAVON_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VAVON_BLINE)
+#define ENCP_VIDEO_HSO_BEGIN 0x1ba7	/* register.h:8119 */
+#define P_ENCP_VIDEO_HSO_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HSO_BEGIN)
+#define ENCP_VIDEO_HSO_END 0x1ba8	/* register.h:8120 */
+#define P_ENCP_VIDEO_HSO_END VCBUS_REG_ADDR(ENCP_VIDEO_HSO_END)
+#define ENCP_VIDEO_VSO_BEGIN 0x1ba9	/* register.h:8121 */
+#define P_ENCP_VIDEO_VSO_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BEGIN)
+#define ENCP_VIDEO_VSO_END 0x1baa	/* register.h:8122 */
+#define P_ENCP_VIDEO_VSO_END VCBUS_REG_ADDR(ENCP_VIDEO_VSO_END)
+#define ENCP_VIDEO_VSO_BLINE 0x1bab	/* register.h:8123 */
+#define P_ENCP_VIDEO_VSO_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BLINE)
+#define ENCP_VIDEO_VSO_ELINE 0x1bac	/* register.h:8124 */
+#define P_ENCP_VIDEO_VSO_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VSO_ELINE)
+#define ENCP_VIDEO_SYNC_WAVE_CURVE 0x1bad	/* register.h:8125 */
+#define P_ENCP_VIDEO_SYNC_WAVE_CURVE VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_WAVE_CURVE)
+#define ENCP_VIDEO_MAX_LNCNT 0x1bae	/* register.h:8126 */
+#define P_ENCP_VIDEO_MAX_LNCNT VCBUS_REG_ADDR(ENCP_VIDEO_MAX_LNCNT)
+#define ENCP_VIDEO_SY_VAL 0x1bb0	/* register.h:8127 */
+#define P_ENCP_VIDEO_SY_VAL VCBUS_REG_ADDR(ENCP_VIDEO_SY_VAL)
+#define ENCP_VIDEO_SY2_VAL 0x1bb1	/* register.h:8128 */
+#define P_ENCP_VIDEO_SY2_VAL VCBUS_REG_ADDR(ENCP_VIDEO_SY2_VAL)
+#define ENCP_VIDEO_BLANKY_VAL 0x1bb2	/* register.h:8129 */
+#define P_ENCP_VIDEO_BLANKY_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKY_VAL)
+#define ENCP_VIDEO_BLANKPB_VAL 0x1bb3	/* register.h:8130 */
+#define P_ENCP_VIDEO_BLANKPB_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKPB_VAL)
+#define ENCP_VIDEO_BLANKPR_VAL 0x1bb4	/* register.h:8131 */
+#define P_ENCP_VIDEO_BLANKPR_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKPR_VAL)
+#define ENCP_VIDEO_HOFFST 0x1bb5	/* register.h:8132 */
+#define P_ENCP_VIDEO_HOFFST VCBUS_REG_ADDR(ENCP_VIDEO_HOFFST)
+#define ENCP_VIDEO_VOFFST 0x1bb6	/* register.h:8133 */
+#define P_ENCP_VIDEO_VOFFST VCBUS_REG_ADDR(ENCP_VIDEO_VOFFST)
+#define ENCP_VIDEO_RGB_CTRL 0x1bb7	/* register.h:8134 */
+#define P_ENCP_VIDEO_RGB_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_RGB_CTRL)
+#define ENCP_VIDEO_FILT_CTRL 0x1bb8	/* register.h:8135 */
+#define P_ENCP_VIDEO_FILT_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_FILT_CTRL)
+#define ENCP_VIDEO_OFLD_VPEQ_OFST 0x1bb9	/* register.h:8136 */
+#define P_ENCP_VIDEO_OFLD_VPEQ_OFST VCBUS_REG_ADDR(ENCP_VIDEO_OFLD_VPEQ_OFST)
+#define ENCP_VIDEO_OFLD_VOAV_OFST 0x1bba	/* register.h:8137 */
+#define P_ENCP_VIDEO_OFLD_VOAV_OFST VCBUS_REG_ADDR(ENCP_VIDEO_OFLD_VOAV_OFST)
+#define ENCP_VIDEO_MATRIX_CB 0x1bbb	/* register.h:8138 */
+#define P_ENCP_VIDEO_MATRIX_CB VCBUS_REG_ADDR(ENCP_VIDEO_MATRIX_CB)
+#define ENCP_VIDEO_MATRIX_CR 0x1bbc	/* register.h:8139 */
+#define P_ENCP_VIDEO_MATRIX_CR VCBUS_REG_ADDR(ENCP_VIDEO_MATRIX_CR)
+#define ENCP_VIDEO_RGBIN_CTRL 0x1bbd	/* register.h:8140 */
+#define P_ENCP_VIDEO_RGBIN_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_RGBIN_CTRL)
+#define ENCP_MACV_BLANKY_VAL 0x1bc0	/* register.h:8142 */
+#define P_ENCP_MACV_BLANKY_VAL VCBUS_REG_ADDR(ENCP_MACV_BLANKY_VAL)
+#define ENCP_MACV_MAXY_VAL 0x1bc1	/* register.h:8143 */
+#define P_ENCP_MACV_MAXY_VAL VCBUS_REG_ADDR(ENCP_MACV_MAXY_VAL)
+#define ENCP_MACV_1ST_PSSYNC_STRT 0x1bc2	/* register.h:8144 */
+#define P_ENCP_MACV_1ST_PSSYNC_STRT VCBUS_REG_ADDR(ENCP_MACV_1ST_PSSYNC_STRT)
+#define ENCP_MACV_PSSYNC_STRT 0x1bc3	/* register.h:8145 */
+#define P_ENCP_MACV_PSSYNC_STRT VCBUS_REG_ADDR(ENCP_MACV_PSSYNC_STRT)
+#define ENCP_MACV_AGC_STRT 0x1bc4	/* register.h:8146 */
+#define P_ENCP_MACV_AGC_STRT VCBUS_REG_ADDR(ENCP_MACV_AGC_STRT)
+#define ENCP_MACV_AGC_END 0x1bc5	/* register.h:8147 */
+#define P_ENCP_MACV_AGC_END VCBUS_REG_ADDR(ENCP_MACV_AGC_END)
+#define ENCP_MACV_WAVE_END 0x1bc6	/* register.h:8148 */
+#define P_ENCP_MACV_WAVE_END VCBUS_REG_ADDR(ENCP_MACV_WAVE_END)
+#define ENCP_MACV_STRTLINE 0x1bc7	/* register.h:8149 */
+#define P_ENCP_MACV_STRTLINE VCBUS_REG_ADDR(ENCP_MACV_STRTLINE)
+#define ENCP_MACV_ENDLINE 0x1bc8	/* register.h:8150 */
+#define P_ENCP_MACV_ENDLINE VCBUS_REG_ADDR(ENCP_MACV_ENDLINE)
+#define ENCP_MACV_TS_CNT_MAX_L 0x1bc9	/* register.h:8151 */
+#define P_ENCP_MACV_TS_CNT_MAX_L VCBUS_REG_ADDR(ENCP_MACV_TS_CNT_MAX_L)
+#define ENCP_MACV_TS_CNT_MAX_H 0x1bca	/* register.h:8152 */
+#define P_ENCP_MACV_TS_CNT_MAX_H VCBUS_REG_ADDR(ENCP_MACV_TS_CNT_MAX_H)
+#define ENCP_MACV_TIME_DOWN 0x1bcb	/* register.h:8153 */
+#define P_ENCP_MACV_TIME_DOWN VCBUS_REG_ADDR(ENCP_MACV_TIME_DOWN)
+#define ENCP_MACV_TIME_LO 0x1bcc	/* register.h:8154 */
+#define P_ENCP_MACV_TIME_LO VCBUS_REG_ADDR(ENCP_MACV_TIME_LO)
+#define ENCP_MACV_TIME_UP 0x1bcd	/* register.h:8155 */
+#define P_ENCP_MACV_TIME_UP VCBUS_REG_ADDR(ENCP_MACV_TIME_UP)
+#define ENCP_MACV_TIME_RST 0x1bce	/* register.h:8156 */
+#define P_ENCP_MACV_TIME_RST VCBUS_REG_ADDR(ENCP_MACV_TIME_RST)
+#define ENCP_VBI_CTRL 0x1bd0	/* register.h:8158 */
+#define P_ENCP_VBI_CTRL VCBUS_REG_ADDR(ENCP_VBI_CTRL)
+#define ENCP_VBI_SETTING 0x1bd1	/* register.h:8159 */
+#define P_ENCP_VBI_SETTING VCBUS_REG_ADDR(ENCP_VBI_SETTING)
+#define ENCP_VBI_BEGIN 0x1bd2	/* register.h:8160 */
+#define P_ENCP_VBI_BEGIN VCBUS_REG_ADDR(ENCP_VBI_BEGIN)
+#define ENCP_VBI_WIDTH 0x1bd3	/* register.h:8161 */
+#define P_ENCP_VBI_WIDTH VCBUS_REG_ADDR(ENCP_VBI_WIDTH)
+#define ENCP_VBI_HVAL 0x1bd4	/* register.h:8162 */
+#define P_ENCP_VBI_HVAL VCBUS_REG_ADDR(ENCP_VBI_HVAL)
+#define ENCP_VBI_DATA0 0x1bd5	/* register.h:8163 */
+#define P_ENCP_VBI_DATA0 VCBUS_REG_ADDR(ENCP_VBI_DATA0)
+#define ENCP_VBI_DATA1 0x1bd6	/* register.h:8164 */
+#define P_ENCP_VBI_DATA1 VCBUS_REG_ADDR(ENCP_VBI_DATA1)
+
+#define ENCI_VIDEO_MODE 0x1b00	/* register.h:8185 */
+#define P_ENCI_VIDEO_MODE VCBUS_REG_ADDR(ENCI_VIDEO_MODE)
+#define ENCI_VIDEO_MODE_ADV 0x1b01	/* register.h:8186 */
+#define P_ENCI_VIDEO_MODE_ADV VCBUS_REG_ADDR(ENCI_VIDEO_MODE_ADV)
+#define ENCI_VIDEO_FSC_ADJ 0x1b02	/* register.h:8187 */
+#define P_ENCI_VIDEO_FSC_ADJ VCBUS_REG_ADDR(ENCI_VIDEO_FSC_ADJ)
+#define ENCI_VIDEO_BRIGHT 0x1b03	/* register.h:8188 */
+#define P_ENCI_VIDEO_BRIGHT VCBUS_REG_ADDR(ENCI_VIDEO_BRIGHT)
+#define ENCI_VIDEO_CONT 0x1b04	/* register.h:8189 */
+#define P_ENCI_VIDEO_CONT VCBUS_REG_ADDR(ENCI_VIDEO_CONT)
+#define ENCI_VIDEO_SAT 0x1b05	/* register.h:8190 */
+#define P_ENCI_VIDEO_SAT VCBUS_REG_ADDR(ENCI_VIDEO_SAT)
+#define ENCI_VIDEO_HUE 0x1b06	/* register.h:8191 */
+#define P_ENCI_VIDEO_HUE VCBUS_REG_ADDR(ENCI_VIDEO_HUE)
+#define ENCI_VIDEO_SCH 0x1b07	/* register.h:8192 */
+#define P_ENCI_VIDEO_SCH VCBUS_REG_ADDR(ENCI_VIDEO_SCH)
+#define ENCI_SYNC_MODE 0x1b08	/* register.h:8193 */
+#define P_ENCI_SYNC_MODE VCBUS_REG_ADDR(ENCI_SYNC_MODE)
+#define ENCI_SYNC_CTRL 0x1b09	/* register.h:8194 */
+#define P_ENCI_SYNC_CTRL VCBUS_REG_ADDR(ENCI_SYNC_CTRL)
+#define ENCI_SYNC_HSO_BEGIN 0x1b0a	/* register.h:8195 */
+#define P_ENCI_SYNC_HSO_BEGIN VCBUS_REG_ADDR(ENCI_SYNC_HSO_BEGIN)
+#define ENCI_SYNC_HSO_END 0x1b0b	/* register.h:8196 */
+#define P_ENCI_SYNC_HSO_END VCBUS_REG_ADDR(ENCI_SYNC_HSO_END)
+#define ENCI_SYNC_VSO_EVN 0x1b0c	/* register.h:8197 */
+#define P_ENCI_SYNC_VSO_EVN VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVN)
+#define ENCI_SYNC_VSO_ODD 0x1b0d	/* register.h:8198 */
+#define P_ENCI_SYNC_VSO_ODD VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODD)
+#define ENCI_SYNC_VSO_EVNLN 0x1b0e	/* register.h:8199 */
+#define P_ENCI_SYNC_VSO_EVNLN VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVNLN)
+#define ENCI_SYNC_VSO_ODDLN 0x1b0f	/* register.h:8200 */
+#define P_ENCI_SYNC_VSO_ODDLN VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODDLN)
+#define ENCI_SYNC_HOFFST 0x1b10	/* register.h:8201 */
+#define P_ENCI_SYNC_HOFFST VCBUS_REG_ADDR(ENCI_SYNC_HOFFST)
+#define ENCI_SYNC_VOFFST 0x1b11	/* register.h:8202 */
+#define P_ENCI_SYNC_VOFFST VCBUS_REG_ADDR(ENCI_SYNC_VOFFST)
+#define ENCI_SYNC_ADJ 0x1b12	/* register.h:8203 */
+#define P_ENCI_SYNC_ADJ VCBUS_REG_ADDR(ENCI_SYNC_ADJ)
+#define ENCI_RGB_SETTING 0x1b13	/* register.h:8204 */
+#define P_ENCI_RGB_SETTING VCBUS_REG_ADDR(ENCI_RGB_SETTING)
+#define ENCI_DE_H_BEGIN 0x1b16	/* register.h:8207 */
+#define P_ENCI_DE_H_BEGIN VCBUS_REG_ADDR(ENCI_DE_H_BEGIN)
+#define ENCI_DE_H_END 0x1b17	/* register.h:8208 */
+#define P_ENCI_DE_H_END VCBUS_REG_ADDR(ENCI_DE_H_END)
+#define ENCI_DE_V_BEGIN_EVEN 0x1b18	/* register.h:8209 */
+#define P_ENCI_DE_V_BEGIN_EVEN VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_EVEN)
+#define ENCI_DE_V_END_EVEN 0x1b19	/* register.h:8210 */
+#define P_ENCI_DE_V_END_EVEN VCBUS_REG_ADDR(ENCI_DE_V_END_EVEN)
+#define ENCI_DE_V_BEGIN_ODD 0x1b1a	/* register.h:8211 */
+#define P_ENCI_DE_V_BEGIN_ODD VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_ODD)
+#define ENCI_DE_V_END_ODD 0x1b1b	/* register.h:8212 */
+#define P_ENCI_DE_V_END_ODD VCBUS_REG_ADDR(ENCI_DE_V_END_ODD)
+#define ENCI_VBI_SETTING 0x1b20	/* register.h:8213 */
+#define P_ENCI_VBI_SETTING VCBUS_REG_ADDR(ENCI_VBI_SETTING)
+#define ENCI_VBI_CCDT_EVN 0x1b21	/* register.h:8214 */
+#define P_ENCI_VBI_CCDT_EVN VCBUS_REG_ADDR(ENCI_VBI_CCDT_EVN)
+#define ENCI_VBI_CCDT_ODD 0x1b22	/* register.h:8215 */
+#define P_ENCI_VBI_CCDT_ODD VCBUS_REG_ADDR(ENCI_VBI_CCDT_ODD)
+#define ENCI_VBI_CC525_LN 0x1b23	/* register.h:8216 */
+#define P_ENCI_VBI_CC525_LN VCBUS_REG_ADDR(ENCI_VBI_CC525_LN)
+#define ENCI_VBI_CC625_LN 0x1b24	/* register.h:8217 */
+#define P_ENCI_VBI_CC625_LN VCBUS_REG_ADDR(ENCI_VBI_CC625_LN)
+#define ENCI_VBI_WSSDT 0x1b25	/* register.h:8218 */
+#define P_ENCI_VBI_WSSDT VCBUS_REG_ADDR(ENCI_VBI_WSSDT)
+#define ENCI_VBI_WSS_LN 0x1b26	/* register.h:8219 */
+#define P_ENCI_VBI_WSS_LN VCBUS_REG_ADDR(ENCI_VBI_WSS_LN)
+#define ENCI_VBI_CGMSDT_L 0x1b27	/* register.h:8220 */
+#define P_ENCI_VBI_CGMSDT_L VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_L)
+#define ENCI_VBI_CGMSDT_H 0x1b28	/* register.h:8221 */
+#define P_ENCI_VBI_CGMSDT_H VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_H)
+#define ENCI_VBI_CGMS_LN 0x1b29	/* register.h:8222 */
+#define P_ENCI_VBI_CGMS_LN VCBUS_REG_ADDR(ENCI_VBI_CGMS_LN)
+#define ENCI_VBI_TTX_HTIME 0x1b2a	/* register.h:8223 */
+#define P_ENCI_VBI_TTX_HTIME VCBUS_REG_ADDR(ENCI_VBI_TTX_HTIME)
+#define ENCI_VBI_TTX_LN 0x1b2b	/* register.h:8224 */
+#define P_ENCI_VBI_TTX_LN VCBUS_REG_ADDR(ENCI_VBI_TTX_LN)
+#define ENCI_VBI_TTXDT0 0x1b2c	/* register.h:8225 */
+#define P_ENCI_VBI_TTXDT0 VCBUS_REG_ADDR(ENCI_VBI_TTXDT0)
+#define ENCI_VBI_TTXDT1 0x1b2d	/* register.h:8226 */
+#define P_ENCI_VBI_TTXDT1 VCBUS_REG_ADDR(ENCI_VBI_TTXDT1)
+#define ENCI_VBI_TTXDT2 0x1b2e	/* register.h:8227 */
+#define P_ENCI_VBI_TTXDT2 VCBUS_REG_ADDR(ENCI_VBI_TTXDT2)
+#define ENCI_VBI_TTXDT3 0x1b2f	/* register.h:8228 */
+#define P_ENCI_VBI_TTXDT3 VCBUS_REG_ADDR(ENCI_VBI_TTXDT3)
+#define ENCI_MACV_N0 0x1b30	/* register.h:8229 */
+#define P_ENCI_MACV_N0 VCBUS_REG_ADDR(ENCI_MACV_N0)
+#define ENCI_MACV_N1 0x1b31	/* register.h:8230 */
+#define P_ENCI_MACV_N1 VCBUS_REG_ADDR(ENCI_MACV_N1)
+#define ENCI_MACV_N2 0x1b32	/* register.h:8231 */
+#define P_ENCI_MACV_N2 VCBUS_REG_ADDR(ENCI_MACV_N2)
+#define ENCI_MACV_N3 0x1b33	/* register.h:8232 */
+#define P_ENCI_MACV_N3 VCBUS_REG_ADDR(ENCI_MACV_N3)
+#define ENCI_MACV_N4 0x1b34	/* register.h:8233 */
+#define P_ENCI_MACV_N4 VCBUS_REG_ADDR(ENCI_MACV_N4)
+#define ENCI_MACV_N5 0x1b35	/* register.h:8234 */
+#define P_ENCI_MACV_N5 VCBUS_REG_ADDR(ENCI_MACV_N5)
+#define ENCI_MACV_N6 0x1b36	/* register.h:8235 */
+#define P_ENCI_MACV_N6 VCBUS_REG_ADDR(ENCI_MACV_N6)
+#define ENCI_MACV_N7 0x1b37	/* register.h:8236 */
+#define P_ENCI_MACV_N7 VCBUS_REG_ADDR(ENCI_MACV_N7)
+#define ENCI_MACV_N8 0x1b38	/* register.h:8237 */
+#define P_ENCI_MACV_N8 VCBUS_REG_ADDR(ENCI_MACV_N8)
+#define ENCI_MACV_N9 0x1b39	/* register.h:8238 */
+#define P_ENCI_MACV_N9 VCBUS_REG_ADDR(ENCI_MACV_N9)
+#define ENCI_MACV_N10 0x1b3a	/* register.h:8239 */
+#define P_ENCI_MACV_N10 VCBUS_REG_ADDR(ENCI_MACV_N10)
+#define ENCI_MACV_N11 0x1b3b	/* register.h:8240 */
+#define P_ENCI_MACV_N11 VCBUS_REG_ADDR(ENCI_MACV_N11)
+#define ENCI_MACV_N12 0x1b3c	/* register.h:8241 */
+#define P_ENCI_MACV_N12 VCBUS_REG_ADDR(ENCI_MACV_N12)
+#define ENCI_MACV_N13 0x1b3d	/* register.h:8242 */
+#define P_ENCI_MACV_N13 VCBUS_REG_ADDR(ENCI_MACV_N13)
+#define ENCI_MACV_N14 0x1b3e	/* register.h:8243 */
+#define P_ENCI_MACV_N14 VCBUS_REG_ADDR(ENCI_MACV_N14)
+#define ENCI_MACV_N15 0x1b3f	/* register.h:8244 */
+#define P_ENCI_MACV_N15 VCBUS_REG_ADDR(ENCI_MACV_N15)
+#define ENCI_MACV_N16 0x1b40	/* register.h:8245 */
+#define P_ENCI_MACV_N16 VCBUS_REG_ADDR(ENCI_MACV_N16)
+#define ENCI_MACV_N17 0x1b41	/* register.h:8246 */
+#define P_ENCI_MACV_N17 VCBUS_REG_ADDR(ENCI_MACV_N17)
+#define ENCI_MACV_N18 0x1b42	/* register.h:8247 */
+#define P_ENCI_MACV_N18 VCBUS_REG_ADDR(ENCI_MACV_N18)
+#define ENCI_MACV_N19 0x1b43	/* register.h:8248 */
+#define P_ENCI_MACV_N19 VCBUS_REG_ADDR(ENCI_MACV_N19)
+#define ENCI_MACV_N20 0x1b44	/* register.h:8249 */
+#define P_ENCI_MACV_N20 VCBUS_REG_ADDR(ENCI_MACV_N20)
+#define ENCI_MACV_N21 0x1b45	/* register.h:8250 */
+#define P_ENCI_MACV_N21 VCBUS_REG_ADDR(ENCI_MACV_N21)
+#define ENCI_MACV_N22 0x1b46	/* register.h:8251 */
+#define P_ENCI_MACV_N22 VCBUS_REG_ADDR(ENCI_MACV_N22)
+#define ENCI_DBG_PX_RST 0x1b48	/* register.h:8253 */
+#define P_ENCI_DBG_PX_RST VCBUS_REG_ADDR(ENCI_DBG_PX_RST)
+#define ENCI_DBG_FLDLN_RST 0x1b49	/* register.h:8254 */
+#define P_ENCI_DBG_FLDLN_RST VCBUS_REG_ADDR(ENCI_DBG_FLDLN_RST)
+#define ENCI_DBG_PX_INT 0x1b4a	/* register.h:8255 */
+#define P_ENCI_DBG_PX_INT VCBUS_REG_ADDR(ENCI_DBG_PX_INT)
+#define ENCI_DBG_FLDLN_INT 0x1b4b	/* register.h:8256 */
+#define P_ENCI_DBG_FLDLN_INT VCBUS_REG_ADDR(ENCI_DBG_FLDLN_INT)
+#define ENCI_DBG_MAXPX 0x1b4c	/* register.h:8257 */
+#define P_ENCI_DBG_MAXPX VCBUS_REG_ADDR(ENCI_DBG_MAXPX)
+#define ENCI_DBG_MAXLN 0x1b4d	/* register.h:8258 */
+#define P_ENCI_DBG_MAXLN VCBUS_REG_ADDR(ENCI_DBG_MAXLN)
+#define ENCI_MACV_MAX_AMP 0x1b50	/* register.h:8259 */
+#define P_ENCI_MACV_MAX_AMP VCBUS_REG_ADDR(ENCI_MACV_MAX_AMP)
+#define ENCI_MACV_PULSE_LO 0x1b51	/* register.h:8260 */
+#define P_ENCI_MACV_PULSE_LO VCBUS_REG_ADDR(ENCI_MACV_PULSE_LO)
+#define ENCI_MACV_PULSE_HI 0x1b52	/* register.h:8261 */
+#define P_ENCI_MACV_PULSE_HI VCBUS_REG_ADDR(ENCI_MACV_PULSE_HI)
+#define ENCI_MACV_BKP_MAX 0x1b53	/* register.h:8262 */
+#define P_ENCI_MACV_BKP_MAX VCBUS_REG_ADDR(ENCI_MACV_BKP_MAX)
+#define ENCI_CFILT_CTRL 0x1b54	/* register.h:8263 */
+#define P_ENCI_CFILT_CTRL VCBUS_REG_ADDR(ENCI_CFILT_CTRL)
+#define ENCI_CFILT7 0x1b55	/* register.h:8264 */
+#define P_ENCI_CFILT7 VCBUS_REG_ADDR(ENCI_CFILT7)
+#define ENCI_YC_DELAY 0x1b56	/* register.h:8265 */
+#define P_ENCI_YC_DELAY VCBUS_REG_ADDR(ENCI_YC_DELAY)
+#define ENCI_VIDEO_EN 0x1b57	/* register.h:8266 */
+#define P_ENCI_VIDEO_EN VCBUS_REG_ADDR(ENCI_VIDEO_EN)
+#define VENC_VIDEO_PROG_MODE 0x1b68	/* /../ucode/register.h:8023 */
+#define P_VENC_VIDEO_PROG_MODE		VCBUS_REG_ADDR(VENC_VIDEO_PROG_MODE)
+
+#define ENCI_DVI_HSO_BEGIN 0x1c00	/* register.h:8280 */
+#define P_ENCI_DVI_HSO_BEGIN VCBUS_REG_ADDR(ENCI_DVI_HSO_BEGIN)
+#define ENCI_DVI_HSO_END 0x1c01	/* register.h:8281 */
+#define P_ENCI_DVI_HSO_END VCBUS_REG_ADDR(ENCI_DVI_HSO_END)
+#define ENCI_DVI_VSO_BLINE_EVN 0x1c02	/* register.h:8282 */
+#define P_ENCI_DVI_VSO_BLINE_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_BLINE_EVN)
+#define ENCI_DVI_VSO_BLINE_ODD 0x1c03	/* register.h:8283 */
+#define P_ENCI_DVI_VSO_BLINE_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_BLINE_ODD)
+#define ENCI_DVI_VSO_ELINE_EVN 0x1c04	/* register.h:8284 */
+#define P_ENCI_DVI_VSO_ELINE_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_ELINE_EVN)
+#define ENCI_DVI_VSO_ELINE_ODD 0x1c05	/* register.h:8285 */
+#define P_ENCI_DVI_VSO_ELINE_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_ELINE_ODD)
+#define ENCI_DVI_VSO_BEGIN_EVN 0x1c06	/* register.h:8286 */
+#define P_ENCI_DVI_VSO_BEGIN_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_BEGIN_EVN)
+#define ENCI_DVI_VSO_BEGIN_ODD 0x1c07	/* register.h:8287 */
+#define P_ENCI_DVI_VSO_BEGIN_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_BEGIN_ODD)
+#define ENCI_DVI_VSO_END_EVN 0x1c08	/* register.h:8288 */
+#define P_ENCI_DVI_VSO_END_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_END_EVN)
+#define ENCI_DVI_VSO_END_ODD 0x1c09	/* register.h:8289 */
+#define P_ENCI_DVI_VSO_END_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_END_ODD)
+#define ENCI_CFILT_CTRL2 0x1c0a	/* register.h:8295 */
+#define P_ENCI_CFILT_CTRL2 VCBUS_REG_ADDR(ENCI_CFILT_CTRL2)
+#define ENCI_DACSEL_0 0x1c0b	/* register.h:8296 */
+#define P_ENCI_DACSEL_0 VCBUS_REG_ADDR(ENCI_DACSEL_0)
+#define ENCI_DACSEL_1 0x1c0c	/* register.h:8297 */
+#define P_ENCI_DACSEL_1 VCBUS_REG_ADDR(ENCI_DACSEL_1)
+#define ENCP_DACSEL_0 0x1c0d	/* register.h:8298 */
+#define P_ENCP_DACSEL_0 VCBUS_REG_ADDR(ENCP_DACSEL_0)
+#define ENCP_DACSEL_1 0x1c0e	/* register.h:8299 */
+#define P_ENCP_DACSEL_1 VCBUS_REG_ADDR(ENCP_DACSEL_1)
+#define ENCP_MAX_LINE_SWITCH_POINT 0x1c0f	/* register.h:8300 */
+#define P_ENCP_MAX_LINE_SWITCH_POINT VCBUS_REG_ADDR(ENCP_MAX_LINE_SWITCH_POINT)
+#define ENCI_TST_EN 0x1c10	/* register.h:8301 */
+#define P_ENCI_TST_EN VCBUS_REG_ADDR(ENCI_TST_EN)
+#define ENCI_TST_MDSEL 0x1c11	/* register.h:8302 */
+#define P_ENCI_TST_MDSEL VCBUS_REG_ADDR(ENCI_TST_MDSEL)
+#define ENCI_TST_Y 0x1c12	/* register.h:8303 */
+#define P_ENCI_TST_Y VCBUS_REG_ADDR(ENCI_TST_Y)
+#define ENCI_TST_CB 0x1c13	/* register.h:8304 */
+#define P_ENCI_TST_CB VCBUS_REG_ADDR(ENCI_TST_CB)
+#define ENCI_TST_CR 0x1c14	/* register.h:8305 */
+#define P_ENCI_TST_CR VCBUS_REG_ADDR(ENCI_TST_CR)
+#define ENCI_TST_CLRBAR_STRT 0x1c15	/* register.h:8306 */
+#define P_ENCI_TST_CLRBAR_STRT VCBUS_REG_ADDR(ENCI_TST_CLRBAR_STRT)
+#define ENCI_TST_CLRBAR_WIDTH 0x1c16	/* register.h:8307 */
+#define P_ENCI_TST_CLRBAR_WIDTH VCBUS_REG_ADDR(ENCI_TST_CLRBAR_WIDTH)
+#define ENCI_TST_VDCNT_STSET 0x1c17	/* register.h:8308 */
+#define P_ENCI_TST_VDCNT_STSET VCBUS_REG_ADDR(ENCI_TST_VDCNT_STSET)
+#define ENCI_VFIFO2VD_CTL 0x1c18	/* register.h:8313 */
+#define P_ENCI_VFIFO2VD_CTL VCBUS_REG_ADDR(ENCI_VFIFO2VD_CTL)
+#define ENCI_VFIFO2VD_PIXEL_START 0x1c19	/* register.h:8315 */
+#define P_ENCI_VFIFO2VD_PIXEL_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_PIXEL_START)
+#define ENCI_VFIFO2VD_PIXEL_END 0x1c1a	/* register.h:8317 */
+#define P_ENCI_VFIFO2VD_PIXEL_END VCBUS_REG_ADDR(ENCI_VFIFO2VD_PIXEL_END)
+#define ENCI_VFIFO2VD_LINE_TOP_START 0x1c1b	/* register.h:8319 */
+#define P_ENCI_VFIFO2VD_LINE_TOP_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_TOP_START)
+#define ENCI_VFIFO2VD_LINE_TOP_END 0x1c1c	/* register.h:8321 */
+#define P_ENCI_VFIFO2VD_LINE_TOP_END \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_TOP_END)
+#define ENCI_VFIFO2VD_LINE_BOT_START 0x1c1d	/* register.h:8323 */
+#define P_ENCI_VFIFO2VD_LINE_BOT_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_BOT_START)
+#define ENCI_VFIFO2VD_LINE_BOT_END 0x1c1e	/* register.h:8325 */
+#define P_ENCI_VFIFO2VD_LINE_BOT_END \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_BOT_END)
+#define ENCI_VFIFO2VD_CTL2 0x1c1f	/* register.h:8326 */
+#define P_ENCI_VFIFO2VD_CTL2 VCBUS_REG_ADDR(ENCI_VFIFO2VD_CTL2)
+
+#define ENCP_DVI_HSO_BEGIN 0x1c30	/* register.h:8354 */
+#define P_ENCP_DVI_HSO_BEGIN VCBUS_REG_ADDR(ENCP_DVI_HSO_BEGIN)
+#define ENCP_DVI_HSO_END 0x1c31	/* register.h:8355 */
+#define P_ENCP_DVI_HSO_END VCBUS_REG_ADDR(ENCP_DVI_HSO_END)
+#define ENCP_DVI_VSO_BLINE_EVN 0x1c32	/* register.h:8356 */
+#define P_ENCP_DVI_VSO_BLINE_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_BLINE_EVN)
+#define ENCP_DVI_VSO_BLINE_ODD 0x1c33	/* register.h:8357 */
+#define P_ENCP_DVI_VSO_BLINE_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_BLINE_ODD)
+#define ENCP_DVI_VSO_ELINE_EVN 0x1c34	/* register.h:8358 */
+#define P_ENCP_DVI_VSO_ELINE_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_ELINE_EVN)
+#define ENCP_DVI_VSO_ELINE_ODD 0x1c35	/* register.h:8359 */
+#define P_ENCP_DVI_VSO_ELINE_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_ELINE_ODD)
+#define ENCP_DVI_VSO_BEGIN_EVN 0x1c36	/* register.h:8360 */
+#define P_ENCP_DVI_VSO_BEGIN_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_BEGIN_EVN)
+#define ENCP_DVI_VSO_BEGIN_ODD 0x1c37	/* register.h:8361 */
+#define P_ENCP_DVI_VSO_BEGIN_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_BEGIN_ODD)
+#define ENCP_DVI_VSO_END_EVN 0x1c38	/* register.h:8362 */
+#define P_ENCP_DVI_VSO_END_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_END_EVN)
+#define ENCP_DVI_VSO_END_ODD 0x1c39	/* register.h:8363 */
+#define P_ENCP_DVI_VSO_END_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_END_ODD)
+#define ENCP_DE_H_BEGIN 0x1c3a	/* register.h:8364 */
+#define P_ENCP_DE_H_BEGIN VCBUS_REG_ADDR(ENCP_DE_H_BEGIN)
+#define ENCP_DE_H_END 0x1c3b	/* register.h:8365 */
+#define P_ENCP_DE_H_END VCBUS_REG_ADDR(ENCP_DE_H_END)
+#define ENCP_DE_V_BEGIN_EVEN 0x1c3c	/* register.h:8366 */
+#define P_ENCP_DE_V_BEGIN_EVEN VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_EVEN)
+#define ENCP_DE_V_END_EVEN 0x1c3d	/* register.h:8367 */
+#define P_ENCP_DE_V_END_EVEN VCBUS_REG_ADDR(ENCP_DE_V_END_EVEN)
+#define ENCP_DE_V_BEGIN_ODD 0x1c3e	/* register.h:8368 */
+#define P_ENCP_DE_V_BEGIN_ODD VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_ODD)
+#define ENCP_DE_V_END_ODD 0x1c3f	/* register.h:8369 */
+#define P_ENCP_DE_V_END_ODD VCBUS_REG_ADDR(ENCP_DE_V_END_ODD)
+#define ENCI_SYNC_LINE_LENGTH 0x1c40	/* register.h:8372 */
+#define P_ENCI_SYNC_LINE_LENGTH VCBUS_REG_ADDR(ENCI_SYNC_LINE_LENGTH)
+#define ENCI_SYNC_PIXEL_EN 0x1c41	/* register.h:8375 */
+#define P_ENCI_SYNC_PIXEL_EN VCBUS_REG_ADDR(ENCI_SYNC_PIXEL_EN)
+#define ENCI_SYNC_TO_LINE_EN 0x1c42	/* register.h:8382 */
+#define P_ENCI_SYNC_TO_LINE_EN VCBUS_REG_ADDR(ENCI_SYNC_TO_LINE_EN)
+#define ENCI_SYNC_TO_PIXEL 0x1c43	/* register.h:8384 */
+#define P_ENCI_SYNC_TO_PIXEL VCBUS_REG_ADDR(ENCI_SYNC_TO_PIXEL)
+#define ENCP_SYNC_LINE_LENGTH 0x1c44	/* register.h:8387 */
+#define P_ENCP_SYNC_LINE_LENGTH VCBUS_REG_ADDR(ENCP_SYNC_LINE_LENGTH)
+#define ENCP_SYNC_PIXEL_EN 0x1c45	/* register.h:8390 */
+#define P_ENCP_SYNC_PIXEL_EN VCBUS_REG_ADDR(ENCP_SYNC_PIXEL_EN)
+#define ENCP_SYNC_TO_LINE_EN 0x1c46	/* register.h:8397 */
+#define P_ENCP_SYNC_TO_LINE_EN VCBUS_REG_ADDR(ENCP_SYNC_TO_LINE_EN)
+#define ENCP_SYNC_TO_PIXEL 0x1c47	/* register.h:8399 */
+#define P_ENCP_SYNC_TO_PIXEL VCBUS_REG_ADDR(ENCP_SYNC_TO_PIXEL)
+
+/* [3:2] cntl_viu2_sel_venc: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT. */
+/* [1:0] cntl_viu1_sel_venc: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT. */
+#define VPU_VIU_VENC_MUX_CTRL 0x271a	/* register.h:9214 */
+#define P_VPU_VIU_VENC_MUX_CTRL VCBUS_REG_ADDR(VPU_VIU_VENC_MUX_CTRL)
+#define VPU_HDMI_SETTING 0x271b	/* register.h:9229 */
+#define P_VPU_HDMI_SETTING VCBUS_REG_ADDR(VPU_HDMI_SETTING)
+
+#define VPU_HDMI_DATA_OVR 0x2727	/* register.h:9270 */
+#define P_VPU_HDMI_DATA_OVR VCBUS_REG_ADDR(VPU_HDMI_DATA_OVR)
+#define VPU_HDMI_FMT_CTRL 0x2743
+#define P_VPU_HDMI_FMT_CTRL VCBUS_REG_ADDR(VPU_HDMI_FMT_CTRL)
+
+/* c_always_on_pointer.h:71 */
+#define AO_RTI_PULL_UP_REG ((0x00 << 10) | (0x0B << 2))
+#define P_AO_RTI_PULL_UP_REG		AOBUS_REG_ADDR(AO_RTI_PULL_UP_REG)
+#define AO_RTI_PIN_MUX_REG ((0x00 << 10) | (0x05 << 2))
+#define P_AO_RTI_PIN_MUX_REG		AOBUS_REG_ADDR(AO_RTI_PIN_MUX_REG)
+#define AO_DEBUG_REG0 ((0x00 << 10) | (0x28 << 2))
+#define P_AO_DEBUG_REG0		AOBUS_REG_ADDR(AO_DEBUG_REG0)
+#define AO_DEBUG_REG1 ((0x00 << 10) | (0x29 << 2))
+#define P_AO_DEBUG_REG1		AOBUS_REG_ADDR(AO_DEBUG_REG1)
+#define AO_DEBUG_REG2 ((0x00 << 10) | (0x2a << 2))
+#define P_AO_DEBUG_REG2		AOBUS_REG_ADDR(AO_DEBUG_REG2)
+#define AO_DEBUG_REG3 ((0x00 << 10) | (0x2b << 2))
+#define P_AO_DEBUG_REG3		AOBUS_REG_ADDR(AO_DEBUG_REG3)
+#define AO_CEC_GEN_CNTL ((0x00 << 10) | (0x40 << 2))
+#define P_AO_CEC_GEN_CNTL		AOBUS_REG_ADDR(AO_CEC_GEN_CNTL)
+#define AO_CEC_RW_REG ((0x00 << 10) | (0x41 << 2))
+#define P_AO_CEC_RW_REG		AOBUS_REG_ADDR(AO_CEC_RW_REG)
+#define AO_CEC_INTR_MASKN ((0x00 << 10) | (0x42 << 2))
+#define P_AO_CEC_INTR_MASKN		AOBUS_REG_ADDR(AO_CEC_INTR_MASKN)
+#define AO_CEC_INTR_CLR ((0x00 << 10) | (0x43 << 2))
+#define P_AO_CEC_INTR_CLR		AOBUS_REG_ADDR(AO_CEC_INTR_CLR)
+#define AO_CEC_INTR_STAT ((0x00 << 10) | (0x44 << 2))
+#define P_AO_CEC_INTR_STAT		AOBUS_REG_ADDR(AO_CEC_INTR_STAT)
+
+#define P_AO_RTI_GEN_PWR_SLEEP0 (0xc8100000 + (0x3a << 2))
+
+#define P_HDMITX_ADDR_PORT_SEC        0xda83a000
+#define P_HDMITX_DATA_PORT_SEC        0xda83a004
+#define P_HDMITX_CTRL_PORT_SEC        0xda83a008
+/* secure address P_HDMITX_ADDR_PORT 0xda83a000 */
+#define P_HDMITX_ADDR_PORT        0xc883a000
+#define P_HDMITX_DATA_PORT        0xc883a004
+#define P_HDMITX_CTRL_PORT        0xc883a008
+
+#endif
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/reg_ops.c b/arch/arm/cpu/armv8/gxb/hdmitx20/reg_ops.c
new file mode 100644
index 0000000..e194aed
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/reg_ops.c
@@ -0,0 +1,104 @@
+#include <common.h>
+#include <asm/arch/io.h>
+#include <asm/io.h>
+#include "mach_reg.h"
+#include "hdmitx_reg.h"
+#include <amlogic/hdmi.h>
+
+static int dbg_en;
+
+void hd_write_reg(unsigned long addr, unsigned long val)
+{
+	writel(val, addr);
+	if (dbg_en)
+		printk("W: 0x%08lx  0x%08lx %s 0x%08lx\n", addr, val, (val == hd_read_reg(addr)) ? "==" : "!=", hd_read_reg(addr));
+}
+
+unsigned long hd_read_reg(unsigned long addr)
+{
+	unsigned long val = 0;
+	val = readl(addr);
+	if (dbg_en)
+		printk("R: 0x%08lx   0x%08lx\n", addr, val);
+	return val;
+}
+
+void hd_set_reg_bits(unsigned long addr, unsigned long value,
+	unsigned long offset, unsigned long len)
+{
+	unsigned long data = 0;
+
+	data = hd_read_reg(addr);
+	data &= ~(((1L << len) - 1) << offset);
+	data |= (value & ((1L << len) - 1)) << offset;
+	hd_write_reg(addr, data);
+}
+
+unsigned int hdmitx_rd_reg(unsigned int addr)
+{
+	unsigned int data = 0;
+	unsigned long offset = (addr & DWC_OFFSET_MASK) >> 24;
+
+	if (addr & SEC_OFFSET) {
+		/* TODO */
+		/* LATER */
+	} else {
+		addr = addr & 0xffff;
+
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		data = hd_read_reg(P_HDMITX_DATA_PORT + offset);
+	}
+	if (dbg_en)
+		pr_info("%s rd[0x%x] 0x%x\n", offset ? "DWC" : "TOP",
+			addr, data);
+	return data;
+}
+
+void hdmitx_wr_reg(unsigned int addr, unsigned int data)
+{
+	unsigned long offset = (addr & DWC_OFFSET_MASK) >> 24;
+
+	if (addr & SEC_OFFSET) {
+		/* TODO */
+		/* LATER */
+	} else {
+		addr = addr & 0xffff;
+
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		hd_write_reg(P_HDMITX_DATA_PORT + offset, data);
+	}
+	if (dbg_en)
+		pr_info("%s wr[0x%x] 0x%x\n", offset ? "DWC" : "TOP",
+			addr, data);
+}
+
+void hdmitx_set_reg_bits(unsigned int addr, unsigned int value,
+	unsigned int offset, unsigned int len)
+{
+	unsigned int data32 = 0;
+
+	data32 = hdmitx_rd_reg(addr);
+	data32 &= ~(((1 << len) - 1) << offset);
+	data32 |= (value & ((1 << len) - 1)) << offset;
+	hdmitx_wr_reg(addr, data32);
+}
+
+void hdmitx_poll_reg(unsigned int addr, unsigned int val, unsigned long timeout)
+{
+	udelay(2000);
+	if (!(hdmitx_rd_reg(addr) & val))
+		pr_info("hdmitx poll:0x%x  val:0x%x t=%dms timeout\n",
+			addr, val, 2000);
+}
+
+void hdmitx_rd_check_reg (unsigned long addr, unsigned long exp_data, unsigned long mask)
+{
+    unsigned long rd_data;
+    rd_data = hdmitx_rd_reg(addr);
+    if ((rd_data | mask) != (exp_data | mask)) {
+        pr_info("HDMITX-DWC addr=0x%04x rd_data=0x%02x\n", (unsigned int)addr, (unsigned int)rd_data);
+        pr_info("Error: HDMITX-DWC exp_data=0x%02x mask=0x%02x\n", (unsigned int)exp_data, (unsigned int)mask);
+    }
+}
diff --git a/arch/arm/cpu/armv8/gxb/mailbox.c b/arch/arm/cpu/armv8/gxb/mailbox.c
new file mode 100644
index 0000000..020e316
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/mailbox.c
@@ -0,0 +1,152 @@
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/arch/mailbox.h>
+#include <asm/arch/secure_apb.h>
+
+/* Bit position for size value in MHU header */
+#define SIZE_SHIFT	20
+/* Mask to extract size value in MHU header*/
+#define SIZE_MASK	0x1ff
+
+static unsigned int *ap_mb_stat[] = {
+	(unsigned int *)HIU_MAILBOX_STAT_4,
+	(unsigned int *)HIU_MAILBOX_STAT_5,
+};
+static unsigned int *ap_mb_set[] = {
+	(unsigned int *)HIU_MAILBOX_SET_4,
+	(unsigned int *)HIU_MAILBOX_SET_5,
+};
+static unsigned int *ap_mb_clear[] = {
+	(unsigned int *)HIU_MAILBOX_CLR_4,
+	(unsigned int *)HIU_MAILBOX_CLR_5,
+};
+static unsigned int *ap_mb_payload[] = {
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_LOW_AP_TO_SCP_PAYLOAD),
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_HIGH_AP_TO_SCP_PAYLOAD),
+};
+static unsigned int *scp_mb_stat[] = {
+	(unsigned int *)HIU_MAILBOX_STAT_1,
+	(unsigned int *)HIU_MAILBOX_STAT_2,
+};
+/*
+static unsigned int *scp_mb_set[] = {
+	(unsigned int *)HIU_MAILBOX_SET_1,
+	(unsigned int *)HIU_MAILBOX_SET_2,
+};
+*/
+static unsigned int *scp_mb_clear[] = {
+	(unsigned int *)HIU_MAILBOX_CLR_1,
+	(unsigned int *)HIU_MAILBOX_CLR_2,
+};
+static unsigned int *scp_mb_payload[] = {
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_LOW_SCP_TO_AP_PAYLOAD),
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_HIGH_SCP_TO_AP_PAYLOAD),
+};
+
+static void mb_message_start(unsigned int priority)
+{
+	while (readl(ap_mb_stat[priority]) != 0)
+		;
+}
+static void mb_message_send(unsigned int command, unsigned int priority)
+{
+	writel(command, ap_mb_set[priority]);
+	while (readl(ap_mb_stat[priority]) != 0)
+		;
+}
+static unsigned int mb_message_wait(unsigned int priority)
+{
+	unsigned int response;
+	while (!(response = readl(scp_mb_stat[priority])))
+		;
+	return response;
+}
+static void mb_message_end(unsigned int priority)
+{
+	writel(0xffffffff, scp_mb_clear[priority]);
+}
+static unsigned int mb_message_receive(
+					void **message_out,
+					unsigned int *size_out,
+					unsigned int priority)
+{
+	unsigned int response = mb_message_wait(priority);
+	unsigned int size = (response >> SIZE_SHIFT) & SIZE_MASK;
+
+	response &= ~(SIZE_MASK << SIZE_SHIFT);
+
+	if (size_out)
+		*size_out = size;
+	if (message_out)
+		*message_out = (void *)(scp_mb_payload[priority]);
+
+	return response;
+}
+static void mb_init(unsigned int priority)
+{
+	writel(0xffffffff, ap_mb_clear[priority]);
+}
+
+static void scpi_send32(unsigned int command,
+			unsigned int message, unsigned int priority)
+{
+	mb_init(priority);
+	mb_message_start(priority);
+	writel(message, ap_mb_payload[priority]);
+	mb_message_send(command, priority);
+	mb_message_wait(priority);
+	mb_message_end(priority);
+}
+
+void open_scp_log(void)
+{
+	scpi_send32(SCPI_CMD_OPEN_SCP_LOG, 0x1, LOW_PRIORITY);
+}
+
+/*
+*  type:
+*		0: data; 1: version
+*/
+int thermal_calibration(unsigned int type, unsigned int data)
+{
+	unsigned int *appayload = ap_mb_payload[LOW_PRIORITY];
+	unsigned int *response;
+	unsigned int size;
+
+	mb_message_start(LOW_PRIORITY);
+	writel(type, appayload);
+	writel(data, appayload+1);
+	mb_message_send(
+				((0x8 << SIZE_SHIFT) | SCPI_CMD_THERMAL_CALIB),
+				LOW_PRIORITY);
+	mb_message_receive((void *)&response, &size, LOW_PRIORITY);
+	mb_message_end(LOW_PRIORITY);
+
+	if (*response != SCPI_SUCCESS)
+		return -1;
+	else
+		return 0;
+}
+
+int thermal_get_value(unsigned int sensor_id, unsigned int *value)
+{
+	unsigned int *response;
+	unsigned int size;
+
+	mb_message_start(LOW_PRIORITY);
+	writel(sensor_id, ap_mb_payload[LOW_PRIORITY]);
+	mb_message_send(
+				((0x4 << SIZE_SHIFT) | SCPI_CMD_SENSOR_VALUE),
+				LOW_PRIORITY);
+	mb_message_receive((void *)&response, &size, LOW_PRIORITY);
+	mb_message_end(LOW_PRIORITY);
+
+	*value = *(response+1);
+	if (*response != SCPI_SUCCESS)
+		return -1;
+	else
+		return 0;
+}
diff --git a/arch/arm/cpu/armv8/gxb/power_gate.h b/arch/arm/cpu/armv8/gxb/power_gate.h
new file mode 100644
index 0000000..2ce9581
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/power_gate.h
@@ -0,0 +1,1142 @@
+#ifndef __POWER_MGR_HEADER_
+#define __POWER_MGR_HEADER_
+
+#include <asm/arch/io.h>
+#include <common.h>
+#include <asm/arch-gxb/io.h>
+/* #include <asm/arch-gxb/register.h> */
+#include <asm/arch/secure_apb.h>
+/* clock gate control */
+
+#define DEBUG_MASK 0
+
+#define SET_CLK_GATE_MASK(reg, mask) __raw_writel((__raw_readl(reg)|mask), reg)
+#define CLEAR_CLK_GATE_MASK(reg, mask) \
+	__raw_writel((__raw_readl(reg)&(~mask)), reg)
+#define CLK_GATE_ON(_MOD) do { \
+	if (DEBUG_MASK) \
+		printf("on reg %24s before read :0x%x : 0x%x\n",\
+				GCLK_NAME_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+		SET_CLK_GATE_MASK(GCLK_REG_##_MOD, \
+				(unsigned int)GCLK_MASK_##_MOD); \
+	if (DEBUG_MASK) \
+		printf("on reg %24s after  read :0x%x : 0x%x\n",\
+				GCLK_NAME_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+	} while (0)
+
+#define CLK_GATE_OFF(_MOD) do { \
+	if (DEBUG_MASK) \
+		printf("off reg[ %24s ][0x%08x]before read:0x%08x:0x%08x\n",\
+				GCLK_NAME_##_MOD, (int)GCLK_MASK_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+	CLEAR_CLK_GATE_MASK(GCLK_REG_##_MOD, (unsigned int)GCLK_MASK_##_MOD);\
+	if (DEBUG_MASK)\
+		printf("off reg[ %24s ][0x%08x] read after:0x%08x:0x%08x\n",\
+				GCLK_NAME_##_MOD, \
+				(int)GCLK_MASK_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+	} while (0)
+
+#define IS_CLK_GATE_ON(_MOD) (__raw_readl(GCLK_REG_##_MOD) & (GCLK_MASK_##_MOD))
+#define GATE_INIT(_MOD) GCLK_ref[GCLK_IDX_##_MOD] = IS_CLK_GATE_ON(_MOD) ? 1 : 0
+
+#define GCLK_IDX_DDR         0
+#define GCLK_NAME_DDR      "DDR"
+#define GCLK_DEV_DDR      "CLKGATE_DDR"
+#define GCLK_REG_DDR      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_DDR      (1<<0)
+
+#define GCLK_IDX_DOS         1
+#define GCLK_NAME_DOS      "DOS"
+#define GCLK_DEV_DOS      "CLKGATE_DOS"
+#define GCLK_REG_DOS      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_DOS      (1<<1)
+
+#define GCLK_IDX_RESERVED0_0         2
+#define GCLK_NAME_RESERVED0_0      "RESERVED0_0"
+#define GCLK_DEV_RESERVED0_0      "CLKGATE_RESERVED0_0"
+#define GCLK_REG_RESERVED0_0      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_0      (1<<2)
+
+#define GCLK_IDX_RESERVED0_1         3
+#define GCLK_NAME_RESERVED0_1      "RESERVED0_1"
+#define GCLK_DEV_RESERVED0_1      "CLKGATE_RESERVED0_1"
+#define GCLK_REG_RESERVED0_1      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_1      (1<<3)
+
+/* #define GCLK_IDX_AHB_BRIDGE         4 */
+/* #define GCLK_NAME_AHB_BRIDGE      "AHB_BRIDGE" */
+/* #define GCLK_DEV_AHB_BRIDGE      "CLKGATE_AHB_BRIDGE" */
+/* #define GCLK_REG_AHB_BRIDGE      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_AHB_BRIDGE      (1<<4) */
+
+#define GCLK_IDX_ISA         5
+#define GCLK_NAME_ISA      "ISA"
+#define GCLK_DEV_ISA      "CLKGATE_ISA"
+#define GCLK_REG_ISA      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_ISA      (1<<5)
+
+/* NEW ADD */
+#define GCLK_IDX_PL310_CBUS         6
+#define GCLK_NAME_PL310_CBUS      "PL310_CBUS"
+#define GCLK_DEV_PL310_CBUS      "CLKGATE_PL310_CBUS"
+#define GCLK_REG_PL310_CBUS      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_PL310_CBUS      (1<<6)
+
+#define GCLK_IDX_PERIPHS_TOP     7
+#define GCLK_NAME_PERIPHS_TOP      "PERIPHS_TOP"
+#define GCLK_DEV_PERIPHS_TOP      "CLKGATE_PERIPHS_TOP"
+#define GCLK_REG_PERIPHS_TOP      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_PERIPHS_TOP      (1<<7)
+
+#define GCLK_IDX_SPICC         8
+#define GCLK_NAME_SPICC      "SPICC"
+#define GCLK_DEV_SPICC      "CLKGATE_SPICC"
+#define GCLK_REG_SPICC      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_SPICC      (1<<8)
+
+#define GCLK_IDX_I2C         9
+#define GCLK_NAME_I2C      "I2C"
+#define GCLK_DEV_I2C      "CLKGATE_I2C"
+#define GCLK_REG_I2C      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_I2C      (1<<9)
+
+#define GCLK_IDX_SAR_ADC         10
+#define GCLK_NAME_SAR_ADC      "SAR_ADC"
+#define GCLK_DEV_SAR_ADC      "CLKGATE_SAR_ADC"
+#define GCLK_REG_SAR_ADC      (HHI_SAR_CLK_CNTL)
+#define GCLK_MASK_SAR_ADC      (1<<8)
+
+#define GCLK_IDX_SMART_CARD_MPEG_DOMAIN         11
+#define GCLK_NAME_SMART_CARD_MPEG_DOMAIN      "SMART_CARD_MPEG_DOMAIN"
+#define GCLK_DEV_SMART_CARD_MPEG_DOMAIN      "CLKGATE_SMART_CARD_MPEG_DOMAIN"
+#define GCLK_REG_SMART_CARD_MPEG_DOMAIN      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_SMART_CARD_MPEG_DOMAIN      (1<<11)
+
+#define GCLK_IDX_RANDOM_NUM_GEN         12
+#define GCLK_NAME_RANDOM_NUM_GEN      "RANDOM_NUM_GEN"
+#define GCLK_DEV_RANDOM_NUM_GEN      "CLKGATE_RANDOM_NUM_GEN"
+#define GCLK_REG_RANDOM_NUM_GEN      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RANDOM_NUM_GEN      (1<<12)
+
+#define GCLK_IDX_UART0         13
+#define GCLK_NAME_UART0      "UART0"
+#define GCLK_DEV_UART0      "CLKGATE_UART0"
+#define GCLK_REG_UART0      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_UART0      (1<<13)
+
+/* gxb no this clock gate */
+/* #define GCLK_IDX_SDHC         14 */
+/* #define GCLK_NAME_SDHC      "SDHC" */
+/* #define GCLK_DEV_SDHC      "CLKGATE_SDHC" */
+/* #define GCLK_REG_SDHC      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_SDHC      (1<<14) */
+
+#define GCLK_IDX_STREAM         15
+#define GCLK_NAME_STREAM      "STREAM"
+#define GCLK_DEV_STREAM      "CLKGATE_STREAM"
+#define GCLK_REG_STREAM      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_STREAM      (1<<15)
+
+#define GCLK_IDX_ASYNC_FIFO         16
+#define GCLK_NAME_ASYNC_FIFO      "ASYNC_FIFO"
+#define GCLK_DEV_ASYNC_FIFO      "CLKGATE_ASYNC_FIFO"
+#define GCLK_REG_ASYNC_FIFO      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_ASYNC_FIFO      (1<<16)
+
+/* gxb no this clock gate */
+/* #define GCLK_IDX_SDIO         17 */
+/* #define GCLK_NAME_SDIO      "SDIO" */
+/* #define GCLK_DEV_SDIO      "CLKGATE_SDIO" */
+/* #define GCLK_REG_SDIO      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_SDIO      (1<<17) */
+
+/* gxb no this clock gate */
+/* #define GCLK_IDX_AUD_BUF         18 */
+/* #define GCLK_NAME_AUD_BUF      "AUD_BUF" */
+/* #define GCLK_DEV_AUD_BUF      "CLKGATE_AUD_BUF" */
+/* #define GCLK_REG_AUD_BUF      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_AUD_BUF      (1<<18) */
+
+#define GCLK_IDX_HIU_PARSER         19
+#define GCLK_NAME_HIU_PARSER      "HIU_PARSER"
+#define GCLK_DEV_HIU_PARSER      "CLKGATE_HIU_PARSER"
+#define GCLK_REG_HIU_PARSER      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_HIU_PARSER      (1<<19)
+
+#define GCLK_IDX_RESERVED0_2         20
+#define GCLK_NAME_RESERVED0_2      "RESERVED0_2"
+#define GCLK_DEV_RESERVED0_2      "CLKGATE_RESERVED0_2"
+#define GCLK_REG_RESERVED0_2      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_2      (1<<20)
+
+/* NEW ADD */
+#define GCLK_IDX_RESERVED0_3         21
+#define GCLK_NAME_RESERVED0_3      "RESERVED0_3 "
+#define GCLK_DEV_RESERVED0_3      "CLKGATE_RESERVED0_3 "
+#define GCLK_REG_RESERVED0_3      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_3      (1<<21)
+
+#define GCLK_IDX_RESERVED0_4         22
+#define GCLK_NAME_RESERVED0_4      "RESERVED0_4"
+#define GCLK_DEV_RESERVED0_4      "CLKGATE_RESERVED0_4"
+#define GCLK_REG_RESERVED0_4      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_4      (1<<22)
+
+#define GCLK_IDX_ASSIST_MISC         23
+#define GCLK_NAME_ASSIST_MISC      "ASSIST_MISC"
+#define GCLK_DEV_ASSIST_MISC      "CLKGATE_ASSIST_MISC"
+#define GCLK_REG_ASSIST_MISC      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_ASSIST_MISC      (1<<23)
+
+
+#define  GCLK_IDX_EMMC_A         24
+#define GCLK_NAME_EMMC_A      "EMMC_A"
+#define  GCLK_DEV_EMMC_A     "CLKGATE_EMMC_A"
+#define  GCLK_REG_EMMC_A      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_EMMC_A      (1<<24)
+
+#define  GCLK_IDX_EMMC_B         25
+#define GCLK_NAME_EMMC_B      "EMMC_B"
+#define  GCLK_DEV_EMMC_B      "CLKGATE_EMMC_B"
+#define  GCLK_REG_EMMC_B      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_EMMC_B      (1<<25)
+
+#define  GCLK_IDX_EMMC_C         26
+#define GCLK_NAME_EMMC_C      "EMMC_C"
+#define  GCLK_DEV_EMMC_C      "CLKGATE_EMMC_C"
+#define  GCLK_REG_EMMC_C      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_EMMC_C      (1<<26)
+
+#define GCLK_IDX_RESERVED0_8         27
+#define GCLK_NAME_RESERVED0_8      "RESERVED0_8"
+#define GCLK_DEV_RESERVED0_8      "CLKGATE_RESERVED0_8"
+#define GCLK_REG_RESERVED0_8      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_8      (1<<27)
+
+#define GCLK_IDX_RESERVED0_9         28
+#define GCLK_NAME_RESERVED0_9      "RESERVED0_9"
+#define GCLK_DEV_RESERVED0_9      "CLKGATE_RESERVED0_9"
+#define GCLK_REG_RESERVED0_9      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_9      (1<<28)
+
+#define GCLK_IDX_RESERVED0_A         29
+#define GCLK_NAME_RESERVED0_A      "RESERVED0_A"
+#define GCLK_DEV_RESERVED0_A      "CLKGATE_RESERVED0_A"
+#define GCLK_REG_RESERVED0_A      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_A      (1<<29)
+
+#define GCLK_IDX_SPI         30
+#define GCLK_NAME_SPI      "SPI"
+#define GCLK_DEV_SPI      "CLKGATE_SPI"
+#define GCLK_REG_SPI      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_SPI      (1<<30)
+
+#define GCLK_IDX_RESERVED0_B         31
+#define GCLK_NAME_RESERVED0_B      "RESERVED0_B"
+#define GCLK_DEV_RESERVED0_B      "CLKGATE_RESERVED0_B"
+#define GCLK_REG_RESERVED0_B      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_B      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_RESERVED1_1         32
+#define GCLK_NAME_RESERVED1_1      "RESERVED1_1"
+#define GCLK_DEV_RESERVED1_1      "CLKGATE_RESERVED1_1"
+#define GCLK_REG_RESERVED1_1      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_1      (1<<0)
+
+
+#define GCLK_IDX_RESERVED1_2         33
+#define GCLK_NAME_RESERVED1_2      "RESERVED1_2"
+#define GCLK_DEV_RESERVED1_2      "CLKGATE_RESERVED1_2"
+#define GCLK_REG_RESERVED1_2      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_2      (1<<1)
+
+
+#define GCLK_IDX_AUD_IN         34
+#define GCLK_NAME_AUD_IN      "AUD_IN"
+#define GCLK_DEV_AUD_IN      "CLKGATE_AUD_IN"
+#define GCLK_REG_AUD_IN      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AUD_IN      (1<<2)
+
+#define GCLK_IDX_ETHERNET         35
+#define GCLK_NAME_ETHERNET      "ETHERNET"
+#define GCLK_DEV_ETHERNET      "CLKGATE_ETHERNET"
+#define GCLK_REG_ETHERNET      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_ETHERNET      (1<<3)
+
+#define GCLK_IDX_ETH_CLK     145
+#define GCLK_NAME_ETH_CLK    "ETH_CLK"
+#define GCLK_REG_ETH_CLK     (HHI_MPLL_CNTL10)
+#define GCLK_MASK_ETH_CLK      (1<<3)
+
+#define GCLK_IDX_DEMUX         36
+#define GCLK_NAME_DEMUX      "DEMUX"
+#define GCLK_DEV_DEMUX      "CLKGATE_DEMUX"
+#define GCLK_REG_DEMUX      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_DEMUX      (1<<4)
+
+#define GCLK_IDX_RESERVED1_3         37
+#define GCLK_NAME_RESERVED1_3      "RESERVED1_3"
+#define GCLK_DEV_RESERVED1_3      "CLKGATE_RESERVED1_3"
+#define GCLK_REG_RESERVED1_3      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_3      (1<<5)
+
+#define GCLK_IDX_AIU_AI_TOP_GLUE         38
+#define GCLK_NAME_AIU_AI_TOP_GLUE      "AIU_AI_TOP_GLUE"
+#define GCLK_DEV_AIU_AI_TOP_GLUE      "CLKGATE_AIU_AI_TOP_GLUE"
+#define GCLK_REG_AIU_AI_TOP_GLUE      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AI_TOP_GLUE      (1<<6)
+
+#define GCLK_IDX_AIU_IEC958         39
+#define GCLK_NAME_AIU_IEC958      "AIU_IEC958"
+#define GCLK_DEV_AIU_IEC958      "CLKGATE_AIU_IEC958"
+#define GCLK_REG_AIU_IEC958      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_IEC958      (1<<7)
+
+#define GCLK_IDX_AIU_I2S_OUT         40
+#define GCLK_NAME_AIU_I2S_OUT      "AIU_I2S_OUT"
+#define GCLK_DEV_AIU_I2S_OUT      "CLKGATE_AIU_I2S_OUT"
+#define GCLK_REG_AIU_I2S_OUT      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_I2S_OUT      (1<<8)
+
+#define GCLK_IDX_AIU_AMCLK_MEASURE         41
+#define GCLK_NAME_AIU_AMCLK_MEASURE      "AIU_AMCLK_MEASURE"
+#define GCLK_DEV_AIU_AMCLK_MEASURE      "CLKGATE_AIU_AMCLK_MEASURE"
+#define GCLK_REG_AIU_AMCLK_MEASURE      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AMCLK_MEASURE      (1<<9)
+
+#define GCLK_IDX_AIU_AIFIFO2         42
+#define GCLK_NAME_AIU_AIFIFO2      "AIU_AIFIFO2"
+#define GCLK_DEV_AIU_AIFIFO2      "CLKGATE_AIU_AIFIFO2"
+#define GCLK_REG_AIU_AIFIFO2      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AIFIFO2      (1<<10)
+
+#define GCLK_IDX_AIU_AUD_MIXER         43
+#define GCLK_NAME_AIU_AUD_MIXER      "AIU_AUD_MIXER"
+#define GCLK_DEV_AIU_AUD_MIXER      "CLKGATE_AIU_AUD_MIXER"
+#define GCLK_REG_AIU_AUD_MIXER      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AUD_MIXER      (1<<11)
+
+#define GCLK_IDX_AIU_MIXER_REG         44
+#define GCLK_NAME_AIU_MIXER_REG      "AIU_MIXER_REG"
+#define GCLK_DEV_AIU_MIXER_REG      "CLKGATE_AIU_MIXER_REG"
+#define GCLK_REG_AIU_MIXER_REG      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_MIXER_REG      (1<<12)
+
+#define GCLK_IDX_AIU_ADC         45
+#define GCLK_NAME_AIU_ADC      "AIU_ADC"
+#define GCLK_DEV_AIU_ADC      "CLKGATE_AIU_ADC"
+#define GCLK_REG_AIU_ADC      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_ADC      (1<<13)
+
+#define GCLK_IDX_BLK_MOV         46
+#define GCLK_NAME_BLK_MOV      "BLK_MOV"
+#define GCLK_DEV_BLK_MOV      "CLKGATE_BLK_MOV"
+#define GCLK_REG_BLK_MOV      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_BLK_MOV      (1<<14)
+
+/* NEW ADD */
+#define GCLK_IDX_AIU_TOP_LEVEL         47
+#define GCLK_NAME_AIU_TOP_LEVEL      "AIU_TOP_LEVEL"
+#define GCLK_DEV_AIU_TOP_LEVEL      "CLKGATE_AIU_TOP_LEVEL"
+#define GCLK_REG_AIU_TOP_LEVEL      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_TOP_LEVEL      (1<<15)
+
+#define GCLK_NAME_PCM_MCLK       "PCM_MCLK"
+#define GCLK_REG_PCM_MCLK        (HHI_PCM_CLK_CNTL)
+#define GCLK_MASK_PCM_MCLK       (1<<9)
+
+#define GCLK_NAME_PCM_SCLK       "PCM_SCLK"
+#define GCLK_REG_PCM_SCLK        (HHI_PCM_CLK_CNTL)
+#define GCLK_MASK_PCM_SCLK       (1<<22)
+
+#define GCLK_IDX_UART1         48
+#define GCLK_NAME_UART1      "UART1"
+#define GCLK_DEV_UART1      "CLKGATE_UART1"
+#define GCLK_REG_UART1      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_UART1      (1<<16)
+
+#define GCLK_IDX_RESERVED1_4         49
+#define GCLK_NAME_RESERVED1_4      "RESERVED1_4"
+#define GCLK_DEV_RESERVED1_4      "CLKGATE_RESERVED1_4"
+#define GCLK_REG_RESERVED1_4      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_4      (1<<17)
+
+/* NEW ADD */
+#define GCLK_IDX_RESERVED1_5         50
+#define GCLK_NAME_RESERVED1_5      "RESERVED1_5"
+#define GCLK_DEV_RESERVED1_5      "CLKGATE_RESERVED1_5"
+#define GCLK_REG_RESERVED1_5      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_5      (1<<18)
+
+#define GCLK_IDX_RESERVED1_6         51
+#define GCLK_NAME_RESERVED1_6      "RESERVED1_6"
+#define GCLK_DEV_RESERVED1_6      "CLKGATE_RESERVED1_6"
+#define GCLK_REG_RESERVED1_6      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_6      (1<<19)
+
+#define GCLK_IDX_GE2D         52
+#define GCLK_NAME_GE2D      "GE2D"
+#define GCLK_DEV_GE2D      "CLKGATE_GE2D"
+#define GCLK_REG_GE2D      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_GE2D      (1<<20)
+
+#define GCLK_IDX_USB0         53
+#define GCLK_NAME_USB0      "USB0"
+#define GCLK_DEV_USB0      "CLKGATE_USB0"
+#define GCLK_REG_USB0      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_USB0      (1<<21)
+
+#define GCLK_IDX_USB1         54
+#define GCLK_NAME_USB1      "USB1"
+#define GCLK_DEV_USB1      "CLKGATE_USB1"
+#define GCLK_REG_USB1      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_USB1      (1<<22)
+
+#define GCLK_IDX_RESET         55
+#define GCLK_NAME_RESET      "RESET"
+#define GCLK_DEV_RESET      "CLKGATE_RESET"
+#define GCLK_REG_RESET      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESET      (1<<23)
+
+#define GCLK_IDX_NAND_CLK         56
+#define GCLK_NAME_NAND_CLK      "NAND CLK"
+#define GCLK_DEV_NAND_CLK      "HHI_NAND_CLK"
+#define GCLK_REG_NAND_CLK      (HHI_NAND_CLK_CNTL)
+#define GCLK_MASK_NAND_CLK      (1<<7)
+
+#define GCLK_IDX_HIU_PARSER_TOP         57
+#define GCLK_NAME_HIU_PARSER_TOP      "HIU_PARSER_TOP"
+#define GCLK_DEV_HIU_PARSER_TOP      "CLKGATE_HIU_PARSER_TOP"
+#define GCLK_REG_HIU_PARSER_TOP      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_HIU_PARSER_TOP      (1<<25)
+
+/* NEW ADD */
+#define GCLK_NAME_USB_CLK       "USB_CLK"
+#define GCLK_REG_USB_CLK        (HHI_USB_CLK_CNTL)
+#define GCLK_MASK_USB_CLK       (1<<9)
+
+#define GCLK_IDX_USB_GENERAL         58
+#define GCLK_NAME_USB_GENERAL      "USB_GENERAL"
+#define GCLK_DEV_USB_GENERAL      "CLKGATE_USB_GENERAL"
+#define GCLK_REG_USB_GENERAL      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_USB_GENERAL      (1<<26)
+
+#define GCLK_IDX_RESERVED1_7         59
+#define GCLK_NAME_RESERVED1_7      "RESERVED1_7"
+#define GCLK_DEV_RESERVED1_7      "CLKGATE_RESERVED1_7"
+#define GCLK_REG_RESERVED1_7      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_7      (1<<27)
+
+/* #define GCLK_IDX_VDIN1         60 */
+/* #define GCLK_NAME_VDIN1      "VDIN1" */
+/* #define GCLK_DEV_VDIN1      "CLKGATE_VDIN1" */
+/* #define GCLK_REG_VDIN1      (HHI_GCLK_MPEG1) */
+/* #define GCLK_MASK_VDIN1      (1<<28) */
+
+#define GCLK_IDX_AHB_ARB0         61
+#define GCLK_NAME_AHB_ARB0      "AHB_ARB0"
+#define GCLK_DEV_AHB_ARB0      "CLKGATE_AHB_ARB0"
+#define GCLK_REG_AHB_ARB0      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AHB_ARB0      (1<<29)
+
+#define GCLK_IDX_EFUSE         62
+#define GCLK_NAME_EFUSE      "EFUSE"
+#define GCLK_DEV_EFUSE      "CLKGATE_EFUSE"
+#define GCLK_REG_EFUSE      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_EFUSE      (1<<30)
+
+#define GCLK_IDX_ROM_CLK         63
+#define GCLK_NAME_ROM_CLK      "ROM_CLK"
+#define GCLK_DEV_ROM_CLK      "CLKGATE_ROM_CLK"
+#define GCLK_REG_ROM_CLK      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_ROM_CLK      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_RESERVED2_0         64
+#define GCLK_NAME_RESERVED2_0      "RESERVED2_0"
+#define GCLK_DEV_RESERVED2_0      "CLKGATE_RESERVED2_0"
+#define GCLK_REG_RESERVED2_0      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_0      (1<<0)
+
+#define GCLK_IDX_AHB_DATA_BUS         65
+#define GCLK_NAME_AHB_DATA_BUS      "AHB_DATA_BUS"
+#define GCLK_DEV_AHB_DATA_BUS      "CLKGATE_AHB_DATA_BUS"
+#define GCLK_REG_AHB_DATA_BUS      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_AHB_DATA_BUS      (1<<1)
+
+#define GCLK_IDX_AHB_CONTROL_BUS         66
+#define GCLK_NAME_AHB_CONTROL_BUS      "AHB_CONTROL_BUS"
+#define GCLK_DEV_AHB_CONTROL_BUS      "CLKGATE_AHB_CONTROL_BUS"
+#define GCLK_REG_AHB_CONTROL_BUS      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_AHB_CONTROL_BUS      (1<<2)
+
+#define GCLK_IDX_HDMI_INTR_SYNC         67
+#define GCLK_NAME_HDMI_INTR_SYNC      "HDMI_INTR_SYNC"
+#define GCLK_DEV_HDMI_INTR_SYNC      "CLKGATE_HDMI_INTR_SYNC"
+#define GCLK_REG_HDMI_INTR_SYNC      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_HDMI_INTR_SYNC      (1<<3)
+
+#define GCLK_IDX_HDMI_PCLK         68
+#define GCLK_NAME_HDMI_PCLK      "HDMI_PCLK"
+#define GCLK_DEV_HDMI_PCLK      "CLKGATE_HDMI_PCLK"
+#define GCLK_REG_HDMI_PCLK      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_HDMI_PCLK      (1<<4)
+
+#define  GCLK_IDX_PDM         69
+#define GCLK_NAME_PDM      "PDM"
+#define  GCLK_DEV_PDM      "CLKGATE_PDM"
+#define  GCLK_REG_PDM      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_PDM      (1<<5)
+
+#define  GCLK_IDX_BT656        70
+#define GCLK_NAME_BT656     "BT656"
+#define  GCLK_DEV_BT656     "CLKGATE_BT656"
+#define  GCLK_REG_BT656     (HHI_GCLK_MPEG2)
+#define GCLK_MASK_BT656     (1<<6)
+
+#define  GCLK_IDX_BT656_2         71
+#define GCLK_NAME_BT656_2      "BT656_2"
+#define  GCLK_DEV_BT656_2      "CLKGATE_BT656_2"
+#define  GCLK_REG_BT656_2      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_BT656_2      (1<<7)
+
+#define GCLK_IDX_MISC_USB1_TO_DDR         72
+#define GCLK_NAME_MISC_USB1_TO_DDR      "MISC_USB1_TO_DDR"
+#define GCLK_DEV_MISC_USB1_TO_DDR      "CLKGATE_MISC_USB1_TO_DDR"
+#define GCLK_REG_MISC_USB1_TO_DDR      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MISC_USB1_TO_DDR      (1<<8)
+
+#define GCLK_IDX_MISC_USB0_TO_DDR         73
+#define GCLK_NAME_MISC_USB0_TO_DDR      "MISC_USB0_TO_DDR"
+#define GCLK_DEV_MISC_USB0_TO_DDR      "CLKGATE_MISC_USB0_TO_DDR"
+#define GCLK_REG_MISC_USB0_TO_DDR      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MISC_USB0_TO_DDR      (1<<9)
+
+#define GCLK_IDX_RESERVED2_4        74
+#define GCLK_NAME_RESERVED2_4      "RESERVED2_4"
+#define GCLK_DEV_RESERVED2_4      "CLKGATE_RESERVED2_4"
+#define GCLK_REG_RESERVED2_4      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_4      (1<<10)
+
+#define GCLK_IDX_MMC_PCLK         75
+#define GCLK_NAME_MMC_PCLK      "MMC_PCLK"
+#define GCLK_DEV_MMC_PCLK      "CLKGATE_MMC_PCLK"
+#define GCLK_REG_MMC_PCLK      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MMC_PCLK      (1<<11)
+
+#define GCLK_NAME_MMC_A_PCLK     "MMC_A_PCLK"
+#define GCLK_REG_MMC_A_PCLK      (HHI_MPLL_CNTL10)
+#define GCLK_MASK_MMC_A_PCLK      (1<<2)
+
+#define GCLK_NAME_MMC_B_PCLK     "MMC_B_PCLK"
+#define GCLK_REG_MMC_B_PCLK      (HHI_MPLL_CNTL10)
+#define GCLK_MASK_MMC_B_PCLK      (1<<1)
+
+#define GCLK_NAME_MMC_C_PCLK     "MMC_C_PCLK"
+#define GCLK_REG_MMC_C_PCLK      (HHI_MPLL_CNTL10)
+#define GCLK_MASK_MMC_C_PCLK      (1<<0)
+
+#define GCLK_NAME_EMMC_A_CLK      "EMMC_A_CLK"
+#define GCLK_REG_EMMC_A_CLK      (HHI_SD_EMMC_CLK_CNTL)
+#define GCLK_MASK_EMMC_A_CLK    (1<<7)
+
+#define GCLK_NAME_EMMC_B_CLK      "EMMC_B_CLK"
+#define GCLK_REG_EMMC_B_CLK      (HHI_SD_EMMC_CLK_CNTL)
+#define GCLK_MASK_EMMC_B_CLK    (1<<23)
+
+#define GCLK_IDX_MISC_DVIN         76
+#define GCLK_NAME_MISC_DVIN      "MISC_DVIN"
+#define GCLK_DEV_MISC_DVIN      "CLKGATE_MISC_DVIN"
+#define GCLK_REG_MISC_DVIN      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MISC_DVIN      (1<<12)
+
+#define GCLK_IDX_RESERVED2_5         77
+#define GCLK_NAME_RESERVED2_5      "RESERVED2_5"
+#define GCLK_DEV_RESERVED2_5      "CLKGATE_RESERVED2_5"
+#define GCLK_REG_RESERVED2_5      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_5      (1<<13)
+
+#define GCLK_IDX_RESERVED2_6         78
+#define GCLK_NAME_RESERVED2_6      "RESERVED2_6"
+#define GCLK_DEV_RESERVED2_6      "CLKGATE_RESERVED2_6"
+#define GCLK_REG_RESERVED2_6      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_6      (1<<14)
+
+#define GCLK_IDX_UART2         79
+#define GCLK_NAME_UART2      "UART2"
+#define GCLK_DEV_UART2      "CLKGATE_UART2"
+#define GCLK_REG_UART2      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_UART2      (1<<15)
+
+#define GCLK_IDX_RESERVED2_7         80
+#define GCLK_NAME_RESERVED2_7      "RESERVED2_7"
+#define GCLK_DEV_RESERVED2_7      "CLKGATE_RESERVED2_7"
+#define GCLK_REG_RESERVED2_7      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_7      (1<<16)
+
+#define GCLK_IDX_RESERVED2_8         81
+#define GCLK_NAME_RESERVED2_8      "RESERVED2_8"
+#define GCLK_DEV_RESERVED2_8      "CLKGATE_RESERVED2_8"
+#define GCLK_REG_RESERVED2_8      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_8      (1<<17)
+
+#define GCLK_IDX_RESERVED2_9         82
+#define GCLK_NAME_RESERVED2_9      "RESERVED2_9"
+#define GCLK_DEV_RESERVED2_9      "CLKGATE_RESERVED2_9"
+#define GCLK_REG_RESERVED2_9      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_9      (1<<18)
+
+#define GCLK_IDX_RESERVED2_A         83
+#define GCLK_NAME_RESERVED2_A      "RESERVED2_A"
+#define GCLK_DEV_RESERVED2_A      "CLKGATE_RESERVED2_A"
+#define GCLK_REG_RESERVED2_A      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_A      (1<<19)
+
+#define GCLK_IDX_RESERVED2_B         84
+#define GCLK_NAME_RESERVED2_B      "RESERVED2_B"
+#define GCLK_DEV_RESERVED2_B      "CLKGATE_RESERVED2_B"
+#define GCLK_REG_RESERVED2_B      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_B      (1<<20)
+
+#define  GCLK_IDX_UART3         85
+#define GCLK_NAME_UART3      "UART3"
+#define  GCLK_DEV_UART3      "CLKGATE_UART3"
+#define  GCLK_REG_UART3      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_UART3      (1<<21)
+
+#define GCLK_IDX_SANA        86
+#define GCLK_NAME_SANA      "SANA"
+#define GCLK_DEV_SANA      "CLKGATE_SANA"
+#define GCLK_REG_SANA      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_SANA      (1<<22)
+
+#define GCLK_IDX_RESERVED2_D        87
+#define GCLK_NAME_RESERVED2_D      "RESERVED2_D"
+#define GCLK_DEV_RESERVED2_D      "CLKGATE_RESERVED2_D"
+#define GCLK_REG_RESERVED2_D      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_D      (1<<23)
+
+#define GCLK_IDX_RESERVED2_E        88
+#define GCLK_NAME_RESERVED2_E      "RESERVED2_E"
+#define GCLK_DEV_RESERVED2_E      "CLKGATE_RESERVED2_E"
+#define GCLK_REG_RESERVED2_E      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_E      (1<<24)
+
+#define GCLK_IDX_VPU_INTR        89
+#define GCLK_NAME_VPU_INTR      "VPU_INTR"
+#define GCLK_DEV_VPU_INTR      "CLKGATE_VPU_INTR"
+#define GCLK_REG_VPU_INTR      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_VPU_INTR      (1<<25)
+
+#define GCLK_IDX_SECURE_AHP_APB3        90
+#define GCLK_NAME_SECURE_AHP_APB3      "SECURE_AHP_APB3"
+#define GCLK_DEV_SECURE_AHP_APB3      "CLKGATE_SECURE_AHP_APB3"
+#define GCLK_REG_SECURE_AHP_APB3      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_SECURE_AHP_APB3      (1<<26)
+
+#define GCLK_IDX_RESERVED2_F        91
+#define GCLK_NAME_RESERVED2_F      "RESERVED2_F"
+#define GCLK_DEV_RESERVED2_F      "CLKGATE_RESERVED2_F"
+#define GCLK_REG_RESERVED2_F      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_F      (1<<27)
+
+#define GCLK_IDX_RESERVED2_10        92
+#define GCLK_NAME_RESERVED2_10      "RESERVED2_10"
+#define GCLK_DEV_RESERVED2_10      "CLKGATE_RESERVED2_10"
+#define GCLK_REG_RESERVED2_10      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_10      (1<<28)
+
+#define GCLK_IDX_CLK81_TO_A9        93
+#define GCLK_NAME_CLK81_TO_A9      "CLK81_TO_A9"
+#define GCLK_DEV_CLK81_TO_A9      "CLKGATE_CLK81_TO_A9"
+#define GCLK_REG_CLK81_TO_A9      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_CLK81_TO_A9      (1<<29)
+
+#define  GCLK_IDX_GIC        94
+#define GCLK_NAME_GIC      "GIC"
+#define  GCLK_DEV_GIC      "CLKGATE_GIC"
+#define  GCLK_REG_GIC      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_GIC      (1<<30)
+
+#define GCLK_IDX_RESERVED2_12        95
+#define GCLK_NAME_RESERVED2_12      "RESERVED2_12"
+#define GCLK_DEV_RESERVED2_12      "CLKGATE_RESERVED2_12"
+#define GCLK_REG_RESERVED2_12      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_12      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_RESERVED3_0        96
+#define GCLK_NAME_RESERVED3_0      "RESERVED3_0"
+#define GCLK_DEV_RESERVED3_0      "CLKGATE_RESERVED3_0"
+#define GCLK_REG_RESERVED3_0      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_0      (1<<0)
+
+#define GCLK_IDX_VCLK2_VENCI         97
+#define GCLK_NAME_VCLK2_VENCI      "VCLK2_VENCI"
+#define GCLK_DEV_VCLK2_VENCI      "CLKGATE_VCLK2_VENCI"
+#define GCLK_REG_VCLK2_VENCI      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCI      (1<<1)
+
+#define GCLK_IDX_VCLK2_VENCI1         98
+#define GCLK_NAME_VCLK2_VENCI1      "VCLK2_VENCI1"
+#define GCLK_DEV_VCLK2_VENCI1      "CLKGATE_VCLK2_VENCI1"
+#define GCLK_REG_VCLK2_VENCI1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCI1      (1<<2)
+
+#define GCLK_IDX_VCLK2_VENCP         99
+#define GCLK_NAME_VCLK2_VENCP      "VCLK2_VENCP"
+#define GCLK_DEV_VCLK2_VENCP      "CLKGATE_VCLK2_VENCP"
+#define GCLK_REG_VCLK2_VENCP      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCP      (1<<3)
+
+#define GCLK_IDX_VCLK2_VENCP1         100
+#define GCLK_NAME_VCLK2_VENCP1      "VCLK2_VENCP1"
+#define GCLK_DEV_VCLK2_VENCP1      "CLKGATE_VCLK2_VENCP1"
+#define GCLK_REG_VCLK2_VENCP1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCP1      (1<<4)
+
+#define GCLK_IDX_VCLK2_VENCT         101
+#define GCLK_NAME_VCLK2_VENCT      "VCLK2_VENCT"
+#define GCLK_DEV_VCLK2_VENCT      "CLKGATE_VCLK2_VENCT"
+#define GCLK_REG_VCLK2_VENCT      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCT      (1<<5)
+
+#define GCLK_IDX_VCLK2_VENCT1         102
+#define GCLK_NAME_VCLK2_VENCT1      "VCLK2_VENCT1"
+#define GCLK_DEV_VCLK2_VENCT1      "CLKGATE_VCLK2_VENCT1"
+#define GCLK_REG_VCLK2_VENCT1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCT1      (1<<6)
+
+#define GCLK_IDX_VCLK2_OTHER         103
+#define GCLK_NAME_VCLK2_OTHER      "VCLK2_OTHER"
+#define GCLK_DEV_VCLK2_OTHER      "CLKGATE_VCLK2_OTHER"
+#define GCLK_REG_VCLK2_OTHER      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_OTHER      (1<<7)
+
+#define GCLK_IDX_VCLK2_ENCI         104
+#define GCLK_NAME_VCLK2_ENCI      "VCLK2_ENCI"
+#define GCLK_DEV_VCLK2_ENCI      "CLKGATE_VCLK2_ENCI"
+#define GCLK_REG_VCLK2_ENCI      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCI      (1<<8)
+
+#define GCLK_IDX_VCLK2_ENCP         105
+#define GCLK_NAME_VCLK2_ENCP      "VCLK2_ENCP"
+#define GCLK_DEV_VCLK2_ENCP      "CLKGATE_VCLK2_ENCP"
+#define GCLK_REG_VCLK2_ENCP      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCP      (1<<9)
+
+#define GCLK_IDX_DAC_CLK         106
+#define GCLK_NAME_DAC_CLK      "DAC_CLK"
+#define GCLK_DEV_DAC_CLK      "CLKGATE_DAC_CLK"
+#define GCLK_REG_DAC_CLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_DAC_CLK      (1<<10)
+
+#define GCLK_IDX_RESERVED3_1        107
+#define GCLK_NAME_RESERVED3_1      "RESERVED3_1"
+#define GCLK_DEV_RESERVED3_1      "CLKGATE_RESERVED3_1"
+#define GCLK_REG_RESERVED3_1      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_1      (1<<11)
+
+#define GCLK_IDX_RESERVED3_2        108
+#define GCLK_NAME_RESERVED3_2      "RESERVED3_2"
+#define GCLK_DEV_RESERVED3_2      "CLKGATE_RESERVED3_2"
+#define GCLK_REG_RESERVED3_2      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_2      (1<<12)
+
+#define GCLK_IDX_RESERVED3_3        109
+#define GCLK_NAME_RESERVED3_3      "RESERVED3_3"
+#define GCLK_DEV_RESERVED3_3      "CLKGATE_RESERVED3_3"
+#define GCLK_REG_RESERVED3_3      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_3      (1<<13)
+
+#define GCLK_IDX_AIU_AOCLK         110
+#define GCLK_NAME_AIU_AOCLK      "AIU_AOCLK"
+#define GCLK_DEV_AIU_AOCLK      "CLKGATE_AIU_AOCLK"
+#define GCLK_REG_AIU_AOCLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_AIU_AOCLK      (1<<14)
+
+#define GCLK_IDX_RESERVED3_4         111
+#define GCLK_NAME_RESERVED3_4      "RESERVED3_4"
+#define GCLK_DEV_RESERVED3_4      "CLKGATE_RESERVED3_4"
+#define GCLK_REG_RESERVED3_4      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_4      (1<<15)
+
+#define GCLK_IDX_AIU_ICE958_AMCLK         112
+#define GCLK_NAME_AIU_ICE958_AMCLK      "AIU_ICE958_AMCLK"
+#define GCLK_DEV_AIU_ICE958_AMCLK      "CLKGATE_AIU_ICE958_AMCLK"
+#define GCLK_REG_AIU_ICE958_AMCLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_AIU_ICE958_AMCLK      (1<<16)
+
+#define GCLK_IDX_RESERVED3_5         113
+#define GCLK_NAME_RESERVED3_5      "RESERVED3_5"
+#define GCLK_DEV_RESERVED3_5      "CLKGATE_RESERVED3_5"
+#define GCLK_REG_RESERVED3_5      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_5      (1<<17)
+
+#define GCLK_IDX_RESERVED3_6         114
+#define GCLK_NAME_RESERVED3_6      "RESERVED3_6"
+#define GCLK_DEV_RESERVED3_6      "CLKGATE_RESERVED3_6"
+#define GCLK_REG_RESERVED3_6      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_6      (1<<18)
+
+#define GCLK_IDX_RESERVED3_7         115
+#define GCLK_NAME_RESERVED3_7      "RESERVED3_7"
+#define GCLK_DEV_RESERVED3_7      "CLKGATE_RESERVED3_7"
+#define GCLK_REG_RESERVED3_7      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_7      (1<<19)
+
+#define GCLK_IDX_ENC480P         116
+#define GCLK_NAME_ENC480P      "ENC480P"
+#define GCLK_DEV_ENC480P      "CLKGATE_ENC480P"
+#define GCLK_REG_ENC480P      (HHI_GCLK_OTHER)
+#define GCLK_MASK_ENC480P      (1<<20)
+
+#define GCLK_IDX_RANDOM_NUM_GEN1         117
+#define GCLK_NAME_RANDOM_NUM_GEN1      "RANDOM_NUM_GEN1"
+#define GCLK_DEV_RANDOM_NUM_GEN1      "CLKGATE_RANDOM_NUM_GEN1"
+#define GCLK_REG_RANDOM_NUM_GEN1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RANDOM_NUM_GEN1      (1<<21)
+
+#define GCLK_IDX_VCLK2_ENCT         118
+#define GCLK_NAME_VCLK2_ENCT      "GCLK_VENCL_INT"
+#define GCLK_DEV_VCLK2_ENCT      "CLKGATE_GCLK_VENCL_INT"
+#define GCLK_REG_VCLK2_ENCT      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCT      (1<<22)
+
+#define  GCLK_IDX_VCLK2_ENCL         119
+#define GCLK_NAME_VCLK2_ENCL      "VLKC2_ENCL"
+#define  GCLK_DEV_VCLK2_ENCL      "CLKGATE_VCLK2_ENCL"
+#define  GCLK_REG_VCLK2_ENCL      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCL      (1<<23)
+
+#define GCLK_IDX_MMC_CLK         120
+#define GCLK_NAME_MMC_CLK      "MMC_CLK"
+#define GCLK_DEV_MMC_CLK      "CLKGATE_MMC_CLK"
+#define GCLK_REG_MMC_CLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_MMC_CLK      (1<<24)
+
+#define GCLK_IDX_VCLK2_VENCL         121
+#define GCLK_NAME_VCLK2_VENCL      "VCLK2_VENCL"
+#define GCLK_DEV_VCLK2_VENCL      "CLKGATE_VCLK2_VENCL"
+#define GCLK_REG_VCLK2_VENCL      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCL      (1<<25)
+
+#define GCLK_IDX_VCLK2_OTHER1         122
+#define GCLK_NAME_VCLK2_OTHER1      "VCLK2_OTHER1"
+#define GCLK_DEV_VCLK2_OTHER1      "CLKGATE_VCLK2_OTHER1"
+#define GCLK_REG_VCLK2_OTHER1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_OTHER1      (1<<26)
+
+#define GCLK_IDX_RESERVED3_9         123
+#define GCLK_NAME_RESERVED3_9      "RESERVED3_9"
+#define GCLK_DEV_RESERVED3_9      "CLKGATE_RESERVED3_9"
+#define GCLK_REG_RESERVED3_9      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_9      (1<<27)
+
+#define GCLK_IDX_RESERVED3_A         124
+#define GCLK_NAME_RESERVED3_A      "RESERVED3_A"
+#define GCLK_DEV_RESERVED3_A      "CLKGATE_RESERVED3_A"
+#define GCLK_REG_RESERVED3_A      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_A      (1<<28)
+
+#define GCLK_IDX_RESERVED3_B         125
+#define GCLK_NAME_RESERVED3_B      "RESERVED3_B"
+#define GCLK_DEV_RESERVED3_B      "CLKGATE_RESERVED3_B"
+#define GCLK_REG_RESERVED3_B      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_B      (1<<29)
+
+#define GCLK_IDX_RESERVED3_C         126
+#define GCLK_NAME_RESERVED3_C      "RESERVED3_C"
+#define GCLK_DEV_RESERVED3_C      "CLKGATE_RESERVED3_C"
+#define GCLK_REG_RESERVED3_C      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_C      (1<<30)
+
+#define GCLK_IDX_EDP_CLK         127
+#define GCLK_NAME_EDP_CLK      "EDP_CLK"
+#define GCLK_DEV_EDP_CLK      "CLKGATE_EDP_CLK"
+#define GCLK_REG_EDP_CLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_EDP_CLK      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_MEDIA_CPU         128
+#define GCLK_NAME_MEDIA_CPU      "MEDIA_CPU"
+#define GCLK_DEV_MEDIA_CPU      "CLKGATE_MEDIA_CPU"
+#define GCLK_REG_MEDIA_CPU      (HHI_GCLK_AO)
+#define GCLK_MASK_MEDIA_CPU      (1<<0)
+
+#define GCLK_IDX_AHB_SRAM         129
+#define GCLK_NAME_AHB_SRAM      "AHB_SRAM"
+#define GCLK_DEV_AHB_SRAM      "CLKGATE_AHB_SRAM"
+#define GCLK_REG_AHB_SRAM      (HHI_GCLK_AO)
+#define GCLK_MASK_AHB_SRAM      (1<<1)
+
+#define GCLK_IDX_AHB_BUS         130
+#define GCLK_NAME_AHB_BUS      "AHB_BUS"
+#define GCLK_DEV_AHB_BUS      "CLKGATE_AHB_BUS"
+#define GCLK_REG_AHB_BUS      (HHI_GCLK_AO)
+#define GCLK_MASK_AHB_BUS      (1<<2)
+
+#define GCLK_IDX_AO_REGS         131
+#define GCLK_NAME_AO_REGS      "AO_REGS"
+#define GCLK_DEV_AO_REGS      "CLKGATE_AO_REGS"
+#define GCLK_REG_AO_REGS      (HHI_GCLK_AO)
+#define GCLK_MASK_AO_REGS      (1<<3)
+
+#define GCLK_NAME_I2C_AO    "I2C_AO"
+#define  GCLK_REG_I2C_AO    (HHI_GCLK_AO)
+#define GCLK_MASK_I2C_AO    (1<<4)
+
+
+#define GCLK_IDX_CTS_ENCI         132
+#define GCLK_NAME_CTS_ENCI      "CTS_ENCI"
+#define GCLK_DEV_CTS_ENCI      "CLKGATE_CTS_ENCI"
+#define GCLK_REG_CTS_ENCI      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCI      (1<<0)
+
+#define GCLK_IDX_CTS_ENCT         133
+#define GCLK_NAME_CTS_ENCT      "CTS_ENCT"
+#define GCLK_DEV_CTS_ENCT      "CLKGATE_CTS_ENCT"
+#define GCLK_REG_CTS_ENCT      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCT      (1<<1)
+
+#define GCLK_IDX_CTS_ENCP         134
+#define GCLK_NAME_CTS_ENCP      "CTS_ENCP"
+#define GCLK_DEV_CTS_ENCP      "CLKGATE_CTS_ENCP"
+#define GCLK_REG_CTS_ENCP      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCP      (1<<2)
+
+#define GCLK_IDX_CTS_ENCL         135
+#define GCLK_NAME_CTS_ENCL      "CTS_ENCL"
+#define GCLK_DEV_CTS_ENCL      "CLKGATE_CTS_ENCL"
+#define GCLK_REG_CTS_ENCL      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCL      (1<<3)
+
+#define GCLK_IDX_CTS_VDAC         136
+#define GCLK_NAME_CTS_VDAC      "CTS_VDAC"
+#define GCLK_DEV_CTS_VDAC      "CLKGATE_CTS_VDAC"
+#define GCLK_REG_CTS_VDAC      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_VDAC      (1<<4)
+
+#define GCLK_IDX_CTS_HDMI_TX_PIXEL         137
+#define GCLK_NAME_CTS_HDMI_TX_PIXEL      "CTS_HDMI_TX_PIXEL"
+#define GCLK_DEV_CTS_HDMI_TX_PIXEL      "CLKGATE_CTS_HDMI_TX_PIXEL"
+#define GCLK_REG_CTS_HDMI_TX_PIXEL      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_HDMI_TX_PIXEL      (1<<5)
+
+#define GCLK_IDX_AUD         138
+#define GCLK_NAME_AUD      "AUD"
+#define GCLK_DEV_AUD      "CLKGATE_AUD"
+#define GCLK_REG_AUD      (HHI_AUD_CLK_CNTL)
+#define GCLK_MASK_AUD      (1<<23)
+
+
+#define GCLK_IDX_AUD2         138
+#define GCLK_NAME_AUD2      "AUD2"
+#define GCLK_DEV_AUD2      "CLKGATE_AUD2"
+#define GCLK_REG_AUD2      (HHI_AUD_CLK_CNTL)
+#define GCLK_MASK_AUD2      (1<<8)
+
+
+#define GCLK_NAME_AUD_CLK_2      "AUD_CLK_2"
+#define GCLK_REG_AUD_CLK_2      (HHI_AUD_CLK_CNTL2)
+#define GCLK_MASK_AUD_CLK_2      (1<<8)
+
+#define GCLK_IDX_AUD_CLK_3         138
+#define GCLK_NAME_AUD_CLK_3      "AUD_CLK"
+#define GCLK_DEV_AUD_CLK_3      "CLKGATE_AUD_CLK"
+#define GCLK_REG_AUD_CLK_3      (HHI_AUD_CLK_CNTL3)
+#define GCLK_MASK_AUD_CLK_3      (1<<16)
+
+#define GCLK_IDX_LCD_AN_PHY2         139
+#define GCLK_NAME_LCD_AN_PHY2      "LCD_AN_PHY2"
+#define GCLK_DEV_LCD_AN_PHY2      "CLKGATE_LCD_AN_PHY2"
+#define GCLK_REG_LCD_AN_PHY2      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_LCD_AN_PHY2      (1<<7)
+
+#define GCLK_IDX_LCD_AN_PHY3         140
+#define GCLK_NAME_LCD_AN_PHY3      "LCD_AN_PHY3"
+#define GCLK_DEV_LCD_AN_PHY3      "CLKGATE_LCD_AN_PHY3"
+#define GCLK_REG_LCD_AN_PHY3      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_LCD_AN_PHY3      (1<<6)
+
+#define GCLK_NAME_ATV_DEMO_VDAC     "ATV_DEMO_VDAC"
+#define GCLK_REG_ATV_DEMO_VDAC      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_ATV_DEMO_VDAC      (1<<8)
+
+#define GCLK_IDX_HDMI_PLL_CNTL         142
+#define GCLK_NAME_HDMI_PLL_CNTL      "HDMI_PLL_CNTL"
+#define GCLK_DEV_HDMI_PLL_CNTL       "GATE_HDMI_PLL_CNTL"
+#define GCLK_REG_HDMI_PLL_CNTL       (HHI_HDMI_PLL_CNTL)
+#define GCLK_MASK_HDMI_PLL_CNTL       (1<<30)
+
+#define GCLK_NAME_HDMITX_CLK    "HDMITX_CLK"
+#define GCLK_REG_HDMITX_CLK    (HHI_HDMI_CLK_CNTL)
+#define GCLK_MASK_HDMITX_CLK    (1<<8)
+
+
+#define GCLK_NAME_HDMITX_CLK    "HDMITX_CLK"
+#define GCLK_REG_HDMITX_CLK    (HHI_HDMI_CLK_CNTL)
+#define GCLK_MASK_HDMITX_CLK    (1<<8)
+
+#define GCLK_IDX_VDEC_CLK_1        144
+#define GCLK_NAME_VDEC_CLK_1      "VDEC_CLK_1"
+#define GCLK_DEV_VDEC_CLK_1       "CLKGATE_VDEC_CLK_1"
+#define GCLK_REG_VDEC_CLK_1       (HHI_VDEC_CLK_CNTL)
+#define GCLK_MASK_VDEC_CLK_1       (1<<8)
+
+#define GCLK_NAME_VDEC_CLK_2      "VDEC_CLK_2"
+#define GCLK_REG_VDEC_CLK_2       (HHI_VDEC3_CLK_CNTL)
+#define GCLK_MASK_VDEC_CLK_2       (1<<8)
+
+#define GCLK_NAME_VDEC2_CLK_1     "VDEC2_CLK_1"
+#define GCLK_REG_VDEC2_CLK_1       (HHI_VDEC2_CLK_CNTL)
+#define GCLK_MASK_VDEC2_CLK_1       (1<<8)
+
+#define GCLK_NAME_VDEC2_CLK_2     "VDEC2_CLK_2"
+#define GCLK_REG_VDEC2_CLK_2      (HHI_VDEC4_CLK_CNTL)
+#define GCLK_MASK_VDEC2_CLK_2       (1<<8)
+
+#define GCLK_IDX_HCODEC_CLK_1        145
+#define GCLK_NAME_HCODEC_CLK_1      "HCODEC_CLK"
+#define GCLK_DEV_HCODEC_CLK_1       "CLKGATE_HCODEC_CLK"
+#define GCLK_REG_HCODEC_CLK_1       (HHI_VDEC_CLK_CNTL)
+#define GCLK_MASK_HCODEC_CLK_1       (1<<24)
+
+#define GCLK_NAME_HCODEC_CLK_2      "HCODEC_CLK_2"
+#define GCLK_REG_HCODEC_CLK_2       (HHI_VDEC3_CLK_CNTL)
+#define GCLK_MASK_HCODEC_CLK_2       (1<<24)
+
+#define GCLK_NAME_HEVC_CLK_1      "HCODEC_CLK_1"
+#define GCLK_REG_HEVC_CLK_1       (HHI_VDEC2_CLK_CNTL)
+#define GCLK_MASK_HEVC_CLK_1       (1<<24)
+
+#define GCLK_NAME_HEVC_CLK_2      "HEVC_CLK_2"
+#define GCLK_REG_HEVC_CLK_2       (HHI_VDEC4_CLK_CNTL)
+#define GCLK_MASK_HEVC_CLK_2       (1<<24)
+
+#define GCLK_IDX_GEN_CLK        146
+#define GCLK_NAME_GEN_CLK      "GEN_CLK"
+#define GCLK_DEV_GEN_CLK       "CLKGATE_HCODEC_CLK"
+#define GCLK_REG_GEN_CLK       (HHI_GEN_CLK_CNTL)
+#define GCLK_MASK_GEN_CLK       (1<<11)
+
+#define GCLK_NAME_VPU_CLK_1      "VPU_CLK_1"
+#define GCLK_REG_VPU_CLK_1       (HHI_VPU_CLK_CNTL)
+#define GCLK_MASK_VPU_CLK_1       (1<<8)
+
+#define GCLK_NAME_VPU_CLK_2      "VPU_CLK_2"
+#define GCLK_REG_VPU_CLK_2       (HHI_VPU_CLK_CNTL)
+#define GCLK_MASK_VPU_CLK_2       (1<<24)
+
+
+#define GCLK_NAME_VPU_CLKB      "VPU_CLKB"
+#define GCLK_REG_VPU_CLKB       (HHI_VPU_CLKB_CNTL)
+#define GCLK_MASK_VPU_CLKB       (1<<8)
+
+#define GCLK_NAME_VAPB_CLK_1    "VAPB_CLK_1"
+#define  GCLK_REG_VAPB_CLK_1    (HHI_VAPBCLK_CNTL)
+#define GCLK_MASK_VAPB_CLK_1    (1<<8)
+
+#define GCLK_NAME_VAPB_CLK_2    "VAPB_CLK_2"
+#define  GCLK_REG_VAPB_CLK_2    (HHI_VAPBCLK_CNTL)
+#define GCLK_MASK_VAPB_CLK_2    (1<<24)
+
+#define GCLK_NAME_MALI_CLK_1     "MALI_CLK_1"
+#define GCLK_REG_MALI_CLK_1    (HHI_MALI_CLK_CNTL)
+#define GCLK_MASK_MALI_CLK_1   (1<<8)
+
+#define GCLK_NAME_MALI_CLK_2     "MALI_CLK_2"
+#define GCLK_REG_MALI_CLK_2    (HHI_MALI_CLK_CNTL)
+#define GCLK_MASK_MALI_CLK_2   (1<<24)
+
+#define GCLK_NAME_PWM_A_CLK    "PWM_A_CLK"
+#define GCLK_REG_PWM_A_CLK    (CBUS_REG_ADDR(0x2156))
+#define GCLK_MASK_PWM_A_CLK    (1<<15)
+
+#define GCLK_NAME_PWM_B_CLK    "PWM_B_CLK"
+#define GCLK_REG_PWM_B_CLK    (CBUS_REG_ADDR(0x2156))
+#define GCLK_MASK_PWM_B_CLK    (1<<23)
+
+#define GCLK_NAME_PWM_C_CLK    "PWM_C_CLK"
+#define GCLK_REG_PWM_C_CLK    (CBUS_REG_ADDR(0x2196))
+#define GCLK_MASK_PWM_C_CLK    (1<<15)
+
+#define GCLK_NAME_PWM_D_CLK    "PWM_D_CLK"
+#define GCLK_REG_PWM_D_CLK    (CBUS_REG_ADDR(0x2196))
+#define GCLK_MASK_PWM_D_CLK    (1<<23)
+
+#define GCLK_NAME_PWM_E_CLK    "PWM_E_CLK"
+#define GCLK_REG_PWM_E_CLK    (CBUS_REG_ADDR(0x21b2))
+#define GCLK_MASK_PWM_E_CLK    (1<<15)
+
+#define GCLK_NAME_PWM_F_CLK    "PWM_D_CLK"
+#define GCLK_REG_PWM_F_CLK    (CBUS_REG_ADDR(0x21b2))
+#define GCLK_MASK_PWM_F_CLK    (1<<23)
+
+#define GCLK_NAME_VDIN_MEAS_CLK    "VDIN_MEAS_CLK"
+#define  GCLK_REG_VDIN_MEAS_CLK   (HHI_VDIN_MEAS_CLK_CNTL)
+#define GCLK_MASK_VDIN_MEAS_CLK   (1<<8)
+
+#define GCLK_NAME_MSR_CLK    "MSR_CLK"
+#define  GCLK_REG_MSR_CLK    (CBUS_REG_ADDR(0x21d7))
+#define GCLK_MASK_MSR_CLK    (1<<19)
+
+#define GCLK_NAME_MSR_HS_CLK    "MSR_HS_CLK"
+#define  GCLK_REG_MSR_HS_CLK    (CBUS_REG_ADDR(0x21d9))
+#define GCLK_MASK_MSR_HS_CLK    (1<<28)
+
+#define GCLK_NAME_32K_CLK     "32K_CLK"
+#define GCLK_REG_32K_CLK     (HHI_32K_CLK_CNTL)
+#define GCLK_MASK_32K_CLK    (1<<15)
+
+
+
+#define GCLK_IDX_MAX 200
+
+extern short GCLK_ref[GCLK_IDX_MAX];
+
+#define REGISTER_CLK(_MOD) \
+static struct clk CLK_##_MOD = {            \
+	.name       = GCLK_NAME_##_MOD,             \
+	.clock_index = GCLK_IDX_##_MOD,          \
+	.clock_gate_reg_adr = GCLK_REG_##_MOD,  \
+	.clock_gate_reg_mask = GCLK_MASK_##_MOD,    \
+}
+
+#define CLK_LOOKUP_ITEM(_MOD) \
+	{           \
+		.dev_id = GCLK_DEV_##_MOD, \
+		.con_id = GCLK_NAME_##_MOD, \
+		.clk    = &CLK_##_MOD,   \
+	}
+
+
+
+/**********************/
+/* internal audio dac control */
+#define ADAC_RESET                      (0x5000+0x00*4)
+#define ADAC_LATCH                      (0x5000+0x01*4)
+#define ADAC_POWER_CTRL_REG1            (0x5000+0x10*4)
+#define ADAC_POWER_CTRL_REG2            (0x5000+0x11*4)
+
+int audio_internal_dac_disable(void);
+
+/* video dac control */
+int  video_dac_enable(unsigned char enable_mask);
+
+int  video_dac_disable(void);
+
+
+#endif
diff --git a/arch/arm/cpu/armv8/gxb/sdio.c b/arch/arm/cpu/armv8/gxb/sdio.c
new file mode 100644
index 0000000..ee25376
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/sdio.c
@@ -0,0 +1,78 @@
+
+/*
+ * arch/arm/cpu/armv8/gxb/sdio.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <asm/arch/io.h>
+#include <asm/arch/cpu_sdio.h>
+#include <asm/arch/secure_apb.h>
+
+void  cpu_sd_emmc_pwr_prepare(unsigned port)
+{
+//    switch(port)
+//    {
+//        case SDIO_PORT_A:
+//            clrbits_le32(P_PREG_PAD_GPIO4_EN_N,0x30f);
+//            clrbits_le32(P_PREG_PAD_GPIO4_O   ,0x30f);
+//            clrbits_le32(P_PERIPHS_PIN_MUX_8,0x3f);
+//            break;
+//        case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,0x3f<<23);
+//            clrbits_le32(P_PREG_PAD_GPIO5_O   ,0x3f<<23);
+//            clrbits_le32(P_PERIPHS_PIN_MUX_2,0x3f<<10);
+//            break;
+//        case SDIO_PORT_C:
+//            //clrbits_le32(P_PREG_PAD_GPIO3_EN_N,0xc0f);
+//            //clrbits_le32(P_PREG_PAD_GPIO3_O   ,0xc0f);
+//            //clrbits_le32(P_PERIPHS_PIN_MUX_6,(0x3f<<24));break;
+//            break;
+//    }
+
+    /**
+        do nothing here
+    */
+}
+unsigned sd_debug_board_1bit_flag = 0;
+int cpu_sd_emmc_init(unsigned port)
+{
+
+    //printf("inand sdio  port:%d\n",port);
+    switch (port)
+    {
+        case SDIO_PORT_A:
+			setbits_le32(P_PERIPHS_PIN_MUX_8,0x3f);
+			break;
+
+        case SDIO_PORT_B:
+			if (sd_debug_board_1bit_flag == 1)
+                setbits_le32(P_PERIPHS_PIN_MUX_2,(0x3<<10)|(0x1<<15));
+            else
+                setbits_le32(P_PERIPHS_PIN_MUX_2,0x3f<<10);
+			break;
+        case SDIO_PORT_C://SDIOC GPIOB_2~GPIOB_7
+			clrbits_le32(P_PERIPHS_PIN_MUX_2,(0x1f<<22));
+			setbits_le32(P_PERIPHS_PIN_MUX_4,(0x3<<18)|(3<<30));
+            //printf("inand sdio  port:%d\n",port);
+            break;
+        default:
+            return -1;
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/gxb/timer.c b/arch/arm/cpu/armv8/gxb/timer.c
new file mode 100644
index 0000000..6bbd554
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/timer.c
@@ -0,0 +1,39 @@
+
+/*
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/timer.h>
+#include <asm/types.h>
+
+#define P_EE_TIMER_E		P_ISA_TIMERE
+
+uint32_t get_time(void)
+{
+	return readl(P_EE_TIMER_E);
+}
+
+void _udelay(unsigned int us)
+{
+#ifndef CONFIG_PXP_EMULATOR
+	unsigned int t0 = get_time();
+
+	while (get_time() - t0 <= us)
+		;
+#endif
+}
diff --git a/arch/arm/cpu/armv8/gxb/usb.c b/arch/arm/cpu/armv8/gxb/usb.c
new file mode 100644
index 0000000..c8d1a92
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/usb.c
@@ -0,0 +1,302 @@
+
+/*
+ * arch/arm/cpu/armv8/gxb/usb.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+//#include <common.h>
+//#include <asm/cache.h>
+#include <asm/arch/usb.h>
+#include <asm/arch/romboot.h>
+
+
+#ifdef CONFIG_USB_DWC_OTG_HCD
+static amlogic_usb_config_t * g_usb_cfg[BOARD_USB_MODE_MAX][USB_PHY_PORT_MAX];
+
+static char * g_clock_src_name_m8[]={
+    "XTAL input",
+};
+
+extern void _udelay(unsigned long usec);
+extern void _mdelay(unsigned long usec);
+//static int reset_count = 0;
+//int set_usb_phy_clk(struct lm_device * plmdev,int is_enable)
+//{
+static int set_usb_phy_clock(amlogic_usb_config_t * usb_cfg)
+{
+
+	int port_idx;
+	usb_peri_reg_t * peri;
+	usb_config_data_t config;
+	usb_ctrl_data_t control;
+	int clk_sel,clk_div;
+	unsigned int port = usb_cfg->base_addr & USB_PHY_PORT_MSK;
+	int time_dly = 500; //usec
+
+	if (!usb_cfg)
+		return -1;
+
+
+	if (port == USB_PHY_PORT_A) {
+		port_idx = 0;
+		peri = (usb_peri_reg_t*)PREI_USB_PHY_REG_A;//CBUS_REG_ADDR(PREI_USB_PHY_REG_A);
+	}else if(port == USB_PHY_PORT_B){
+		port_idx = 1;
+		peri = (usb_peri_reg_t*)PREI_USB_PHY_REG_B;//CBUS_REG_ADDR(PREI_USB_PHY_REG_B);
+	}else{
+		printf("usb base address error: %x\n",usb_cfg->base_addr);
+		return -1;
+	}
+	writel((1 << 2),P_RESET1_REGISTER);
+	printf("USB (%d) peri reg base: %x\n",port_idx,(uint32_t)(unsigned long long)peri);
+	clk_sel = usb_cfg->clk_selecter;
+	clk_div = usb_cfg->pll_divider;
+
+	config.d32 = peri->config;
+	config.b.clk_32k_alt_sel= 1;
+	peri->config = config.d32;
+
+	printf("USB (%d) use clock source: %s, div: %d\n",port_idx,g_clock_src_name_m8[clk_sel], clk_div);
+
+	control.d32 = peri->ctrl;
+	control.b.fsel = 5;	/* PHY default is 24M (5), change to 12M (2) */
+	control.b.por = 1;  /* power off default*/
+	peri->ctrl = control.d32;
+	_udelay(time_dly);
+	return 0;
+}
+//call after set clock
+void set_usb_phy_power(amlogic_usb_config_t * usb_cfg,int is_on)
+{
+	unsigned long delay = 1000;
+	int port_idx = 100;
+	unsigned int port = usb_cfg->base_addr & USB_PHY_PORT_MSK;
+	usb_peri_reg_t *peri_a,*peri_b,*peri_c,*peri_d,*peri;
+	peri = NULL;
+	usb_ctrl_data_t control;
+	usb_adp_bc_data_t adp_bc;
+
+	peri_a = (usb_peri_reg_t*)PREI_USB_PHY_REG_A;//CBUS_REG_ADDR(PREI_USB_PHY_REG_A);
+	peri_b = (usb_peri_reg_t*)PREI_USB_PHY_REG_B;//CBUS_REG_ADDR(PREI_USB_PHY_REG_B);
+//	peri_c = (usb_peri_reg_t*)CBUS_REG_ADDR(PREI_USB_PHY_REG_C);
+//	peri_d = (usb_peri_reg_t*)CBUS_REG_ADDR(PREI_USB_PHY_REG_D);
+	peri_c = NULL;
+	peri_d = NULL;
+
+	if (port == USB_PHY_PORT_A) {
+		peri = peri_a;
+		port_idx = 0;
+	}else if(port == USB_PHY_PORT_B){
+		peri = peri_b;
+		port_idx = 1;
+	}
+	else if(port == USB_PHY_PORT_C){
+		peri = peri_c;
+		port_idx = 2;
+	}else if(port == USB_PHY_PORT_D){
+		peri = peri_d;
+		port_idx = 3;
+	}
+
+	if (is_on) {
+		control.d32 = peri->ctrl;
+		control.b.por = 0;
+		peri->ctrl = control.d32;
+
+		_udelay(delay);
+		/* read back clock detected flag*/
+		control.d32 = peri->ctrl;
+		if (!control.b.clk_detected) {
+			printf("USB (%d) PHY Clock not detected!\n",port_idx);
+		}
+		if (port == USB_PHY_PORT_B) {
+			adp_bc.d32 = peri->adp_bc;
+			adp_bc.b.aca_enable = 1;
+			peri->adp_bc = adp_bc.d32;
+			_udelay(50);
+			adp_bc.d32 = peri->adp_bc;
+			if (adp_bc.b.aca_pin_float) {
+				printf("USB-B ID detect failed!\n");
+				printf("Please use the chip after version RevA1!\n");
+				return;
+			}
+		}
+	}else{
+		control.d32 = peri->ctrl;
+		control.b.por = 1;
+		peri->ctrl = control.d32;
+	}
+	_udelay(delay);
+
+}
+const char * bc_name[]={
+	"UNKNOWN",
+	"SDP (PC)",
+	"DCP (Charger)",
+	"CDP (PC with Charger)",
+};
+#define T_DCD_TIMEOUT	10
+#define T_VDPSRC_ON	40
+#define T_VDMSRC_EN	(20 + 5)
+#define T_VDMSRC_DIS	(20 + 5)
+#define T_VDMSRC_ON	40
+static void usb_bc_detect(amlogic_usb_config_t * usb_cfg)
+{
+	int port_idx,timeout_det;
+	unsigned int port = usb_cfg->base_addr & USB_PHY_PORT_MSK;
+	usb_peri_reg_t *peri,*peri_a,*peri_b,*peri_c,*peri_d;
+	peri = NULL;
+	port_idx = 100;
+	usb_adp_bc_data_t adp_bc;
+	int bc_mode = BC_MODE_UNKNOWN;
+
+	peri_a = (usb_peri_reg_t*)PREI_USB_PHY_REG_A;//CBUS_REG_ADDR(PREI_USB_PHY_REG_A);
+	peri_b = (usb_peri_reg_t*)PREI_USB_PHY_REG_B;//CBUS_REG_ADDR(PREI_USB_PHY_REG_B);
+//	peri_c = (usb_peri_reg_t*)CBUS_REG_ADDR(PREI_USB_PHY_REG_C);
+//	peri_d = (usb_peri_reg_t*)CBUS_REG_ADDR(PREI_USB_PHY_REG_D);
+	peri_c = NULL;
+	peri_d = NULL;
+
+	if (port == USB_PHY_PORT_A) {
+		peri = peri_a;
+		port_idx = 0;
+	}else if(port == USB_PHY_PORT_B){
+		peri = peri_b;
+		port_idx = 1;
+	}
+	else if(port == USB_PHY_PORT_C){
+		peri = peri_c;
+		port_idx = 2;
+	}else if(port == USB_PHY_PORT_D){
+		peri = peri_d;
+		port_idx = 3;
+	}
+
+	adp_bc.d32 = peri->adp_bc;
+	if (adp_bc.b.device_sess_vld) {
+		_mdelay(T_DCD_TIMEOUT);
+
+		/* Turn on VDPSRC */
+		adp_bc.b.chrgsel = 0;
+		adp_bc.b.vdatdetenb = 1;
+		adp_bc.b.vdatsrcenb = 1;
+		adp_bc.b.dcd_enable = 0;
+		peri->adp_bc = adp_bc.d32;
+
+		/* SDP and CDP/DCP distinguish */
+		timeout_det = T_VDMSRC_EN;
+		while (timeout_det--) {
+			adp_bc.d32 = peri->adp_bc;
+			if (adp_bc.b.chg_det)
+				break;
+			_mdelay(1);
+		};
+
+		if (adp_bc.b.chg_det) {
+			/* Turn off VDPSRC */
+			adp_bc.d32 = peri->adp_bc;
+			adp_bc.b.vdatdetenb = 0;
+			adp_bc.b.vdatsrcenb = 0;
+			peri->adp_bc = adp_bc.d32;
+
+			/* Wait VDMSRC_DIS */
+			timeout_det = T_VDMSRC_DIS;
+			while (timeout_det--) {
+				adp_bc.d32 = peri->adp_bc;
+				if (!adp_bc.b.chg_det)
+					break;
+				_mdelay(1);
+			};
+
+			if (timeout_det <= 0)
+				printf("Time out for VDMSRC_DIS!");
+
+			/* Turn on VDMSRC */
+			adp_bc.d32 = peri->adp_bc;
+			adp_bc.b.chrgsel = 1;
+			adp_bc.b.vdatdetenb = 1;
+			adp_bc.b.vdatsrcenb = 1;
+			peri->adp_bc = adp_bc.d32;
+
+			_mdelay(T_VDMSRC_ON);
+			adp_bc.d32 = peri->adp_bc;
+			if (adp_bc.b.chg_det)
+				bc_mode = BC_MODE_DCP;
+			else
+				bc_mode = BC_MODE_CDP;
+		}
+		else{
+			bc_mode = BC_MODE_SDP;
+		}
+		adp_bc.d32 = peri->adp_bc;
+		adp_bc.b.vdatdetenb = 0;
+		adp_bc.b.vdatsrcenb = 0;
+		adp_bc.b.dcd_enable = 0;
+		peri->adp_bc = adp_bc.d32;
+	}
+
+	printf("Port %d detect usb battery charger mode: %s\n",port_idx, bc_name[bc_mode]);
+	usb_cfg->battery_charging_det_cb(bc_mode);
+
+}
+amlogic_usb_config_t * amlogic_usb_start(int mode,int index)
+{
+	if (mode < 0 || mode >= BOARD_USB_MODE_MAX||!g_usb_cfg[mode][index])
+		return 0;
+
+
+	set_usb_phy_clock(g_usb_cfg[mode][index]);
+	set_usb_phy_power(g_usb_cfg[mode][index],1);//on
+	if(mode == BOARD_USB_MODE_CHARGER &&
+	    g_usb_cfg[mode][index]->battery_charging_det_cb)
+		usb_bc_detect(g_usb_cfg[mode][index]);
+	return g_usb_cfg[mode][index];
+}
+
+int amlogic_usb_stop(int mode,int index)
+{
+	printf("board_usb_stop cfg: %d\n",mode);
+	if (mode < 0 || mode >= BOARD_USB_MODE_MAX)
+		return 1;
+	set_usb_phy_power(g_usb_cfg[mode][index],0);//off
+
+	return 0;
+}
+
+int usb_index = 0;
+void amlogic_usb_init(amlogic_usb_config_t * usb_cfg,int mode)
+{
+
+	if (mode < 0 || mode >= BOARD_USB_MODE_MAX || !usb_cfg)
+		return ;
+
+	if (mode == BOARD_USB_MODE_HOST) {
+		if (usb_index >= USB_PHY_PORT_MAX)
+			return;
+		g_usb_cfg[mode][usb_index] = usb_cfg;
+		usb_index++;
+	}else
+		g_usb_cfg[mode][0] = usb_cfg;
+	printf("register usb cfg[%d][%d] = %p\n",mode,(mode==BOARD_USB_MODE_HOST)?usb_index:0,usb_cfg);
+}
+
+int get_usb_count(void)
+{
+    return  usb_index;
+}
+#endif //CONFIG_USB_DWC_OTG_HCD
diff --git a/arch/arm/cpu/armv8/gxb/watchdog.c b/arch/arm/cpu/armv8/gxb/watchdog.c
new file mode 100644
index 0000000..2f546d6
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/watchdog.c
@@ -0,0 +1,77 @@
+
+/*
+ * arch/arm/cpu/armv8/common/firmware/plat/gxb/watchdog.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/types.h>
+#include <asm/arch/romboot.h>
+#include <asm/arch/watchdog.h>
+#include <asm/arch/io.h>
+#include <asm/arch/timer.h>
+
+void watchdog_init(uint32_t msec)
+{
+	// src: 24MHz
+	// div: 24000 for 1ms
+	// reset ao-22 and ee-21
+	*P_WATCHDOG_CNTL = (1<<24)|(1<<25)|(1<<22)|(1<<21)|(24000-1);
+
+	// set timeout
+	*P_WATCHDOG_TCNT = msec;
+	*P_WATCHDOG_RESET = 0;
+
+	// enable
+	*P_WATCHDOG_CNTL |= (1<<18);
+}
+
+void watchdog_reset(void)
+{
+	*P_WATCHDOG_RESET = 0;
+}
+
+void watchdog_disable(void)
+{
+	// turn off internal counter and disable
+	*P_WATCHDOG_CNTL &= ~((1<<18)|(1<<25));
+}
+void reset_system(void)
+{
+	int i;
+	_udelay(10000); //wait print
+	while (1) {
+		writel( 0x3 | (1 << 21) // sys reset en
+					| (1 << 23) // interrupt en
+					| (1 << 24) // clk en
+					| (1 << 25) // clk div en
+					| (1 << 26) // sys reset now
+			, P_WATCHDOG_CNTL);
+		writel(0, P_WATCHDOG_RESET);
+
+		writel(readl(P_WATCHDOG_CNTL) | (1<<18), // watchdog en
+			P_WATCHDOG_CNTL);
+		for (i=0; i<100; i++)
+			readl(P_WATCHDOG_CNTL);/*Deceive gcc for waiting some cycles */
+	}
+}
+
+/* uboot reset interface */
+void reset_cpu(unsigned long flag){
+	reset_system();
+}
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-gxb/acs.h b/arch/arm/include/asm/arch-gxb/acs.h
new file mode 100644
index 0000000..1e0e1a1
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/acs.h
@@ -0,0 +1,34 @@
+/***********************************************
+**********Amlogic Configurable SPL**************
+***********************************************/
+
+#ifndef __ACS_H
+#define __ACS_H
+
+#ifndef __ASSEMBLY__
+struct acs_setting{
+		char				acs_magic[5];	//acs setting magic word, make sure this piece of data was right.
+		unsigned char		chip_type;		//chip type
+		unsigned short		version;		//version of acs_setting struct, for PC tool use.
+		unsigned long		acs_set_length;	//length of current struct.
+
+		//ddr setting part, 16 bytes
+		char				ddr_magic[5];		//magic word to indicate that following 12 bytes was ddr setting.
+		unsigned char		ddr_set_version;	//struct version, for PC tool use.
+		unsigned short		ddr_set_length;		//length of ddr struct.
+		unsigned long		ddr_set_addr;		//address of ddr setting.
+
+		//ddr timing part, 16 bytes
+		char				ddrt_magic[5];
+		unsigned char		ddrt_set_version;
+		unsigned short		ddrt_set_length;
+		unsigned long		ddrt_set_addr;
+
+		char				pll_magic[5];
+		unsigned char		pll_set_version;
+		unsigned short		pll_set_length;
+		unsigned long		pll_set_addr;
+}__attribute__ ((packed));
+
+#endif
+#endif
diff --git a/arch/arm/include/asm/arch-gxb/bl31_apis.h b/arch/arm/include/asm/arch-gxb/bl31_apis.h
new file mode 100644
index 0000000..9c93552
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/bl31_apis.h
@@ -0,0 +1,125 @@
+
+/*
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Trustzone API
+ *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *
+ */
+
+#ifndef __GXBB_BL31_APIS_H
+#define __GXBB_BL31_APIS_H
+
+#include <asm/arch/io.h>
+
+/*#define SRAM_READ				0x82000010
+#define CORE_RD_REV1			0x82000011
+#define SRAM_ACS_READ		0x82000012
+#define SRAM_ACS_INDIRECT_READ		0x82000013*/
+
+#define GET_SHARE_MEM_INPUT_BASE		0x82000020
+#define GET_SHARE_MEM_OUTPUT_BASE		0x82000021
+#define GET_REBOOT_REASON		0x82000022
+#define GET_SHARE_STORAGE_IN_BASE		0x82000023
+#define GET_SHARE_STORAGE_OUT_BASE		0x82000024
+#define GET_SHARE_STORAGE_BLOCK_BASE	0x82000025
+#define GET_SHARE_STORAGE_MESSAGE_BASE	0x82000026
+#define GET_SHARE_STORAGE_BLOCK_SIZE		0x82000027
+
+/* Set Reboot Reason then Reboot*/
+#define PSCI_SYS_REBOOT		0x84000009
+
+/* SECUREOS DEFINITION*/
+/* SMC Identifiers for non-secure world functions */
+#define CALL_TRUSTZONE_HAL_API                  0x5
+
+/* EFUSE */
+#define EFUSE_READ					0x82000030
+#define EFUSE_WRITE				0x82000031
+#define EFUSE_WRITE_PATTERN		0x82000032
+#define EFUSE_USER_MAX    0x82000033
+
+#define DEBUG_EFUSE_WRITE_PATTERN	0x820000F0
+#define DEBUG_EFUSE_READ_PATTERN	0x820000F1
+
+/* JTAG*/
+#define JTAG_ON                                0x82000040
+#define JTAG_OFF                               0x82000041
+
+#define SET_USB_BOOT_FUNC	0x82000043
+	/* USB BOOT FUNC sub command list*/
+	#define CLEAR_USB_BOOT			1
+	#define FORCE_USB_BOOT			2
+	#define RUN_COMD_USB_BOOT		3
+	#define PANIC_DUMP_USB_BOOT	4
+
+/* Security Key*/
+#define SECURITY_KEY_QUERY	0x82000060
+#define SECURITY_KEY_READ	0x82000061
+#define SECURITY_KEY_WRITE	0x82000062
+#define SECURITY_KEY_TELL		0x82000063
+#define SECURITY_KEY_VERIFY	0x82000064
+#define SECURITY_KEY_STATUS	0x82000065
+#define SECURITY_KEY_NOTIFY	0x82000066
+#define SECURITY_KEY_LIST		0x82000067
+#define SECURITY_KEY_REMOVE	0x82000068
+
+/* Secure HAL APIs */
+#define TRUSTZONE_HAL_API_SRAM                  0x400
+
+
+#define SRAM_HAL_API_CHECK_EFUSE 0x403
+struct sram_hal_api_arg {
+	unsigned int cmd;
+	unsigned int req_len;
+	unsigned int res_len;
+	unsigned long req_phy_addr;
+	unsigned long res_phy_addr;
+	unsigned long ret_phy_addr;
+};
+
+#define JTAG_STATE_ON  0
+#define JTAG_STATE_OFF 1
+#define JTAG_M3_AO     0
+#define JTAG_M3_EE     1
+#define JTAG_A53_AO    2
+#define JTAG_A53_EE 3
+
+
+/////////////////////////////////////////////////////////////////////////////////
+#define AML_DATA_PROCESS                 (0x820000FF)
+	#define AML_D_P_W_EFUSE_SECURE_BOOT  (0x10)
+	#define AML_D_P_W_EFUSE_PASSWORD     (0x11)
+	#define AML_D_P_W_EFUSE_CUSTOMER_ID  (0x12)
+	#define AML_D_P_IMG_DECRYPT          (0x40)
+	#define AML_D_P_UPGRADE_CHECK        (0x80)
+
+#define GXB_EFUSE_PATTERN_SIZE      (0x500)
+#define GXB_IMG_SIZE                (24<<20)
+#define GXB_IMG_LOAD_ADDR           (0x1080000)
+	#define GXB_IMG_DEC_KNL   (1<<0)
+	#define GXB_IMG_DEC_RMD   (1<<1)
+	#define GXB_IMG_DEC_DTB   (1<<2)
+	#define GXB_IMG_DEC_ALL   (GXB_IMG_DEC_KNL|GXB_IMG_DEC_RMD|GXB_IMG_DEC_DTB)
+
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+
+void aml_set_jtag_state(unsigned state, unsigned select);
+unsigned aml_get_reboot_reason(void);
+unsigned aml_reboot(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2);
+unsigned long aml_sec_boot_check(unsigned long ,unsigned long ,unsigned long,unsigned long );
+long get_sharemem_info(unsigned long);
+void set_usb_boot_function(unsigned long command);
+
+#endif
diff --git a/arch/arm/include/asm/arch-gxb/clock.h b/arch/arm/include/asm/arch-gxb/clock.h
new file mode 100644
index 0000000..f926073
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/clock.h
@@ -0,0 +1,82 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/clock.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_ARM_MESON_CLOCK_H_U_BOOT_
+#define __ARCH_ARM_MESON_CLOCK_H_U_BOOT_
+
+/* below clk is M8, it is placed here for compiling pass */
+#define CTS_PWM_A_CLK                  (45)
+#define CTS_PWM_B_CLK                  (44)
+#define CTS_PWM_C_CLK                  (43)
+#define CTS_PWM_D_CLK                  (42)
+#define CTS_ETH_RX_TX                  (41)
+#define CTS_PCM_MCLK                   (40)
+#define CTS_PCM_SCLK                   (39)
+#define CTS_VDIN_MEAS_CLK              (38)
+#define CTS_VDAC_CLK1                  (37)
+#define CTS_HDMI_TX_PIXEL_CLK          (36)
+#define CTS_MALI_CLK                   (35)
+#define CTS_SDHC_CLK1                  (34)
+#define CTS_SDHC_CLK0                  (33)
+#define CTS_AUDAC_CLKPI                (32)
+#define CTS_A9_CLK                     (31)
+#define CTS_DDR_CLK                    (30)
+#define CTS_VDAC_CLK0                  (29)
+#define CTS_SAR_ADC_CLK                (28)
+#define CTS_ENCI_CLK                   (27)
+#define SC_CLK_INT                     (26)
+#define USB_CLK_12MHZ                  (25)
+#define LVDS_FIFO_CLK                  (24)
+#define HDMI_CH3_TMDSCLK               (23)
+#define MOD_ETH_CLK50_I                (22)
+#define MOD_AUDIN_AMCLK_I              (21)
+#define CTS_BTCLK27                    (20)
+#define CTS_HDMI_SYS_CLK               (19)
+#define CTS_LED_PLL_CLK                (18)
+#define CTS_VGHL_PLL_CLK               (17)
+#define CTS_FEC_CLK_2                  (16)
+#define CTS_FEC_CLK_1                  (15)
+#define CTS_FEC_CLK_0                  (14)
+#define CTS_AMCLK                      (13)
+#define VID2_PLL_CLK                   (12)
+#define CTS_ETH_RMII                   (11)
+#define CTS_ENCT_CLK                   (10)
+#define CTS_ENCL_CLK                   (9)
+#define CTS_ENCP_CLK                   (8)
+#define CLK81                          (7)
+#define VID_PLL_CLK                    (6)
+#define AUD_PLL_CLK                    (5)
+#define MISC_PLL_CLK                   (4)
+#define DDR_PLL_CLK                    (3)
+#define SYS_PLL_CLK                    (2)
+#define AM_RING_OSC_CLK_OUT1           (1)
+#define AM_RING_OSC_CLK_OUT0           (0)
+
+int clk_get_rate(unsigned clksrc);
+unsigned long clk_util_clk_msr( unsigned long   clk_mux );
+__u32 get_cpu_clk(void);
+__u32 get_clk_ddr(void);
+__u32 get_clk81(void);
+__u32 get_misc_pll_clk(void);
+
+
+#endif /* __ARCH_ARM_MESON_CLOCK_H_U_BOOT_ */
+
diff --git a/arch/arm/include/asm/arch-gxb/cpu.h b/arch/arm/include/asm/arch-gxb/cpu.h
new file mode 100644
index 0000000..359f7b0
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/cpu.h
@@ -0,0 +1,58 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/cpu.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _CPU_H
+#define _CPU_H
+//#include <config.h>
+//#include <asm/plat-cpu.h>
+//#include <asm/arch/ddr.h>
+
+#define CONFIG_AML_MESON 1
+#define CONFIG_AML_MESON_GX 1
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(64*1024*1024)
+
+/* dram */
+#define PHYS_SDRAM_1_BASE					0x00000000UL
+#define PHYS_SDRAM_1_SIZE					(CONFIG_DDR_SIZE << 20)
+#define CONFIG_SYS_SDRAM_BASE				PHYS_SDRAM_1_BASE
+#define CONFIG_SYS_INIT_SP_ADDR				(0x20000000)
+
+#define CONFIG_SYS_TEXT_BASE		0x01000000 /*16MB rsv*/
+#define CONFIG_SYS_LOAD_ADDR		(PHYS_SDRAM_1_BASE + CONFIG_SYS_TEXT_BASE)
+
+/* ? */
+#define CONFIG_SYS_CBSIZE		512
+#define CONFIG_SYS_PROMPT		SYS_PROMPT
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+/* support board late init */
+#define CONFIG_BOARD_LATE_INIT
+/* use "hush" command parser */
+#define CONFIG_SYS_HUSH_PARSER
+
+#define CONFIG_DTB_MEM_ADDR 0x1000000
+
+#endif /* _CPU_H */
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-gxb/cpu_config.h b/arch/arm/include/asm/arch-gxb/cpu_config.h
new file mode 100644
index 0000000..86c3045
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/cpu_config.h
@@ -0,0 +1,101 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/config.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _BOOT_ROM_CONFIG_H_
+#define _BOOT_ROM_CONFIG_H_
+
+/***********************************************************
+ * The following constants are GXBB definition
+ **********************************************************/
+#define ROMBOOT_START   0xD9040000
+#define ROM_SIZE        (64*1024)
+#define ROMBOOT_END     (ROMBOOT_START+ROM_SIZE)
+
+/***********************************************************
+ * AHB-SRAM Total Size 80KB, layout shown as below
+ *
+ * ROMCODE use the top 32KB
+ *
+ * [	128]	0xD901_3F80 - 0xD901_3FFF	Reserved
+ * [	128]	0xD901_3F00 - 0xD901_3F7F	CPUs Boot Entry
+ * [	256]	0xD901_3E00 - 0xD901_3EFF	Debug Info
+ * [	512]	0xD901_3C00 - 0xD901_3DFF	eFuse mirror
+ * [	 1K]	0xD901_3800 - 0xD901_3BFF	Secure Mailbox (3)
+ * [	 1K]	0xD901_3400 - 0xD901_37FF	High Mailbox (2) *
+ * [	 1K]	0xD901_3000 - 0xD901_33FF	High Mailbox (1) *
+ * [	26K]	0xD900_C800 - 0xD901_2FFF	BL1 Stack, BSS
+ * [	 1K]	0xD900_C400 - 0xD900_C7FF	NAND, USB Buffer
+ * [	 1K]	0xD900_C000 - 0xD900_C3FF	Reserved
+ *
+ **********************************************************/
+#define RAM_START			0xD9000000
+#define RAM_SIZE			(80 * 1024)
+#define BL1_RAM_START			(RAM_START + 0xC000)
+#define BL1_RAM_SIZE			(32 * 1024)
+#define BL1_RAM_END			(BL1_RAM_START + BL1_RAM_SIZE)
+#define BSS_START			(BL1_RAM_START + (2 * 1024))
+#define BSS_SIZE			(18 * 1024)
+#define _STACK_END			(BSS_START + BSS_SIZE + 8*1024)
+#define BL1_EFUSE_MIRROR		(BL1_RAM_END - 1024)
+#define P_SHARED_EFUSE_MIRROR		(volatile uint32_t *)(BL1_EFUSE_MIRROR)
+#define BL1_DEBUG_BUFFER		(BL1_RAM_END - 512)
+#define CPU_BOOT_ENTRY		(BL1_DEBUG_BUFFER + 256)
+#define P_SHARED_DEBUG_BUFF		(volatile uint32_t *)(BL1_DEBUG_BUFFER)
+#define BL1_SEC_MBX			(BL1_RAM_END - 2*1024)
+#define BL1_NAND_BUFF			(BL1_RAM_START + 1024)
+#define BL1_USB_BUFF			(BL1_NAND_BUFF)
+
+#define MEMORY_LOC			RAM_START
+
+#define SRAM_DEBUG_BUFF_SIZE		256
+
+/* BL2 SPL size */
+#define BL2_SIZE			(48 * 1024)
+
+//for signature test
+//#define CONFIG_AML_SIG_TEST_BUILD
+
+/* Software SHA2 */
+#define CONFIG_SHA2_SW
+
+/* Hardware SHA2 */
+#define CONFIG_SHA2_HW
+#define SHA2_HW_UPDATE_API
+
+/* Keep timer config in conf.h */
+#define CONFIG_TIMER
+
+/* Bootrom debug info */
+#define CONFIG_DEBUG_INFO
+
+/* Mincrypt RSA library */
+//#define CONFIG_MINCRYPT
+
+/* PolarSSL RSA library */
+#define CONFIG_POLARSSL_RSA
+
+#ifdef CONFIG_POLARSSL_RSA
+#ifndef CONFIG_MALLOC
+#define CONFIG_MALLOC
+#endif /* ! CONFIG_MALLOC */
+#endif /* CONFIG_POLARSSL_RSA */
+
+#endif /* _BOOT_ROM_CONFIG_H_ */
diff --git a/arch/arm/include/asm/arch-gxb/cpu_sdio.h b/arch/arm/include/asm/arch-gxb/cpu_sdio.h
new file mode 100644
index 0000000..cedf371
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/cpu_sdio.h
@@ -0,0 +1,264 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/cpu_sdio.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __CPU_SDIO_H__
+#define __CPU_SDIO_H__
+
+#define SD_EMMC_BASE_A 0xd0070000
+#define SD_EMMC_BASE_B 0xd0072000
+#define SD_EMMC_BASE_C 0xd0074000
+
+#define SDIO_PORT_A 0
+#define SDIO_PORT_B 1
+#define SDIO_PORT_C 2
+
+#define	Cfg_div 	0
+#define Cfg_src		6
+#define Cfg_co_phase	8
+#define	Cfg_tx_phase	10
+#define	Cfg_rx_phase	12
+#define	Cfg_sram_pd		14
+#define	Cfg_tx_delay	16
+#define	Cfg_rx_delay	20
+#define	Cfg_always_on	24
+#define	Cfg_irq_sdio_sleep   25
+#define Cfg_irq_sdio_sleep_ds		26
+
+#define	SD_EMMC_RXD_ERROR				1
+#define	SD_EMMC_TXD_ERROR				1<<1
+#define	SD_EMMC_DESC_ERROR				1<<2
+#define	SD_EMMC_RESP_CRC_ERROR			1<<3
+#define	SD_EMMC_RESP_TIMEOUT_ERROR		1<<4
+#define	SD_EMMC_DESC_TIMEOUT_ERROR		1<<5
+
+struct sd_emmc_global_regs {
+    volatile uint32_t gclock;     // 0x00
+    volatile uint32_t gdelay;     // 0x04
+    volatile uint32_t gadjust;    // 0x08
+    volatile uint32_t reserved_0c;       // 0x0c
+    volatile uint32_t gcalout;    // 0x10
+    volatile uint32_t reserved_14[11];   // 0x14~0x3c
+    volatile uint32_t gstart;     // 0x40
+    volatile uint32_t gcfg;       // 0x44
+    volatile uint32_t gstatus;    // 0x48
+    volatile uint32_t girq_en;    // 0x4c
+    volatile uint32_t gcmd_cfg;   // 0x50
+    volatile uint32_t gcmd_arg;   // 0x54
+    volatile uint32_t gcmd_dat;   // 0x58
+    volatile uint32_t gcmd_rsp0;   // 0x5c
+    volatile uint32_t gcmd_rsp1;  // 0x60
+    volatile uint32_t gcmd_rsp2;  // 0x64
+    volatile uint32_t gcmd_rsp3;  // 0x68
+    volatile uint32_t reserved_6c;       // 0x6c
+    volatile uint32_t gcurr_cfg;  // 0x70
+    volatile uint32_t gcurr_arg;  // 0x74
+    volatile uint32_t gcurr_dat;  // 0x78
+    volatile uint32_t gcurr_rsp;  // 0x7c
+    volatile uint32_t gnext_cfg;  // 0x80
+    volatile uint32_t gnext_arg;  // 0x84
+    volatile uint32_t gnext_dat;  // 0x88
+    volatile uint32_t gnext_rsp;  // 0x8c
+    volatile uint32_t grxd;       // 0x90
+    volatile uint32_t gtxd;       // 0x94
+    volatile uint32_t reserved_98[90];   // 0x98~0x1fc
+    volatile uint32_t gdesc[128]; // 0x200
+    volatile uint32_t gping[128]; // 0x400
+    volatile uint32_t gpong[128]; // 0x800
+};
+
+union sd_emmc_setup {
+    uint32_t d32;
+    struct {
+        unsigned bw:3;
+        unsigned fast:1;
+        unsigned par:3;
+        unsigned hcs:1;
+        unsigned sd:1;
+        unsigned sdhc:1;
+        unsigned type:6;
+        unsigned rca:16;
+    } b;
+};
+
+struct sd_emmc_desc_info{
+    uint32_t cmd_info;
+    uint32_t cmd_arg;
+    uint32_t data_addr;
+    uint32_t resp_addr;
+};
+
+struct cmd_cfg{
+    uint32_t length:9;
+    uint32_t block_mode:1;
+    uint32_t r1b:1;
+    uint32_t end_of_chain:1;
+    uint32_t timeout:4;
+    uint32_t no_resp:1;
+    uint32_t no_cmd:1;
+    uint32_t data_io:1;
+    uint32_t data_wr:1;
+    uint32_t resp_nocrc:1;
+    uint32_t resp_128:1;
+    uint32_t resp_num:1;
+    uint32_t data_num:1;
+    uint32_t cmd_index:6;
+    uint32_t error:1;
+    uint32_t owner:1;
+};
+
+struct sd_emmc_status{
+	uint32_t rxd_err:8;      /*[7:0]     RX data CRC error per wire, for multiple block read, the CRC errors are ORed together.*/
+	uint32_t txd_err:1;      /*[8]       TX data CRC error, for multiple block write, any one of blocks CRC error. */
+	uint32_t desc_err:1;     /*[9]       SD/eMMC controller doesnt own descriptor. The owner bit is 0, set cfg_ignore_owner to ignore this error.*/
+	uint32_t resp_err:1;     /*[10]      Response CRC error.*/
+	uint32_t resp_timeout:1; /*[11]      No response received before time limit. The timeout limit is set by cfg_resp_timeout.*/
+	uint32_t desc_timeout:1; /*[12]      Descriptor execution time over time limit. The timeout limit is set by descriptor itself.*/
+                            /*      Consider the multiple block read/write, set the proper timeout limits.*/
+	uint32_t end_of_chain:1; /*[13]      End of Chain IRQ, Normal IRQ. */
+	uint32_t desc_irq:1;     /*[14]      This descriptor requests an IRQ, Normal IRQ, the descriptor chain execution keeps going on.*/
+	uint32_t irq_sdio:1;     /*[15]      SDIO device uses DAT[1] to request IRQ. */
+	uint32_t dat_i:8;        /*[23:16]   Input data signals. */
+	uint32_t cmd_i:1;        /*[24]      nput response signal. */
+	uint32_t ds:1;           /*[25]      Input data strobe. */
+	uint32_t bus_fsm:1;      /*[30:28]   BUS fsm */
+    uint32_t desc_wr_rdy:1;  /*[31]      Descriptor write back process is done and it is ready for CPU to read.*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_clock{
+    uint32_t div:6;          /*[5:0]     Clock divider. Frequency = clock source/cfg_div, Maximum divider 63. */
+                            /*Clock off: cfg_div==0, the clock is disabled */
+                            /*Divider bypass: cfg_div==1, clock source is used as core clock without divider. */
+    uint32_t src:2;          /*[7:6]     Clock source, 0: Crystal 24MHz, 1: Fix PLL, 850MHz*/
+                            /* 2: MPLL, <637MHz, used for 400MHz exactly. 3: different PLL */
+    uint32_t core_phase:2;   /*[9:8]     Core clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t tx_phase:2;     /*[11:10]   TX clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t rx_phase:2;     /*[13:12]   RX clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t reserved14:2;
+    uint32_t tx_delay:4;     /*[19:16]   TX clock delay line. 0: no delay, n: delay n*200ps. Maximum delay 3ns.*/
+    uint32_t rx_delay:4;     /*[23:20]   RX clock delay line. 0: no delay, n: delay n*200ps. Maximum delay 3ns.*/
+    uint32_t always_on:1;    /*[24]      1: Keep clock always on. 0: Clock on/off controlled by activities. */
+                            /*Any APB3 access or descriptor execution will keep clock on.*/
+    uint32_t irq_sdio_sleep:1; /*[25]    1: enable IRQ sdio when in sleep mode. */
+    uint32_t reserved26:6;
+};
+
+struct sd_emmc_delay{
+    uint32_t dat0:4;         /*[3:0]       Data 0 delay line. */
+    uint32_t dat1:4;         /*[7:4]       Data 1 delay line. */
+    uint32_t dat2:4;         /*[11:8]      Data 2 delay line. */
+    uint32_t dat3:4;         /*[15:12]     Data 3 delay line. */
+    uint32_t dat4:4;         /*[19:16]     Data 4 delay line. */
+    uint32_t dat5:4;         /*[23:20]     Data 5 delay line. */
+    uint32_t dat6:4;         /*[27:24]     Data 6 delay line. */
+    uint32_t dat7:4;         /*[31:28]     Data 7 delay line. */
+};
+
+
+struct sd_emmc_adjust{
+    uint32_t cmd_delay:4;           /*[3:0]       Command delay line. */
+    uint32_t ds_delay:4;            /*[7:4]       DS delay line. */
+    uint32_t cali_sel:4;            /*[11:8]      Select one signal to be tested.*/
+                                        /*Signals are labeled from 0 to 9 the same as delay lines. */
+    uint32_t cali_enable:1;         /*[12]        Enable calibration. */
+    uint32_t adj_enable:1;          /*[13]       Adjust interface timing by resampling the input signals. */
+    uint32_t cali_rise:1;           /*[14]       1: test the rising edge. 0: test the falling edge. */
+    uint32_t reserved15:1;
+    uint32_t adj_delay:6;           /*[21:16]       Resample the input signals when clock index==adj_delay. */
+    uint32_t reserved22:10;
+};
+
+
+struct sd_emmc_calout{
+    uint32_t cali_idx:6;         /*[5:0]       Calibration reading. The event happens at this index. */
+    uint32_t reserved6:1;
+    uint32_t cali_vld:1;         /*[7]         The reading is valid. */
+    uint32_t cali_setup:8;       /*[15:8]      Copied from BASE+0x8 [15:8] include cali_sel, cali_enable, adj_enable, cali_rise. */
+    uint32_t reserved16:16;
+};
+
+
+struct sd_emmc_start{
+	uint32_t init:1;         /*[0]   1: Read descriptor from internal SRAM, limited to 32 descriptors. */
+                            /*  0: Read descriptor from external DDR */
+	uint32_t busy:1;         /*[1]   1: Start command chain execution process. 0: Stop */
+	uint32_t addr:30;        /*[31:2] Descriptor address, the last 2 bits are 0, 4 bytes aligned. */
+                            /*  When internal SRAM is used, the valid address range is from 0x200~0x3ff */
+                            /*  When external DDR is used, the valid address is anywhere in DDR, the length of chain is unlimited.*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_config{
+	uint32_t bus_width:2;    /*[1:0]     0: 1 bit, 1: 4 bits, 2: 8 bits, 3: 2 bits (not supported)*/
+	uint32_t ddr:1;          /*[2]       1: DDR mode, 0: SDR mode */
+	uint32_t dc_ugt:1;       /*[3]       1: DDR access urgent, 0: DDR access normal. */
+	uint32_t bl_len:4;       /*[7:4]     Block length 2^cfg_bl_len, because internal buffer size is limited to 512 bytes, the cfg_bl_len <=9. */
+	uint32_t resp_timeout:4; /*[11:8]    Wait response till 2^cfg_resp_timeout core clock cycles. Maximum 32768 core cycles. */
+	uint32_t rc_cc:4;        /*[15:12]   Wait response-command, command-command gap before next command, 2^cfg_rc_cc core clock cycles. */
+	uint32_t out_fall:1;     /*[16]      DDR mode only. The command and TXD start from rising edge. Set 1 to start from falling edge. */
+	uint32_t blk_gap_ip:1;   /*[17]      1: Enable SDIO data block gap interrupt period. 0: Disabled.*/
+	uint32_t spare:1;        /*[18]      Spare,  ??? need check*/
+	uint32_t ignore_owner:1; /*[19]      Use this descriptor even if its owner bit is 0.*/
+	uint32_t chk_ds:1;       /*[20]      Check data strobe in HS400.*/
+	uint32_t cmd_low:1;      /*[21]      Hold CMD as output Low, eMMC boot mode.*/
+	uint32_t stop_clk:1;     /*[22]      1: stop clock. 0: normal clock.*/
+	                        /*In normal mode, the clock is automatically on/off during reading mode to back off reading in case of*/
+	                        /*DDR slow response, stop clock is used in voltage switch.*/
+	uint32_t auto_clk:1;     /*[23]      1: when BUS is idle and no descriptor is available, turn off clock, to save power.*/
+                            /*      0: core clock is always on.*/
+    uint32_t txd_add_err:1;	/*[24]   	TXD add error test*/
+							/*Test feature, should not be used in normal condition.*/
+							/*It will inverted the first CRC bits of the 3rd block.*/
+							/*Block index starts from 0, 1, 2, */
+    uint32_t txd_retry:1;	/*[25]   	When TXD CRC error, host sends the block again.*/
+							/*The total number of retries of one descriptor is limited to 15, */
+							/*after 15 retries, the TXD_err is set to high.*/
+    uint32_t revd:8;	        /*[31:26]   reved*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_irq_en{
+	uint32_t rxd_err:8;      /*[7:0]     RX data CRC error per wire.*/
+	uint32_t txd_err:1;      /*[8]       TX data CRC error. */
+	uint32_t desc_err:1;     /*[9]       SD/eMMC controller doesnt own descriptor. */
+	uint32_t resp_err:1;     /*[10]      Response CRC error.*/
+	uint32_t resp_timeout:1; /*[11]      No response received before time limit. */
+	uint32_t desc_timeout:1; /*[12]      Descriptor execution time over time limit. */
+	uint32_t end_of_chain:1; /*[13]      End of Chain IRQ. */
+	uint32_t desc_irq:1;     /*[14]      This descriptor requests an IRQ. */
+	uint32_t irq_sdio:1;     /*[15]      Enable sdio interrupt. */
+    uint32_t revd:16;	    /*[31:16]   reved*/
+};
+
+struct sd_emmc_data_info{
+	uint32_t cnt:10;         /*[9:0]     Rxd words received from BUS. Txd words received from DDR.*/
+	uint32_t blk:9;          /*[24:16]   Rxd Blocks received from BUS. Txd blocks received from DDR.*/
+	uint32_t revd:30;        /*[31:17]   Reved. */
+};
+
+
+struct sd_emmc_card_info{
+	uint32_t txd_cnt:10;     /*[9:0]     Txd BUS cycle counter. */
+	uint32_t txd_blk:9;      /*[24:16]   Txd BUS block counter.*/
+	uint32_t revd:30;        /*[31:17]   Reved. */
+};
+
+#endif
diff --git a/arch/arm/include/asm/arch-gxb/ddr.h b/arch/arm/include/asm/arch-gxb/ddr.h
new file mode 100644
index 0000000..9a182a2
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/ddr.h
@@ -0,0 +1,96 @@
+
+#include <config.h>
+#include <io.h>
+#include <stdint.h>
+#include <asm/arch/ddr_define.h>
+
+/* io defines */
+//#define wr_reg(addr, data)	(*((volatile uint32_t *)addr))=(uint32_t)(uint64_t)(data)
+//#define rd_reg(addr)		(*((volatile uint32_t *)(addr)))
+#define wr_reg(addr, data)	writel(data, addr)
+#define rd_reg(addr)	readl(addr)
+/*clear [mask] 0 bits in [addr], set these 0 bits with [value] corresponding bits*/
+#define modify_reg(addr, value, mask) wr_reg(addr, ((rd_reg(addr) & (mask)) | (value)))
+#define wait_set(addr, loc) do{}while(0 == (rd_reg(addr) & (1<<loc)));
+#define wait_clr(addr, loc) do{}while(1 == (rd_reg(addr) & (1<<loc)));
+#define wait_equal(addr, data) do{}while(data != (rd_reg(addr)));
+
+/* function defines */
+unsigned int ddr_init(void);
+unsigned int ddr_init_pll(void);
+unsigned int ddr_init_dmc(void);
+unsigned int ddr_init_pctl(void);
+unsigned int hot_boot(void);
+void ddr_print_info(void);
+void ddr_test(void);
+void ddr_pre_init(void);
+void ddr_debug(void);
+
+/* pctl status */
+#define  UPCTL_STAT_MASK        (7)
+#define  UPCTL_STAT_INIT        (0)
+#define  UPCTL_STAT_CONFIG      (1)
+#define  UPCTL_STAT_ACCESS      (3)
+#define  UPCTL_STAT_LOW_POWER   (5)
+
+/* pctl cmds */
+#define UPCTL_CMD_INIT         (0)
+#define UPCTL_CMD_CONFIG       (1)
+#define UPCTL_CMD_GO           (2)
+#define UPCTL_CMD_SLEEP        (3)
+#define UPCTL_CMD_WAKEUP       (4)
+
+/* PUB PIR setting */
+#define PUB_PIR_INIT						(1<<0)
+#define PUB_PIR_ZCAL						(1<<1)
+#define PUB_PIR_CA							(1<<2)
+#define PUB_PIR_PLLINIT						(1<<4)
+#define PUB_PIR_DCAL						(1<<5)
+#define PUB_PIR_PHYRST						(1<<6)
+#define PUB_PIR_DRAMRST						(1<<7)
+#define PUB_PIR_DRAMINIT					(1<<8)
+#define PUB_PIR_WL							(1<<9)
+#define PUB_PIR_QSGATE						(1<<10)
+#define PUB_PIR_WLADJ						(1<<11)
+#define PUB_PIR_RDDSKW						(1<<12)
+#define PUB_PIR_WRDSKW						(1<<13)
+#define PUB_PIR_RDEYE						(1<<14)
+#define PUB_PIR_WREYE						(1<<15)
+#define PUB_PIR_ICPC						(1<<16)
+#define PUB_PIR_PLLBYP						(1<<17)
+#define PUB_PIR_CTLDINIT					(1<<18)
+#define PUB_PIR_RDIMMINIT					(1<<19)
+#define PUB_PIR_CLRSR						(1<<27)
+#define PUB_PIR_LOCKBYP						(1<<28)
+#define PUB_PIR_DCALBYP						(1<<29)
+#define PUB_PIR_ZCALBYP						(1<<30)
+#define PUB_PIR_INITBYP						(1<<31)
+
+/* PHY initialize register (PIR) */
+#define DDR_PIR ((PUB_PIR_ZCAL) 		|\
+				(PUB_PIR_PLLINIT) 		|\
+				(PUB_PIR_DCAL) 			|\
+				(PUB_PIR_PHYRST)		|\
+				(PUB_PIR_DRAMRST)		|\
+				(PUB_PIR_DRAMINIT)		|\
+				(PUB_PIR_WL)			|\
+				(PUB_PIR_QSGATE)		|\
+				(PUB_PIR_WLADJ)			|\
+				(PUB_PIR_RDDSKW)		|\
+				(PUB_PIR_WRDSKW)		|\
+				(PUB_PIR_RDEYE)			|\
+				(PUB_PIR_WREYE)			 \
+				)
+
+/* PHY general status register (PGSR0) */
+#if (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3)
+#define DDR_PGSR0_CHECK() ((rd_reg(DDR0_PUB_PGSR0) != 0xC0000fff) && \
+							(rd_reg(DDR0_PUB_PGSR0) != 0x80000fff))
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR2)
+#define DDR_PGSR0_CHECK()
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+#define DDR_PGSR0_CHECK()
+#endif
+
+/* other regs */
+#define SCRATCH0				0xC1107D3C
diff --git a/arch/arm/include/asm/arch-gxb/ddr_define.h b/arch/arm/include/asm/arch-gxb/ddr_define.h
new file mode 100644
index 0000000..3fc0117
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/ddr_define.h
@@ -0,0 +1,31 @@
+
+/* ddr type defines */
+#define CONFIG_DDR_TYPE_DDR3				0
+#define CONFIG_DDR_TYPE_LPDDR2				1
+#define CONFIG_DDR_TYPE_LPDDR3				2
+
+/* ddr channel defines */
+#define CONFIG_DDR0_RANK0_ONLY				1
+#define CONFIG_DDR0_RANK01_SAME				2
+#define CONFIG_DDR0_RANK01_DIFF				3
+#define CONFIG_DDR01_SHARE_AC				4
+#define CONFIG_DDR0_ONLY_16BIT				5
+
+#define CFG_DDR_BASE_ADDR					0X0
+#define CFG_DDR_START_OFFSET				0X01000000 //SKIP 16MB
+
+/* ddr type identifier */
+#define CONFIG_DDR_TIMMING_LPDDR2			0x02
+#define CONFIG_DDR_TIMMING_LPDDR3			0x03
+#define CONFIG_DDR_TIMMING_DDR3_7			0x07
+#define CONFIG_DDR_TIMMING_DDR3_9			0x09
+#define CONFIG_DDR_TIMMING_DDR3_11			0x0B
+#define CONFIG_DDR_TIMMING_DDR3_12			0x0C
+#define CONFIG_DDR_TIMMING_DDR3_13			0x0D
+#define CONFIG_DDR_TIMMING_DDR3_14			0x0E
+
+#define DDR_USE_1_CHANNEL(chl_set)	((chl_set == CONFIG_DDR0_RANK01_SAME) || \
+				(chl_set == CONFIG_DDR0_ONLY_16BIT) || \
+				(chl_set == CONFIG_DDR0_RANK0_ONLY))
+#define DDR_USE_2_CHANNEL(chl_set)	((chl_set == CONFIG_DDR01_SHARE_AC) || \
+					(chl_set == CONFIG_DDR0_RANK01_DIFF))
diff --git a/arch/arm/include/asm/arch-gxb/efuse.h b/arch/arm/include/asm/arch-gxb/efuse.h
new file mode 100644
index 0000000..64c9ba4
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/efuse.h
@@ -0,0 +1,62 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/efuse.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __EFUSE_H
+#define __EFUSE_H
+
+#include <config.h>
+#include <common.h>
+
+/* efuse HAL_API arg */
+struct efuse_hal_api_arg {
+	unsigned int cmd;		/* R/W */
+	unsigned int offset;
+	unsigned int size;
+	unsigned long buffer_phy;
+	unsigned long retcnt_phy;
+};
+
+
+#define EFUSE_BYTES				512   /* (EFUSE_BITS/8) */
+
+#define EFUSE_HAL_API_READ	0
+#define EFUSE_HAL_API_WRITE 1
+#define EFUSE_HAL_API_WRITE_PATTERN 2
+#define EFUSE_HAL_API_USER_MAX 3
+
+#define EFUSE_USER_MASK            (0x1 << 16)
+#define EFUSE_THERMAL_MASK         (0x1 << 17)
+#define EFUSE_THERMAL_VERFLAG_MASK (0x1 << 18)
+#define EFUSE_ENCRYPT_MASK         (0x1 << 19)
+
+#define ASSIST_HW_REV                              0x1f53
+
+int efuse_read_usr(char *buf, size_t count, loff_t *ppos);
+int efuse_write_usr(char *buf, size_t count, loff_t *ppos);
+uint32_t efuse_get_max(void);
+ssize_t efuse_read(char *buf, size_t count, loff_t *ppos);
+ssize_t efuse_write(const char *buf, size_t count, loff_t *ppos);
+
+int32_t meson_trustzone_efuse(struct efuse_hal_api_arg *arg);
+int32_t meson_trustzone_efuse_get_max(struct efuse_hal_api_arg *arg);
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-gxb/eth_setup.h b/arch/arm/include/asm/arch-gxb/eth_setup.h
new file mode 100644
index 0000000..883814f0
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/eth_setup.h
@@ -0,0 +1,116 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/eth_setup.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/io.h>
+
+/*
+ *board configuration interface.
+ * */
+struct eth_clock_conf{
+	int enable;
+	int clock_50MHZ_phase;
+	//add ... as you need.
+};
+
+struct eth_board_socket{
+char *name ;
+int (*eth_clock_configure)(struct eth_clock_conf);
+int (*eth_pinmux_setup)(void);
+int (*eth_hw_reset)(void);
+
+};
+
+
+
+/*
+ *clock define part
+ */
+
+#define ETH_BASE                                (0xC9410000)
+#define ETH_PLL_CNTL                            CBUS_REG_ADDR(0x2050)
+ /* Ethernet ctrl */
+#define ETH_PLL_CNTL_DIVEN                      (1<<0)
+#define ETH_PLL_CNTL_MACSPD                     (1<<1)
+#define ETH_PLL_CNTL_DATEND                     (1<<2)
+#define ETH_PLL_CNTL_DESEND                     (1<<3)
+
+
+/*
+	please refer following doc for detail
+	@AppNote-M3-ClockTrees.docx
+
+	select clk: -> CBUS_REG(0x1076)
+
+	7-sys_pll_div2
+	6-vid2_pll_clk
+	5-vid_pll_clk
+	4-aud_pll_clk
+	3-ddr_pll_clk
+	2-misc_pll_clk
+	1-sys_pll_clk
+	0-XTAL
+
+	clk_freq:800MHz
+	output_clk:50MHz
+	aways,maybe changed for others?
+*/
+
+#define ETH_CLKSRC_XTAL             (0)
+#define ETH_CLKSRC_SYS_PLL_CLK      (1)
+#define ETH_CLKSRC_MISC_PLL_CLK     (2)
+#define ETH_CLKSRC_DDR_PLL_CLK      (3)
+#define ETH_CLKSRC_AUD_PLL_CLK      (
+#define ETH_CLKSRC_VID_PLL_CLK      (5)
+#define ETH_CLKSRC_VID2_PLL_CLK     (6)
+#define ETH_CLKSRC_SYS_PLL_DIV2_CLK (7)
+#define CLK_1M						(1000000)
+
+typedef union eth_aml_reg0 {
+    /** raw register data */
+    unsigned int d32;
+    /** register bits */
+	struct {
+        unsigned phy_intf_sel:1;
+        unsigned data_endian:1;
+        unsigned desc_endian:1;
+        unsigned rx_clk_rmii_invert:1;
+        unsigned rgmii_tx_clk_src:1;
+        unsigned rgmii_tx_clk_phase:2;
+        unsigned rgmii_tx_clk_ratio:3;
+        unsigned phy_ref_clk_enable:1;
+        unsigned clk_rmii_i_invert:1;
+        unsigned clk_en:1;
+        unsigned adj_enable:1;
+        unsigned adj_setup:1;
+        unsigned adj_delay:5;
+        unsigned adj_skew:5;
+        unsigned cali_start:1;
+        unsigned cali_rise:1;
+        unsigned cali_sel:3;
+        unsigned rgmii_rx_reuse:1;
+        unsigned eth_urgent:1;
+		} b;
+} eth_aml_reg0_t;
+
+#define ETH_VALIDE_CLKSRC(clk,out_clk) ((clk%out_clk)==0)
+
+int  eth_clk_set(int selectclk,unsigned long clk_freq,unsigned long out_clk);
+
diff --git a/arch/arm/include/asm/arch-gxb/gpio.h b/arch/arm/include/asm/arch-gxb/gpio.h
new file mode 100644
index 0000000..01c3a8e
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/gpio.h
@@ -0,0 +1,286 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/gpio.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_GPIO_H_
+#define __ARCH_GPIO_H_
+/*AO Bank*/
+#define	GPIOAO_0    0
+#define	GPIOAO_1    1
+#define	GPIOAO_2    2
+#define	GPIOAO_3    3
+#define	GPIOAO_4    4
+#define	GPIOAO_5    5
+#define	GPIOAO_6    6
+#define	GPIOAO_7    7
+#define	GPIOAO_8    8
+#define	GPIOAO_9    9
+#define	GPIOAO_10    10
+#define	GPIOAO_11    11
+#define	GPIOAO_12    12
+#define	GPIOAO_13    13
+
+/*EE Bank*/
+#define	GPIOZ_0    0
+#define	GPIOZ_1    1
+#define	GPIOZ_2    2
+#define	GPIOZ_3    3
+#define	GPIOZ_4    4
+#define	GPIOZ_5    5
+#define	GPIOZ_6    6
+#define	GPIOZ_7    7
+#define	GPIOZ_8    8
+#define	GPIOZ_9    9
+#define	GPIOZ_10    10
+#define	GPIOZ_11    11
+#define	GPIOZ_12    12
+#define	GPIOZ_13    13
+#define	GPIOZ_14    14
+#define	GPIOZ_15    15
+#define	GPIOH_0    16
+#define	GPIOH_1    17
+#define	GPIOH_2    18
+#define	GPIOH_3    19
+#define	BOOT_0    20
+#define	BOOT_1    21
+#define	BOOT_2    22
+#define	BOOT_3    23
+#define	BOOT_4    24
+#define	BOOT_5    25
+#define	BOOT_6    26
+#define	BOOT_7    27
+#define	BOOT_8    28
+#define	BOOT_9    29
+#define	BOOT_10    30
+#define	BOOT_11    31
+#define	BOOT_12    32
+#define	BOOT_13    33
+#define	BOOT_14    34
+#define	BOOT_15    35
+#define	BOOT_16    36
+#define	BOOT_17    37
+#define	CARD_0    38
+#define	CARD_1    39
+#define	CARD_2    40
+#define	CARD_3    41
+#define	CARD_4    42
+#define	CARD_5    43
+#define	CARD_6    44
+#define	GPIODV_0    45
+#define	GPIODV_1    46
+#define	GPIODV_2    47
+#define	GPIODV_3    48
+#define	GPIODV_4    49
+#define	GPIODV_5    50
+#define	GPIODV_6    51
+#define	GPIODV_7    52
+#define	GPIODV_8    53
+#define	GPIODV_9    54
+#define	GPIODV_10    55
+#define	GPIODV_11    56
+#define	GPIODV_12    57
+#define	GPIODV_13    58
+#define	GPIODV_14    59
+#define	GPIODV_15    60
+#define	GPIODV_16    61
+#define	GPIODV_17    62
+#define	GPIODV_18    63
+#define	GPIODV_19    64
+#define	GPIODV_20    65
+#define	GPIODV_21    66
+#define	GPIODV_22    67
+#define	GPIODV_23    68
+#define	GPIODV_24    69
+#define	GPIODV_25    70
+#define	GPIODV_26    71
+#define	GPIODV_27    72
+#define	GPIODV_28    73
+#define	GPIODV_29    74
+#define	GPIOY_0    75
+#define	GPIOY_1    76
+#define	GPIOY_2    77
+#define	GPIOY_3    78
+#define	GPIOY_4    79
+#define	GPIOY_5    80
+#define	GPIOY_6    81
+#define	GPIOY_7    82
+#define	GPIOY_8    83
+#define	GPIOY_9    84
+#define	GPIOY_10    85
+#define	GPIOY_11    86
+#define	GPIOY_12    87
+#define	GPIOY_13    88
+#define	GPIOY_14    89
+#define	GPIOY_15    90
+#define	GPIOY_16    91
+#define	GPIOX_0    92
+#define	GPIOX_1    93
+#define	GPIOX_2    94
+#define	GPIOX_3    95
+#define	GPIOX_4    96
+#define	GPIOX_5    97
+#define	GPIOX_6    98
+#define	GPIOX_7    99
+#define	GPIOX_8    100
+#define	GPIOX_9    101
+#define	GPIOX_10    102
+#define	GPIOX_11    103
+#define	GPIOX_12    104
+#define	GPIOX_13    105
+#define	GPIOX_14    106
+#define	GPIOX_15    107
+#define	GPIOX_16    108
+#define	GPIOX_17    109
+#define	GPIOX_18    110
+#define	GPIOX_19    111
+#define	GPIOX_20    112
+#define	GPIOX_21    113
+#define	GPIOX_22    114
+#define	GPIOCLK_0    115
+#define	GPIOCLK_1    116
+#define	GPIOCLK_2    117
+#define	GPIOCLK_3    118
+#define	GPIO_TEST_N    119
+
+
+
+#define EE_OFFSET 14
+
+#define	PIN_GPIOZ_0    (EE_OFFSET + GPIOZ_0)
+#define	PIN_GPIOZ_1    (EE_OFFSET + GPIOZ_1)
+#define	PIN_GPIOZ_2    (EE_OFFSET + GPIOZ_2)
+#define	PIN_GPIOZ_3    (EE_OFFSET + GPIOZ_3)
+#define	PIN_GPIOZ_4    (EE_OFFSET + GPIOZ_4)
+#define	PIN_GPIOZ_5    (EE_OFFSET + GPIOZ_5)
+#define	PIN_GPIOZ_6    (EE_OFFSET + GPIOZ_6)
+#define	PIN_GPIOZ_7    (EE_OFFSET + GPIOZ_7)
+#define	PIN_GPIOZ_8    (EE_OFFSET + GPIOZ_8)
+#define	PIN_GPIOZ_9    (EE_OFFSET + GPIOZ_9)
+#define	PIN_GPIOZ_10    (EE_OFFSET + GPIOZ_10)
+#define	PIN_GPIOZ_11    (EE_OFFSET + GPIOZ_11)
+#define	PIN_GPIOZ_12    (EE_OFFSET + GPIOZ_12)
+#define	PIN_GPIOZ_13    (EE_OFFSET + GPIOZ_13)
+#define	PIN_GPIOZ_14    (EE_OFFSET + GPIOZ_14)
+#define	PIN_GPIOZ_15    (EE_OFFSET + GPIOZ_15)
+#define	PIN_GPIOH_0    (EE_OFFSET + GPIOH_0)
+#define	PIN_GPIOH_1    (EE_OFFSET + GPIOH_1)
+#define	PIN_GPIOH_2    (EE_OFFSET + GPIOH_2)
+#define	PIN_GPIOH_3    (EE_OFFSET + GPIOH_3)
+#define	PIN_BOOT_0    (EE_OFFSET + BOOT_0)
+#define	PIN_BOOT_1    (EE_OFFSET + BOOT_1)
+#define	PIN_BOOT_2    (EE_OFFSET + BOOT_2)
+#define	PIN_BOOT_3    (EE_OFFSET + BOOT_3)
+#define	PIN_BOOT_4    (EE_OFFSET + BOOT_4)
+#define	PIN_BOOT_5    (EE_OFFSET + BOOT_5)
+#define	PIN_BOOT_6    (EE_OFFSET + BOOT_6)
+#define	PIN_BOOT_7    (EE_OFFSET + BOOT_7)
+#define	PIN_BOOT_8    (EE_OFFSET + BOOT_8)
+#define	PIN_BOOT_9    (EE_OFFSET + BOOT_9)
+#define	PIN_BOOT_10    (EE_OFFSET + BOOT_10)
+#define	PIN_BOOT_11    (EE_OFFSET + BOOT_11)
+#define	PIN_BOOT_12    (EE_OFFSET + BOOT_12)
+#define	PIN_BOOT_13    (EE_OFFSET + BOOT_13)
+#define	PIN_BOOT_14    (EE_OFFSET + BOOT_14)
+#define	PIN_BOOT_15    (EE_OFFSET + BOOT_15)
+#define	PIN_BOOT_16    (EE_OFFSET + BOOT_16)
+#define	PIN_BOOT_17    (EE_OFFSET + BOOT_17)
+#define	PIN_CARD_0    (EE_OFFSET + CARD_0)
+#define	PIN_CARD_1    (EE_OFFSET + CARD_1)
+#define	PIN_CARD_2    (EE_OFFSET + CARD_2)
+#define	PIN_CARD_3    (EE_OFFSET + CARD_3)
+#define	PIN_CARD_4    (EE_OFFSET + CARD_4)
+#define	PIN_CARD_5    (EE_OFFSET + CARD_5)
+#define	PIN_CARD_6    (EE_OFFSET + CARD_6)
+#define	PIN_GPIODV_0    (EE_OFFSET + GPIODV_0)
+#define	PIN_GPIODV_1    (EE_OFFSET + GPIODV_1)
+#define	PIN_GPIODV_2    (EE_OFFSET + GPIODV_2)
+#define	PIN_GPIODV_3    (EE_OFFSET + GPIODV_3)
+#define	PIN_GPIODV_4    (EE_OFFSET + GPIODV_4)
+#define	PIN_GPIODV_5    (EE_OFFSET + GPIODV_5)
+#define	PIN_GPIODV_6    (EE_OFFSET + GPIODV_6)
+#define	PIN_GPIODV_7    (EE_OFFSET + GPIODV_7)
+#define	PIN_GPIODV_8    (EE_OFFSET + GPIODV_8)
+#define	PIN_GPIODV_9    (EE_OFFSET + GPIODV_9)
+#define	PIN_GPIODV_10    (EE_OFFSET + GPIODV_10)
+#define	PIN_GPIODV_11    (EE_OFFSET + GPIODV_11)
+#define	PIN_GPIODV_12    (EE_OFFSET + GPIODV_12)
+#define	PIN_GPIODV_13    (EE_OFFSET + GPIODV_13)
+#define	PIN_GPIODV_14    (EE_OFFSET + GPIODV_14)
+#define	PIN_GPIODV_15    (EE_OFFSET + GPIODV_15)
+#define	PIN_GPIODV_16    (EE_OFFSET + GPIODV_16)
+#define	PIN_GPIODV_17    (EE_OFFSET + GPIODV_17)
+#define	PIN_GPIODV_18    (EE_OFFSET + GPIODV_18)
+#define	PIN_GPIODV_19    (EE_OFFSET + GPIODV_19)
+#define	PIN_GPIODV_20    (EE_OFFSET + GPIODV_20)
+#define	PIN_GPIODV_21    (EE_OFFSET + GPIODV_21)
+#define	PIN_GPIODV_22    (EE_OFFSET + GPIODV_22)
+#define	PIN_GPIODV_23    (EE_OFFSET + GPIODV_23)
+#define	PIN_GPIODV_24    (EE_OFFSET + GPIODV_24)
+#define	PIN_GPIODV_25    (EE_OFFSET + GPIODV_25)
+#define	PIN_GPIODV_26    (EE_OFFSET + GPIODV_26)
+#define	PIN_GPIODV_27    (EE_OFFSET + GPIODV_27)
+#define	PIN_GPIODV_28    (EE_OFFSET + GPIODV_28)
+#define	PIN_GPIODV_29    (EE_OFFSET + GPIODV_29)
+#define	PIN_GPIOY_0    (EE_OFFSET + GPIOY_0)
+#define	PIN_GPIOY_1    (EE_OFFSET + GPIOY_1)
+#define	PIN_GPIOY_2    (EE_OFFSET + GPIOY_2)
+#define	PIN_GPIOY_3    (EE_OFFSET + GPIOY_3)
+#define	PIN_GPIOY_4    (EE_OFFSET + GPIOY_4)
+#define	PIN_GPIOY_5    (EE_OFFSET + GPIOY_5)
+#define	PIN_GPIOY_6    (EE_OFFSET + GPIOY_6)
+#define	PIN_GPIOY_7    (EE_OFFSET + GPIOY_7)
+#define	PIN_GPIOY_8    (EE_OFFSET + GPIOY_8)
+#define	PIN_GPIOY_9    (EE_OFFSET + GPIOY_9)
+#define	PIN_GPIOY_10    (EE_OFFSET + GPIOY_10)
+#define	PIN_GPIOY_11    (EE_OFFSET + GPIOY_11)
+#define	PIN_GPIOY_12    (EE_OFFSET + GPIOY_12)
+#define	PIN_GPIOY_13    (EE_OFFSET + GPIOY_13)
+#define	PIN_GPIOY_14    (EE_OFFSET + GPIOY_14)
+#define	PIN_GPIOY_15    (EE_OFFSET + GPIOY_15)
+#define	PIN_GPIOY_16    (EE_OFFSET + GPIOY_16)
+#define	PIN_GPIOX_0    (EE_OFFSET + GPIOX_0)
+#define	PIN_GPIOX_1    (EE_OFFSET + GPIOX_1)
+#define	PIN_GPIOX_2    (EE_OFFSET + GPIOX_2)
+#define	PIN_GPIOX_3    (EE_OFFSET + GPIOX_3)
+#define	PIN_GPIOX_4    (EE_OFFSET + GPIOX_4)
+#define	PIN_GPIOX_5    (EE_OFFSET + GPIOX_5)
+#define	PIN_GPIOX_6    (EE_OFFSET + GPIOX_6)
+#define	PIN_GPIOX_7    (EE_OFFSET + GPIOX_7)
+#define	PIN_GPIOX_8    (EE_OFFSET + GPIOX_8)
+#define	PIN_GPIOX_9    (EE_OFFSET + GPIOX_9)
+#define	PIN_GPIOX_10    (EE_OFFSET + GPIOX_10)
+#define	PIN_GPIOX_11    (EE_OFFSET + GPIOX_11)
+#define	PIN_GPIOX_12    (EE_OFFSET + GPIOX_12)
+#define	PIN_GPIOX_13    (EE_OFFSET + GPIOX_13)
+#define	PIN_GPIOX_14    (EE_OFFSET + GPIOX_14)
+#define	PIN_GPIOX_15    (EE_OFFSET + GPIOX_15)
+#define	PIN_GPIOX_16    (EE_OFFSET + GPIOX_16)
+#define	PIN_GPIOX_17    (EE_OFFSET + GPIOX_17)
+#define	PIN_GPIOX_18    (EE_OFFSET + GPIOX_18)
+#define	PIN_GPIOX_19    (EE_OFFSET + GPIOX_19)
+#define	PIN_GPIOX_20    (EE_OFFSET + GPIOX_20)
+#define	PIN_GPIOX_21    (EE_OFFSET + GPIOX_21)
+#define	PIN_GPIOX_22    (EE_OFFSET + GPIOX_22)
+#define	PIN_GPIOCLK_0    (EE_OFFSET + GPIOCLK_0)
+#define	PIN_GPIOCLK_1    (EE_OFFSET + GPIOCLK_1)
+#define	PIN_GPIOCLK_2    (EE_OFFSET + GPIOCLK_2)
+#define	PIN_GPIOCLK_3    (EE_OFFSET + GPIOCLK_3)
+#define	PIN_GPIO_TEST_N    (EE_OFFSET + GPIO_TEST_N)
+#endif
diff --git a/arch/arm/include/asm/arch-gxb/i2c.h b/arch/arm/include/asm/arch-gxb/i2c.h
new file mode 100644
index 0000000..b0fa30a
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/i2c.h
@@ -0,0 +1,247 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/i2c.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __AML_MACH_I2C__
+#define __AML_MACH_I2C__
+
+#include <asm/io.h>
+
+/**
+ * struct i2c_msg - an I2C transaction segment beginning with START
+ * @addr: Slave address, either seven or ten bits.  When this is a ten
+ *	bit address, I2C_M_TEN must be set in @flags and the adapter
+ *	must support I2C_FUNC_10BIT_ADDR.
+ * @flags: I2C_M_RD is handled by all adapters.  No other flags may be
+ *	provided unless the adapter exported the relevant I2C_FUNC_*
+ *	flags through i2c_check_functionality().
+ * @len: Number of data bytes in @buf being read from or written to the
+ *	I2C slave address.  For read transactions where I2C_M_RECV_LEN
+ *	is set, the caller guarantees that this buffer can hold up to
+ *	32 bytes in addition to the initial length byte sent by the
+ *	slave (plus, if used, the SMBus PEC); and this value will be
+ *	incremented by the number of block data bytes received.
+ * @buf: The buffer into which data is read, or from which it's written.
+ *
+ * An i2c_msg is the low level representation of one segment of an I2C
+ * transaction.  It is visible to drivers in the @i2c_transfer() procedure,
+ * to userspace from i2c-dev, and to I2C adapter drivers through the
+ * @i2c_adapter.@master_xfer() method.
+ *
+ * Except when I2C "protocol mangling" is used, all I2C adapters implement
+ * the standard rules for I2C transactions.  Each transaction begins with a
+ * START.  That is followed by the slave address, and a bit encoding read
+ * versus write.  Then follow all the data bytes, possibly including a byte
+ * with SMBus PEC.  The transfer terminates with a NAK, or when all those
+ * bytes have been transferred and ACKed.  If this is the last message in a
+ * group, it is followed by a STOP.  Otherwise it is followed by the next
+ * @i2c_msg transaction segment, beginning with a (repeated) START.
+ *
+ * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then
+ * passing certain @flags may have changed those standard protocol behaviors.
+ * Those flags are only for use with broken/nonconforming slaves, and with
+ * adapters which are known to support the specific mangling options they
+ * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).
+ */
+struct i2c_msg {
+	__u16 addr;	/* slave address			*/
+	__u16 flags;
+#define I2C_M_TEN		0x0010	/* this is a ten bit chip address */
+#define I2C_M_RD		0x0001	/* read data, from slave to master */
+#define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
+	__u16 len;		/* msg length				*/
+	__u8 *buf;		/* pointer to msg data			*/
+};
+
+#define I2C_M_0_CONTROL_REG                        0x2140
+
+/*#define I2C_M_0_SLAVE_ADDR                         0x2141
+#define I2C_M_0_TOKEN_LIST0                        0x2142
+#define I2C_M_0_TOKEN_LIST1                        0x2143
+#define I2C_M_0_WDATA_REG0                         0x2144
+#define I2C_M_0_WDATA_REG1                         0x2145
+#define I2C_M_0_RDATA_REG0                         0x2146
+#define I2C_M_0_RDATA_REG1                         0x2147
+*/
+#define I2C_S_CONTROL_REG                          0x2150
+#define I2C_M_1_CONTROL_REG                        0x21f0
+#define I2C_M_2_CONTROL_REG 					   0x21f8
+#define I2C_M_3_CONTROL_REG                        0x2348
+
+#define MESON_I2C_MASTER_AO_START	(0xc8100500)
+#define MESON_I2C_MASTER_AO_END		(0xc810051c+5)
+
+#define MESON_I2C_MASTER_A_START	CBUS_REG_ADDR(I2C_M_0_CONTROL_REG)
+#define MESON_I2C_MASTER_A_END		(CBUS_REG_ADDR(I2C_M_0_RDATA_REG1+1)-1)
+
+#define MESON_I2C_MASTER_B_START	CBUS_REG_ADDR(I2C_M_1_CONTROL_REG)
+#define MESON_I2C_MASTER_B_END		(CBUS_REG_ADDR(I2C_M_1_RDATA_REG1+1)-1)
+
+#define MESON_I2C_MASTER_C_START	CBUS_REG_ADDR(I2C_M_2_CONTROL_REG)
+#define MESON_I2C_MASTER_C_END		(CBUS_REG_ADDR(I2C_M_2_RDATA_REG1+1)-1)
+
+#define MESON_I2C_MASTER_D_START	CBUS_REG_ADDR(I2C_M_3_CONTROL_REG)
+#define MESON_I2C_MASTER_D_END		(CBUS_REG_ADDR(I2C_M_3_RDATA_REG1+1)-1)
+
+#define MESON_I2C_SLAVE_START		CBUS_REG_ADDR(I2C_S_CONTROL_REG)
+#define MESON_I2C_SLAVE_END			(CBUS_REG_ADDR(I2C_S_CNTL1_REG+1)-1)
+
+
+#define AML_I2C_MASTER_AO			0
+#define AML_I2C_MASTER_A			1
+#define AML_I2C_MASTER_B 			2
+#define AML_I2C_MASTER_C 			3
+#define AML_I2C_MASTER_D 			4
+
+
+#define AML_I2C_SLAVE_ADDR			0x6c
+
+/*M1 i2c pinmux
+ *       I/O			I2C_MASTER_A		I2C_MASTER_B		I2C_SLAVE
+ * GPIO_JTAG_TMS	SCK_A REG1[12]							SCK_A REG1[13]
+ * GPIO_JTAG_TDI		SDA_A REG1[12]							SDA_A REG1[13]
+ * GPIO_JTAG_TCK						SCK_B REG1[16]		SCK_A REG1[17]
+ * GPIO_JTAG_TDO						SDA_B REG1[20]		SDA_A REG1[21]
+ * GPIOB_0								SCK_B REG2[5]		SCK_A REG2[6]
+ * GPIOB_1								SDA_B REG2[2]		SDA_A REG2[3]
+ * GPIOB_2			SCK_A REGS[13]							SCK_A REG2[14]
+ * GPIOB_3			SDA_A REG2[9]							SDA_A REG2[10]
+ * GPIOC_13								SCK_B REG3[28]		SCK_A REG3[29]
+ * GPIOC_14								SDA_B REG3[25]		SDA_A REG3[26]
+ * GPIOC_21			SCK_A REG7[9]							SCK_A REG7[10]
+ * GPIOC_22			SDA_A REG7[6]							SDA_A REG7[7]
+ * GPIOE_16								SCK_B REG5[27]		SCK_A REG5[28]
+ * GPIOE_17								SDA_B REG5[25]		SDA_A REG5[26]
+*/
+
+/*i2c master a*/
+#define MESON_I2C_MASTER_A_GPIODV_24_REG		(P_PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_A_GPIODV_24_BIT		(1<<27)
+#define MESON_I2C_MASTER_A_GPIODV_25_REG		(P_PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_A_GPIODV_25_BIT		(1<<26)
+/*i2c master b*/
+#define MESON_I2C_MASTER_B_GPIODV_26_REG		(P_PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_B_GPIODV_26_BIT		(1<<25)
+#define MESON_I2C_MASTER_B_GPIODV_27_REG		(P_PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_B_GPIODV_27_BIT		(1<<24)
+ /*i2c master c*/
+#define MESON_I2C_MASTER_C_GPIODV_28_REG		(P_PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_C_GPIODV_28_BIT		(1<<23)
+#define MESON_I2C_MASTER_C_GPIODV_29_REG		(P_PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_C_GPIODV_29_BIT		(1<<22)
+
+/*i2c master d*/
+#define MESON_I2C_MASTER_D_GPIOX_16_REG			(PERIPHS_PIN_MUX_4)
+#define MESON_I2C_MASTER_D_GPIOX_16_BIT			(1<<3)
+#define MESON_I2C_MASTER_D_GPIOX_17_REG			(PERIPHS_PIN_MUX_4)
+#define MESON_I2C_MASTER_D_GPIOX_17_BIT			(1<<2)
+
+/*i2c master AO*/
+#define MESON_I2C_MASTER_AO_GPIOAO_4_REG	(P_AO_RTI_PIN_MUX_REG)
+#define MESON_I2C_MASTER_AO_GPIOAO_4_BIT	(1<<6)
+#define MESON_I2C_MASTER_AO_GPIOAO_5_REG	(P_AO_RTI_PIN_MUX_REG)
+#define MESON_I2C_MASTER_AO_GPIOAO_5_BIT	(1<<5)
+
+/*i2c slave*/
+
+
+
+#define AML_I2C_SPPED_50K			50000
+#define AML_I2C_SPPED_100K			100000
+#define AML_I2C_SPPED_200K			200000
+#define AML_I2C_SPPED_300K			300000
+#define AML_I2C_SPPED_400K			400000
+
+struct aml_pinmux_reg_bit {
+	unsigned long	scl_reg;
+	unsigned long	sda_reg;
+	unsigned int  scl_bit;
+	unsigned int  sda_bit;
+};
+
+struct aml_i2c_platform{
+	unsigned int		slave_addr;/*7bit addr*/
+	unsigned int 		wait_count;/*i2c wait ack timeout =
+											wait_count * wait_ack_interval */
+	unsigned int 		wait_ack_interval;
+	unsigned int 		wait_read_interval;
+	unsigned int 		wait_xfer_interval;
+	unsigned int 		master_no;
+	unsigned int		use_pio;/*0: hardware i2c, 1: manual pio i2c*/
+	unsigned int		master_i2c_speed;
+
+	/* only need 1 i2c master to comunicate with several devices,
+	  * should I prepare 2 master interface to use simultaneously?*/
+	struct resource	* resource;
+	struct aml_pinmux_reg_bit master_ao_pinmux;
+	struct aml_pinmux_reg_bit master_a_pinmux;
+	struct aml_pinmux_reg_bit master_b_pinmux;
+	struct aml_pinmux_reg_bit master_c_pinmux;
+	struct aml_pinmux_reg_bit master_d_pinmux;
+
+	struct aml_pinmux_reg_bit slave_reg_bit;
+};
+
+/**************i2c software gpio***************/
+
+#define MESON_I2C_PREG_GPIOC_OE			CBUS_REG_ADDR(PREG_FGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOC_OUTLVL		CBUS_REG_ADDR(PREG_FGPIO_O)
+#define MESON_I2C_PREG_GPIOC_INLVL		CBUS_REG_ADDR(PREG_FGPIO_I)
+
+#define MESON_I2C_PREG_GPIOE_OE			CBUS_REG_ADDR(PREG_HGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOE_OUTLVL		CBUS_REG_ADDR(PREG_HGPIO_O)
+#define MESON_I2C_PREG_GPIOE_INLVL		CBUS_REG_ADDR(PREG_HGPIO_I)
+
+#define MESON_I2C_PREG_GPIOA_OE			CBUS_REG_ADDR(PREG_EGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOA_OUTLVL		CBUS_REG_ADDR(PREG_EGPIO_O)
+#define MESON_I2C_PREG_GPIOA_INLVL		CBUS_REG_ADDR(PREG_EGPIO_I)
+
+struct aml_sw_i2c_pins
+{
+	unsigned int scl_reg_out;
+	unsigned int scl_reg_in;
+	unsigned int scl_bit;
+	unsigned int scl_oe;
+	unsigned int sda_reg_out;
+	unsigned int sda_reg_in;
+	unsigned int sda_bit;
+	unsigned int sda_oe;
+};
+
+
+struct aml_sw_i2c_platform {
+	struct aml_sw_i2c_pins sw_pins;
+
+	/* local settings */
+	int udelay;		/* half clock cycle time in us,
+				   minimum 2 us for fast-mode I2C,
+				   minimum 5 us for standard-mode I2C and SMBus,
+				   maximum 50 us for SMBus */
+	int timeout;		/* in jiffies */
+};
+
+
+#endif //__AML_MACH_I2C__
+
+
diff --git a/arch/arm/include/asm/arch-gxb/io.h b/arch/arm/include/asm/arch-gxb/io.h
new file mode 100644
index 0000000..105821e
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/io.h
@@ -0,0 +1,124 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/io.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __MACH_MESSON_REGS_IO_H
+#define __MACH_MESSON_REGS_IO_H
+
+#ifndef __ASSEMBLY__
+
+#include <asm/io.h>
+#define IO_CBUS_BASE			0xc1100000L
+#define IO_AXI_BUS_BASE			0xc1300000L
+#define IO_AHB_BUS_BASE			0xc9000000L
+#define IO_APB_BUS_BASE			0xc8000000L
+#define IO_APB_HDMI_BUS_BASE    0xd0040000L
+#define IO_VPU_BUS_BASE			0xd0100000L
+
+#define MESON_PERIPHS1_VIRT_BASE	0xc1108400L
+#define MESON_PERIPHS1_PHYS_BASE	0xc1108400L
+
+#define MESON_PERIPHS1_VIRT_BASE	0xc1108400L
+#define MESON_PERIPHS1_PHYS_BASE	0xc1108400L
+
+#define CBUS_REG_OFFSET(reg) ((reg) << 2)
+#define CBUS_REG_ADDR(reg)	 (IO_CBUS_BASE + CBUS_REG_OFFSET(reg))
+
+#define AXI_REG_OFFSET(reg)  ((reg) << 2)
+#define AXI_REG_ADDR(reg)	 (IO_AXI_BUS_BASE + AXI_REG_OFFSET(reg))
+
+#define AHB_REG_OFFSET(reg)  ((reg) << 2)
+#define AHB_REG_ADDR(reg)	 (IO_AHB_BUS_BASE + AHB_REG_OFFSET(reg))
+
+#define VPU_REG_OFFSET(reg)  ((reg) << 2)
+#define VPU_REG_ADDR(reg)	 (IO_VPU_BUS_BASE + VPU_REG_OFFSET(reg))
+
+
+#define APB_REG_OFFSET(reg)  (reg)
+#define APB_REG_ADDR(reg)	 (IO_APB_BUS_BASE + APB_REG_OFFSET(reg))
+#define APB_REG_ADDR_VALID(reg) (((unsigned long)(reg) & 3) == 0)
+
+#define APB_HDMI_REG_OFFSET(reg)  (reg)
+#define APB_HDMI_REG_ADDR(reg)	 (IO_APB_HDMI_BUS_BASE + APB_HDMI_REG_OFFSET(reg))
+#define APB_HDMI_REG_ADDR_VALID(reg) (((unsigned long)(reg) & 3) == 0)
+
+
+#define WRITE_CBUS_REG(reg, val) __raw_writel(val, CBUS_REG_ADDR(reg))
+#define READ_CBUS_REG(reg) (__raw_readl(CBUS_REG_ADDR(reg)))
+#define WRITE_CBUS_REG_BITS(reg, val, start, len) \
+    WRITE_CBUS_REG(reg,	(READ_CBUS_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_CBUS_REG_BITS(reg, start, len) \
+    ((READ_CBUS_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_CBUS_REG_MASK(reg, mask) WRITE_CBUS_REG(reg, (READ_CBUS_REG(reg)&(~(mask))))
+#define SET_CBUS_REG_MASK(reg, mask)   WRITE_CBUS_REG(reg, (READ_CBUS_REG(reg)|(mask)))
+
+#define WRITE_AXI_REG(reg, val) __raw_writel(val, AXI_REG_ADDR(reg))
+#define READ_AXI_REG(reg) (__raw_readl(AXI_REG_ADDR(reg)))
+#define WRITE_AXI_REG_BITS(reg, val, start, len) \
+    WRITE_AXI_REG(reg,	(READ_AXI_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_AXI_REG_BITS(reg, start, len) \
+    ((READ_AXI_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_AXI_REG_MASK(reg, mask) WRITE_AXI_REG(reg, (READ_AXI_REG(reg)&(~(mask))))
+#define SET_AXI_REG_MASK(reg, mask)   WRITE_AXI_REG(reg, (READ_AXI_REG(reg)|(mask)))
+
+#define WRITE_AHB_REG(reg, val) __raw_writel(val, AHB_REG_ADDR(reg))
+#define READ_AHB_REG(reg) (__raw_readl(AHB_REG_ADDR(reg)))
+#define WRITE_AHB_REG_BITS(reg, val, start, len) \
+    WRITE_AHB_REG(reg,	(READ_AHB_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_AHB_REG_BITS(reg, start, len) \
+    ((READ_AHB_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_AHB_REG_MASK(reg, mask) WRITE_AHB_REG(reg, (READ_AHB_REG(reg)&(~(mask))))
+#define SET_AHB_REG_MASK(reg, mask)   WRITE_AHB_REG(reg, (READ_AHB_REG(reg)|(mask)))
+
+#define WRITE_APB_REG(reg, val) __raw_writel(val, APB_REG_ADDR(reg))
+#define READ_APB_REG(reg) (__raw_readl(APB_REG_ADDR(reg)))
+#define WRITE_APB_REG_BITS(reg, val, start, len) \
+    WRITE_APB_REG(reg,	(READ_APB_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_APB_REG_BITS(reg, start, len) \
+    ((READ_APB_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_APB_REG_MASK(reg, mask) WRITE_APB_REG(reg, (READ_APB_REG(reg)&(~(mask))))
+#define SET_APB_REG_MASK(reg, mask)   WRITE_APB_REG(reg, (READ_APB_REG(reg)|(mask)))
+
+#define WRITE_APB_HDMI_REG(reg, val) __raw_writel(val, APB_HDMI_REG_ADDR(reg))
+#define READ_APB_HDMI_REG(reg) (__raw_readl(APB_HDMI_REG_ADDR(reg)))
+#define WRITE_APB_HDMI_REG_BITS(reg, val, start, len) \
+    WRITE_APB_HDMI_REG(reg,	(READ_APB_HDMI_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_APB_HDMI_REG_BITS(reg, start, len) \
+    ((READ_APB_HDMI_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_APB_HDMI_REG_MASK(reg, mask) WRITE_APB_HDMI_REG(reg, (READ_APB_HDMI_REG(reg)&(~(mask))))
+#define SET_APB_HDMI_REG_MASK(reg, mask)   WRITE_APB_HDMI_REG(reg, (READ_APB_HDMI_REG(reg)|(mask)))
+
+/* for back compatible alias */
+#define WRITE_MPEG_REG(reg, val) \
+	WRITE_CBUS_REG(reg, val)
+#define READ_MPEG_REG(reg) \
+	READ_CBUS_REG(reg)
+#define WRITE_MPEG_REG_BITS(reg, val, start, len) \
+	WRITE_CBUS_REG_BITS(reg, val, start, len)
+#define READ_MPEG_REG_BITS(reg, start, len) \
+	READ_CBUS_REG_BITS(reg, start, len)
+#define CLEAR_MPEG_REG_MASK(reg, mask) \
+	CLEAR_CBUS_REG_MASK(reg, mask)
+#define SET_MPEG_REG_MASK(reg, mask) \
+	SET_CBUS_REG_MASK(reg, mask)
+#endif
+
+
+#endif
diff --git a/arch/arm/include/asm/arch-gxb/mailbox.h b/arch/arm/include/asm/arch-gxb/mailbox.h
new file mode 100644
index 0000000..7bf982e
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/mailbox.h
@@ -0,0 +1,55 @@
+/*
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+ /*
+  *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *
+ */
+
+#ifndef __GXBB_MAILBOX_H_
+#define __GXBB_MAILBOX_H_
+
+#define SCPI_CMD_SENSOR_VALUE 0x1C
+#define SCPI_CMD_OPEN_SCP_LOG 0xC4
+#define SCPI_CMD_THERMAL_CALIB 0xC5
+
+#define LOW_PRIORITY	0
+#define HIGH_PRIORITY 1
+
+#define P_SHARE_SRAM_BASE    0xc8000000
+#define MHU_HIGH_SCP_TO_AP_PAYLOAD		0x13400
+#define MHU_HIGH_AP_TO_SCP_PAYLOAD		0x13600
+#define MHU_LOW_SCP_TO_AP_PAYLOAD		0x13000
+#define MHU_LOW_AP_TO_SCP_PAYLOAD		0x13200
+
+enum scpi_error_codes {
+	SCPI_SUCCESS = 0, /* Success */
+	SCPI_ERR_PARAM = 1, /* Invalid parameter(s) */
+	SCPI_ERR_ALIGN = 2, /* Invalid alignment */
+	SCPI_ERR_SIZE = 3, /* Invalid size */
+	SCPI_ERR_HANDLER = 4, /* Invalid handler/callback */
+	SCPI_ERR_ACCESS = 5, /* Invalid access/permission denied */
+	SCPI_ERR_RANGE = 6, /* Value out of range */
+	SCPI_ERR_TIMEOUT = 7, /* Timeout has occurred */
+	SCPI_ERR_NOMEM = 8, /* Invalid memory area or pointer */
+	SCPI_ERR_PWRSTATE = 9, /* Invalid power state */
+	SCPI_ERR_SUPPORT = 10, /* Not supported or disabled */
+	SCPI_ERR_DEVICE = 11, /* Device error */
+	SCPI_ERR_MAX
+};
+
+void open_scp_log(void);
+int thermal_calibration(unsigned int type, unsigned int data);
+int thermal_get_value(unsigned int sensor_id, unsigned int *value);
+
+ #endif
diff --git a/arch/arm/include/asm/arch-gxb/nand.h b/arch/arm/include/asm/arch-gxb/nand.h
new file mode 100644
index 0000000..c1762df
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/nand.h
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * NAND controller register define
+ */
+
+#ifndef __NAND_H__
+#define __NAND_H__
+#include <asm/arch/cpu_config.h>
+
+#ifndef SD_EMMC_BASE_C
+#define SD_EMMC_BASE_C 0xd0074000
+#endif
+
+#define P_NAND_BASE (SD_EMMC_BASE_C | (1<<11))
+#define P_CLK_CNTL	(volatile uint32_t *)(SD_EMMC_BASE_C)
+#define P_NAND_CMD  (volatile uint32_t *)(P_NAND_BASE + 0x00)
+#define P_NAND_CFG  (volatile uint32_t *)(P_NAND_BASE + 0x04)
+#define P_NAND_DADR (volatile uint32_t *)(P_NAND_BASE + 0x08)
+#define P_NAND_IADR (volatile uint32_t *)(P_NAND_BASE + 0x0c)
+#define P_NAND_BUF  (volatile uint32_t *)(P_NAND_BASE + 0x10)
+#define P_NAND_INFO (volatile uint32_t *)(P_NAND_BASE + 0x14)
+#define P_NAND_DC   (volatile uint32_t *)(P_NAND_BASE + 0x18)
+#define P_NAND_ADR  (volatile uint32_t *)(P_NAND_BASE + 0x1c)
+#define P_NAND_DL   (volatile uint32_t *)(P_NAND_BASE + 0x20)
+#define P_NAND_DH   (volatile uint32_t *)(P_NAND_BASE + 0x24)
+#define P_NAND_CADR (volatile uint32_t *)(P_NAND_BASE + 0x28)
+#define P_NAND_SADR (volatile uint32_t *)(P_NAND_BASE + 0x2c)
+
+#define CEF (0xf<<10)
+#define CE0 (0xe<<10)
+#define CE1 (0xd<<10)
+#define CE2 (0xb<<10)
+#define CE3 (0x7<<10)
+
+#define IO4 ((0xe<<10)|(1<<18))
+#define IO5 ((0xd<<10)|(1<<18))
+#define IO6 ((0xb<<10)|(1<<18))
+
+#define CLE  (0x5<<14)
+#define ALE  (0x6<<14)
+#define DWR  (0x4<<14)
+#define DRD  (0x8<<14)
+#define IDLE (0xc<<14)
+#define RB   (1<<20)
+
+#define M2N  ((0<<17) | (2<<20) | (1<<19))
+#define N2M  ((1<<17) | (2<<20) | (1<<19))
+#define STS  ((3<<17) | (2<<20))
+#define ADL  ((0<<16) | (3<<20))
+#define ADH  ((1<<16) | (3<<20))
+#define AIL  ((2<<16) | (3<<20))
+#define AIH  ((3<<16) | (3<<20))
+#define ASL  ((4<<16) | (3<<20))
+#define ASH  ((5<<16) | (3<<20))
+#define SEED ((8<<16) | (3<<20))
+
+// NAND Flash Manufacturer ID Codes
+#define NAND_MFR_TOSHIBA	0x98
+#define NAND_MFR_SAMSUNG	0xec
+#define NAND_MFR_FUJITSU	0x04
+#define NAND_MFR_NATIONAL	0x8f
+#define NAND_MFR_RENESAS	0x07
+#define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX		0xad
+#define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
+#define NAND_MFR_INTEL		0x89
+#define NAND_MFR_SANDISK    	0x45
+#define NAND_MFR_USER          0x100
+#define NAND_MFR_EFUSE         0x101
+
+typedef struct nand_setup {
+    union {
+        uint32_t d32;
+        struct {
+            unsigned cmd:22;
+            unsigned large_page:1; // 22
+            unsigned no_rb:1;      // 23 from efuse
+            unsigned a2:1;         // 24
+            unsigned reserved25:1; // 25
+            unsigned page_list:1;  // 26
+            unsigned sync_mode:2;  // 27 from efuse
+            unsigned size:2;       // 29 from efuse
+            unsigned active:1;     // 31
+        } b;
+    } cfg;
+    uint16_t id;
+    uint16_t max; // id:0x100 user, max:0 disable.
+} nand_setup_t;
+
+typedef struct _nand_cmd{
+    unsigned char type;
+    unsigned char val;
+} nand_cmd_t;
+
+typedef struct _ext_info{
+	uint32_t read_info;		//nand_read_info;
+	uint32_t new_type;		//new_nand_type;
+	uint32_t page_per_blk;	//pages_in_block;
+	uint32_t xlc;			//slc=1, mlc=2, tlc=3.
+	uint32_t rsv1[5];
+} ext_info_t;
+
+typedef struct _nand_page0 {
+	nand_setup_t nand_setup;		//8
+	unsigned char page_list[16]; 	//16
+	nand_cmd_t retry_usr[32];		//64 (32 cmd max I/F)
+	ext_info_t ext_info;			//64
+} nand_page0_t;	//384 bytes max.
+
+//#define NAND_PAGE0_BUF	  BL1_NAND_BUFF
+#define NAND_PAGE0_BUF  (0x1800000)
+#define NAND_PAGE_LIST	  (NAND_PAGE0_BUF + sizeof(nand_setup_t))
+#define NAND_RETRY_USER	  (NAND_PAGE_LIST + 16)
+#define NAND_INFO_BUF     (NAND_PAGE0_BUF + 512)
+#define DEFAULT_ECC_MODE  ((1<<23) |(1<<22) | (2<<20) |(1<<19) |(1<<17)|(7<<14)|(1<<13)|(48<<6)|1)
+//#define DEFAULT_ECC_MODE  ((1<<23) |(1<<22) | (2<<20) |(1<<19) |(1<<17)|(7<<14)|(1<<13)|(48<<6)|1)
+
+#define ERROR_MOD(mod,num) ((uint32_t)(((mod<<6)|num)))
+#define ERROR_NAND_TIMEOUT          ERROR_MOD(2,1)      //
+#define ERROR_NAND_ECC              ERROR_MOD(2,2)      //
+#define ERROR_NAND_MAGIC_WORD       ERROR_MOD(2,3)      //
+#define ERROR_NAND_INIT_READ        ERROR_MOD(2,4)      //
+#define ERROR_NAND_BLANK_PAGE       ERROR_MOD(2,5)      //
+#define ERROR_NAND_UNALIGN_SRC      ERROR_MOD(2,6)      //
+
+#define NAND_SECTOR_SIZE		(512)
+#define NAND_MAX_PAGESIZE		(0x4000)	//16K
+#define SRC_ALIGN_SIZE			(NAND_MAX_PAGESIZE)
+
+#define INFO_BYTE_PER_ECCPAGE	(8)
+uint32_t nfio_init(void);
+uint32_t nf_read(uint32_t boot_device, uint32_t src, uint32_t des, uint32_t size);
+#endif /* __NAND_H__ */
+
diff --git a/arch/arm/include/asm/arch-gxb/reboot.h b/arch/arm/include/asm/arch-gxb/reboot.h
new file mode 100644
index 0000000..0775fee
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/reboot.h
@@ -0,0 +1,58 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/reboot.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __REBOOT_H
+#define __REBOOT_H
+
+/*
+Reboot reason AND corresponding env setting:
+0:  Cold boot                 cold_boot
+1:  Normal boot               normal
+2:  Factory reset             factory_reset
+3:  Upgrade system            update
+4:  USB Burning               usb_burning
+5:  Suspend                   suspend_off
+6:  Hibernate                 hibernate
+7~10: reserved
+11:  Crash dump               crash_dump
+12~15: reserved
+*/
+#define AMLOGIC_COLD_BOOT				0
+#define	AMLOGIC_NORMAL_BOOT				1
+#define	AMLOGIC_FACTORY_RESET_REBOOT	2
+#define	AMLOGIC_UPDATE_REBOOT			3
+#define AMLOGIC_USB_BURNING_REBOOT		4
+#define AMLOGIC_SUSPEND_REBOOT			5
+#define AMLOGIC_HIBERNATE_REBOOT		6
+#define	AMLOGIC_CRASH_REBOOT			11
+#define AMLOGIC_KERNEL_PANIC			12
+
+/*
+old version env
+0x01010101, normal
+0x02020202, factory_reset
+0x03030303, update
+0x09090909, usb_burning
+0x0b0b0b0b, suspend_off
+*/
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-gxb/register.h b/arch/arm/include/asm/arch-gxb/register.h
new file mode 100644
index 0000000..a67486b
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/register.h
@@ -0,0 +1,99 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/register.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __REGISTER_H__
+#define __REGISTER_H__
+
+#define IO_CBUS_BASE			  0xc1100000
+#define IO_AXI_BUS_BASE			0xc1300000
+#define IO_AHB_BUS_BASE			0xc9000000
+#define IO_APB_BUS_BASE			0xc8000000
+#define IO_APB_HDMI_BUS_BASE    0xd0040000
+#define IO_VPU_BUS_BASE			0xd0100000
+
+#define CBUS_REG_OFFSET(reg) ((reg) << 2)
+#define CBUS_REG_ADDR(reg)	 (IO_CBUS_BASE + CBUS_REG_OFFSET(reg))
+
+/* below UART0,UART1,AO_UART is m8 addr,it is placed is for compiling pass */
+/* -------------------------------
+// UART0
+// ---------------------------- */
+#define UART0_WFIFO                                0x2130
+#define UART0_RFIFO                                0x2131
+#define UART0_CONTROL                              0x2132
+#define UART0_STATUS                               0x2133
+#define UART0_MISC                                 0x2134
+#define UART0_REG5                                 0x2135
+/* ----------------------------
+// UART1
+----------------------------*/
+#define UART1_WFIFO                                0x2137
+#define UART1_RFIFO                                0x2138
+#define UART1_CONTROL                              0x2139
+#define UART1_STATUS                               0x213a
+#define UART1_MISC                                 0x213b
+#define UART1_REG5                                 0x213c
+
+
+/* ------------------------------------------------------
+ The following are handled by $periphs/rtl/periphs_reg.v
+  ----------------------------------------              */
+#define PREG_CTLREG0_ADDR                          0x2000
+#define P_PREG_CTLREG0_ADDR CBUS_REG_ADDR(PREG_CTLREG0_ADDR)
+
+
+/* ----------------------------
+ clock measure (4)
+ ---------------------------- */
+#define MSR_CLK_DUTY                               0x21d6
+#define MSR_CLK_REG0                               0x21d7
+#define MSR_CLK_REG1                               0x21d8
+#define MSR_CLK_REG2                               0x21d9
+#define P_MSR_CLK_DUTY CBUS_REG_ADDR(MSR_CLK_DUTY)
+#define P_MSR_CLK_REG0 CBUS_REG_ADDR(MSR_CLK_REG0)
+#define P_MSR_CLK_REG1 CBUS_REG_ADDR(MSR_CLK_REG1)
+#define P_MSR_CLK_REG2 CBUS_REG_ADDR(MSR_CLK_REG2)
+
+
+
+/* --------------------------------
+ *  AO uart
+ * -------------------------------*/
+#define IO_AOBUS_BASE       0xc8100000  ///1M
+
+#define AOBUS_REG_OFFSET(reg)   ((reg) )
+#define AOBUS_REG_ADDR(reg)	    (IO_AOBUS_BASE + AOBUS_REG_OFFSET(reg))
+
+#define AO_UART_WFIFO ((0x01 << 10) | (0x30 << 2)) 	///../ucode/c_always_on_pointer.h:89
+#define P_AO_UART_WFIFO 		AOBUS_REG_ADDR(AO_UART_WFIFO)
+#define AO_UART_RFIFO ((0x01 << 10) | (0x31 << 2)) 	///../ucode/c_always_on_pointer.h:90
+#define P_AO_UART_RFIFO 		AOBUS_REG_ADDR(AO_UART_RFIFO)
+#define AO_UART_CONTROL ((0x01 << 10) | (0x32 << 2)) 	///../ucode/c_always_on_pointer.h:91
+#define P_AO_UART_CONTROL 		AOBUS_REG_ADDR(AO_UART_CONTROL)
+#define AO_UART_STATUS ((0x01 << 10) | (0x33 << 2)) 	///../ucode/c_always_on_pointer.h:92
+#define P_AO_UART_STATUS 		AOBUS_REG_ADDR(AO_UART_STATUS)
+#define AO_UART_MISC ((0x01 << 10) | (0x34 << 2)) 	///../ucode/c_always_on_pointer.h:93
+#define P_AO_UART_MISC 		AOBUS_REG_ADDR(AO_UART_MISC)
+#define AO_UART_REG5 ((0x01 << 10) | (0x35 << 2)) 	///../ucode/c_always_on_pointer.h:94
+#define P_AO_UART_REG5 		AOBUS_REG_ADDR(AO_UART_REG5)
+
+
+#endif //__REGISTER_H__
diff --git a/arch/arm/include/asm/arch-gxb/romboot.h b/arch/arm/include/asm/arch-gxb/romboot.h
new file mode 100644
index 0000000..3679586
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/romboot.h
@@ -0,0 +1,67 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/romboot.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __BOOT_ROM_H_
+#define __BOOT_ROM_H_
+#ifndef __ASSEMBLY__
+//#include <stdint.h>
+//uint8_t simple_i2c(uint8_t adr);
+//void spi_pin_mux(void);
+//void spi_init(void);
+//uint32_t spi_read(uint32_t src, uint32_t mem, uint32_t size);
+//void udelay(uint32_t usec);
+//void boot_des_decrypt(uint8_t *ct, uint8_t *pt, uint32_t size);
+
+#endif /* ! __ASSEMBLY__ */
+#include "config.h"
+
+/* Magic number to "boot" up A53 */
+#define AO_SEC_SD_CFG10_CB			0x80000000
+
+/*BOOT device and ddr size*/
+/*31-28: boot device id, 27-24: boot device para, 23-20: reserved*/
+/*19-8: ddr size, 7-0: board revision*/
+//#define P_AO_SEC_GP_CFG0                                     0xDA100240 //defined in secure_apb.h
+#define AO_SEC_GP_CFG7_W0_BIT			8
+#define AO_SEC_GP_CFG7_W0			0x100
+
+#define P_ISA_TIMERE                 (volatile uint32_t *)0xc1109988
+#define P_ASSIST_POR_CONFIG          (volatile uint32_t *)0xc1107d54
+
+#define P_RESET1_REGISTER	     (volatile uint32_t *)0xc1104408
+
+#define P_WATCHDOG_CNTL              (volatile uint32_t *)0xc11098d0
+#define P_WATCHDOG_CNTL1             (volatile uint32_t *)0xc11098d4
+#define P_WATCHDOG_TCNT              (volatile uint32_t *)0xc11098d8
+#define P_WATCHDOG_RESET             (volatile uint32_t *)0xc11098dc
+
+#define P_SPI_FLASH_CTRL             (volatile uint32_t *)0xc1108c88
+#define P_SPI_USER_REG               (volatile uint32_t *)0xc1108c9c
+#define P_SPI_START_ADDR             (volatile uint32_t *)0xCC000000
+
+#define BOOT_ID_RESERVED	0
+#define BOOT_ID_EMMC		1
+#define BOOT_ID_NAND		2
+#define BOOT_ID_SPI		3
+#define BOOT_ID_SDCARD		4
+#define BOOT_ID_USB		5
+
+#endif /* __BOOT_ROM_H_ */
diff --git a/arch/arm/include/asm/arch-gxb/sd_emmc.h b/arch/arm/include/asm/arch-gxb/sd_emmc.h
new file mode 100644
index 0000000..fc6d0d1
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/sd_emmc.h
@@ -0,0 +1,175 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/sd_emmc.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __SD_EMMC_H__
+#define __SD_EMMC_H__
+
+#include "cpu_sdio.h"
+
+#define SD_EMMC_BASE_A 0xd0070000
+#define SD_EMMC_BASE_B 0xd0072000
+#define SD_EMMC_BASE_C 0xd0074000
+
+#define NEWSD_IRQ_ALL				    0x3fff
+
+#define SD_EMMC_CLKSRC_24M 	24000000
+#define SD_EMMC_CLKSRC_DIV2	1000000000
+
+#define NEWSD_IRQ_EN_ALL_INIT
+#define NEWSD_MAX_DESC_MUN					512
+#define NEWSD_BOUNCE_REQ_SIZE		(512*1024)
+#define MAX_BLOCK_COUNTS	256
+#define SD_EMMC_CLKSRC 24000000
+
+#define MMC_RSP_136_NUM					4
+#define MAX_RESPONSE_BYTES     4
+
+#define RESPONSE_R1_R3_R6_R7_LENGTH     6
+#define RESPONSE_R2_CID_CSD_LENGTH      17
+#define RESPONSE_R4_R5_NONE_LENGTH      0
+
+#define SDIO_PORT_A    0
+#define SDIO_PORT_B    1
+#define SDIO_PORT_C    2
+
+#define CARD_SD_SDIO_INIT          (1<<0)
+#define CARD_SD_SDIO_DETECT        (1<<1)
+#define CARD_SD_SDIO_PWR_PREPARE   (1<<2)
+#define CARD_SD_SDIO_PWR_ON        (1<<3)
+#define CARD_SD_SDIO_PWR_OFF       (1<<4)
+
+typedef enum _SD_Error_Status_t {
+	SD_NO_ERROR                 = 0,
+	SD_ERROR_OUT_OF_RANGE,                  //Bit 31
+	SD_ERROR_ADDRESS,                       //Bit 30
+	SD_ERROR_BLOCK_LEN,                     //Bit 29
+	SD_ERROR_ERASE_SEQ,                     //Bit 28
+	SD_ERROR_ERASE_PARAM,                   //Bit 27
+	SD_ERROR_WP_VIOLATION,                  //Bit 26
+	SD_ERROR_CARD_IS_LOCKED,                    //Bit 25
+	SD_ERROR_LOCK_UNLOCK_FAILED,                //Bit 24
+	SD_ERROR_COM_CRC,                       //Bit 23
+	SD_ERROR_ILLEGAL_COMMAND,               //Bit 22
+	SD_ERROR_CARD_ECC_FAILED,                   //Bit 21
+	SD_ERROR_CC,                                //Bit 20
+	SD_ERROR_GENERAL,                       //Bit 19
+	SD_ERROR_Reserved1,                         //Bit 18
+	SD_ERROR_Reserved2,                         //Bit 17
+	SD_ERROR_CID_CSD_OVERWRITE,             //Bit 16
+	SD_ERROR_AKE_SEQ,                           //Bit 03
+	SD_ERROR_STATE_MISMATCH,
+	SD_ERROR_HEADER_MISMATCH,
+	SD_ERROR_DATA_CRC,
+	SD_ERROR_TIMEOUT,
+	SD_ERROR_DRIVER_FAILURE,
+	SD_ERROR_WRITE_PROTECTED,
+	SD_ERROR_NO_MEMORY,
+	SD_ERROR_SWITCH_FUNCTION_COMUNICATION,
+	SD_ERROR_NO_FUNCTION_SWITCH,
+	SD_ERROR_NO_CARD_INS
+} SD_Error_Status_t;
+
+
+typedef enum _SD_Bus_Width
+{
+	SD_BUS_SINGLE                   = 1,        //only DAT0
+	SD_BUS_WIDE                     = 4         //use DAT0-4
+} SD_Bus_Width_t;
+
+//LSB -> MSB, structrue for SD Card Status
+typedef struct _SD_Card_Status
+{
+	unsigned Reserved3: 2;
+	unsigned Reserved4: 1;
+	unsigned AKE_SEQ_ERROR: 1;                  //Error in the sequence of authentication process.
+	unsigned Reserved5: 1;
+	unsigned APP_CMD: 1;                        //The card will expect ACMD, or indication that the command has been interpreted as ACMD.
+	unsigned NotUsed: 2;
+
+	unsigned READY_FOR_DATA: 1;                 //Corresponds to buffer empty signalling on the bus.
+	unsigned CURRENT_STATE: 4;                  //The state of the card when receiving the command.
+	unsigned ERASE_RESET: 1;                    //An erase sequence was cleared beforem executing because an out of erase sequence command was received.
+	unsigned CARD_ECC_DISABLED: 1;              //The command has been executed without using the internal ECC.
+	unsigned WP_ERASE_SKIP: 1;                  //Only partial address space was erased due to existing write protected blocks.
+
+	unsigned CID_CSD_OVERWRITE: 1;              //Can be either one of the following errors:
+	unsigned Reserved1: 1;
+	unsigned Reserved2: 1;
+	unsigned ERROR: 1;                          //A general or an unknown error occurred during the operation.
+	unsigned CC_ERROR: 1;                       //Internal card controller error
+	unsigned CARD_ECC_FAILED: 1;                //Card internal ECC was applied but failed to correct the data.
+	unsigned ILLEGAL_COMMAND: 1;                //Command not legal for the card state
+	unsigned COM_CRC_ERROR: 1;                  //The CRC check of the previous command failed.
+
+	unsigned LOCK_UNLOCK_FAILED: 1;             //Set when a sequence or password error has been detected in lock/ unlock card command or if there was an attempt to access a locked card
+
+	unsigned CARD_IS_LOCKED: 1;                 //When set, signals that the card is locked by the host
+	unsigned WP_VIOLATION: 1;                   //Attempt to program a write-protected block.
+	unsigned ERASE_PARAM: 1;                    //An invalid selection of write-blocks for erase occurred.
+	unsigned ERASE_SEQ_ERROR: 1;                //An error in the sequence of erase commands occurred.
+	unsigned BLOCK_LEN_ERROR: 1;                //The transferred block length is not allowed for this card, or the number of transferred bytes does not match the block length.
+	unsigned ADDRESS_ERROR: 1;                  //A misaligned address that did not match the block length was used in the command.
+	unsigned OUT_OF_RANGE: 1;                   //The command??s argument was out of the allowed range for this card.
+
+} SD_Card_Status_t;
+
+//structure for response
+typedef struct _SD_Response_R1
+{
+	SD_Card_Status_t card_status;               //card status
+} SD_Response_R1_t;
+
+
+struct aml_card_sd_info
+{
+	unsigned sd_emmc_port;				 //0: sdioa, 1:sdiob, 2:sdioc
+	unsigned sd_emmc_reg_base;
+	char * name;
+	int inited_flag;
+	int removed_flag;
+	int init_retry;
+	int single_blk_failed;
+	char* desc_buf;
+	struct mmc_config cfg;
+	struct sd_emmc_global_regs *sd_emmc_reg;
+	dma_addr_t		desc_dma_addr;
+#ifdef AML_CARD_SD_INFO_DETAILED
+	int  (* sd_emmc_init)(unsigned port,struct aml_card_sd_info *sdio);
+	int  (* sd_emmc_detect)(unsigned port,struct aml_card_sd_info *sdio);
+	void (* sd_emmc_pwr_prepare)(unsigned port,struct aml_card_sd_info *sdio);
+	void (* sd_emmc_pwr_on)(unsigned port,struct aml_card_sd_info *sdio);
+	void (* sd_emmc_pwr_off)(unsigned port,struct aml_card_sd_info *sdio);
+	unsigned int sdio_pwr_flag;
+#else
+	int  (* sd_emmc_init)(unsigned port);
+	int  (* sd_emmc_detect)(unsigned port);
+	void (* sd_emmc_pwr_prepare)(unsigned port);
+	void (* sd_emmc_pwr_on)(unsigned port);
+	void (* sd_emmc_pwr_off)(unsigned port);
+#endif
+};
+
+extern struct aml_card_sd_info * cpu_sd_emmc_get(unsigned port);
+extern int                cpu_sd_emmc_init(unsigned port);
+extern void               cpu_sd_emmc_pwr_prepare(unsigned port);
+struct mmc;//mmc is struct mmc , to avoid include mmc.h , declare it
+extern void               sd_emmc_register(struct aml_card_sd_info *);
+#endif
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-gxb/secure_apb.h b/arch/arm/include/asm/arch-gxb/secure_apb.h
new file mode 100644
index 0000000..84137e9
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/secure_apb.h
@@ -0,0 +1,2108 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/secure_apb.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_headers_from_secure_apb4_h.pl
+//
+// and was applied to the file
+//
+// ./secure_apb4_ee.h ./ao_rti_reg.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+#ifdef SECURE_APB_H
+#else
+#define SECURE_APB_H
+
+//
+// Reading file:  ./secure_apb4_ee.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//========================================================================
+//  RNG
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834000
+//  APB4_DECODER_SECURE_BASE         32'hDA834000
+//  Non Secure Register
+#define     RNG_DATA                                           (0xc8834000 + (0x00 << 2))
+#define SEC_RNG_DATA                                           (0xda834000 + (0x00 << 2))
+#define   P_RNG_DATA                                           (volatile uint32_t *)(0xc8834000 + (0x00 << 2))
+//  Secure Register
+#define     RNG_SEC_CONFIG_REG1                                (0xc8834000 + (0x01 << 2))
+#define SEC_RNG_SEC_CONFIG_REG1                                (0xda834000 + (0x01 << 2))
+#define   P_RNG_SEC_CONFIG_REG1                                (volatile uint32_t *)(0xc8834000 + (0x01 << 2))
+#define     RNG_SEC_CONFIG_REG2                                (0xc8834000 + (0x02 << 2))
+#define SEC_RNG_SEC_CONFIG_REG2                                (0xda834000 + (0x02 << 2))
+#define   P_RNG_SEC_CONFIG_REG2                                (volatile uint32_t *)(0xc8834000 + (0x02 << 2))
+#define     RNG_SEC_SCRATCH_REG                                (0xc8834000 + (0x03 << 2))
+#define SEC_RNG_SEC_SCRATCH_REG                                (0xda834000 + (0x03 << 2))
+#define   P_RNG_SEC_SCRATCH_REG                                (volatile uint32_t *)(0xc8834000 + (0x03 << 2))
+//========================================================================
+//  PERIPHS
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834400
+//  APB4_DECODER_SECURE_BASE         32'hDA834400
+// The following are handled by $periphs/rtl/periphs_reg.v
+#define     PREG_CTLREG0_ADDR                                  (0xc8834400 + (0x00 << 2))
+#define SEC_PREG_CTLREG0_ADDR                                  (0xda834400 + (0x00 << 2))
+#define   P_PREG_CTLREG0_ADDR                                  (volatile uint32_t *)(0xc8834400 + (0x00 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO6_EN_N                                (0xc8834400 + (0x08 << 2))
+#define SEC_PREG_PAD_GPIO6_EN_N                                (0xda834400 + (0x08 << 2))
+#define   P_PREG_PAD_GPIO6_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x08 << 2))
+#define     PREG_PAD_GPIO6_O                                   (0xc8834400 + (0x09 << 2))
+#define SEC_PREG_PAD_GPIO6_O                                   (0xda834400 + (0x09 << 2))
+#define   P_PREG_PAD_GPIO6_O                                   (volatile uint32_t *)(0xc8834400 + (0x09 << 2))
+#define     PREG_PAD_GPIO6_I                                   (0xc8834400 + (0x0a << 2))
+#define SEC_PREG_PAD_GPIO6_I                                   (0xda834400 + (0x0a << 2))
+#define   P_PREG_PAD_GPIO6_I                                   (volatile uint32_t *)(0xc8834400 + (0x0a << 2))
+// ----------------------------
+// ----------------------------
+#define     PREG_JTAG_GPIO_ADDR                                (0xc8834400 + (0x0b << 2))
+#define SEC_PREG_JTAG_GPIO_ADDR                                (0xda834400 + (0x0b << 2))
+#define   P_PREG_JTAG_GPIO_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x0b << 2))
+// ----------------------------
+// Pre-defined GPIO addresses
+// ----------------------------
+#define     PREG_PAD_GPIO0_EN_N                                (0xc8834400 + (0x0c << 2))
+#define SEC_PREG_PAD_GPIO0_EN_N                                (0xda834400 + (0x0c << 2))
+#define   P_PREG_PAD_GPIO0_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0c << 2))
+#define     PREG_PAD_GPIO0_O                                   (0xc8834400 + (0x0d << 2))
+#define SEC_PREG_PAD_GPIO0_O                                   (0xda834400 + (0x0d << 2))
+#define   P_PREG_PAD_GPIO0_O                                   (volatile uint32_t *)(0xc8834400 + (0x0d << 2))
+#define     PREG_PAD_GPIO0_I                                   (0xc8834400 + (0x0e << 2))
+#define SEC_PREG_PAD_GPIO0_I                                   (0xda834400 + (0x0e << 2))
+#define   P_PREG_PAD_GPIO0_I                                   (volatile uint32_t *)(0xc8834400 + (0x0e << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO1_EN_N                                (0xc8834400 + (0x0f << 2))
+#define SEC_PREG_PAD_GPIO1_EN_N                                (0xda834400 + (0x0f << 2))
+#define   P_PREG_PAD_GPIO1_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0f << 2))
+#define     PREG_PAD_GPIO1_O                                   (0xc8834400 + (0x10 << 2))
+#define SEC_PREG_PAD_GPIO1_O                                   (0xda834400 + (0x10 << 2))
+#define   P_PREG_PAD_GPIO1_O                                   (volatile uint32_t *)(0xc8834400 + (0x10 << 2))
+#define     PREG_PAD_GPIO1_I                                   (0xc8834400 + (0x11 << 2))
+#define SEC_PREG_PAD_GPIO1_I                                   (0xda834400 + (0x11 << 2))
+#define   P_PREG_PAD_GPIO1_I                                   (volatile uint32_t *)(0xc8834400 + (0x11 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO2_EN_N                                (0xc8834400 + (0x12 << 2))
+#define SEC_PREG_PAD_GPIO2_EN_N                                (0xda834400 + (0x12 << 2))
+#define   P_PREG_PAD_GPIO2_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x12 << 2))
+#define     PREG_PAD_GPIO2_O                                   (0xc8834400 + (0x13 << 2))
+#define SEC_PREG_PAD_GPIO2_O                                   (0xda834400 + (0x13 << 2))
+#define   P_PREG_PAD_GPIO2_O                                   (volatile uint32_t *)(0xc8834400 + (0x13 << 2))
+#define     PREG_PAD_GPIO2_I                                   (0xc8834400 + (0x14 << 2))
+#define SEC_PREG_PAD_GPIO2_I                                   (0xda834400 + (0x14 << 2))
+#define   P_PREG_PAD_GPIO2_I                                   (volatile uint32_t *)(0xc8834400 + (0x14 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO3_EN_N                                (0xc8834400 + (0x15 << 2))
+#define SEC_PREG_PAD_GPIO3_EN_N                                (0xda834400 + (0x15 << 2))
+#define   P_PREG_PAD_GPIO3_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x15 << 2))
+#define     PREG_PAD_GPIO3_O                                   (0xc8834400 + (0x16 << 2))
+#define SEC_PREG_PAD_GPIO3_O                                   (0xda834400 + (0x16 << 2))
+#define   P_PREG_PAD_GPIO3_O                                   (volatile uint32_t *)(0xc8834400 + (0x16 << 2))
+#define     PREG_PAD_GPIO3_I                                   (0xc8834400 + (0x17 << 2))
+#define SEC_PREG_PAD_GPIO3_I                                   (0xda834400 + (0x17 << 2))
+#define   P_PREG_PAD_GPIO3_I                                   (volatile uint32_t *)(0xc8834400 + (0x17 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO4_EN_N                                (0xc8834400 + (0x18 << 2))
+#define SEC_PREG_PAD_GPIO4_EN_N                                (0xda834400 + (0x18 << 2))
+#define   P_PREG_PAD_GPIO4_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x18 << 2))
+#define     PREG_PAD_GPIO4_O                                   (0xc8834400 + (0x19 << 2))
+#define SEC_PREG_PAD_GPIO4_O                                   (0xda834400 + (0x19 << 2))
+#define   P_PREG_PAD_GPIO4_O                                   (volatile uint32_t *)(0xc8834400 + (0x19 << 2))
+#define     PREG_PAD_GPIO4_I                                   (0xc8834400 + (0x1a << 2))
+#define SEC_PREG_PAD_GPIO4_I                                   (0xda834400 + (0x1a << 2))
+#define   P_PREG_PAD_GPIO4_I                                   (volatile uint32_t *)(0xc8834400 + (0x1a << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO5_EN_N                                (0xc8834400 + (0x1b << 2))
+#define SEC_PREG_PAD_GPIO5_EN_N                                (0xda834400 + (0x1b << 2))
+#define   P_PREG_PAD_GPIO5_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x1b << 2))
+#define     PREG_PAD_GPIO5_O                                   (0xc8834400 + (0x1c << 2))
+#define SEC_PREG_PAD_GPIO5_O                                   (0xda834400 + (0x1c << 2))
+#define   P_PREG_PAD_GPIO5_O                                   (volatile uint32_t *)(0xc8834400 + (0x1c << 2))
+#define     PREG_PAD_GPIO5_I                                   (0xc8834400 + (0x1d << 2))
+#define SEC_PREG_PAD_GPIO5_I                                   (0xda834400 + (0x1d << 2))
+#define   P_PREG_PAD_GPIO5_I                                   (volatile uint32_t *)(0xc8834400 + (0x1d << 2))
+// ----------------------------
+// ----------------------------
+// Pin Mux  (9)
+// ----------------------------
+#define     PERIPHS_PIN_MUX_0                                  (0xc8834400 + (0x2c << 2))
+#define SEC_PERIPHS_PIN_MUX_0                                  (0xda834400 + (0x2c << 2))
+#define   P_PERIPHS_PIN_MUX_0                                  (volatile uint32_t *)(0xc8834400 + (0x2c << 2))
+#define     PERIPHS_PIN_MUX_1                                  (0xc8834400 + (0x2d << 2))
+#define SEC_PERIPHS_PIN_MUX_1                                  (0xda834400 + (0x2d << 2))
+#define   P_PERIPHS_PIN_MUX_1                                  (volatile uint32_t *)(0xc8834400 + (0x2d << 2))
+#define     PERIPHS_PIN_MUX_2                                  (0xc8834400 + (0x2e << 2))
+#define SEC_PERIPHS_PIN_MUX_2                                  (0xda834400 + (0x2e << 2))
+#define   P_PERIPHS_PIN_MUX_2                                  (volatile uint32_t *)(0xc8834400 + (0x2e << 2))
+#define     PERIPHS_PIN_MUX_3                                  (0xc8834400 + (0x2f << 2))
+#define SEC_PERIPHS_PIN_MUX_3                                  (0xda834400 + (0x2f << 2))
+#define   P_PERIPHS_PIN_MUX_3                                  (volatile uint32_t *)(0xc8834400 + (0x2f << 2))
+#define     PERIPHS_PIN_MUX_4                                  (0xc8834400 + (0x30 << 2))
+#define SEC_PERIPHS_PIN_MUX_4                                  (0xda834400 + (0x30 << 2))
+#define   P_PERIPHS_PIN_MUX_4                                  (volatile uint32_t *)(0xc8834400 + (0x30 << 2))
+#define     PERIPHS_PIN_MUX_5                                  (0xc8834400 + (0x31 << 2))
+#define SEC_PERIPHS_PIN_MUX_5                                  (0xda834400 + (0x31 << 2))
+#define   P_PERIPHS_PIN_MUX_5                                  (volatile uint32_t *)(0xc8834400 + (0x31 << 2))
+#define     PERIPHS_PIN_MUX_6                                  (0xc8834400 + (0x32 << 2))
+#define SEC_PERIPHS_PIN_MUX_6                                  (0xda834400 + (0x32 << 2))
+#define   P_PERIPHS_PIN_MUX_6                                  (volatile uint32_t *)(0xc8834400 + (0x32 << 2))
+#define     PERIPHS_PIN_MUX_7                                  (0xc8834400 + (0x33 << 2))
+#define SEC_PERIPHS_PIN_MUX_7                                  (0xda834400 + (0x33 << 2))
+#define   P_PERIPHS_PIN_MUX_7                                  (volatile uint32_t *)(0xc8834400 + (0x33 << 2))
+#define     PERIPHS_PIN_MUX_8                                  (0xc8834400 + (0x34 << 2))
+#define SEC_PERIPHS_PIN_MUX_8                                  (0xda834400 + (0x34 << 2))
+#define   P_PERIPHS_PIN_MUX_8                                  (volatile uint32_t *)(0xc8834400 + (0x34 << 2))
+#define     PERIPHS_PIN_MUX_9                                  (0xc8834400 + (0x35 << 2))
+#define SEC_PERIPHS_PIN_MUX_9                                  (0xda834400 + (0x35 << 2))
+#define   P_PERIPHS_PIN_MUX_9                                  (volatile uint32_t *)(0xc8834400 + (0x35 << 2))
+#define     PERIPHS_PIN_MUX_10                                 (0xc8834400 + (0x36 << 2))
+#define SEC_PERIPHS_PIN_MUX_10                                 (0xda834400 + (0x36 << 2))
+#define   P_PERIPHS_PIN_MUX_10                                 (volatile uint32_t *)(0xc8834400 + (0x36 << 2))
+#define     PERIPHS_PIN_MUX_11                                 (0xc8834400 + (0x37 << 2))
+#define SEC_PERIPHS_PIN_MUX_11                                 (0xda834400 + (0x37 << 2))
+#define   P_PERIPHS_PIN_MUX_11                                 (volatile uint32_t *)(0xc8834400 + (0x37 << 2))
+#define     PERIPHS_PIN_MUX_12                                 (0xc8834400 + (0x38 << 2))
+#define SEC_PERIPHS_PIN_MUX_12                                 (0xda834400 + (0x38 << 2))
+#define   P_PERIPHS_PIN_MUX_12                                 (volatile uint32_t *)(0xc8834400 + (0x38 << 2))
+// ----------------------------
+// Pad conntrols
+// ----------------------------
+#define     PAD_PULL_UP_REG6                                   (0xc8834400 + (0x39 << 2))
+#define SEC_PAD_PULL_UP_REG6                                   (0xda834400 + (0x39 << 2))
+#define   P_PAD_PULL_UP_REG6                                   (volatile uint32_t *)(0xc8834400 + (0x39 << 2))
+#define     PAD_PULL_UP_REG0                                   (0xc8834400 + (0x3a << 2))
+#define SEC_PAD_PULL_UP_REG0                                   (0xda834400 + (0x3a << 2))
+#define   P_PAD_PULL_UP_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x3a << 2))
+#define     PAD_PULL_UP_REG1                                   (0xc8834400 + (0x3b << 2))
+#define SEC_PAD_PULL_UP_REG1                                   (0xda834400 + (0x3b << 2))
+#define   P_PAD_PULL_UP_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x3b << 2))
+#define     PAD_PULL_UP_REG2                                   (0xc8834400 + (0x3c << 2))
+#define SEC_PAD_PULL_UP_REG2                                   (0xda834400 + (0x3c << 2))
+#define   P_PAD_PULL_UP_REG2                                   (volatile uint32_t *)(0xc8834400 + (0x3c << 2))
+#define     PAD_PULL_UP_REG3                                   (0xc8834400 + (0x3d << 2))
+#define SEC_PAD_PULL_UP_REG3                                   (0xda834400 + (0x3d << 2))
+#define   P_PAD_PULL_UP_REG3                                   (volatile uint32_t *)(0xc8834400 + (0x3d << 2))
+#define     PAD_PULL_UP_REG4                                   (0xc8834400 + (0x3e << 2))
+#define SEC_PAD_PULL_UP_REG4                                   (0xda834400 + (0x3e << 2))
+#define   P_PAD_PULL_UP_REG4                                   (volatile uint32_t *)(0xc8834400 + (0x3e << 2))
+#define     PAD_PULL_UP_REG5                                   (0xc8834400 + (0x3f << 2))
+#define SEC_PAD_PULL_UP_REG5                                   (0xda834400 + (0x3f << 2))
+#define   P_PAD_PULL_UP_REG5                                   (volatile uint32_t *)(0xc8834400 + (0x3f << 2))
+// ----------------------------
+// Random (2)
+// ----------------------------
+#define     RAND64_ADDR0                                       (0xc8834400 + (0x40 << 2))
+#define SEC_RAND64_ADDR0                                       (0xda834400 + (0x40 << 2))
+#define   P_RAND64_ADDR0                                       (volatile uint32_t *)(0xc8834400 + (0x40 << 2))
+#define     RAND64_ADDR1                                       (0xc8834400 + (0x41 << 2))
+#define SEC_RAND64_ADDR1                                       (0xda834400 + (0x41 << 2))
+#define   P_RAND64_ADDR1                                       (volatile uint32_t *)(0xc8834400 + (0x41 << 2))
+// ---------------------------
+// Ethernet (1)
+// ----------------------------
+#define     PREG_ETHERNET_ADDR0                                (0xc8834400 + (0x42 << 2))
+#define SEC_PREG_ETHERNET_ADDR0                                (0xda834400 + (0x42 << 2))
+#define   P_PREG_ETHERNET_ADDR0                                (volatile uint32_t *)(0xc8834400 + (0x42 << 2))
+// ---------------------------
+// AM_ANALOG_TOP
+// ----------------------------
+#define     PREG_AM_ANALOG_ADDR                                (0xc8834400 + (0x43 << 2))
+#define SEC_PREG_AM_ANALOG_ADDR                                (0xda834400 + (0x43 << 2))
+#define   P_PREG_AM_ANALOG_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x43 << 2))
+// ---------------------------
+// Mali55 (1)
+// ----------------------------
+#define     PREG_MALI_BYTE_CNTL                                (0xc8834400 + (0x44 << 2))
+#define SEC_PREG_MALI_BYTE_CNTL                                (0xda834400 + (0x44 << 2))
+#define   P_PREG_MALI_BYTE_CNTL                                (volatile uint32_t *)(0xc8834400 + (0x44 << 2))
+// ---------------------------
+// WIFI (1)
+// ----------------------------
+#define     PREG_WIFI_CNTL                                     (0xc8834400 + (0x45 << 2))
+#define SEC_PREG_WIFI_CNTL                                     (0xda834400 + (0x45 << 2))
+#define   P_PREG_WIFI_CNTL                                     (volatile uint32_t *)(0xc8834400 + (0x45 << 2))
+#define     PAD_PULL_UP_EN_REG0                                (0xc8834400 + (0x48 << 2))
+#define SEC_PAD_PULL_UP_EN_REG0                                (0xda834400 + (0x48 << 2))
+#define   P_PAD_PULL_UP_EN_REG0                                (volatile uint32_t *)(0xc8834400 + (0x48 << 2))
+#define     PAD_PULL_UP_EN_REG1                                (0xc8834400 + (0x49 << 2))
+#define SEC_PAD_PULL_UP_EN_REG1                                (0xda834400 + (0x49 << 2))
+#define   P_PAD_PULL_UP_EN_REG1                                (volatile uint32_t *)(0xc8834400 + (0x49 << 2))
+#define     PAD_PULL_UP_EN_REG2                                (0xc8834400 + (0x4a << 2))
+#define SEC_PAD_PULL_UP_EN_REG2                                (0xda834400 + (0x4a << 2))
+#define   P_PAD_PULL_UP_EN_REG2                                (volatile uint32_t *)(0xc8834400 + (0x4a << 2))
+#define     PAD_PULL_UP_EN_REG3                                (0xc8834400 + (0x4b << 2))
+#define SEC_PAD_PULL_UP_EN_REG3                                (0xda834400 + (0x4b << 2))
+#define   P_PAD_PULL_UP_EN_REG3                                (volatile uint32_t *)(0xc8834400 + (0x4b << 2))
+#define     PAD_PULL_UP_EN_REG4                                (0xc8834400 + (0x4c << 2))
+#define SEC_PAD_PULL_UP_EN_REG4                                (0xda834400 + (0x4c << 2))
+#define   P_PAD_PULL_UP_EN_REG4                                (volatile uint32_t *)(0xc8834400 + (0x4c << 2))
+#define     PAD_PULL_UP_EN_REG5                                (0xc8834400 + (0x4d << 2))
+#define SEC_PAD_PULL_UP_EN_REG5                                (0xda834400 + (0x4d << 2))
+#define   P_PAD_PULL_UP_EN_REG5                                (volatile uint32_t *)(0xc8834400 + (0x4d << 2))
+#define     PAD_PULL_UP_EN_REG6                                (0xc8834400 + (0x4e << 2))
+#define SEC_PAD_PULL_UP_EN_REG6                                (0xda834400 + (0x4e << 2))
+#define   P_PAD_PULL_UP_EN_REG6                                (volatile uint32_t *)(0xc8834400 + (0x4e << 2))
+// ---------------------------
+#define     PREG_ETH_REG0                                      (0xc8834400 + (0x50 << 2))
+#define SEC_PREG_ETH_REG0                                      (0xda834400 + (0x50 << 2))
+#define   P_PREG_ETH_REG0                                      (volatile uint32_t *)(0xc8834400 + (0x50 << 2))
+#define     PREG_ETH_REG1                                      (0xc8834400 + (0x51 << 2))
+#define SEC_PREG_ETH_REG1                                      (0xda834400 + (0x51 << 2))
+#define   P_PREG_ETH_REG1                                      (volatile uint32_t *)(0xc8834400 + (0x51 << 2))
+#define     PREG_NAND_CFG_KEY0                                 (0xc8834400 + (0x52 << 2))
+#define SEC_PREG_NAND_CFG_KEY0                                 (0xda834400 + (0x52 << 2))
+#define   P_PREG_NAND_CFG_KEY0                                 (volatile uint32_t *)(0xc8834400 + (0x52 << 2))
+#define     PREG_NAND_CFG_KEY1                                 (0xc8834400 + (0x53 << 2))
+#define SEC_PREG_NAND_CFG_KEY1                                 (0xda834400 + (0x53 << 2))
+#define   P_PREG_NAND_CFG_KEY1                                 (volatile uint32_t *)(0xc8834400 + (0x53 << 2))
+#define     PREG_VPU_SECURE0                                   (0xc8834400 + (0x54 << 2))
+#define SEC_PREG_VPU_SECURE0                                   (0xda834400 + (0x54 << 2))
+#define   P_PREG_VPU_SECURE0                                   (volatile uint32_t *)(0xc8834400 + (0x54 << 2))
+#define     PREG_VPU_SECURE1                                   (0xc8834400 + (0x55 << 2))
+#define SEC_PREG_VPU_SECURE1                                   (0xda834400 + (0x55 << 2))
+#define   P_PREG_VPU_SECURE1                                   (volatile uint32_t *)(0xc8834400 + (0x55 << 2))
+// ---------------------------
+// Generic production test
+// ----------------------------
+#define     PROD_TEST_REG0                                     (0xc8834400 + (0x60 << 2))
+#define SEC_PROD_TEST_REG0                                     (0xda834400 + (0x60 << 2))
+#define   P_PROD_TEST_REG0                                     (volatile uint32_t *)(0xc8834400 + (0x60 << 2))
+#define     PROD_TEST_REG1                                     (0xc8834400 + (0x61 << 2))
+#define SEC_PROD_TEST_REG1                                     (0xda834400 + (0x61 << 2))
+#define   P_PROD_TEST_REG1                                     (volatile uint32_t *)(0xc8834400 + (0x61 << 2))
+#define     PROD_TEST_REG2                                     (0xc8834400 + (0x62 << 2))
+#define SEC_PROD_TEST_REG2                                     (0xda834400 + (0x62 << 2))
+#define   P_PROD_TEST_REG2                                     (volatile uint32_t *)(0xc8834400 + (0x62 << 2))
+#define     PROD_TEST_REG3                                     (0xc8834400 + (0x63 << 2))
+#define SEC_PROD_TEST_REG3                                     (0xda834400 + (0x63 << 2))
+#define   P_PROD_TEST_REG3                                     (volatile uint32_t *)(0xc8834400 + (0x63 << 2))
+// ---------------------------
+// am_analog_top
+// ----------------------------
+#define     METAL_REVISION                                     (0xc8834400 + (0x6a << 2))
+#define SEC_METAL_REVISION                                     (0xda834400 + (0x6a << 2))
+#define   P_METAL_REVISION                                     (volatile uint32_t *)(0xc8834400 + (0x6a << 2))
+#define     ADC_TOP_MISC                                       (0xc8834400 + (0x6b << 2))
+#define SEC_ADC_TOP_MISC                                       (0xda834400 + (0x6b << 2))
+#define   P_ADC_TOP_MISC                                       (volatile uint32_t *)(0xc8834400 + (0x6b << 2))
+#define     DPLL_TOP_MISC                                      (0xc8834400 + (0x6c << 2))
+#define SEC_DPLL_TOP_MISC                                      (0xda834400 + (0x6c << 2))
+#define   P_DPLL_TOP_MISC                                      (volatile uint32_t *)(0xc8834400 + (0x6c << 2))
+#define     ANALOG_TOP_MISC                                    (0xc8834400 + (0x6d << 2))
+#define SEC_ANALOG_TOP_MISC                                    (0xda834400 + (0x6d << 2))
+#define   P_ANALOG_TOP_MISC                                    (volatile uint32_t *)(0xc8834400 + (0x6d << 2))
+#define     AM_ANALOG_TOP_REG0                                 (0xc8834400 + (0x6e << 2))
+#define SEC_AM_ANALOG_TOP_REG0                                 (0xda834400 + (0x6e << 2))
+#define   P_AM_ANALOG_TOP_REG0                                 (volatile uint32_t *)(0xc8834400 + (0x6e << 2))
+#define     AM_ANALOG_TOP_REG1                                 (0xc8834400 + (0x6f << 2))
+#define SEC_AM_ANALOG_TOP_REG1                                 (0xda834400 + (0x6f << 2))
+#define   P_AM_ANALOG_TOP_REG1                                 (volatile uint32_t *)(0xc8834400 + (0x6f << 2))
+// ---------------------------
+// Sticky regs
+// ----------------------------
+#define     PREG_STICKY_REG0                                   (0xc8834400 + (0x7c << 2))
+#define SEC_PREG_STICKY_REG0                                   (0xda834400 + (0x7c << 2))
+#define   P_PREG_STICKY_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x7c << 2))
+#define     PREG_STICKY_REG1                                   (0xc8834400 + (0x7d << 2))
+#define SEC_PREG_STICKY_REG1                                   (0xda834400 + (0x7d << 2))
+#define   P_PREG_STICKY_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x7d << 2))
+#define     PREG_WRITE_ONCE_REG                                (0xc8834400 + (0x7e << 2))
+#define SEC_PREG_WRITE_ONCE_REG                                (0xda834400 + (0x7e << 2))
+#define   P_PREG_WRITE_ONCE_REG                                (volatile uint32_t *)(0xc8834400 + (0x7e << 2))
+// ---------------------------
+// AM Ring Oscillator
+// ----------------------------
+#define     AM_RING_OSC_REG0                                   (0xc8834400 + (0x7f << 2))
+#define SEC_AM_RING_OSC_REG0                                   (0xda834400 + (0x7f << 2))
+#define   P_AM_RING_OSC_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x7f << 2))
+// Control whether to provide random number to HDMITX20
+#define     HDMITX20_RNDNUM                                    (0xc8834400 + (0x80 << 2))
+#define SEC_HDMITX20_RNDNUM                                    (0xda834400 + (0x80 << 2))
+#define   P_HDMITX20_RNDNUM                                    (volatile uint32_t *)(0xc8834400 + (0x80 << 2))
+// ---------------------------
+// Bus Monitoring
+// ----------------------------
+#define     BUS_MONITOR_CNTL                                   (0xc8834400 + (0x81 << 2))
+#define SEC_BUS_MONITOR_CNTL                                   (0xda834400 + (0x81 << 2))
+#define   P_BUS_MONITOR_CNTL                                   (volatile uint32_t *)(0xc8834400 + (0x81 << 2))
+#define     BUS_MON0_ADDR                                      (0xc8834400 + (0x82 << 2))
+#define SEC_BUS_MON0_ADDR                                      (0xda834400 + (0x82 << 2))
+#define   P_BUS_MON0_ADDR                                      (volatile uint32_t *)(0xc8834400 + (0x82 << 2))
+#define     BUS_MON0_DATA                                      (0xc8834400 + (0x83 << 2))
+#define SEC_BUS_MON0_DATA                                      (0xda834400 + (0x83 << 2))
+#define   P_BUS_MON0_DATA                                      (volatile uint32_t *)(0xc8834400 + (0x83 << 2))
+#define     BUS_MON0_DATA_MSK                                  (0xc8834400 + (0x84 << 2))
+#define SEC_BUS_MON0_DATA_MSK                                  (0xda834400 + (0x84 << 2))
+#define   P_BUS_MON0_DATA_MSK                                  (volatile uint32_t *)(0xc8834400 + (0x84 << 2))
+#define     BUS_MON1_ADDR                                      (0xc8834400 + (0x85 << 2))
+#define SEC_BUS_MON1_ADDR                                      (0xda834400 + (0x85 << 2))
+#define   P_BUS_MON1_ADDR                                      (volatile uint32_t *)(0xc8834400 + (0x85 << 2))
+#define     BUS_MON1_DATA                                      (0xc8834400 + (0x86 << 2))
+#define SEC_BUS_MON1_DATA                                      (0xda834400 + (0x86 << 2))
+#define   P_BUS_MON1_DATA                                      (volatile uint32_t *)(0xc8834400 + (0x86 << 2))
+#define     BUS_MON1_DATA_MSK                                  (0xc8834400 + (0x87 << 2))
+#define SEC_BUS_MON1_DATA_MSK                                  (0xda834400 + (0x87 << 2))
+#define   P_BUS_MON1_DATA_MSK                                  (volatile uint32_t *)(0xc8834400 + (0x87 << 2))
+// ---------------------------
+// System CPU control registers
+// ----------------------------
+#define     SYS_CPU_POR_CFG0                                   (0xc8834400 + (0x90 << 2))
+#define SEC_SYS_CPU_POR_CFG0                                   (0xda834400 + (0x90 << 2))
+#define   P_SYS_CPU_POR_CFG0                                   (volatile uint32_t *)(0xc8834400 + (0x90 << 2))
+#define     SYS_CPU_POR_CFG1                                   (0xc8834400 + (0x91 << 2))
+#define SEC_SYS_CPU_POR_CFG1                                   (0xda834400 + (0x91 << 2))
+#define   P_SYS_CPU_POR_CFG1                                   (volatile uint32_t *)(0xc8834400 + (0x91 << 2))
+#define     SYS_CPU_CFG0                                       (0xc8834400 + (0x92 << 2))
+#define SEC_SYS_CPU_CFG0                                       (0xda834400 + (0x92 << 2))
+#define   P_SYS_CPU_CFG0                                       (volatile uint32_t *)(0xc8834400 + (0x92 << 2))
+#define     SYS_CPU_CFG1                                       (0xc8834400 + (0x93 << 2))
+#define SEC_SYS_CPU_CFG1                                       (0xda834400 + (0x93 << 2))
+#define   P_SYS_CPU_CFG1                                       (volatile uint32_t *)(0xc8834400 + (0x93 << 2))
+#define     SYS_CPU_CFG2                                       (0xc8834400 + (0x94 << 2))
+#define SEC_SYS_CPU_CFG2                                       (0xda834400 + (0x94 << 2))
+#define   P_SYS_CPU_CFG2                                       (volatile uint32_t *)(0xc8834400 + (0x94 << 2))
+#define     SYS_CPU_CFG3                                       (0xc8834400 + (0x95 << 2))
+#define SEC_SYS_CPU_CFG3                                       (0xda834400 + (0x95 << 2))
+#define   P_SYS_CPU_CFG3                                       (volatile uint32_t *)(0xc8834400 + (0x95 << 2))
+#define     SYS_CPU_CFG4                                       (0xc8834400 + (0x96 << 2))
+#define SEC_SYS_CPU_CFG4                                       (0xda834400 + (0x96 << 2))
+#define   P_SYS_CPU_CFG4                                       (volatile uint32_t *)(0xc8834400 + (0x96 << 2))
+#define     SYS_CPU_CFG5                                       (0xc8834400 + (0x97 << 2))
+#define SEC_SYS_CPU_CFG5                                       (0xda834400 + (0x97 << 2))
+#define   P_SYS_CPU_CFG5                                       (volatile uint32_t *)(0xc8834400 + (0x97 << 2))
+#define     SYS_CPU_CFG6                                       (0xc8834400 + (0x98 << 2))
+#define SEC_SYS_CPU_CFG6                                       (0xda834400 + (0x98 << 2))
+#define   P_SYS_CPU_CFG6                                       (volatile uint32_t *)(0xc8834400 + (0x98 << 2))
+#define     SYS_CPU_CFG7                                       (0xc8834400 + (0x99 << 2))
+#define SEC_SYS_CPU_CFG7                                       (0xda834400 + (0x99 << 2))
+#define   P_SYS_CPU_CFG7                                       (volatile uint32_t *)(0xc8834400 + (0x99 << 2))
+#define     SYS_CPU_CFG8                                       (0xc8834400 + (0x9a << 2))
+#define SEC_SYS_CPU_CFG8                                       (0xda834400 + (0x9a << 2))
+#define   P_SYS_CPU_CFG8                                       (volatile uint32_t *)(0xc8834400 + (0x9a << 2))
+#define     SYS_CPU_CFG9                                       (0xc8834400 + (0x9b << 2))
+#define SEC_SYS_CPU_CFG9                                       (0xda834400 + (0x9b << 2))
+#define   P_SYS_CPU_CFG9                                       (volatile uint32_t *)(0xc8834400 + (0x9b << 2))
+#define     SYS_CPU_CFG10                                      (0xc8834400 + (0x9c << 2))
+#define SEC_SYS_CPU_CFG10                                      (0xda834400 + (0x9c << 2))
+#define   P_SYS_CPU_CFG10                                      (volatile uint32_t *)(0xc8834400 + (0x9c << 2))
+#define     SYS_CPU_CFG11                                      (0xc8834400 + (0x9d << 2))
+#define SEC_SYS_CPU_CFG11                                      (0xda834400 + (0x9d << 2))
+#define   P_SYS_CPU_CFG11                                      (volatile uint32_t *)(0xc8834400 + (0x9d << 2))
+#define     SYS_CPU_CFG12                                      (0xc8834400 + (0x9e << 2))
+#define SEC_SYS_CPU_CFG12                                      (0xda834400 + (0x9e << 2))
+#define   P_SYS_CPU_CFG12                                      (volatile uint32_t *)(0xc8834400 + (0x9e << 2))
+#define     SYS_CPU_CFG13                                      (0xc8834400 + (0x9f << 2))
+#define SEC_SYS_CPU_CFG13                                      (0xda834400 + (0x9f << 2))
+#define   P_SYS_CPU_CFG13                                      (volatile uint32_t *)(0xc8834400 + (0x9f << 2))
+#define     SYS_CPU_STATUS0                                    (0xc8834400 + (0xa0 << 2))
+#define SEC_SYS_CPU_STATUS0                                    (0xda834400 + (0xa0 << 2))
+#define   P_SYS_CPU_STATUS0                                    (volatile uint32_t *)(0xc8834400 + (0xa0 << 2))
+#define     SYS_CPU_STATUS1                                    (0xc8834400 + (0xa1 << 2))
+#define SEC_SYS_CPU_STATUS1                                    (0xda834400 + (0xa1 << 2))
+#define   P_SYS_CPU_STATUS1                                    (volatile uint32_t *)(0xc8834400 + (0xa1 << 2))
+#define     SYS_CPU_STATUS2                                    (0xc8834400 + (0xa2 << 2))
+#define SEC_SYS_CPU_STATUS2                                    (0xda834400 + (0xa2 << 2))
+#define   P_SYS_CPU_STATUS2                                    (volatile uint32_t *)(0xc8834400 + (0xa2 << 2))
+#define     SYS_CPU_STATUS3                                    (0xc8834400 + (0xa3 << 2))
+#define SEC_SYS_CPU_STATUS3                                    (0xda834400 + (0xa3 << 2))
+#define   P_SYS_CPU_STATUS3                                    (volatile uint32_t *)(0xc8834400 + (0xa3 << 2))
+#define     SYS_CPU_STATUS4                                    (0xc8834400 + (0xa4 << 2))
+#define SEC_SYS_CPU_STATUS4                                    (0xda834400 + (0xa4 << 2))
+#define   P_SYS_CPU_STATUS4                                    (volatile uint32_t *)(0xc8834400 + (0xa4 << 2))
+#define     SYS_CPU_STATUS5                                    (0xc8834400 + (0xa5 << 2))
+#define SEC_SYS_CPU_STATUS5                                    (0xda834400 + (0xa5 << 2))
+#define   P_SYS_CPU_STATUS5                                    (volatile uint32_t *)(0xc8834400 + (0xa5 << 2))
+#define     SYS_CPU_MISC                                       (0xc8834400 + (0xa8 << 2))
+#define SEC_SYS_CPU_MISC                                       (0xda834400 + (0xa8 << 2))
+#define   P_SYS_CPU_MISC                                       (volatile uint32_t *)(0xc8834400 + (0xa8 << 2))
+//========================================================================
+//  HIU - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C000
+// APB4_DECODER_SECURE_BASE         32'hDA83C000
+#define     SCR_HIU                                            (0xc883c000 + (0x0b << 2))
+#define SEC_SCR_HIU                                            (0xda83c000 + (0x0b << 2))
+#define   P_SCR_HIU                                            (volatile uint32_t *)(0xc883c000 + (0x0b << 2))
+#define     HPG_TIMER                                          (0xc883c000 + (0x0f << 2))
+#define SEC_HPG_TIMER                                          (0xda83c000 + (0x0f << 2))
+#define   P_HPG_TIMER                                          (volatile uint32_t *)(0xc883c000 + (0x0f << 2))
+#define     HHI_GP0_PLL_CNTL                                   (0xc883c000 + (0x10 << 2))
+#define SEC_HHI_GP0_PLL_CNTL                                   (0xda83c000 + (0x10 << 2))
+#define   P_HHI_GP0_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x10 << 2))
+#define     HHI_GP0_PLL_CNTL2                                  (0xc883c000 + (0x11 << 2))
+#define SEC_HHI_GP0_PLL_CNTL2                                  (0xda83c000 + (0x11 << 2))
+#define   P_HHI_GP0_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x11 << 2))
+#define     HHI_GP0_PLL_CNTL3                                  (0xc883c000 + (0x12 << 2))
+#define SEC_HHI_GP0_PLL_CNTL3                                  (0xda83c000 + (0x12 << 2))
+#define   P_HHI_GP0_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x12 << 2))
+#define     HHI_GP0_PLL_CNTL4                                  (0xc883c000 + (0x13 << 2))
+#define SEC_HHI_GP0_PLL_CNTL4                                  (0xda83c000 + (0x13 << 2))
+#define   P_HHI_GP0_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x13 << 2))
+#define     HHI_GP0_PLL_CNTL5                                  (0xc883c000 + (0x14 << 2))
+#define SEC_HHI_GP0_PLL_CNTL5                                  (0xda83c000 + (0x14 << 2))
+#define   P_HHI_GP0_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x14 << 2))
+#define     HHI_GP1_PLL_CNTL                                   (0xc883c000 + (0x16 << 2))
+#define SEC_HHI_GP1_PLL_CNTL                                   (0xda83c000 + (0x16 << 2))
+#define   P_HHI_GP1_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x16 << 2))
+#define     HHI_GP1_PLL_CNTL2                                  (0xc883c000 + (0x17 << 2))
+#define SEC_HHI_GP1_PLL_CNTL2                                  (0xda83c000 + (0x17 << 2))
+#define   P_HHI_GP1_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x17 << 2))
+#define     HHI_GP1_PLL_CNTL3                                  (0xc883c000 + (0x18 << 2))
+#define SEC_HHI_GP1_PLL_CNTL3                                  (0xda83c000 + (0x18 << 2))
+#define   P_HHI_GP1_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x18 << 2))
+#define     HHI_GP1_PLL_CNTL4                                  (0xc883c000 + (0x19 << 2))
+#define SEC_HHI_GP1_PLL_CNTL4                                  (0xda83c000 + (0x19 << 2))
+#define   P_HHI_GP1_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x19 << 2))
+#define     HHI_GP1_PLL_CNTL5                                  (0xc883c000 + (0x1a << 2))
+#define SEC_HHI_GP1_PLL_CNTL5                                  (0xda83c000 + (0x1a << 2))
+#define   P_HHI_GP1_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x1a << 2))
+#define     HHI_CADC_CNTL                                      (0xc883c000 + (0x20 << 2))
+#define SEC_HHI_CADC_CNTL                                      (0xda83c000 + (0x20 << 2))
+#define   P_HHI_CADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x20 << 2))
+#define     HHI_CADC_CNTL2                                     (0xc883c000 + (0x21 << 2))
+#define SEC_HHI_CADC_CNTL2                                     (0xda83c000 + (0x21 << 2))
+#define   P_HHI_CADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x21 << 2))
+#define     HHI_CADC_CNTL3                                     (0xc883c000 + (0x22 << 2))
+#define SEC_HHI_CADC_CNTL3                                     (0xda83c000 + (0x22 << 2))
+#define   P_HHI_CADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x22 << 2))
+#define     HHI_CADC_CNTL4                                     (0xc883c000 + (0x23 << 2))
+#define SEC_HHI_CADC_CNTL4                                     (0xda83c000 + (0x23 << 2))
+#define   P_HHI_CADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x23 << 2))
+#define     HHI_CADC_CNTL5                                     (0xc883c000 + (0x24 << 2))
+#define SEC_HHI_CADC_CNTL5                                     (0xda83c000 + (0x24 << 2))
+#define   P_HHI_CADC_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0x24 << 2))
+#define     HHI_CADC_CNTL6                                     (0xc883c000 + (0x25 << 2))
+#define SEC_HHI_CADC_CNTL6                                     (0xda83c000 + (0x25 << 2))
+#define   P_HHI_CADC_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0x25 << 2))
+#define     HHI_DADC_CNTL                                      (0xc883c000 + (0x27 << 2))
+#define SEC_HHI_DADC_CNTL                                      (0xda83c000 + (0x27 << 2))
+#define   P_HHI_DADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x27 << 2))
+#define     HHI_DADC_CNTL2                                     (0xc883c000 + (0x28 << 2))
+#define SEC_HHI_DADC_CNTL2                                     (0xda83c000 + (0x28 << 2))
+#define   P_HHI_DADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x28 << 2))
+#define     HHI_DADC_RDBK0_I                                   (0xc883c000 + (0x29 << 2))
+#define SEC_HHI_DADC_RDBK0_I                                   (0xda83c000 + (0x29 << 2))
+#define   P_HHI_DADC_RDBK0_I                                   (volatile uint32_t *)(0xc883c000 + (0x29 << 2))
+#define     HHI_DADC_CNTL3                                     (0xc883c000 + (0x2a << 2))
+#define SEC_HHI_DADC_CNTL3                                     (0xda83c000 + (0x2a << 2))
+#define   P_HHI_DADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x2a << 2))
+#define     HHI_DADC_CNTL4                                     (0xc883c000 + (0x2b << 2))
+#define SEC_HHI_DADC_CNTL4                                     (0xda83c000 + (0x2b << 2))
+#define   P_HHI_DADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x2b << 2))
+#define     HHI_XTAL_DIVN_CNTL                                 (0xc883c000 + (0x2f << 2))
+#define SEC_HHI_XTAL_DIVN_CNTL                                 (0xda83c000 + (0x2f << 2))
+#define   P_HHI_XTAL_DIVN_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x2f << 2))
+#define     HHI_TIMER90K                                       (0xc883c000 + (0x3b << 2))
+#define SEC_HHI_TIMER90K                                       (0xda83c000 + (0x3b << 2))
+#define   P_HHI_TIMER90K                                       (volatile uint32_t *)(0xc883c000 + (0x3b << 2))
+#define     HHI_MEM_PD_REG0                                    (0xc883c000 + (0x40 << 2))
+#define SEC_HHI_MEM_PD_REG0                                    (0xda83c000 + (0x40 << 2))
+#define   P_HHI_MEM_PD_REG0                                    (volatile uint32_t *)(0xc883c000 + (0x40 << 2))
+//VIU1
+//bit 29:28 mem_pd_vi_sharp,  2'b00: Sharpness line buffer memory power on, 2'b11: power down
+//bit 29:28 mem_pd_vi_dipost, 2'b00: Deinterlace - di_post memory power on, 2'b11: power down
+//bit 27:26 mem_pd_vi_dipre,  2'b00: Deinterlace - di_pre memory power on, 2'b11: power down
+//bit 25:24 mem_pd_vi_prot3,  2'b00: picture rotation3 memory power on, 2'b11: power down
+//bit 23:22 mem_pd_vi_prot2,  2'b00: picture rotation2 memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vi_prot1,  2'b00: picture rotation1 memory power on, 2'b11: power down
+//bit 19:18 mem_pd_vi_vdin1,  2'b00: vdin1 memory power on, 2'b11: power down
+//bit 17:16 mem_pd_vi_vdin0,  2'b00: vdin0 memory power on, 2'b11: power down
+//bit 15:14 mem_pd_vi_osd_sc, 2'b00: osd_scaler memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi_scale,  2'b00: scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi_ofifo,  2'b00: vpp output fifo memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi_chroma, 2'b00: color management module memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi_vd2,    2'b00: vd2 memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi_vd1,    2'b00: vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi_osd2,   2'b00: osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi_osd1,   2'b00: osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG0                                (0xc883c000 + (0x41 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG0                                (0xda83c000 + (0x41 << 2))
+#define   P_HHI_VPU_MEM_PD_REG0                                (volatile uint32_t *)(0xc883c000 + (0x41 << 2))
+//bit 29:28 mem_pd_atv_dmd,   2'b00: ATV DMD memory power on, 2'b11: power down
+//bit 29:28 mem_pd_cvd2,      2'b00: CVD2 memory power on, 2'b11: power down
+//bit 27:26 mem_pd_isp,       2'b00: ISP memory power on, 2'b11: power down
+//bit 25:24 mem_pd_venci_int, 2'b00: cvbs- enci interface memory power on, 2'b11: power down
+//bit 23:22 mem_pd_venc_l_top,2'b00: panel - encl top memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vencp_int, 2'b00: hdmi - encp interface memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi2_osd_sc,2'b00: viu2 OSD scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi2_scale, 2'b00: viu2 scaler memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi2_ofifo, 2'b00: viu2 vpp output fifo memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi2_chroma,2'b00: viu2 color management module memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi2_vd1,   2'b00: viu2 vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi2_osd2,  2'b00: viu2 osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi2_osd1,  2'b00: viu2 osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG1                                (0xc883c000 + (0x42 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG1                                (0xda83c000 + (0x42 << 2))
+#define   P_HHI_VPU_MEM_PD_REG1                                (volatile uint32_t *)(0xc883c000 + (0x42 << 2))
+#define     HHI_DEMOD_MEM_PD_REG                               (0xc883c000 + (0x43 << 2))
+#define SEC_HHI_DEMOD_MEM_PD_REG                               (0xda83c000 + (0x43 << 2))
+#define   P_HHI_DEMOD_MEM_PD_REG                               (volatile uint32_t *)(0xc883c000 + (0x43 << 2))
+#define     HHI_AUD_DAC_CTRL                                   (0xc883c000 + (0x44 << 2))
+#define SEC_HHI_AUD_DAC_CTRL                                   (0xda83c000 + (0x44 << 2))
+#define   P_HHI_AUD_DAC_CTRL                                   (volatile uint32_t *)(0xc883c000 + (0x44 << 2))
+// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
+// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
+// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
+// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
+#define     HHI_VIID_CLK_DIV                                   (0xc883c000 + (0x4a << 2))
+#define SEC_HHI_VIID_CLK_DIV                                   (0xda83c000 + (0x4a << 2))
+#define   P_HHI_VIID_CLK_DIV                                   (volatile uint32_t *)(0xc883c000 + (0x4a << 2))
+#define     HHI_VIID_CLK_CNTL                                  (0xc883c000 + (0x4b << 2))
+#define SEC_HHI_VIID_CLK_CNTL                                  (0xda83c000 + (0x4b << 2))
+#define   P_HHI_VIID_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x4b << 2))
+#define     HHI_VIID_DIVIDER_CNTL                              (0xc883c000 + (0x4c << 2))
+#define SEC_HHI_VIID_DIVIDER_CNTL                              (0xda83c000 + (0x4c << 2))
+#define   P_HHI_VIID_DIVIDER_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x4c << 2))
+// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
+#define     HHI_GCLK_MPEG0                                     (0xc883c000 + (0x50 << 2))
+#define SEC_HHI_GCLK_MPEG0                                     (0xda83c000 + (0x50 << 2))
+#define   P_HHI_GCLK_MPEG0                                     (volatile uint32_t *)(0xc883c000 + (0x50 << 2))
+#define     HHI_GCLK_MPEG1                                     (0xc883c000 + (0x51 << 2))
+#define SEC_HHI_GCLK_MPEG1                                     (0xda83c000 + (0x51 << 2))
+#define   P_HHI_GCLK_MPEG1                                     (volatile uint32_t *)(0xc883c000 + (0x51 << 2))
+#define     HHI_GCLK_MPEG2                                     (0xc883c000 + (0x52 << 2))
+#define SEC_HHI_GCLK_MPEG2                                     (0xda83c000 + (0x52 << 2))
+#define   P_HHI_GCLK_MPEG2                                     (volatile uint32_t *)(0xc883c000 + (0x52 << 2))
+#define     HHI_GCLK_OTHER                                     (0xc883c000 + (0x54 << 2))
+#define SEC_HHI_GCLK_OTHER                                     (0xda83c000 + (0x54 << 2))
+#define   P_HHI_GCLK_OTHER                                     (volatile uint32_t *)(0xc883c000 + (0x54 << 2))
+#define     HHI_GCLK_AO                                        (0xc883c000 + (0x55 << 2))
+#define SEC_HHI_GCLK_AO                                        (0xda83c000 + (0x55 << 2))
+#define   P_HHI_GCLK_AO                                        (volatile uint32_t *)(0xc883c000 + (0x55 << 2))
+#define     HHI_SYS_OSCIN_CNTL                                 (0xc883c000 + (0x56 << 2))
+#define SEC_HHI_SYS_OSCIN_CNTL                                 (0xda83c000 + (0x56 << 2))
+#define   P_HHI_SYS_OSCIN_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x56 << 2))
+#define     HHI_SYS_CPU_CLK_CNTL1                              (0xc883c000 + (0x57 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL1                              (0xda83c000 + (0x57 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0x57 << 2))
+#define     HHI_SYS_CPU_RESET_CNTL                             (0xc883c000 + (0x58 << 2))
+#define SEC_HHI_SYS_CPU_RESET_CNTL                             (0xda83c000 + (0x58 << 2))
+#define   P_HHI_SYS_CPU_RESET_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x58 << 2))
+// PLL Controls
+#define     HHI_VID_CLK_DIV                                    (0xc883c000 + (0x59 << 2))
+#define SEC_HHI_VID_CLK_DIV                                    (0xda83c000 + (0x59 << 2))
+#define   P_HHI_VID_CLK_DIV                                    (volatile uint32_t *)(0xc883c000 + (0x59 << 2))
+#define     HHI_MPEG_CLK_CNTL                                  (0xc883c000 + (0x5d << 2))
+#define SEC_HHI_MPEG_CLK_CNTL                                  (0xda83c000 + (0x5d << 2))
+#define   P_HHI_MPEG_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x5d << 2))
+#define     HHI_AUD_CLK_CNTL                                   (0xc883c000 + (0x5e << 2))
+#define SEC_HHI_AUD_CLK_CNTL                                   (0xda83c000 + (0x5e << 2))
+#define   P_HHI_AUD_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5e << 2))
+#define     HHI_VID_CLK_CNTL                                   (0xc883c000 + (0x5f << 2))
+#define SEC_HHI_VID_CLK_CNTL                                   (0xda83c000 + (0x5f << 2))
+#define   P_HHI_VID_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5f << 2))
+#define     HHI_WIFI_CLK_CNTL                                  (0xc883c000 + (0x60 << 2))
+#define SEC_HHI_WIFI_CLK_CNTL                                  (0xda83c000 + (0x60 << 2))
+#define   P_HHI_WIFI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x60 << 2))
+#define     HHI_WIFI_PLL_CNTL                                  (0xc883c000 + (0x61 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL                                  (0xda83c000 + (0x61 << 2))
+#define   P_HHI_WIFI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x61 << 2))
+#define     HHI_WIFI_PLL_CNTL2                                 (0xc883c000 + (0x62 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL2                                 (0xda83c000 + (0x62 << 2))
+#define   P_HHI_WIFI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0x62 << 2))
+#define     HHI_WIFI_PLL_CNTL3                                 (0xc883c000 + (0x63 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL3                                 (0xda83c000 + (0x63 << 2))
+#define   P_HHI_WIFI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0x63 << 2))
+#define     HHI_AUD_CLK_CNTL2                                  (0xc883c000 + (0x64 << 2))
+#define SEC_HHI_AUD_CLK_CNTL2                                  (0xda83c000 + (0x64 << 2))
+#define   P_HHI_AUD_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x64 << 2))
+#define     HHI_VID_CLK_CNTL2                                  (0xc883c000 + (0x65 << 2))
+#define SEC_HHI_VID_CLK_CNTL2                                  (0xda83c000 + (0x65 << 2))
+#define   P_HHI_VID_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x65 << 2))
+#define     HHI_VID_DIVIDER_CNTL                               (0xc883c000 + (0x66 << 2))
+#define SEC_HHI_VID_DIVIDER_CNTL                               (0xda83c000 + (0x66 << 2))
+#define   P_HHI_VID_DIVIDER_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x66 << 2))
+#define     HHI_SYS_CPU_CLK_CNTL                               (0xc883c000 + (0x67 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL                               (0xda83c000 + (0x67 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x67 << 2))
+#define     HHI_VID_PLL_CLK_DIV                                (0xc883c000 + (0x68 << 2))
+#define SEC_HHI_VID_PLL_CLK_DIV                                (0xda83c000 + (0x68 << 2))
+#define   P_HHI_VID_PLL_CLK_DIV                                (volatile uint32_t *)(0xc883c000 + (0x68 << 2))
+#define     HHI_AUD_CLK_CNTL3                                  (0xc883c000 + (0x69 << 2))
+#define SEC_HHI_AUD_CLK_CNTL3                                  (0xda83c000 + (0x69 << 2))
+#define   P_HHI_AUD_CLK_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x69 << 2))
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
+#define     HHI_MALI_CLK_CNTL                                  (0xc883c000 + (0x6c << 2))
+#define SEC_HHI_MALI_CLK_CNTL                                  (0xda83c000 + (0x6c << 2))
+#define   P_HHI_MALI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x6c << 2))
+#define     HHI_MIPI_PHY_CLK_CNTL                              (0xc883c000 + (0x6e << 2))
+#define SEC_HHI_MIPI_PHY_CLK_CNTL                              (0xda83c000 + (0x6e << 2))
+#define   P_HHI_MIPI_PHY_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x6e << 2))
+#define     HHI_VPU_CLK_CNTL                                   (0xc883c000 + (0x6f << 2))
+#define SEC_HHI_VPU_CLK_CNTL                                   (0xda83c000 + (0x6f << 2))
+#define   P_HHI_VPU_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x6f << 2))
+#define     HHI_OTHER_PLL_CNTL                                 (0xc883c000 + (0x70 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL                                 (0xda83c000 + (0x70 << 2))
+#define   P_HHI_OTHER_PLL_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x70 << 2))
+#define     HHI_OTHER_PLL_CNTL2                                (0xc883c000 + (0x71 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL2                                (0xda83c000 + (0x71 << 2))
+#define   P_HHI_OTHER_PLL_CNTL2                                (volatile uint32_t *)(0xc883c000 + (0x71 << 2))
+#define     HHI_OTHER_PLL_CNTL3                                (0xc883c000 + (0x72 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL3                                (0xda83c000 + (0x72 << 2))
+#define   P_HHI_OTHER_PLL_CNTL3                                (volatile uint32_t *)(0xc883c000 + (0x72 << 2))
+#define     HHI_HDMI_CLK_CNTL                                  (0xc883c000 + (0x73 << 2))
+#define SEC_HHI_HDMI_CLK_CNTL                                  (0xda83c000 + (0x73 << 2))
+#define   P_HHI_HDMI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x73 << 2))
+#define     HHI_DEMOD_CLK_CNTL                                 (0xc883c000 + (0x74 << 2))
+#define SEC_HHI_DEMOD_CLK_CNTL                                 (0xda83c000 + (0x74 << 2))
+#define   P_HHI_DEMOD_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x74 << 2))
+#define     HHI_SATA_CLK_CNTL                                  (0xc883c000 + (0x75 << 2))
+#define SEC_HHI_SATA_CLK_CNTL                                  (0xda83c000 + (0x75 << 2))
+#define   P_HHI_SATA_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x75 << 2))
+#define     HHI_ETH_CLK_CNTL                                   (0xc883c000 + (0x76 << 2))
+#define SEC_HHI_ETH_CLK_CNTL                                   (0xda83c000 + (0x76 << 2))
+#define   P_HHI_ETH_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x76 << 2))
+#define     HHI_CLK_DOUBLE_CNTL                                (0xc883c000 + (0x77 << 2))
+#define SEC_HHI_CLK_DOUBLE_CNTL                                (0xda83c000 + (0x77 << 2))
+#define   P_HHI_CLK_DOUBLE_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x77 << 2))
+#define     HHI_VDEC_CLK_CNTL                                  (0xc883c000 + (0x78 << 2))
+#define SEC_HHI_VDEC_CLK_CNTL                                  (0xda83c000 + (0x78 << 2))
+#define   P_HHI_VDEC_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x78 << 2))
+#define     HHI_VDEC2_CLK_CNTL                                 (0xc883c000 + (0x79 << 2))
+#define SEC_HHI_VDEC2_CLK_CNTL                                 (0xda83c000 + (0x79 << 2))
+#define   P_HHI_VDEC2_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x79 << 2))
+#define     HHI_VDEC3_CLK_CNTL                                 (0xc883c000 + (0x7a << 2))
+#define SEC_HHI_VDEC3_CLK_CNTL                                 (0xda83c000 + (0x7a << 2))
+#define   P_HHI_VDEC3_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7a << 2))
+#define     HHI_VDEC4_CLK_CNTL                                 (0xc883c000 + (0x7b << 2))
+#define SEC_HHI_VDEC4_CLK_CNTL                                 (0xda83c000 + (0x7b << 2))
+#define   P_HHI_VDEC4_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7b << 2))
+#define     HHI_HDCP22_CLK_CNTL                                (0xc883c000 + (0x7c << 2))
+#define SEC_HHI_HDCP22_CLK_CNTL                                (0xda83c000 + (0x7c << 2))
+#define   P_HHI_HDCP22_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7c << 2))
+#define     HHI_VAPBCLK_CNTL                                   (0xc883c000 + (0x7d << 2))
+#define SEC_HHI_VAPBCLK_CNTL                                   (0xda83c000 + (0x7d << 2))
+#define   P_HHI_VAPBCLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x7d << 2))
+#define     HHI_VP9DEC_CLK_CNTL                                (0xc883c000 + (0x7e << 2))
+#define SEC_HHI_VP9DEC_CLK_CNTL                                (0xda83c000 + (0x7e << 2))
+#define   P_HHI_VP9DEC_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7e << 2))
+// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
+// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
+// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
+// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
+#define     HHI_HDMI_AFC_CNTL                                  (0xc883c000 + (0x7f << 2))
+#define SEC_HHI_HDMI_AFC_CNTL                                  (0xda83c000 + (0x7f << 2))
+#define   P_HHI_HDMI_AFC_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x7f << 2))
+#define     HHI_HDMIRX_CLK_CNTL                                (0xc883c000 + (0x80 << 2))
+#define SEC_HHI_HDMIRX_CLK_CNTL                                (0xda83c000 + (0x80 << 2))
+#define   P_HHI_HDMIRX_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x80 << 2))
+#define     HHI_HDMIRX_AUD_CLK_CNTL                            (0xc883c000 + (0x81 << 2))
+#define SEC_HHI_HDMIRX_AUD_CLK_CNTL                            (0xda83c000 + (0x81 << 2))
+#define   P_HHI_HDMIRX_AUD_CLK_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x81 << 2))
+#define     HHI_EDP_APB_CLK_CNTL                               (0xc883c000 + (0x82 << 2))
+#define SEC_HHI_EDP_APB_CLK_CNTL                               (0xda83c000 + (0x82 << 2))
+#define   P_HHI_EDP_APB_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x82 << 2))
+#define     HHI_VPU_CLKB_CNTL                                  (0xc883c000 + (0x83 << 2))
+#define SEC_HHI_VPU_CLKB_CNTL                                  (0xda83c000 + (0x83 << 2))
+#define   P_HHI_VPU_CLKB_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x83 << 2))
+#define     HHI_VID_PLL_MOD_CNTL0                              (0xc883c000 + (0x84 << 2))
+#define SEC_HHI_VID_PLL_MOD_CNTL0                              (0xda83c000 + (0x84 << 2))
+#define   P_HHI_VID_PLL_MOD_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0x84 << 2))
+#define     HHI_VID_PLL_MOD_LOW_TCNT                           (0xc883c000 + (0x85 << 2))
+#define SEC_HHI_VID_PLL_MOD_LOW_TCNT                           (0xda83c000 + (0x85 << 2))
+#define   P_HHI_VID_PLL_MOD_LOW_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x85 << 2))
+#define     HHI_VID_PLL_MOD_HIGH_TCNT                          (0xc883c000 + (0x86 << 2))
+#define SEC_HHI_VID_PLL_MOD_HIGH_TCNT                          (0xda83c000 + (0x86 << 2))
+#define   P_HHI_VID_PLL_MOD_HIGH_TCNT                          (volatile uint32_t *)(0xc883c000 + (0x86 << 2))
+#define     HHI_VID_PLL_MOD_NOM_TCNT                           (0xc883c000 + (0x87 << 2))
+#define SEC_HHI_VID_PLL_MOD_NOM_TCNT                           (0xda83c000 + (0x87 << 2))
+#define   P_HHI_VID_PLL_MOD_NOM_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x87 << 2))
+#define     HHI_USB_CLK_CNTL                                   (0xc883c000 + (0x88 << 2))
+#define SEC_HHI_USB_CLK_CNTL                                   (0xda83c000 + (0x88 << 2))
+#define   P_HHI_USB_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x88 << 2))
+// Removed `define HHI_DDR_CLK_CNTL            8'h88
+#define     HHI_32K_CLK_CNTL                                   (0xc883c000 + (0x89 << 2))
+#define SEC_HHI_32K_CLK_CNTL                                   (0xda83c000 + (0x89 << 2))
+#define   P_HHI_32K_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x89 << 2))
+#define     HHI_GEN_CLK_CNTL                                   (0xc883c000 + (0x8a << 2))
+#define SEC_HHI_GEN_CLK_CNTL                                   (0xda83c000 + (0x8a << 2))
+#define   P_HHI_GEN_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x8a << 2))
+#define     HHI_GEN_CLK_CNTL2                                  (0xc883c000 + (0x8b << 2))
+#define SEC_HHI_GEN_CLK_CNTL2                                  (0xda83c000 + (0x8b << 2))
+#define   P_HHI_GEN_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x8b << 2))
+#define     HHI_JTAG_CONFIG                                    (0xc883c000 + (0x8e << 2))
+#define SEC_HHI_JTAG_CONFIG                                    (0xda83c000 + (0x8e << 2))
+#define   P_HHI_JTAG_CONFIG                                    (volatile uint32_t *)(0xc883c000 + (0x8e << 2))
+#define     HHI_VAFE_CLKXTALIN_CNTL                            (0xc883c000 + (0x8f << 2))
+#define SEC_HHI_VAFE_CLKXTALIN_CNTL                            (0xda83c000 + (0x8f << 2))
+#define   P_HHI_VAFE_CLKXTALIN_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x8f << 2))
+#define     HHI_VAFE_CLKOSCIN_CNTL                             (0xc883c000 + (0x90 << 2))
+#define SEC_HHI_VAFE_CLKOSCIN_CNTL                             (0xda83c000 + (0x90 << 2))
+#define   P_HHI_VAFE_CLKOSCIN_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x90 << 2))
+#define     HHI_VAFE_CLKIN_CNTL                                (0xc883c000 + (0x91 << 2))
+#define SEC_HHI_VAFE_CLKIN_CNTL                                (0xda83c000 + (0x91 << 2))
+#define   P_HHI_VAFE_CLKIN_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x91 << 2))
+#define     HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xc883c000 + (0x92 << 2))
+#define SEC_HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xda83c000 + (0x92 << 2))
+#define   P_HHI_TVFE_AUTOMODE_CLK_CNTL                         (volatile uint32_t *)(0xc883c000 + (0x92 << 2))
+#define     HHI_VAFE_CLKPI_CNTL                                (0xc883c000 + (0x93 << 2))
+#define SEC_HHI_VAFE_CLKPI_CNTL                                (0xda83c000 + (0x93 << 2))
+#define   P_HHI_VAFE_CLKPI_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x93 << 2))
+#define     HHI_VDIN_MEAS_CLK_CNTL                             (0xc883c000 + (0x94 << 2))
+#define SEC_HHI_VDIN_MEAS_CLK_CNTL                             (0xda83c000 + (0x94 << 2))
+#define   P_HHI_VDIN_MEAS_CLK_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x94 << 2))
+// `define HHI_PCM2_CLK_CNTL           8'h95
+#define     HHI_PCM_CLK_CNTL                                   (0xc883c000 + (0x96 << 2))
+#define SEC_HHI_PCM_CLK_CNTL                                   (0xda83c000 + (0x96 << 2))
+#define   P_HHI_PCM_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x96 << 2))
+#define     HHI_NAND_CLK_CNTL                                  (0xc883c000 + (0x97 << 2))
+#define SEC_HHI_NAND_CLK_CNTL                                  (0xda83c000 + (0x97 << 2))
+#define   P_HHI_NAND_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x97 << 2))
+#define     HHI_ISP_LED_CLK_CNTL                               (0xc883c000 + (0x98 << 2))
+#define SEC_HHI_ISP_LED_CLK_CNTL                               (0xda83c000 + (0x98 << 2))
+#define   P_HHI_ISP_LED_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x98 << 2))
+#define     HHI_SD_EMMC_CLK_CNTL                               (0xc883c000 + (0x99 << 2))
+#define SEC_HHI_SD_EMMC_CLK_CNTL                               (0xda83c000 + (0x99 << 2))
+#define   P_HHI_SD_EMMC_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x99 << 2))
+#define     HHI_EDP_TX_PHY_CNTL0                               (0xc883c000 + (0x9c << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL0                               (0xda83c000 + (0x9c << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL0                               (volatile uint32_t *)(0xc883c000 + (0x9c << 2))
+#define     HHI_EDP_TX_PHY_CNTL1                               (0xc883c000 + (0x9d << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL1                               (0xda83c000 + (0x9d << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL1                               (volatile uint32_t *)(0xc883c000 + (0x9d << 2))
+#define     HHI_MPLL_CNTL                                      (0xc883c000 + (0xa0 << 2))
+#define SEC_HHI_MPLL_CNTL                                      (0xda83c000 + (0xa0 << 2))
+#define   P_HHI_MPLL_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0xa0 << 2))
+#define     HHI_MPLL_CNTL2                                     (0xc883c000 + (0xa1 << 2))
+#define SEC_HHI_MPLL_CNTL2                                     (0xda83c000 + (0xa1 << 2))
+#define   P_HHI_MPLL_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0xa1 << 2))
+#define     HHI_MPLL_CNTL3                                     (0xc883c000 + (0xa2 << 2))
+#define SEC_HHI_MPLL_CNTL3                                     (0xda83c000 + (0xa2 << 2))
+#define   P_HHI_MPLL_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0xa2 << 2))
+#define     HHI_MPLL_CNTL4                                     (0xc883c000 + (0xa3 << 2))
+#define SEC_HHI_MPLL_CNTL4                                     (0xda83c000 + (0xa3 << 2))
+#define   P_HHI_MPLL_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0xa3 << 2))
+#define     HHI_MPLL_CNTL5                                     (0xc883c000 + (0xa4 << 2))
+#define SEC_HHI_MPLL_CNTL5                                     (0xda83c000 + (0xa4 << 2))
+#define   P_HHI_MPLL_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0xa4 << 2))
+#define     HHI_MPLL_CNTL6                                     (0xc883c000 + (0xa5 << 2))
+#define SEC_HHI_MPLL_CNTL6                                     (0xda83c000 + (0xa5 << 2))
+#define   P_HHI_MPLL_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0xa5 << 2))
+#define     HHI_MPLL_CNTL7                                     (0xc883c000 + (0xa6 << 2))
+#define SEC_HHI_MPLL_CNTL7                                     (0xda83c000 + (0xa6 << 2))
+#define   P_HHI_MPLL_CNTL7                                     (volatile uint32_t *)(0xc883c000 + (0xa6 << 2))
+#define     HHI_MPLL_CNTL8                                     (0xc883c000 + (0xa7 << 2))
+#define SEC_HHI_MPLL_CNTL8                                     (0xda83c000 + (0xa7 << 2))
+#define   P_HHI_MPLL_CNTL8                                     (volatile uint32_t *)(0xc883c000 + (0xa7 << 2))
+#define     HHI_MPLL_CNTL9                                     (0xc883c000 + (0xa8 << 2))
+#define SEC_HHI_MPLL_CNTL9                                     (0xda83c000 + (0xa8 << 2))
+#define   P_HHI_MPLL_CNTL9                                     (volatile uint32_t *)(0xc883c000 + (0xa8 << 2))
+#define     HHI_MPLL_CNTL10                                    (0xc883c000 + (0xa9 << 2))
+#define SEC_HHI_MPLL_CNTL10                                    (0xda83c000 + (0xa9 << 2))
+#define   P_HHI_MPLL_CNTL10                                    (volatile uint32_t *)(0xc883c000 + (0xa9 << 2))
+#define     HHI_ADC_PLL_CNTL                                   (0xc883c000 + (0xaa << 2))
+#define SEC_HHI_ADC_PLL_CNTL                                   (0xda83c000 + (0xaa << 2))
+#define   P_HHI_ADC_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xaa << 2))
+#define     HHI_ADC_PLL_CNTL2                                  (0xc883c000 + (0xab << 2))
+#define SEC_HHI_ADC_PLL_CNTL2                                  (0xda83c000 + (0xab << 2))
+#define   P_HHI_ADC_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xab << 2))
+#define     HHI_ADC_PLL_CNTL3                                  (0xc883c000 + (0xac << 2))
+#define SEC_HHI_ADC_PLL_CNTL3                                  (0xda83c000 + (0xac << 2))
+#define   P_HHI_ADC_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xac << 2))
+#define     HHI_ADC_PLL_CNTL4                                  (0xc883c000 + (0xad << 2))
+#define SEC_HHI_ADC_PLL_CNTL4                                  (0xda83c000 + (0xad << 2))
+#define   P_HHI_ADC_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xad << 2))
+#define     HHI_ADC_PLL_CNTL_I                                 (0xc883c000 + (0xae << 2))
+#define SEC_HHI_ADC_PLL_CNTL_I                                 (0xda83c000 + (0xae << 2))
+#define   P_HHI_ADC_PLL_CNTL_I                                 (volatile uint32_t *)(0xc883c000 + (0xae << 2))
+#define     HHI_AUDCLK_PLL_CNTL                                (0xc883c000 + (0xb0 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL                                (0xda83c000 + (0xb0 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb0 << 2))
+#define     HHI_AUDCLK_PLL_CNTL2                               (0xc883c000 + (0xb1 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL2                               (0xda83c000 + (0xb1 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL2                               (volatile uint32_t *)(0xc883c000 + (0xb1 << 2))
+#define     HHI_AUDCLK_PLL_CNTL3                               (0xc883c000 + (0xb2 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL3                               (0xda83c000 + (0xb2 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL3                               (volatile uint32_t *)(0xc883c000 + (0xb2 << 2))
+#define     HHI_AUDCLK_PLL_CNTL4                               (0xc883c000 + (0xb3 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL4                               (0xda83c000 + (0xb3 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL4                               (volatile uint32_t *)(0xc883c000 + (0xb3 << 2))
+#define     HHI_AUDCLK_PLL_CNTL5                               (0xc883c000 + (0xb4 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL5                               (0xda83c000 + (0xb4 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL5                               (volatile uint32_t *)(0xc883c000 + (0xb4 << 2))
+#define     HHI_AUDCLK_PLL_CNTL6                               (0xc883c000 + (0xb5 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL6                               (0xda83c000 + (0xb5 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL6                               (volatile uint32_t *)(0xc883c000 + (0xb5 << 2))
+#define     HHI_L2_DDR_CLK_CNTL                                (0xc883c000 + (0xb6 << 2))
+#define SEC_HHI_L2_DDR_CLK_CNTL                                (0xda83c000 + (0xb6 << 2))
+#define   P_HHI_L2_DDR_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb6 << 2))
+#define     HHI_MPLL3_CNTL0                                    (0xc883c000 + (0xb8 << 2))
+#define SEC_HHI_MPLL3_CNTL0                                    (0xda83c000 + (0xb8 << 2))
+#define   P_HHI_MPLL3_CNTL0                                    (volatile uint32_t *)(0xc883c000 + (0xb8 << 2))
+#define     HHI_MPLL3_CNTL1                                    (0xc883c000 + (0xb9 << 2))
+#define SEC_HHI_MPLL3_CNTL1                                    (0xda83c000 + (0xb9 << 2))
+#define   P_HHI_MPLL3_CNTL1                                    (volatile uint32_t *)(0xc883c000 + (0xb9 << 2))
+#define     HHI_VDAC_CNTL0                                     (0xc883c000 + (0xbd << 2))
+#define SEC_HHI_VDAC_CNTL0                                     (0xda83c000 + (0xbd << 2))
+#define   P_HHI_VDAC_CNTL0                                     (volatile uint32_t *)(0xc883c000 + (0xbd << 2))
+#define     HHI_VDAC_CNTL1                                     (0xc883c000 + (0xbe << 2))
+#define SEC_HHI_VDAC_CNTL1                                     (0xda83c000 + (0xbe << 2))
+#define   P_HHI_VDAC_CNTL1                                     (volatile uint32_t *)(0xc883c000 + (0xbe << 2))
+#define     HHI_SYS_PLL_CNTL                                   (0xc883c000 + (0xc0 << 2))
+#define SEC_HHI_SYS_PLL_CNTL                                   (0xda83c000 + (0xc0 << 2))
+#define   P_HHI_SYS_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xc0 << 2))
+#define     HHI_SYS_PLL_CNTL2                                  (0xc883c000 + (0xc1 << 2))
+#define SEC_HHI_SYS_PLL_CNTL2                                  (0xda83c000 + (0xc1 << 2))
+#define   P_HHI_SYS_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xc1 << 2))
+#define     HHI_SYS_PLL_CNTL3                                  (0xc883c000 + (0xc2 << 2))
+#define SEC_HHI_SYS_PLL_CNTL3                                  (0xda83c000 + (0xc2 << 2))
+#define   P_HHI_SYS_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xc2 << 2))
+#define     HHI_SYS_PLL_CNTL4                                  (0xc883c000 + (0xc3 << 2))
+#define SEC_HHI_SYS_PLL_CNTL4                                  (0xda83c000 + (0xc3 << 2))
+#define   P_HHI_SYS_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xc3 << 2))
+#define     HHI_SYS_PLL_CNTL5                                  (0xc883c000 + (0xc4 << 2))
+#define SEC_HHI_SYS_PLL_CNTL5                                  (0xda83c000 + (0xc4 << 2))
+#define   P_HHI_SYS_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0xc4 << 2))
+#define     HHI_DPLL_TOP_I                                     (0xc883c000 + (0xc6 << 2))
+#define SEC_HHI_DPLL_TOP_I                                     (0xda83c000 + (0xc6 << 2))
+#define   P_HHI_DPLL_TOP_I                                     (volatile uint32_t *)(0xc883c000 + (0xc6 << 2))
+#define     HHI_DPLL_TOP2_I                                    (0xc883c000 + (0xc7 << 2))
+#define SEC_HHI_DPLL_TOP2_I                                    (0xda83c000 + (0xc7 << 2))
+#define   P_HHI_DPLL_TOP2_I                                    (volatile uint32_t *)(0xc883c000 + (0xc7 << 2))
+#define     HHI_HDMI_PLL_CNTL                                  (0xc883c000 + (0xc8 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL                                  (0xda83c000 + (0xc8 << 2))
+#define   P_HHI_HDMI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xc8 << 2))
+#define     HHI_HDMI_PLL_CNTL2                                 (0xc883c000 + (0xc9 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL2                                 (0xda83c000 + (0xc9 << 2))
+#define   P_HHI_HDMI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xc9 << 2))
+#define     HHI_HDMI_PLL_CNTL3                                 (0xc883c000 + (0xca << 2))
+#define SEC_HHI_HDMI_PLL_CNTL3                                 (0xda83c000 + (0xca << 2))
+#define   P_HHI_HDMI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xca << 2))
+#define     HHI_HDMI_PLL_CNTL4                                 (0xc883c000 + (0xcb << 2))
+#define SEC_HHI_HDMI_PLL_CNTL4                                 (0xda83c000 + (0xcb << 2))
+#define   P_HHI_HDMI_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xcb << 2))
+#define     HHI_HDMI_PLL_CNTL5                                 (0xc883c000 + (0xcc << 2))
+#define SEC_HHI_HDMI_PLL_CNTL5                                 (0xda83c000 + (0xcc << 2))
+#define   P_HHI_HDMI_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xcc << 2))
+#define     HHI_HDMI_PLL_CNTL6                                 (0xc883c000 + (0xcd << 2))
+#define SEC_HHI_HDMI_PLL_CNTL6                                 (0xda83c000 + (0xcd << 2))
+#define   P_HHI_HDMI_PLL_CNTL6                                 (volatile uint32_t *)(0xc883c000 + (0xcd << 2))
+#define     HHI_HDMI_PLL_CNTL_I                                (0xc883c000 + (0xce << 2))
+#define SEC_HHI_HDMI_PLL_CNTL_I                                (0xda83c000 + (0xce << 2))
+#define   P_HHI_HDMI_PLL_CNTL_I                                (volatile uint32_t *)(0xc883c000 + (0xce << 2))
+#define     HHI_HDMI_PLL_CNTL7                                 (0xc883c000 + (0xcf << 2))
+#define SEC_HHI_HDMI_PLL_CNTL7                                 (0xda83c000 + (0xcf << 2))
+#define   P_HHI_HDMI_PLL_CNTL7                                 (volatile uint32_t *)(0xc883c000 + (0xcf << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL0                             (0xc883c000 + (0xd1 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL0                             (0xda83c000 + (0xd1 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL0                             (volatile uint32_t *)(0xc883c000 + (0xd1 << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL1                             (0xc883c000 + (0xd2 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL1                             (0xda83c000 + (0xd2 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL1                             (volatile uint32_t *)(0xc883c000 + (0xd2 << 2))
+#define     HHI_CSI_PHY_CNTL0                                  (0xc883c000 + (0xd3 << 2))
+#define SEC_HHI_CSI_PHY_CNTL0                                  (0xda83c000 + (0xd3 << 2))
+#define   P_HHI_CSI_PHY_CNTL0                                  (volatile uint32_t *)(0xc883c000 + (0xd3 << 2))
+#define     HHI_CSI_PHY_CNTL1                                  (0xc883c000 + (0xd4 << 2))
+#define SEC_HHI_CSI_PHY_CNTL1                                  (0xda83c000 + (0xd4 << 2))
+#define   P_HHI_CSI_PHY_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xd4 << 2))
+#define     HHI_CSI_PHY_CNTL2                                  (0xc883c000 + (0xd5 << 2))
+#define SEC_HHI_CSI_PHY_CNTL2                                  (0xda83c000 + (0xd5 << 2))
+#define   P_HHI_CSI_PHY_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xd5 << 2))
+#define     HHI_CSI_PHY_CNTL3                                  (0xc883c000 + (0xd6 << 2))
+#define SEC_HHI_CSI_PHY_CNTL3                                  (0xda83c000 + (0xd6 << 2))
+#define   P_HHI_CSI_PHY_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xd6 << 2))
+#define     HHI_CSI_PHY_CNTL4                                  (0xc883c000 + (0xd7 << 2))
+#define SEC_HHI_CSI_PHY_CNTL4                                  (0xda83c000 + (0xd7 << 2))
+#define   P_HHI_CSI_PHY_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xd7 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL0                              (0xc883c000 + (0xd8 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL0                              (0xda83c000 + (0xd8 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xd8 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL1                              (0xc883c000 + (0xd9 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL1                              (0xda83c000 + (0xd9 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xd9 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL2                              (0xc883c000 + (0xda << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL2                              (0xda83c000 + (0xda << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL2                              (volatile uint32_t *)(0xc883c000 + (0xda << 2))
+#define     HHI_DIF_CSI_PHY_CNTL3                              (0xc883c000 + (0xdb << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL3                              (0xda83c000 + (0xdb << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL3                              (volatile uint32_t *)(0xc883c000 + (0xdb << 2))
+#define     HHI_DIF_CSI_PHY_CNTL4                              (0xc883c000 + (0xdc << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL4                              (0xda83c000 + (0xdc << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL4                              (volatile uint32_t *)(0xc883c000 + (0xdc << 2))
+#define     HHI_DIF_CSI_PHY_CNTL5                              (0xc883c000 + (0xdd << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL5                              (0xda83c000 + (0xdd << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL5                              (volatile uint32_t *)(0xc883c000 + (0xdd << 2))
+#define     HHI_LVDS_TX_PHY_CNTL0                              (0xc883c000 + (0xde << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL0                              (0xda83c000 + (0xde << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xde << 2))
+#define     HHI_LVDS_TX_PHY_CNTL1                              (0xc883c000 + (0xdf << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL1                              (0xda83c000 + (0xdf << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xdf << 2))
+#define     HHI_VID2_PLL_CNTL                                  (0xc883c000 + (0xe0 << 2))
+#define SEC_HHI_VID2_PLL_CNTL                                  (0xda83c000 + (0xe0 << 2))
+#define   P_HHI_VID2_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xe0 << 2))
+#define     HHI_VID2_PLL_CNTL2                                 (0xc883c000 + (0xe1 << 2))
+#define SEC_HHI_VID2_PLL_CNTL2                                 (0xda83c000 + (0xe1 << 2))
+#define   P_HHI_VID2_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xe1 << 2))
+#define     HHI_VID2_PLL_CNTL3                                 (0xc883c000 + (0xe2 << 2))
+#define SEC_HHI_VID2_PLL_CNTL3                                 (0xda83c000 + (0xe2 << 2))
+#define   P_HHI_VID2_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xe2 << 2))
+#define     HHI_VID2_PLL_CNTL4                                 (0xc883c000 + (0xe3 << 2))
+#define SEC_HHI_VID2_PLL_CNTL4                                 (0xda83c000 + (0xe3 << 2))
+#define   P_HHI_VID2_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xe3 << 2))
+#define     HHI_VID2_PLL_CNTL5                                 (0xc883c000 + (0xe4 << 2))
+#define SEC_HHI_VID2_PLL_CNTL5                                 (0xda83c000 + (0xe4 << 2))
+#define   P_HHI_VID2_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xe4 << 2))
+#define     HHI_VID2_PLL_CNTL_I                                (0xc883c000 + (0xe5 << 2))
+#define SEC_HHI_VID2_PLL_CNTL_I                                (0xda83c000 + (0xe5 << 2))
+#define   P_HHI_VID2_PLL_CNTL_I                                (volatile uint32_t *)(0xc883c000 + (0xe5 << 2))
+#define     HHI_HDMI_PHY_CNTL0                                 (0xc883c000 + (0xe8 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL0                                 (0xda83c000 + (0xe8 << 2))
+#define   P_HHI_HDMI_PHY_CNTL0                                 (volatile uint32_t *)(0xc883c000 + (0xe8 << 2))
+#define     HHI_HDMI_PHY_CNTL1                                 (0xc883c000 + (0xe9 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL1                                 (0xda83c000 + (0xe9 << 2))
+#define   P_HHI_HDMI_PHY_CNTL1                                 (volatile uint32_t *)(0xc883c000 + (0xe9 << 2))
+#define     HHI_HDMI_PHY_CNTL2                                 (0xc883c000 + (0xea << 2))
+#define SEC_HHI_HDMI_PHY_CNTL2                                 (0xda83c000 + (0xea << 2))
+#define   P_HHI_HDMI_PHY_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xea << 2))
+#define     HHI_HDMI_PHY_CNTL3                                 (0xc883c000 + (0xeb << 2))
+#define SEC_HHI_HDMI_PHY_CNTL3                                 (0xda83c000 + (0xeb << 2))
+#define   P_HHI_HDMI_PHY_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xeb << 2))
+#define     HHI_VID_LOCK_CLK_CNTL                              (0xc883c000 + (0xf2 << 2))
+#define SEC_HHI_VID_LOCK_CLK_CNTL                              (0xda83c000 + (0xf2 << 2))
+#define   P_HHI_VID_LOCK_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0xf2 << 2))
+#define     HHI_ATV_DMD_SYS_CLK_CNTL                           (0xc883c000 + (0xf3 << 2))
+#define SEC_HHI_ATV_DMD_SYS_CLK_CNTL                           (0xda83c000 + (0xf3 << 2))
+#define   P_HHI_ATV_DMD_SYS_CLK_CNTL                           (volatile uint32_t *)(0xc883c000 + (0xf3 << 2))
+// `define HHI_EE_MISC_CNTL            8'hf4
+#define     HHI_BT656_CLK_CNTL                                 (0xc883c000 + (0xf5 << 2))
+#define SEC_HHI_BT656_CLK_CNTL                                 (0xda83c000 + (0xf5 << 2))
+#define   P_HHI_BT656_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0xf5 << 2))
+#define     HHI_SAR_CLK_CNTL                                   (0xc883c000 + (0xf6 << 2))
+#define SEC_HHI_SAR_CLK_CNTL                                   (0xda83c000 + (0xf6 << 2))
+#define   P_HHI_SAR_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xf6 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL                            (0xc883c000 + (0xf8 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL                            (0xda83c000 + (0xf8 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL                            (volatile uint32_t *)(0xc883c000 + (0xf8 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL2                           (0xc883c000 + (0xf9 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL2                           (0xda83c000 + (0xf9 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL2                           (volatile uint32_t *)(0xc883c000 + (0xf9 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL3                           (0xc883c000 + (0xfa << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL3                           (0xda83c000 + (0xfa << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL3                           (volatile uint32_t *)(0xc883c000 + (0xfa << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL4                           (0xc883c000 + (0xfb << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL4                           (0xda83c000 + (0xfb << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL4                           (volatile uint32_t *)(0xc883c000 + (0xfb << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL5                           (0xc883c000 + (0xfc << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL5                           (0xda83c000 + (0xfc << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL5                           (volatile uint32_t *)(0xc883c000 + (0xfc << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL6                           (0xc883c000 + (0xfd << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL6                           (0xda83c000 + (0xfd << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL6                           (volatile uint32_t *)(0xc883c000 + (0xfd << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xc883c000 + (0xfe << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xda83c000 + (0xfe << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL_I                          (volatile uint32_t *)(0xc883c000 + (0xfe << 2))
+//========================================================================
+//  HIU - Mailbox
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C400
+// APB4_DECODER_SECURE_BASE         32'hDA83C400
+#define     HIU_MAILBOX_SET_0                                  (0xc883c400 + (0x01 << 2))
+#define SEC_HIU_MAILBOX_SET_0                                  (0xda83c400 + (0x01 << 2))
+#define   P_HIU_MAILBOX_SET_0                                  (volatile uint32_t *)(0xc883c400 + (0x01 << 2))
+#define     HIU_MAILBOX_STAT_0                                 (0xc883c400 + (0x02 << 2))
+#define SEC_HIU_MAILBOX_STAT_0                                 (0xda83c400 + (0x02 << 2))
+#define   P_HIU_MAILBOX_STAT_0                                 (volatile uint32_t *)(0xc883c400 + (0x02 << 2))
+#define     HIU_MAILBOX_CLR_0                                  (0xc883c400 + (0x03 << 2))
+#define SEC_HIU_MAILBOX_CLR_0                                  (0xda83c400 + (0x03 << 2))
+#define   P_HIU_MAILBOX_CLR_0                                  (volatile uint32_t *)(0xc883c400 + (0x03 << 2))
+#define     HIU_MAILBOX_SET_1                                  (0xc883c400 + (0x04 << 2))
+#define SEC_HIU_MAILBOX_SET_1                                  (0xda83c400 + (0x04 << 2))
+#define   P_HIU_MAILBOX_SET_1                                  (volatile uint32_t *)(0xc883c400 + (0x04 << 2))
+#define     HIU_MAILBOX_STAT_1                                 (0xc883c400 + (0x05 << 2))
+#define SEC_HIU_MAILBOX_STAT_1                                 (0xda83c400 + (0x05 << 2))
+#define   P_HIU_MAILBOX_STAT_1                                 (volatile uint32_t *)(0xc883c400 + (0x05 << 2))
+#define     HIU_MAILBOX_CLR_1                                  (0xc883c400 + (0x06 << 2))
+#define SEC_HIU_MAILBOX_CLR_1                                  (0xda83c400 + (0x06 << 2))
+#define   P_HIU_MAILBOX_CLR_1                                  (volatile uint32_t *)(0xc883c400 + (0x06 << 2))
+#define     HIU_MAILBOX_SET_2                                  (0xc883c400 + (0x07 << 2))
+#define SEC_HIU_MAILBOX_SET_2                                  (0xda83c400 + (0x07 << 2))
+#define   P_HIU_MAILBOX_SET_2                                  (volatile uint32_t *)(0xc883c400 + (0x07 << 2))
+#define     HIU_MAILBOX_STAT_2                                 (0xc883c400 + (0x08 << 2))
+#define SEC_HIU_MAILBOX_STAT_2                                 (0xda83c400 + (0x08 << 2))
+#define   P_HIU_MAILBOX_STAT_2                                 (volatile uint32_t *)(0xc883c400 + (0x08 << 2))
+#define     HIU_MAILBOX_CLR_2                                  (0xc883c400 + (0x09 << 2))
+#define SEC_HIU_MAILBOX_CLR_2                                  (0xda83c400 + (0x09 << 2))
+#define   P_HIU_MAILBOX_CLR_2                                  (volatile uint32_t *)(0xc883c400 + (0x09 << 2))
+#define     HIU_MAILBOX_SET_3                                  (0xc883c400 + (0x0a << 2))
+#define SEC_HIU_MAILBOX_SET_3                                  (0xda83c400 + (0x0a << 2))
+#define   P_HIU_MAILBOX_SET_3                                  (volatile uint32_t *)(0xc883c400 + (0x0a << 2))
+#define     HIU_MAILBOX_STAT_3                                 (0xc883c400 + (0x0b << 2))
+#define SEC_HIU_MAILBOX_STAT_3                                 (0xda83c400 + (0x0b << 2))
+#define   P_HIU_MAILBOX_STAT_3                                 (volatile uint32_t *)(0xc883c400 + (0x0b << 2))
+#define     HIU_MAILBOX_CLR_3                                  (0xc883c400 + (0x0c << 2))
+#define SEC_HIU_MAILBOX_CLR_3                                  (0xda83c400 + (0x0c << 2))
+#define   P_HIU_MAILBOX_CLR_3                                  (volatile uint32_t *)(0xc883c400 + (0x0c << 2))
+#define     HIU_MAILBOX_SET_4                                  (0xc883c400 + (0x0d << 2))
+#define SEC_HIU_MAILBOX_SET_4                                  (0xda83c400 + (0x0d << 2))
+#define   P_HIU_MAILBOX_SET_4                                  (volatile uint32_t *)(0xc883c400 + (0x0d << 2))
+#define     HIU_MAILBOX_STAT_4                                 (0xc883c400 + (0x0e << 2))
+#define SEC_HIU_MAILBOX_STAT_4                                 (0xda83c400 + (0x0e << 2))
+#define   P_HIU_MAILBOX_STAT_4                                 (volatile uint32_t *)(0xc883c400 + (0x0e << 2))
+#define     HIU_MAILBOX_CLR_4                                  (0xc883c400 + (0x0f << 2))
+#define SEC_HIU_MAILBOX_CLR_4                                  (0xda83c400 + (0x0f << 2))
+#define   P_HIU_MAILBOX_CLR_4                                  (volatile uint32_t *)(0xc883c400 + (0x0f << 2))
+#define     HIU_MAILBOX_SET_5                                  (0xc883c400 + (0x10 << 2))
+#define SEC_HIU_MAILBOX_SET_5                                  (0xda83c400 + (0x10 << 2))
+#define   P_HIU_MAILBOX_SET_5                                  (volatile uint32_t *)(0xc883c400 + (0x10 << 2))
+#define     HIU_MAILBOX_STAT_5                                 (0xc883c400 + (0x11 << 2))
+#define SEC_HIU_MAILBOX_STAT_5                                 (0xda83c400 + (0x11 << 2))
+#define   P_HIU_MAILBOX_STAT_5                                 (volatile uint32_t *)(0xc883c400 + (0x11 << 2))
+#define     HIU_MAILBOX_CLR_5                                  (0xc883c400 + (0x12 << 2))
+#define SEC_HIU_MAILBOX_CLR_5                                  (0xda83c400 + (0x12 << 2))
+#define   P_HIU_MAILBOX_CLR_5                                  (volatile uint32_t *)(0xc883c400 + (0x12 << 2))
+//========================================================================
+//  EFUSE
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8830000
+//  APB4_DECODER_SECURE_BASE         32'hDA830000
+#define     EFUSE_CNTL0                                        (0xc8830000 + (0x00 << 2))
+#define SEC_EFUSE_CNTL0                                        (0xda830000 + (0x00 << 2))
+#define   P_EFUSE_CNTL0                                        (volatile uint32_t *)(0xc8830000 + (0x00 << 2))
+#define     EFUSE_CNTL1                                        (0xc8830000 + (0x01 << 2))
+#define SEC_EFUSE_CNTL1                                        (0xda830000 + (0x01 << 2))
+#define   P_EFUSE_CNTL1                                        (volatile uint32_t *)(0xc8830000 + (0x01 << 2))
+#define     EFUSE_CNTL2                                        (0xc8830000 + (0x02 << 2))
+#define SEC_EFUSE_CNTL2                                        (0xda830000 + (0x02 << 2))
+#define   P_EFUSE_CNTL2                                        (volatile uint32_t *)(0xc8830000 + (0x02 << 2))
+#define     EFUSE_CNTL3                                        (0xc8830000 + (0x03 << 2))
+#define SEC_EFUSE_CNTL3                                        (0xda830000 + (0x03 << 2))
+#define   P_EFUSE_CNTL3                                        (volatile uint32_t *)(0xc8830000 + (0x03 << 2))
+#define     EFUSE_CNTL4                                        (0xc8830000 + (0x04 << 2))
+#define SEC_EFUSE_CNTL4                                        (0xda830000 + (0x04 << 2))
+#define   P_EFUSE_CNTL4                                        (volatile uint32_t *)(0xc8830000 + (0x04 << 2))
+#define     EFUSE_WDATA0                                       (0xc8830000 + (0x05 << 2))
+#define SEC_EFUSE_WDATA0                                       (0xda830000 + (0x05 << 2))
+#define   P_EFUSE_WDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x05 << 2))
+#define     EFUSE_WDATA1                                       (0xc8830000 + (0x06 << 2))
+#define SEC_EFUSE_WDATA1                                       (0xda830000 + (0x06 << 2))
+#define   P_EFUSE_WDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x06 << 2))
+#define     EFUSE_WDATA2                                       (0xc8830000 + (0x07 << 2))
+#define SEC_EFUSE_WDATA2                                       (0xda830000 + (0x07 << 2))
+#define   P_EFUSE_WDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x07 << 2))
+#define     EFUSE_WDATA3                                       (0xc8830000 + (0x08 << 2))
+#define SEC_EFUSE_WDATA3                                       (0xda830000 + (0x08 << 2))
+#define   P_EFUSE_WDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x08 << 2))
+#define     EFUSE_RDATA0                                       (0xc8830000 + (0x09 << 2))
+#define SEC_EFUSE_RDATA0                                       (0xda830000 + (0x09 << 2))
+#define   P_EFUSE_RDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x09 << 2))
+#define     EFUSE_RDATA1                                       (0xc8830000 + (0x0a << 2))
+#define SEC_EFUSE_RDATA1                                       (0xda830000 + (0x0a << 2))
+#define   P_EFUSE_RDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x0a << 2))
+#define     EFUSE_RDATA2                                       (0xc8830000 + (0x0b << 2))
+#define SEC_EFUSE_RDATA2                                       (0xda830000 + (0x0b << 2))
+#define   P_EFUSE_RDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x0b << 2))
+#define     EFUSE_RDATA3                                       (0xc8830000 + (0x0c << 2))
+#define SEC_EFUSE_RDATA3                                       (0xda830000 + (0x0c << 2))
+#define   P_EFUSE_RDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x0c << 2))
+#define     EFUSE_RD_DISABLE                                   (0xc8830000 + (0x10 << 2))
+#define SEC_EFUSE_RD_DISABLE                                   (0xda830000 + (0x10 << 2))
+#define   P_EFUSE_RD_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x10 << 2))
+#define     EFUSE_WR_DISABLE                                   (0xc8830000 + (0x11 << 2))
+#define SEC_EFUSE_WR_DISABLE                                   (0xda830000 + (0x11 << 2))
+#define   P_EFUSE_WR_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x11 << 2))
+#define     EFUSE_OBFUSCATE                                    (0xc8830000 + (0x12 << 2))
+#define SEC_EFUSE_OBFUSCATE                                    (0xda830000 + (0x12 << 2))
+#define   P_EFUSE_OBFUSCATE                                    (volatile uint32_t *)(0xc8830000 + (0x12 << 2))
+#define     EFUSE_AES_KEY32                                    (0xc8830000 + (0x13 << 2))
+#define SEC_EFUSE_AES_KEY32                                    (0xda830000 + (0x13 << 2))
+#define   P_EFUSE_AES_KEY32                                    (volatile uint32_t *)(0xc8830000 + (0x13 << 2))
+#define     KEY_LDR_USR_CNTL                                   (0xc8830000 + (0x20 << 2))
+#define SEC_KEY_LDR_USR_CNTL                                   (0xda830000 + (0x20 << 2))
+#define   P_KEY_LDR_USR_CNTL                                   (volatile uint32_t *)(0xc8830000 + (0x20 << 2))
+#define     KEY_LDR_USR_RAM_W                                  (0xc8830000 + (0x21 << 2))
+#define SEC_KEY_LDR_USR_RAM_W                                  (0xda830000 + (0x21 << 2))
+#define   P_KEY_LDR_USR_RAM_W                                  (volatile uint32_t *)(0xc8830000 + (0x21 << 2))
+#define     KEY_LDR_VENDOR_ID                                  (0xc8830000 + (0x22 << 2))
+#define SEC_KEY_LDR_VENDOR_ID                                  (0xda830000 + (0x22 << 2))
+#define   P_KEY_LDR_VENDOR_ID                                  (volatile uint32_t *)(0xc8830000 + (0x22 << 2))
+#define     KEY_LDR_SEC_REG0                                   (0xc8830000 + (0x23 << 2))
+#define SEC_KEY_LDR_SEC_REG0                                   (0xda830000 + (0x23 << 2))
+#define   P_KEY_LDR_SEC_REG0                                   (volatile uint32_t *)(0xc8830000 + (0x23 << 2))
+#define     KEY_LDR_SEC_CFG                                    (0xc8830000 + (0x24 << 2))
+#define SEC_KEY_LDR_SEC_CFG                                    (0xda830000 + (0x24 << 2))
+#define   P_KEY_LDR_SEC_CFG                                    (volatile uint32_t *)(0xc8830000 + (0x24 << 2))
+#define     KEY_LDR_SEC_BLK_NUM                                (0xc8830000 + (0x25 << 2))
+#define SEC_KEY_LDR_SEC_BLK_NUM                                (0xda830000 + (0x25 << 2))
+#define   P_KEY_LDR_SEC_BLK_NUM                                (volatile uint32_t *)(0xc8830000 + (0x25 << 2))
+#define     KEY_LDR_NONCE_0                                    (0xc8830000 + (0x26 << 2))
+#define SEC_KEY_LDR_NONCE_0                                    (0xda830000 + (0x26 << 2))
+#define   P_KEY_LDR_NONCE_0                                    (volatile uint32_t *)(0xc8830000 + (0x26 << 2))
+#define     KEY_LDR_NONCE_1                                    (0xc8830000 + (0x27 << 2))
+#define SEC_KEY_LDR_NONCE_1                                    (0xda830000 + (0x27 << 2))
+#define   P_KEY_LDR_NONCE_1                                    (volatile uint32_t *)(0xc8830000 + (0x27 << 2))
+#define     KEY_LDR_NONCE_2                                    (0xc8830000 + (0x28 << 2))
+#define SEC_KEY_LDR_NONCE_2                                    (0xda830000 + (0x28 << 2))
+#define   P_KEY_LDR_NONCE_2                                    (volatile uint32_t *)(0xc8830000 + (0x28 << 2))
+#define     KEY_LDR_NONCE_3                                    (0xc8830000 + (0x29 << 2))
+#define SEC_KEY_LDR_NONCE_3                                    (0xda830000 + (0x29 << 2))
+#define   P_KEY_LDR_NONCE_3                                    (volatile uint32_t *)(0xc8830000 + (0x29 << 2))
+//========================================================================
+//  BLKMV
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8832000
+//  APB4_DECODER_SECURE_BASE         32'hDA832000
+//
+// Secure APB3 Slot 3 registers
+//
+#define     SEC_BLKMV_AES_REG0                                 (0xc8832000 + (0x00 << 2))
+#define SEC_SEC_BLKMV_AES_REG0                                 (0xda832000 + (0x00 << 2))
+#define   P_SEC_BLKMV_AES_REG0                                 (volatile uint32_t *)(0xc8832000 + (0x00 << 2))
+#define     SEC_BLKMV_AES_PIO_W0                               (0xc8832000 + (0x01 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W0                               (0xda832000 + (0x01 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W0                               (volatile uint32_t *)(0xc8832000 + (0x01 << 2))
+#define     SEC_BLKMV_AES_PIO_W1                               (0xc8832000 + (0x02 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W1                               (0xda832000 + (0x02 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W1                               (volatile uint32_t *)(0xc8832000 + (0x02 << 2))
+#define     SEC_BLKMV_AES_PIO_W2                               (0xc8832000 + (0x03 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W2                               (0xda832000 + (0x03 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W2                               (volatile uint32_t *)(0xc8832000 + (0x03 << 2))
+#define     SEC_BLKMV_AES_PIO_W3                               (0xc8832000 + (0x04 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W3                               (0xda832000 + (0x04 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W3                               (volatile uint32_t *)(0xc8832000 + (0x04 << 2))
+#define     SEC_BLKMV_TDES_KEY_LO                              (0xc8832000 + (0x08 << 2))
+#define SEC_SEC_BLKMV_TDES_KEY_LO                              (0xda832000 + (0x08 << 2))
+#define   P_SEC_BLKMV_TDES_KEY_LO                              (volatile uint32_t *)(0xc8832000 + (0x08 << 2))
+#define     SEC_BLKMV_TDES_KEY_HI                              (0xc8832000 + (0x09 << 2))
+#define SEC_SEC_BLKMV_TDES_KEY_HI                              (0xda832000 + (0x09 << 2))
+#define   P_SEC_BLKMV_TDES_KEY_HI                              (volatile uint32_t *)(0xc8832000 + (0x09 << 2))
+#define     SEC_BLKMV_TDES_CONTROL                             (0xc8832000 + (0x0a << 2))
+#define SEC_SEC_BLKMV_TDES_CONTROL                             (0xda832000 + (0x0a << 2))
+#define   P_SEC_BLKMV_TDES_CONTROL                             (volatile uint32_t *)(0xc8832000 + (0x0a << 2))
+#define     SEC_BLKMV_AES_IV_0                                 (0xc8832000 + (0x0b << 2))
+#define SEC_SEC_BLKMV_AES_IV_0                                 (0xda832000 + (0x0b << 2))
+#define   P_SEC_BLKMV_AES_IV_0                                 (volatile uint32_t *)(0xc8832000 + (0x0b << 2))
+#define     SEC_BLKMV_AES_IV_1                                 (0xc8832000 + (0x0c << 2))
+#define SEC_SEC_BLKMV_AES_IV_1                                 (0xda832000 + (0x0c << 2))
+#define   P_SEC_BLKMV_AES_IV_1                                 (volatile uint32_t *)(0xc8832000 + (0x0c << 2))
+#define     SEC_BLKMV_AES_IV_2                                 (0xc8832000 + (0x0d << 2))
+#define SEC_SEC_BLKMV_AES_IV_2                                 (0xda832000 + (0x0d << 2))
+#define   P_SEC_BLKMV_AES_IV_2                                 (volatile uint32_t *)(0xc8832000 + (0x0d << 2))
+#define     SEC_BLKMV_AES_IV_3                                 (0xc8832000 + (0x0e << 2))
+#define SEC_SEC_BLKMV_AES_IV_3                                 (0xda832000 + (0x0e << 2))
+#define   P_SEC_BLKMV_AES_IV_3                                 (volatile uint32_t *)(0xc8832000 + (0x0e << 2))
+#define     SEC_BLKMV_AES_KEY_0                                (0xc8832000 + (0x10 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_0                                (0xda832000 + (0x10 << 2))
+#define   P_SEC_BLKMV_AES_KEY_0                                (volatile uint32_t *)(0xc8832000 + (0x10 << 2))
+#define     SEC_BLKMV_AES_KEY_1                                (0xc8832000 + (0x11 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_1                                (0xda832000 + (0x11 << 2))
+#define   P_SEC_BLKMV_AES_KEY_1                                (volatile uint32_t *)(0xc8832000 + (0x11 << 2))
+#define     SEC_BLKMV_AES_KEY_2                                (0xc8832000 + (0x12 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_2                                (0xda832000 + (0x12 << 2))
+#define   P_SEC_BLKMV_AES_KEY_2                                (volatile uint32_t *)(0xc8832000 + (0x12 << 2))
+#define     SEC_BLKMV_AES_KEY_3                                (0xc8832000 + (0x13 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_3                                (0xda832000 + (0x13 << 2))
+#define   P_SEC_BLKMV_AES_KEY_3                                (volatile uint32_t *)(0xc8832000 + (0x13 << 2))
+#define     SEC_BLKMV_AES_KEY_4                                (0xc8832000 + (0x14 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_4                                (0xda832000 + (0x14 << 2))
+#define   P_SEC_BLKMV_AES_KEY_4                                (volatile uint32_t *)(0xc8832000 + (0x14 << 2))
+#define     SEC_BLKMV_AES_KEY_5                                (0xc8832000 + (0x15 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_5                                (0xda832000 + (0x15 << 2))
+#define   P_SEC_BLKMV_AES_KEY_5                                (volatile uint32_t *)(0xc8832000 + (0x15 << 2))
+#define     SEC_BLKMV_AES_KEY_6                                (0xc8832000 + (0x16 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_6                                (0xda832000 + (0x16 << 2))
+#define   P_SEC_BLKMV_AES_KEY_6                                (volatile uint32_t *)(0xc8832000 + (0x16 << 2))
+#define     SEC_BLKMV_AES_KEY_7                                (0xc8832000 + (0x17 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_7                                (0xda832000 + (0x17 << 2))
+#define   P_SEC_BLKMV_AES_KEY_7                                (volatile uint32_t *)(0xc8832000 + (0x17 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START0                      (0xc8832000 + (0x18 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START0                      (0xda832000 + (0x18 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START0                      (volatile uint32_t *)(0xc8832000 + (0x18 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR0                       (0xc8832000 + (0x19 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR0                       (0xda832000 + (0x19 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR0                       (volatile uint32_t *)(0xc8832000 + (0x19 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END0                        (0xc8832000 + (0x1a << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END0                        (0xda832000 + (0x1a << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END0                        (volatile uint32_t *)(0xc8832000 + (0x1a << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START1                      (0xc8832000 + (0x1b << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START1                      (0xda832000 + (0x1b << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START1                      (volatile uint32_t *)(0xc8832000 + (0x1b << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR1                       (0xc8832000 + (0x1c << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR1                       (0xda832000 + (0x1c << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR1                       (volatile uint32_t *)(0xc8832000 + (0x1c << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END1                        (0xc8832000 + (0x1d << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END1                        (0xda832000 + (0x1d << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END1                        (volatile uint32_t *)(0xc8832000 + (0x1d << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START2                      (0xc8832000 + (0x1e << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START2                      (0xda832000 + (0x1e << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START2                      (volatile uint32_t *)(0xc8832000 + (0x1e << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR2                       (0xc8832000 + (0x1f << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR2                       (0xda832000 + (0x1f << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR2                       (volatile uint32_t *)(0xc8832000 + (0x1f << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END2                        (0xc8832000 + (0x20 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END2                        (0xda832000 + (0x20 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END2                        (volatile uint32_t *)(0xc8832000 + (0x20 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START3                      (0xc8832000 + (0x21 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START3                      (0xda832000 + (0x21 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START3                      (volatile uint32_t *)(0xc8832000 + (0x21 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR3                       (0xc8832000 + (0x22 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR3                       (0xda832000 + (0x22 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR3                       (volatile uint32_t *)(0xc8832000 + (0x22 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END3                        (0xc8832000 + (0x23 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END3                        (0xda832000 + (0x23 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END3                        (volatile uint32_t *)(0xc8832000 + (0x23 << 2))
+#define     SEC_BLKMV_GEN_REG0                                 (0xc8832000 + (0x24 << 2))
+#define SEC_SEC_BLKMV_GEN_REG0                                 (0xda832000 + (0x24 << 2))
+#define   P_SEC_BLKMV_GEN_REG0                                 (volatile uint32_t *)(0xc8832000 + (0x24 << 2))
+#define     SEC_BLKMV_PIO_CNTL0                                (0xc8832000 + (0x25 << 2))
+#define SEC_SEC_BLKMV_PIO_CNTL0                                (0xda832000 + (0x25 << 2))
+#define   P_SEC_BLKMV_PIO_CNTL0                                (volatile uint32_t *)(0xc8832000 + (0x25 << 2))
+#define     SEC_BLKMV_PIO_DATA0                                (0xc8832000 + (0x26 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA0                                (0xda832000 + (0x26 << 2))
+#define   P_SEC_BLKMV_PIO_DATA0                                (volatile uint32_t *)(0xc8832000 + (0x26 << 2))
+#define     SEC_BLKMV_PIO_DATA1                                (0xc8832000 + (0x27 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA1                                (0xda832000 + (0x27 << 2))
+#define   P_SEC_BLKMV_PIO_DATA1                                (volatile uint32_t *)(0xc8832000 + (0x27 << 2))
+#define     SEC_BLKMV_PIO_DATA2                                (0xc8832000 + (0x28 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA2                                (0xda832000 + (0x28 << 2))
+#define   P_SEC_BLKMV_PIO_DATA2                                (volatile uint32_t *)(0xc8832000 + (0x28 << 2))
+#define     SEC_BLKMV_PIO_DATA3                                (0xc8832000 + (0x29 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA3                                (0xda832000 + (0x29 << 2))
+#define   P_SEC_BLKMV_PIO_DATA3                                (volatile uint32_t *)(0xc8832000 + (0x29 << 2))
+#define     SEC_BLKMV_PIO_DATA4                                (0xc8832000 + (0x2a << 2))
+#define SEC_SEC_BLKMV_PIO_DATA4                                (0xda832000 + (0x2a << 2))
+#define   P_SEC_BLKMV_PIO_DATA4                                (volatile uint32_t *)(0xc8832000 + (0x2a << 2))
+#define     SEC_BLKMV_PIO_DATA5                                (0xc8832000 + (0x2b << 2))
+#define SEC_SEC_BLKMV_PIO_DATA5                                (0xda832000 + (0x2b << 2))
+#define   P_SEC_BLKMV_PIO_DATA5                                (volatile uint32_t *)(0xc8832000 + (0x2b << 2))
+#define     SEC_BLKMV_PIO_DATA6                                (0xc8832000 + (0x2c << 2))
+#define SEC_SEC_BLKMV_PIO_DATA6                                (0xda832000 + (0x2c << 2))
+#define   P_SEC_BLKMV_PIO_DATA6                                (volatile uint32_t *)(0xc8832000 + (0x2c << 2))
+#define     SEC_BLKMV_PIO_DATA7                                (0xc8832000 + (0x2d << 2))
+#define SEC_SEC_BLKMV_PIO_DATA7                                (0xda832000 + (0x2d << 2))
+#define   P_SEC_BLKMV_PIO_DATA7                                (volatile uint32_t *)(0xc8832000 + (0x2d << 2))
+#define     SEC_BLKMV_PIO_DATA8                                (0xc8832000 + (0x2e << 2))
+#define SEC_SEC_BLKMV_PIO_DATA8                                (0xda832000 + (0x2e << 2))
+#define   P_SEC_BLKMV_PIO_DATA8                                (volatile uint32_t *)(0xc8832000 + (0x2e << 2))
+#define     SEC_BLKMV_PIO_DATA9                                (0xc8832000 + (0x2f << 2))
+#define SEC_SEC_BLKMV_PIO_DATA9                                (0xda832000 + (0x2f << 2))
+#define   P_SEC_BLKMV_PIO_DATA9                                (volatile uint32_t *)(0xc8832000 + (0x2f << 2))
+#define     SEC_BLKMV_PIO_DATA10                               (0xc8832000 + (0x30 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA10                               (0xda832000 + (0x30 << 2))
+#define   P_SEC_BLKMV_PIO_DATA10                               (volatile uint32_t *)(0xc8832000 + (0x30 << 2))
+#define     SEC_BLKMV_PIO_DATA11                               (0xc8832000 + (0x31 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA11                               (0xda832000 + (0x31 << 2))
+#define   P_SEC_BLKMV_PIO_DATA11                               (volatile uint32_t *)(0xc8832000 + (0x31 << 2))
+#define     SEC_BLKMV_SHA_CONTROL                              (0xc8832000 + (0x32 << 2))
+#define SEC_SEC_BLKMV_SHA_CONTROL                              (0xda832000 + (0x32 << 2))
+#define   P_SEC_BLKMV_SHA_CONTROL                              (volatile uint32_t *)(0xc8832000 + (0x32 << 2))
+#define     SEC_BLKMV_SHA_PIO_WDATA                            (0xc8832000 + (0x33 << 2))
+#define SEC_SEC_BLKMV_SHA_PIO_WDATA                            (0xda832000 + (0x33 << 2))
+#define   P_SEC_BLKMV_SHA_PIO_WDATA                            (volatile uint32_t *)(0xc8832000 + (0x33 << 2))
+#define     SEC_BLKMV_SHA_DMA_MSG_IN                           (0xc8832000 + (0x34 << 2))
+#define SEC_SEC_BLKMV_SHA_DMA_MSG_IN                           (0xda832000 + (0x34 << 2))
+#define   P_SEC_BLKMV_SHA_DMA_MSG_IN                           (volatile uint32_t *)(0xc8832000 + (0x34 << 2))
+#define     SEC_BLKMV_SHA_DMA_DATALEN_IN                       (0xc8832000 + (0x35 << 2))
+#define SEC_SEC_BLKMV_SHA_DMA_DATALEN_IN                       (0xda832000 + (0x35 << 2))
+#define   P_SEC_BLKMV_SHA_DMA_DATALEN_IN                       (volatile uint32_t *)(0xc8832000 + (0x35 << 2))
+#define     SEC_BLKMV_AES_CW_WR                                (0xc8832000 + (0x38 << 2))
+#define SEC_SEC_BLKMV_AES_CW_WR                                (0xda832000 + (0x38 << 2))
+#define   P_SEC_BLKMV_AES_CW_WR                                (volatile uint32_t *)(0xc8832000 + (0x38 << 2))
+#define     SEC_BLKMV_TDES_CW_WR                               (0xc8832000 + (0x39 << 2))
+#define SEC_SEC_BLKMV_TDES_CW_WR                               (0xda832000 + (0x39 << 2))
+#define   P_SEC_BLKMV_TDES_CW_WR                               (volatile uint32_t *)(0xc8832000 + (0x39 << 2))
+// ----------------------------
+// Non-Secure
+// ----------------------------
+#define     NDMA_CNTL_REG0                                     (0xc8832000 + (0x70 << 2))
+#define SEC_NDMA_CNTL_REG0                                     (0xda832000 + (0x70 << 2))
+#define   P_NDMA_CNTL_REG0                                     (volatile uint32_t *)(0xc8832000 + (0x70 << 2))
+    #define NDMA_STATUS                 26
+    #define NDMA_PERIODIC_INT_DLY_MSB   25
+    #define NDMA_PERIODIC_INT_DLY_LSB   16
+    #define NDMA_PERIODIC_INT_EN        15
+    #define NDMA_ENABLE                 14
+    #define NDMA_AHB_DELAY_MSB          13
+    #define NDMA_AHB_DELAY_LSB          0
+#define     NDMA_TABLE_ADD_REG                                 (0xc8832000 + (0x72 << 2))
+#define SEC_NDMA_TABLE_ADD_REG                                 (0xda832000 + (0x72 << 2))
+#define   P_NDMA_TABLE_ADD_REG                                 (volatile uint32_t *)(0xc8832000 + (0x72 << 2))
+#define     NDMA_TDES_KEY_LO                                   (0xc8832000 + (0x73 << 2))
+#define SEC_NDMA_TDES_KEY_LO                                   (0xda832000 + (0x73 << 2))
+#define   P_NDMA_TDES_KEY_LO                                   (volatile uint32_t *)(0xc8832000 + (0x73 << 2))
+#define     NDMA_TDES_KEY_HI                                   (0xc8832000 + (0x74 << 2))
+#define SEC_NDMA_TDES_KEY_HI                                   (0xda832000 + (0x74 << 2))
+#define   P_NDMA_TDES_KEY_HI                                   (volatile uint32_t *)(0xc8832000 + (0x74 << 2))
+#define     NDMA_TDES_CONTROL                                  (0xc8832000 + (0x75 << 2))
+#define SEC_NDMA_TDES_CONTROL                                  (0xda832000 + (0x75 << 2))
+#define   P_NDMA_TDES_CONTROL                                  (volatile uint32_t *)(0xc8832000 + (0x75 << 2))
+#define     NDMA_RIJNDAEL_CONTROL                              (0xc8832000 + (0x76 << 2))
+#define SEC_NDMA_RIJNDAEL_CONTROL                              (0xda832000 + (0x76 << 2))
+#define   P_NDMA_RIJNDAEL_CONTROL                              (volatile uint32_t *)(0xc8832000 + (0x76 << 2))
+#define     NDMA_RIJNDAEL_RK_FIFO                              (0xc8832000 + (0x77 << 2))
+#define SEC_NDMA_RIJNDAEL_RK_FIFO                              (0xda832000 + (0x77 << 2))
+#define   P_NDMA_RIJNDAEL_RK_FIFO                              (volatile uint32_t *)(0xc8832000 + (0x77 << 2))
+#define     NDMA_CRC_OUT                                       (0xc8832000 + (0x78 << 2))
+#define SEC_NDMA_CRC_OUT                                       (0xda832000 + (0x78 << 2))
+#define   P_NDMA_CRC_OUT                                       (volatile uint32_t *)(0xc8832000 + (0x78 << 2))
+#define     NDMA_THREAD_REG                                    (0xc8832000 + (0x79 << 2))
+#define SEC_NDMA_THREAD_REG                                    (0xda832000 + (0x79 << 2))
+#define   P_NDMA_THREAD_REG                                    (volatile uint32_t *)(0xc8832000 + (0x79 << 2))
+#define     NDMA_THREAD_TABLE_START0                           (0xc8832000 + (0x80 << 2))
+#define SEC_NDMA_THREAD_TABLE_START0                           (0xda832000 + (0x80 << 2))
+#define   P_NDMA_THREAD_TABLE_START0                           (volatile uint32_t *)(0xc8832000 + (0x80 << 2))
+#define     NDMA_THREAD_TABLE_CURR0                            (0xc8832000 + (0x81 << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR0                            (0xda832000 + (0x81 << 2))
+#define   P_NDMA_THREAD_TABLE_CURR0                            (volatile uint32_t *)(0xc8832000 + (0x81 << 2))
+#define     NDMA_THREAD_TABLE_END0                             (0xc8832000 + (0x82 << 2))
+#define SEC_NDMA_THREAD_TABLE_END0                             (0xda832000 + (0x82 << 2))
+#define   P_NDMA_THREAD_TABLE_END0                             (volatile uint32_t *)(0xc8832000 + (0x82 << 2))
+#define     NDMA_THREAD_TABLE_START1                           (0xc8832000 + (0x83 << 2))
+#define SEC_NDMA_THREAD_TABLE_START1                           (0xda832000 + (0x83 << 2))
+#define   P_NDMA_THREAD_TABLE_START1                           (volatile uint32_t *)(0xc8832000 + (0x83 << 2))
+#define     NDMA_THREAD_TABLE_CURR1                            (0xc8832000 + (0x84 << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR1                            (0xda832000 + (0x84 << 2))
+#define   P_NDMA_THREAD_TABLE_CURR1                            (volatile uint32_t *)(0xc8832000 + (0x84 << 2))
+#define     NDMA_THREAD_TABLE_END1                             (0xc8832000 + (0x85 << 2))
+#define SEC_NDMA_THREAD_TABLE_END1                             (0xda832000 + (0x85 << 2))
+#define   P_NDMA_THREAD_TABLE_END1                             (volatile uint32_t *)(0xc8832000 + (0x85 << 2))
+#define     NDMA_THREAD_TABLE_START2                           (0xc8832000 + (0x86 << 2))
+#define SEC_NDMA_THREAD_TABLE_START2                           (0xda832000 + (0x86 << 2))
+#define   P_NDMA_THREAD_TABLE_START2                           (volatile uint32_t *)(0xc8832000 + (0x86 << 2))
+#define     NDMA_THREAD_TABLE_CURR2                            (0xc8832000 + (0x87 << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR2                            (0xda832000 + (0x87 << 2))
+#define   P_NDMA_THREAD_TABLE_CURR2                            (volatile uint32_t *)(0xc8832000 + (0x87 << 2))
+#define     NDMA_THREAD_TABLE_END2                             (0xc8832000 + (0x88 << 2))
+#define SEC_NDMA_THREAD_TABLE_END2                             (0xda832000 + (0x88 << 2))
+#define   P_NDMA_THREAD_TABLE_END2                             (volatile uint32_t *)(0xc8832000 + (0x88 << 2))
+#define     NDMA_THREAD_TABLE_START3                           (0xc8832000 + (0x89 << 2))
+#define SEC_NDMA_THREAD_TABLE_START3                           (0xda832000 + (0x89 << 2))
+#define   P_NDMA_THREAD_TABLE_START3                           (volatile uint32_t *)(0xc8832000 + (0x89 << 2))
+#define     NDMA_THREAD_TABLE_CURR3                            (0xc8832000 + (0x8a << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR3                            (0xda832000 + (0x8a << 2))
+#define   P_NDMA_THREAD_TABLE_CURR3                            (volatile uint32_t *)(0xc8832000 + (0x8a << 2))
+#define     NDMA_THREAD_TABLE_END3                             (0xc8832000 + (0x8b << 2))
+#define SEC_NDMA_THREAD_TABLE_END3                             (0xda832000 + (0x8b << 2))
+#define   P_NDMA_THREAD_TABLE_END3                             (volatile uint32_t *)(0xc8832000 + (0x8b << 2))
+#define     NDMA_CNTL_REG1                                     (0xc8832000 + (0x8c << 2))
+#define SEC_NDMA_CNTL_REG1                                     (0xda832000 + (0x8c << 2))
+#define   P_NDMA_CNTL_REG1                                     (volatile uint32_t *)(0xc8832000 + (0x8c << 2))
+// Non-secure AES Key Writes
+#define     NDMA_AES_KEY_0                                     (0xc8832000 + (0x90 << 2))
+#define SEC_NDMA_AES_KEY_0                                     (0xda832000 + (0x90 << 2))
+#define   P_NDMA_AES_KEY_0                                     (volatile uint32_t *)(0xc8832000 + (0x90 << 2))
+#define     NDMA_AES_KEY_1                                     (0xc8832000 + (0x91 << 2))
+#define SEC_NDMA_AES_KEY_1                                     (0xda832000 + (0x91 << 2))
+#define   P_NDMA_AES_KEY_1                                     (volatile uint32_t *)(0xc8832000 + (0x91 << 2))
+#define     NDMA_AES_KEY_2                                     (0xc8832000 + (0x92 << 2))
+#define SEC_NDMA_AES_KEY_2                                     (0xda832000 + (0x92 << 2))
+#define   P_NDMA_AES_KEY_2                                     (volatile uint32_t *)(0xc8832000 + (0x92 << 2))
+#define     NDMA_AES_KEY_3                                     (0xc8832000 + (0x93 << 2))
+#define SEC_NDMA_AES_KEY_3                                     (0xda832000 + (0x93 << 2))
+#define   P_NDMA_AES_KEY_3                                     (volatile uint32_t *)(0xc8832000 + (0x93 << 2))
+#define     NDMA_AES_KEY_4                                     (0xc8832000 + (0x94 << 2))
+#define SEC_NDMA_AES_KEY_4                                     (0xda832000 + (0x94 << 2))
+#define   P_NDMA_AES_KEY_4                                     (volatile uint32_t *)(0xc8832000 + (0x94 << 2))
+#define     NDMA_AES_KEY_5                                     (0xc8832000 + (0x95 << 2))
+#define SEC_NDMA_AES_KEY_5                                     (0xda832000 + (0x95 << 2))
+#define   P_NDMA_AES_KEY_5                                     (volatile uint32_t *)(0xc8832000 + (0x95 << 2))
+#define     NDMA_AES_KEY_6                                     (0xc8832000 + (0x96 << 2))
+#define SEC_NDMA_AES_KEY_6                                     (0xda832000 + (0x96 << 2))
+#define   P_NDMA_AES_KEY_6                                     (volatile uint32_t *)(0xc8832000 + (0x96 << 2))
+#define     NDMA_AES_KEY_7                                     (0xc8832000 + (0x97 << 2))
+#define SEC_NDMA_AES_KEY_7                                     (0xda832000 + (0x97 << 2))
+#define   P_NDMA_AES_KEY_7                                     (volatile uint32_t *)(0xc8832000 + (0x97 << 2))
+// Non-secure AES IV Writes
+#define     NDMA_AES_IV_0                                      (0xc8832000 + (0x98 << 2))
+#define SEC_NDMA_AES_IV_0                                      (0xda832000 + (0x98 << 2))
+#define   P_NDMA_AES_IV_0                                      (volatile uint32_t *)(0xc8832000 + (0x98 << 2))
+#define     NDMA_AES_IV_1                                      (0xc8832000 + (0x99 << 2))
+#define SEC_NDMA_AES_IV_1                                      (0xda832000 + (0x99 << 2))
+#define   P_NDMA_AES_IV_1                                      (volatile uint32_t *)(0xc8832000 + (0x99 << 2))
+#define     NDMA_AES_IV_2                                      (0xc8832000 + (0x9a << 2))
+#define SEC_NDMA_AES_IV_2                                      (0xda832000 + (0x9a << 2))
+#define   P_NDMA_AES_IV_2                                      (volatile uint32_t *)(0xc8832000 + (0x9a << 2))
+#define     NDMA_AES_IV_3                                      (0xc8832000 + (0x9b << 2))
+#define SEC_NDMA_AES_IV_3                                      (0xda832000 + (0x9b << 2))
+#define   P_NDMA_AES_IV_3                                      (volatile uint32_t *)(0xc8832000 + (0x9b << 2))
+#define     NDMA_AES_REG0                                      (0xc8832000 + (0x9c << 2))
+#define SEC_NDMA_AES_REG0                                      (0xda832000 + (0x9c << 2))
+#define   P_NDMA_AES_REG0                                      (volatile uint32_t *)(0xc8832000 + (0x9c << 2))
+// Non-secure SHA Message In writes
+#define     NDMA_SHA_MSG_IN                                    (0xc8832000 + (0x9d << 2))
+#define SEC_NDMA_SHA_MSG_IN                                    (0xda832000 + (0x9d << 2))
+#define   P_NDMA_SHA_MSG_IN                                    (volatile uint32_t *)(0xc8832000 + (0x9d << 2))
+// Non-secure SHA Datalenth In writes
+#define     NDMA_SHA_DATALEN_IN                                (0xc8832000 + (0x9e << 2))
+#define SEC_NDMA_SHA_DATALEN_IN                                (0xda832000 + (0x9e << 2))
+#define   P_NDMA_SHA_DATALEN_IN                                (volatile uint32_t *)(0xc8832000 + (0x9e << 2))
+#define     NDMA_SHA_CONTROL                                   (0xc8832000 + (0x9f << 2))
+#define SEC_NDMA_SHA_CONTROL                                   (0xda832000 + (0x9f << 2))
+#define   P_NDMA_SHA_CONTROL                                   (volatile uint32_t *)(0xc8832000 + (0x9f << 2))
+// Non-secure SHA Reads
+#define     NDMA_CRYPTO_OUT_0                                  (0xc8832000 + (0xa0 << 2))
+#define SEC_NDMA_CRYPTO_OUT_0                                  (0xda832000 + (0xa0 << 2))
+#define   P_NDMA_CRYPTO_OUT_0                                  (volatile uint32_t *)(0xc8832000 + (0xa0 << 2))
+#define     NDMA_CRYPTO_OUT_1                                  (0xc8832000 + (0xa1 << 2))
+#define SEC_NDMA_CRYPTO_OUT_1                                  (0xda832000 + (0xa1 << 2))
+#define   P_NDMA_CRYPTO_OUT_1                                  (volatile uint32_t *)(0xc8832000 + (0xa1 << 2))
+#define     NDMA_CRYPTO_OUT_2                                  (0xc8832000 + (0xa2 << 2))
+#define SEC_NDMA_CRYPTO_OUT_2                                  (0xda832000 + (0xa2 << 2))
+#define   P_NDMA_CRYPTO_OUT_2                                  (volatile uint32_t *)(0xc8832000 + (0xa2 << 2))
+#define     NDMA_CRYPTO_OUT_3                                  (0xc8832000 + (0xa3 << 2))
+#define SEC_NDMA_CRYPTO_OUT_3                                  (0xda832000 + (0xa3 << 2))
+#define   P_NDMA_CRYPTO_OUT_3                                  (volatile uint32_t *)(0xc8832000 + (0xa3 << 2))
+#define     NDMA_CRYPTO_OUT_4                                  (0xc8832000 + (0xa4 << 2))
+#define SEC_NDMA_CRYPTO_OUT_4                                  (0xda832000 + (0xa4 << 2))
+#define   P_NDMA_CRYPTO_OUT_4                                  (volatile uint32_t *)(0xc8832000 + (0xa4 << 2))
+#define     NDMA_CRYPTO_OUT_5                                  (0xc8832000 + (0xa5 << 2))
+#define SEC_NDMA_CRYPTO_OUT_5                                  (0xda832000 + (0xa5 << 2))
+#define   P_NDMA_CRYPTO_OUT_5                                  (volatile uint32_t *)(0xc8832000 + (0xa5 << 2))
+#define     NDMA_CRYPTO_OUT_6                                  (0xc8832000 + (0xa6 << 2))
+#define SEC_NDMA_CRYPTO_OUT_6                                  (0xda832000 + (0xa6 << 2))
+#define   P_NDMA_CRYPTO_OUT_6                                  (volatile uint32_t *)(0xc8832000 + (0xa6 << 2))
+#define     NDMA_CRYPTO_OUT_7                                  (0xc8832000 + (0xa7 << 2))
+#define SEC_NDMA_CRYPTO_OUT_7                                  (0xda832000 + (0xa7 << 2))
+#define   P_NDMA_CRYPTO_OUT_7                                  (volatile uint32_t *)(0xc8832000 + (0xa7 << 2))
+#define     NDMA_CRYPTO_OUT_8                                  (0xc8832000 + (0xa8 << 2))
+#define SEC_NDMA_CRYPTO_OUT_8                                  (0xda832000 + (0xa8 << 2))
+#define   P_NDMA_CRYPTO_OUT_8                                  (volatile uint32_t *)(0xc8832000 + (0xa8 << 2))
+#define     NDMA_CRYPTO_OUT_9                                  (0xc8832000 + (0xa9 << 2))
+#define SEC_NDMA_CRYPTO_OUT_9                                  (0xda832000 + (0xa9 << 2))
+#define   P_NDMA_CRYPTO_OUT_9                                  (volatile uint32_t *)(0xc8832000 + (0xa9 << 2))
+#define     NDMA_CRYPTO_OUT_10                                 (0xc8832000 + (0xaa << 2))
+#define SEC_NDMA_CRYPTO_OUT_10                                 (0xda832000 + (0xaa << 2))
+#define   P_NDMA_CRYPTO_OUT_10                                 (volatile uint32_t *)(0xc8832000 + (0xaa << 2))
+#define     NDMA_CRYPTO_OUT_11                                 (0xc8832000 + (0xab << 2))
+#define SEC_NDMA_CRYPTO_OUT_11                                 (0xda832000 + (0xab << 2))
+#define   P_NDMA_CRYPTO_OUT_11                                 (volatile uint32_t *)(0xc8832000 + (0xab << 2))
+#define     NON_SEC_BLKMV_AES_CW_WR                            (0xc8832000 + (0xb0 << 2))
+#define SEC_NON_SEC_BLKMV_AES_CW_WR                            (0xda832000 + (0xb0 << 2))
+#define   P_NON_SEC_BLKMV_AES_CW_WR                            (volatile uint32_t *)(0xc8832000 + (0xb0 << 2))
+#define     NON_SEC_BLKMV_TDES_CW_WR                           (0xc8832000 + (0xb1 << 2))
+#define SEC_NON_SEC_BLKMV_TDES_CW_WR                           (0xda832000 + (0xb1 << 2))
+#define   P_NON_SEC_BLKMV_TDES_CW_WR                           (volatile uint32_t *)(0xc8832000 + (0xb1 << 2))
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./secure_apb4_ee.h
+//
+//
+// Reading file:  ./ao_rti_reg.h
+//
+// -------------------------------------------------------------------
+// PSEL #0
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100000
+// APB4_DECODER_SECURE_BASE         32'hDA100000
+// Registers not affected by the Watchdog timer
+#define     AO_RTI_STATUS_REG0                                 (0xc8100000 + (0x00 << 2))
+#define SEC_AO_RTI_STATUS_REG0                                 (0xda100000 + (0x00 << 2))
+#define   P_AO_RTI_STATUS_REG0                                 (volatile uint32_t *)(0xc8100000 + (0x00 << 2))
+#define     AO_RTI_STATUS_REG1                                 (0xc8100000 + (0x01 << 2))
+#define SEC_AO_RTI_STATUS_REG1                                 (0xda100000 + (0x01 << 2))
+#define   P_AO_RTI_STATUS_REG1                                 (volatile uint32_t *)(0xc8100000 + (0x01 << 2))
+#define     AO_RTI_STATUS_REG2                                 (0xc8100000 + (0x02 << 2))
+#define SEC_AO_RTI_STATUS_REG2                                 (0xda100000 + (0x02 << 2))
+#define   P_AO_RTI_STATUS_REG2                                 (volatile uint32_t *)(0xc8100000 + (0x02 << 2))
+#define     AO_RTI_PWR_CNTL_REG1                               (0xc8100000 + (0x03 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG1                               (0xda100000 + (0x03 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG1                               (volatile uint32_t *)(0xc8100000 + (0x03 << 2))
+#define     AO_RTI_PWR_CNTL_REG0                               (0xc8100000 + (0x04 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG0                               (0xda100000 + (0x04 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x04 << 2))
+#define     AO_RTI_PIN_MUX_REG                                 (0xc8100000 + (0x05 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG                                 (0xda100000 + (0x05 << 2))
+#define   P_AO_RTI_PIN_MUX_REG                                 (volatile uint32_t *)(0xc8100000 + (0x05 << 2))
+#define     AO_RTI_PIN_MUX_REG2                                (0xc8100000 + (0x06 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG2                                (0xda100000 + (0x06 << 2))
+#define   P_AO_RTI_PIN_MUX_REG2                                (volatile uint32_t *)(0xc8100000 + (0x06 << 2))
+#define     AO_RTI_STATUS_REG3                                 (0xc8100000 + (0x07 << 2))
+#define SEC_AO_RTI_STATUS_REG3                                 (0xda100000 + (0x07 << 2))
+#define   P_AO_RTI_STATUS_REG3                                 (volatile uint32_t *)(0xc8100000 + (0x07 << 2))
+//`define AO_REMAP_REG0               8'h07 //TODO: DELETE. NOT USED
+#define     AO_REMAP_REG1                                      (0xc8100000 + (0x08 << 2))
+#define SEC_AO_REMAP_REG1                                      (0xda100000 + (0x08 << 2))
+#define   P_AO_REMAP_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x08 << 2))
+#define     AO_GPIO_O_EN_N                                     (0xc8100000 + (0x09 << 2))
+#define SEC_AO_GPIO_O_EN_N                                     (0xda100000 + (0x09 << 2))
+#define   P_AO_GPIO_O_EN_N                                     (volatile uint32_t *)(0xc8100000 + (0x09 << 2))
+#define     AO_GPIO_I                                          (0xc8100000 + (0x0a << 2))
+#define SEC_AO_GPIO_I                                          (0xda100000 + (0x0a << 2))
+#define   P_AO_GPIO_I                                          (volatile uint32_t *)(0xc8100000 + (0x0a << 2))
+#define     AO_RTI_PULL_UP_REG                                 (0xc8100000 + (0x0b << 2))
+#define SEC_AO_RTI_PULL_UP_REG                                 (0xda100000 + (0x0b << 2))
+#define   P_AO_RTI_PULL_UP_REG                                 (volatile uint32_t *)(0xc8100000 + (0x0b << 2))
+#define     AO_RTI_JTAG_CONFIG_REG                             (0xc8100000 + (0x0c << 2))
+#define SEC_AO_RTI_JTAG_CONFIG_REG                             (0xda100000 + (0x0c << 2))
+#define   P_AO_RTI_JTAG_CONFIG_REG                             (volatile uint32_t *)(0xc8100000 + (0x0c << 2))
+#define     AO_RTI_WD_MARK                                     (0xc8100000 + (0x0d << 2))
+#define SEC_AO_RTI_WD_MARK                                     (0xda100000 + (0x0d << 2))
+#define   P_AO_RTI_WD_MARK                                     (volatile uint32_t *)(0xc8100000 + (0x0d << 2))
+// sando add for AO CPU
+#define     AO_CPU_CNTL                                        (0xc8100000 + (0x0e << 2))
+#define SEC_AO_CPU_CNTL                                        (0xda100000 + (0x0e << 2))
+#define   P_AO_CPU_CNTL                                        (volatile uint32_t *)(0xc8100000 + (0x0e << 2))
+#define     AO_CPU_CNTL2                                       (0xc8100000 + (0x0f << 2))
+#define SEC_AO_CPU_CNTL2                                       (0xda100000 + (0x0f << 2))
+#define   P_AO_CPU_CNTL2                                       (volatile uint32_t *)(0xc8100000 + (0x0f << 2))
+#define     AO_RTI_GEN_CNTL_REG0                               (0xc8100000 + (0x10 << 2))
+#define SEC_AO_RTI_GEN_CNTL_REG0                               (0xda100000 + (0x10 << 2))
+#define   P_AO_RTI_GEN_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x10 << 2))
+#define     AO_CPU_CNTL_NS                                     (0xc8100000 + (0x11 << 2))
+#define SEC_AO_CPU_CNTL_NS                                     (0xda100000 + (0x11 << 2))
+#define   P_AO_CPU_CNTL_NS                                     (volatile uint32_t *)(0xc8100000 + (0x11 << 2))
+#define     AO_TIMER_REG                                       (0xc8100000 + (0x13 << 2))
+#define SEC_AO_TIMER_REG                                       (0xda100000 + (0x13 << 2))
+#define   P_AO_TIMER_REG                                       (volatile uint32_t *)(0xc8100000 + (0x13 << 2))
+#define     AO_TIMERA_REG                                      (0xc8100000 + (0x14 << 2))
+#define SEC_AO_TIMERA_REG                                      (0xda100000 + (0x14 << 2))
+#define   P_AO_TIMERA_REG                                      (volatile uint32_t *)(0xc8100000 + (0x14 << 2))
+#define     AO_TIMERE_REG                                      (0xc8100000 + (0x15 << 2))
+#define SEC_AO_TIMERE_REG                                      (0xda100000 + (0x15 << 2))
+#define   P_AO_TIMERE_REG                                      (volatile uint32_t *)(0xc8100000 + (0x15 << 2))
+#define     AO_AHB2DDR_CNTL                                    (0xc8100000 + (0x18 << 2))
+#define SEC_AO_AHB2DDR_CNTL                                    (0xda100000 + (0x18 << 2))
+#define   P_AO_AHB2DDR_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x18 << 2))
+#define     AO_TIMEBASE_CNTL                                   (0xc8100000 + (0x19 << 2))
+#define SEC_AO_TIMEBASE_CNTL                                   (0xda100000 + (0x19 << 2))
+#define   P_AO_TIMEBASE_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x19 << 2))
+#define     AO_CRT_CLK_CNTL1                                   (0xc8100000 + (0x1a << 2))
+#define SEC_AO_CRT_CLK_CNTL1                                   (0xda100000 + (0x1a << 2))
+#define   P_AO_CRT_CLK_CNTL1                                   (volatile uint32_t *)(0xc8100000 + (0x1a << 2))
+#define     AO_RTI_INTER_OSC_CTL0                              (0xc8100000 + (0x1b << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL0                              (0xda100000 + (0x1b << 2))
+#define   P_AO_RTI_INTER_OSC_CTL0                              (volatile uint32_t *)(0xc8100000 + (0x1b << 2))
+#define     AO_RTI_INTER_OSC_CTL1                              (0xc8100000 + (0x1c << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL1                              (0xda100000 + (0x1c << 2))
+#define   P_AO_RTI_INTER_OSC_CTL1                              (volatile uint32_t *)(0xc8100000 + (0x1c << 2))
+#define     AO_IRQ_MASK_FIQ_SEL                                (0xc8100000 + (0x20 << 2))
+#define SEC_AO_IRQ_MASK_FIQ_SEL                                (0xda100000 + (0x20 << 2))
+#define   P_AO_IRQ_MASK_FIQ_SEL                                (volatile uint32_t *)(0xc8100000 + (0x20 << 2))
+#define     AO_IRQ_GPIO_REG                                    (0xc8100000 + (0x21 << 2))
+#define SEC_AO_IRQ_GPIO_REG                                    (0xda100000 + (0x21 << 2))
+#define   P_AO_IRQ_GPIO_REG                                    (volatile uint32_t *)(0xc8100000 + (0x21 << 2))
+#define     AO_IRQ_STAT                                        (0xc8100000 + (0x22 << 2))
+#define SEC_AO_IRQ_STAT                                        (0xda100000 + (0x22 << 2))
+#define   P_AO_IRQ_STAT                                        (volatile uint32_t *)(0xc8100000 + (0x22 << 2))
+#define     AO_IRQ_STAT_CLR                                    (0xc8100000 + (0x23 << 2))
+#define SEC_AO_IRQ_STAT_CLR                                    (0xda100000 + (0x23 << 2))
+#define   P_AO_IRQ_STAT_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x23 << 2))
+// `define AO_SAR_CLK                  8'h24 moved to the EE domain in Gx
+#define     AO_RTC_ALT_CLK_CNTL0                               (0xc8100000 + (0x25 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL0                               (0xda100000 + (0x25 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL0                               (volatile uint32_t *)(0xc8100000 + (0x25 << 2))
+#define     AO_RTC_ALT_CLK_CNTL1                               (0xc8100000 + (0x26 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL1                               (0xda100000 + (0x26 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL1                               (volatile uint32_t *)(0xc8100000 + (0x26 << 2))
+#define     AO_DEBUG_REG0                                      (0xc8100000 + (0x28 << 2))
+#define SEC_AO_DEBUG_REG0                                      (0xda100000 + (0x28 << 2))
+#define   P_AO_DEBUG_REG0                                      (volatile uint32_t *)(0xc8100000 + (0x28 << 2))
+#define     AO_DEBUG_REG1                                      (0xc8100000 + (0x29 << 2))
+#define SEC_AO_DEBUG_REG1                                      (0xda100000 + (0x29 << 2))
+#define   P_AO_DEBUG_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x29 << 2))
+#define     AO_DEBUG_REG2                                      (0xc8100000 + (0x2a << 2))
+#define SEC_AO_DEBUG_REG2                                      (0xda100000 + (0x2a << 2))
+#define   P_AO_DEBUG_REG2                                      (volatile uint32_t *)(0xc8100000 + (0x2a << 2))
+#define     AO_DEBUG_REG3                                      (0xc8100000 + (0x2b << 2))
+#define SEC_AO_DEBUG_REG3                                      (0xda100000 + (0x2b << 2))
+#define   P_AO_DEBUG_REG3                                      (volatile uint32_t *)(0xc8100000 + (0x2b << 2))
+#define     AO_TIMESTAMP_CNTL                                  (0xc8100000 + (0x2d << 2))
+#define SEC_AO_TIMESTAMP_CNTL                                  (0xda100000 + (0x2d << 2))
+#define   P_AO_TIMESTAMP_CNTL                                  (volatile uint32_t *)(0xc8100000 + (0x2d << 2))
+#define     AO_TIMESTAMP_RD0                                   (0xc8100000 + (0x2e << 2))
+#define SEC_AO_TIMESTAMP_RD0                                   (0xda100000 + (0x2e << 2))
+#define   P_AO_TIMESTAMP_RD0                                   (volatile uint32_t *)(0xc8100000 + (0x2e << 2))
+#define     AO_TIMESTAMP_RD1                                   (0xc8100000 + (0x2f << 2))
+#define SEC_AO_TIMESTAMP_RD1                                   (0xda100000 + (0x2f << 2))
+#define   P_AO_TIMESTAMP_RD1                                   (volatile uint32_t *)(0xc8100000 + (0x2f << 2))
+#define     AO_IR_BLASTER_ADDR0                                (0xc8100000 + (0x30 << 2))
+#define SEC_AO_IR_BLASTER_ADDR0                                (0xda100000 + (0x30 << 2))
+#define   P_AO_IR_BLASTER_ADDR0                                (volatile uint32_t *)(0xc8100000 + (0x30 << 2))
+#define     AO_IR_BLASTER_ADDR1                                (0xc8100000 + (0x31 << 2))
+#define SEC_AO_IR_BLASTER_ADDR1                                (0xda100000 + (0x31 << 2))
+#define   P_AO_IR_BLASTER_ADDR1                                (volatile uint32_t *)(0xc8100000 + (0x31 << 2))
+#define     AO_IR_BLASTER_ADDR2                                (0xc8100000 + (0x32 << 2))
+#define SEC_AO_IR_BLASTER_ADDR2                                (0xda100000 + (0x32 << 2))
+#define   P_AO_IR_BLASTER_ADDR2                                (volatile uint32_t *)(0xc8100000 + (0x32 << 2))
+#define     AO_CPU_STAT1                                       (0xc8100000 + (0x33 << 2))
+#define SEC_AO_CPU_STAT1                                       (0xda100000 + (0x33 << 2))
+#define   P_AO_CPU_STAT1                                       (volatile uint32_t *)(0xc8100000 + (0x33 << 2))
+#define     AO_CPU_STAT2                                       (0xc8100000 + (0x34 << 2))
+#define SEC_AO_CPU_STAT2                                       (0xda100000 + (0x34 << 2))
+#define   P_AO_CPU_STAT2                                       (volatile uint32_t *)(0xc8100000 + (0x34 << 2))
+#define     AO_CPU_TIMESTAMP                                   (0xc8100000 + (0x35 << 2))
+#define SEC_AO_CPU_TIMESTAMP                                   (0xda100000 + (0x35 << 2))
+#define   P_AO_CPU_TIMESTAMP                                   (volatile uint32_t *)(0xc8100000 + (0x35 << 2))
+#define     AO_CPU_TIMESTAMP2                                  (0xc8100000 + (0x36 << 2))
+#define SEC_AO_CPU_TIMESTAMP2                                  (0xda100000 + (0x36 << 2))
+#define   P_AO_CPU_TIMESTAMP2                                  (volatile uint32_t *)(0xc8100000 + (0x36 << 2))
+#define     AO_CPU_CNTL3                                       (0xc8100000 + (0x37 << 2))
+#define SEC_AO_CPU_CNTL3                                       (0xda100000 + (0x37 << 2))
+#define   P_AO_CPU_CNTL3                                       (volatile uint32_t *)(0xc8100000 + (0x37 << 2))
+// general Power control
+#define     AO_RTI_PWR_SYS_CPU_CNTL0                           (0xc8100000 + (0x38 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL0                           (0xda100000 + (0x38 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL0                           (volatile uint32_t *)(0xc8100000 + (0x38 << 2))
+#define     AO_RTI_PWR_SYS_CPU_CNTL1                           (0xc8100000 + (0x39 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL1                           (0xda100000 + (0x39 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL1                           (volatile uint32_t *)(0xc8100000 + (0x39 << 2))
+#define     AO_RTI_GEN_PWR_SLEEP0                              (0xc8100000 + (0x3a << 2))
+#define SEC_AO_RTI_GEN_PWR_SLEEP0                              (0xda100000 + (0x3a << 2))
+#define   P_AO_RTI_GEN_PWR_SLEEP0                              (volatile uint32_t *)(0xc8100000 + (0x3a << 2))
+#define     AO_RTI_GEN_PWR_ISO0                                (0xc8100000 + (0x3b << 2))
+#define SEC_AO_RTI_GEN_PWR_ISO0                                (0xda100000 + (0x3b << 2))
+#define   P_AO_RTI_GEN_PWR_ISO0                                (volatile uint32_t *)(0xc8100000 + (0x3b << 2))
+#define     AO_RTI_GEN_PWR_ACK0                                (0xc8100000 + (0x3c << 2))
+#define SEC_AO_RTI_GEN_PWR_ACK0                                (0xda100000 + (0x3c << 2))
+#define   P_AO_RTI_GEN_PWR_ACK0                                (volatile uint32_t *)(0xc8100000 + (0x3c << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xc8100000 + (0x3d << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xda100000 + (0x3d << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (volatile uint32_t *)(0xc8100000 + (0x3d << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xc8100000 + (0x3e << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xda100000 + (0x3e << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (volatile uint32_t *)(0xc8100000 + (0x3e << 2))
+#define     AO_CPU_CNTL4                                       (0xc8100000 + (0x3f << 2))
+#define SEC_AO_CPU_CNTL4                                       (0xda100000 + (0x3f << 2))
+#define   P_AO_CPU_CNTL4                                       (volatile uint32_t *)(0xc8100000 + (0x3f << 2))
+#define     AO_CEC_GEN_CNTL                                    (0xc8100000 + (0x40 << 2))
+#define SEC_AO_CEC_GEN_CNTL                                    (0xda100000 + (0x40 << 2))
+#define   P_AO_CEC_GEN_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x40 << 2))
+#define     AO_CEC_RW_REG                                      (0xc8100000 + (0x41 << 2))
+#define SEC_AO_CEC_RW_REG                                      (0xda100000 + (0x41 << 2))
+#define   P_AO_CEC_RW_REG                                      (volatile uint32_t *)(0xc8100000 + (0x41 << 2))
+#define     AO_CEC_INTR_MASKN                                  (0xc8100000 + (0x42 << 2))
+#define SEC_AO_CEC_INTR_MASKN                                  (0xda100000 + (0x42 << 2))
+#define   P_AO_CEC_INTR_MASKN                                  (volatile uint32_t *)(0xc8100000 + (0x42 << 2))
+#define     AO_CEC_INTR_CLR                                    (0xc8100000 + (0x43 << 2))
+#define SEC_AO_CEC_INTR_CLR                                    (0xda100000 + (0x43 << 2))
+#define   P_AO_CEC_INTR_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x43 << 2))
+#define     AO_CEC_INTR_STAT                                   (0xc8100000 + (0x44 << 2))
+#define SEC_AO_CEC_INTR_STAT                                   (0xda100000 + (0x44 << 2))
+#define   P_AO_CEC_INTR_STAT                                   (volatile uint32_t *)(0xc8100000 + (0x44 << 2))
+#define     AO_CPU_CNTL5                                       (0xc8100000 + (0x45 << 2))
+#define SEC_AO_CPU_CNTL5                                       (0xda100000 + (0x45 << 2))
+#define   P_AO_CPU_CNTL5                                       (volatile uint32_t *)(0xc8100000 + (0x45 << 2))
+#define     AO_WATCHDOG_CNTL                                   (0xc8100000 + (0x48 << 2))
+#define SEC_AO_WATCHDOG_CNTL                                   (0xda100000 + (0x48 << 2))
+#define   P_AO_WATCHDOG_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x48 << 2))
+#define     AO_WATCHDOG_CNTL1                                  (0xc8100000 + (0x49 << 2))
+#define SEC_AO_WATCHDOG_CNTL1                                  (0xda100000 + (0x49 << 2))
+#define   P_AO_WATCHDOG_CNTL1                                  (volatile uint32_t *)(0xc8100000 + (0x49 << 2))
+#define     AO_WATCHDOG_TCNT                                   (0xc8100000 + (0x4a << 2))
+#define SEC_AO_WATCHDOG_TCNT                                   (0xda100000 + (0x4a << 2))
+#define   P_AO_WATCHDOG_TCNT                                   (volatile uint32_t *)(0xc8100000 + (0x4a << 2))
+#define     AO_WATCHDOG_RESET                                  (0xc8100000 + (0x4b << 2))
+#define SEC_AO_WATCHDOG_RESET                                  (0xda100000 + (0x4b << 2))
+#define   P_AO_WATCHDOG_RESET                                  (volatile uint32_t *)(0xc8100000 + (0x4b << 2))
+//
+// Secure APB3 Slot 2 registers
+//
+#define     AO_SEC_REG0                                        (0xc8100000 + (0x50 << 2))
+#define SEC_AO_SEC_REG0                                        (0xda100000 + (0x50 << 2))
+#define   P_AO_SEC_REG0                                        (volatile uint32_t *)(0xc8100000 + (0x50 << 2))
+#define     AO_SEC_REG1                                        (0xc8100000 + (0x51 << 2))
+#define SEC_AO_SEC_REG1                                        (0xda100000 + (0x51 << 2))
+#define   P_AO_SEC_REG1                                        (volatile uint32_t *)(0xc8100000 + (0x51 << 2))
+#define     AO_SEC_REG2                                        (0xc8100000 + (0x52 << 2))
+#define SEC_AO_SEC_REG2                                        (0xda100000 + (0x52 << 2))
+#define   P_AO_SEC_REG2                                        (volatile uint32_t *)(0xc8100000 + (0x52 << 2))
+#define     AO_SEC_TMODE_PWD0                                  (0xc8100000 + (0x58 << 2))
+#define SEC_AO_SEC_TMODE_PWD0                                  (0xda100000 + (0x58 << 2))
+#define   P_AO_SEC_TMODE_PWD0                                  (volatile uint32_t *)(0xc8100000 + (0x58 << 2))
+#define     AO_SEC_TMODE_PWD1                                  (0xc8100000 + (0x59 << 2))
+#define SEC_AO_SEC_TMODE_PWD1                                  (0xda100000 + (0x59 << 2))
+#define   P_AO_SEC_TMODE_PWD1                                  (volatile uint32_t *)(0xc8100000 + (0x59 << 2))
+#define     AO_SEC_TMODE_PWD2                                  (0xc8100000 + (0x5a << 2))
+#define SEC_AO_SEC_TMODE_PWD2                                  (0xda100000 + (0x5a << 2))
+#define   P_AO_SEC_TMODE_PWD2                                  (volatile uint32_t *)(0xc8100000 + (0x5a << 2))
+#define     AO_SEC_TMODE_PWD3                                  (0xc8100000 + (0x5b << 2))
+#define SEC_AO_SEC_TMODE_PWD3                                  (0xda100000 + (0x5b << 2))
+#define   P_AO_SEC_TMODE_PWD3                                  (volatile uint32_t *)(0xc8100000 + (0x5b << 2))
+#define     AO_SEC_SCRATCH                                     (0xc8100000 + (0x5f << 2))
+#define SEC_AO_SEC_SCRATCH                                     (0xda100000 + (0x5f << 2))
+#define   P_AO_SEC_SCRATCH                                     (volatile uint32_t *)(0xc8100000 + (0x5f << 2))
+#define     AO_SEC_JTAG_PWD0                                   (0xc8100000 + (0x60 << 2))
+#define SEC_AO_SEC_JTAG_PWD0                                   (0xda100000 + (0x60 << 2))
+#define   P_AO_SEC_JTAG_PWD0                                   (volatile uint32_t *)(0xc8100000 + (0x60 << 2))
+#define     AO_SEC_JTAG_PWD1                                   (0xc8100000 + (0x61 << 2))
+#define SEC_AO_SEC_JTAG_PWD1                                   (0xda100000 + (0x61 << 2))
+#define   P_AO_SEC_JTAG_PWD1                                   (volatile uint32_t *)(0xc8100000 + (0x61 << 2))
+#define     AO_SEC_JTAG_PWD2                                   (0xc8100000 + (0x62 << 2))
+#define SEC_AO_SEC_JTAG_PWD2                                   (0xda100000 + (0x62 << 2))
+#define   P_AO_SEC_JTAG_PWD2                                   (volatile uint32_t *)(0xc8100000 + (0x62 << 2))
+#define     AO_SEC_JTAG_PWD3                                   (0xc8100000 + (0x63 << 2))
+#define SEC_AO_SEC_JTAG_PWD3                                   (0xda100000 + (0x63 << 2))
+#define   P_AO_SEC_JTAG_PWD3                                   (volatile uint32_t *)(0xc8100000 + (0x63 << 2))
+#define     AO_SEC_JTAG_SEC_CNTL                               (0xc8100000 + (0x64 << 2))
+#define SEC_AO_SEC_JTAG_SEC_CNTL                               (0xda100000 + (0x64 << 2))
+#define   P_AO_SEC_JTAG_SEC_CNTL                               (volatile uint32_t *)(0xc8100000 + (0x64 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR0                              (0xc8100000 + (0x65 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR0                              (0xda100000 + (0x65 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR0                              (volatile uint32_t *)(0xc8100000 + (0x65 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR1                              (0xc8100000 + (0x66 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR1                              (0xda100000 + (0x66 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR1                              (volatile uint32_t *)(0xc8100000 + (0x66 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR2                              (0xc8100000 + (0x67 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR2                              (0xda100000 + (0x67 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR2                              (volatile uint32_t *)(0xc8100000 + (0x67 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR3                              (0xc8100000 + (0x68 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR3                              (0xda100000 + (0x68 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR3                              (volatile uint32_t *)(0xc8100000 + (0x68 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xc8100000 + (0x70 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xda100000 + (0x70 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (volatile uint32_t *)(0xc8100000 + (0x70 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xc8100000 + (0x71 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xda100000 + (0x71 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (volatile uint32_t *)(0xc8100000 + (0x71 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xc8100000 + (0x72 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xda100000 + (0x72 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (volatile uint32_t *)(0xc8100000 + (0x72 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xc8100000 + (0x73 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xda100000 + (0x73 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (volatile uint32_t *)(0xc8100000 + (0x73 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xc8100000 + (0x74 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xda100000 + (0x74 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (volatile uint32_t *)(0xc8100000 + (0x74 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xc8100000 + (0x75 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xda100000 + (0x75 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (volatile uint32_t *)(0xc8100000 + (0x75 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xc8100000 + (0x76 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xda100000 + (0x76 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (volatile uint32_t *)(0xc8100000 + (0x76 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xc8100000 + (0x77 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xda100000 + (0x77 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (volatile uint32_t *)(0xc8100000 + (0x77 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xc8100000 + (0x78 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xda100000 + (0x78 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (volatile uint32_t *)(0xc8100000 + (0x78 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xc8100000 + (0x79 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xda100000 + (0x79 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (volatile uint32_t *)(0xc8100000 + (0x79 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xc8100000 + (0x7a << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xda100000 + (0x7a << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (volatile uint32_t *)(0xc8100000 + (0x7a << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xc8100000 + (0x7b << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xda100000 + (0x7b << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (volatile uint32_t *)(0xc8100000 + (0x7b << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_0                          (0xc8100000 + (0x7c << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_0                          (0xda100000 + (0x7c << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_0                          (volatile uint32_t *)(0xc8100000 + (0x7c << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_1                          (0xc8100000 + (0x7d << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_1                          (0xda100000 + (0x7d << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_1                          (volatile uint32_t *)(0xc8100000 + (0x7d << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_0                          (0xc8100000 + (0x7e << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_0                          (0xda100000 + (0x7e << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_0                          (volatile uint32_t *)(0xc8100000 + (0x7e << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_1                          (0xc8100000 + (0x7f << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_1                          (0xda100000 + (0x7f << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_1                          (volatile uint32_t *)(0xc8100000 + (0x7f << 2))
+#define     AO_SEC_SD_CFG0                                     (0xc8100000 + (0x80 << 2))
+#define SEC_AO_SEC_SD_CFG0                                     (0xda100000 + (0x80 << 2))
+#define   P_AO_SEC_SD_CFG0                                     (volatile uint32_t *)(0xc8100000 + (0x80 << 2))
+#define     AO_SEC_SD_CFG1                                     (0xc8100000 + (0x81 << 2))
+#define SEC_AO_SEC_SD_CFG1                                     (0xda100000 + (0x81 << 2))
+#define   P_AO_SEC_SD_CFG1                                     (volatile uint32_t *)(0xc8100000 + (0x81 << 2))
+#define     AO_SEC_SD_CFG2                                     (0xc8100000 + (0x82 << 2))
+#define SEC_AO_SEC_SD_CFG2                                     (0xda100000 + (0x82 << 2))
+#define   P_AO_SEC_SD_CFG2                                     (volatile uint32_t *)(0xc8100000 + (0x82 << 2))
+#define     AO_SEC_SD_CFG3                                     (0xc8100000 + (0x83 << 2))
+#define SEC_AO_SEC_SD_CFG3                                     (0xda100000 + (0x83 << 2))
+#define   P_AO_SEC_SD_CFG3                                     (volatile uint32_t *)(0xc8100000 + (0x83 << 2))
+#define     AO_SEC_SD_CFG4                                     (0xc8100000 + (0x84 << 2))
+#define SEC_AO_SEC_SD_CFG4                                     (0xda100000 + (0x84 << 2))
+#define   P_AO_SEC_SD_CFG4                                     (volatile uint32_t *)(0xc8100000 + (0x84 << 2))
+#define     AO_SEC_SD_CFG5                                     (0xc8100000 + (0x85 << 2))
+#define SEC_AO_SEC_SD_CFG5                                     (0xda100000 + (0x85 << 2))
+#define   P_AO_SEC_SD_CFG5                                     (volatile uint32_t *)(0xc8100000 + (0x85 << 2))
+#define     AO_SEC_SD_CFG6                                     (0xc8100000 + (0x86 << 2))
+#define SEC_AO_SEC_SD_CFG6                                     (0xda100000 + (0x86 << 2))
+#define   P_AO_SEC_SD_CFG6                                     (volatile uint32_t *)(0xc8100000 + (0x86 << 2))
+#define     AO_SEC_SD_CFG7                                     (0xc8100000 + (0x87 << 2))
+#define SEC_AO_SEC_SD_CFG7                                     (0xda100000 + (0x87 << 2))
+#define   P_AO_SEC_SD_CFG7                                     (volatile uint32_t *)(0xc8100000 + (0x87 << 2))
+#define     AO_SEC_SD_CFG8                                     (0xc8100000 + (0x88 << 2))
+#define SEC_AO_SEC_SD_CFG8                                     (0xda100000 + (0x88 << 2))
+#define   P_AO_SEC_SD_CFG8                                     (volatile uint32_t *)(0xc8100000 + (0x88 << 2))
+#define     AO_SEC_SD_CFG9                                     (0xc8100000 + (0x89 << 2))
+#define SEC_AO_SEC_SD_CFG9                                     (0xda100000 + (0x89 << 2))
+#define   P_AO_SEC_SD_CFG9                                     (volatile uint32_t *)(0xc8100000 + (0x89 << 2))
+#define     AO_SEC_SD_CFG10                                    (0xc8100000 + (0x8a << 2))
+#define SEC_AO_SEC_SD_CFG10                                    (0xda100000 + (0x8a << 2))
+#define   P_AO_SEC_SD_CFG10                                    (volatile uint32_t *)(0xc8100000 + (0x8a << 2))
+#define     AO_SEC_SD_CFG11                                    (0xc8100000 + (0x8b << 2))
+#define SEC_AO_SEC_SD_CFG11                                    (0xda100000 + (0x8b << 2))
+#define   P_AO_SEC_SD_CFG11                                    (volatile uint32_t *)(0xc8100000 + (0x8b << 2))
+#define     AO_SEC_SD_CFG12                                    (0xc8100000 + (0x8c << 2))
+#define SEC_AO_SEC_SD_CFG12                                    (0xda100000 + (0x8c << 2))
+#define   P_AO_SEC_SD_CFG12                                    (volatile uint32_t *)(0xc8100000 + (0x8c << 2))
+#define     AO_SEC_SD_CFG13                                    (0xc8100000 + (0x8d << 2))
+#define SEC_AO_SEC_SD_CFG13                                    (0xda100000 + (0x8d << 2))
+#define   P_AO_SEC_SD_CFG13                                    (volatile uint32_t *)(0xc8100000 + (0x8d << 2))
+#define     AO_SEC_SD_CFG14                                    (0xc8100000 + (0x8e << 2))
+#define SEC_AO_SEC_SD_CFG14                                    (0xda100000 + (0x8e << 2))
+#define   P_AO_SEC_SD_CFG14                                    (volatile uint32_t *)(0xc8100000 + (0x8e << 2))
+#define     AO_SEC_SD_CFG15                                    (0xc8100000 + (0x8f << 2))
+#define SEC_AO_SEC_SD_CFG15                                    (0xda100000 + (0x8f << 2))
+#define   P_AO_SEC_SD_CFG15                                    (volatile uint32_t *)(0xc8100000 + (0x8f << 2))
+#define     AO_SEC_GP_CFG0                                     (0xc8100000 + (0x90 << 2))
+#define SEC_AO_SEC_GP_CFG0                                     (0xda100000 + (0x90 << 2))
+#define   P_AO_SEC_GP_CFG0                                     (volatile uint32_t *)(0xc8100000 + (0x90 << 2))
+#define     AO_SEC_GP_CFG1                                     (0xc8100000 + (0x91 << 2))
+#define SEC_AO_SEC_GP_CFG1                                     (0xda100000 + (0x91 << 2))
+#define   P_AO_SEC_GP_CFG1                                     (volatile uint32_t *)(0xc8100000 + (0x91 << 2))
+#define     AO_SEC_GP_CFG2                                     (0xc8100000 + (0x92 << 2))
+#define SEC_AO_SEC_GP_CFG2                                     (0xda100000 + (0x92 << 2))
+#define   P_AO_SEC_GP_CFG2                                     (volatile uint32_t *)(0xc8100000 + (0x92 << 2))
+#define     AO_SEC_GP_CFG3                                     (0xc8100000 + (0x93 << 2))
+#define SEC_AO_SEC_GP_CFG3                                     (0xda100000 + (0x93 << 2))
+#define   P_AO_SEC_GP_CFG3                                     (volatile uint32_t *)(0xc8100000 + (0x93 << 2))
+#define     AO_SEC_GP_CFG4                                     (0xc8100000 + (0x94 << 2))
+#define SEC_AO_SEC_GP_CFG4                                     (0xda100000 + (0x94 << 2))
+#define   P_AO_SEC_GP_CFG4                                     (volatile uint32_t *)(0xc8100000 + (0x94 << 2))
+#define     AO_SEC_GP_CFG5                                     (0xc8100000 + (0x95 << 2))
+#define SEC_AO_SEC_GP_CFG5                                     (0xda100000 + (0x95 << 2))
+#define   P_AO_SEC_GP_CFG5                                     (volatile uint32_t *)(0xc8100000 + (0x95 << 2))
+#define     AO_SEC_GP_CFG6                                     (0xc8100000 + (0x96 << 2))
+#define SEC_AO_SEC_GP_CFG6                                     (0xda100000 + (0x96 << 2))
+#define   P_AO_SEC_GP_CFG6                                     (volatile uint32_t *)(0xc8100000 + (0x96 << 2))
+#define     AO_SEC_GP_CFG7                                     (0xc8100000 + (0x97 << 2))
+#define SEC_AO_SEC_GP_CFG7                                     (0xda100000 + (0x97 << 2))
+#define   P_AO_SEC_GP_CFG7                                     (volatile uint32_t *)(0xc8100000 + (0x97 << 2))
+//`define AO_RTC_ADDR0                    8'h70 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR1                    8'h71 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR2                    8'h72 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR3                    8'h73 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR4                    8'h74 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+// -------------------------------------------------------------------
+// PSEL #1
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100400
+// APB4_DECODER_SECURE_BASE         32'hDA100400
+// ----------------------------
+// IR Remote (8)
+// ----------------------------
+#define     AO_IR_DEC_LDR_ACTIVE                               (0xc8100400 + (0x20 << 2))
+#define SEC_AO_IR_DEC_LDR_ACTIVE                               (0xda100400 + (0x20 << 2))
+#define   P_AO_IR_DEC_LDR_ACTIVE                               (volatile uint32_t *)(0xc8100400 + (0x20 << 2))
+#define     AO_IR_DEC_LDR_IDLE                                 (0xc8100400 + (0x21 << 2))
+#define SEC_AO_IR_DEC_LDR_IDLE                                 (0xda100400 + (0x21 << 2))
+#define   P_AO_IR_DEC_LDR_IDLE                                 (volatile uint32_t *)(0xc8100400 + (0x21 << 2))
+#define     AO_IR_DEC_LDR_REPEAT                               (0xc8100400 + (0x22 << 2))
+#define SEC_AO_IR_DEC_LDR_REPEAT                               (0xda100400 + (0x22 << 2))
+#define   P_AO_IR_DEC_LDR_REPEAT                               (volatile uint32_t *)(0xc8100400 + (0x22 << 2))
+#define     AO_IR_DEC_BIT_0                                    (0xc8100400 + (0x23 << 2))
+#define SEC_AO_IR_DEC_BIT_0                                    (0xda100400 + (0x23 << 2))
+#define   P_AO_IR_DEC_BIT_0                                    (volatile uint32_t *)(0xc8100400 + (0x23 << 2))
+#define     AO_IR_DEC_REG0                                     (0xc8100400 + (0x24 << 2))
+#define SEC_AO_IR_DEC_REG0                                     (0xda100400 + (0x24 << 2))
+#define   P_AO_IR_DEC_REG0                                     (volatile uint32_t *)(0xc8100400 + (0x24 << 2))
+#define     AO_IR_DEC_FRAME                                    (0xc8100400 + (0x25 << 2))
+#define SEC_AO_IR_DEC_FRAME                                    (0xda100400 + (0x25 << 2))
+#define   P_AO_IR_DEC_FRAME                                    (volatile uint32_t *)(0xc8100400 + (0x25 << 2))
+#define     AO_IR_DEC_STATUS                                   (0xc8100400 + (0x26 << 2))
+#define SEC_AO_IR_DEC_STATUS                                   (0xda100400 + (0x26 << 2))
+#define   P_AO_IR_DEC_STATUS                                   (volatile uint32_t *)(0xc8100400 + (0x26 << 2))
+#define     AO_IR_DEC_REG1                                     (0xc8100400 + (0x27 << 2))
+#define SEC_AO_IR_DEC_REG1                                     (0xda100400 + (0x27 << 2))
+#define   P_AO_IR_DEC_REG1                                     (volatile uint32_t *)(0xc8100400 + (0x27 << 2))
+// ----------------------------
+// UART
+// ----------------------------
+#define     AO_UART_WFIFO                                      (0xc8100400 + (0x30 << 2))
+#define SEC_AO_UART_WFIFO                                      (0xda100400 + (0x30 << 2))
+#define   P_AO_UART_WFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x30 << 2))
+#define     AO_UART_RFIFO                                      (0xc8100400 + (0x31 << 2))
+#define SEC_AO_UART_RFIFO                                      (0xda100400 + (0x31 << 2))
+#define   P_AO_UART_RFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x31 << 2))
+#define     AO_UART_CONTROL                                    (0xc8100400 + (0x32 << 2))
+#define SEC_AO_UART_CONTROL                                    (0xda100400 + (0x32 << 2))
+#define   P_AO_UART_CONTROL                                    (volatile uint32_t *)(0xc8100400 + (0x32 << 2))
+#define     AO_UART_STATUS                                     (0xc8100400 + (0x33 << 2))
+#define SEC_AO_UART_STATUS                                     (0xda100400 + (0x33 << 2))
+#define   P_AO_UART_STATUS                                     (volatile uint32_t *)(0xc8100400 + (0x33 << 2))
+#define     AO_UART_MISC                                       (0xc8100400 + (0x34 << 2))
+#define SEC_AO_UART_MISC                                       (0xda100400 + (0x34 << 2))
+#define   P_AO_UART_MISC                                       (volatile uint32_t *)(0xc8100400 + (0x34 << 2))
+#define     AO_UART_REG5                                       (0xc8100400 + (0x35 << 2))
+#define SEC_AO_UART_REG5                                       (0xda100400 + (0x35 << 2))
+#define   P_AO_UART_REG5                                       (volatile uint32_t *)(0xc8100400 + (0x35 << 2))
+// ----------------------------
+// UART2
+// ----------------------------
+#define     AO_UART2_WFIFO                                     (0xc8100400 + (0x38 << 2))
+#define SEC_AO_UART2_WFIFO                                     (0xda100400 + (0x38 << 2))
+#define   P_AO_UART2_WFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x38 << 2))
+#define     AO_UART2_RFIFO                                     (0xc8100400 + (0x39 << 2))
+#define SEC_AO_UART2_RFIFO                                     (0xda100400 + (0x39 << 2))
+#define   P_AO_UART2_RFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x39 << 2))
+#define     AO_UART2_CONTROL                                   (0xc8100400 + (0x3a << 2))
+#define SEC_AO_UART2_CONTROL                                   (0xda100400 + (0x3a << 2))
+#define   P_AO_UART2_CONTROL                                   (volatile uint32_t *)(0xc8100400 + (0x3a << 2))
+#define     AO_UART2_STATUS                                    (0xc8100400 + (0x3b << 2))
+#define SEC_AO_UART2_STATUS                                    (0xda100400 + (0x3b << 2))
+#define   P_AO_UART2_STATUS                                    (volatile uint32_t *)(0xc8100400 + (0x3b << 2))
+#define     AO_UART2_MISC                                      (0xc8100400 + (0x3c << 2))
+#define SEC_AO_UART2_MISC                                      (0xda100400 + (0x3c << 2))
+#define   P_AO_UART2_MISC                                      (volatile uint32_t *)(0xc8100400 + (0x3c << 2))
+#define     AO_UART2_REG5                                      (0xc8100400 + (0x3d << 2))
+#define SEC_AO_UART2_REG5                                      (0xda100400 + (0x3d << 2))
+#define   P_AO_UART2_REG5                                      (volatile uint32_t *)(0xc8100400 + (0x3d << 2))
+// ----------------------------
+// I2C Master (8)
+// ----------------------------
+#define     AO_I2C_M_0_CONTROL_REG                             (0xc8100400 + (0x40 << 2))
+#define SEC_AO_I2C_M_0_CONTROL_REG                             (0xda100400 + (0x40 << 2))
+#define   P_AO_I2C_M_0_CONTROL_REG                             (volatile uint32_t *)(0xc8100400 + (0x40 << 2))
+#define     AO_I2C_M_0_SLAVE_ADDR                              (0xc8100400 + (0x41 << 2))
+#define SEC_AO_I2C_M_0_SLAVE_ADDR                              (0xda100400 + (0x41 << 2))
+#define   P_AO_I2C_M_0_SLAVE_ADDR                              (volatile uint32_t *)(0xc8100400 + (0x41 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST0                             (0xc8100400 + (0x42 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST0                             (0xda100400 + (0x42 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST0                             (volatile uint32_t *)(0xc8100400 + (0x42 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST1                             (0xc8100400 + (0x43 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST1                             (0xda100400 + (0x43 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST1                             (volatile uint32_t *)(0xc8100400 + (0x43 << 2))
+#define     AO_I2C_M_0_WDATA_REG0                              (0xc8100400 + (0x44 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG0                              (0xda100400 + (0x44 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x44 << 2))
+#define     AO_I2C_M_0_WDATA_REG1                              (0xc8100400 + (0x45 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG1                              (0xda100400 + (0x45 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x45 << 2))
+#define     AO_I2C_M_0_RDATA_REG0                              (0xc8100400 + (0x46 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG0                              (0xda100400 + (0x46 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x46 << 2))
+#define     AO_I2C_M_0_RDATA_REG1                              (0xc8100400 + (0x47 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG1                              (0xda100400 + (0x47 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x47 << 2))
+// ----------------------------
+// I2C Slave (3)
+// ----------------------------
+#define     AO_I2C_S_CONTROL_REG                               (0xc8100400 + (0x50 << 2))
+#define SEC_AO_I2C_S_CONTROL_REG                               (0xda100400 + (0x50 << 2))
+#define   P_AO_I2C_S_CONTROL_REG                               (volatile uint32_t *)(0xc8100400 + (0x50 << 2))
+#define     AO_I2C_S_SEND_REG                                  (0xc8100400 + (0x51 << 2))
+#define SEC_AO_I2C_S_SEND_REG                                  (0xda100400 + (0x51 << 2))
+#define   P_AO_I2C_S_SEND_REG                                  (volatile uint32_t *)(0xc8100400 + (0x51 << 2))
+#define     AO_I2C_S_RECV_REG                                  (0xc8100400 + (0x52 << 2))
+#define SEC_AO_I2C_S_RECV_REG                                  (0xda100400 + (0x52 << 2))
+#define   P_AO_I2C_S_RECV_REG                                  (volatile uint32_t *)(0xc8100400 + (0x52 << 2))
+#define     AO_I2C_S_CNTL1_REG                                 (0xc8100400 + (0x53 << 2))
+#define SEC_AO_I2C_S_CNTL1_REG                                 (0xda100400 + (0x53 << 2))
+#define   P_AO_I2C_S_CNTL1_REG                                 (volatile uint32_t *)(0xc8100400 + (0x53 << 2))
+// ----------------------------
+// PWM A-B
+// ----------------------------
+#define     AO_PWM_PWM_A                                       (0xc8100400 + (0x54 << 2))
+#define SEC_AO_PWM_PWM_A                                       (0xda100400 + (0x54 << 2))
+#define   P_AO_PWM_PWM_A                                       (volatile uint32_t *)(0xc8100400 + (0x54 << 2))
+#define     AO_PWM_PWM_B                                       (0xc8100400 + (0x55 << 2))
+#define SEC_AO_PWM_PWM_B                                       (0xda100400 + (0x55 << 2))
+#define   P_AO_PWM_PWM_B                                       (volatile uint32_t *)(0xc8100400 + (0x55 << 2))
+#define     AO_PWM_MISC_REG_AB                                 (0xc8100400 + (0x56 << 2))
+#define SEC_AO_PWM_MISC_REG_AB                                 (0xda100400 + (0x56 << 2))
+#define   P_AO_PWM_MISC_REG_AB                                 (volatile uint32_t *)(0xc8100400 + (0x56 << 2))
+#define     AO_PWM_DELTA_SIGMA_AB                              (0xc8100400 + (0x57 << 2))
+#define SEC_AO_PWM_DELTA_SIGMA_AB                              (0xda100400 + (0x57 << 2))
+#define   P_AO_PWM_DELTA_SIGMA_AB                              (volatile uint32_t *)(0xc8100400 + (0x57 << 2))
+// ----------------------------
+// Multiformat IR Remote
+// ----------------------------
+#define     AO_MF_IR_DEC_LDR_ACTIVE                            (0xc8100400 + (0x60 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_ACTIVE                            (0xda100400 + (0x60 << 2))
+#define   P_AO_MF_IR_DEC_LDR_ACTIVE                            (volatile uint32_t *)(0xc8100400 + (0x60 << 2))
+#define     AO_MF_IR_DEC_LDR_IDLE                              (0xc8100400 + (0x61 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_IDLE                              (0xda100400 + (0x61 << 2))
+#define   P_AO_MF_IR_DEC_LDR_IDLE                              (volatile uint32_t *)(0xc8100400 + (0x61 << 2))
+#define     AO_MF_IR_DEC_LDR_REPEAT                            (0xc8100400 + (0x62 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_REPEAT                            (0xda100400 + (0x62 << 2))
+#define   P_AO_MF_IR_DEC_LDR_REPEAT                            (volatile uint32_t *)(0xc8100400 + (0x62 << 2))
+#define     AO_MF_IR_DEC_BIT_0                                 (0xc8100400 + (0x63 << 2))
+#define SEC_AO_MF_IR_DEC_BIT_0                                 (0xda100400 + (0x63 << 2))
+#define   P_AO_MF_IR_DEC_BIT_0                                 (volatile uint32_t *)(0xc8100400 + (0x63 << 2))
+#define     AO_MF_IR_DEC_REG0                                  (0xc8100400 + (0x64 << 2))
+#define SEC_AO_MF_IR_DEC_REG0                                  (0xda100400 + (0x64 << 2))
+#define   P_AO_MF_IR_DEC_REG0                                  (volatile uint32_t *)(0xc8100400 + (0x64 << 2))
+#define     AO_MF_IR_DEC_FRAME                                 (0xc8100400 + (0x65 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME                                 (0xda100400 + (0x65 << 2))
+#define   P_AO_MF_IR_DEC_FRAME                                 (volatile uint32_t *)(0xc8100400 + (0x65 << 2))
+#define     AO_MF_IR_DEC_STATUS                                (0xc8100400 + (0x66 << 2))
+#define SEC_AO_MF_IR_DEC_STATUS                                (0xda100400 + (0x66 << 2))
+#define   P_AO_MF_IR_DEC_STATUS                                (volatile uint32_t *)(0xc8100400 + (0x66 << 2))
+#define     AO_MF_IR_DEC_REG1                                  (0xc8100400 + (0x67 << 2))
+#define SEC_AO_MF_IR_DEC_REG1                                  (0xda100400 + (0x67 << 2))
+#define   P_AO_MF_IR_DEC_REG1                                  (volatile uint32_t *)(0xc8100400 + (0x67 << 2))
+#define     AO_MF_IR_DEC_REG2                                  (0xc8100400 + (0x68 << 2))
+#define SEC_AO_MF_IR_DEC_REG2                                  (0xda100400 + (0x68 << 2))
+#define   P_AO_MF_IR_DEC_REG2                                  (volatile uint32_t *)(0xc8100400 + (0x68 << 2))
+#define     AO_MF_IR_DEC_DURATN2                               (0xc8100400 + (0x69 << 2))
+#define SEC_AO_MF_IR_DEC_DURATN2                               (0xda100400 + (0x69 << 2))
+#define   P_AO_MF_IR_DEC_DURATN2                               (volatile uint32_t *)(0xc8100400 + (0x69 << 2))
+#define     AO_MF_IR_DEC_DURATN3                               (0xc8100400 + (0x6a << 2))
+#define SEC_AO_MF_IR_DEC_DURATN3                               (0xda100400 + (0x6a << 2))
+#define   P_AO_MF_IR_DEC_DURATN3                               (volatile uint32_t *)(0xc8100400 + (0x6a << 2))
+#define     AO_MF_IR_DEC_FRAME1                                (0xc8100400 + (0x6b << 2))
+#define SEC_AO_MF_IR_DEC_FRAME1                                (0xda100400 + (0x6b << 2))
+#define   P_AO_MF_IR_DEC_FRAME1                                (volatile uint32_t *)(0xc8100400 + (0x6b << 2))
+#define     AO_MF_IR_DEC_STATUS1                               (0xc8100400 + (0x6c << 2))
+#define SEC_AO_MF_IR_DEC_STATUS1                               (0xda100400 + (0x6c << 2))
+#define   P_AO_MF_IR_DEC_STATUS1                               (volatile uint32_t *)(0xc8100400 + (0x6c << 2))
+#define     AO_MF_IR_DEC_STATUS2                               (0xc8100400 + (0x6d << 2))
+#define SEC_AO_MF_IR_DEC_STATUS2                               (0xda100400 + (0x6d << 2))
+#define   P_AO_MF_IR_DEC_STATUS2                               (volatile uint32_t *)(0xc8100400 + (0x6d << 2))
+#define     AO_MF_IR_DEC_REG3                                  (0xc8100400 + (0x6e << 2))
+#define SEC_AO_MF_IR_DEC_REG3                                  (0xda100400 + (0x6e << 2))
+#define   P_AO_MF_IR_DEC_REG3                                  (volatile uint32_t *)(0xc8100400 + (0x6e << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV0                            (0xc8100400 + (0x6f << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV0                            (0xda100400 + (0x6f << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV0                            (volatile uint32_t *)(0xc8100400 + (0x6f << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV1                            (0xc8100400 + (0x70 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV1                            (0xda100400 + (0x70 << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV1                            (volatile uint32_t *)(0xc8100400 + (0x70 << 2))
+// ---------------------------
+// SAR ADC
+// ---------------------------
+// `define AO_SAR_ADC_REG0             8'h80
+// `define AO_SAR_ADC_CHAN_LIST        8'h81
+// `define AO_SAR_ADC_AVG_CNTL         8'h82
+// `define AO_SAR_ADC_REG3             8'h83
+// `define AO_SAR_ADC_DELAY            8'h84
+// `define AO_SAR_ADC_LAST_RD          8'h85
+// `define AO_SAR_ADC_FIFO_RD          8'h86
+// `define AO_SAR_ADC_AUX_SW           8'h87
+// `define AO_SAR_ADC_CHAN_10_SW       8'h88
+// `define AO_SAR_ADC_DETECT_IDLE_SW   8'h89
+// `define AO_SAR_ADC_DELTA_10         8'h8a
+// `define AO_SAR_ADC_REG11            8'h8b
+// `define AO_SAR_ADC_REG12            8'h8c
+// ---------------------------
+// RTC (4)
+// ---------------------------
+// Moved to the secure APB3 bus
+// `define AO_RTC_ADDR0                8'hd0
+// `define AO_RTC_ADDR1                8'hd1
+// `define AO_RTC_ADDR2                8'hd2
+// `define AO_RTC_ADDR3                8'hd3
+// `define AO_RTC_ADDR4                8'hd4
+//
+// Closing file:  ./ao_rti_reg.h
+//
+
+#endif // SECURE_APB_H
diff --git a/arch/arm/include/asm/arch-gxb/timer.h b/arch/arm/include/asm/arch-gxb/timer.h
new file mode 100644
index 0000000..7be8e3f
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/timer.h
@@ -0,0 +1,41 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/timer.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __TIMER_H
+#define __TIMER_H
+
+#include <asm/arch/romboot.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/io.h>
+
+/**
+ * Get the current timestamp from the system timer.
+ */
+uint32_t get_time(void);
+
+/**
+ * Busy-wait.
+ *
+ * @param us            Number of microseconds to delay.
+ */
+void _udelay(unsigned int us);
+
+#endif /* __TIMER_H */
diff --git a/arch/arm/include/asm/arch-gxb/timing.h b/arch/arm/include/asm/arch-gxb/timing.h
new file mode 100644
index 0000000..fbca4a6
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/timing.h
@@ -0,0 +1,161 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/timing.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __AML_TIMING_H_
+#define __AML_TIMING_H_
+
+struct ddr_set{
+	/* common and function defines */
+	unsigned char  ddr_channel_set;
+	unsigned char  ddr_type;
+	unsigned char  ddr_2t_mode;
+	unsigned char  ddr_full_test;
+	unsigned char  ddr_size_detect;
+	unsigned char  ddr_drv;
+	unsigned char  ddr_odt;
+	unsigned char  ddr_timing_ind;
+	unsigned short ddr_size; //define in header file
+	unsigned short ddr_clk;
+	unsigned int   ddr_base_addr;
+	unsigned int   ddr_start_offset;
+	unsigned int   ddr_pll_ctrl;
+	unsigned int   ddr_dmc_ctrl;
+	unsigned int   ddr0_addrmap[5];
+	unsigned int   ddr1_addrmap[5];
+
+	/* pub defines */
+	unsigned int   t_pub_ptr[5];  //PUB PTR0-3
+	unsigned short t_pub_mr[4];   //PUB MR0-3
+	unsigned int   t_pub_odtcr;
+	unsigned int   t_pub_dtpr[4]; //PUB DTPR0-3
+	unsigned int   t_pub_pgcr0;   //PUB PGCR0
+	unsigned int   t_pub_pgcr1;   //PUB PGCR1
+	unsigned int   t_pub_pgcr2;   //PUB PGCR2
+	unsigned int   t_pub_pgcr3;   //PUB PGCR3
+	unsigned int   t_pub_dxccr;   //PUB DXCCR
+	unsigned int   t_pub_dtcr;    //PUB DTCR
+	unsigned int   t_pub_aciocr[5];  //PUB ACIOCRx
+	unsigned int   t_pub_dx0gcr[3];  //PUB DX0GCRx
+	unsigned int   t_pub_dx1gcr[3];  //PUB DX1GCRx
+	unsigned int   t_pub_dx2gcr[3];  //PUB DX2GCRx
+	unsigned int   t_pub_dx3gcr[3];  //PUB DX3GCRx
+	unsigned int   t_pub_dcr;     //PUB DCR
+	unsigned int   t_pub_dtar;
+	unsigned int   t_pub_dsgcr;   //PUB DSGCR
+	unsigned int   t_pub_zq0pr;   //PUB ZQ0PR
+	unsigned int   t_pub_zq1pr;   //PUB ZQ1PR
+	unsigned int   t_pub_zq2pr;   //PUB ZQ2PR
+	unsigned int   t_pub_zq3pr;   //PUB ZQ3PR
+
+	/* pctl0 defines */
+	unsigned short t_pctl0_1us_pck;   //PCTL TOGCNT1U
+	unsigned short t_pctl0_100ns_pck; //PCTL TOGCNT100N
+	unsigned short t_pctl0_init_us;   //PCTL TINIT
+	unsigned short t_pctl0_rsth_us;   //PCTL TRSTH
+	unsigned int   t_pctl0_mcfg;   //PCTL MCFG
+	unsigned int   t_pctl0_mcfg1;  //PCTL MCFG1
+	unsigned short t_pctl0_scfg;   //PCTL SCFG
+	unsigned short t_pctl0_sctl;   //PCTL SCTL
+	unsigned int   t_pctl0_ppcfg;
+	unsigned short t_pctl0_dfistcfg0;
+	unsigned short t_pctl0_dfistcfg1;
+	unsigned short t_pctl0_dfitctrldelay;
+	unsigned short t_pctl0_dfitphywrdata;
+	unsigned short t_pctl0_dfitphywrlta;
+	unsigned short t_pctl0_dfitrddataen;
+	unsigned short t_pctl0_dfitphyrdlat;
+	unsigned short t_pctl0_dfitdramclkdis;
+	unsigned short t_pctl0_dfitdramclken;
+	unsigned short t_pctl0_dfitphyupdtype1;
+	unsigned short t_pctl0_dfitctrlupdmin;
+	unsigned short t_pctl0_cmdtstaten;
+	unsigned int   t_pctl0_dfiodtcfg;
+	unsigned int   t_pctl0_dfiodtcfg1;
+	unsigned int   t_pctl0_dfilpcfg0;
+
+	//PUB CLK fine tune
+	unsigned int   t_pub_acbdlr0; //2015.09.21 CK0 delay for different board PCB design
+
+}__attribute__ ((packed));
+
+struct ddr_timing{
+	//Identifier
+	unsigned char  identifier; //refer ddr.h
+
+	//DTPR0
+	unsigned char  cfg_ddr_rtp;
+	unsigned char  cfg_ddr_wtr;
+	unsigned char  cfg_ddr_rp;
+	unsigned char  cfg_ddr_rcd;
+	unsigned char  cfg_ddr_ras;
+	unsigned char  cfg_ddr_rrd;
+	unsigned char  cfg_ddr_rc;
+
+	//DTPR1
+	unsigned char  cfg_ddr_mrd;
+	unsigned char  cfg_ddr_mod;
+	unsigned char  cfg_ddr_faw;
+	unsigned char  cfg_ddr_wlmrd;
+	unsigned char  cfg_ddr_wlo;
+
+	//DTPR2
+	unsigned char  cfg_ddr_xp;
+
+	//DTPR1
+	unsigned short cfg_ddr_rfc;
+
+	//DTPR2
+	unsigned short cfg_ddr_xs;
+	unsigned short cfg_ddr_dllk;
+	unsigned char  cfg_ddr_cke;
+	unsigned char  cfg_ddr_rtodt;
+	unsigned char  cfg_ddr_rtw;
+
+	unsigned char  cfg_ddr_refi;
+	unsigned char  cfg_ddr_refi_mddr3;
+	unsigned char  cfg_ddr_cl;
+	unsigned char  cfg_ddr_wr;
+	unsigned char  cfg_ddr_cwl;
+	unsigned char  cfg_ddr_al;
+	unsigned char  cfg_ddr_dqs;
+	unsigned char  cfg_ddr_cksre;
+	unsigned char  cfg_ddr_cksrx;
+	unsigned char  cfg_ddr_zqcs;
+	unsigned char  cfg_ddr_xpdll;
+	unsigned short cfg_ddr_exsr;
+	unsigned short cfg_ddr_zqcl;
+	unsigned short cfg_ddr_zqcsi;
+}__attribute__ ((packed));
+
+typedef struct ddr_set ddr_set_t;
+typedef struct ddr_timing ddr_timing_t;
+
+struct pll_set{
+	unsigned short cpu_clk;
+	unsigned short pxp;
+	unsigned int spi_ctrl;
+	unsigned short vddee;
+	unsigned short vcck;
+}__attribute__ ((packed));
+
+typedef struct pll_set pll_set_t;
+
+#endif //__AML_TIMING_H_
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-gxb/uart.h b/arch/arm/include/asm/arch-gxb/uart.h
new file mode 100644
index 0000000..e8aa5d9
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/uart.h
@@ -0,0 +1,168 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/uart.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __MESON_FIRM_UART_H_
+#define __MESON_FIRM_UART_H_
+#include <config.h>
+#include <common.h>
+#include "register.h"
+//#include "io.h"
+
+
+#ifndef CONFIG_CONS_INDEX
+#error Please define CONFIG_CONS_INDEX==[0|1]
+#endif
+
+#if CONFIG_CONS_INDEX==0
+#define UART_PORT_CONS UART_PORT_0
+#elif CONFIG_CONS_INDEX==1
+#define UART_PORT_CONS UART_PORT_1
+#elif CONFIG_CONS_INDEX==2
+#define UART_PORT_CONS UART_PORT_AO
+#define USE_AO_UART   1
+#else
+#error Please define CONFIG_CONS_INDEX==[0|1]
+#endif
+/*
+#define UART_PORT_0     CBUS_REG_ADDR(UART0_WFIFO)
+#define UART_PORT_1     CBUS_REG_ADDR(UART1_WFIFO)
+#define UART_PORT_2     CBUS_REG_ADDR(UART2_WFIFO)
+#define UART_PORT_AO    P_AO_UART_WFIFO
+
+#define UART_WFIFO      (0<<2)
+#define UART_RFIFO      (1<<2)
+#define UART_CONTROL    (2<<2)
+#define UART_STATUS     (3<<2)
+#define UART_MISC       (4<<2)
+*/
+
+#include "clock.h"
+
+#define UART_CLK_SRC    CLK81
+#define UART_PORT_0     UART0_WFIFO
+#define UART_PORT_1     UART1_WFIFO
+#define UART_PORT_AO    P_AO_UART_WFIFO
+#define UART_WFIFO      0
+#define UART_RFIFO      1
+#define UART_CONTROL    2
+#define UART_STATUS     3
+#define UART_MISC       4
+
+#if USE_AO_UART == 1
+#define P_UART(uart_base,reg)    	  (uart_base + (reg<<2))
+#else
+#define P_UART(uart_base,reg)    	CBUS_REG_ADDR(uart_base+reg)
+#endif
+#define P_UART_WFIFO(uart_base)   	P_UART(uart_base,UART_WFIFO)
+#define P_UART_RFIFO(uart_base)   	P_UART(uart_base,UART_RFIFO)
+
+#define P_UART_CONTROL(uart_base)    P_UART(uart_base,UART_CONTROL)
+    #define UART_CNTL_MASK_BAUD_RATE                (0xfff)
+    #define UART_CNTL_MASK_TX_EN                    (1<<12)
+    #define UART_CNTL_MASK_RX_EN                    (1<<13)
+    #define UART_CNTL_MASK_2WIRE                    (1<<15)
+    #define UART_CNTL_MASK_STP_BITS                 (3<<16)
+    #define UART_CNTL_MASK_STP_1BIT                 (0<<16)
+    #define UART_CNTL_MASK_STP_2BIT                 (1<<16)
+    #define UART_CNTL_MASK_PRTY_EVEN                (0<<18)
+    #define UART_CNTL_MASK_PRTY_ODD                 (1<<18)
+    #define UART_CNTL_MASK_PRTY_TYPE                (1<<18)
+    #define UART_CNTL_MASK_PRTY_EN                  (1<<19)
+    #define UART_CNTL_MASK_CHAR_LEN                 (3<<20)
+    #define UART_CNTL_MASK_CHAR_8BIT                (0<<20)
+    #define UART_CNTL_MASK_CHAR_7BIT                (1<<20)
+    #define UART_CNTL_MASK_CHAR_6BIT                (2<<20)
+    #define UART_CNTL_MASK_CHAR_5BIT                (3<<20)
+    #define UART_CNTL_MASK_RST_TX                   (1<<22)
+    #define UART_CNTL_MASK_RST_RX                   (1<<23)
+    #define UART_CNTL_MASK_CLR_ERR                  (1<<24)
+    #define UART_CNTL_MASK_INV_RX                   (1<<25)
+    #define UART_CNTL_MASK_INV_TX                   (1<<26)
+    #define UART_CNTL_MASK_RINT_EN                  (1<<27)
+    #define UART_CNTL_MASK_TINT_EN                  (1<<28)
+    #define UART_CNTL_MASK_INV_CTS                  (1<<29)
+    #define UART_CNTL_MASK_MASK_ERR                 (1<<30)
+    #define UART_CNTL_MASK_INV_RTS                  (1<<31)
+#define P_UART_STATUS(uart_base)  P_UART(uart_base,UART_STATUS )
+    #define UART_STAT_MASK_RFIFO_CNT                (0x7f<<0)
+    #define UART_STAT_MASK_TFIFO_CNT                (0x7f<<8)
+    #define UART_STAT_MASK_PRTY_ERR                 (1<<16)
+    #define UART_STAT_MASK_FRAM_ERR                 (1<<17)
+    #define UART_STAT_MASK_WFULL_ERR                (1<<18)
+    #define UART_STAT_MASK_RFIFO_FULL               (1<<19)
+    #define UART_STAT_MASK_RFIFO_EMPTY              (1<<20)
+    #define UART_STAT_MASK_TFIFO_FULL               (1<<21)
+    #define UART_STAT_MASK_TFIFO_EMPTY              (1<<22)
+    #define UART_STAT_MASK_XMIT_BUSY					(1<<25)
+    #define UART_STAT_MASK_RECV_BUSY					(1<<26)
+#define P_UART_MISC(uart_base)    P_UART(uart_base,UART_MISC   )
+
+
+#ifndef CONFIG_SERIAL_STP_BITS
+#define CONFIG_SERIAL_STP_BITS 1 // 1 , 2
+#endif
+#if CONFIG_SERIAL_STP_BITS==1
+#define UART_STP_BIT UART_CNTL_MASK_STP_1BIT
+#elif CONFIG_SERIAL_STP_BITS==2
+#define UART_STP_BIT UART_CNTL_MASK_STP_2BIT
+#else
+#error CONFIG_SERIAL_STP_BITS wrong
+#endif
+
+
+#ifndef CONFIG_SERIAL_PRTY_TYPE
+#define CONFIG_SERIAL_PRTY_TYPE 0 //0 ,2 ,3
+#endif
+#if CONFIG_SERIAL_PRTY_TYPE==0
+#define UART_PRTY_BIT 0
+#elif CONFIG_SERIAL_PRTY_TYPE==2
+#define UART_PRTY_BIT    (UART_CNTL_MASK_PRTY_EN|UART_CNTL_MASK_PRTY_EVEN)
+#elif CONFIG_SERIAL_PRTY_TYPE==3
+#define UART_PRTY_BIT    (UART_CNTL_MASK_PRTY_EN|UART_CNTL_MASK_PRTY_ODD)
+#else
+#error CONFIG_SERIAL_PRTY_TYPE wrong
+#endif
+
+#ifndef CONFIG_SERIAL_CHAR_LEN
+#define CONFIG_SERIAL_CHAR_LEN 8 //5,6,7,8
+#endif
+#if CONFIG_SERIAL_CHAR_LEN==5
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_5BIT
+#elif CONFIG_SERIAL_CHAR_LEN==6
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_6BIT
+#elif CONFIG_SERIAL_CHAR_LEN==7
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_7BIT
+#elif CONFIG_SERIAL_CHAR_LEN==8
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_8BIT
+#else
+#error CONFIG_SERIAL_CHAR_LEN wrong
+#endif
+#define UART_CONTROL_SET(baud,clk81)                        \
+                        (((clk81)/(baud*4) -1)              \
+                        | UART_STP_BIT                      \
+                        | UART_PRTY_BIT                     \
+                        | UART_CHAR_LEN                     \
+                        | UART_CNTL_MASK_TX_EN              \
+                        | UART_CNTL_MASK_RX_EN              \
+                        | UART_CNTL_MASK_RST_TX             \
+                        | UART_CNTL_MASK_RST_RX             \
+                        | UART_CNTL_MASK_CLR_ERR    )
+#endif
diff --git a/arch/arm/include/asm/arch-gxb/usb.h b/arch/arm/include/asm/arch-gxb/usb.h
new file mode 100644
index 0000000..2468772
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/usb.h
@@ -0,0 +1,282 @@
+
+/*
+ * arch/arm/include/asm/arch-gxb/usb.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_ARM_MESON_USB_H_U_BOOT__
+#define __ARCH_ARM_MESON_USB_H_U_BOOT__
+
+#include <common.h>
+#include <asm/types.h>
+#include <asm/arch/io.h>
+/*
+#define USB_PHY_PORT_A	    (0x40000)
+#define USB_PHY_PORT_B	    (0xc0000)
+#define USB_PHY_PORT_C	    (0x100000)
+#define USB_PHY_PORT_D	    (0x140000)
+#define USB_PHY_PORT_MSK	(0x1f0000) */
+
+#define USB_PHY_PORT_A		0x000000
+#define USB_PHY_PORT_B		0x100000
+#define USB_PHY_PORT_C		0x200000
+#define USB_PHY_PORT_D		0x300000
+#define USB_PHY_PORT_MSK	0x300000
+#define USB_PHY_PORT_MAX	2
+
+#define PREI_USB_PHY_REG_A     0xc0000000
+#define PREI_USB_PHY_REG_B     0xc0000020
+//#define PREI_USB_PHY_REG_C     0x2210
+//#define PREI_USB_PHY_REG_D     0x2218
+typedef struct usb_peri_reg {
+	volatile uint32_t config;
+	volatile uint32_t ctrl;
+	volatile uint32_t endp_intr;
+	volatile uint32_t adp_bc;
+	volatile uint32_t dbg_uart;
+	volatile uint32_t test;
+	volatile uint32_t tune;
+	volatile uint32_t reserved;
+} usb_peri_reg_t;
+
+typedef union usb_config_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned clk_en:1;
+        unsigned clk_sel:3;
+        unsigned clk_div:7;
+        unsigned reserved0:4;
+        unsigned clk_32k_alt_sel:1;
+        unsigned reserved1:15;
+        unsigned test_trig:1;
+    } b;
+} usb_config_data_t;
+
+typedef union usb_ctrl_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned soft_prst:1;
+        unsigned soft_hreset:1;
+        unsigned ss_scaledown_mode:2;
+        unsigned clk_det_rst:1;
+        unsigned intr_sel:1;
+        unsigned reserved:2;
+        unsigned clk_detected:1;
+        unsigned sof_sent_rcvd_tgl:1;
+        unsigned sof_toggle_out:1;
+        unsigned not_used:4;
+        unsigned por:1;
+        unsigned sleepm:1;
+        unsigned txbitstuffennh:1;
+        unsigned txbitstuffenn:1;
+        unsigned commononn:1;
+        unsigned refclksel:2;
+        unsigned fsel:3;
+        unsigned portreset:1;
+        unsigned thread_id:6;
+    } b;
+} usb_ctrl_data_t;
+
+typedef union usb_endp_intr_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned int0:1;
+        unsigned int1:1;
+        unsigned int2:1;
+        unsigned int3:1;
+        unsigned int4:1;
+        unsigned int5:1;
+        unsigned int6:1;
+        unsigned int7:1;
+        unsigned int8:1;
+        unsigned int9:1;
+        unsigned int10:1;
+        unsigned int11:1;
+        unsigned int12:1;
+        unsigned int13:1;
+        unsigned int14:1;
+        unsigned int15:1;
+        unsigned int16:1;
+        unsigned int17:1;
+        unsigned int18:1;
+        unsigned int19:1;
+        unsigned int20:1;
+        unsigned int21:1;
+        unsigned int22:1;
+        unsigned int23:1;
+        unsigned int24:1;
+        unsigned int25:1;
+        unsigned int26:1;
+        unsigned int27:1;
+        unsigned int28:1;
+        unsigned int29:1;
+        unsigned int30:1;
+        unsigned int31:1;
+    } b;
+} usb_endp_intr_data_t;
+
+typedef union usb_adp_bc_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned vbusvldextsel:1;
+	unsigned vbusvldext:1;
+	unsigned otgdisable:1;
+	unsigned idpullup:1;
+	unsigned drvvbus:1;
+	unsigned adp_prb_en:1;
+	unsigned adp_dischrg:1;
+	unsigned adp_chrg:1;
+	unsigned sessend:1;
+	unsigned device_sess_vld:1;
+	unsigned bvalid:1;
+	unsigned avalid:1;
+	unsigned iddig:1;
+	unsigned vbusvalid:1;
+	unsigned adp_probe:1;
+	unsigned adp_sense:1;
+	unsigned aca_enable:1;
+	unsigned dcd_enable:1;
+	unsigned vdatdetenb:1;
+	unsigned vdatsrcenb:1;
+	unsigned chrgsel:1;
+	unsigned chg_det:1;
+	unsigned aca_pin_range_c:1;
+	unsigned aca_pin_range_b:1;
+	unsigned aca_pin_range_a:1;
+	unsigned aca_pin_gnd:1;
+	unsigned aca_pin_float:1;
+	unsigned not_used:5;
+    } b;
+} usb_adp_bc_data_t;
+
+typedef union usb_dbg_uart_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned bypass_sel:1;
+	unsigned bypass_dm_en:1;
+	unsigned bypass_dp_en:1;
+	unsigned bypass_dm_data:1;
+	unsigned bypass_dp_data:1;
+	unsigned fsv_minus:1;
+	unsigned fsv_plus:1;
+	unsigned burn_in_test:1;
+	unsigned loopbackenb:1;
+	unsigned set_iddq:1;
+	unsigned ate_reset:1;
+	unsigned reserved:4;
+	unsigned not_used:17;
+    } b;
+} usb_dbg_uart_data_t;
+
+typedef union phy_test_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned data_in:4;
+	unsigned data_in_en:4;
+	unsigned addr:4;
+	unsigned data_out_sel:1;
+	unsigned clk:1;
+	unsigned vatestenb:2;
+	unsigned data_out:4;
+	unsigned not_used:12;
+    } b;
+} phy_test_data_t;
+
+typedef union phy_tune_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned tx_res_tune:2;
+	unsigned tx_hsxv_tune:2;
+	unsigned tx_vref_tune:4;
+	unsigned tx_rise_tune:2;
+	unsigned tx_preemp_pulse_tune:1;
+	unsigned tx_preemp_amp_tune:2;
+	unsigned tx_fsls_tune:4;
+	unsigned sqrx_tune:3;
+	unsigned otg_tune:3;
+	unsigned comp_dis_tune:3;
+	unsigned not_used:6;
+    } b;
+} phy_tune_data_t;
+
+
+/*
+ * Clock source index must sync with chip's spec
+ * M1/M2/M3/M6/M8 are different!
+ * This is only for M8
+ */
+#define USB_PHY_CLK_SEL_XTAL	0
+
+#define USB_PHY_A_INTR_BIT	(1 << 30)
+#define USB_PHY_B_INTR_BIT	(1 << 31)
+
+/* usb id mode, only after M2
+	 mode = 0 : HARDWARE
+	 mode = 1 : SW_HOST
+	 mode = 2 : SW_DEVICE
+ */
+#define USB_ID_MODE_HARDWARE    (1)
+#define USB_ID_MODE_SW_HOST     (2)
+#define USB_ID_MODE_SW_DEVICE   (3)
+
+typedef struct amlogic_usb_config{
+	/* clock info */
+	int clk_selecter; // usb USB_PHY_CLOCK_SEL_xxx
+	int pll_divider;  // when other/ddr/demod pll used, fill this
+
+	/* controller */
+	unsigned int base_addr;
+
+	/* role */
+	int id_mode; // only used after M2
+
+	/* vbus call back */
+	void (* set_vbus_power)(char is_power_on);
+
+	/* battery charging detect call back */
+	int(* battery_charging_det_cb)(char bc_mode);
+#define BC_MODE_UNKNOWN	0
+#define BC_MODE_SDP		1	/* Standard Downstream Port */
+#define BC_MODE_DCP		2	/* Dedicated Charging Port */
+#define BC_MODE_CDP		3	/* Charging Downstream Port */
+
+}amlogic_usb_config_t;
+
+#define BOARD_USB_MODE_HOST	0
+#define BOARD_USB_MODE_SLAVE	1
+#define BOARD_USB_MODE_CHARGER	2
+#define BOARD_USB_MODE_MAX	3
+amlogic_usb_config_t * amlogic_usb_start(int mode,int index);
+int amlogic_usb_stop(int mode,int index);
+void amlogic_usb_init(amlogic_usb_config_t * usb_cfg,int mode);
+int get_usb_count(void);
+#endif //__ARCH_ARM_MESON_USB_H_U_BOOT__
diff --git a/arch/arm/include/asm/arch-gxb/watchdog.h b/arch/arm/include/asm/arch-gxb/watchdog.h
new file mode 100644
index 0000000..f26254b
--- /dev/null
+++ b/arch/arm/include/asm/arch-gxb/watchdog.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Watchdog related routine defines
+ */
+
+#ifndef _BOOT_ROM_WATCHDOG_H
+#define _BOOT_ROM_WATCHDOG_H
+
+//#include "common.h"
+
+void watchdog_init(uint32_t msec);
+void watchdog_reset(void);
+void reset_system(void);
+void watchdog_disable(void);
+
+/* uboot reset interface */
+void reset_cpu(unsigned long flag);
+
+#endif /* _BOOT_ROM_WATCHDOG_H */
diff --git a/arch/arm/include/asm/io.h b/arch/arm/include/asm/io.h
index bfbe0a0..dedbdd1 100644
--- a/arch/arm/include/asm/io.h
+++ b/arch/arm/include/asm/io.h
@@ -453,6 +453,6 @@ out:
 #endif	/* __mem_isa */
 #endif	/* __KERNEL__ */
 
-#include <iotrace.h>
+//#include <iotrace.h>
 
 #endif	/* __ASM_ARM_IO_H */
diff --git a/arch/arm/include/asm/macro.h b/arch/arm/include/asm/macro.h
index 1c8c425..9394093 100644
--- a/arch/arm/include/asm/macro.h
+++ b/arch/arm/include/asm/macro.h
@@ -79,6 +79,9 @@ lr	.req	x30
  */
 .macro	branch_if_slave, xreg, slave_label
 	mrs	\xreg, mpidr_el1
+	#if defined(MPIDR_CLUSTER_MASTER_CORE)
+	eor \xreg1, \xreg1, #MPIDR_CLUSTER_MASTER_CORE
+	#endif
 	tst	\xreg, #0xff		/* Test Affinity 0 */
 	b.ne	\slave_label
 	lsr	\xreg, \xreg, #8
@@ -101,6 +104,9 @@ lr	.req	x30
 	lsr	\xreg2, \xreg1, #32
 	lsl	\xreg1, \xreg1, #40
 	lsr	\xreg1, \xreg1, #40
+	#if defined(MPIDR_CLUSTER_MASTER_CORE)
+	eor \xreg1, \xreg1, #MPIDR_CLUSTER_MASTER_CORE
+	#endif
 	orr	\xreg1, \xreg1, \xreg2
 	cbz	\xreg1, \master_label
 .endm
diff --git a/arch/arm/include/asm/saradc.h b/arch/arm/include/asm/saradc.h
new file mode 100644
index 0000000..88831c3
--- /dev/null
+++ b/arch/arm/include/asm/saradc.h
@@ -0,0 +1,41 @@
+#ifndef __AML_SARADC_H__
+#define __AML_SARADC_H__
+
+enum{AML_ADC_CHAN_0 = 0, AML_ADC_CHAN_1, AML_ADC_CHAN_2, AML_ADC_CHAN_3,
+	 AML_ADC_CHAN_4,	 AML_ADC_CHAN_5, AML_ADC_CHAN_6, AML_ADC_CHAN_7,
+	 AML_ADC_SARADC_CHAN_NUM,
+};
+
+enum{AML_ADC_NO_AVG = 0,  AML_ADC_SIMPLE_AVG_1, AML_ADC_SIMPLE_AVG_2,
+	 AML_ADC_SIMPLE_AVG_4,AML_ADC_SIMPLE_AVG_8, AML_ADC_MEDIAN_AVG_8,
+};
+
+#define AML_ADC_CHAN_XP	AML_ADC_CHAN_0
+#define AML_ADC_CHAN_YP	AML_ADC_CHAN_1
+#define AML_ADC_CHAN_XN	AML_ADC_CHAN_2
+#define AML_ADC_CHAN_YN	AML_ADC_CHAN_3
+
+
+
+typedef struct adckey_info{
+	const char *key;
+	int   value;	/* voltage/3.3v * 1023 */
+	int   tolerance;
+}adckey_info_t;
+
+typedef struct adc_info{
+	char * tint;
+	int    chan;
+	int    adc_type;
+	void * adc_data;
+}adc_info_t;
+
+struct adc_device{
+	adc_info_t * adc_device_info;
+	unsigned dev_num;
+};
+void saradc_enable(void);
+int saradc_disable(void);
+int  get_adc_sample_gxbb(int chan);
+
+#endif /*__AML_SARADC_H__*/
\ No newline at end of file
diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
index 0c1298a..18d3b6c 100644
--- a/arch/arm/lib/bootm.c
+++ b/arch/arm/lib/bootm.c
@@ -24,6 +24,14 @@
 #include <linux/compiler.h>
 #include <bootm.h>
 #include <vxworks.h>
+#include <asm/arch/timer.h>
+
+#ifdef CONFIG_ODROID_C2
+#include <asm/arch-gxb/gpio.h>
+#include <asm-generic/gpio.h>
+#define GPIO_TF3V3		35
+#define GPIO_TF1V8		122
+#endif
 
 #if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
 #include <asm/armv7.h>
@@ -196,6 +204,21 @@ static void do_nonsec_virt_switch(void)
 #ifdef CONFIG_ARMV8_SWITCH_TO_EL1
 	armv8_switch_to_el1();
 #endif
+
+#ifdef CONFIG_ODROID_C2
+	/* T-Flash card reset */
+	gpio_request(GPIO_TF1V8, "TF_1V8");
+	gpio_request(GPIO_TF3V3, "TF_3V3");
+
+	gpio_direction_output(GPIO_TF1V8, 0);
+	udelay(500000);
+	gpio_direction_output(GPIO_TF1V8, 1);
+	gpio_direction_output(GPIO_TF3V3, 0);
+	udelay(500000);
+
+	gpio_direction_output(GPIO_TF1V8, 0);
+	gpio_direction_output(GPIO_TF3V3, 1);
+#endif
 }
 #endif
 
@@ -276,6 +299,7 @@ static void boot_jump_linux(bootm_headers_t *images, int flag)
 
 	if (!fake) {
 		do_nonsec_virt_switch();
+		printf("uboot time: %u us\n", get_time());
 		kernel_entry(images->ft_addr, NULL, NULL, NULL);
 	}
 #else
diff --git a/board/amlogic/Kconfig b/board/amlogic/Kconfig
new file mode 100644
index 0000000..b7c2935
--- /dev/null
+++ b/board/amlogic/Kconfig
@@ -0,0 +1,28 @@
+
+config GXB_SKT_V1
+	bool "Support amlogic gxbaby skt v1 board"
+	default n
+
+config GXB_P200_V1
+	bool "Support amlogic gxbaby p200(develop) v1 board"
+	default n
+
+config GXB_P201_V1
+	bool "Support amlogic gxbaby p200(reference) v1 board"
+	default n
+
+config PXP_EMULATOR
+	bool "Support pxp environment"
+	default n
+
+if GXB_SKT_V1
+source "board/amlogic/gxb_skt_v1/Kconfig"
+endif
+
+if GXB_P200_V1
+source "board/amlogic/gxb_p200_v1/Kconfig"
+endif
+
+if GXB_P201_V1
+source "board/amlogic/gxb_p201_v1/Kconfig"
+endif
diff --git a/board/amlogic/gxb_p200_v1/Kconfig b/board/amlogic/gxb_p200_v1/Kconfig
new file mode 100644
index 0000000..832fd04
--- /dev/null
+++ b/board/amlogic/gxb_p200_v1/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_MESON_GX
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "gxb_p200_v1"
+
+config SYS_VENDOR
+	string
+	default "amlogic"
+
+config SYS_SOC
+	string
+	default "gxb"
+
+config SYS_CONFIG_NAME
+	default "gxb_p200_v1"
+
+endif
diff --git a/board/amlogic/gxb_p200_v1/Makefile b/board/amlogic/gxb_p200_v1/Makefile
new file mode 100644
index 0000000..35a1991
--- /dev/null
+++ b/board/amlogic/gxb_p200_v1/Makefile
@@ -0,0 +1,2 @@
+
+obj-y += $(BOARD).o eth_setup.o
diff --git a/board/amlogic/gxb_p200_v1/aml-user-key.sig b/board/amlogic/gxb_p200_v1/aml-user-key.sig
new file mode 100644
index 0000000..e69de29
diff --git a/board/amlogic/gxb_p200_v1/eth_setup.c b/board/amlogic/gxb_p200_v1/eth_setup.c
new file mode 100644
index 0000000..33b5db1
--- /dev/null
+++ b/board/amlogic/gxb_p200_v1/eth_setup.c
@@ -0,0 +1,50 @@
+
+/*
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/arch/eth_setup.h>
+/*
+ *
+ *setup eth device board socket
+ *
+ */
+struct eth_board_socket* eth_board_setup(char *name){
+	struct eth_board_socket* new_board;
+	new_board= (struct eth_board_socket*) malloc(sizeof(struct eth_board_socket));
+	if (NULL == new_board) return NULL;
+	if (name != NULL) {
+		new_board->name=(char*)malloc(strlen(name));
+		strncpy(new_board->name,name,strlen(name));
+	}else{
+		new_board->name="gxb";
+	}
+
+	new_board->eth_pinmux_setup=NULL ;
+	new_board->eth_clock_configure=NULL;
+	new_board->eth_hw_reset=NULL;
+	return new_board;
+}
+//pinmux   HHI_GCLK_MPEG1[bit 3]
+//
diff --git a/board/amlogic/gxb_p200_v1/gxb_p200_v1.c b/board/amlogic/gxb_p200_v1/gxb_p200_v1.c
new file mode 100644
index 0000000..be81797
--- /dev/null
+++ b/board/amlogic/gxb_p200_v1/gxb_p200_v1.c
@@ -0,0 +1,492 @@
+
+/*
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#ifdef CONFIG_SYS_I2C_AML
+#include <aml_i2c.h>
+#include <asm/arch/secure_apb.h>
+#include <asm/arch/io.h>
+#endif
+#ifdef CONFIG_AML_VPU
+#include <vpu.h>
+#endif
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+#include <amlogic/aml_v2_burning.h>
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+#include <asm/arch/eth_setup.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+//new static eth setup
+struct eth_board_socket*  eth_board_skt;
+
+
+int serial_set_pin_port(unsigned long port_base)
+{
+    //UART in "Always On Module"
+    //GPIOAO_0==tx,GPIOAO_1==rx
+    //setbits_le32(P_AO_RTI_PIN_MUX_REG,3<<11);
+    return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+/* secondary_boot_func
+ * this function should be write with asm, here, is is only for compiling pass
+ * */
+void secondary_boot_func(void)
+{
+}
+
+static void setup_net_chip(void)
+{
+	eth_aml_reg0_t eth_reg0;
+
+	//setup ethernet clk need calibrate to configre
+	setbits_le32(P_PERIPHS_PIN_MUX_6, 0x3fff);
+
+	eth_reg0.d32 = 0;
+	eth_reg0.b.phy_intf_sel = 1;
+	eth_reg0.b.data_endian = 0;
+	eth_reg0.b.desc_endian = 0;
+	eth_reg0.b.rx_clk_rmii_invert = 0;
+	eth_reg0.b.rgmii_tx_clk_src = 0;
+	eth_reg0.b.rgmii_tx_clk_phase = 1;
+	eth_reg0.b.rgmii_tx_clk_ratio = 4;
+	eth_reg0.b.phy_ref_clk_enable = 1;
+	eth_reg0.b.clk_rmii_i_invert = 0;
+	eth_reg0.b.clk_en = 1;
+	eth_reg0.b.adj_enable = 0;
+	eth_reg0.b.adj_setup = 0;
+	eth_reg0.b.adj_delay = 0;
+	eth_reg0.b.adj_skew = 0;
+	eth_reg0.b.cali_start = 0;
+	eth_reg0.b.cali_rise = 0;
+	eth_reg0.b.cali_sel = 0;
+	eth_reg0.b.rgmii_rx_reuse = 0;
+	eth_reg0.b.eth_urgent = 0;
+	setbits_le32(P_PREG_ETH_REG0, eth_reg0.d32);// rgmii mode
+
+	setbits_le32(HHI_GCLK_MPEG1,1<<3);
+
+	/* power on memory */
+	clrbits_le32(HHI_MEM_PD_REG0, (1 << 3) | (1<<2));
+
+	/* hardware reset ethernet phy : gpioz14 connect phyreset pin*/
+	clrbits_le32(PREG_PAD_GPIO3_EN_N, 1 << 14);
+	clrbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+	udelay(10000);
+	setbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+}
+
+extern struct eth_board_socket* eth_board_setup(char *name);
+extern int aml_eth_init(bd_t *bis);
+int board_eth_init(bd_t *bis)
+{
+	setup_net_chip();
+	udelay(1000);
+	aml_eth_init(bis);
+
+	return 0;
+}
+
+#if CONFIG_AML_SD_EMMC
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+static int  sd_emmc_init(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+			//todo add card detect
+			//setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			break;
+		case SDIO_PORT_C:
+			//enable pull up
+			//clrbits_le32(P_PAD_PULL_UP_REG3, 0xff<<0);
+			break;
+		default:
+			break;
+	}
+
+	return cpu_sd_emmc_init(port);
+}
+
+extern unsigned sd_debug_board_1bit_flag;
+static int  sd_emmc_detect(unsigned port)
+{
+	int ret;
+    switch (port) {
+
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+		setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+		ret=readl(P_PREG_PAD_GPIO5_I)&(1<<29)?0:1;
+		printf("ret = %d .",ret);
+		if ((readl(P_PERIPHS_PIN_MUX_8)&(3<<9))) { //if uart pinmux set, debug board in
+			if (!(readl(P_PREG_PAD_GPIO2_I)&(1<<24))) {
+				printf("sdio debug board detected, sd card with 1bit mode\n");
+				sd_debug_board_1bit_flag = 1;
+			}
+			else{
+				printf("sdio debug board detected, no sd card in\n");
+				sd_debug_board_1bit_flag = 0;
+				return 1;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void sd_emmc_pwr_prepare(unsigned port)
+{
+	cpu_sd_emmc_pwr_prepare(port);
+}
+
+static void sd_emmc_pwr_on(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			/// @todo NOT FINISH
+			break;
+		case SDIO_PORT_C:
+			break;
+		default:
+			break;
+	}
+	return;
+}
+static void sd_emmc_pwr_off(unsigned port)
+{
+	/// @todo NOT FINISH
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            setbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			break;
+		case SDIO_PORT_C:
+			break;
+				default:
+			break;
+	}
+	return;
+}
+
+// #define CONFIG_TSD      1
+static void board_mmc_register(unsigned port)
+{
+	struct aml_card_sd_info *aml_priv=cpu_sd_emmc_get(port);
+    if (aml_priv == NULL)
+		return;
+
+	aml_priv->sd_emmc_init=sd_emmc_init;
+	aml_priv->sd_emmc_detect=sd_emmc_detect;
+	aml_priv->sd_emmc_pwr_off=sd_emmc_pwr_off;
+	aml_priv->sd_emmc_pwr_on=sd_emmc_pwr_on;
+	aml_priv->sd_emmc_pwr_prepare=sd_emmc_pwr_prepare;
+	aml_priv->desc_buf = malloc(NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info)));
+
+	if (NULL == aml_priv->desc_buf)
+		printf(" desc_buf Dma alloc Fail!\n");
+	else
+		printf("aml_priv->desc_buf = 0x%p\n",aml_priv->desc_buf);
+
+	sd_emmc_register(aml_priv);
+}
+int board_mmc_init(bd_t	*bis)
+{
+#ifdef CONFIG_VLSI_EMULATOR
+	//board_mmc_register(SDIO_PORT_A);
+#else
+	//board_mmc_register(SDIO_PORT_B);
+#endif
+	board_mmc_register(SDIO_PORT_B);
+	board_mmc_register(SDIO_PORT_C);
+//	board_mmc_register(SDIO_PORT_B1);
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_AML
+#if 0
+static void board_i2c_set_pinmux(void){
+	/*********************************************/
+	/*                | I2C_Master_B        |I2C_Slave            |       */
+	/*********************************************/
+	/*                | I2C_SCK                | I2C_SCK_SLAVE  |      */
+	/* GPIODV_26  | [AO_PIN_MUX: 6]     | [AO_PIN_MUX: 2]   |     */
+	/*********************************************/
+	/*                | I2C_SDA                 | I2C_SDA_SLAVE  |     */
+	/* GPIODV_27  | [AO_PIN_MUX: 5]     | [AO_PIN_MUX: 1]   |     */
+	/*********************************************/
+
+	//disable all other pins which share with I2C_SDA_B & I2C_SCK_B
+	clrbits_le32(P_PERIPHS_PIN_MUX_0, ((1<<9)|(1<<10)));
+	clrbits_le32(P_PERIPHS_PIN_MUX_2, ((1<<26)|(1<<27)));
+	clrbits_le32(P_PERIPHS_PIN_MUX_5, ((1<<8)|(1<<9)|(1<<10)));
+	//enable I2C MASTER B pins
+	setbits_le32(P_PERIPHS_PIN_MUX_7,
+	(MESON_I2C_MASTER_B_GPIODV_26_BIT | MESON_I2C_MASTER_B_GPIODV_27_BIT));
+
+	udelay(10);
+};
+#endif
+struct aml_i2c_platform g_aml_i2c_plat = {
+	.wait_count         = 1000000,
+	.wait_ack_interval  = 5,
+	.wait_read_interval = 5,
+	.wait_xfer_interval = 5,
+	.master_no          = AML_I2C_MASTER_B,
+	.use_pio            = 0,
+	.master_i2c_speed   = AML_I2C_SPPED_400K,
+	.master_b_pinmux = {
+	.scl_reg    = (unsigned long)MESON_I2C_MASTER_B_GPIODV_27_REG,
+	.scl_bit    = MESON_I2C_MASTER_B_GPIODV_27_BIT,
+	.sda_reg    = (unsigned long)MESON_I2C_MASTER_B_GPIODV_26_REG,
+	.sda_bit    = MESON_I2C_MASTER_B_GPIODV_26_BIT,
+}
+};
+#if 0
+static void board_i2c_init(void)
+{
+	//set I2C pinmux with PCB board layout
+	board_i2c_set_pinmux();
+
+	//Amlogic I2C controller initialized
+	//note: it must be call before any I2C operation
+	aml_i2c_init();
+
+	udelay(10);
+}
+#endif
+#endif
+#endif
+
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+int board_early_init_f(void){
+	/*add board early init function here*/
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_DWC_OTG_HCD
+#include <asm/arch/usb.h>
+
+static void gpio_set_vbus_power(char is_power_on)
+{
+	if (is_power_on) {
+		setbits_le32(PREG_PAD_GPIO0_EN_N, 1<<24);
+		setbits_le32(PREG_PAD_GPIO0_O, 1<<24);
+	} else {
+	}
+}
+
+static int usb_charging_detect_call_back(char bc_mode)
+{
+	switch (bc_mode) {
+		case BC_MODE_DCP:
+		case BC_MODE_CDP:
+			//Pull up chargging current > 500mA
+			break;
+
+		case BC_MODE_UNKNOWN:
+		case BC_MODE_SDP:
+		default:
+			//Limit chargging current <= 500mA
+			//Or detet dec-charger
+			break;
+	}
+	return 0;
+}
+//note: try with some M3 pll but only following can work
+//USB_PHY_CLOCK_SEL_M3_XTAL @ 1 (24MHz)
+//USB_PHY_CLOCK_SEL_M3_XTAL_DIV2 @ 0 (12MHz)
+//USB_PHY_CLOCK_SEL_M3_DDR_PLL @ 27(336MHz); @Rev2663 M3 SKT board DDR is 336MHz
+//                                                            43 (528MHz); M3 SKT board DDR not stable for 528MHz
+
+struct amlogic_usb_config g_usb_config_gx_skt_a={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_A,
+	USB_ID_MODE_SW_HOST,
+	gpio_set_vbus_power, //set_vbus_power
+	NULL,
+};
+struct amlogic_usb_config g_usb_config_gx_skt_b={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_B,
+	USB_ID_MODE_SW_HOST,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	NULL,
+};
+struct amlogic_usb_config g_usb_config_gx_skt_h={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_A,
+	USB_ID_MODE_HARDWARE,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	usb_charging_detect_call_back,
+};
+#endif /*CONFIG_USB_DWC_OTG_HCD*/
+
+#ifdef CONFIG_AML_HDMITX20
+static void hdmi_tx_set_hdmi_5v(void)
+{
+	/*Power on VCC_5V for HDMI_5V*/
+	clrbits_le32(P_AO_GPIO_O_EN_N, ((1<<2)|(1<<18)));
+}
+#endif
+
+int board_init(void)
+{
+    //Please keep CONFIG_AML_V2_FACTORY_BURN at first place of board_init
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_usb_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+		/*for LED*/
+	//clear pinmux
+	clrbits_le32(AO_RTI_PIN_MUX_REG, ((1<<3)|(1<<4)));
+	clrbits_le32(AO_RTI_PIN_MUX_REG2, ((1<<1)|(1<<31)));
+	//set output mode
+	clrbits_le32(P_AO_GPIO_O_EN_N, (1<<13));
+	//set output 1
+	setbits_le32(P_AO_GPIO_O_EN_N, (1<<29));
+	/*Power on GPIOAO_2 for VCC_5V*/
+	clrbits_le32(P_AO_GPIO_O_EN_N, ((1<<2)|(1<<18)));
+	#ifdef CONFIG_USB_DWC_OTG_HCD
+	amlogic_usb_init(&g_usb_config_gx_skt_a,BOARD_USB_MODE_HOST);
+	amlogic_usb_init(&g_usb_config_gx_skt_b,BOARD_USB_MODE_HOST);
+	amlogic_usb_init(&g_usb_config_gx_skt_h,BOARD_USB_MODE_CHARGER);
+#endif /*CONFIG_USB_DWC_OTG_HCD*/
+#ifdef CONFIG_AML_VPU
+	vpu_probe();
+#endif
+#ifdef CONFIG_AML_HDMITX20
+	hdmi_tx_set_hdmi_5v();
+	hdmi_tx_init();
+#endif
+#ifdef CONFIG_AML_NAND
+	extern int amlnf_init(unsigned char flag);
+	amlnf_init(0);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void){
+	int ret;
+	/*add board late init function here*/
+	ret = run_command("store dtb read $dtb_mem_addr", 1);
+	if (ret) {
+		printf("%s(): [store dtb read $dtb_mem_addr] fail\n", __func__);
+		#ifdef CONFIG_DTB_MEM_ADDR
+		char cmd[64];
+		printf("load dtb to %x\n", CONFIG_DTB_MEM_ADDR);
+		sprintf(cmd, "store dtb read %x", CONFIG_DTB_MEM_ADDR);
+		ret = run_command(cmd, 1);
+		if (ret) {
+			printf("%s(): %s fail\n", __func__, cmd);
+		}
+		#endif
+	}
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_sdcard_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+	return 0;
+}
+#endif
+
+phys_size_t get_effective_memsize(void)
+{
+	// >>16 -> MB, <<20 -> real size, so >>16<<20 = <<4
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4) - CONFIG_SYS_MEM_TOP_HIDE;
+#else
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
+#endif
+}
+
+#ifdef CONFIG_MULTI_DTB
+int checkhw(char * name)
+{
+	unsigned int ddr_size=0;
+	char loc_name[64] = {0};
+	int i;
+	for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
+		ddr_size += gd->bd->bi_dram[i].size;
+	}
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	ddr_size += CONFIG_SYS_MEM_TOP_HIDE;
+#endif
+	switch (ddr_size) {
+		case 0x80000000:
+			strcpy(loc_name, "gxb_p200_2g\0");
+			break;
+		case 0x40000000:
+			strcpy(loc_name, "gxb_p200_1g\0");
+			break;
+		case 0x2000000:
+			strcpy(loc_name, "gxb_p200_512m\0");
+			break;
+		default:
+			//printf("DDR size: 0x%x, multi-dt doesn't support\n", ddr_size);
+			strcpy(loc_name, "gxb_p200_unsupport");
+			break;
+	}
+	strcpy(name, loc_name);
+	setenv("aml_dt", loc_name);
+	return 0;
+}
+#endif
+
+const char * const _env_args_reserve_[] =
+{
+		"aml_dt",
+
+		NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxb_p201_v1/Kconfig b/board/amlogic/gxb_p201_v1/Kconfig
new file mode 100644
index 0000000..450f350
--- /dev/null
+++ b/board/amlogic/gxb_p201_v1/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_MESON_GX
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "gxb_p201_v1"
+
+config SYS_VENDOR
+	string
+	default "amlogic"
+
+config SYS_SOC
+	string
+	default "gxb"
+
+config SYS_CONFIG_NAME
+	default "gxb_p201_v1"
+
+endif
diff --git a/board/amlogic/gxb_p201_v1/Makefile b/board/amlogic/gxb_p201_v1/Makefile
new file mode 100644
index 0000000..35a1991
--- /dev/null
+++ b/board/amlogic/gxb_p201_v1/Makefile
@@ -0,0 +1,2 @@
+
+obj-y += $(BOARD).o eth_setup.o
diff --git a/board/amlogic/gxb_p201_v1/aml-user-key.sig b/board/amlogic/gxb_p201_v1/aml-user-key.sig
new file mode 100644
index 0000000..e69de29
diff --git a/board/amlogic/gxb_p201_v1/eth_setup.c b/board/amlogic/gxb_p201_v1/eth_setup.c
new file mode 100644
index 0000000..33b5db1
--- /dev/null
+++ b/board/amlogic/gxb_p201_v1/eth_setup.c
@@ -0,0 +1,50 @@
+
+/*
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/arch/eth_setup.h>
+/*
+ *
+ *setup eth device board socket
+ *
+ */
+struct eth_board_socket* eth_board_setup(char *name){
+	struct eth_board_socket* new_board;
+	new_board= (struct eth_board_socket*) malloc(sizeof(struct eth_board_socket));
+	if (NULL == new_board) return NULL;
+	if (name != NULL) {
+		new_board->name=(char*)malloc(strlen(name));
+		strncpy(new_board->name,name,strlen(name));
+	}else{
+		new_board->name="gxb";
+	}
+
+	new_board->eth_pinmux_setup=NULL ;
+	new_board->eth_clock_configure=NULL;
+	new_board->eth_hw_reset=NULL;
+	return new_board;
+}
+//pinmux   HHI_GCLK_MPEG1[bit 3]
+//
diff --git a/board/amlogic/gxb_p201_v1/gxb_p201_v1.c b/board/amlogic/gxb_p201_v1/gxb_p201_v1.c
new file mode 100644
index 0000000..20ccf87
--- /dev/null
+++ b/board/amlogic/gxb_p201_v1/gxb_p201_v1.c
@@ -0,0 +1,450 @@
+
+/*
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#ifdef CONFIG_SYS_I2C_AML
+#include <aml_i2c.h>
+#include <asm/arch/secure_apb.h>
+#endif
+#ifdef CONFIG_AML_VPU
+#include <vpu.h>
+#endif
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+#include <amlogic/aml_v2_burning.h>
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+#include <asm/arch/eth_setup.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+//new static eth setup
+struct eth_board_socket*  eth_board_skt;
+
+
+int serial_set_pin_port(unsigned long port_base)
+{
+    //UART in "Always On Module"
+    //GPIOAO_0==tx,GPIOAO_1==rx
+    //setbits_le32(P_AO_RTI_PIN_MUX_REG,3<<11);
+    return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+/* secondary_boot_func
+ * this function should be write with asm, here, is is only for compiling pass
+ * */
+void secondary_boot_func(void)
+{
+}
+
+static void setup_net_chip(void)
+{
+	eth_aml_reg0_t eth_reg0;
+
+	//setup ethernet clk need calibrate to configre
+	setbits_le32(P_PERIPHS_PIN_MUX_6, 0x3c73);
+
+	eth_reg0.d32 = 0;
+	eth_reg0.b.phy_intf_sel = 0;
+	eth_reg0.b.data_endian = 0;
+	eth_reg0.b.desc_endian = 0;
+	eth_reg0.b.rx_clk_rmii_invert = 0;
+	eth_reg0.b.rgmii_tx_clk_src = 0;
+	eth_reg0.b.rgmii_tx_clk_phase = 0;
+	eth_reg0.b.rgmii_tx_clk_ratio = 0;
+	eth_reg0.b.phy_ref_clk_enable = 0;
+	eth_reg0.b.clk_rmii_i_invert = 1;
+	eth_reg0.b.clk_en = 1;
+	eth_reg0.b.adj_enable = 0;
+	eth_reg0.b.adj_setup = 0;
+	eth_reg0.b.adj_delay = 0;
+	eth_reg0.b.adj_skew = 0;
+	eth_reg0.b.cali_start = 0;
+	eth_reg0.b.cali_rise = 0;
+	eth_reg0.b.cali_sel = 0;
+	eth_reg0.b.rgmii_rx_reuse = 0;
+	eth_reg0.b.eth_urgent = 0;
+	setbits_le32(P_PREG_ETH_REG0, eth_reg0.d32);// rmii mode
+
+	setbits_le32(HHI_GCLK_MPEG1,1<<3);
+
+	/* power on memory */
+	clrbits_le32(HHI_MEM_PD_REG0, (1 << 3) | (1<<2));
+
+	/* hardware reset ethernet phy : gpioz14 connect phyreset pin*/
+	clrbits_le32(PREG_PAD_GPIO3_EN_N, 1 << 14);
+	clrbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+	udelay(10000);
+	setbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+}
+
+extern struct eth_board_socket* eth_board_setup(char *name);
+extern int aml_eth_init(bd_t *bis);
+int board_eth_init(bd_t *bis)
+{
+	setup_net_chip();
+	udelay(1000);
+	aml_eth_init(bis);
+
+	return 0;
+}
+
+#if CONFIG_AML_SD_EMMC
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+static int  sd_emmc_init(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+			//todo add card detect
+			//setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			break;
+		case SDIO_PORT_C:
+			//enable pull up
+			//clrbits_le32(P_PAD_PULL_UP_REG3, 0xff<<0);
+			break;
+		default:
+			break;
+	}
+
+	return cpu_sd_emmc_init(port);
+}
+
+extern unsigned sd_debug_board_1bit_flag;
+static int  sd_emmc_detect(unsigned port)
+{
+	int ret;
+    switch (port) {
+
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+			setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			ret=readl(P_PREG_PAD_GPIO5_I)&(1<<29)?0:1;
+			printf("ret = %d .",ret);
+			if ((readl(P_PERIPHS_PIN_MUX_8)&(3<<9))) { //if uart pinmux set, debug board in
+				if (!(readl(P_PREG_PAD_GPIO2_I)&(1<<24))) {
+					printf("sdio debug board detected, sd card with 1bit mode\n");
+					sd_debug_board_1bit_flag = 1;
+				}
+				else{
+					printf("sdio debug board detected, no sd card in\n");
+					sd_debug_board_1bit_flag = 0;
+					return 1;
+				}
+			}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void sd_emmc_pwr_prepare(unsigned port)
+{
+	cpu_sd_emmc_pwr_prepare(port);
+}
+
+static void sd_emmc_pwr_on(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			/// @todo NOT FINISH
+			break;
+		case SDIO_PORT_C:
+			break;
+		default:
+			break;
+	}
+	return;
+}
+static void sd_emmc_pwr_off(unsigned port)
+{
+	/// @todo NOT FINISH
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            setbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			break;
+		case SDIO_PORT_C:
+			break;
+				default:
+			break;
+	}
+	return;
+}
+
+// #define CONFIG_TSD      1
+static void board_mmc_register(unsigned port)
+{
+	struct aml_card_sd_info *aml_priv=cpu_sd_emmc_get(port);
+    if (aml_priv == NULL)
+		return;
+
+	aml_priv->sd_emmc_init=sd_emmc_init;
+	aml_priv->sd_emmc_detect=sd_emmc_detect;
+	aml_priv->sd_emmc_pwr_off=sd_emmc_pwr_off;
+	aml_priv->sd_emmc_pwr_on=sd_emmc_pwr_on;
+	aml_priv->sd_emmc_pwr_prepare=sd_emmc_pwr_prepare;
+	aml_priv->desc_buf = malloc(NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info)));
+
+	if (NULL == aml_priv->desc_buf)
+		printf(" desc_buf Dma alloc Fail!\n");
+	else
+		printf("aml_priv->desc_buf = 0x%p\n",aml_priv->desc_buf);
+
+	sd_emmc_register(aml_priv);
+}
+int board_mmc_init(bd_t	*bis)
+{
+#ifdef CONFIG_VLSI_EMULATOR
+	//board_mmc_register(SDIO_PORT_A);
+#else
+	//board_mmc_register(SDIO_PORT_B);
+#endif
+	board_mmc_register(SDIO_PORT_B);
+	board_mmc_register(SDIO_PORT_C);
+//	board_mmc_register(SDIO_PORT_B1);
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_AML
+#if 0
+static void board_i2c_set_pinmux(void){
+	/*********************************************/
+	/*                | I2C_Master_AO        |I2C_Slave            |       */
+	/*********************************************/
+	/*                | I2C_SCK                | I2C_SCK_SLAVE  |      */
+	/* GPIOAO_4  | [AO_PIN_MUX: 6]     | [AO_PIN_MUX: 2]   |     */
+	/*********************************************/
+	/*                | I2C_SDA                 | I2C_SDA_SLAVE  |     */
+	/* GPIOAO_5  | [AO_PIN_MUX: 5]     | [AO_PIN_MUX: 1]   |     */
+	/*********************************************/
+
+	//disable all other pins which share with I2C_SDA_AO & I2C_SCK_AO
+	clrbits_le32(P_AO_RTI_PIN_MUX_REG, ((1<<2)|(1<<24)|(1<<1)|(1<<23)));
+	//enable I2C MASTER AO pins
+	setbits_le32(P_AO_RTI_PIN_MUX_REG,
+	(MESON_I2C_MASTER_AO_GPIOAO_4_BIT | MESON_I2C_MASTER_AO_GPIOAO_5_BIT));
+
+	udelay(10);
+};
+#endif
+struct aml_i2c_platform g_aml_i2c_plat = {
+	.wait_count         = 1000000,
+	.wait_ack_interval  = 5,
+	.wait_read_interval = 5,
+	.wait_xfer_interval = 5,
+	.master_no          = AML_I2C_MASTER_AO,
+	.use_pio            = 0,
+	.master_i2c_speed   = AML_I2C_SPPED_400K,
+	.master_ao_pinmux = {
+		.scl_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_4_REG,
+		.scl_bit    = MESON_I2C_MASTER_AO_GPIOAO_4_BIT,
+		.sda_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_5_REG,
+		.sda_bit    = MESON_I2C_MASTER_AO_GPIOAO_5_BIT,
+	}
+};
+#if 0
+static void board_i2c_init(void)
+{
+	//set I2C pinmux with PCB board layout
+	board_i2c_set_pinmux();
+
+	//Amlogic I2C controller initialized
+	//note: it must be call before any I2C operation
+	aml_i2c_init();
+
+	udelay(10);
+}
+#endif
+#endif
+#endif
+
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+int board_early_init_f(void){
+	/*add board early init function here*/
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_DWC_OTG_HCD
+#include <asm/arch/usb.h>
+/*
+static void gpio_set_vbus_power(char is_power_on)
+{
+	if (is_power_on) {
+		setbits_le32(PREG_PAD_GPIO0_EN_N, 1<<24);
+		setbits_le32(PREG_PAD_GPIO0_O, 1<<24);
+	} else {
+	}
+}
+*/
+static int usb_charging_detect_call_back(char bc_mode)
+{
+	switch (bc_mode) {
+		case BC_MODE_DCP:
+		case BC_MODE_CDP:
+			//Pull up chargging current > 500mA
+			break;
+
+		case BC_MODE_UNKNOWN:
+		case BC_MODE_SDP:
+		default:
+			//Limit chargging current <= 500mA
+			//Or detet dec-charger
+			break;
+	}
+	return 0;
+}
+//note: try with some M3 pll but only following can work
+//USB_PHY_CLOCK_SEL_M3_XTAL @ 1 (24MHz)
+//USB_PHY_CLOCK_SEL_M3_XTAL_DIV2 @ 0 (12MHz)
+//USB_PHY_CLOCK_SEL_M3_DDR_PLL @ 27(336MHz); @Rev2663 M3 SKT board DDR is 336MHz
+//                                                            43 (528MHz); M3 SKT board DDR not stable for 528MHz
+
+struct amlogic_usb_config g_usb_config_gx_skt_a={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_A,
+	USB_ID_MODE_SW_HOST,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	NULL,
+};
+struct amlogic_usb_config g_usb_config_gx_skt_b={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_B,
+	USB_ID_MODE_SW_HOST,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	NULL,
+};
+struct amlogic_usb_config g_usb_config_gx_skt_h={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_A,
+	USB_ID_MODE_HARDWARE,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	usb_charging_detect_call_back,
+};
+#endif /*CONFIG_USB_DWC_OTG_HCD*/
+
+#ifdef CONFIG_AML_HDMITX20
+static void hdmi_tx_set_hdmi_5v(void)
+{
+	/*Power on VCC_5V for HDMI_5V*/
+	clrbits_le32(P_AO_GPIO_O_EN_N, ((1<<2)|(1<<18)));
+}
+#endif
+
+int board_init(void)
+{
+    //Please keep CONFIG_AML_V2_FACTORY_BURN at first place of board_init
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_usb_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+	/*for LED*/
+	//clear pinmux
+	clrbits_le32(AO_RTI_PIN_MUX_REG, ((1<<3)|(1<<4)));
+	clrbits_le32(AO_RTI_PIN_MUX_REG2, ((1<<1)|(1<<31)));
+	//set output mode
+	clrbits_le32(P_AO_GPIO_O_EN_N, (1<<13));
+	//set output 1
+	setbits_le32(P_AO_GPIO_O_EN_N, (1<<29));
+
+
+	/*Power on GPIOAO_2 for VCC_5V*/
+	clrbits_le32(P_AO_GPIO_O_EN_N, ((1<<2)|(1<<18)));
+	#ifdef CONFIG_USB_DWC_OTG_HCD
+	amlogic_usb_init(&g_usb_config_gx_skt_a,BOARD_USB_MODE_HOST);
+	amlogic_usb_init(&g_usb_config_gx_skt_b,BOARD_USB_MODE_HOST);
+	amlogic_usb_init(&g_usb_config_gx_skt_h,BOARD_USB_MODE_CHARGER);
+	#endif /*CONFIG_USB_DWC_OTG_HCD*/
+#ifdef CONFIG_AML_VPU
+	vpu_probe();
+#endif
+#ifdef CONFIG_AML_HDMITX20
+	hdmi_tx_set_hdmi_5v();
+	hdmi_tx_init();
+#endif
+#ifdef CONFIG_AML_NAND
+	extern int amlnf_init(unsigned char flag);
+	amlnf_init(0);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void){
+	int ret;
+	/*add board late init function here*/
+	ret = run_command("store dtb read $dtb_mem_addr", 1);
+	if (ret) {
+		printf("%s(): [store dtb read $dtb_mem_addr] fail\n", __func__);
+		#ifdef CONFIG_DTB_MEM_ADDR
+		char cmd[64];
+		printf("load dtb to %x\n", CONFIG_DTB_MEM_ADDR);
+		sprintf(cmd, "store dtb read %x", CONFIG_DTB_MEM_ADDR);
+		ret = run_command(cmd, 1);
+		if (ret) {
+			printf("%s(): %s fail\n", __func__, cmd);
+		}
+		#endif
+	}
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_sdcard_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+	return 0;
+}
+#endif
+
+phys_size_t get_effective_memsize(void)
+{
+	// >>16 -> MB, <<20 -> real size, so >>16<<20 = <<4
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4) - CONFIG_SYS_MEM_TOP_HIDE;
+#else
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
+#endif
+}
diff --git a/board/amlogic/gxb_skt_v1/Kconfig b/board/amlogic/gxb_skt_v1/Kconfig
new file mode 100644
index 0000000..8544f4d
--- /dev/null
+++ b/board/amlogic/gxb_skt_v1/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_MESON_GX
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "gxb_skt_v1"
+
+config SYS_VENDOR
+	string
+	default "amlogic"
+
+config SYS_SOC
+	string
+	default "gxb"
+
+config SYS_CONFIG_NAME
+	default "gxb_skt_v1"
+
+endif
diff --git a/board/amlogic/gxb_skt_v1/Makefile b/board/amlogic/gxb_skt_v1/Makefile
new file mode 100644
index 0000000..35a1991
--- /dev/null
+++ b/board/amlogic/gxb_skt_v1/Makefile
@@ -0,0 +1,2 @@
+
+obj-y += $(BOARD).o eth_setup.o
diff --git a/board/amlogic/gxb_skt_v1/aml-user-key.sig b/board/amlogic/gxb_skt_v1/aml-user-key.sig
new file mode 100644
index 0000000..e69de29
diff --git a/board/amlogic/gxb_skt_v1/eth_setup.c b/board/amlogic/gxb_skt_v1/eth_setup.c
new file mode 100644
index 0000000..f7aff48
--- /dev/null
+++ b/board/amlogic/gxb_skt_v1/eth_setup.c
@@ -0,0 +1,51 @@
+
+/*
+ * board/amlogic/gxb_skt_v1/eth_setup.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/arch/eth_setup.h>
+/*
+ *
+ *setup eth device board socket
+ *
+ */
+struct eth_board_socket* eth_board_setup(char *name){
+	struct eth_board_socket* new_board;
+	new_board= (struct eth_board_socket*) malloc(sizeof(struct eth_board_socket));
+	if (NULL == new_board) return NULL;
+	if (name != NULL) {
+		new_board->name=(char*)malloc(strlen(name));
+		strncpy(new_board->name,name,strlen(name));
+	}else{
+		new_board->name="gxb";
+	}
+
+	new_board->eth_pinmux_setup=NULL ;
+	new_board->eth_clock_configure=NULL;
+	new_board->eth_hw_reset=NULL;
+	return new_board;
+}
+//pinmux   HHI_GCLK_MPEG1[bit 3]
+//
diff --git a/board/amlogic/gxb_skt_v1/gxb_skt_v1.c b/board/amlogic/gxb_skt_v1/gxb_skt_v1.c
new file mode 100644
index 0000000..69fd1c4
--- /dev/null
+++ b/board/amlogic/gxb_skt_v1/gxb_skt_v1.c
@@ -0,0 +1,418 @@
+
+/*
+ * board/amlogic/gxb_skt_v1/gxb_skt_v1.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#ifdef CONFIG_SYS_I2C_AML
+#include <aml_i2c.h>
+#include <asm/arch/secure_apb.h>
+#endif
+#ifdef CONFIG_AML_VPU
+#include <vpu.h>
+#endif
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+#include <amlogic/aml_v2_burning.h>
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+//new static eth setup
+struct eth_board_socket*  eth_board_skt;
+
+
+int serial_set_pin_port(unsigned long port_base)
+{
+    //UART in "Always On Module"
+    //GPIOAO_0==tx,GPIOAO_1==rx
+    //setbits_le32(P_AO_RTI_PIN_MUX_REG,3<<11);
+    return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+/* secondary_boot_func
+ * this function should be write with asm, here, is is only for compiling pass
+ * */
+void secondary_boot_func(void)
+{
+}
+
+extern struct eth_board_socket* eth_board_setup(char *name);
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+	eth_board_setup("g9bb");
+	return rc;
+}
+
+#if CONFIG_AML_SD_EMMC
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+static int  sd_emmc_init(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+			//todo add card detect
+			//setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			break;
+		case SDIO_PORT_C:
+			//enable pull up
+			//clrbits_le32(P_PAD_PULL_UP_REG3, 0xff<<0);
+			break;
+		default:
+			break;
+	}
+
+	return cpu_sd_emmc_init(port);
+}
+
+extern unsigned sd_debug_board_1bit_flag;
+static int  sd_emmc_detect(unsigned port)
+{
+	int ret;
+    switch (port) {
+
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+			setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			ret=readl(P_PREG_PAD_GPIO5_I)&(1<<29)?0:1;
+			printf("ret = %d .",ret);
+			if ((readl(P_PERIPHS_PIN_MUX_8)&(3<<9))) { //if uart pinmux set, debug board in
+				if (!(readl(P_PREG_PAD_GPIO2_I)&(1<<24))) {
+					printf("sdio debug board detected, sd card with 1bit mode\n");
+					sd_debug_board_1bit_flag = 1;
+				}
+				else{
+					printf("sdio debug board detected, no sd card in\n");
+					sd_debug_board_1bit_flag = 0;
+					return 1;
+				}
+			}
+
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void sd_emmc_pwr_prepare(unsigned port)
+{
+	cpu_sd_emmc_pwr_prepare(port);
+}
+
+static void sd_emmc_pwr_on(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			/// @todo NOT FINISH
+			break;
+		case SDIO_PORT_C:
+			break;
+		default:
+			break;
+	}
+	return;
+}
+static void sd_emmc_pwr_off(unsigned port)
+{
+	/// @todo NOT FINISH
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            setbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			break;
+		case SDIO_PORT_C:
+			break;
+				default:
+			break;
+	}
+	return;
+}
+
+// #define CONFIG_TSD      1
+static void board_mmc_register(unsigned port)
+{
+	struct aml_card_sd_info *aml_priv=cpu_sd_emmc_get(port);
+    if (aml_priv == NULL)
+		return;
+
+	aml_priv->sd_emmc_init=sd_emmc_init;
+	aml_priv->sd_emmc_detect=sd_emmc_detect;
+	aml_priv->sd_emmc_pwr_off=sd_emmc_pwr_off;
+	aml_priv->sd_emmc_pwr_on=sd_emmc_pwr_on;
+	aml_priv->sd_emmc_pwr_prepare=sd_emmc_pwr_prepare;
+	aml_priv->desc_buf = malloc(NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info)));
+
+	if (NULL == aml_priv->desc_buf)
+		printf(" desc_buf Dma alloc Fail!\n");
+	else
+		printf("aml_priv->desc_buf = 0x%p\n",aml_priv->desc_buf);
+
+	sd_emmc_register(aml_priv);
+}
+int board_mmc_init(bd_t	*bis)
+{
+#ifdef CONFIG_VLSI_EMULATOR
+	//board_mmc_register(SDIO_PORT_A);
+#else
+	//board_mmc_register(SDIO_PORT_B);
+#endif
+	board_mmc_register(SDIO_PORT_B);
+	board_mmc_register(SDIO_PORT_C);
+//	board_mmc_register(SDIO_PORT_B1);
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_AML
+#if 0
+static void board_i2c_set_pinmux(void){
+	/*********************************************/
+	/*                | I2C_Master_AO        |I2C_Slave            |       */
+	/*********************************************/
+	/*                | I2C_SCK                | I2C_SCK_SLAVE  |      */
+	/* GPIOAO_4  | [AO_PIN_MUX: 6]     | [AO_PIN_MUX: 2]   |     */
+	/*********************************************/
+	/*                | I2C_SDA                 | I2C_SDA_SLAVE  |     */
+	/* GPIOAO_5  | [AO_PIN_MUX: 5]     | [AO_PIN_MUX: 1]   |     */
+	/*********************************************/
+
+	//disable all other pins which share with I2C_SDA_AO & I2C_SCK_AO
+	clrbits_le32(P_AO_RTI_PIN_MUX_REG, ((1<<2)|(1<<24)|(1<<1)|(1<<23)));
+	//enable I2C MASTER AO pins
+	setbits_le32(P_AO_RTI_PIN_MUX_REG,
+	(MESON_I2C_MASTER_AO_GPIOAO_4_BIT | MESON_I2C_MASTER_AO_GPIOAO_5_BIT));
+
+	udelay(10);
+};
+#endif
+struct aml_i2c_platform g_aml_i2c_plat = {
+	.wait_count         = 1000000,
+	.wait_ack_interval  = 5,
+	.wait_read_interval = 5,
+	.wait_xfer_interval = 5,
+	.master_no          = AML_I2C_MASTER_AO,
+	.use_pio            = 0,
+	.master_i2c_speed   = AML_I2C_SPPED_400K,
+	.master_ao_pinmux = {
+		.scl_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_4_REG,
+		.scl_bit    = MESON_I2C_MASTER_AO_GPIOAO_4_BIT,
+		.sda_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_5_REG,
+		.sda_bit    = MESON_I2C_MASTER_AO_GPIOAO_5_BIT,
+	}
+};
+#if 0
+static void board_i2c_init(void)
+{
+	//set I2C pinmux with PCB board layout
+	board_i2c_set_pinmux();
+
+	//Amlogic I2C controller initialized
+	//note: it must be call before any I2C operation
+	aml_i2c_init();
+
+	udelay(10);
+}
+#endif
+#endif
+#endif
+
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+int board_early_init_f(void){
+	/*add board early init function here*/
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_DWC_OTG_HCD
+#include <asm/arch/usb.h>
+
+static void gpio_set_vbus_power(char is_power_on)
+{
+	if (is_power_on) {
+		setbits_le32(PREG_PAD_GPIO0_EN_N, 1<<24);
+		setbits_le32(PREG_PAD_GPIO0_O, 1<<24);
+	} else {
+	}
+}
+
+static int usb_charging_detect_call_back(char bc_mode)
+{
+	switch (bc_mode) {
+		case BC_MODE_DCP:
+		case BC_MODE_CDP:
+			//Pull up chargging current > 500mA
+			break;
+
+		case BC_MODE_UNKNOWN:
+		case BC_MODE_SDP:
+		default:
+			//Limit chargging current <= 500mA
+			//Or detet dec-charger
+			break;
+	}
+	return 0;
+}
+//note: try with some M3 pll but only following can work
+//USB_PHY_CLOCK_SEL_M3_XTAL @ 1 (24MHz)
+//USB_PHY_CLOCK_SEL_M3_XTAL_DIV2 @ 0 (12MHz)
+//USB_PHY_CLOCK_SEL_M3_DDR_PLL @ 27(336MHz); @Rev2663 M3 SKT board DDR is 336MHz
+//                                                            43 (528MHz); M3 SKT board DDR not stable for 528MHz
+
+struct amlogic_usb_config g_usb_config_gx_skt_a={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_A,
+	USB_ID_MODE_SW_HOST,
+	gpio_set_vbus_power, //set_vbus_power
+	NULL,
+};
+struct amlogic_usb_config g_usb_config_gx_skt_b={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_B,
+	USB_ID_MODE_SW_HOST,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	NULL,
+};
+struct amlogic_usb_config g_usb_config_gx_skt_h={
+	USB_PHY_CLK_SEL_XTAL,
+	1, //PLL divider: (clock/12 -1)
+	CONFIG_M8_USBPORT_BASE_A,
+	USB_ID_MODE_HARDWARE,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	usb_charging_detect_call_back,
+};
+#endif /*CONFIG_USB_DWC_OTG_HCD*/
+
+#ifdef CONFIG_AML_HDMITX20
+static void hdmi_tx_set_hdmi_5v(void)
+{
+}
+#endif
+
+int board_init(void)
+{
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_usb_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+#ifdef CONFIG_USB_DWC_OTG_HCD
+	//setbits_le32(PREG_PAD_GPIO0_EN_N, 1<<24);
+	//setbits_le32(PREG_PAD_GPIO0_O, 1<<24);
+	amlogic_usb_init(&g_usb_config_gx_skt_a,BOARD_USB_MODE_HOST);
+	amlogic_usb_init(&g_usb_config_gx_skt_b,BOARD_USB_MODE_HOST);
+	amlogic_usb_init(&g_usb_config_gx_skt_h,BOARD_USB_MODE_CHARGER);
+#endif /*CONFIG_USB_DWC_OTG_HCD*/
+#ifdef CONFIG_AML_VPU
+	vpu_probe();
+#endif
+#ifdef CONFIG_AML_HDMITX20
+	hdmi_tx_set_hdmi_5v();
+	hdmi_tx_init();
+#endif
+#ifdef CONFIG_AML_NAND
+	extern int amlnf_init(unsigned char flag);
+	amlnf_init(0);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void){
+	int ret;
+	/*add board late init function here*/
+	run_command("setenv fdt_high 0x20000000", 1);
+	run_command("setenv dtb_mem_addr 0x1000000", 1);
+	ret = run_command("store dtb read $dtb_mem_addr", 1);
+	if (ret) {
+		printf("%s(): [store dtb read $dtb_mem_addr] fail\n", __func__);
+		#ifdef CONFIG_DTB_MEM_ADDR
+		char cmd[64];
+		printf("load dtb to %x\n", CONFIG_DTB_MEM_ADDR);
+		sprintf(cmd, "store dtb read %x", CONFIG_DTB_MEM_ADDR);
+		ret = run_command(cmd, 1);
+		if (ret) {
+			printf("%s(): %s fail\n", __func__, cmd);
+		}
+		#endif
+	}
+
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	/*aml_try_factory_sdcard_burning(0, gd->bd);*/
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AML_TINY_USBTOOL
+int usb_get_update_result(void)
+{
+	unsigned long upgrade_step;
+	upgrade_step = simple_strtoul (getenv ("upgrade_step"), NULL, 16);
+	printf("upgrade_step = %d\n", (int)upgrade_step);
+	if (upgrade_step == 1)
+	{
+		run_command("defenv", 1);
+		run_command("setenv upgrade_step 2", 1);
+		run_command("saveenv", 1);
+		return 0;
+	}
+	else
+	{
+		return -1;
+	}
+}
+#endif
+
+phys_size_t get_effective_memsize(void)
+{
+	// >>16 -> MB, <<20 -> real size, so >>16<<20 = <<4
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4) - CONFIG_SYS_MEM_TOP_HIDE;
+#else
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
+#endif
+}
diff --git a/board/hardkernel/Kconfig b/board/hardkernel/Kconfig
new file mode 100644
index 0000000..8585dd9
--- /dev/null
+++ b/board/hardkernel/Kconfig
@@ -0,0 +1,7 @@
+config ODROID_C2
+	bool "Support Hardkernel ODROID-C2 board"
+	default n
+
+if ODROID_C2
+source "board/hardkernel/odroidc2/Kconfig"
+endif
diff --git a/board/hardkernel/odroidc2/Kconfig b/board/hardkernel/odroidc2/Kconfig
new file mode 100644
index 0000000..d8fb462
--- /dev/null
+++ b/board/hardkernel/odroidc2/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_MESON_GX
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "odroidc2"
+
+config SYS_VENDOR
+	string
+	default "hardkernel"
+
+config SYS_SOC
+	string
+	default "gxb"
+
+config SYS_CONFIG_NAME
+	default "odroidc2"
+
+endif
diff --git a/board/hardkernel/odroidc2/Makefile b/board/hardkernel/odroidc2/Makefile
new file mode 100644
index 0000000..baab45d
--- /dev/null
+++ b/board/hardkernel/odroidc2/Makefile
@@ -0,0 +1,3 @@
+obj-y += $(BOARD).o $(BOARD)-eth.o
+obj-$(CONFIG_USB_GADGET) += $(BOARD)-otg.o
+obj-$(CONFIG_CMD_FASTBOOT) += $(BOARD)-fastboot.o $(BOARD)-recovery.o
diff --git a/board/hardkernel/odroidc2/aml-user-key.sig b/board/hardkernel/odroidc2/aml-user-key.sig
new file mode 100755
index 0000000..6b51b19
Binary files /dev/null and b/board/hardkernel/odroidc2/aml-user-key.sig differ
diff --git a/board/hardkernel/odroidc2/odroidc2-eth.c b/board/hardkernel/odroidc2/odroidc2-eth.c
new file mode 100644
index 0000000..7f69cde
--- /dev/null
+++ b/board/hardkernel/odroidc2/odroidc2-eth.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/arch/eth_setup.h>
+#include <asm/arch/secure_apb.h>
+
+#if defined(CONFIG_AML_ETHERNET)
+extern int aml_eth_init(bd_t *bis);
+
+struct eth_board_socket* eth_board_setup(char *name)
+{
+	struct eth_board_socket* new_board;
+
+	new_board = (struct eth_board_socket*)
+		malloc(sizeof(struct eth_board_socket));
+	if (NULL == new_board)
+		return NULL;
+
+	if (name != NULL) {
+		new_board->name = (char*)malloc(strlen(name));
+		strncpy(new_board->name, name, strlen(name));
+	} else {
+		new_board->name = CONFIG_SYS_BOARD;
+	}
+
+	new_board->eth_pinmux_setup = NULL ;
+	new_board->eth_clock_configure = NULL;
+	new_board->eth_hw_reset = NULL;
+
+	return new_board;
+}
+
+static void setup_net_chip(void)
+{
+	eth_aml_reg0_t reg;
+
+	/*
+	 * Set up ethernet clk need calibrate to configure
+	 */
+	setbits_le32(P_PERIPHS_PIN_MUX_6, 0x3fff);
+
+	reg.d32 = 0;
+	reg.b.phy_intf_sel = 1;
+	reg.b.data_endian = 0;
+	reg.b.desc_endian = 0;
+	reg.b.rx_clk_rmii_invert = 0;
+	reg.b.rgmii_tx_clk_src = 0;
+	reg.b.rgmii_tx_clk_phase = 1;
+	reg.b.rgmii_tx_clk_ratio = 4;
+	reg.b.phy_ref_clk_enable = 1;
+	reg.b.clk_rmii_i_invert = 0;
+	reg.b.clk_en = 1;
+	reg.b.adj_enable = 0;
+	reg.b.adj_setup = 0;
+	reg.b.adj_delay = 0;
+	reg.b.adj_skew = 0;
+	reg.b.cali_start = 0;
+	reg.b.cali_rise = 0;
+	reg.b.cali_sel = 0;
+	reg.b.rgmii_rx_reuse = 0;
+	reg.b.eth_urgent = 0;
+
+	/* RGMII Mode */
+	setbits_le32(P_PREG_ETH_REG0, reg.d32);
+
+	setbits_le32(HHI_GCLK_MPEG1, 1 << 3);
+
+	/*
+	 * Power on memory
+	 */
+	clrbits_le32(HHI_MEM_PD_REG0, (1 << 3) | (1<<2));
+
+	/*
+	 * Hardware reset ethernet phy : GPIOZ_14
+	 */
+	clrbits_le32(PREG_PAD_GPIO3_EN_N, 1 << 14);
+	clrbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+	udelay(100000);
+	setbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_net_chip();
+	udelay(1000);
+	aml_eth_init(bis);
+
+	return 0;
+}
+#endif
diff --git a/board/hardkernel/odroidc2/odroidc2-fastboot.c b/board/hardkernel/odroidc2/odroidc2-fastboot.c
new file mode 100644
index 0000000..87c286c
--- /dev/null
+++ b/board/hardkernel/odroidc2/odroidc2-fastboot.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <linux/sizes.h>
+#include <linux/string.h>
+#include <usb/fastboot.h>
+
+/* FIXME: Is block size always 512? */
+#define bytes_to_lba(x)		((x) / 512)
+#define gbytes_to_lba(x)	((x) * 1024 * 1024 * 2)
+
+#define SZ_RESERVED		(48 * SZ_1K + 512)	/* BL1 + MBR */
+#define SZ_BOOTLOADER		(720 * SZ_1K)
+#define SZ_BOOTMESSAGE		(4 * SZ_1K)
+
+static struct fbt_partition {
+	const char *name;
+	lbaint_t lba;
+} partitions[] = {
+	{
+		.name = "-reserved",
+		.lba = bytes_to_lba(SZ_RESERVED)
+	}, {
+		.name = "bootloader",
+		.lba = bytes_to_lba(SZ_BOOTLOADER
+				- (SZ_RESERVED + SZ_BOOTMESSAGE))
+	}, {
+		.name = "bcb",			/* Bootloader control block */
+		.lba = bytes_to_lba(SZ_BOOTMESSAGE)
+	}, {
+		.name = "env",			/* "environment" */
+		.lba = bytes_to_lba(CONFIG_ENV_SIZE)
+	}, {
+		.name = "dtb",			/* Device Tree */
+		.lba = bytes_to_lba(SZ_64K)
+	}, {
+		.name = "boot",			/* Boot image */
+		.lba = bytes_to_lba(16 * SZ_1M)
+	}, {
+		.name = "recovery",		/* Recovery Image */
+		.lba = bytes_to_lba(12 * SZ_1M)
+	}, {
+		.name = "logo",			/* Logo */
+		.lba = bytes_to_lba(2 * SZ_1M)
+	}
+};
+
+static struct dos_partition {
+	const char *name;
+	int part;
+	u8 type;
+	lbaint_t lba;
+} dos_partitions[] = {
+	{
+		.name = "cache",
+		.part = 3,
+		.type = 0x83,
+		.lba = bytes_to_lba(512 * SZ_1M),
+	}, {
+		.name = "system",
+		.part = 2,
+		.type = 0x83,
+		.lba = gbytes_to_lba(1),
+	}, {
+		.name = "vfat",
+		.part = 1,
+		.type = 0x0c,
+		.lba = bytes_to_lba(128 * SZ_1M),
+	}, {
+		.name = "userdata",
+		.part = 4,
+		.type = 0x83,
+		.lba = -1,
+	},
+};
+
+static int n = 0;
+
+static int valid_partition_number(int part)
+{
+	return (1 <= part) && (part <= ARRAY_SIZE(dos_partitions));
+}
+
+/*
+ * Initiate dos partition index and return the first sector (lba)
+ */
+lbaint_t board_dos_partition_start(void)
+{
+	int n;
+	lbaint_t next = 0;
+
+	for (n = 0 ; n < ARRAY_SIZE(partitions); n++)
+		next += partitions[n].lba;
+
+	return next;
+}
+
+/*
+ * Get the partition detail, partition number and its type, as well as
+ * return the number of sectors to allocate for the partition.
+ */
+lbaint_t board_dos_partition_next(int *part, u8 *type)
+{
+	if (!valid_partition_number(n + 1))
+		return 0;
+
+	struct dos_partition *p = &dos_partitions[n++];
+
+	*part = p->part;	/* partition number */
+	*type = p->type;	/* partition type */
+
+	/* Use remained sectors for this partition */
+	if (p->lba == -1)
+		return -1;
+
+	return p->lba;
+}
+
+/*
+ * Return the partition name of given partiton number. Since DOS partition
+ * does not support name on its parition table, the partition names are
+ * predefined upon each partition number.
+ */
+char *board_dos_partition_name(int part, char* name)
+{
+	int i;
+
+	if (!valid_partition_number(part))
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(dos_partitions); i++) {
+		/* Partition number is same with given to seek */
+		if (dos_partitions[i].part == part) {
+			strcpy(name, dos_partitions[i].name);
+			return name;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * Initiate the fastboot partition entries with internal system partitions and
+ * DOS partition table.
+ */
+int board_partition_init(void)
+{
+	struct mmc *mmc;
+	fastboot_ptentry ptn;
+	lbaint_t next = 0;
+	lbaint_t len;
+	int n = 0;
+
+	fastboot_flash_reset_ptn();
+
+	mmc = find_mmc_device(CONFIG_FASTBOOT_FLASH_MMC_DEV);
+
+	for (n = 0 ; mmc && n < ARRAY_SIZE(partitions); n++) {
+		len = partitions[n].lba;
+
+		/* Skip to add the partition if start with '-', but move forward
+		 * to next position as much as its size
+		 */
+		if (partitions[n].name[0] == '-') {
+			next += len;
+			continue;
+		}
+
+		/* 'env' partition contains U-boot's environment fields, it
+		 * could be damaged by fastboot if its offset is invalid with
+		 * defined by CONFIG_ENV_OFFSET.
+		 */
+		if (!strcmp(partitions[n].name, "env") &&
+				(bytes_to_lba(CONFIG_ENV_OFFSET) != next)) {
+			printf("WARNING!!: Invalid offset of 'env' partition,"
+					" it must be " LBAFU " but " LBAFU "\n",
+					next, (lbaint_t)bytes_to_lba(CONFIG_ENV_OFFSET));
+		}
+
+		if (len == 0)
+			len = mmc->block_dev.lba - next;
+
+		strncpy((char*)&ptn.name, partitions[n].name, sizeof(ptn.name));
+
+		ptn.start = next;
+		ptn.length = len;
+
+		/* Add the partition to fastboot partition entry table */
+		fastboot_flash_add_ptn(&ptn);
+
+		next += len;
+	}
+
+	fastboot_load_dos_partition();
+
+	return 0;
+}
+
+int board_fastboot_pre_flash(block_dev_desc_t *dev_desc, lbaint_t start,
+		void *buffer)
+{
+	if (start == 0) {
+		/* MUST be trying to modify MBR, hence at least DOS partition
+		 * table have to be kept. So buffer to flashing will be
+		 * overwritten with exist partition table.
+		 */
+		u8 mbr[512];
+
+		if (dev_desc->block_read(dev_desc->dev, start, 1, mbr) != 1) {
+			printf("fastboot: can't read MBR from device %d\n",
+					dev_desc->dev);
+			return -EIO;
+		}
+
+		memcpy(buffer + 0x1be, &mbr[0x1be], 512 - 0x1be);
+	}
+
+	return 0;
+}
diff --git a/board/hardkernel/odroidc2/odroidc2-otg.c b/board/hardkernel/odroidc2/odroidc2-otg.c
new file mode 100644
index 0000000..d8f1f3a
--- /dev/null
+++ b/board/hardkernel/odroidc2/odroidc2-otg.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/usb.h>
+
+#include <usb.h>
+#include <usb/s3c_udc.h>
+
+#define P_RESET1_REGISTER_USB	0xc1104408
+
+#define PREI_USB_PHY_A_REG_BASE	0xC0000000
+#define PREI_USB_PHY_REG_BASE	PREI_USB_PHY_A_REG_BASE
+
+#define PORT_REG_OFFSET		0x0000	/* Port - A */
+#define DWC_REG_BASE		(0xC9000000 + PORT_REG_OFFSET)
+
+#define DWC_REG_GSNPSID		0x040	/* Synopsys ID Register (Read Only) */
+
+#define OTG_PHY_CONFIG          0x0000
+#define OTG_PHY_CTRL            0x0004
+#define OTG_PHY_CTRL_POR        (1 << 15)
+#define OTG_PHY_CTRL_FSEL(x)    ((x) << 22)
+#define OTG_PHY_CTRL_CLKDET     (1 << 8)
+#define OTG_PHY_ENDP_INTR       0x0008
+#define OTG_PHY_ADP_BC          0x000c
+#define OTG_PHY_DBG_UART        0x0010
+#define OTG_PHY_TEST            0x0014
+#define OTG_PHY_TUNE            0x0018
+
+extern struct amlogic_usb_config *amlogic_usb_config(int port);
+
+static int dwc_otg_start_clk(int on)
+{
+        if (on) {
+                u32 temp;
+                u32 snpsid;
+
+                writel((1 << 2), P_RESET1_REGISTER_USB);
+                udelay(500);
+
+                /* Power On Reset & select 24MHz as reference clock */
+                temp = readl(PREI_USB_PHY_REG_BASE + OTG_PHY_CTRL);
+                temp |= OTG_PHY_CTRL_FSEL(5) | OTG_PHY_CTRL_POR;
+                writel(temp, PREI_USB_PHY_REG_BASE + OTG_PHY_CTRL);
+
+                udelay(500);    // 500us
+
+                temp &= ~OTG_PHY_CTRL_POR;
+                writel(temp, PREI_USB_PHY_REG_BASE + OTG_PHY_CTRL);
+
+                udelay(50000);  // 50ms
+
+                /* USB OTG PHY does work? */
+                temp = readl(PREI_USB_PHY_REG_BASE + OTG_PHY_CTRL);
+                if (0 == (temp & OTG_PHY_CTRL_CLKDET)) {
+                        printf("ERROR, usb phy clock is not detected!\n");
+                }
+
+                /* Check USB OTG ID, if it can work */
+                snpsid = readl(DWC_REG_BASE + DWC_REG_GSNPSID);
+                if (0x4f543000 != (snpsid & 0xfffff000)) {
+                        printf("%s, Bad value for SNPSID: 0x%08x\n",
+                                        __func__, snpsid);
+                        return -1;
+                }
+        } else {
+		/* FIXME: Add to disable USB OTG PHY
+		 */
+	}
+
+        return 0;
+}
+
+struct s3c_plat_otg_data odroid_otg_data = {
+	.phy_control	= dwc_otg_start_clk,
+	.regs_otg	= DWC_REG_BASE,
+};
+
+void otg_phy_init(struct s3c_udc *dev)
+{
+	dev->pdata->phy_control(1);
+
+	/* USB PHY0 Enable */
+	printf("USB PHY0 Enabled\n");
+}
+
+void otg_phy_off(struct s3c_udc *dev)
+{
+	dev->pdata->phy_control(0);
+
+	/* USB PHY0 Disable */
+	printf("USB PHY0 Disabled\n");
+}
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	amlogic_usb_config_t *usb_config;
+
+	if (init == USB_INIT_DEVICE) {
+		usb_config = amlogic_usb_start(BOARD_USB_MODE_SLAVE, 0);
+		if (usb_config == amlogic_usb_config(0))
+			return s3c_udc_probe(&odroid_otg_data);
+	} else {
+		/* FIXME: do we need to initiate USB host here? */
+	}
+
+	return -ENODEV;
+}
diff --git a/board/hardkernel/odroidc2/odroidc2-recovery.c b/board/hardkernel/odroidc2/odroidc2-recovery.c
new file mode 100644
index 0000000..e9bbcca
--- /dev/null
+++ b/board/hardkernel/odroidc2/odroidc2-recovery.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+#include <usb/fastboot.h>
+
+/* Bootloader Message
+ *
+ * This structure describes the content of a block in flash
+ * that is used for recovery and the bootloader to talk to
+ * each other.
+ *
+ * The command field is updated by linux when it wants to
+ * reboot into recovery or to update radio or bootloader firmware.
+ * It is also updated by the bootloader when firmware update
+ * is complete (to boot into recovery for any final cleanup)
+ *
+ * The status field is written by the bootloader after the
+ * completion of an "update-radio" or "update-hboot" command.
+ *
+ * The recovery field is only written by linux and used
+ * for the system to send a message to recovery or the
+ * other way around.
+ */
+struct bootloader_message {
+        char command[32];
+        char status[32];
+        char recovery[1024];
+};
+
+static const char *bcb_name = "bcb";
+static const char *bcb_magic = "recovery";
+static struct bootloader_message bcb;
+
+int board_get_recovery_message(void)
+{
+	block_dev_desc_t *dev_desc;
+	fastboot_ptentry *ptn;
+	unsigned int offset;
+
+	dev_desc = mmc_get_dev(0);
+	if (NULL == dev_desc)
+		return ODROID_REBOOT_CMD_UNKNOWN;
+
+	ptn = fastboot_flash_find_ptn(bcb_name);
+	if (NULL == ptn)
+		return ODROID_REBOOT_CMD_UNKNOWN;
+
+	offset = ptn->start;
+
+	dev_desc->block_read(dev_desc->dev, offset,
+			(sizeof(struct bootloader_message)
+			 + (dev_desc->blksz - 1)) / dev_desc->blksz, &bcb);
+
+	bcb.recovery[strlen(bcb_magic)] = 0;
+	if (0 == strncmp(bcb.recovery, bcb_magic, strlen(bcb_magic))) {
+		do_format();
+		printf("Default Android partition is created...\n");
+		return ODROID_REBOOT_CMD_RECOVERY;
+	}
+
+	return ODROID_REBOOT_CMD_UNKNOWN;
+}
diff --git a/board/hardkernel/odroidc2/odroidc2.c b/board/hardkernel/odroidc2/odroidc2.c
new file mode 100644
index 0000000..536114c
--- /dev/null
+++ b/board/hardkernel/odroidc2/odroidc2.c
@@ -0,0 +1,542 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/arch/secure_apb.h>
+#include <asm/arch/eth_setup.h>
+#include <asm/arch-gxb/gpio.h>
+#include <asm-generic/gpio.h>
+#include <usb/fastboot.h>
+#include <asm/arch/efuse.h>
+
+#ifdef CONFIG_AML_VPU
+#include <vpu.h>
+#endif
+
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern int board_get_recovery_message(void);
+extern unsigned int get_mmc_size(void);
+
+#define GPIO_BLUELED		132
+#define GPIO_USB_PWREN		123
+#define GPIO_OTG_PWREN		124
+#define GPIO_TF3V3		35	/* GPIOY_12 */
+#define GPIO_TF1V8		122	/* GPIOAO_3 */
+
+int serial_set_pin_port(unsigned long port_base)
+{
+	//UART in "Always On Module"
+	//GPIOAO_0==tx,GPIOAO_1==rx
+	//setbits_le32(P_AO_RTI_PIN_MUX_REG,3<<11);
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+void secondary_boot_func(void)
+{
+	/*
+	 * TODO: should be written in ASM if necessary
+	 */
+}
+
+/*
+ * Discover the boot device within MicroSD or eMMC
+ * and return 1 for eMMC, otherwise 0.
+ */
+#define BOOT_DEVICE_RESERVED	0
+#define BOOT_DEVICE_EMMC	1
+#define BOOT_DEVICE_NAND	2
+#define BOOT_DEVICE_SPI		3
+#define BOOT_DEVICE_SD		4
+#define BOOT_DEVICE_USB		5
+
+int get_boot_device(void)
+{
+	return readl(AO_SEC_GP_CFG0) & 0xf;
+}
+
+/*
+ * Discover the boot reason:
+ *   1. check if the board is started with Android Self-Installation.
+ *   2. if rebooted by 'reboot' command in previous kernel boot.
+ *   3. Otherwise returns normal boot response by power cycle.
+ */
+int board_reboot_reason(void)
+{
+	static int __reboot_reason = ODROID_REBOOT_CMD_UNKNOWN;
+
+	if (ODROID_REBOOT_CMD_UNKNOWN == __reboot_reason) {
+		__reboot_reason = board_get_recovery_message();
+		if (ODROID_REBOOT_CMD_UNKNOWN == __reboot_reason)
+			__reboot_reason = (readl(AO_SEC_SD_CFG15) >> 12) & 0xf;
+	}
+
+	return __reboot_reason;
+}
+
+void board_print_info(void)
+{
+	int i;
+	int offset, length;
+	char buf[EFUSE_BYTES];
+
+	printf("-------------------------------------------------\n");
+	printf("* Welcome to Hardkernel's ODROID-C2\n");
+	printf("-------------------------------------------------\n");
+
+	/* CPU */
+	printf("CPU : AMLogic S905\n");
+
+	/* S/N */
+	offset = 20;
+	length = 16;
+	memset(buf, 0, EFUSE_BYTES);
+	efuse_read_usr(buf, length, (loff_t *)&offset);
+	buf[length] = '\0';
+	printf("S/N : ");
+	printf("%s\n", buf);
+
+	/* MAC */
+	offset = 52;
+	length = 6;
+	memset(buf, 0, EFUSE_BYTES);
+	efuse_read_usr(buf, length, (loff_t *)&offset);
+	buf[length] = '\0';
+	printf("MAC : ");
+	for (i=0;i<(length-1);i++)
+		printf("%02x:", buf[i]);
+	printf("%02x\n", buf[i]);
+
+	/* BID */
+	offset = 70;
+	length = 48;
+	memset(buf, 0, EFUSE_BYTES);
+	efuse_read_usr(buf, length, (loff_t *)&offset);
+	buf[0xA] = '\0';
+	printf("BID : ");
+	printf("%s\n", buf);
+
+	printf("-------------------------------------------------\n");
+}
+
+void board_identity(void)
+{
+	char __serialno[17];
+	int offset, length;
+
+	/* S/N */
+	offset = 20;
+	length = 16;
+
+	memset(__serialno, 0, 17);
+	efuse_read_usr(__serialno, length, (loff_t *)&offset);
+
+	__serialno[16] = '\0';
+
+	setenv("fbt_id#", __serialno);
+	run_command("saveenv", 1);
+}
+
+#if CONFIG_AML_SD_EMMC
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+
+static int  sd_emmc_init(unsigned port)
+{
+	switch (port)
+	{
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+		//todo add card detect
+		//setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+		break;
+	case SDIO_PORT_C:
+		//enable pull up
+		//clrbits_le32(P_PAD_PULL_UP_REG3, 0xff<<0);
+		break;
+	default:
+		break;
+	}
+
+	return cpu_sd_emmc_init(port);
+}
+
+extern unsigned sd_debug_board_1bit_flag;
+static int  sd_emmc_detect(unsigned port)
+{
+	int ret;
+	switch (port) {
+
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+		setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+		ret=readl(P_PREG_PAD_GPIO5_I)&(1<<29)?0:1;
+		printf("ret = %d .",ret);
+		if ((readl(P_PERIPHS_PIN_MUX_8)&(3<<9))) { //if uart pinmux set, debug board in
+			if (!(readl(P_PREG_PAD_GPIO2_I)&(1<<24))) {
+				printf("sdio debug board detected, sd card with 1bit mode\n");
+				sd_debug_board_1bit_flag = 1;
+			}
+			else{
+				printf("sdio debug board detected, no sd card in\n");
+				sd_debug_board_1bit_flag = 0;
+				return 1;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void sd_emmc_pwr_prepare(unsigned port)
+{
+	cpu_sd_emmc_pwr_prepare(port);
+}
+
+static void sd_emmc_pwr_on(unsigned port)
+{
+	switch (port)
+	{
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+		//            clrbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+		//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+		/// @todo NOT FINISH
+		break;
+	case SDIO_PORT_C:
+		break;
+	default:
+		break;
+	}
+	return;
+}
+static void sd_emmc_pwr_off(unsigned port)
+{
+	/// @todo NOT FINISH
+	switch (port)
+	{
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+		//            setbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+		//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+		break;
+	case SDIO_PORT_C:
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+static void board_mmc_register(unsigned port)
+{
+	struct aml_card_sd_info *aml_priv=cpu_sd_emmc_get(port);
+
+	if (aml_priv == NULL)
+		return;
+
+	aml_priv->sd_emmc_init=sd_emmc_init;
+	aml_priv->sd_emmc_detect=sd_emmc_detect;
+	aml_priv->sd_emmc_pwr_off=sd_emmc_pwr_off;
+	aml_priv->sd_emmc_pwr_on=sd_emmc_pwr_on;
+	aml_priv->sd_emmc_pwr_prepare=sd_emmc_pwr_prepare;
+	aml_priv->desc_buf = malloc(NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info)));
+
+	if (NULL == aml_priv->desc_buf)
+		printf(" desc_buf Dma alloc Fail!\n");
+	else
+		printf("aml_priv->desc_buf = 0x%p\n",aml_priv->desc_buf);
+
+	sd_emmc_register(aml_priv);
+}
+
+int board_mmc_init(bd_t	*bis)
+{
+#ifdef CONFIG_VLSI_EMULATOR
+	//board_mmc_register(SDIO_PORT_A);
+#else
+	//board_mmc_register(SDIO_PORT_B);
+#endif
+	switch (get_boot_device())
+	{
+	case BOOT_DEVICE_EMMC:
+		board_mmc_register(SDIO_PORT_C);	// "mmc0"
+		board_mmc_register(SDIO_PORT_B);
+		break;
+	case BOOT_DEVICE_SD:
+		board_mmc_register(SDIO_PORT_B);	// "mmc0"
+		board_mmc_register(SDIO_PORT_C);
+		break;
+	default:
+		printf("No available mmc device! Check boot device!\n");
+		do_reset(NULL, 0, 0, NULL);
+		break;
+	}
+	//	board_mmc_register(SDIO_PORT_B1);
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_SYS_I2C_AML)
+#include <aml_i2c.h>
+
+struct aml_i2c_platform g_aml_i2c_plat = {
+	.wait_count         = 1000000,
+	.wait_ack_interval  = 5,
+	.wait_read_interval = 5,
+	.wait_xfer_interval = 5,
+	.master_no          = AML_I2C_MASTER_AO,
+	.use_pio            = 0,
+	.master_i2c_speed   = AML_I2C_SPPED_400K,
+	.master_ao_pinmux = {
+		.scl_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_4_REG,
+		.scl_bit    = MESON_I2C_MASTER_AO_GPIOAO_4_BIT,
+		.sda_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_5_REG,
+		.sda_bit    = MESON_I2C_MASTER_AO_GPIOAO_5_BIT,
+	}
+};
+
+static void board_i2c_init(void)
+{
+	//disable all other pins which share with I2C_SDA_AO & I2C_SCK_AO
+	clrbits_le32(P_AO_RTI_PIN_MUX_REG,
+			(1 << 2) | (1 << 24) | (1 << 1) | (1 << 23));
+
+	//enable I2C MASTER AO pins
+	setbits_le32(P_AO_RTI_PIN_MUX_REG,
+			(MESON_I2C_MASTER_AO_GPIOAO_4_BIT
+			 | MESON_I2C_MASTER_AO_GPIOAO_5_BIT));
+
+	udelay(10);
+
+	//Amlogic I2C controller initialized
+	//note: it must be call before any I2C operation
+	aml_i2c_init();
+
+	udelay(10);
+}
+#endif
+
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+int board_early_init_f(void)
+{
+	return 0;
+}
+#endif
+
+static void board_run_fastboot(void)
+{
+	run_command("fastboot", 0);
+}
+
+static void board_run_recovery(void)
+{
+	run_command("movi read dtb 0 ${dtb_mem_addr}", 0);
+	run_command("movi read recovery 0 ${loadaddr}", 0);
+	run_command("bootm ${load_addr}", 0);
+}
+
+void board_get_mmc_size(void)
+{
+	char str[3];
+	unsigned int actual_size = get_mmc_size();
+	unsigned int card_size, result;
+	unsigned char i=0;
+
+	while (1) {
+		card_size = (8 << i);
+		result = actual_size / card_size;
+
+		if (1 > result)		break;
+		else if (10 < i)	break;
+		else	i++;
+	}
+
+	sprintf(str, "%d", card_size);
+	if (card_size < 128) 	str[2] = '\0';
+
+	setenv("mmc_size", str);
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+	int reboot_reason;
+
+	board_partition_init();
+
+	board_get_mmc_size();
+
+#ifdef CONFIG_DISPLAY_LOGO
+	run_command("showlogo 720p60hz", 0);
+#endif
+
+	board_identity();
+
+	reboot_reason = board_reboot_reason();
+	if (ODROID_REBOOT_CMD_FASTBOOT == reboot_reason)
+		board_run_fastboot();
+	else if (ODROID_REBOOT_CMD_RECOVERY == reboot_reason)
+		board_run_recovery();
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_USB_DWC_OTG_HCD)
+#include <asm/arch/usb.h>
+
+static void callback_otg_power(char power)
+{
+	gpio_direction_output(GPIO_OTG_PWREN, power);
+}
+
+static void callback_host_power(char power)
+{
+	gpio_direction_output(GPIO_USB_PWREN, power);
+}
+
+static struct amlogic_usb_config usb_config0 = {
+	.clk_selecter	= USB_PHY_CLK_SEL_XTAL,
+	.pll_divider	= 1,
+	.base_addr	= CONFIG_M8_USBPORT_BASE_A,
+	.id_mode	= USB_ID_MODE_SW_HOST,
+	.set_vbus_power	= callback_otg_power,
+};
+
+static struct amlogic_usb_config usb_config1= {
+	.clk_selecter	= USB_PHY_CLK_SEL_XTAL,
+	.pll_divider	= 1,
+	.base_addr	= CONFIG_M8_USBPORT_BASE_B,
+	.id_mode	= USB_ID_MODE_SW_HOST,
+	.set_vbus_power	= callback_host_power,
+};
+
+struct amlogic_usb_config *amlogic_usb_config(int port)
+{
+	if (0 == port)
+		return &usb_config0;
+	else if (1 == port)
+		return &usb_config1;
+
+	return NULL;
+}
+#endif
+
+int board_init(void)
+{
+	board_print_info();
+
+	/* T-Flash Init voltage : T-Flash I/O 3.3V, T-Flash mem 3.3V */
+	gpio_request(GPIO_TF1V8, "TF_1V8");
+	gpio_direction_output(GPIO_TF1V8, 0);
+	gpio_request(GPIO_TF3V3, "TF_3V3");
+	gpio_direction_output(GPIO_TF3V3, 1);
+
+	/* LED: SYSLED (Blue color) */
+	gpio_request(GPIO_BLUELED, "blueled");
+	gpio_direction_output(GPIO_BLUELED, 0);
+
+	/*
+	 * USB Host: RST_N for GL852
+	 * Off by default, On when USB HOST is activated
+	 */
+	gpio_request(GPIO_USB_PWREN, "usb_pwren");
+	gpio_direction_output(GPIO_USB_PWREN, 0);
+
+	/*
+	 * USB OTG: Power 
+	 * Off by default, On when USB OTG is activated
+	 */
+	gpio_request(GPIO_OTG_PWREN, "otg_pwren");
+	gpio_direction_output(GPIO_OTG_PWREN, 0);
+
+#if defined(CONFIG_USB_DWC_OTG_HCD)
+	amlogic_usb_init(&usb_config0, BOARD_USB_MODE_SLAVE);
+	amlogic_usb_init(&usb_config1, BOARD_USB_MODE_HOST);
+#endif
+
+#ifdef CONFIG_AML_VPU
+	vpu_probe();
+#endif
+
+#ifdef CONFIG_AML_HDMITX20
+	hdmi_tx_init();
+#endif
+
+	return 0;
+}
+
+phys_size_t get_effective_memsize(void)
+{
+	phys_size_t phys_size = (readl(AO_SEC_GP_CFG0) & 0xFFFF0000) << 4;
+
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	phys_size -= CONFIG_SYS_MEM_TOP_HIDE;
+#endif
+
+	return phys_size;
+}
+
+#ifdef CONFIG_MULTI_DTB
+int checkhw(char * name)
+{
+	unsigned int ddr_size=0;
+	char loc_name[64] = {0};
+	int i;
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		ddr_size += gd->bd->bi_dram[i].size;
+	}
+
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	ddr_size += CONFIG_SYS_MEM_TOP_HIDE;
+#endif
+
+	switch (ddr_size) {
+	case 0x80000000:
+		strcpy(loc_name, "odroidc2_2g\0");
+		break;
+	case 0x40000000:
+		strcpy(loc_name, "odroidc2_1g\0");
+		break;
+	case 0x2000000:
+		strcpy(loc_name, "odroidc2_512m\0");
+		break;
+	default:
+		//printf("DDR size: 0x%x, multi-dt doesn't support\n", ddr_size);
+		strcpy(loc_name, "odroidc2_unsupport");
+		break;
+	}
+
+	strcpy(name, loc_name);
+	setenv("aml_dt", loc_name);
+
+	return 0;
+}
+#endif
diff --git a/common/Makefile b/common/Makefile
index c668a2f..6f3cff2 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -34,6 +34,14 @@ obj-$(CONFIG_CMD_BOOTM) += cmd_bootm.o bootm.o bootm_os.o
 obj-y += cmd_help.o
 obj-y += cmd_version.o
 
+#partitions
+ifndef CONFIG_MACH_ODROIDC2
+obj-y += partitions.o
+endif
+
+#remote support
+obj-$(CONFIG_IR_REMOTE) += cmd_irkey.o
+
 # environment
 obj-y += env_attr.o
 obj-y += env_callback.o
@@ -48,6 +56,8 @@ obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
 obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o
 obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o
 obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
+obj-$(CONFIG_ENV_IS_IN_AMLNAND) += env_amlnand.o
+obj-$(CONFIG_STORE_COMPATIBLE) += env_storage.o env_amlnand.o env_mmc.o
 obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
 obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
 obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
@@ -58,6 +68,7 @@ obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
 # command
 obj-$(CONFIG_CMD_AES) += cmd_aes.o
 obj-$(CONFIG_CMD_AMBAPP) += cmd_ambapp.o
+obj-$(CONFIG_CMD_AUTOSCRIPT) += cmd_autoscript.o
 obj-$(CONFIG_SOURCE) += cmd_source.o
 obj-$(CONFIG_CMD_SOURCE) += cmd_source.o
 obj-$(CONFIG_CMD_BDI) += cmd_bdinfo.o
@@ -70,6 +81,7 @@ obj-$(CONFIG_CMD_CACHE) += cmd_cache.o
 obj-$(CONFIG_CMD_CBFS) += cmd_cbfs.o
 obj-$(CONFIG_CMD_CLK) += cmd_clk.o
 obj-$(CONFIG_CMD_CONSOLE) += cmd_console.o
+obj-$(CONFIG_CMD_SARADC) += cmd_saradc.o
 obj-$(CONFIG_CMD_CPLBINFO) += cmd_cplbinfo.o
 obj-$(CONFIG_DATAFLASH_MMC_SELECT) += cmd_dataflash_mmc_mux.o
 obj-$(CONFIG_CMD_DATE) += cmd_date.o
@@ -93,6 +105,7 @@ obj-$(CONFIG_CMD_EXT2) += cmd_ext2.o
 obj-$(CONFIG_CMD_FAT) += cmd_fat.o
 obj-$(CONFIG_CMD_FDC) += cmd_fdc.o
 obj-$(CONFIG_OF_LIBFDT) += cmd_fdt.o fdt_support.o
+obj-$(CONFIG_MULTI_DTB) += aml_dt.o
 obj-$(CONFIG_CMD_FITUPD) += cmd_fitupd.o
 obj-$(CONFIG_CMD_FLASH) += cmd_flash.o
 ifdef CONFIG_FPGA
@@ -132,6 +145,9 @@ obj-$(CONFIG_CMD_MII) += cmd_mdio.o
 endif
 obj-$(CONFIG_CMD_MISC) += cmd_misc.o
 obj-$(CONFIG_CMD_MMC) += cmd_mmc.o
+#obj-$(CONFIG_CMD_MMC) += cmd_aml_mmc.o
+obj-$(CONFIG_STORE_COMPATIBLE) += store_interface.o cmd_burnup.o
+obj-$(CONFIG_STORE_COMPATIBLE) += cmd_imgread.o
 obj-$(CONFIG_CMD_MMC_SPI) += cmd_mmc_spi.o
 obj-$(CONFIG_MP) += cmd_mp.o
 obj-$(CONFIG_CMD_MTDPARTS) += cmd_mtdparts.o
@@ -187,6 +203,9 @@ obj-$(CONFIG_YAFFS2) += cmd_yaffs2.o
 obj-$(CONFIG_CMD_SPL) += cmd_spl.o
 obj-$(CONFIG_CMD_ZIP) += cmd_zip.o
 obj-$(CONFIG_CMD_ZFS) += cmd_zfs.o
+obj-$(CONFIG_AML_VPU) += cmd_vpu.o
+obj-$(CONFIG_CMD_DDR_TEST) += cmd_d2pll.o
+obj-$(CONFIG_CMD_DDR_TEST) += cmd_ddr_test.o
 
 # others
 obj-$(CONFIG_BOOTSTAGE) += bootstage.o
@@ -204,6 +223,8 @@ obj-$(CONFIG_UPDATE_TFTP) += update.o
 obj-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
 obj-$(CONFIG_CMD_DFU) += cmd_dfu.o
 obj-$(CONFIG_CMD_GPT) += cmd_gpt.o
+obj-$(CONFIG_CMD_EFUSE) += cmd_efuse.o
+obj-$(CONFIG_CMD_CPU_TEMP) += cmd_cpu_temp.o
 endif
 
 ifdef CONFIG_SPL_BUILD
@@ -234,6 +255,7 @@ endif
 obj-y += cmd_nvedit.o
 #environment
 obj-y += env_common.o
+obj-y += cmd_defenv_without.o
 #others
 obj-$(CONFIG_DDR_SPD) += ddr_spd.o
 obj-$(CONFIG_SPD_EEPROM) += ddr_spd.o
@@ -262,6 +284,8 @@ endif
 
 obj-$(CONFIG_CMD_BLOB) += cmd_blob.o
 
+obj-$(CONFIG_INSTABOOT) += cmd_wipeisb.o instaboot.o
+
 # We always have this since drivers/ddr/fs/interactive.c needs it
 obj-y += cli_simple.o
 
@@ -272,4 +296,17 @@ obj-y += s_record.o
 obj-y += xyzModem.o
 obj-y += cmd_disk.o
 
+# amlogic commands
+obj-$(CONFIG_CMD_REBOOT) += cmd_reboot.o
+obj-y += cmd_scp.o
+obj-$(CONFIG_AML_HDMITX20) += hdmi_parameters.o cmd_hdmitx.o
+obj-$(CONFIG_CMD_JTAG) += cmd_jtag.o
+obj-$(CONFIG_AML_OSD) += cmd_osd.o
+obj-$(CONFIG_AML_CVBS) += cmd_cvbs.o
+obj-$(CONFIG_AML_VOUT) += cmd_vout.o
+
 CFLAGS_env_embedded.o := -Wa,--no-warn -DENV_CRC=$(shell tools/envcrc 2>/dev/null)
+
+obj-$(CONFIG_MACH_ODROIDC2) += cmd_movi.o
+obj-$(CONFIG_MACH_ODROIDC2) += cmd_cfgload.o
+obj-$(CONFIG_MACH_ODROIDC2) += cmd_showlogo.o
diff --git a/common/aml_dt.c b/common/aml_dt.c
new file mode 100644
index 0000000..2cd6a04
--- /dev/null
+++ b/common/aml_dt.c
@@ -0,0 +1,162 @@
+#include <common.h>
+#include <bootm.h>
+#include <command.h>
+#include <image.h>
+#include <malloc.h>
+#include <asm/arch/io.h>
+
+#define AML_DT_IND_LENGTH_V1		4	/*fixed*/
+#define AML_DT_IND_LENGTH_V2		16	/*fixed*/
+
+#define AML_DT_IND_LENGTH			16
+#define AML_DT_ID_VARI_TOTAL		3	//Total 3 strings
+#define AML_DT_EACH_ID_INT			(AML_DT_IND_LENGTH / 4)
+
+/*Latest version: v2*/
+#define AML_DT_VERSION_OFFSET		4
+#define AML_DT_TOTAL_DTB_OFFSET		8
+#define AML_DT_FIRST_DTB_OFFSET		12
+//#define AML_DT_DTB_HEADER_SIZE	(8+(AML_DT_IND_LENGTH * AML_DT_ID_VARI_TOTAL))
+#define AML_DT_DTB_DT_INFO_OFFSET	0
+//#define AML_DT_DTB_OFFSET_OFFSET	(AML_DT_IND_LENGTH * AML_DT_ID_VARI_TOTAL)
+//#define AML_DT_DTB_SIZE_OFFSET	16
+
+#define AML_DT_UBOOT_ENV	"aml_dt"
+#define DT_HEADER_MAGIC		0xedfe0dd0	/*header of dtb file*/
+#define AML_DT_HEADER_MAGIC	0x5f4c4d41	/*"AML_", multi dtbs supported*/
+
+//#define readl(addr) (*(volatile unsigned int*)(addr))
+extern int checkhw(char * name);
+
+unsigned long get_multi_dt_entry(unsigned long fdt_addr){
+	unsigned int dt_magic = readl(fdt_addr);
+	unsigned int dt_total = 0;
+	unsigned int dt_tool_version = 0;
+	printf("      Amlogic multi-dtb tool\n");
+	/*printf("      Process device tree. dt magic: %x\n", dt_magic);*/
+	if (dt_magic == DT_HEADER_MAGIC) {/*normal dtb*/
+		printf("      Single dtb detected\n");
+		return fdt_addr;
+	}
+	else if (dt_magic == AML_DT_HEADER_MAGIC) {/*multi dtb*/
+		printf("      Multi dtb detected\n");
+		/* check and set aml_dt */
+		int i = 0;
+		char *aml_dt_buf;
+		aml_dt_buf = (char *)malloc(sizeof(char)*64);
+		memset(aml_dt_buf, 0, sizeof(aml_dt_buf));
+		char *aml_dt = getenv(AML_DT_UBOOT_ENV);
+
+		/* if aml_dt not exist or env not ready, get correct dtb by name */
+		if (NULL == aml_dt)
+			checkhw(aml_dt_buf);
+		else
+			memcpy(aml_dt_buf, aml_dt, (strlen(aml_dt)>64?64:(strlen(aml_dt)+1)));
+
+		unsigned int aml_dt_len = aml_dt_buf ? strlen(aml_dt_buf) : 0;
+		if (aml_dt_len <= 0) {
+			printf("      Get env aml_dt failed!\n");
+			return fdt_addr;
+		}
+
+		/*version control, compatible with v1*/
+		dt_tool_version = readl(fdt_addr + AML_DT_VERSION_OFFSET);
+		unsigned int aml_each_id_length=0;
+		unsigned int aml_dtb_offset_offset;
+		unsigned int aml_dtb_header_size;
+		if (dt_tool_version == 1)
+			aml_each_id_length = 4;
+		else if(dt_tool_version == 2)
+			aml_each_id_length = 16;
+
+		aml_dtb_offset_offset = aml_each_id_length * AML_DT_ID_VARI_TOTAL;
+		aml_dtb_header_size = 8+(aml_each_id_length * AML_DT_ID_VARI_TOTAL);
+		printf("      Multi dtb tool version: v%d .\n", dt_tool_version);
+
+		/*fdt_addr + 0x8: num of dtbs*/
+		dt_total = readl(fdt_addr + AML_DT_TOTAL_DTB_OFFSET);
+		printf("      Support %d dtbs.\n", dt_total);
+
+		/* split aml_dt to 3 strings */
+		char *tokens[3] = {NULL, NULL, NULL};
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++) {
+			tokens[i] = strsep(&aml_dt_buf, "_");
+		}
+		if (aml_dt_buf)
+			free(aml_dt_buf);
+		printf("        aml_dt soc: %s platform: %s variant: %s\n", tokens[0], tokens[1], tokens[2]);
+
+		/*match and print result*/
+		char **dt_info;
+		dt_info = (char **)malloc(sizeof(char *)*AML_DT_ID_VARI_TOTAL);
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++)
+			dt_info[i] = (char *)malloc(sizeof(char)*aml_each_id_length);
+		unsigned int dtb_match_num = 0xffff;
+		unsigned int x = 0, y = 0, z = 0; //loop counter
+		unsigned int read_data;
+		for (i = 0; i < dt_total; i++) {
+			for (x = 0; x < AML_DT_ID_VARI_TOTAL; x++) {
+				for (y = 0; y < aml_each_id_length; y+=4) {
+					read_data = readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
+						 i * aml_dtb_header_size + AML_DT_DTB_DT_INFO_OFFSET + \
+						 (x * aml_each_id_length) + y);
+					dt_info[x][y+0] = (read_data >> 24) & 0xff;
+					dt_info[x][y+1] = (read_data >> 16) & 0xff;
+					dt_info[x][y+2] = (read_data >> 8) & 0xff;
+					dt_info[x][y+3] = (read_data >> 0) & 0xff;
+				}
+				for (z=0; z<aml_each_id_length; z++) {
+					/*fix string with \0*/
+					if (0x20 == (uint)dt_info[x][z]) {
+						dt_info[x][z] = '\0';
+					}
+				}
+				//printf("dt_info[x]: %s\n", dt_info[x]);
+				//printf("strlen(dt_info[x]): %d\n", strlen(dt_info[x]));
+			}
+			if (dt_tool_version == 1)
+				printf("        dtb %d soc: %.4s   plat: %.4s   vari: %.4s\n", i, (char *)(dt_info[0]), (char *)(dt_info[1]), (char *)(dt_info[2]));
+			else if(dt_tool_version == 2)
+				printf("        dtb %d soc: %.16s   plat: %.16s   vari: %.16s\n", i, (char *)(dt_info[0]), (char *)(dt_info[1]), (char *)(dt_info[2]));
+			uint match_str_counter = 0;
+			for (z=0; z<AML_DT_ID_VARI_TOTAL; z++) {
+				/*must match 3 strings*/
+				if (!strncmp(tokens[z], (char *)(dt_info[z]), strlen(tokens[z])) && \
+					(strlen(tokens[z]) == strlen(dt_info[z])))
+					match_str_counter++;
+			}
+			if (match_str_counter == AML_DT_ID_VARI_TOTAL) {
+				//printf("Find match dtb\n");
+				dtb_match_num = i;
+			}
+			for (z=0; z<AML_DT_ID_VARI_TOTAL; z++) {
+				/*clear data for next loop*/
+				memset(dt_info[z], 0, sizeof(aml_each_id_length));
+			}
+		}
+		/*clean malloc memory*/
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++) {
+			if (dt_info[i])
+				free(dt_info[i]);
+		}
+		if (dt_info)
+			free(dt_info);
+
+		/*if find match dtb, return address, or else return main entrance address*/
+		if (0xffff != dtb_match_num) {
+			printf("      Find match dtb: %d\n", dtb_match_num);
+			/*this offset is based on dtb image package, so should add on base address*/
+			return (fdt_addr + readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
+				dtb_match_num * aml_dtb_header_size + aml_dtb_offset_offset));
+		}
+		else{
+			printf("      Not match any dtb.\n");
+			return fdt_addr;
+		}
+	}
+	else {
+		printf("      Cannot find legal dtb!\n");
+		return fdt_addr;
+	}
+	return 0;
+}
diff --git a/common/autoboot.c b/common/autoboot.c
index c27cc2c..ccb7b41 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -114,7 +114,7 @@ static int abortboot_keyed(int bootdelay)
 					delaykey[i].len, delaykey[i].str,
 					delaykey[i].len) == 0) {
 					debug_bootkeys("got %skey\n",
-						delaykey[i].retry ? "delay" :
+						       delaykey[i].retry ? "delay" :
 						"stop");
 
 				/* don't retry auto boot */
@@ -146,6 +146,7 @@ static int abortboot_normal(int bootdelay)
 {
 	int abort = 0;
 	unsigned long ts;
+	int key;
 
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
@@ -167,24 +168,21 @@ static int abortboot_normal(int bootdelay)
 		}
 	}
 #endif
-
 	while ((bootdelay > 0) && (!abort)) {
 		--bootdelay;
 		/* delay 1000 ms */
 		ts = get_timer(0);
 		do {
 			if (tstc()) {	/* we got a key press	*/
-				abort  = 1;	/* don't auto boot	*/
-				bootdelay = 0;	/* no more delay	*/
-# ifdef CONFIG_MENUKEY
-				menukey = getc();
-# else
-				(void) getc();  /* consume input	*/
-# endif
-				break;
+				key = getc();
+				if ((key != 0xff) && (key != 0)) {
+					abort  = 1;	/* don't auto boot	*/
+					bootdelay = 0;	/* no more delay	*/
+					break;
+				}
 			}
-			udelay(10000);
-		} while (!abort && get_timer(ts) < 1000);
+			udelay(1000);
+		} while (!abort && get_timer(ts) < 100);
 
 		printf("\b\b\b%2d ", bootdelay);
 	}
diff --git a/common/board_f.c b/common/board_f.c
index cfd77f8..b0d6c31 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -213,6 +213,11 @@ static int show_dram_config(void)
 	size = gd->ram_size;
 #endif
 
+/* add HIDE mem size, print total ddr size */
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	size = size + CONFIG_SYS_MEM_TOP_HIDE;
+#endif
+
 	print_size(size, "");
 	board_add_ram_info(0);
 	putc('\n');
@@ -738,6 +743,8 @@ static int setup_reloc(void)
 #endif
 	memcpy(gd->new_gd, (char *)gd, sizeof(gd_t));
 
+	printf("Relocation Offset is: %08lx\n", gd->reloc_off);
+
 	debug("Relocation Offset is: %08lx\n", gd->reloc_off);
 	debug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
 	      gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd),
diff --git a/common/bootm.c b/common/bootm.c
index 6b3ea8c..79e1597 100644
--- a/common/bootm.c
+++ b/common/bootm.c
@@ -152,11 +152,13 @@ static int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,
 #ifdef CONFIG_ANDROID_BOOT_IMAGE
 	case IMAGE_FORMAT_ANDROID:
 		images.os.type = IH_TYPE_KERNEL;
-		images.os.comp = IH_COMP_NONE;
+		images.os.comp =  android_image_get_comp(os_hdr);
 		images.os.os = IH_OS_LINUX;
 
 		images.os.end = android_image_get_end(os_hdr);
 		images.os.load = android_image_get_kload(os_hdr);
+		if (images.os.load == 0x10008000)
+			images.os.load = 0x1080000;
 		images.ep = images.os.load;
 		ep_found = true;
 		break;
@@ -226,8 +228,38 @@ static int bootm_find_fdt(int flag, int argc, char * const argv[])
 	int ret;
 
 	/* find flattened device tree */
+	#ifdef CONFIG_DTB_MEM_ADDR
+	unsigned long long dtb_mem_addr =  -1;
+	char *ft_addr_bak;
+	ulong ft_len_bak;
+	if (getenv("dtb_mem_addr"))
+		dtb_mem_addr = simple_strtoul(getenv("dtb_mem_addr"), NULL, 16);
+	else
+		dtb_mem_addr = CONFIG_DTB_MEM_ADDR;
+
+#ifdef CONFIG_MULTI_DTB
+	extern unsigned long get_multi_dt_entry(unsigned long fdt_addr);
+	/* update dtb address, compatible with single dtb and multi dtbs */
+	dtb_mem_addr = get_multi_dt_entry(dtb_mem_addr);
+#endif
+
+	ft_addr_bak = (char *)images.ft_addr;
+	ft_len_bak = images.ft_len;
+	images.ft_addr = (char *)map_sysmem(dtb_mem_addr, 0);
+	printf("load dtb from 0x%lx ......\n", (unsigned long)(images.ft_addr));
+	#endif
 	ret = boot_get_fdt(flag, argc, argv, IH_ARCH_DEFAULT, &images,
 			   &images.ft_addr, &images.ft_len);
+	#ifdef CONFIG_DTB_MEM_ADDR
+	if (ret) {
+		images.ft_addr = ft_addr_bak;
+		images.ft_len = ft_len_bak;
+		printf("load dtb from 0x%lx ......\n",
+			(unsigned long)(images.ft_addr));
+		ret = boot_get_fdt(flag, argc, argv, IH_ARCH_DEFAULT, &images,
+			   &images.ft_addr, &images.ft_len);
+	}
+	#endif
 	if (ret) {
 		puts("Could not find a valid device tree\n");
 		return 1;
@@ -283,13 +315,13 @@ static int decomp_image(int comp, ulong load, ulong image_start, int type,
 {
 	const char *type_name = genimg_get_type_name(type);
 	__attribute__((unused)) uint unc_len = CONFIG_SYS_BOOTM_LEN;
-
 	*load_end = load;
 	switch (comp) {
 	case IH_COMP_NONE:
-		if (load == image_start) {
+		/*if (load == image_start) {
 			printf("   XIP %s ... ", type_name);
-		} else {
+		} else */
+		{
 			printf("   Loading %s ... ", type_name);
 			memmove_wd(load_buf, image_buf, image_len, CHUNKSZ);
 		}
@@ -352,7 +384,6 @@ static int decomp_image(int comp, ulong load, ulong image_start, int type,
 		int ret;
 
 		printf("   Uncompressing %s ... ", type_name);
-
 		ret = lzop_decompress(image_buf, image_len, load_buf, &size);
 		if (ret != LZO_E_OK) {
 			printf("LZO: uncompress or overwrite error %d - must RESET board to recover\n",
@@ -389,6 +420,7 @@ static int bootm_load_os(bootm_headers_t *images, unsigned long *load_end,
 	int err;
 
 	load_buf = map_sysmem(load, 0);
+
 	image_buf = map_sysmem(os.image_start, image_len);
 	err = decomp_image(os.comp, load, os.image_start, os.type, load_buf,
 			   image_buf, image_len, load_end);
@@ -398,7 +430,7 @@ static int bootm_load_os(bootm_headers_t *images, unsigned long *load_end,
 	}
 	flush_cache(load, (*load_end - load) * sizeof(ulong));
 
-	debug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
+	printf("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
 	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);
 
 	no_overlap = (os.comp == IH_COMP_NONE && load == image_start);
@@ -408,7 +440,7 @@ static int bootm_load_os(bootm_headers_t *images, unsigned long *load_end,
 		      blob_start, blob_end);
 		debug("images.os.load = 0x%lx, load_end = 0x%lx\n", load,
 		      *load_end);
-
+#ifndef CONFIG_ANDROID_BOOT_IMAGE
 		/* Check what type of image this is. */
 		if (images->legacy_hdr_valid) {
 			if (image_get_type(&images->legacy_hdr_os_copy)
@@ -420,6 +452,7 @@ static int bootm_load_os(bootm_headers_t *images, unsigned long *load_end,
 			bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);
 			return BOOTM_ERR_RESET;
 		}
+#endif
 	}
 
 	return 0;
@@ -571,6 +604,7 @@ int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 		argc = 0;	/* consume the args */
 	}
 
+
 	/* Load the OS */
 	if (!ret && (states & BOOTM_STATE_LOADOS)) {
 		ulong load_end;
@@ -654,10 +688,10 @@ int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 	}
 
 	/* Now run the OS! We hope this doesn't return */
-	if (!ret && (states & BOOTM_STATE_OS_GO))
+	if (!ret && (states & BOOTM_STATE_OS_GO)) {
 		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,
 				images, boot_fn);
-
+		}
 	/* Deal with any fallout */
 err:
 	if (iflag)
@@ -827,6 +861,10 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 #ifdef CONFIG_ANDROID_BOOT_IMAGE
 	case IMAGE_FORMAT_ANDROID:
 		printf("## Booting Android Image at 0x%08lx ...\n", img_addr);
+		if (!android_image_need_move(&img_addr, buf))
+			buf = map_sysmem(img_addr, 0);
+		else
+			return NULL;
 		if (android_image_get_kernel(buf, images->verify,
 					     os_data, os_len))
 			return NULL;
diff --git a/common/cmd_aml_mmc.c b/common/cmd_aml_mmc.c
new file mode 100644
index 0000000..87c4998
--- /dev/null
+++ b/common/cmd_aml_mmc.c
@@ -0,0 +1,786 @@
+/*
+ * (C) Copyright 2003
+ * Kyle Harris, kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <command.h>
+#include <linux/ctype.h>
+#include <mmc.h>
+#include <partition_table.h>
+#include <emmc_partitions.h>
+
+extern int mmc_key_erase(void);
+extern int find_dev_num_by_partition_name (char *name);
+#define DTB_BLOCK_CNT		1024
+#define SZ_1M				0x100000
+#define DTB_ADDR_SIZE		(SZ_1M * 40)
+#define KEY_SIZE_CNT		()
+#define KEY_ADDR_SIZE		(SZ_1M * 40 + 16 * 1024)
+#define CONFIG_SECURITYKEY
+bool emmckey_is_protected (struct mmc *mmc)
+{
+#ifdef CONFIG_STORE_COMPATIBLE
+#ifdef CONFIG_SECURITYKEY
+	if (info_disprotect & DISPROTECT_KEY) { // disprotect
+		printf("emmckey_is_protected : disprotect\n ");
+		return 0;
+	}else{
+		printf("emmckey_is_protected : protect\n ");
+	// protect
+		return 1;
+	}
+#else
+		return 0;
+#endif
+#else
+#ifdef CONFIG_SECURITYKEY
+		//return mmc->key_protect;
+		return 0; /* fixme, */
+#else
+		return 0;
+#endif
+#endif
+}
+
+unsigned emmc_cur_partition = 0;
+
+static int get_off_size(struct mmc * mmc, char * name, uint64_t offset, uint64_t  size, u64 * blk, u64 * cnt, u64 * sz_byte)
+{
+        struct partitions *part_info = NULL;
+        uint64_t off = 0;
+        int blk_shift = 0;
+
+        blk_shift =  ffs(mmc->read_bl_len) - 1;
+        // printf("blk_shift:%d , off:0x%llx , size:0x%llx.\n ",blk_shift,off,size );
+        part_info = find_mmc_partition_by_name(name);
+        if (part_info == NULL) {
+                printf("get partition info failed !!\n");
+                return -1;
+        }
+        off = part_info->offset + offset;
+
+        // printf("part_info->offset:0x%llx , off:0x%llx , size:0x%llx.\n",part_info->offset ,off,size);
+
+        *blk = off >>  blk_shift ;
+        *cnt = size >>  blk_shift ;
+        *sz_byte = size - ((*cnt)<<blk_shift) ;
+
+        // printf("get_partition_off_size : blk:0x%llx , cnt:0x%llx.\n",*blk,*cnt);
+        return 0;
+}
+
+static int get_partition_size(unsigned char* name, uint64_t* addr)
+{
+        struct partitions *part_info = NULL;
+        part_info = find_mmc_partition_by_name((char *)name);
+        if (part_info == NULL) {
+                printf("get partition info failed !!\n");
+                return -1;
+        }
+
+        *addr = part_info->size >> 9; // unit: 512 bytes
+        return 0;
+}
+
+static inline int isstring(char *p)
+{
+        char *endptr = p;
+        while (*endptr != '\0') {
+                if (!(((*endptr >= '0') && (*endptr <= '9'))
+                                        || ((*endptr >= 'a') && (*endptr <= 'f'))
+                                        || ((*endptr >= 'A') && (*endptr <= 'F'))
+                                        || (*endptr == 'x') || (*endptr == 'X')))
+                        return 1;
+                endptr++;
+        }
+
+        return 0;
+}
+
+
+int do_amlmmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int rc = 0;
+        /*printf("%s:%d\n",__func__,__LINE__);*/
+        /*printf("argc = %d\n",argc);*/
+        switch (argc) {
+                case 3:
+                        if (strcmp(argv[1], "rescan") == 0) {
+                                int dev = simple_strtoul(argv[2], NULL, 10);
+                                if (dev < 0) {
+                                        printf("Cannot find dev.\n");
+                                        return 1;
+                                }
+                                struct mmc *mmc = find_mmc_device(dev);
+
+                                if (!mmc)
+                                        return 1;
+
+                                return mmc_init(mmc);
+                        } else if (strncmp(argv[1], "part", 4) == 0) {
+                                int dev = simple_strtoul(argv[2], NULL, 10);
+                                block_dev_desc_t *mmc_dev;
+                                struct mmc *mmc = find_mmc_device(dev);
+
+                                if (!mmc) {
+                                        puts("no mmc devices available\n");
+                                        return 1;
+                                }
+                                mmc_init(mmc);
+                                mmc_dev = mmc_get_dev(dev);
+                                if (mmc_dev != NULL &&
+                                                mmc_dev->type != DEV_TYPE_UNKNOWN) {
+                                        print_part(mmc_dev);
+                                        return 0;
+                                }
+
+                                puts("get mmc type error!\n");
+                                return 1;
+                        } else if (strcmp(argv[1], "erase") == 0) {
+                                char *name = NULL;
+                                int dev;
+                                u32 n=0;
+                                bool is_part = false;//is argv[2] partition name
+                                bool protect_cache = false;
+                                bool non_loader = false;
+                                int blk_shift;
+                                u64 cnt=0, blk =0,start_blk =0;
+                                struct partitions *part_info;
+
+                                if (isstring(argv[2])) {
+                                        if (!strcmp(argv[2], "whole")) {
+                                                name = "logo";
+                                                dev = find_dev_num_by_partition_name (name);
+                                        }else if(!strcmp(argv[2], "non_cache")){
+                                                name = "logo";
+                                                dev = find_dev_num_by_partition_name (name);
+                                                protect_cache = true;
+                                        }
+                                        else if(!strcmp(argv[2], "non_loader")){
+                                                dev = 1;
+                                                non_loader = true;
+                                        }
+                                        else{
+                                                name = argv[2];
+                                                dev = find_dev_num_by_partition_name (name);
+                                                is_part = true;
+                                        }
+                                }else if(isdigit(argv[2][0])){
+                                        dev = simple_strtoul(argv[2], NULL, 10);
+                                }else{
+                                        printf("Input is invalid, nothing happen.\n");
+                                        return 1;
+                                }
+
+                                if (dev < 0) {
+                                        printf("Cannot find dev.\n");
+                                        return 1;
+                                }
+                                struct mmc *mmc = find_mmc_device(dev);
+
+                                if (!mmc)
+                                        return 1;
+
+                                mmc_init(mmc);
+
+                                blk_shift = ffs(mmc->read_bl_len) -1;
+                                if (is_part) { // erase only one partition
+                                        if (emmckey_is_protected(mmc)
+                                                        && (strncmp(name, MMC_RESERVED_NAME, sizeof(MMC_RESERVED_NAME)) == 0x00)) {
+                                                printf("\"%s-partition\" is been protecting and should no be erased!\n", MMC_RESERVED_NAME);
+                                                return 1;
+                                        }
+
+                                        part_info = find_mmc_partition_by_name(name);
+                                        if (part_info == NULL) {
+                                                return 1;
+                                        }
+
+                                        blk = part_info->offset>> blk_shift;
+                                        if (emmc_cur_partition && !strncmp(name, "bootloader", strlen("bootloader"))) {
+
+                                                cnt = mmc->boot_size>> blk_shift;
+                                        }
+                                        else
+                                                cnt = part_info->size>> blk_shift;
+                                        n = mmc->block_dev.block_erase(dev, blk, cnt);
+                                } else { // erase the whole card if possible
+
+                                        if (non_loader) {
+                                                part_info = find_mmc_partition_by_name(MMC_BOOT_NAME);
+                                                if (part_info == NULL) {
+                                                        start_blk = 0;
+                                                        printf("no uboot partition for eMMC boot, just erase from 0\n");
+                                                }
+                                                else{
+                                                        start_blk = (part_info->offset + part_info->size) >> blk_shift;
+                                                }
+                                        }
+                                        else{
+                                                start_blk = 0;
+                                        }
+
+                                        if (emmckey_is_protected(mmc)) {
+                                                part_info = find_mmc_partition_by_name(MMC_RESERVED_NAME);
+                                                if (part_info == NULL) {
+                                                        return 1;
+                                                }
+
+                                                blk = part_info->offset;
+                                                if (blk > 0) { // it means: there should be other partitions before reserve-partition.
+                                                        blk -= PARTITION_RESERVED;
+                                                }
+                                                blk >>= blk_shift;
+
+                                                n=0;
+
+                                                // (1) erase all the area before reserve-partition
+                                                if (blk > 0) {
+                                                        n = mmc->block_dev.block_erase(dev, start_blk, blk);
+                                                        // printf("(1) erase blk: 0 --> %llx %s\n", blk, (n == 0) ? "OK" : "ERROR");
+                                                }
+                                                if (n == 0) { // not error
+                                                        // (2) erase all the area after reserve-partition
+                                                        if (protect_cache) {
+                                                                part_info = find_mmc_partition_by_name(MMC_CACHE_NAME);
+                                                                if (part_info == NULL) {
+                                                                        return 1;
+                                                                }
+                                                        }
+                                                        start_blk = (part_info->offset + part_info->size + PARTITION_RESERVED) >> blk_shift;
+                                                        u64 erase_cnt = (mmc->capacity >> blk_shift) - 1 - start_blk;
+                                                        n = mmc->block_dev.block_erase(dev, start_blk, erase_cnt);
+                                                        // printf("(2) erase blk: %#llx --> %#llx %s\n", start_blk, start_blk+erase_cnt, (n == 0) ? "OK" : "ERROR");
+                                                }
+
+                                        } else {
+                                                n = mmc->block_dev.block_erase(dev, start_blk, 0); // erase the whole card
+                                        }
+
+                                        //erase boot partition
+                                        if (mmc->boot_size && (n == 0) && (non_loader == false)) {
+
+                                                for (cnt=0;cnt<2;cnt++) {
+                                                        rc = mmc_switch_part(dev, cnt+1);
+                                                        if (rc != 0) {
+                                                                printf("mmc switch %s failed\n", (cnt == 0)?"boot0":"boot1");
+                                                                break;
+                                                        }
+
+                                                        n = mmc->block_dev.block_erase(dev, 0, mmc->boot_size>>blk_shift);
+                                                        if (n != 0) {
+                                                                printf("mmc erase %s failed\n", (cnt == 0)?"boot0":"boot1");
+                                                                break;
+                                                        }
+                                                }
+
+                                                rc = mmc_switch_part(dev, 0);
+                                                if (rc != 0) {
+                                                        printf("mmc switch back to user failed\n");
+                                                }
+                                        }
+                                }
+
+                                // printf("dev # %d, %s, # %#llx blocks erased %s\n",
+                                // dev, (is_part == 0) ? "card":(argv[2]) ,
+                                // (cnt == 0) ? (int)(mmc->block_dev.lba): cnt ,
+                                // (n == 0) ? "OK" : "ERROR");
+                                return (n == 0) ? 0 : 1;
+                        } else {
+                                return cmd_usage(cmdtp);
+                        }
+
+                case 0:
+                case 1:
+                case 4:
+                        if (strcmp(argv[1], "switch") == 0) {
+                                int dev = simple_strtoul(argv[2], NULL, 10);
+                                struct mmc* mmc = find_mmc_device(dev);
+                                if (!mmc) {
+                                        puts("no mmc devices available\n");
+                                        return 1;
+                                }
+                                mmc_init(mmc);
+                                printf("mmc switch to ");
+                                if (strcmp(argv[3], "boot0") == 0) {
+                                        rc = mmc_switch_part(dev, 1);
+                                        if (rc == 0) {
+                                                emmc_cur_partition = 1;
+                                                printf("boot0 success\n");
+                                        } else {
+                                                printf("boot0 failed\n");
+                                        }
+                                }
+                                else if(strcmp(argv[3], "boot1") == 0) {
+                                        rc = mmc_switch_part(dev, 2);
+                                        if (rc == 0) {
+                                                emmc_cur_partition = 2;
+                                                printf("boot1 success\n");
+                                        } else {
+                                                printf("boot1 failed\n");
+                                        }
+                                }
+                                else if(strcmp(argv[3], "user") == 0) {
+                                        rc = mmc_switch_part(dev, 0);
+                                        if (rc == 0) {
+                                                emmc_cur_partition = 0;
+                                                printf("user success\n");
+                                        } else {
+                                                printf("user failed\n");
+                                       }
+                                }
+#ifdef CONFIG_SUPPORT_EMMC_RPMB
+                                else if(strcmp(argv[3], "rpmb") == 0) {
+                                        rc = mmc_switch_part(dev, 3);
+                                        if (rc == 0) {
+                                                emmc_cur_partition = 3;
+                                                printf("rpmb success\n");
+                                        } else {
+                                                printf("rpmb failed\n");
+                                        }
+                                }
+#endif
+                                else
+                                        printf("%s failed\n", argv[3]);
+                                return rc;
+                        }
+
+                        if (strcmp(argv[1], "size") == 0) {
+                                char *name;
+                                uint64_t* addr =NULL;
+                                name = argv[2];
+                                addr = (uint64_t *)simple_strtoul(argv[3], NULL, 16);
+                                return get_partition_size((unsigned char *)name, addr);
+                        }
+
+                        return cmd_usage(cmdtp);
+
+                case 2:
+                        if (!strcmp(argv[1], "list")) {
+                                print_mmc_devices('\n');
+                                return 0;
+                        }
+
+                        if (strcmp(argv[1], "env") == 0) {
+                                printf("herh\n");
+                                env_relocate();
+                                return 0 ;
+                        }
+
+#ifdef CONFIG_SECURITYKEY
+                        if (strcmp(argv[1], "key") == 0) {
+                                struct mmc* mmc;
+                                char *name = "logo";
+                                int dev = find_dev_num_by_partition_name (name);
+                                mmc = find_mmc_device(dev);
+                                if (!mmc) {
+                                        printf("device %d is invalid\n",dev);
+                                        return 1;
+                                }
+                                //mmc->key_protect = 0;
+#ifdef CONFIG_STORE_COMPATIBLE
+                                info_disprotect |= DISPROTECT_KEY;  //disprotect
+                                printf("emmc disprotect key\n");
+#endif
+                                return 0;
+                        }
+#endif
+                        return cmd_usage(cmdtp);
+
+                default: /* at least 5 args */
+                        if (strcmp(argv[1], "read") == 0) {
+                                int dev;
+                                void *addr =NULL;
+                                u32 flag =0;
+                                u64 cnt =0,n =0, blk =0, sz_byte =0;
+                                char *name=NULL;
+                                u64 offset =0,size =0;
+
+                                if (argc != 6) {
+                                        printf("Input is invalid, nothing happen.\n");
+                                        return 1;
+                                }
+
+                                if (isstring(argv[2])) {
+                                        name = argv[2];
+                                        dev = find_dev_num_by_partition_name (name);
+                                        addr = (void *)simple_strtoul(argv[3], NULL, 16);
+                                        size = simple_strtoull(argv[5], NULL, 16);
+                                        offset  = simple_strtoull(argv[4], NULL, 16);
+                                        /*printf("offset %llx size %llx\n",offset,size);*/
+                                        flag = 1;
+                                        if ((strcmp(argv[2], "card") == 0)) {
+                                                flag = 2;
+                                        }
+                                }else{
+                                        dev = simple_strtoul(argv[2], NULL, 10);
+                                        addr = (void *)simple_strtoul(argv[3], NULL, 16);
+                                        cnt = simple_strtoull(argv[5], NULL, 16);
+                                        blk = simple_strtoull(argv[4], NULL, 16);
+                                }
+                                if (dev < 0) {
+                                        printf("Cannot find dev.\n");
+                                        return 1;
+                                }
+                                struct mmc *mmc = find_mmc_device(dev);
+                                if (!mmc) {
+                                        printf("dev = %d;, no mmc device found",dev);
+                                        return 1;
+                                }
+
+                                if (flag == 1) { // emmc or tsd
+                                        /*printf("offset %#llx size %#llx\n",offset,size);*/
+                                        get_off_size(mmc, name, offset, size, &blk, &cnt, &sz_byte);
+                                }
+                                else if(flag == 2){ // card
+                                        int blk_shift = ffs( mmc->read_bl_len) -1;
+                                        cnt = size >> blk_shift;
+                                        blk = offset >> blk_shift;
+                                        sz_byte = size - (cnt<<blk_shift);
+                                }
+
+
+                                /*printf("MMC read: dev # %d, block # %#llx, count # %#llx ...\n",*/
+                                                /*dev, blk, cnt);*/
+                                mmc_init(mmc);
+
+                                n = mmc->block_dev.block_read(dev, blk, cnt, addr);
+                                //read sz_byte bytes
+                                if ((n == cnt) && (sz_byte != 0)) {
+                                        /*printf("sz_byte=%#llx bytes\n",sz_byte);*/
+                                        void *addr_tmp = malloc(mmc->read_bl_len);
+                                        void *addr_byte = (void *)(addr+cnt*(mmc->read_bl_len));
+                                        ulong start_blk = blk+cnt;
+
+                                        if (addr_tmp == NULL) {
+                                                printf("mmc read: malloc fail\n");
+                                                return 1;
+                                        }
+
+                                        if (mmc->block_dev.block_read(dev, start_blk, 1, addr_tmp) != 1) { // read 1 block
+                                                free(addr_tmp);
+                                                printf("mmc read 1 block fail\n");
+                                                return 1;
+                                        }
+
+                                        memcpy(addr_byte, addr_tmp, sz_byte);
+                                        free(addr_tmp);
+                                }
+
+                                /* flush cache after read */
+                                //flush_cache((ulong)addr, cnt * 512); /* FIXME */
+
+                                if (n != cnt) {
+                                        printf("MMC read: dev # %d, block # %#llx, count # %#llx, byte_size # %#llx ERROR!\n",
+                                                        dev, blk, cnt, sz_byte);
+                                        printf("%#llx blocks read: %s\n",
+                                                        n, (n==cnt) ? "OK" : "ERROR");
+                                }
+                                return (n == cnt) ? 0 : 1;
+                        } else if (strcmp(argv[1], "write") == 0) {
+                                int dev;
+                                void *addr =NULL;
+                                u32 flag =0;
+                                u64 cnt =0,n =0, blk =0,sz_byte =0;
+                                char *name=NULL;
+                                u64 offset =0,size =0;
+
+                                if (argc != 6) {
+                                        printf("Input is invalid, nothing happen.\n");
+                                        return 1;
+                                }
+
+                                if (isstring(argv[2])) {
+                                        name = argv[2];
+                                        dev = find_dev_num_by_partition_name (name);
+                                        addr = (void *)simple_strtoul(argv[3], NULL, 16);
+                                        offset  = simple_strtoull(argv[4], NULL, 16);
+                                        size = simple_strtoull(argv[5], NULL, 16);
+                                        flag = 1;
+                                        if ((strcmp(argv[2], "card") == 0)) {
+                                                flag = 2;
+                                        }
+                                }else{
+                                        dev = simple_strtoul(argv[2], NULL, 10);
+                                        addr = (void *)simple_strtoul(argv[3], NULL, 16);
+                                        blk = simple_strtoull(argv[4], NULL, 16);
+                                        cnt = simple_strtoull(argv[5], NULL, 16);
+                                }
+                                if (dev < 0) {
+                                        printf("Cannot find dev.\n");
+                                        return 1;
+                                }
+                                struct mmc *mmc = find_mmc_device(dev);
+
+                                if (flag == 1) { // tsd or emmc
+                                        get_off_size(mmc, name, offset, size, &blk, &cnt, &sz_byte);
+                                }
+                                else if(flag == 2){ // card
+                                        int blk_shift = ffs( mmc->read_bl_len) -1;
+                                        cnt = size >> blk_shift;
+                                        blk = offset >> blk_shift;
+                                        sz_byte = size - (cnt<<blk_shift);
+                                }
+
+                                if (!mmc)
+                                        return 1;
+
+                                // printf("MMC write: dev # %d, block # %#llx, count # %#llx ... ",
+                                // dev, blk, cnt);
+
+                                mmc_init(mmc);
+
+                                n = mmc->block_dev.block_write(dev, blk, cnt, addr);
+
+                                //write sz_byte bytes
+                                if ((n == cnt) && (sz_byte != 0)) {
+                                        // printf("sz_byte=%#llx bytes\n",sz_byte);
+                                        void *addr_tmp = malloc(mmc->write_bl_len);
+                                        void *addr_byte = (void*)(addr+cnt*(mmc->write_bl_len));
+                                        ulong start_blk = blk+cnt;
+
+                                        if (addr_tmp == NULL) {
+                                                printf("mmc write: malloc fail\n");
+                                                return 1;
+                                        }
+
+                                        if (mmc->block_dev.block_read(dev, start_blk, 1, addr_tmp) != 1) { // read 1 block
+                                                free(addr_tmp);
+                                                printf("mmc read 1 block fail\n");
+                                                return 1;
+                                        }
+
+                                        memcpy(addr_tmp, addr_byte, sz_byte);
+                                        if (mmc->block_dev.block_write(dev, start_blk, 1, addr_tmp) != 1) { // write 1 block
+                                                free(addr_tmp);
+                                                printf("mmc write 1 block fail\n");
+                                                return 1;
+                                        }
+                                        free(addr_tmp);
+                                }
+
+                                if (cnt != n) {
+                                        printf("%#llx blocks , %#llx bytes written: ERROR\n", n, sz_byte);
+                                }
+                                return (n == cnt) ? 0 : 1;
+                        }
+                        else if (strcmp(argv[1], "erase") == 0) {
+
+                                int dev=0;
+                                u32 flag=0;
+                                u64 cnt = 0, blk = 0, n = 0, sz_byte =0;
+                                char *name=NULL;
+                                u64 offset_addr =0, size=0;
+
+                                if (argc != 5) {
+                                        printf("Input is invalid, nothing happen.\n");
+                                        return 1;
+                                }
+
+                                if (isstring(argv[2])) {
+                                        name = argv[2];
+                                        dev = find_dev_num_by_partition_name (name);
+                                        offset_addr = simple_strtoull(argv[3], NULL, 16);
+                                        size = simple_strtoull(argv[4], NULL, 16);
+                                        flag = 1;
+                                        if ((strcmp(argv[2], "card") == 0)) {
+                                                flag = 2;
+                                        }
+                                }else if(isdigit(argv[2][0])){
+                                        dev = simple_strtoul(argv[2], NULL, 10);
+                                        blk = simple_strtoull(argv[3], NULL, 16);
+                                        cnt = simple_strtoull(argv[4], NULL, 16);
+                                }
+
+                                if (dev < 0) {
+                                        printf("Cannot find dev.\n");
+                                        return 1;
+                                }
+
+                                struct mmc *mmc = find_mmc_device(dev);
+
+                                if (flag == 1) { // mmc write logo add offset size
+                                        struct partitions *part_info  = find_mmc_partition_by_name(name);
+
+                                        if (offset_addr >= part_info->size) {
+                                                printf("Start address out #%s# partition'address region,(addr_byte < 0x%llx)\n",
+                                                                name, part_info->size);
+                                                return 1;
+                                        }
+                                        if ((offset_addr+size) > part_info->size) {
+                                                printf("End address exceeds #%s# partition,(offset = 0x%llx,size = 0x%llx)\n",
+                                                                name, part_info->offset,part_info->size);
+                                                return 1;
+                                        }
+                                        get_off_size(mmc, name, offset_addr, size, &blk, &cnt, &sz_byte);
+                                }
+                                else if(flag == 2){
+                                        int tmp_shift = ffs( mmc->read_bl_len) -1;
+                                        cnt = size >> tmp_shift;
+                                        blk = offset_addr >> tmp_shift;
+                                        sz_byte = size - (cnt<<tmp_shift);
+                                }
+
+                                if (!mmc)
+                                        return 1;
+
+                                printf("MMC erase: dev # %d, start_erase_address(in block) # %#llx, several blocks  # %lld will be erased ...\n ",
+                                                dev, blk, cnt);
+
+                                mmc_init(mmc);
+
+                                if (cnt != 0)
+                                        n = mmc->block_dev.block_erase(dev, blk, cnt);
+
+                                printf("dev # %d, %s, several blocks erased %s\n",
+                                                dev, (flag == 0) ? " ":(argv[2]),(n == 0) ? "OK" : "ERROR");
+
+                                return (n == 0) ? 0 : 1;
+
+                        } else
+                                rc = cmd_usage(cmdtp);
+
+                        return rc;
+        }
+}
+
+U_BOOT_CMD(
+	amlmmc, 6, 1, do_amlmmcops,
+	"AMLMMC sub system",
+	"amlmmc read  <partition name> ram_addr addr_byte# cnt_byte\n"
+	"amlmmc write <partition name> ram_addr addr_byte# cnt_byte\n"
+	"amlmmc erase <partition name> addr_byte# cnt_byte\n"
+	"amlmmc erase <partition name>/<device num>\n"
+	"amlmmc rescan <device num>\n"
+	"amlmmc part <device num> - show partition infomation of mmc\n"
+	"amlmmc list - lists available devices\n"
+	"amlmmc switch <device num> <part name> - part name : boot0, boot1, user");
+
+int do_amlmmc_dtb_key(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+		int dev, ret = 0;
+		void *addr = NULL;
+		u64 cnt =0,n =0, blk =0;
+		//u64 size;
+
+	switch (argc) {
+		case 3:
+			if (strcmp(argv[1], "erase") == 0) {
+				if (strcmp(argv[2], "dtb") == 0) {
+					printf("start erase dtb......\n");
+					dev = 1;
+					struct mmc *mmc = find_mmc_device(dev);
+					if (!mmc) {
+						printf("not find mmc\n");
+						return 1;
+					}
+					blk = DTB_ADDR_SIZE / mmc->read_bl_len;
+					cnt = DTB_BLOCK_CNT;
+					if (cnt != 0)
+						n = mmc->block_dev.block_erase(dev, blk, cnt);
+					printf("dev # %d, %s, several blocks erased %s\n",
+							dev, (flag == 0) ? " ":(argv[2]),(n == 0) ? "OK" : "ERROR");
+					return (n == 0) ? 0 : 1;
+				}else if (strcmp(argv[2], "key") == 0){
+					printf("start erase key......\n");
+					dev = 1;
+					struct mmc *mmc = find_mmc_device(dev);
+					if (!mmc) {
+						printf("not find mmc\n");
+						return 1;
+					}
+					n = mmc_key_erase();
+					printf("dev # %d, %s, several blocks erased %s\n",
+							dev, (flag == 0) ? " ":(argv[2]),(n == 0) ? "OK" : "ERROR");
+					return (n == 0) ? 0 : 1;
+				}
+			}
+		case 4:
+			if (strcmp(argv[1], "dtb_read") == 0) {
+				printf("read emmc dtb\n");
+				dev = 1;
+				struct mmc *mmc = find_mmc_device(dev);
+				if (!mmc) {
+					printf("not find mmc\n");
+					return 1;
+				}
+				ret = mmc_init(mmc);
+				if (ret) {
+					printf("mmc init failed\n");
+					return 1;
+				}
+				addr = (void *)simple_strtoul(argv[2], NULL, 16);
+				//size = simple_strtoull(argv[3], NULL, 16);
+				blk = DTB_ADDR_SIZE / mmc->read_bl_len;
+				cnt = DTB_BLOCK_CNT;
+				n = mmc->block_dev.block_read(dev, blk, cnt, addr);
+				if (n != cnt)
+					printf("mmc dtb_read: dev # %d, block # %#llx, count # %#llx ERROR!\n",
+								dev, blk, cnt);
+				return (n == cnt) ? 0 : 1;
+			} else if (strcmp(argv[1], "dtb_write") == 0) {
+				printf("write emmc dtb\n");
+				dev = 1;
+				struct mmc *mmc = find_mmc_device(dev);
+				if (!mmc) {
+					printf("not find mmc\n");
+					return 1;
+				}
+				ret = mmc_init(mmc);
+				if (ret) {
+					printf("mmc init failed\n");
+					return 1;
+				}
+				addr = (void *)simple_strtoul(argv[2], NULL, 16);
+				//size = simple_strtoull(argv[3], NULL, 16);
+				blk = DTB_ADDR_SIZE / mmc->read_bl_len;
+				cnt = DTB_BLOCK_CNT;
+				n = mmc->block_dev.block_write(dev, blk, cnt, addr);
+				if (n != cnt) {
+					printf("mmc dtb_write: dev # %d, block # %#llx, count # %#llx ERROR!\n",
+								dev, blk, cnt);
+					return 1;
+				}
+				//return (n == cnt) ? 0 : 1;
+				ret = mmc_device_init(mmc);
+				if (ret == 0) {
+					printf(" partition table success\n");
+					return 0;
+				}
+				printf(" partition table error\n");
+				return 1;
+			}
+			return 0;
+		default:
+			break;
+	}
+	return 1;
+}
+
+U_BOOT_CMD(
+	emmc, 4, 1, do_amlmmc_dtb_key,
+	"EMMC sub system",
+	"emmc dtb_read addr size\n"
+	"emmc dtb_write addr size\n"
+	"emmc erase dtb\n"
+	"emmc erase key\n");
diff --git a/common/cmd_autoscript.c b/common/cmd_autoscript.c
new file mode 100644
index 0000000..fca060f
--- /dev/null
+++ b/common/cmd_autoscript.c
@@ -0,0 +1,233 @@
+/*
+ * (C) Copyright 2001
+ * Kyle Harris, kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * autoscript allows a remote host to download a command file and,
+ * optionally, binary data for automatically updating the target. For
+ * example, you create a new kernel image and want the user to be
+ * able to simply download the image and the machine does the rest.
+ * The kernel image is postprocessed with mkimage, which creates an
+ * image with a script file prepended. If enabled, autoscript will
+ * verify the script and contents of the download and execute the
+ * script portion. This would be responsible for erasing flash,
+ * copying the new image, and rebooting the machine.
+ */
+
+/* #define DEBUG */
+
+#include <common.h>
+#include <command.h>
+#include <image.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+#if defined(CONFIG_8xx)
+#include <mpc8xx.h>
+#endif
+#include <cli_hush.h>
+
+int
+autoscript (ulong addr, const char *fit_uname)
+{
+	ulong		len;
+	image_header_t	*hdr;
+	ulong		*data;
+	char		*cmd;
+	int		rcode = 0;
+	int		verify;
+#if defined(CONFIG_FIT)
+	const void*	fit_hdr;
+	int		noffset;
+	const void	*fit_data;
+	size_t		fit_len;
+#endif
+
+	verify = getenv_yesno ("verify");
+
+	switch (genimg_get_format ((void *)addr)) {
+	case IMAGE_FORMAT_LEGACY:
+		hdr = (image_header_t *)addr;
+
+		if (!image_check_magic (hdr)) {
+			puts ("Bad magic number\n");
+			return 1;
+		}
+
+		if (!image_check_hcrc (hdr)) {
+			puts ("Bad header crc\n");
+			return 1;
+		}
+
+		if (verify) {
+			if (!image_check_dcrc (hdr)) {
+				puts ("Bad data crc\n");
+				return 1;
+			}
+		}
+
+		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
+			puts ("Bad image type\n");
+			return 1;
+		}
+
+		/* get length of script */
+		ulong original_data = image_get_data(hdr);
+        ulong count = image_multi_count(hdr);
+		data = (ulong *)(original_data + (count + 1) * sizeof(uint32_t));
+		if ((len = uimage_to_cpu (*((ulong *)original_data))) == 0) {
+			puts ("Empty Script\n");
+			return 1;
+		}
+
+		break;
+#if defined(CONFIG_FIT)
+	case IMAGE_FORMAT_FIT:
+		if (fit_uname == NULL) {
+			puts ("No FIT subimage unit name\n");
+			return 1;
+		}
+
+		fit_hdr = (const void *)addr;
+		if (!fit_check_format (fit_hdr)) {
+			puts ("Bad FIT image format\n");
+			return 1;
+		}
+
+		/* get script component image node offset */
+		noffset = fit_image_get_node (fit_hdr, fit_uname);
+		if (noffset < 0) {
+			printf ("Can't find '%s' FIT subimage\n", fit_uname);
+			return 1;
+		}
+
+		if (!fit_image_check_type (fit_hdr, noffset, IH_TYPE_SCRIPT)) {
+			puts ("Not a image image\n");
+			return 1;
+		}
+
+		/* verify integrity */
+		if (verify) {
+			if (!fit_image_verify (fit_hdr, noffset)) {
+				puts ("Bad Data Hash\n");
+				return 1;
+			}
+		}
+
+		/* get script subimage data address and length */
+		if (fit_image_get_data (fit_hdr, noffset, &fit_data, &fit_len)) {
+			puts ("Could not find script subimage data\n");
+			return 1;
+		}
+
+		data = (ulong *)fit_data;
+		len = (ulong)fit_len;
+		break;
+#endif
+	default:
+		puts ("Wrong image format for autoscript\n");
+		return 1;
+	}
+
+	debug ("** Script length: %ld\n", len);
+
+	if ((cmd = malloc (len + 1)) == NULL) {
+		return 1;
+	}
+
+	/* make sure cmd is null terminated */
+	memmove (cmd, (char *)data, len);
+	*(cmd + len) = 0;
+
+//#ifdef CONFIG_SYS_HUSH_PARSER /*?? */
+//	rcode = parse_string_outer (cmd, FLAG_PARSE_SEMICOLON);
+//#else
+	{
+		char *line = cmd;
+		char *next = cmd;
+		printf("########## cmd=%s\n",cmd);
+		/*
+		 * break into individual lines,
+		 * and execute each line;
+		 * terminate on error.
+		 */
+		while (*next) {
+			if (*next == '\n') {
+				*next = '\0';
+				/* run only non-empty commands */
+				if (*line) {
+					debug ("** exec: \"%s\"\n",
+						line);
+					if (run_command (line, 0) < 0) {
+						rcode = 1;
+						break;
+					}
+				}
+				line = next + 1;
+			}
+			++next;
+		}
+		if (rcode == 0 && *line)
+			rcode = (run_command(line, 0) >= 0);
+	}
+//#endif
+	free (cmd);
+	return rcode;
+}
+
+/**************************************************/
+#if defined(CONFIG_CMD_AUTOSCRIPT)
+int do_autoscript (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong addr;
+	int rcode;
+	const char *fit_uname = NULL;
+
+	/* Find script image */
+	if (argc < 2) {
+		addr = CONFIG_SYS_LOAD_ADDR;
+		debug ("*  autoscr: default load address = 0x%08lx\n", addr);
+#if defined(CONFIG_FIT)
+	} else if (fit_parse_subimage (argv[1], load_addr, &addr, &fit_uname)) {
+		debug ("*  autoscr: subimage '%s' from FIT image at 0x%08lx\n",
+				fit_uname, addr);
+#endif
+	} else {
+		addr = simple_strtoul(argv[1], NULL, 16);
+		debug ("*  autoscr: cmdline image address = 0x%08lx\n", addr);
+	}
+
+	printf ("## Executing script at %08lx\n", addr);
+	rcode = autoscript (addr, fit_uname);
+	return rcode;
+}
+
+U_BOOT_CMD(
+	autoscr, 2, 0,	do_autoscript,
+	"run script from memory",
+	"[addr] - run script starting at addr"
+	" - A valid autoscr header must be present\n"
+#if defined(CONFIG_FIT)
+	"For FIT format uImage addr must include subimage\n"
+	"unit name in the form of addr:<subimg_uname>\n"
+#endif
+);
+#endif
diff --git a/common/cmd_bmp.c b/common/cmd_bmp.c
index cc904c2..6d340d1 100644
--- a/common/cmd_bmp.c
+++ b/common/cmd_bmp.c
@@ -18,7 +18,13 @@
 #include <splash.h>
 #include <video.h>
 
-static int bmp_info (ulong addr);
+static int bmp_info(ulong addr);
+#ifdef CONFIG_OSD_SCALE_ENABLE
+static int bmp_scale(void);
+#else
+static int bmp_scale(ulong src_addr, ulong dst_addr, unsigned int new_width,
+		     unsigned new_height);
+#endif
 
 /*
  * Allocate and decompress a BMP image using gunzip().
@@ -55,7 +61,9 @@ bmp_image_t *gunzip_bmp(unsigned long addr, unsigned long *lenp,
 	bmp = dst;
 
 	/* align to 32-bit-aligned-address + 2 */
-	bmp = (bmp_image_t *)((((unsigned int)dst + 1) & ~3) + 2);
+	/* adjust type to fix the warning
+	  "cast from pointer to interger of different size" on 64bit machine */
+	bmp = (bmp_image_t *)((((phys_addr_t)dst + 1) & ~3) + 2);
 
 	if (gunzip(bmp, CONFIG_SYS_VIDEO_LOGO_MAX_SIZE, (uchar *)addr, &len) != 0) {
 		free(dst);
@@ -63,7 +71,7 @@ bmp_image_t *gunzip_bmp(unsigned long addr, unsigned long *lenp,
 	}
 	if (len == CONFIG_SYS_VIDEO_LOGO_MAX_SIZE)
 		puts("Image could be truncated"
-				" (increase CONFIG_SYS_VIDEO_LOGO_MAX_SIZE)!\n");
+		     " (increase CONFIG_SYS_VIDEO_LOGO_MAX_SIZE)!\n");
 
 	/*
 	 * Check for bmp mark 'BM'
@@ -87,7 +95,7 @@ bmp_image_t *gunzip_bmp(unsigned long addr, unsigned long *lenp,
 }
 #endif
 
-static int do_bmp_info(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+static int do_bmp_info(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	ulong addr;
 
@@ -105,7 +113,8 @@ static int do_bmp_info(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[
 	return (bmp_info(addr));
 }
 
-static int do_bmp_display(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+static int do_bmp_display(cmd_tbl_t *cmdtp, int flag, int argc,
+			  char *const argv[])
 {
 	ulong addr;
 	int x = 0, y = 0;
@@ -118,6 +127,8 @@ static int do_bmp_display(cmd_tbl_t * cmdtp, int flag, int argc, char * const ar
 		break;
 	case 2:		/* use argument */
 		addr = simple_strtoul(argv[1], NULL, 16);
+		x = -1;
+		y = -1;
 		break;
 	case 4:
 		addr = simple_strtoul(argv[1], NULL, 16);
@@ -128,16 +139,44 @@ static int do_bmp_display(cmd_tbl_t * cmdtp, int flag, int argc, char * const ar
 		return CMD_RET_USAGE;
 	}
 
-	 return (bmp_display(addr, x, y));
+	return (bmp_display(addr, x, y));
+}
+
+static int do_bmp_scale(cmd_tbl_t *cmdtp, int flag, int argc,
+			char *const argv[])
+{
+#ifndef CONFIG_OSD_SCALE_ENABLE
+	ulong src_addr, dst_addr;
+	unsigned width, height;
+
+	switch (argc) {
+	case 3:
+		src_addr = simple_strtoul(argv[1], NULL, 16);
+		dst_addr = simple_strtoul(argv[2], NULL, 16);
+		width = simple_strtoul(getenv("display_width"), NULL, 0);
+		height = simple_strtoul(getenv("display_height"), NULL, 0);
+		printf("src_addr=0x%x,dst_addr=0x%x,w=%d,h=%d\n", (uint)src_addr,
+		       (uint)dst_addr, width, height);
+		break;
+	default:
+		return cmd_usage(cmdtp);
+		break;
+	}
+	return (bmp_scale(src_addr, dst_addr, width, height));
+#else
+	return (bmp_scale());
+#endif
 }
 
 static cmd_tbl_t cmd_bmp_sub[] = {
 	U_BOOT_CMD_MKENT(info, 3, 0, do_bmp_info, "", ""),
 	U_BOOT_CMD_MKENT(display, 5, 0, do_bmp_display, "", ""),
+	U_BOOT_CMD_MKENT(scale, 4, 0, do_bmp_scale, "", ""),
 };
 
 #ifdef CONFIG_NEEDS_MANUAL_RELOC
-void bmp_reloc(void) {
+void bmp_reloc(void)
+{
 	fixup_cmdtable(cmd_bmp_sub, ARRAY_SIZE(cmd_bmp_sub));
 }
 #endif
@@ -152,7 +191,7 @@ void bmp_reloc(void) {
  * Return:      None
  *
  */
-static int do_bmp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+static int do_bmp(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	cmd_tbl_t *c;
 
@@ -171,8 +210,9 @@ static int do_bmp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 U_BOOT_CMD(
 	bmp,	5,	1,	do_bmp,
 	"manipulate BMP image data",
-	"info <imageAddr>          - display image info\n"
-	"bmp display <imageAddr> [x y] - display image at x,y"
+	"info <imageAddr>              - display image info\n"
+	"bmp display <imageAddr> [x y]     - display image at x,y\n"
+	"bmp scale [imageAddr scaleAddr]   - scale image\n"
 );
 
 /*
@@ -187,12 +227,12 @@ U_BOOT_CMD(
  */
 static int bmp_info(ulong addr)
 {
-	bmp_image_t *bmp=(bmp_image_t *)addr;
+	bmp_image_t *bmp = (bmp_image_t *)addr;
 	void *bmp_alloc_addr = NULL;
 	unsigned long len;
 
-	if (!((bmp->header.signature[0]=='B') &&
-	      (bmp->header.signature[1]=='M')))
+	if (!((bmp->header.signature[0] == 'B') &&
+	      (bmp->header.signature[1] == 'M')))
 		bmp = gunzip_bmp(addr, &len, &bmp_alloc_addr);
 
 	if (bmp == NULL) {
@@ -208,7 +248,7 @@ static int bmp_info(ulong addr)
 	if (bmp_alloc_addr)
 		free(bmp_alloc_addr);
 
-	return(0);
+	return (0);
 }
 
 /*
@@ -228,8 +268,8 @@ int bmp_display(ulong addr, int x, int y)
 	void *bmp_alloc_addr = NULL;
 	unsigned long len;
 
-	if (!((bmp->header.signature[0]=='B') &&
-	      (bmp->header.signature[1]=='M')))
+	if (!((bmp->header.signature[0] == 'B') &&
+	      (bmp->header.signature[1] == 'M')))
 		bmp = gunzip_bmp(addr, &len, &bmp_alloc_addr);
 
 	if (!bmp) {
@@ -239,7 +279,7 @@ int bmp_display(ulong addr, int x, int y)
 
 #if defined(CONFIG_LCD)
 	ret = lcd_display_bitmap((ulong)bmp, x, y);
-#elif defined(CONFIG_VIDEO)
+#elif defined(CONFIG_VIDEO) || defined(CONFIG_AML_OSD)
 	ret = video_display_bitmap((unsigned long)bmp, x, y);
 #else
 # error bmp_display() requires CONFIG_LCD or CONFIG_VIDEO
@@ -250,3 +290,75 @@ int bmp_display(ulong addr, int x, int y)
 
 	return ret;
 }
+
+#ifdef CONFIG_OSD_SCALE_ENABLE
+static int bmp_scale(void)
+{
+	int ret = 0;
+
+	extern int video_scale_bitmap(void);
+	ret = video_scale_bitmap();
+
+	return ret;
+}
+#else
+static int bmp_scale(ulong src_addr, ulong dst_addr, unsigned int new_width,
+		     unsigned new_height)
+{
+	bmp_image_t *bmp = (bmp_image_t *)src_addr;
+	bmp_image_t *bmp_dst = (bmp_image_t *)dst_addr;
+	unsigned long len;
+	void *bmp_alloc_addr = NULL;
+	char *pBuf = (char *)bmp + bmp->header.data_offset;
+
+	printf("Begin bmp scale ...\n");
+	if (!((bmp->header.signature[0] == 'B') &&
+	      (bmp->header.signature[1] == 'M')))
+		bmp = gunzip_bmp(src_addr, &len, &bmp_alloc_addr);
+
+	if (!bmp) {
+		printf("There is no valid bmp file at the given address\n");
+		if (bmp_alloc_addr)
+			free(bmp_alloc_addr);
+
+		return 1;
+	}
+
+	memcpy(bmp_dst, bmp, sizeof(bmp_image_t));
+	bmp_dst->header.width = new_width;
+	bmp_dst->header.height = new_height;
+	char *pBuf_dst = (char *)bmp_dst + bmp_dst->header.data_offset;
+
+#if 1//Fast scale
+	int nWidth, nNewWidth, nNewHeight, nNewWidthBit;
+	float m_xscale, m_yscale;
+	int i, j, x, y, oldoffset;
+	char *pNewTmp = NULL;
+
+	m_xscale = (float)bmp_dst->header.width / (float)bmp->header.width;
+	m_yscale = (float)bmp_dst->header.height / (float)bmp->header.height;
+	nWidth = bmp->header.width;
+	//nHeight = bmp->header.height;
+	nNewHeight = bmp_dst->header.width;
+	nNewWidth =	bmp_dst->header.width;
+	nNewWidthBit = (4 - nNewWidth * 3 % 4) % 4 + nNewWidth * 3;
+
+	for (i = 0; i < nNewHeight; i++) {
+		pNewTmp = pBuf_dst + nNewWidthBit * i;
+		for (j = 0; j < nNewWidth * 3; j += 3) {
+			x = (int)(j / m_xscale);
+			y = (int)(i / m_yscale);
+			oldoffset = (y * nWidth * 3 + x) - (y * nWidth * 3 + x) %
+				    3; //correct positon in 3 byte mode
+			memcpy(pNewTmp + j, pBuf + oldoffset, 3);
+		}
+	}
+#endif
+	printf("End bmp scale \n");
+
+	if (bmp_alloc_addr)
+		free(bmp_alloc_addr);
+
+	return 0;
+}
+#endif
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 6723360..0abf7bc 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -22,6 +22,7 @@
 #include <linux/ctype.h>
 #include <linux/err.h>
 #include <u-boot/zlib.h>
+#include <asm/arch/bl31_apis.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -108,6 +109,9 @@ int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	}
 #endif
 
+	extern void ee_gate_off(void);
+	extern void ee_gate_on(void);
+
 	/* determine if we have a sub command */
 	argc--; argv++;
 	if (argc > 0) {
@@ -126,7 +130,24 @@ int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			return do_bootm_subcommand(cmdtp, flag, argc, argv);
 	}
 
-	return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |
+	unsigned int nLoadAddr = GXB_IMG_LOAD_ADDR; //default load address
+
+	if (argc > 0)
+	{
+		char *endp;
+		nLoadAddr = simple_strtoul(argv[0], &endp, 16);
+		//printf("aml log : addr = 0x%x\n",nLoadAddr);
+	}
+
+	int nRet = aml_sec_boot_check(AML_D_P_IMG_DECRYPT,nLoadAddr,GXB_IMG_SIZE,GXB_IMG_DEC_ALL);
+	if (nRet)
+	{
+		printf("\naml log : Sig Check %d\n",nRet);
+		return nRet;
+	}
+
+	ee_gate_off();
+	nRet = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |
 		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
 		BOOTM_STATE_LOADOS |
 #if defined(CONFIG_PPC) || defined(CONFIG_MIPS)
@@ -134,6 +155,8 @@ int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 #endif
 		BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
 		BOOTM_STATE_OS_GO, &images, 1);
+	ee_gate_on();
+	return nRet;//should be here.
 }
 
 int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
diff --git a/common/cmd_burnup.c b/common/cmd_burnup.c
new file mode 100644
index 0000000..dbf0ae6
--- /dev/null
+++ b/common/cmd_burnup.c
@@ -0,0 +1,369 @@
+#include <command.h>
+#include <watchdog.h>
+#include <malloc.h>
+#include <common.h>
+#include <linux/ctype.h>
+#include <asm/byteorder.h>
+#include <div64.h>
+#include <linux/err.h>
+#include <partition_table.h>
+
+unsigned char *cmd_name = (unsigned char *)("store");
+
+/***
+upgrade_read_ops:
+
+partition_name: env / logo / recovery /boot / system /cache /media
+
+ ***/
+
+int store_read_ops(unsigned char *partition_name,unsigned char * buf, uint64_t off, uint64_t size)
+{
+        unsigned char *name;
+        uint64_t addr;
+        char	str[128];
+        int ret =0;
+
+        if (!buf) {
+                store_msg("upgrade: no buf!!");
+                return -1;
+        }
+
+        name = partition_name;
+        addr = (unsigned long)buf;
+
+        sprintf(str, "%s  read %s 0x%llx  0x%llx  0x%llx",cmd_name, name, addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+                store_msg("cmd %s failed ",cmd_name);
+                return -1;
+        }
+
+        return 0;
+}
+
+/***
+upgrade_write_ops:
+
+partition_name: env / logo / recovery /boot / system /cache /media
+
+ ***/
+
+int store_write_ops(unsigned char *partition_name,unsigned char * buf, uint64_t off, uint64_t size)
+{
+        unsigned char *name;
+        uint64_t addr;
+        char	str[128];
+        int ret =0;
+
+        if (!buf) {
+                store_msg("upgrade: no buf!!");
+                return -1;
+        }
+
+        name = partition_name;
+        addr = (unsigned long)buf;
+
+        sprintf(str, "%s  write %s 0x%llx  0x%llx  0x%llx",cmd_name, name, addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+                store_msg("cmd %s failed ",cmd_name);
+                return -1;
+        }
+
+        return 0;
+}
+
+
+/***
+upgrade_write_ops:
+
+partition_name: env / logo / recovery /boot / system /cache /media
+
+ ***/
+
+int store_get_partititon_size(unsigned char *partition_name, uint64_t *size)
+{
+        unsigned char *name;
+        char	str[128];
+        uint64_t addr;
+        int ret=0;
+        unsigned char * buf = malloc(4*sizeof(uint64_t));
+
+        if (!buf) {
+                store_msg("store_get_partititon_size : malloc failed");
+                return -1;
+        }
+        memset(buf,0x0,4*sizeof(uint64_t));
+        store_dbg("4*sizeof(uint64_t) =%ld",4*sizeof(uint64_t));
+        addr = (unsigned long)size;
+        name = partition_name;
+        sprintf(str, "%s  size %s 0x%llx ",cmd_name, name, addr);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+                store_msg("cmd %s size failed ",cmd_name);
+                return -1;
+        }
+
+
+
+        if (buf) {
+                kfree(buf);
+        }
+        return 0;
+}
+
+
+/***
+upgrade_erase_ops:
+
+partition_name: boot / data
+
+flag = 0; indicate erase partition ;
+flag = 1; indicate scurb whole nand;
+
+ ***/
+int store_erase_ops(unsigned char *par_name, uint64_t off, uint64_t size, unsigned char flag)
+{
+        unsigned char *name;
+        char	str[128];
+        int ret=0;
+
+        name = par_name;
+        if (flag == 0) {
+                sprintf(str, "%s  erase %s 0x%llx  0x%llx",cmd_name, name, off, size);
+                store_dbg("command:	%s", str);
+                ret = run_command(str, 0);
+                if (ret != 0) {
+                        store_msg("cmd %s erase failed",cmd_name);
+                        return -1;
+                }
+
+        }else if(flag == 1){
+
+                sprintf(str, "%s  rom_protect off ",cmd_name);
+                store_dbg("command:	%s", str);
+                ret = run_command(str, 0);
+                if (ret != 0) {
+                        store_msg("cmd %s scrub failed ",cmd_name);
+                        return -1;
+                }
+
+                sprintf(str, "%s  scrub  0x%llx ",cmd_name, (long long unsigned int)0);
+                store_dbg("command:	%s", str);
+                ret = run_command(str, 0);
+                if (ret != 0) {
+                        store_msg("cmd %s scrub failed",cmd_name);
+                        return -1;
+                }
+        }
+
+        return 0;
+}
+
+/***
+bootloader:
+ ***/
+int store_boot_read(unsigned char * buf, uint64_t off, uint64_t size)
+{
+        //unsigned char *name;
+        uint64_t addr;
+        char	str[128];
+        int ret =0;
+
+        if (!buf) {
+                store_msg("upgrade: no buf!!");
+                return -1;
+        }
+
+        addr = (unsigned long)buf;
+        store_dbg("store_boot_read: addr 0x%llx\n",addr);
+
+        sprintf(str, "%s  rom_read 0x%llx  0x%llx  0x%llx",cmd_name, addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+                store_msg("cmd %s  rom_read failed",cmd_name);
+                return -1;
+        }
+
+        return 0;
+
+}
+
+int store_boot_write(unsigned char * buf,uint64_t off, uint64_t size)
+{
+        //unsigned char *name;
+        uint64_t addr;
+        char	str[128];
+        int ret =0;
+
+        if (!buf) {
+                store_msg("upgrade: no buf!!");
+                return -1;
+        }
+
+        addr = (unsigned long)buf;
+
+        sprintf(str, "%s  rom_write 0x%llx  0x%llx  0x%llx",cmd_name, addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+                store_msg("cmd %s rom_write failed",cmd_name);
+                return -1;
+        }
+
+        return 0;
+
+}
+
+
+int store_init(unsigned  flag)
+{
+        //unsigned char *name;
+        //unsigned long addr;
+        char	str[128];
+        int ret =0;
+        store_dbg("flag : %d",flag);
+
+        sprintf(str, "%s  init %d",cmd_name,flag);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+                store_msg("cmd [%s] init failed ",cmd_name);
+                return -1;
+        }
+
+        return 0;
+}
+
+int store_exit(void)
+{
+        //unsigned char *name;
+        //unsigned long addr;
+        char	str[128];
+        int ret =0;
+
+        sprintf(str, "%s  exit",cmd_name);
+        printf("command:	%s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+                store_msg("cmd %s exit failed",cmd_name);
+                return -1;
+        }
+
+        return 0;
+
+}
+
+//store dtb read/write buf sz
+int store_dtb_rw(void* buf, unsigned dtbSz, int isWrite)
+{
+    char _cmdBuf[128];
+    char* ops = isWrite ? "write" : "read";
+
+    sprintf(_cmdBuf, "store dtb %s 0x%p 0x%x", ops, buf, dtbSz);
+    return run_command(_cmdBuf, 0);
+}
+
+#if 0
+int do_store_test(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+        int i, init_flag=0,dev, ret = 0;
+        ulong addr;
+        uint64_t off, size;
+        char *cmd, *s, *area;
+        char	str[128];
+        unsigned char *buf;
+
+        cmd = argv[1];
+
+        buf = malloc(0x400000);
+        if (!buf) {
+                printf("do_store_test : malloc failed\n");
+                return -1;
+        }
+
+        area ="logo";
+
+        if (strcmp(cmd, "read") == 0) {
+                ret = store_read_ops(area,buf,0x0,0x40000);
+                if (ret < 0) {
+                        printf("store read failed\n");
+                        return -1;
+                }
+                printf("store read OK\n");
+        }
+
+        if (strcmp(cmd, "boot_read") == 0) {
+                ret = store_boot_read(buf,0x0,0x60000);
+                if (ret < 0) {
+                        printf("store boot_read failed\n");
+                        return -1;
+                }
+                printf("store boot_read OK\n");
+        }
+
+        if (strcmp(cmd, "init") == 0) {
+                ret = store_init(0x0);
+                if (ret < 0) {
+                        printf("store init failed\n");
+                        return -1;
+                }
+                printf("store init OK\n");
+        }
+
+        if (strcmp(cmd, "write") == 0) {
+                memset(buf,0xa5,0x400000);
+                ret = store_write_ops(area,buf,0x0,0x40000);
+                if (ret < 0) {
+                        printf("store write failed\n");
+                        return -1;
+                }
+                printf("store write OK\n");
+        }
+
+        if (strcmp(cmd, "erase") == 0) {
+                area = "data";
+                ret = store_erase_ops(area,0x0,0,0);
+                if (ret < 0) {
+                        printf("store write failed\n");
+                        return -1;
+                }
+        }
+
+        if (strcmp(cmd, "size") == 0) {
+                uint64_t off=0, size;
+
+                ret = store_get_partititon_size(area,&size);
+                if (ret < 0) {
+                        printf("store write failed\n");
+                        return -1;
+                }
+                printf("off =%llx size=%llx\n",off,size);
+        }
+
+        if (buf)
+                kfree(buf);
+        return 0;
+
+}
+
+U_BOOT_CMD(store_test, CONFIG_SYS_MAXARGS, 1, do_store_test,
+                "NAND sub-system",
+                "store read name addr off|partition size\n"
+                "    read 'size' bytes starting at offset 'off'\n"
+                "    to/from memory address 'addr', skipping bad blocks.\n"
+                "store write name addr off|partition size\n"
+                "    write 'size' bytes starting at offset 'off'\n"
+                "    to/from memory address 'addr', skipping bad blocks.\n"
+                "store erase boot/data: \n"
+                "erase the area which is uboot or datas \n"
+                "store scrub off|partition size\n"
+                "scrub the area from offset and size \n"
+          );
+#endif
+
diff --git a/common/cmd_cfgload.c b/common/cmd_cfgload.c
new file mode 100644
index 0000000..6774e37
--- /dev/null
+++ b/common/cmd_cfgload.c
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/errno.h>
+#include <malloc.h>
+#include <linux/ctype.h>    /* isalpha, isdigit */
+#include <linux/sizes.h>
+
+#ifdef CONFIG_SYS_HUSH_PARSER
+#include <cli_hush.h>
+#endif
+
+#define BOOTINI_MAGIC	"ODROIDC2-UBOOT-CONFIG"
+#define SZ_BOOTINI		SZ_64K
+
+/* Nothing to proceed with zero size string or comment.
+ *
+ * FIXME: Do we really need to strip the line start with '#' or ';',
+ *        since any U-boot command does not start with punctuation character.
+ */
+static int valid_command(const char* p)
+{
+	char *q;
+
+	for (q = (char*)p; *q; q++) {
+		if (isblank(*q)) continue;
+		if (isalnum(*q)) return 1;
+		if (ispunct(*q))
+			return (*q != '#') && (*q != ';');
+	}
+
+	return !(p == q);
+}
+
+/* Read boot.ini from FAT partition
+ */
+static char* read_cfgload(void)
+{
+	char cmd[128];
+	unsigned long filesize;
+	char *p;
+
+	p = (char *)simple_strtoul(getenv("loadaddr"), NULL, 16);
+	if (NULL == p)
+		p = (char *)CONFIG_SYS_LOAD_ADDR;
+
+	setenv("filesize", "0");
+
+	sprintf(cmd, "fatload mmc 0:1 0x%p boot.ini", (void *)p);
+	run_command(cmd, 0);
+
+	filesize = getenv_ulong("filesize", 16, 0);
+	if (0 == filesize) {
+		printf("cfgload: no boot.ini or empty file\n");
+		return NULL;
+	}
+
+	if (filesize > SZ_BOOTINI) {
+		printf("boot.ini: 'boot.ini' exceeds %d, size=%ld\n",
+				SZ_BOOTINI, filesize);
+		return NULL;
+    }
+
+	/* Terminate the read buffer with '\0' to be treated as string */
+	*(char *)(p + filesize) = '\0';
+
+	/* Scan MAGIC string, readed boot.ini must start with exact magic string.
+	 * Otherwise, we will not proceed at all.
+	 */
+	while (*p) {
+		char *s = strsep(&p, "\n");
+		if (!valid_command(s))
+			continue;
+
+		/* MAGIC string is discovered, return the buffer address of next to
+		 * proceed the commands.
+		 */
+		if (!strncmp(s, BOOTINI_MAGIC, sizeof(BOOTINI_MAGIC)))
+			return memcpy(malloc(filesize), p, filesize);
+	}
+
+	printf("cfgload: MAGIC NAME, %s, is not found!!\n", BOOTINI_MAGIC);
+
+	return NULL;
+}
+
+static int do_load_cfgload(cmd_tbl_t *cmdtp, int flag, int argc,
+		char *const argv[])
+{
+	char *p;
+	char *cmd;
+
+	p = read_cfgload();
+	if (NULL == p)
+		return 0;
+
+	printf("cfgload: applying boot.ini...\n");
+
+	while (p) {
+		cmd = strsep(&p, "\n");
+		if (!valid_command(cmd))
+			continue;
+
+		printf("cfgload: %s\n", cmd);
+
+#ifndef CONFIG_SYS_HUSH_PARSER
+		run_command(cmd, 0);
+#else
+		parse_string_outer(cmd, FLAG_PARSE_SEMICOLON
+				| FLAG_EXIT_FROM_LOOP);
+#endif
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+		cfgload,		1,		0,		do_load_cfgload,
+		"read 'boot.ini' from FAT partiton",
+		"\n"
+		"    - read boot.ini from the first partiton treated as FAT partiton"
+);
+
+/* vim: set ts=4 sw=4 tw=80: */
diff --git a/common/cmd_cpu_temp.c b/common/cmd_cpu_temp.c
new file mode 100644
index 0000000..bffa465
--- /dev/null
+++ b/common/cmd_cpu_temp.c
@@ -0,0 +1,344 @@
+
+/*
+ * common/cmd_cpu_temp.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/efuse.h>
+#include <command.h>
+#include <asm/arch/secure_apb.h>
+#include <asm/arch/mailbox.h>
+int temp_base = 27;
+#define NUM 30
+
+int get_tsc(int temp)
+{
+	int vmeasure, TS_C;
+	vmeasure = temp-(435+(temp_base-27)*3.4);
+	printf("vmeasure=%d\n", vmeasure);
+	TS_C = ((vmeasure)/8.25)+16;
+
+	if (TS_C > 31)
+		TS_C = 31;
+	else if (TS_C < 0)
+		TS_C = 0;
+	printf("TS_C=%d\n", TS_C);
+	return TS_C;
+}
+
+int adc_init_chan6(void)
+{
+	/*adc reg3 bit28: config adc registers flag*/
+	if (readl(0xc110868c)&(0x1<<28))
+		return 0;
+	writel(0x003c2000, 0xc11086ac);
+	writel(0x00000006, 0xc1108684);
+	writel(0x00003000, 0xc1108688);
+	writel(0xc3a8500a, 0xc110868c);
+	writel(0x010a000a, 0xc1108690);
+	writel(0x03eb1a0c, 0xc110869c);
+	writel(0x008c000c, 0xc11086a0);
+	writel(0x030e030c, 0xc11086a4);
+	writel(0x0c00c400, 0xc11086a8);
+	writel(0x00000114, 0xc883c3d8);        /* Clock */
+	writel(readl(0xc110868c)|(0x1<<28), 0xc110868c);
+	return 0;
+}
+
+int get_adc_sample(int chan)
+{
+	unsigned value;
+
+	/*adc reg3 bit29: read adc sample value flag*/
+	while (readl(0xc110868c)&(1<<29))
+		udelay(10000);
+	writel(readl(0xc110868c)|(1 < 29), 0xc110868c);
+
+	writel(0x84064040, 0xc1108680);
+	writel(0x84064041, 0xc1108680);
+	writel(0x84064045, 0xc1108680);
+
+	value = readl(0xc1108698);
+	writel(readl(0xc110868c)&(~(1 < 29)), 0xc110868c);
+	value = value&0x3ff;
+
+	return value;
+}
+unsigned int get_cpu_temp(int tsc, int flag)
+{
+	unsigned value;
+	if (flag) {
+		value = readl(0xc11086ac);
+	  writel(((value&(~(0x1f<<14)))|((tsc&0x1f)<<14)), 0xc11086ac);
+	  /* bit[14-18]:tsc */
+	} else{
+		value = readl(0xc11086ac);
+	  writel(((value&(~(0x1f<<14)))|(0x10<<14)), 0xc11086ac);
+	  /* bit[14-18]:0x16 */
+	}
+	return  get_adc_sample(6);
+}
+
+void quicksort(int a[], int numsize)
+{
+	int i = 0, j = numsize-1;
+	int val = a[0];
+	if (numsize > 1) {
+		while (i < j) {
+			for (; j > i; j--)
+				if (a[j] < val) {
+					a[i] = a[j];
+					break;
+				}
+			for (; i < j; i++)
+				if (a[i] > val) {
+					a[j] = a[i];
+					break;
+				}
+		}
+	a[i] = val;
+	quicksort(a, i);
+	quicksort(a+i+1, numsize-1-i);
+}
+}
+
+int do_read_calib_data(int *flag, int *temp, int *TS_C)
+{
+	char buf[2];
+	unsigned ret;
+	*flag = 0;
+	buf[0] = 0; buf[1] = 0;
+
+	char flagbuf;
+
+	ret = readl(AO_SEC_SD_CFG12);
+	flagbuf = (ret>>24)&0xff;
+	if (((int)flagbuf != 0xA0) && ((int)flagbuf != 0x40)
+		&& ((int)flagbuf != 0xC0)) {
+		printf("thermal ver flag error!\n");
+		printf("flagbuf is 0x%x!\n", flagbuf);
+		return -1;
+	}
+
+	buf[0] = (ret)&0xff;
+	buf[1] = (ret>>8)&0xff;
+
+	*temp = buf[1];
+	*temp = (*temp<<8)|buf[0];
+	*TS_C =  *temp&0x1f;
+	*flag = (*temp&0x8000)>>15;
+	*temp = (*temp&0x7fff)>>5;
+
+	if (0x40 == (int)flagbuf)/*ver2*/
+		*TS_C = 16;
+	printf("adc=%d,TS_C=%d,flag=%d\n", *temp, *TS_C, *flag);
+	return ret;
+}
+
+static int do_write_trim(cmd_tbl_t *cmdtp, int flag1,
+	int argc, char * const argv[])
+{
+	int temp = 0;
+	int temp1[NUM];
+	char buf[2];
+	unsigned int data;
+	int i, TS_C;
+	int ret;
+	int flag;
+
+	memset(temp1, 0, NUM);
+
+	adc_init_chan6();
+
+	ret = do_read_calib_data(&flag, &temp, &TS_C);
+	if (ret > 0) {
+		printf("chip has trimed!!!\n");
+		return 0;
+	} else {
+		printf("chip is not triming! triming now......\n");
+		flag = 0;
+		temp = 0;
+		TS_C = 0;
+	}
+	for (i = 0; i < NUM; i++) {
+		udelay(10000);
+
+		temp1[i] = get_cpu_temp(16, 0);
+	}
+
+	printf("raw data\n");
+	for (i = 0; i < NUM; i++)
+		printf("%d ", temp1[i]);
+
+	printf("\nsort  data\n");
+
+	quicksort(temp1, NUM);
+	for (i = 0; i < NUM; i++)
+		printf("%d ", temp1[i]);
+	printf("\n");
+	for (i = 2; i < NUM-2; i++)
+		temp += temp1[i];
+	temp = temp/(NUM-4);
+	printf("the adc cpu adc=%d\n", temp);
+
+/**********************************/
+	TS_C = get_tsc(temp);
+/**********************************/
+	temp = 0;
+	memset(temp1, 0, NUM);
+	/* flag=1; */
+	for (i = 0; i < NUM; i++) {
+		udelay(10000);
+		temp1[i] = get_cpu_temp(TS_C, 1);
+	}
+	printf("use triming  data\n");
+	quicksort(temp1, NUM);
+	for (i = 0; i < NUM; i++)
+		printf("%d ", temp1[i]);
+	printf("\n");
+	for (i = 2; i < NUM-2; i++)
+		temp += temp1[i];
+	temp = temp/(NUM-4);
+
+/**************recalculate to 27******/
+	temp = temp - 3.4*(temp_base - 27);
+/**********************************/
+	temp = ((temp<<5)|(TS_C&0x1f))&0xffff;
+/* write efuse tsc,flag */
+	buf[0] = (char)(temp&0xff);
+	buf[1] = (char)((temp>>8)&0xff);
+	buf[1] |= 0x80;
+	printf("buf[0]=%x,buf[1]=%x\n", buf[0], buf[1]);
+	data = buf[1]<<8 | buf[0];
+	ret = thermal_calibration(0, data);
+	return ret;
+}
+static int do_read_temp(cmd_tbl_t *cmdtp, int flag1,
+	int argc, char * const argv[])
+{
+	int temp;
+	int TS_C;
+	int flag, adc, count, tempa;
+	unsigned ret;
+	flag = 0;
+	char buf[100] = {};
+
+	setenv("tempa", " ");
+	adc_init_chan6();
+	ret = do_read_calib_data(&flag, &temp, &TS_C);
+	if (ret > 0) {
+		adc = 0;
+		count = 0;
+		while (count < 64) {
+			adc += get_cpu_temp(TS_C, flag);
+			count++;
+			udelay(200);
+		}
+		adc /= count;
+		tempa = 0;
+		printf("adc=%d\n", adc);
+		if (flag) {
+			tempa = (10*(adc-temp))/34+27;
+			printf("tempa=%d\n", tempa);
+
+			sprintf(buf, "%d", tempa);
+			setenv("tempa", buf);
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "temp:%d, adc:%d, tsc:%d, dout:%d", tempa, adc, TS_C, temp);
+			setenv("err_info_tempa", buf);
+		} else {
+			printf("This chip is not trimmed\n");
+			sprintf(buf, "%s", "This chip is not trimmed");
+			setenv("err_info_tempa", buf);
+			return -1;
+		}
+	} else {
+		printf("read calibrated data failed\n");
+		sprintf(buf, "%s", "read calibrated data failed");
+		setenv("err_info_tempa", buf);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int do_write_version(cmd_tbl_t *cmdtp, int flag1,
+	int argc, char * const argv[])
+{
+	int ret;
+	unsigned int val = simple_strtoul(argv[1], NULL, 16);
+
+	ret = thermal_calibration(1, val);
+	return ret;
+}
+
+static int do_set_trim_base(cmd_tbl_t *cmdtp, int flag1,
+	int argc, char * const argv[])
+{
+	int temp = simple_strtoul(argv[1], NULL, 10);
+	temp_base = temp;
+	printf("set base temperature: %d\n", temp_base);
+	return 0;
+}
+
+static int do_temp_triming(cmd_tbl_t *cmdtp, int flag1,
+	int argc, char * const argv[])
+{
+	int temp = simple_strtoul(argv[1], NULL, 10);
+	temp_base = temp;
+	printf("set base temperature: %d\n", temp_base);
+	run_command("write_trim", 0);
+	/*FB calibration v5: 1010 0000*/
+	/*manual calibration v2: 0100 0000*/
+	printf("manual calibration v3: 1100 0000\n");
+	run_command("write_version 0xc0", 0);
+	run_command("read_temp", 0);
+	return 0;
+}
+
+U_BOOT_CMD(
+	write_trim,	5,	0,	do_write_trim,
+	"cpu temp-system",
+	"write_trim data"
+);
+
+U_BOOT_CMD(
+	read_temp,	5,	0,	do_read_temp,
+	"cpu temp-system",
+	"read_temp pos"
+);
+
+U_BOOT_CMD(
+	write_version,	5,	0,	do_write_version,
+	"cpu temp-system",
+	"write_flag"
+);
+
+U_BOOT_CMD(
+	temp_triming,	5,	1,	do_temp_triming,
+	"cpu temp-system",
+	"write_trim 502 and write flag"
+);
+
+U_BOOT_CMD(
+	set_trim_base,	5,	1,	do_set_trim_base,
+	"cpu temp-system",
+	"set triming base temp"
+);
diff --git a/common/cmd_cvbs.c b/common/cmd_cvbs.c
new file mode 100644
index 0000000..b7af0aa
--- /dev/null
+++ b/common/cmd_cvbs.c
@@ -0,0 +1,115 @@
+/*
+ * (C) Copyright 2012
+ * Amlogic. Inc. jets.yan@amlogic.com
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+#include <amlogic/cvbs.h>
+
+static int do_cvbs_debug(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	if ((argc != 2) && (argc != 4) && (argc != 5)) {
+		printf("cvbs debug command format as:\n"
+		"    r h/v address\n"
+		"    w value h/v address\n"
+		"    dump h/v addr_start addr_end\n"
+		"    enci\n"
+		"    clock\n");
+		return CMD_RET_FAILURE;
+	}
+
+	cvbs_reg_debug(argc, argv);
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_cvbs_output(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	if (argc < 1)
+		return cmd_usage(cmdtp);
+
+	if ((argc != 2) && (argc != 3)) {
+		printf("cvbs output mode can be:\n"
+			"    576cvbs\n"
+			"    480cvbs\n"
+			"    bist [off|1 or colorbar|2 or thinline|3 or dotgrid|0 or fixval]\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (strcmp(argv[1], "list") == 0) {
+		cvbs_show_valid_vmode();
+	} else if (strcmp(argv[1], "bist") == 0) {
+		if (argc != 3)
+			printf("bist mode can be: [off|1 or colorbar|2 or thinline|3 or dotgrid|0 or fixval]\n");
+		else
+			cvbs_set_bist(argv[2]);
+	} else { /* "output" */
+			cvbs_set_vmode(argv[1]);
+	}
+	return CMD_RET_SUCCESS;
+}
+
+static int do_vdac(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	cvbs_set_vdac(simple_strtoul(argv[1], NULL, 16));
+	return 1;
+}
+
+static cmd_tbl_t cmd_cvbs_sub[] = {
+	U_BOOT_CMD_MKENT(debug, 1, 1, do_cvbs_debug, "", ""),
+	U_BOOT_CMD_MKENT(output, 3, 1, do_cvbs_output, "", ""),
+	U_BOOT_CMD_MKENT(vdac, 1, 1, do_vdac, "", ""),
+};
+
+static int do_cvbs(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	cmd_tbl_t *c;
+
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	argc--;
+	argv++;
+
+	c = find_cmd_tbl(argv[0], &cmd_cvbs_sub[0], ARRAY_SIZE(cmd_cvbs_sub));
+
+	if (c)
+		return  c->cmd(cmdtp, flag, argc, argv);
+	else
+		return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(cvbs, CONFIG_SYS_MAXARGS, 1, do_cvbs,
+	"CVBS sub-system",
+	"cvbs debug\n"
+	"    r h/v address\n"
+	"    w value h/v address\n"
+	"    dump h/v addr_start addr_end\n"
+	"    enci\n"
+	"    clock\n"
+	"cvbs output [FORMAT | bist MODE]\n"
+	"    FORMAT : [576cvbs|480cvbs]\n"
+	"    bist mode : [off|1 or colorbar|2 or thinline|3 or dotgrid|0 or fixval]\n"
+	"cvbs vdac\n"
+	"    0 for off, 1 for enci, 2 for atv, 3 for analog-cvbs passthrough\n"
+);
diff --git a/common/cmd_d2pll.c b/common/cmd_d2pll.c
new file mode 100644
index 0000000..4df88f9
--- /dev/null
+++ b/common/cmd_d2pll.c
@@ -0,0 +1,140 @@
+/*
+ * Command d2pll & ddrtest support.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/io.h>
+#include <asm/arch/secure_apb.h>
+#include <asm/arch/romboot.h>
+
+void watchdog_reset_system(void)
+{
+		int i;
+
+		while (1) {
+		writel(	0x3	| (1 << 21) // sys reset en
+				| (1 << 23) // interrupt en
+				| (1 << 24) // clk en
+				| (1 << 25) // clk div en
+				| (1 << 26) // sys reset now
+			, P_WATCHDOG_CNTL);
+				writel(0, P_WATCHDOG_RESET);
+
+				writel(readl(P_WATCHDOG_CNTL) | (1<<18), // watchdog en
+			P_WATCHDOG_CNTL);
+				for (i=0; i<100; i++)
+						readl(P_WATCHDOG_CNTL);/*Deceive gcc for waiting some cycles */
+	}
+}
+
+int do_ddr2pll(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *endp;
+	unsigned long pll, zqcr;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+
+	pll = simple_strtoul(argv[1], &endp, 16);
+	if (*argv[1] == 0 || *endp != 0) {
+		printf ("Error: Wrong format parament!\n");
+		return 1;
+	}
+if (argc >2)
+{
+	zqcr = simple_strtoul(argv[2], &endp, 16);
+	if (*argv[2] == 0 || *endp != 0) {
+		zqcr = 0;
+	}
+}
+else
+{
+	  zqcr = 0;
+}
+
+#if defined(CONFIG_M6TV) || defined(CONFIG_M6TVD)
+	writel(zqcr | (0x3c << 24), P_PREG_STICKY_REG0);
+#else
+	writel(zqcr | (0xf13 << 20), P_PREG_STICKY_REG0);
+#endif
+	writel(pll, P_PREG_STICKY_REG1);
+	printf("Set pll done [0x%08x]\n", readl(P_PREG_STICKY_REG1));
+#ifdef CONFIG_M8B
+	writel(0xf080000 | 2000, WATCHDOG_TC);
+#else
+  //  writel(WATCHDOG_TC, 0xf400000 | 2000);
+ // *P_WATCHDOG_RESET = 0;
+ watchdog_reset_system();
+#endif
+
+	return 0;
+
+usage:
+	cmd_usage(cmdtp);
+	return 1;
+}
+
+U_BOOT_CMD(
+	d2pll,	5,	1,	do_ddr2pll,
+	"DDR set PLL function",
+	"DDR PLL set: d2pll PLL [ZQCR], e...g... 0x1022c.\n"
+);
+
+
+int do_ddr_sram_tune(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *endp;
+	unsigned long pll, zqcr;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+
+	pll = simple_strtoul(argv[1], &endp, 16);
+	if (*argv[1] == 0 || *endp != 0) {
+		printf ("Error: Wrong format parament!\n");
+		return 1;
+	}
+
+if (argc >2)
+{
+	zqcr = simple_strtoul(argv[2], &endp, 16);
+	if (*argv[2] == 0 || *endp != 0) {
+		zqcr = 0;
+	}
+}
+else
+{
+	  zqcr = 0;
+}
+#if defined(CONFIG_M6TV) || defined(CONFIG_M6TVD)
+	writel(zqcr | (0x3c << 24), P_PREG_STICKY_REG0);
+#else
+	writel(zqcr | (0xf13 << 20), P_PREG_STICKY_REG0);
+#endif
+	//writel(P_PREG_STICKY_REG1, pll);
+	writel(pll|(1<<31), P_PREG_STICKY_REG1);//modify
+	printf("Set pll done [0x%08x]\n", readl(P_PREG_STICKY_REG1));
+#ifdef CONFIG_M8B
+	writel(0xf080000 | 2000, WATCHDOG_TC);
+#else
+	//writel(WATCHDOG_TC, 0xf400000 | 2000);
+	//*P_WATCHDOG_RESET = 0;
+	watchdog_reset_system();
+#endif
+
+	return 0;
+
+usage:
+	cmd_usage(cmdtp);
+	return 1;
+}
+
+U_BOOT_CMD(
+	ddr_sram_tune,	5,	1,	do_ddr_sram_tune,
+	"DDR sram tune dqs",
+	"ddr_sram_tune  PLL [ZQCR], e...g... 0x1022c.\n\n"
+);
+
diff --git a/common/cmd_ddr_test.c b/common/cmd_ddr_test.c
new file mode 100644
index 0000000..0f96a70
--- /dev/null
+++ b/common/cmd_ddr_test.c
@@ -0,0 +1,3287 @@
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/arch/io.h>
+//#include <asm/arch/register.h>
+//#include <asm/arch-g9tv/mmc.h>	//jiaxing debug
+
+//extern	void aml_cache_disable(void);
+
+#define TDATA32F 0xffffffff
+#define TDATA32A 0xaaaaaaaa
+#define TDATA325 0x55555555
+unsigned error_count =0;
+unsigned error_outof_count_flag=0;
+
+//#define readl(addr)	(*((volatile unsigned *)addr))	//rd_reg(addr)
+//#define writel(data ,addr)	(*((volatile unsigned *)addr))=(data)	//wr_reg(addr, data)
+
+//#define wr_reg(addr, data)	(*((volatile unsigned *)addr))=(data)
+//#define rd_reg(addr)		(*((volatile unsigned *)addr))
+
+
+
+static void ddr_write(void *buff, unsigned m_length)
+{
+	unsigned *p;
+	unsigned i, j, n;
+	unsigned m_len = m_length;
+
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		for (j=0;j<32;j++)
+		{
+			if (m_len >= 128)
+				n = 32;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+				switch (i)
+				{
+					case 0:
+					case 9:
+					case 14:
+					case 25:
+					case 30:
+						*(p+i) = TDATA32F;
+						break;
+					case 1:
+					case 6:
+					case 8:
+					case 17:
+					case 22:
+						*(p+i) = 0;
+						break;
+					case 16:
+					case 23:
+					case 31:
+						*(p+i) = TDATA32A;
+						break;
+					case 7:
+					case 15:
+					case 24:
+						*(p+i) = TDATA325;
+						break;
+					case 2:
+					case 4:
+					case 10:
+					case 12:
+					case 19:
+					case 21:
+					case 27:
+					case 29:
+						*(p+i) = 1<<j;
+						break;
+					case 3:
+					case 5:
+					case 11:
+					case 13:
+					case 18:
+					case 20:
+					case 26:
+					case 28:
+						*(p+i) = ~(1<<j);
+						break;
+				}
+			}
+
+			if (m_len > 128)
+			{
+				m_len -= 128;
+				p += 32;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+
+
+
+
+static void ddr_read(void *buff, unsigned m_length)
+{
+	unsigned *p;
+	unsigned i, j, n;
+	unsigned m_len = m_length;
+
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		for (j=0;j<32;j++)
+		{
+			if (m_len >= 128)
+				n = 32;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+				if ((error_outof_count_flag) && (error_count))
+				{
+				 printf("Error data out of count");
+				 m_len=0;
+				 break;
+				}
+				switch (i)
+				{
+					case 0:
+					case 9:
+					case 14:
+					case 25:
+					case 30:
+						if (*(p+i) != TDATA32F)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned)(m_length - m_len + i), TDATA32F);
+							}
+						break;
+					case 1:
+					case 6:
+					case 8:
+					case 17:
+					case 22:
+						if (*(p+i) != 0) {error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned)(m_length - m_len + i), 0);
+						}break;
+					case 16:
+					case 23:
+					case 31:
+						if (*(p+i) != TDATA32A) {error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned)(m_length - m_len + i), TDATA32A);
+						} break;
+					case 7:
+					case 15:
+					case 24:
+						if (*(p+i) != TDATA325) {error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned)(m_length - m_len + i), TDATA325);
+						} break;
+					case 2:
+					case 4:
+					case 10:
+					case 12:
+					case 19:
+					case 21:
+					case 27:
+					case 29:
+						if (*(p+i) != 1<<j) {error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned)(m_length - m_len + i), 1<<j);
+						} break;
+					case 3:
+					case 5:
+					case 11:
+					case 13:
+					case 18:
+					case 20:
+					case 26:
+					case 28:
+						if (*(p+i) != ~(1<<j)) {error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned)(m_length - m_len + i), ~(1<<j));
+						} break;
+				}
+			}
+
+			if (m_len > 128)
+			{
+				m_len -= 128;
+				p += 32;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+///*
+#define DDR_PATTERN_LOOP_1 32
+#define DDR_PATTERN_LOOP_2 64
+#define DDR_PATTERN_LOOP_3 96
+static void ddr_write_pattern4_cross_talk_p(void *buff, unsigned m_length)
+{
+	unsigned *p;
+ //	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+//#define ddr_pattern_loop 32
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+				switch (i)
+				{
+					case 0:
+					case 1:
+					case 2:
+					case 3:
+					case 8:
+					case 9:
+					case 10:
+					case 11:
+				case 16:
+					case 17:
+					case 18:
+					case 19:
+					case 24:
+					case 25:
+					case 26:
+					case 27:
+				 //	case 30:
+						*(p+i) = TDATA32F;
+						break;
+					case 4:
+					case 5:
+					case 6:
+					case 7:
+					case 12:
+					case 13:
+					case 14:
+					case 15:
+				case 20:
+					case 21:
+					case 22:
+					case 23:
+				case 28:
+					case 29:
+					case 30:
+					case 31:
+				 //	case 22:
+						*(p+i) = 0;
+						break;
+				case DDR_PATTERN_LOOP_1+0:
+					case DDR_PATTERN_LOOP_1+1:
+					case DDR_PATTERN_LOOP_1+2:
+					case DDR_PATTERN_LOOP_1+3:
+					case DDR_PATTERN_LOOP_1+8:
+					case DDR_PATTERN_LOOP_1+9:
+					case DDR_PATTERN_LOOP_1+10:
+					case DDR_PATTERN_LOOP_1+11:
+				case DDR_PATTERN_LOOP_1+16:
+					case DDR_PATTERN_LOOP_1+17:
+					case DDR_PATTERN_LOOP_1+18:
+					case DDR_PATTERN_LOOP_1+19:
+					case DDR_PATTERN_LOOP_1+24:
+					case DDR_PATTERN_LOOP_1+25:
+					case DDR_PATTERN_LOOP_1+26:
+					case DDR_PATTERN_LOOP_1+27:
+				 //	case 30:
+							*(p+i) = TDATA32A;
+						break;
+					case DDR_PATTERN_LOOP_1+4:
+					case DDR_PATTERN_LOOP_1+5:
+					case DDR_PATTERN_LOOP_1+6:
+					case DDR_PATTERN_LOOP_1+7:
+					case DDR_PATTERN_LOOP_1+12:
+					case DDR_PATTERN_LOOP_1+13:
+					case DDR_PATTERN_LOOP_1+14:
+					case DDR_PATTERN_LOOP_1+15:
+				case DDR_PATTERN_LOOP_1+20:
+					case DDR_PATTERN_LOOP_1+21:
+					case DDR_PATTERN_LOOP_1+22:
+					case DDR_PATTERN_LOOP_1+23:
+				case DDR_PATTERN_LOOP_1+28:
+					case DDR_PATTERN_LOOP_1+29:
+					case DDR_PATTERN_LOOP_1+30:
+					case DDR_PATTERN_LOOP_1+31:
+				*(p+i) = TDATA325;
+
+
+						break;
+				case DDR_PATTERN_LOOP_2+0:
+		 case DDR_PATTERN_LOOP_2+1:
+		 case DDR_PATTERN_LOOP_2+2:
+		 case DDR_PATTERN_LOOP_2+3:
+					*(p+i) =0xfe01fe01;
+					break;
+				case DDR_PATTERN_LOOP_2+4:
+		 case DDR_PATTERN_LOOP_2+5:
+		 case DDR_PATTERN_LOOP_2+6:
+		 case DDR_PATTERN_LOOP_2+7:
+					*(p+i) =0xfd02fd02;
+					break;
+				case DDR_PATTERN_LOOP_2+8:
+		 case DDR_PATTERN_LOOP_2+9:
+		 case DDR_PATTERN_LOOP_2+10:
+		 case DDR_PATTERN_LOOP_2+11:
+					*(p+i) =0xfb04fb04;
+					break;
+				case DDR_PATTERN_LOOP_2+12:
+		 case DDR_PATTERN_LOOP_2+13:
+		 case DDR_PATTERN_LOOP_2+14:
+		 case DDR_PATTERN_LOOP_2+15:
+					*(p+i) =0xf708f708;
+					break;
+				case DDR_PATTERN_LOOP_2+16:
+		 case DDR_PATTERN_LOOP_2+17:
+		 case DDR_PATTERN_LOOP_2+18:
+		 case DDR_PATTERN_LOOP_2+19:
+					*(p+i) =0xef10ef10;
+					break;
+				case DDR_PATTERN_LOOP_2+20:
+		 case DDR_PATTERN_LOOP_2+21:
+		 case DDR_PATTERN_LOOP_2+22:
+		 case DDR_PATTERN_LOOP_2+23:
+					*(p+i) =0xdf20df20;
+					break;
+				case DDR_PATTERN_LOOP_2+24:
+		 case DDR_PATTERN_LOOP_2+25:
+		 case DDR_PATTERN_LOOP_2+26:
+		 case DDR_PATTERN_LOOP_2+27:
+					*(p+i) =0xbf40bf40;
+					break;
+				case DDR_PATTERN_LOOP_2+28:
+		 case DDR_PATTERN_LOOP_2+29:
+		 case DDR_PATTERN_LOOP_2+30:
+		 case DDR_PATTERN_LOOP_2+31:
+					*(p+i) =0x7f807f80;
+					break;
+				case DDR_PATTERN_LOOP_3+0:
+		 case DDR_PATTERN_LOOP_3+1:
+		 case DDR_PATTERN_LOOP_3+2:
+		 case DDR_PATTERN_LOOP_3+3:
+					*(p+i) =0x00000100;
+					break;
+				case DDR_PATTERN_LOOP_3+4:
+		 case DDR_PATTERN_LOOP_3+5:
+		 case DDR_PATTERN_LOOP_3+6:
+		 case DDR_PATTERN_LOOP_3+7:
+					*(p+i) =0x00000200;
+					break;
+				case DDR_PATTERN_LOOP_3+8:
+		 case DDR_PATTERN_LOOP_3+9:
+		 case DDR_PATTERN_LOOP_3+10:
+		 case DDR_PATTERN_LOOP_3+11:
+					*(p+i) =0x00000400;
+					break;
+				case DDR_PATTERN_LOOP_3+12:
+		 case DDR_PATTERN_LOOP_3+13:
+		 case DDR_PATTERN_LOOP_3+14:
+		 case DDR_PATTERN_LOOP_3+15:
+					*(p+i) =0x00000800;
+					break;
+				case DDR_PATTERN_LOOP_3+16:
+		 case DDR_PATTERN_LOOP_3+17:
+		 case DDR_PATTERN_LOOP_3+18:
+		 case DDR_PATTERN_LOOP_3+19:
+					*(p+i) =0x00001000;
+					break;
+				case DDR_PATTERN_LOOP_3+20:
+		 case DDR_PATTERN_LOOP_3+21:
+		 case DDR_PATTERN_LOOP_3+22:
+		 case DDR_PATTERN_LOOP_3+23:
+					*(p+i) =0x00002000;
+					break;
+				case DDR_PATTERN_LOOP_3+24:
+		 case DDR_PATTERN_LOOP_3+25:
+		 case DDR_PATTERN_LOOP_3+26:
+		 case DDR_PATTERN_LOOP_3+27:
+					*(p+i) =0x00004000;
+					break;
+				case DDR_PATTERN_LOOP_3+28:
+		 case DDR_PATTERN_LOOP_3+29:
+		 case DDR_PATTERN_LOOP_3+30:
+		 case DDR_PATTERN_LOOP_3+31:
+					*(p+i) =0x00008000;
+					break;
+
+
+				}
+			}
+
+			if (m_len >( 128*4))
+			{
+				m_len -=( 128*4);
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+static void ddr_write_pattern4_cross_talk_p2(void *buff, unsigned m_length)
+{
+	unsigned *p;
+ //	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+//#define ddr_pattern_loop 32
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+
+
+				switch (i)
+				{
+					 case 0:
+			case DDR_PATTERN_LOOP_1+1:
+			case DDR_PATTERN_LOOP_2+2:
+			case DDR_PATTERN_LOOP_3+3:
+								*(p+i) = 0xfe01fe01;
+									break;
+					 case 4:
+			case DDR_PATTERN_LOOP_1+5:
+			case DDR_PATTERN_LOOP_2+6:
+			case DDR_PATTERN_LOOP_3+7:
+							*(p+i) = 0xfd02fd02;
+									 break;
+
+					 case 8:
+			case DDR_PATTERN_LOOP_1+9:
+			case DDR_PATTERN_LOOP_2+10:
+			case DDR_PATTERN_LOOP_3+11:
+							*(p+i) = 0xfb04fb04;
+						break;
+
+					 case 12:
+			case DDR_PATTERN_LOOP_1+13:
+			case DDR_PATTERN_LOOP_2+14:
+			case DDR_PATTERN_LOOP_3+15:
+							*(p+i) = 0xf708f708;
+						break;
+
+					 case 16:
+			case DDR_PATTERN_LOOP_1+17:
+			case DDR_PATTERN_LOOP_2+18:
+			case DDR_PATTERN_LOOP_3+19:
+							*(p+i) = 0xef10ef10;
+						break;
+
+					 case 20:
+			case DDR_PATTERN_LOOP_1+21:
+			case DDR_PATTERN_LOOP_2+22:
+			case DDR_PATTERN_LOOP_3+23:
+							*(p+i) = 0xdf20df20;
+						break;
+
+					 case 24:
+			case DDR_PATTERN_LOOP_1+25:
+			case DDR_PATTERN_LOOP_2+26:
+			case DDR_PATTERN_LOOP_3+27:
+							*(p+i) = 0xbf40bf40;
+			 break;
+
+						case 28:
+			case DDR_PATTERN_LOOP_1+29:
+			case DDR_PATTERN_LOOP_2+30:
+			case DDR_PATTERN_LOOP_3+31:
+							*(p+i) = 0x7f807f80;
+						break;
+
+
+				default:
+
+							*(p+i) = 0xff00ff00;
+						break;
+
+						break;
+
+
+				}
+			}
+
+			if (m_len >( 128*4))
+			{
+				m_len -=( 128*4);
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+static void ddr_read_pattern4_cross_talk_p(void *buff, unsigned m_length)
+{
+	unsigned *p;
+	//	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+			if ((error_outof_count_flag) && (error_count))
+				{
+				 printf("Error data out of count");
+				 m_len=0;
+				 break;
+				}
+
+				switch (i)
+				{
+					 case 0:
+					case 1:
+					case 2:
+					case 3:
+					case 8:
+					case 9:
+					case 10:
+					case 11:
+				case 16:
+					case 17:
+					case 18:
+					case 19:
+					case 24:
+					case 25:
+					case 26:
+					case 27:
+				 //	case 30:
+					//		*(p+i) = TDATA32F;
+						if (*(p+i) != TDATA32F)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), TDATA32F);
+													break;
+							}
+						 break;
+					 case 4:
+					case 5:
+					case 6:
+					case 7:
+					case 12:
+					case 13:
+					case 14:
+					case 15:
+				case 20:
+					case 21:
+					case 22:
+					case 23:
+				case 28:
+					case 29:
+					case 30:
+					case 31:
+				 //	case 22:
+					 //	*(p+i) = 0;
+						if (*(p+i) != 0)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0);
+						break;}
+						 break;
+					case DDR_PATTERN_LOOP_1+0:
+					case DDR_PATTERN_LOOP_1+1:
+					case DDR_PATTERN_LOOP_1+2:
+					case DDR_PATTERN_LOOP_1+3:
+					case DDR_PATTERN_LOOP_1+8:
+					case DDR_PATTERN_LOOP_1+9:
+					case DDR_PATTERN_LOOP_1+10:
+					case DDR_PATTERN_LOOP_1+11:
+				case DDR_PATTERN_LOOP_1+16:
+					case DDR_PATTERN_LOOP_1+17:
+					case DDR_PATTERN_LOOP_1+18:
+					case DDR_PATTERN_LOOP_1+19:
+					case DDR_PATTERN_LOOP_1+24:
+					case DDR_PATTERN_LOOP_1+25:
+					case DDR_PATTERN_LOOP_1+26:
+					case DDR_PATTERN_LOOP_1+27:
+				 //	case 30:
+					//		*(p+i) = TDATA32A;
+						if (*(p+i) != TDATA32A)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), TDATA32A);
+						break;
+							}
+						 break;
+						case DDR_PATTERN_LOOP_1+4:
+					case DDR_PATTERN_LOOP_1+5:
+					case DDR_PATTERN_LOOP_1+6:
+					case DDR_PATTERN_LOOP_1+7:
+					case DDR_PATTERN_LOOP_1+12:
+					case DDR_PATTERN_LOOP_1+13:
+					case DDR_PATTERN_LOOP_1+14:
+					case DDR_PATTERN_LOOP_1+15:
+				case DDR_PATTERN_LOOP_1+20:
+					case DDR_PATTERN_LOOP_1+21:
+					case DDR_PATTERN_LOOP_1+22:
+					case DDR_PATTERN_LOOP_1+23:
+				case DDR_PATTERN_LOOP_1+28:
+					case DDR_PATTERN_LOOP_1+29:
+					case DDR_PATTERN_LOOP_1+30:
+					case DDR_PATTERN_LOOP_1+31:
+			//	*(p+i) = TDATA325;
+						if (*(p+i) != TDATA325)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), TDATA325);
+						break;
+							}
+						 break;
+					 case DDR_PATTERN_LOOP_2+0:
+		 case DDR_PATTERN_LOOP_2+1:
+		 case DDR_PATTERN_LOOP_2+2:
+		 case DDR_PATTERN_LOOP_2+3:
+			//		*(p+i) =0xfe01fe01;
+						if (*(p+i) !=0xfe01fe01)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xfe01fe01);
+						break;
+							}
+						 break;
+					case DDR_PATTERN_LOOP_2+4:
+		 case DDR_PATTERN_LOOP_2+5:
+		 case DDR_PATTERN_LOOP_2+6:
+		 case DDR_PATTERN_LOOP_2+7:
+				// 	*(p+i) =0xfd02fd02;
+						if (*(p+i) != 0xfd02fd02)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xfd02fd02);
+						break;
+							}
+						 break;
+				case DDR_PATTERN_LOOP_2+8:
+		 case DDR_PATTERN_LOOP_2+9:
+		 case DDR_PATTERN_LOOP_2+10:
+		 case DDR_PATTERN_LOOP_2+11:
+				//	*(p+i) =0xfb04fb04;
+				 if (*(p+i) != 0xfb04fb04)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xfb04fb04);
+					break;
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+12:
+		 case DDR_PATTERN_LOOP_2+13:
+		 case DDR_PATTERN_LOOP_2+14:
+		 case DDR_PATTERN_LOOP_2+15:
+				//	*(p+i) =0xf7b08f708;
+					if (*(p+i) != 0xf708f708)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xf708f708);
+					break;
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+16:
+		 case DDR_PATTERN_LOOP_2+17:
+		 case DDR_PATTERN_LOOP_2+18:
+		 case DDR_PATTERN_LOOP_2+19:
+				//	*(p+i) =0xef10ef10;
+					if (*(p+i) != 0xef10ef10)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xef10ef10);
+					break;
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+20:
+		 case DDR_PATTERN_LOOP_2+21:
+		 case DDR_PATTERN_LOOP_2+22:
+		 case DDR_PATTERN_LOOP_2+23:
+				//	*(p+i) =0xdf20df20;
+					if (*(p+i) != 0xdf20df20)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xdf20df20);
+					break;
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+24:
+		 case DDR_PATTERN_LOOP_2+25:
+		 case DDR_PATTERN_LOOP_2+26:
+		 case DDR_PATTERN_LOOP_2+27:
+			 //		*(p+i) =0xbf40bf40;
+					if (*(p+i) != 0xbf40bf40)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xbf40bf40);
+					break;
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+28:
+		 case DDR_PATTERN_LOOP_2+29:
+		 case DDR_PATTERN_LOOP_2+30:
+		 case DDR_PATTERN_LOOP_2+31:
+			//		*(p+i) =0x7f807f80;
+					if (*(p+i) != 0x7f807f80)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x7f807f80);
+					break;
+
+						}
+					break;
+				case DDR_PATTERN_LOOP_3+0:
+		 case DDR_PATTERN_LOOP_3+1:
+		 case DDR_PATTERN_LOOP_3+2:
+		 case DDR_PATTERN_LOOP_3+3:
+				//	*(p+i) =0x00000100;
+						if (*(p+i) != 0x00000100)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00000100);
+					break;
+							}
+						break;
+				case DDR_PATTERN_LOOP_3+4:
+		 case DDR_PATTERN_LOOP_3+5:
+		 case DDR_PATTERN_LOOP_3+6:
+		 case DDR_PATTERN_LOOP_3+7:
+			 //		*(p+i) =0x00000100;
+					if (*(p+i) != 0x00000200)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00000200);
+					break;
+						}
+					break;
+				case DDR_PATTERN_LOOP_3+8:
+		 case DDR_PATTERN_LOOP_3+9:
+		 case DDR_PATTERN_LOOP_3+10:
+		 case DDR_PATTERN_LOOP_3+11:
+				//	*(p+i) =0x00000100;
+				 if (*(p+i) != 0x00000400)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00000400);
+					break;
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+12:
+		 case DDR_PATTERN_LOOP_3+13:
+		 case DDR_PATTERN_LOOP_3+14:
+		 case DDR_PATTERN_LOOP_3+15:
+				//	*(p+i) =0x00000100;
+				 if (*(p+i) != 0x00000800)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00000800);
+					break;
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+16:
+		 case DDR_PATTERN_LOOP_3+17:
+		 case DDR_PATTERN_LOOP_3+18:
+		 case DDR_PATTERN_LOOP_3+19:
+				//	*(p+i) =0xfffffeff;
+				 if (*(p+i) != 0x00001000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00001000);
+					break;
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+20:
+		 case DDR_PATTERN_LOOP_3+21:
+		 case DDR_PATTERN_LOOP_3+22:
+		 case DDR_PATTERN_LOOP_3+23:
+				// 	*(p+i) =0xfffffeff;
+				 if (*(p+i) != 0x00002000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00002000);
+
+					} break;
+				case DDR_PATTERN_LOOP_3+24:
+		 case DDR_PATTERN_LOOP_3+25:
+		 case DDR_PATTERN_LOOP_3+26:
+		 case DDR_PATTERN_LOOP_3+27:
+				//	*(p+i) =0xfffffeff;
+				 if (*(p+i) != 0x00004000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00004000);
+					break;
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+28:
+		 case DDR_PATTERN_LOOP_3+29:
+		 case DDR_PATTERN_LOOP_3+30:
+		 case DDR_PATTERN_LOOP_3+31:
+				//	*(p+i) =0xfffffeff;
+				 if (*(p+i) != 0x00008000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00008000);
+					break;
+					}
+					break;
+
+
+
+				}
+			}
+
+			if (m_len > 128*4)
+			{
+				m_len -= 128*4;
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+//*/
+static void ddr_read_pattern4_cross_talk_p2(void *buff, unsigned m_length)
+{
+	unsigned *p;
+	//	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+			if ((error_outof_count_flag) && (error_count))
+				{
+				 printf("Error data out of count");
+				 m_len=0;
+				 break;
+				}
+
+				switch (i)
+				{
+					 case 0:
+			case DDR_PATTERN_LOOP_1+1:
+			case DDR_PATTERN_LOOP_2+2:
+			case DDR_PATTERN_LOOP_3+3:
+							//	*(p+i) = 0xfe01fe01;
+								if (*(p+i) != 0xfe01fe01)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xfe01fe01);
+													break;
+							}
+									break;
+					 case 4:
+			case DDR_PATTERN_LOOP_1+5:
+			case DDR_PATTERN_LOOP_2+6:
+			case DDR_PATTERN_LOOP_3+7:
+					//		*(p+i) = 0xfd02fd02;
+								if (*(p+i) != 0xfd02fd02)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xfd02fd02);
+													break;
+							}
+									 break;
+
+					 case 8:
+			case DDR_PATTERN_LOOP_1+9:
+			case DDR_PATTERN_LOOP_2+10:
+			case DDR_PATTERN_LOOP_3+11:
+						//	*(p+i) = 0xfb04fb04;
+								if (*(p+i) != 0xfb04fb04)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xfb04fb04);
+													break;
+							}
+						break;
+
+					 case 12:
+			case DDR_PATTERN_LOOP_1+13:
+			case DDR_PATTERN_LOOP_2+14:
+			case DDR_PATTERN_LOOP_3+15:
+					//		*(p+i) = 0xf708f708;
+								if (*(p+i) != 0xf708f708)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xf708f708);
+													break;
+							}
+						break;
+
+					 case 16:
+			case DDR_PATTERN_LOOP_1+17:
+			case DDR_PATTERN_LOOP_2+18:
+			case DDR_PATTERN_LOOP_3+19:
+					//		*(p+i) = 0xef10ef10;
+								if (*(p+i) != 0xef10ef10)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xef10ef10);
+													break;
+							}
+						break;
+
+					 case 20:
+			case DDR_PATTERN_LOOP_1+21:
+			case DDR_PATTERN_LOOP_2+22:
+			case DDR_PATTERN_LOOP_3+23:
+						//	*(p+i) = 0xdf20df20;
+								if (*(p+i) != 0xdf20df20)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xdf20df20);
+													break;
+							}
+						break;
+
+					 case 24:
+			case DDR_PATTERN_LOOP_1+25:
+			case DDR_PATTERN_LOOP_2+26:
+			case DDR_PATTERN_LOOP_3+27:
+					//		*(p+i) = 0xbf40bf40;
+								if (*(p+i) != 0xbf40bf40)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xbf40bf40);
+													break;
+							}
+													break;
+						case 28:
+			case DDR_PATTERN_LOOP_1+29:
+			case DDR_PATTERN_LOOP_2+30:
+			case DDR_PATTERN_LOOP_3+31:
+					//		*(p+i) = 0x7f807f80;
+								if (*(p+i) != 0x7f807f80)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x7f807f80);
+													break;
+							}
+						break;
+
+
+				default:
+
+						//	*(p+i) = 0xff00ff00;
+							 if (*(p+i) != 0xff00ff00)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff00ff00);
+													break;
+							}
+						break;
+
+						break;
+
+
+				}
+			}
+
+			if (m_len > 128*4)
+			{
+				m_len -= 128*4;
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+static void ddr_write_pattern4_cross_talk_n(void *buff, unsigned m_length)
+{
+	unsigned *p;
+ //	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+//#define ddr_pattern_loop 32
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+				switch (i)
+				{
+					case 0:
+					case 1:
+					case 2:
+					case 3:
+					case 8:
+					case 9:
+					case 10:
+					case 11:
+				case 16:
+					case 17:
+					case 18:
+					case 19:
+					case 24:
+					case 25:
+					case 26:
+					case 27:
+				 //	case 30:
+						*(p+i) = ~TDATA32F;
+						break;
+					case 4:
+					case 5:
+					case 6:
+					case 7:
+					case 12:
+					case 13:
+					case 14:
+					case 15:
+				case 20:
+					case 21:
+					case 22:
+					case 23:
+				case 28:
+					case 29:
+					case 30:
+					case 31:
+				 //	case 22:
+						*(p+i) = ~0;
+						break;
+				case DDR_PATTERN_LOOP_1+0:
+					case DDR_PATTERN_LOOP_1+1:
+					case DDR_PATTERN_LOOP_1+2:
+					case DDR_PATTERN_LOOP_1+3:
+					case DDR_PATTERN_LOOP_1+8:
+					case DDR_PATTERN_LOOP_1+9:
+					case DDR_PATTERN_LOOP_1+10:
+					case DDR_PATTERN_LOOP_1+11:
+				case DDR_PATTERN_LOOP_1+16:
+					case DDR_PATTERN_LOOP_1+17:
+					case DDR_PATTERN_LOOP_1+18:
+					case DDR_PATTERN_LOOP_1+19:
+					case DDR_PATTERN_LOOP_1+24:
+					case DDR_PATTERN_LOOP_1+25:
+					case DDR_PATTERN_LOOP_1+26:
+					case DDR_PATTERN_LOOP_1+27:
+				 //	case 30:
+							*(p+i) = ~TDATA32A;
+						break;
+					case DDR_PATTERN_LOOP_1+4:
+					case DDR_PATTERN_LOOP_1+5:
+					case DDR_PATTERN_LOOP_1+6:
+					case DDR_PATTERN_LOOP_1+7:
+					case DDR_PATTERN_LOOP_1+12:
+					case DDR_PATTERN_LOOP_1+13:
+					case DDR_PATTERN_LOOP_1+14:
+					case DDR_PATTERN_LOOP_1+15:
+				case DDR_PATTERN_LOOP_1+20:
+					case DDR_PATTERN_LOOP_1+21:
+					case DDR_PATTERN_LOOP_1+22:
+					case DDR_PATTERN_LOOP_1+23:
+				case DDR_PATTERN_LOOP_1+28:
+					case DDR_PATTERN_LOOP_1+29:
+					case DDR_PATTERN_LOOP_1+30:
+					case DDR_PATTERN_LOOP_1+31:
+				*(p+i) =~TDATA325;
+
+
+						break;
+				case DDR_PATTERN_LOOP_2+0:
+		 case DDR_PATTERN_LOOP_2+1:
+		 case DDR_PATTERN_LOOP_2+2:
+		 case DDR_PATTERN_LOOP_2+3:
+					*(p+i) =~0xfe01fe01;
+					break;
+				case DDR_PATTERN_LOOP_2+4:
+		 case DDR_PATTERN_LOOP_2+5:
+		 case DDR_PATTERN_LOOP_2+6:
+		 case DDR_PATTERN_LOOP_2+7:
+					*(p+i) =~0xfd02fd02;
+					break;
+				case DDR_PATTERN_LOOP_2+8:
+		 case DDR_PATTERN_LOOP_2+9:
+		 case DDR_PATTERN_LOOP_2+10:
+		 case DDR_PATTERN_LOOP_2+11:
+					*(p+i) =~0xfb04fb04;
+					break;
+				case DDR_PATTERN_LOOP_2+12:
+		 case DDR_PATTERN_LOOP_2+13:
+		 case DDR_PATTERN_LOOP_2+14:
+		 case DDR_PATTERN_LOOP_2+15:
+					*(p+i) =~0xf708f708;
+					break;
+				case DDR_PATTERN_LOOP_2+16:
+		 case DDR_PATTERN_LOOP_2+17:
+		 case DDR_PATTERN_LOOP_2+18:
+		 case DDR_PATTERN_LOOP_2+19:
+					*(p+i) =~0xef10ef10;
+					break;
+				case DDR_PATTERN_LOOP_2+20:
+		 case DDR_PATTERN_LOOP_2+21:
+		 case DDR_PATTERN_LOOP_2+22:
+		 case DDR_PATTERN_LOOP_2+23:
+					*(p+i) =~0xdf20df20;
+					break;
+				case DDR_PATTERN_LOOP_2+24:
+		 case DDR_PATTERN_LOOP_2+25:
+		 case DDR_PATTERN_LOOP_2+26:
+		 case DDR_PATTERN_LOOP_2+27:
+					*(p+i) =~0xbf40bf40;
+					break;
+				case DDR_PATTERN_LOOP_2+28:
+		 case DDR_PATTERN_LOOP_2+29:
+		 case DDR_PATTERN_LOOP_2+30:
+		 case DDR_PATTERN_LOOP_2+31:
+					*(p+i) =~0x7f807f80;
+					break;
+				case DDR_PATTERN_LOOP_3+0:
+		 case DDR_PATTERN_LOOP_3+1:
+		 case DDR_PATTERN_LOOP_3+2:
+		 case DDR_PATTERN_LOOP_3+3:
+					*(p+i) =~0x00000100;
+					break;
+				case DDR_PATTERN_LOOP_3+4:
+		 case DDR_PATTERN_LOOP_3+5:
+		 case DDR_PATTERN_LOOP_3+6:
+		 case DDR_PATTERN_LOOP_3+7:
+					*(p+i) =~0x00000200;
+					break;
+				case DDR_PATTERN_LOOP_3+8:
+		 case DDR_PATTERN_LOOP_3+9:
+		 case DDR_PATTERN_LOOP_3+10:
+		 case DDR_PATTERN_LOOP_3+11:
+					*(p+i) =~0x00000400;
+					break;
+				case DDR_PATTERN_LOOP_3+12:
+		 case DDR_PATTERN_LOOP_3+13:
+		 case DDR_PATTERN_LOOP_3+14:
+		 case DDR_PATTERN_LOOP_3+15:
+					*(p+i) =~0x00000800;
+					break;
+				case DDR_PATTERN_LOOP_3+16:
+		 case DDR_PATTERN_LOOP_3+17:
+		 case DDR_PATTERN_LOOP_3+18:
+		 case DDR_PATTERN_LOOP_3+19:
+					*(p+i) =~0x00001000;
+					break;
+				case DDR_PATTERN_LOOP_3+20:
+		 case DDR_PATTERN_LOOP_3+21:
+		 case DDR_PATTERN_LOOP_3+22:
+		 case DDR_PATTERN_LOOP_3+23:
+					*(p+i) =~0x00002000;
+					break;
+				case DDR_PATTERN_LOOP_3+24:
+		 case DDR_PATTERN_LOOP_3+25:
+		 case DDR_PATTERN_LOOP_3+26:
+		 case DDR_PATTERN_LOOP_3+27:
+					*(p+i) =~0x00004000;
+					break;
+				case DDR_PATTERN_LOOP_3+28:
+		 case DDR_PATTERN_LOOP_3+29:
+		 case DDR_PATTERN_LOOP_3+30:
+		 case DDR_PATTERN_LOOP_3+31:
+					*(p+i) =~0x00008000;
+					break;
+
+
+				}
+			}
+
+			if (m_len >( 128*4))
+			{
+				m_len -=( 128*4);
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+
+static void ddr_write_pattern4_cross_talk_n2(void *buff, unsigned m_length)
+{
+	unsigned *p;
+ //	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+//#define ddr_pattern_loop 32
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+
+
+				switch (i)
+				{
+					 case 0:
+			case DDR_PATTERN_LOOP_1+1:
+			case DDR_PATTERN_LOOP_2+2:
+			case DDR_PATTERN_LOOP_3+3:
+								*(p+i) = ~0xfe01fe01;
+									break;
+					 case 4:
+			case DDR_PATTERN_LOOP_1+5:
+			case DDR_PATTERN_LOOP_2+6:
+			case DDR_PATTERN_LOOP_3+7:
+							*(p+i) = ~0xfd02fd02;
+									 break;
+
+					 case 8:
+			case DDR_PATTERN_LOOP_1+9:
+			case DDR_PATTERN_LOOP_2+10:
+			case DDR_PATTERN_LOOP_3+11:
+							*(p+i) = ~0xfb04fb04;
+						break;
+
+					 case 12:
+			case DDR_PATTERN_LOOP_1+13:
+			case DDR_PATTERN_LOOP_2+14:
+			case DDR_PATTERN_LOOP_3+15:
+							*(p+i) = ~0xf708f708;
+						break;
+
+					 case 16:
+			case DDR_PATTERN_LOOP_1+17:
+			case DDR_PATTERN_LOOP_2+18:
+			case DDR_PATTERN_LOOP_3+19:
+							*(p+i) = ~0xef10ef10;
+						break;
+
+					 case 20:
+			case DDR_PATTERN_LOOP_1+21:
+			case DDR_PATTERN_LOOP_2+22:
+			case DDR_PATTERN_LOOP_3+23:
+							*(p+i) = ~0xdf20df20;
+						break;
+
+					 case 24:
+			case DDR_PATTERN_LOOP_1+25:
+			case DDR_PATTERN_LOOP_2+26:
+			case DDR_PATTERN_LOOP_3+27:
+							*(p+i) =~0xbf40bf40;
+								break;
+						case 28:
+			case DDR_PATTERN_LOOP_1+29:
+			case DDR_PATTERN_LOOP_2+30:
+			case DDR_PATTERN_LOOP_3+31:
+							*(p+i) = ~0x7f807f80;
+						break;
+
+
+				default:
+
+							*(p+i) = ~0xff00ff00;
+						break;
+
+						break;
+
+
+				}
+			}
+
+			if (m_len >( 128*4))
+			{
+				m_len -=( 128*4);
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+static void ddr_read_pattern4_cross_talk_n(void *buff, unsigned m_length)
+{
+	unsigned *p;
+	//	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+				if ((error_outof_count_flag) && (error_count))
+				{
+				 printf("Error data out of count");
+				 m_len=0;
+					break;
+				}
+				switch (i)
+				{
+					 case 0:
+					case 1:
+					case 2:
+					case 3:
+					case 8:
+					case 9:
+					case 10:
+					case 11:
+				case 16:
+					case 17:
+					case 18:
+					case 19:
+					case 24:
+					case 25:
+					case 26:
+					case 27:
+				 //	case 30:
+					//		*(p+i) = TDATA32F;
+						if (*(p+i) !=~TDATA32F)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~TDATA32F);
+						break;
+							}
+						 break;
+					 case 4:
+					case 5:
+					case 6:
+					case 7:
+					case 12:
+					case 13:
+					case 14:
+					case 15:
+				case 20:
+					case 21:
+					case 22:
+					case 23:
+				case 28:
+					case 29:
+					case 30:
+					case 31:
+				 //	case 22:
+					 //	*(p+i) = 0;
+						if (*(p+i) !=~0)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0);
+							}
+						break;
+					case DDR_PATTERN_LOOP_1+0:
+					case DDR_PATTERN_LOOP_1+1:
+					case DDR_PATTERN_LOOP_1+2:
+					case DDR_PATTERN_LOOP_1+3:
+					case DDR_PATTERN_LOOP_1+8:
+					case DDR_PATTERN_LOOP_1+9:
+					case DDR_PATTERN_LOOP_1+10:
+					case DDR_PATTERN_LOOP_1+11:
+				case DDR_PATTERN_LOOP_1+16:
+					case DDR_PATTERN_LOOP_1+17:
+					case DDR_PATTERN_LOOP_1+18:
+					case DDR_PATTERN_LOOP_1+19:
+					case DDR_PATTERN_LOOP_1+24:
+					case DDR_PATTERN_LOOP_1+25:
+					case DDR_PATTERN_LOOP_1+26:
+					case DDR_PATTERN_LOOP_1+27:
+				 //	case 30:
+					//		*(p+i) = TDATA32A;
+						if (*(p+i) != ~TDATA32A)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i),~TDATA32A);
+							}
+						break;
+						case DDR_PATTERN_LOOP_1+4:
+					case DDR_PATTERN_LOOP_1+5:
+					case DDR_PATTERN_LOOP_1+6:
+					case DDR_PATTERN_LOOP_1+7:
+					case DDR_PATTERN_LOOP_1+12:
+					case DDR_PATTERN_LOOP_1+13:
+					case DDR_PATTERN_LOOP_1+14:
+					case DDR_PATTERN_LOOP_1+15:
+				case DDR_PATTERN_LOOP_1+20:
+					case DDR_PATTERN_LOOP_1+21:
+					case DDR_PATTERN_LOOP_1+22:
+					case DDR_PATTERN_LOOP_1+23:
+				case DDR_PATTERN_LOOP_1+28:
+					case DDR_PATTERN_LOOP_1+29:
+					case DDR_PATTERN_LOOP_1+30:
+					case DDR_PATTERN_LOOP_1+31:
+			//	*(p+i) = TDATA325;
+						if (*(p+i) != ~TDATA325)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~TDATA325);
+							}
+						break;
+					 case DDR_PATTERN_LOOP_2+0:
+		 case DDR_PATTERN_LOOP_2+1:
+		 case DDR_PATTERN_LOOP_2+2:
+		 case DDR_PATTERN_LOOP_2+3:
+			//		*(p+i) =0xfe01fe01;
+						if (*(p+i) !=~0xfe01fe01)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xfe01fe01);
+							}
+						break;
+					case DDR_PATTERN_LOOP_2+4:
+		 case DDR_PATTERN_LOOP_2+5:
+		 case DDR_PATTERN_LOOP_2+6:
+		 case DDR_PATTERN_LOOP_2+7:
+				// 	*(p+i) =0xfd02fd02;
+						if (*(p+i) != ~0xfd02fd02)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xfd02fd02);
+							}
+						break;
+
+				case DDR_PATTERN_LOOP_2+8:
+		 case DDR_PATTERN_LOOP_2+9:
+		 case DDR_PATTERN_LOOP_2+10:
+		 case DDR_PATTERN_LOOP_2+11:
+				//	*(p+i) =0xfb04fb04;
+				 if (*(p+i) != ~0xfb04fb04)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xfb04fb04);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+12:
+		 case DDR_PATTERN_LOOP_2+13:
+		 case DDR_PATTERN_LOOP_2+14:
+		 case DDR_PATTERN_LOOP_2+15:
+				//	*(p+i) =0xf7b08f708;
+					if (*(p+i) != ~0xf708f708)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xf708f708);
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+16:
+		 case DDR_PATTERN_LOOP_2+17:
+		 case DDR_PATTERN_LOOP_2+18:
+		 case DDR_PATTERN_LOOP_2+19:
+				//	*(p+i) =0xef10ef10;
+					if (*(p+i) != ~0xef10ef10)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xef10ef10);
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+20:
+		 case DDR_PATTERN_LOOP_2+21:
+		 case DDR_PATTERN_LOOP_2+22:
+		 case DDR_PATTERN_LOOP_2+23:
+				//	*(p+i) =0xdf20df20;
+					if (*(p+i) != ~0xdf20df20)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xdf20df20);
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+24:
+		 case DDR_PATTERN_LOOP_2+25:
+		 case DDR_PATTERN_LOOP_2+26:
+		 case DDR_PATTERN_LOOP_2+27:
+			 //		*(p+i) =0xbf40bf40;
+					if (*(p+i) != ~0xbf40bf40)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xbf40bf40);
+						}
+					break;
+				case DDR_PATTERN_LOOP_2+28:
+		 case DDR_PATTERN_LOOP_2+29:
+		 case DDR_PATTERN_LOOP_2+30:
+		 case DDR_PATTERN_LOOP_2+31:
+			//		*(p+i) =0x7f807f80;
+					if (*(p+i) != ~0x7f807f80)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x7f807f80);
+						}
+					break;
+					break;
+				case DDR_PATTERN_LOOP_3+0:
+		 case DDR_PATTERN_LOOP_3+1:
+		 case DDR_PATTERN_LOOP_3+2:
+		 case DDR_PATTERN_LOOP_3+3:
+				//	*(p+i) =0x00000100;
+						if (*(p+i) != ~0x00000100)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00000100);
+							}
+					break;
+				case DDR_PATTERN_LOOP_3+4:
+		 case DDR_PATTERN_LOOP_3+5:
+		 case DDR_PATTERN_LOOP_3+6:
+		 case DDR_PATTERN_LOOP_3+7:
+			 //		*(p+i) =0x00000100;
+					if (*(p+i) != ~0x00000200)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00000200);
+						}
+					break;
+				case DDR_PATTERN_LOOP_3+8:
+		 case DDR_PATTERN_LOOP_3+9:
+		 case DDR_PATTERN_LOOP_3+10:
+		 case DDR_PATTERN_LOOP_3+11:
+				//	*(p+i) =0x00000100;
+				 if (*(p+i) != ~0x00000400)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00000400);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+12:
+		 case DDR_PATTERN_LOOP_3+13:
+		 case DDR_PATTERN_LOOP_3+14:
+		 case DDR_PATTERN_LOOP_3+15:
+				//	*(p+i) =0x00000100;
+				 if (*(p+i) != ~0x00000800)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00000800);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+16:
+		 case DDR_PATTERN_LOOP_3+17:
+		 case DDR_PATTERN_LOOP_3+18:
+		 case DDR_PATTERN_LOOP_3+19:
+				//	*(p+i) =0xfffffeff;
+				 if (*(p+i) != ~0x00001000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00001000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+20:
+		 case DDR_PATTERN_LOOP_3+21:
+		 case DDR_PATTERN_LOOP_3+22:
+		 case DDR_PATTERN_LOOP_3+23:
+				// 	*(p+i) =0xfffffeff;
+				 if (*(p+i) != ~0x00002000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00002000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+24:
+		 case DDR_PATTERN_LOOP_3+25:
+		 case DDR_PATTERN_LOOP_3+26:
+		 case DDR_PATTERN_LOOP_3+27:
+				//	*(p+i) =0xfffffeff;
+				 if (*(p+i) != ~0x00004000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00004000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+28:
+		 case DDR_PATTERN_LOOP_3+29:
+		 case DDR_PATTERN_LOOP_3+30:
+		 case DDR_PATTERN_LOOP_3+31:
+				//	*(p+i) =0xfffffeff;
+				 if (*(p+i) != ~0x00008000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00008000);
+					}
+					break;
+
+
+
+				}
+			}
+
+			if (m_len > 128*4)
+			{
+				m_len -= 128*4;
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+
+//*/
+static void ddr_read_pattern4_cross_talk_n2(void *buff, unsigned m_length)
+{
+	unsigned *p;
+	//	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+			if ((error_outof_count_flag) && (error_count))
+				{
+				 printf("Error data out of count");
+				 m_len=0;
+				 break;
+				}
+
+				switch (i)
+				{
+					 case 0:
+			case DDR_PATTERN_LOOP_1+1:
+			case DDR_PATTERN_LOOP_2+2:
+			case DDR_PATTERN_LOOP_3+3:
+							//	*(p+i) = 0xfe01fe01;
+								if (*(p+i) != ~0xfe01fe01)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xfe01fe01);
+													break;
+							}
+									break;
+					 case 4:
+			case DDR_PATTERN_LOOP_1+5:
+			case DDR_PATTERN_LOOP_2+6:
+			case DDR_PATTERN_LOOP_3+7:
+					//		*(p+i) = 0xfd02fd02;
+								if (*(p+i) != ~0xfd02fd02)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xfd02fd02);
+													break;
+							}
+									 break;
+
+					 case 8:
+			case DDR_PATTERN_LOOP_1+9:
+			case DDR_PATTERN_LOOP_2+10:
+			case DDR_PATTERN_LOOP_3+11:
+						//	*(p+i) = 0xfb04fb04;
+								if (*(p+i) != ~0xfb04fb04)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xfb04fb04);
+													break;
+							}
+						break;
+
+					 case 12:
+			case DDR_PATTERN_LOOP_1+13:
+			case DDR_PATTERN_LOOP_2+14:
+			case DDR_PATTERN_LOOP_3+15:
+					//		*(p+i) = 0xf708f708;
+								if (*(p+i) != ~0xf708f708)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xf708f708);
+													break;
+							}
+						break;
+
+					 case 16:
+			case DDR_PATTERN_LOOP_1+17:
+			case DDR_PATTERN_LOOP_2+18:
+			case DDR_PATTERN_LOOP_3+19:
+					//		*(p+i) = 0xef10ef10;
+								if (*(p+i) != ~0xef10ef10)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xef10ef10);
+													break;
+							}
+						break;
+
+					 case 20:
+			case DDR_PATTERN_LOOP_1+21:
+			case DDR_PATTERN_LOOP_2+22:
+			case DDR_PATTERN_LOOP_3+23:
+						//	*(p+i) = 0xdf20df20;
+								if (*(p+i) != ~0xdf20df20)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xdf20df20);
+													break;
+							}
+						break;
+
+					 case 24:
+			case DDR_PATTERN_LOOP_1+25:
+			case DDR_PATTERN_LOOP_2+26:
+			case DDR_PATTERN_LOOP_3+27:
+					//		*(p+i) = 0xbf40bf40;
+								if (*(p+i) != ~0xbf40bf40)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xbf40bf40);
+													break;
+							}
+								break;
+						case 28:
+			case DDR_PATTERN_LOOP_1+29:
+			case DDR_PATTERN_LOOP_2+30:
+			case DDR_PATTERN_LOOP_3+31:
+					//		*(p+i) = 0x7f807f80;
+								if (*(p+i) != ~0x7f807f80)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x7f807f80);
+													break;
+							}
+						break;
+
+
+				default:
+
+						//	*(p+i) = 0xff00ff00;
+							 if (*(p+i) != ~0xff00ff00)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ff00);
+													break;
+							}
+						break;
+
+						break;
+
+
+				}
+			}
+
+			if (m_len > 128*4)
+			{
+				m_len -= 128*4;
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+static void ddr_write_pattern4_no_cross_talk(void *buff, unsigned m_length)
+{
+	unsigned *p;
+ //	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+//#define ddr_pattern_loop 32
+	p = (unsigned *)buff;
+
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+				switch (i)
+				{
+					case 0:
+					case 1:
+					case 2:
+					case 3:
+				 *(p+i) = 0xff00ff00;
+					 break;
+				case 4:
+					case 5:
+					case 6:
+					case 7:
+				 *(p+i) = 0xffff0000;
+					 break;
+
+					case 8:
+					case 9:
+					case 10:
+					case 11:
+				 *(p+i) = 0xff000000;
+					 break;
+				case 12:
+					case 13:
+					case 14:
+					case 15:
+				 *(p+i) = 0xff00ffff;
+					 break;
+
+				case 16:
+					case 17:
+					case 18:
+					case 19:
+				 *(p+i) = 0xff00ffff;
+					 break;
+				case 20:
+					case 21:
+					case 22:
+					case 23:
+					*(p+i) = 0xff0000ff;
+							break;
+					case 24:
+					case 25:
+					case 26:
+					case 27:
+					*(p+i) = 0xffff0000;
+						break;
+
+				case 28:
+					case 29:
+					case 30:
+					case 31:
+								 *(p+i) = 0x00ff00ff;
+							break;
+				case DDR_PATTERN_LOOP_1+0:
+		 case DDR_PATTERN_LOOP_1+1:
+		 case DDR_PATTERN_LOOP_1+2:
+		 case DDR_PATTERN_LOOP_1+3:
+					*(p+i) =~0xff00ff00;
+					break;
+				case DDR_PATTERN_LOOP_1+4:
+		 case DDR_PATTERN_LOOP_1+5:
+		 case DDR_PATTERN_LOOP_1+6:
+		 case DDR_PATTERN_LOOP_1+7:
+					*(p+i) =~0xffff0000;
+					break;
+				case DDR_PATTERN_LOOP_1+8:
+		 case DDR_PATTERN_LOOP_1+9:
+		 case DDR_PATTERN_LOOP_1+10:
+		 case DDR_PATTERN_LOOP_1+11:
+					*(p+i) =~0xff000000;
+					break;
+				case DDR_PATTERN_LOOP_1+12:
+		 case DDR_PATTERN_LOOP_1+13:
+		 case DDR_PATTERN_LOOP_1+14:
+		 case DDR_PATTERN_LOOP_1+15:
+					*(p+i) =~0xff00ffff;
+					break;
+				case DDR_PATTERN_LOOP_1+16:
+		 case DDR_PATTERN_LOOP_1+17:
+		 case DDR_PATTERN_LOOP_1+18:
+		 case DDR_PATTERN_LOOP_1+19:
+					*(p+i) =~0xff00ffff;
+					break;
+				case DDR_PATTERN_LOOP_1+20:
+		 case DDR_PATTERN_LOOP_1+21:
+		 case DDR_PATTERN_LOOP_1+22:
+		 case DDR_PATTERN_LOOP_1+23:
+					*(p+i) =~0xff00ffff;
+					break;
+				case DDR_PATTERN_LOOP_1+24:
+		 case DDR_PATTERN_LOOP_1+25:
+		 case DDR_PATTERN_LOOP_1+26:
+		 case DDR_PATTERN_LOOP_1+27:
+					*(p+i) =~0xffff0000;
+					break;
+				case DDR_PATTERN_LOOP_1+28:
+		 case DDR_PATTERN_LOOP_1+29:
+		 case DDR_PATTERN_LOOP_1+30:
+		 case DDR_PATTERN_LOOP_1+31:
+					*(p+i) =~0x00ff00ff;
+					break;
+
+				case DDR_PATTERN_LOOP_2+0:
+		 case DDR_PATTERN_LOOP_2+1:
+		 case DDR_PATTERN_LOOP_2+2:
+		 case DDR_PATTERN_LOOP_2+3:
+					*(p+i) =0x00ff0000;
+					break;
+				case DDR_PATTERN_LOOP_2+4:
+		 case DDR_PATTERN_LOOP_2+5:
+		 case DDR_PATTERN_LOOP_2+6:
+		 case DDR_PATTERN_LOOP_2+7:
+					*(p+i) =0xff000000;
+					break;
+				case DDR_PATTERN_LOOP_2+8:
+		 case DDR_PATTERN_LOOP_2+9:
+		 case DDR_PATTERN_LOOP_2+10:
+		 case DDR_PATTERN_LOOP_2+11:
+					*(p+i) =0x0000ffff;
+					break;
+				case DDR_PATTERN_LOOP_2+12:
+		 case DDR_PATTERN_LOOP_2+13:
+		 case DDR_PATTERN_LOOP_2+14:
+		 case DDR_PATTERN_LOOP_2+15:
+					*(p+i) =0x000000ff;
+					break;
+				case DDR_PATTERN_LOOP_2+16:
+		 case DDR_PATTERN_LOOP_2+17:
+		 case DDR_PATTERN_LOOP_2+18:
+		 case DDR_PATTERN_LOOP_2+19:
+					*(p+i) =0x00ff00ff;
+					break;
+				case DDR_PATTERN_LOOP_2+20:
+		 case DDR_PATTERN_LOOP_2+21:
+		 case DDR_PATTERN_LOOP_2+22:
+		 case DDR_PATTERN_LOOP_2+23:
+					*(p+i) =0xff00ff00;
+					break;
+				case DDR_PATTERN_LOOP_2+24:
+		 case DDR_PATTERN_LOOP_2+25:
+		 case DDR_PATTERN_LOOP_2+26:
+		 case DDR_PATTERN_LOOP_2+27:
+					*(p+i) =0xff00ffff;
+					break;
+				case DDR_PATTERN_LOOP_2+28:
+		 case DDR_PATTERN_LOOP_2+29:
+		 case DDR_PATTERN_LOOP_2+30:
+		 case DDR_PATTERN_LOOP_2+31:
+					*(p+i) =0xff00ff00;
+					break;
+				case DDR_PATTERN_LOOP_3+0:
+		 case DDR_PATTERN_LOOP_3+1:
+		 case DDR_PATTERN_LOOP_3+2:
+		 case DDR_PATTERN_LOOP_3+3:
+					*(p+i) =~0x00ff0000;
+					break;
+				case DDR_PATTERN_LOOP_3+4:
+		 case DDR_PATTERN_LOOP_3+5:
+		 case DDR_PATTERN_LOOP_3+6:
+		 case DDR_PATTERN_LOOP_3+7:
+					*(p+i) =~0xff000000;
+					break;
+				case DDR_PATTERN_LOOP_3+8:
+		 case DDR_PATTERN_LOOP_3+9:
+		 case DDR_PATTERN_LOOP_3+10:
+		 case DDR_PATTERN_LOOP_3+11:
+					*(p+i) =~0x0000ffff;
+					break;
+				case DDR_PATTERN_LOOP_3+12:
+		 case DDR_PATTERN_LOOP_3+13:
+		 case DDR_PATTERN_LOOP_3+14:
+		 case DDR_PATTERN_LOOP_3+15:
+					*(p+i) =~0x000000ff;
+					break;
+				case DDR_PATTERN_LOOP_3+16:
+		 case DDR_PATTERN_LOOP_3+17:
+		 case DDR_PATTERN_LOOP_3+18:
+		 case DDR_PATTERN_LOOP_3+19:
+					*(p+i) =~0x00ff00ff;
+					break;
+				case DDR_PATTERN_LOOP_3+20:
+		 case DDR_PATTERN_LOOP_3+21:
+		 case DDR_PATTERN_LOOP_3+22:
+		 case DDR_PATTERN_LOOP_3+23:
+					*(p+i) =~0xff00ff00;
+					break;
+				case DDR_PATTERN_LOOP_3+24:
+		 case DDR_PATTERN_LOOP_3+25:
+		 case DDR_PATTERN_LOOP_3+26:
+		 case DDR_PATTERN_LOOP_3+27:
+					*(p+i) =~0xff00ffff;
+					break;
+				case DDR_PATTERN_LOOP_3+28:
+		 case DDR_PATTERN_LOOP_3+29:
+		 case DDR_PATTERN_LOOP_3+30:
+		 case DDR_PATTERN_LOOP_3+31:
+					*(p+i) =~0xff00ff00;
+					break;
+
+
+				}
+			}
+
+			if (m_len >( 128*4))
+			{
+				m_len -=( 128*4);
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+static void ddr_read_pattern4_no_cross_talk(void *buff, unsigned m_length)
+{
+	unsigned *p;
+	//	unsigned i, j, n;
+	 unsigned i, n;
+	unsigned m_len = m_length;
+
+	p = (unsigned *)buff;
+	while (m_len)
+	{
+		//	for(j=0;j<32;j++)
+		{
+			if (m_len >= 128*4)
+				n = 32*4;
+			else
+				n = m_len>>2;
+
+			for (i = 0; i < n; i++)
+			{
+				if ((error_outof_count_flag) && (error_count))
+				{
+				 printf("Error data out of count");
+				 m_len=0;
+					break;
+				}
+				switch (i)
+				{
+					case 0:
+					case 1:
+					case 2:
+					case 3:
+					//		if(*(p+i) !=~TDATA32F)
+
+				if ( *(p+i) != 0xff00ff00)
+					{error_count++;
+					printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff00ff00);
+					}
+									 break;
+				case 4:
+					case 5:
+					case 6:
+					case 7:
+						if ( *(p+i) != 0xffff0000)
+							{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xffff0000);
+							}
+					 break;
+
+					case 8:
+					case 9:
+					case 10:
+					case 11:
+				// *(p+i) = 0xff000000;
+				 if ( *(p+i) != 0xff000000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff000000);
+					}
+					 break;
+				case 12:
+					case 13:
+					case 14:
+					case 15:
+				// *(p+i) = 0xff00ffff;
+				 if ( *(p+i) != 0xff00ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff00ffff);
+					}
+					 break;
+
+				case 16:
+					case 17:
+					case 18:
+					case 19:
+			//	 *(p+i) = 0xff00ffff;
+				 if ( *(p+i) != 0xff00ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff00ffff);
+					}
+					 break;
+				case 20:
+					case 21:
+					case 22:
+					case 23:
+				//	*(p+i) = 0xff0000ff;
+					if ( *(p+i) != 0xff0000ff)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff0000ff);
+						}
+							break;
+					case 24:
+					case 25:
+					case 26:
+					case 27:
+				//	*(p+i) = 0xffff0000;
+					if ( *(p+i) != 0xffff0000)
+						{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xffff0000);
+						}
+						break;
+
+				case 28:
+					case 29:
+					case 30:
+					case 31:
+								//	*(p+i) = 0x00ff00ff;
+								 if ( *(p+i) != 0x00ff00ff)
+									{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00ff00ff);
+									}
+							break;
+				case DDR_PATTERN_LOOP_1+0:
+		 case DDR_PATTERN_LOOP_1+1:
+		 case DDR_PATTERN_LOOP_1+2:
+		 case DDR_PATTERN_LOOP_1+3:
+			 //		*(p+i) =~0xff00ff00;
+				if ( *(p+i) != ~0xff00ff00)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ff00);
+					}
+					break;
+				case DDR_PATTERN_LOOP_1+4:
+		 case DDR_PATTERN_LOOP_1+5:
+		 case DDR_PATTERN_LOOP_1+6:
+		 case DDR_PATTERN_LOOP_1+7:
+				// 	*(p+i) =~0xffff0000;
+				if ( *(p+i) != ~0xffff0000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xffff0000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_1+8:
+		 case DDR_PATTERN_LOOP_1+9:
+		 case DDR_PATTERN_LOOP_1+10:
+		 case DDR_PATTERN_LOOP_1+11:
+				// 	*(p+i) =~0xff000000;
+				if ( *(p+i) != ~0xff000000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff000000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_1+12:
+		 case DDR_PATTERN_LOOP_1+13:
+		 case DDR_PATTERN_LOOP_1+14:
+		 case DDR_PATTERN_LOOP_1+15:
+				//	*(p+i) =~0xff00ffff;
+				if ( *(p+i) != ~0xff00ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ffff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_1+16:
+		 case DDR_PATTERN_LOOP_1+17:
+		 case DDR_PATTERN_LOOP_1+18:
+		 case DDR_PATTERN_LOOP_1+19:
+				//	*(p+i) =~0xff00ffff;
+				if ( *(p+i) != ~0xff00ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ffff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_1+20:
+		 case DDR_PATTERN_LOOP_1+21:
+		 case DDR_PATTERN_LOOP_1+22:
+		 case DDR_PATTERN_LOOP_1+23:
+				//	*(p+i) =~0xff00ffff;
+				if ( *(p+i) != ~0xff00ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ffff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_1+24:
+		 case DDR_PATTERN_LOOP_1+25:
+		 case DDR_PATTERN_LOOP_1+26:
+		 case DDR_PATTERN_LOOP_1+27:
+				//	*(p+i) =~0xffff0000;
+				if ( *(p+i) != ~0xffff0000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xffff0000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_1+28:
+		 case DDR_PATTERN_LOOP_1+29:
+		 case DDR_PATTERN_LOOP_1+30:
+		 case DDR_PATTERN_LOOP_1+31:
+			 //		*(p+i) =~0x00ff00ff;
+				if ( *(p+i) != ~0x00ff00ff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00ff00ff);
+					}
+					break;
+
+				case DDR_PATTERN_LOOP_2+0:
+		 case DDR_PATTERN_LOOP_2+1:
+		 case DDR_PATTERN_LOOP_2+2:
+		 case DDR_PATTERN_LOOP_2+3:
+			 //		*(p+i) =0x00ff0000;
+				if ( *(p+i) != 0x00ff0000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00ff0000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+4:
+		 case DDR_PATTERN_LOOP_2+5:
+		 case DDR_PATTERN_LOOP_2+6:
+		 case DDR_PATTERN_LOOP_2+7:
+			//		*(p+i) =0xff000000;
+				if ( *(p+i) != 0xff000000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff000000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+8:
+		 case DDR_PATTERN_LOOP_2+9:
+		 case DDR_PATTERN_LOOP_2+10:
+		 case DDR_PATTERN_LOOP_2+11:
+				// 	*(p+i) =0x0000ffff;
+				if ( *(p+i) != 0x0000ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x0000ffff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+12:
+		 case DDR_PATTERN_LOOP_2+13:
+		 case DDR_PATTERN_LOOP_2+14:
+		 case DDR_PATTERN_LOOP_2+15:
+			//		*(p+i) =0x000000ff;
+				if ( *(p+i) != 0x000000ff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x000000ff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+16:
+		 case DDR_PATTERN_LOOP_2+17:
+		 case DDR_PATTERN_LOOP_2+18:
+		 case DDR_PATTERN_LOOP_2+19:
+			//		*(p+i) =0x00ff00ff;
+				if ( *(p+i) != 0x00ff00ff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0x00ff00ff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+20:
+		 case DDR_PATTERN_LOOP_2+21:
+		 case DDR_PATTERN_LOOP_2+22:
+		 case DDR_PATTERN_LOOP_2+23:
+				//	*(p+i) =0xff00ff00;
+				if ( *(p+i) != 0xff00ff00)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff00ff00);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+24:
+		 case DDR_PATTERN_LOOP_2+25:
+		 case DDR_PATTERN_LOOP_2+26:
+		 case DDR_PATTERN_LOOP_2+27:
+			//		*(p+i) =0xff00ffff;
+				if ( *(p+i) != 0xff00ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff00ffff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_2+28:
+		 case DDR_PATTERN_LOOP_2+29:
+		 case DDR_PATTERN_LOOP_2+30:
+		 case DDR_PATTERN_LOOP_2+31:
+		//			*(p+i) =0xff00ff00;
+				if ( *(p+i) != 0xff00ff00)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), 0xff00ff00);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+0:
+		 case DDR_PATTERN_LOOP_3+1:
+		 case DDR_PATTERN_LOOP_3+2:
+		 case DDR_PATTERN_LOOP_3+3:
+				//	*(p+i) =~0x00ff0000;
+				if ( *(p+i) != ~0x00ff0000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00ff0000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+4:
+		 case DDR_PATTERN_LOOP_3+5:
+		 case DDR_PATTERN_LOOP_3+6:
+		 case DDR_PATTERN_LOOP_3+7:
+			//		*(p+i) =~0xff000000;
+				if ( *(p+i) != ~0xff000000)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff000000);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+8:
+		 case DDR_PATTERN_LOOP_3+9:
+		 case DDR_PATTERN_LOOP_3+10:
+		 case DDR_PATTERN_LOOP_3+11:
+			 //		*(p+i) =~0x0000ffff;
+				if ( *(p+i) != ~0x0000ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x0000ffff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+12:
+		 case DDR_PATTERN_LOOP_3+13:
+		 case DDR_PATTERN_LOOP_3+14:
+		 case DDR_PATTERN_LOOP_3+15:
+			//		*(p+i) =~0x000000ff;
+				if ( *(p+i) != ~0x000000ff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x000000ff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+16:
+		 case DDR_PATTERN_LOOP_3+17:
+		 case DDR_PATTERN_LOOP_3+18:
+		 case DDR_PATTERN_LOOP_3+19:
+			//		*(p+i) =~0x00ff00ff;
+				if ( *(p+i) != ~0x00ff00ff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0x00ff00ff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+20:
+		 case DDR_PATTERN_LOOP_3+21:
+		 case DDR_PATTERN_LOOP_3+22:
+		 case DDR_PATTERN_LOOP_3+23:
+				//	*(p+i) =~0xff00ff00;
+				if ( *(p+i) != ~0xff00ff00)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ff00);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+24:
+		 case DDR_PATTERN_LOOP_3+25:
+		 case DDR_PATTERN_LOOP_3+26:
+		 case DDR_PATTERN_LOOP_3+27:
+			 //		*(p+i) =~0xff00ffff;
+				if ( *(p+i) != ~0xff00ffff)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ffff);
+					}
+					break;
+				case DDR_PATTERN_LOOP_3+28:
+		 case DDR_PATTERN_LOOP_3+29:
+		 case DDR_PATTERN_LOOP_3+30:
+		 case DDR_PATTERN_LOOP_3+31:
+			//		*(p+i) =~0xff00ff00;
+				if ( *(p+i) != ~0xff00ff00)
+					{error_count++;
+							printf("Error data [0x%08x] at offset 0x%08x[0x%08x]\n", *(p+i), (unsigned int)(unsigned long)(p + i), ~0xff00ff00);
+					}
+					break;
+
+
+				}
+			}
+
+			if (m_len >( 128*4))
+			{
+				m_len -=( 128*4);
+				p += 32*4;
+			}
+			else
+			{
+				p += (m_len>>2);
+				m_len = 0;
+				break;
+			}
+		}
+	}
+}
+
+#define DDR_TEST_START_ADDR	0x10000000 //CONFIG_SYS_MEMTEST_START
+#define DDR_TEST_SIZE 0x2000000
+//#define DDR_TEST_SIZE 0x2000
+
+int do_ddr_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *endp;
+	unsigned long loop = 1;
+	unsigned char lflag = 0;
+	unsigned start_addr = DDR_TEST_START_ADDR;
+	unsigned char simple_pattern_flag = 1;
+	unsigned char cross_talk_pattern_flag = 1;
+	unsigned char old_pattern_flag = 1;
+	error_outof_count_flag =0;
+	error_count =0;
+	printf("\nargc== 0x%08x\n", argc);
+	int i;
+	for (i = 0;i<argc;i++)
+		printf("\nargv[%d]=%s",i,argv[i]);
+
+	if (!argc)
+		goto DDR_TEST_START;
+
+	if (argc == 2)
+	{
+		if (strcmp(argv[1], "l") == 0) {
+			lflag = 1;
+		}
+		else if (strcmp(argv[1], "h") == 0){
+			goto usage;
+		}
+		else{
+			loop = simple_strtoul(argv[1], &endp, 10);
+			if (*argv[1] == 0 || *endp != 0)
+				loop = 1;
+		}
+	}
+
+	//printf("\nLINE== 0x%08x\n", __LINE__);
+	if (argc ==1) {
+		start_addr = DDR_TEST_START_ADDR;
+		loop = 1;
+	}
+	if (argc > 2) {
+	//start_addr = simple_strtoul(argv[2], &endp, 16);
+		if (*argv[2] == 0 || *endp != 0)
+			start_addr = DDR_TEST_START_ADDR;
+	}
+	old_pattern_flag = 1;
+	simple_pattern_flag = 1;
+	cross_talk_pattern_flag = 1;
+//printf("\nLINE== 0x%08x\n", __LINE__);
+	if (argc ==2) {
+		if ( (strcmp(argv[1], "s") == 0))
+		{
+			simple_pattern_flag = 1;
+			old_pattern_flag=0;
+			cross_talk_pattern_flag = 0;
+		}
+	else if ((strcmp(argv[1], "c") == 0))
+		{
+			simple_pattern_flag = 0;
+			old_pattern_flag=0;
+			cross_talk_pattern_flag = 1;
+		}
+	else if ( (strcmp(argv[1], "e") == 0))
+		{
+			error_outof_count_flag=1;
+		}
+	}
+	if (argc >2) {
+		if ( (strcmp(argv[1], "s") == 0) || (strcmp(argv[2], "s") == 0))
+		{
+			simple_pattern_flag = 1;
+			old_pattern_flag=0;
+			 cross_talk_pattern_flag = 0;
+		}
+	else if ((strcmp(argv[1], "c") == 0)||(strcmp(argv[2], "c") == 0))
+		{
+			simple_pattern_flag = 0;
+			old_pattern_flag=0;
+			 cross_talk_pattern_flag = 1;
+		}
+	else	if ( (strcmp(argv[1], "e") == 0)||(strcmp(argv[2], "e") == 0))
+		{
+			error_outof_count_flag=1;
+			}
+		}
+//printf("\nLINE1== 0x%08x\n", __LINE__);
+	if (argc > 3) {
+		if ((strcmp(argv[1], "s") == 0) || (strcmp(argv[2], "s") == 0) || (strcmp(argv[3], "s") == 0))
+		{
+			simple_pattern_flag = 1;
+			old_pattern_flag=0;
+			 cross_talk_pattern_flag = 0;
+		}
+		if ((strcmp(argv[1], "c") == 0) || (strcmp(argv[2], "c") == 0) || (strcmp(argv[3], "c") == 0))
+			{
+			simple_pattern_flag = 0;
+			old_pattern_flag=0;
+			cross_talk_pattern_flag = 1;
+		}
+		if ((strcmp(argv[1], "e") == 0) || (strcmp(argv[2], "e") == 0) || (strcmp(argv[3], "e") == 0))
+		{
+		error_outof_count_flag=1;
+		}
+	}
+
+		//	printf("\nLINE2== 0x%08x\n", __LINE__);
+		//	printf("\nLINE3== 0x%08x\n", __LINE__);
+		//	printf("\nLINE== 0x%08x\n", __LINE__);
+
+DDR_TEST_START:
+
+///*
+	do {
+		if (lflag)
+			loop = 888;
+
+		if (old_pattern_flag == 1)
+			{
+		//	printf("\nLINE== 0x%08x\n", __LINE__);
+//printf("\nLINE== 0x%08x\n", __LINE__);
+//printf("\nLINE== 0x%08x\n", __LINE__);
+		printf("\rStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + DDR_TEST_SIZE);
+		ddr_write((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 3rd read.								\n");
+			}
+
+
+if (simple_pattern_flag == 1)
+{
+			printf("\nStart *4 no cross talk pattern.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + DDR_TEST_SIZE);
+		ddr_write_pattern4_no_cross_talk((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_no_cross_talk((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_no_cross_talk((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read_pattern4_no_cross_talk((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 3rd read.								\n");
+}
+
+if (cross_talk_pattern_flag == 1)
+{
+			printf("\nStart *4	cross talk pattern p.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + DDR_TEST_SIZE);
+		ddr_write_pattern4_cross_talk_p((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_cross_talk_p((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_cross_talk_p((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read_pattern4_cross_talk_p((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 3rd read.								\n");
+
+				printf("\nStart *4	cross talk pattern n.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + DDR_TEST_SIZE);
+		ddr_write_pattern4_cross_talk_n((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_cross_talk_n((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_cross_talk_n((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read_pattern4_cross_talk_n((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 3rd read.								\n");
+
+///*
+					printf("\nStart *4	cross talk pattern p2.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + DDR_TEST_SIZE);
+		ddr_write_pattern4_cross_talk_p2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_cross_talk_p2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_cross_talk_p2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read_pattern4_cross_talk_p2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 3rd read.								\n");
+
+				printf("\nStart *4	cross talk pattern n2.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + DDR_TEST_SIZE);
+		ddr_write_pattern4_cross_talk_n2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_cross_talk_n2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_cross_talk_n2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read_pattern4_cross_talk_n2((void *)(unsigned long)start_addr, DDR_TEST_SIZE);
+		printf("\rEnd 3rd read.								\n");
+	//	*/
+
+}
+
+
+			printf("\Error count==0x%08x", error_count);
+			printf("\n		\n");
+		}while(--loop);
+//*/
+
+ printf("\rEnd ddr test.								\n");
+
+		return 0;
+
+usage:
+	cmd_usage(cmdtp);
+	return 1;
+}
+
+U_BOOT_CMD(
+	ddrtest,	5,	1,	do_ddr_test,
+	"DDR test function",
+	"ddrtest [LOOP] [ADDR].Default address is 0x8d000000\n"
+);
+
+/*
+
+int ddr_test_s_cross_talk_pattern(int ddr_test_size)
+{
+unsigned start_addr = DDR_TEST_START_ADDR;
+	error_outof_count_flag=1;
+		error_count=0;
+
+ printf("\rStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + ddr_test_size);
+		ddr_write((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read((void *)(unsigned long)start_addr, ddr_test_size);
+
+ printf("\nStart *4 no cross talk pattern.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + ddr_test_size);
+		ddr_write_pattern4_no_cross_talk((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_no_cross_talk((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_no_cross_talk((void *)(unsigned long)start_addr, ddr_test_size);
+
+//if(cross_talk_pattern_flag==1)
+{
+			printf("\nStart *4	cross talk pattern p.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + ddr_test_size);
+		ddr_write_pattern4_cross_talk_p((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_cross_talk_p((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_cross_talk_p((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read_pattern4_cross_talk_p((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 3rd read.								\n");
+
+				printf("\nStart *4	cross talk pattern n.								 ");
+			printf("\nStart writing at 0x%08x - 0x%08x...", start_addr, start_addr + ddr_test_size);
+		ddr_write_pattern4_cross_talk_n((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd write.								 ");
+		printf("\rStart 1st reading...						");
+		ddr_read_pattern4_cross_talk_n((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 1st read.								");
+		printf("\rStart 2nd reading...						");
+		ddr_read_pattern4_cross_talk_n((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 2nd read.								");
+		printf("\rStart 3rd reading...						");
+		ddr_read_pattern4_cross_talk_n((void *)(unsigned long)start_addr, ddr_test_size);
+		printf("\rEnd 3rd read.								\n");
+
+
+}
+
+if (error_count)
+	return 1;
+else
+	return 0;
+}
+
+
+int do_ddr_test_fine_tune_dqs(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	printf("\nEnter Tune ddr dqs function\n");
+ //	if(!argc)
+	//	goto DDR_TUNE_DQS_START;
+	printf("\nargc== 0x%08x\n", argc);
+ // unsigned	loop = 1;
+	unsigned	temp_count_i = 1;
+	unsigned	temp_count_j= 1;
+	unsigned	temp_count_k= 1;
+	unsigned	temp_test_error= 0;
+
+
+	 char *endp;
+ // unsigned	*p_start_addr;
+ unsigned	test_loop=1;
+	unsigned	test_times=1;
+	unsigned	reg_add=0;
+	unsigned	reg_base_adj=0;
+		 unsigned char channel_a_en = 0;
+		unsigned char channel_b_en = 0;
+		unsigned char testing_channel = 0;
+
+	 #define	DATX8_DQ_LCD_BDL_REG_WIDTH	12
+
+	 #define	DATX8_DQ_LANE_WIDTH	4
+	 #define	CHANNEL_CHANNEL_WIDTH	2
+
+		#define	CHANNEL_A	0
+		#define	CHANNEL_B	1
+
+		#define	CHANNEL_A_REG_BASE	0
+		#define	CHANNEL_B_REG_BASE	0x2000
+
+	#define	DATX8_DQ_LANE_LANE00	0
+	#define	DATX8_DQ_LANE_LANE01	1
+	#define	DATX8_DQ_LANE_LANE02	2
+	#define	DATX8_DQ_LANE_LANE03	3
+
+	 #define	DATX8_DQ_BDLR0	0
+	 #define	DATX8_DQ_BDLR1	1
+	 #define	DATX8_DQ_BDLR2	2
+	 #define	DATX8_DQ_BDLR3	3
+	 #define	DATX8_DQ_BDLR4	4
+	 #define	DATX8_DQ_BDLR5	5
+	 #define	DATX8_DQ_BDLR6	6
+	 #define	DATX8_DQ_DXNLCDLR0	 7
+	 #define	DATX8_DQ_DXNLCDLR1	 8
+	 #define	DATX8_DQ_DXNLCDLR2	 9
+	 #define	DATX8_DQ_DXNMDLR		10
+	 #define	DATX8_DQ_DXNGTR			11
+
+
+	 #define	DDR_CORSS_TALK_TEST_SIZE	0x20000
+
+	 #define	DQ_LCD_BDL_REG_NUM_PER_CHANNEL	DATX8_DQ_LCD_BDL_REG_WIDTH*DATX8_DQ_LANE_WIDTH
+		#define	DQ_LCD_BDL_REG_NUM	DQ_LCD_BDL_REG_NUM_PER_CHANNEL*CHANNEL_CHANNEL_WIDTH
+
+	 unsigned	dq_lcd_bdl_reg_org[DQ_LCD_BDL_REG_NUM];
+	 unsigned	dq_lcd_bdl_reg_left[DQ_LCD_BDL_REG_NUM];
+	 unsigned	dq_lcd_bdl_reg_right[DQ_LCD_BDL_REG_NUM];
+		unsigned	dq_lcd_bdl_reg_index[DQ_LCD_BDL_REG_NUM];
+
+	 unsigned	dq_lcd_bdl_reg_left_min[DQ_LCD_BDL_REG_NUM];
+	 unsigned	dq_lcd_bdl_reg_right_min[DQ_LCD_BDL_REG_NUM];
+
+		unsigned	dq_lcd_bdl_temp_reg_value;
+		unsigned	dq_lcd_bdl_temp_reg_value_dqs;
+	 unsigned	dq_lcd_bdl_temp_reg_value_wdqd;
+		unsigned	dq_lcd_bdl_temp_reg_value_rdqsd;
+		// unsigned	dq_lcd_bdl_temp_reg_value_rdqsnd;
+		unsigned	dq_lcd_bdl_temp_reg_lef_min_value;
+		unsigned	dq_lcd_bdl_temp_reg_rig_min_value;
+	//	unsigned	dq_lcd_bdl_temp_reg_value_dqs;
+	// unsigned	dq_lcd_bdl_temp_reg_value_wdqd;
+	//	unsigned	dq_lcd_bdl_temp_reg_value_rdqsd;
+
+		unsigned	dq_lcd_bdl_temp_reg_lef;
+		unsigned	dq_lcd_bdl_temp_reg_rig;
+		unsigned	dq_lcd_bdl_temp_reg_center;
+		unsigned	dq_lcd_bdl_temp_reg_windows;
+		 unsigned	dq_lcd_bdl_temp_reg_center_min;
+		unsigned	dq_lcd_bdl_temp_reg_windows_min;
+
+		unsigned	ddr_test_size= DDR_CORSS_TALK_TEST_SIZE;
+
+	//	#define DDR0_PUB_REG_BASE					0xc8836000
+		//	#define DDR1_PUB_REG_BASE					0xc8836000
+
+
+	 if (argc == 2)
+		{
+	if ((strcmp(argv[1], "a") == 0) || (strcmp(argv[1], "A") == 0))
+
+	{channel_a_en = 1;
+	}
+	else if	((strcmp(argv[1], "b") == 0)||(strcmp(argv[1], "B") == 0))
+
+	{channel_b_en = 1;
+	}
+	else
+		{
+	goto usage;
+		}
+		}
+		if (argc > 2)
+		{
+	if ((strcmp(argv[1], "a") == 0) || (strcmp(argv[1], "A") == 0) || (strcmp(argv[2], "a") == 0) || (strcmp(argv[2], "A") == 0))
+
+	{channel_a_en = 1;
+	}
+	 if	((strcmp(argv[1], "b") == 0) || (strcmp(argv[1], "B") == 0) || (strcmp(argv[2], "b") == 0) || (strcmp(argv[2], "B") == 0))
+
+	{channel_b_en = 1;
+	}
+			}
+			ddr_test_size = DDR_CORSS_TALK_TEST_SIZE;
+	if (argc >3) {
+	ddr_test_size = simple_strtoul(argv[3], &endp, 16);
+		if (*argv[3] == 0 || *endp != 0)
+			{
+			ddr_test_size = DDR_CORSS_TALK_TEST_SIZE;
+			}
+
+	}
+	if (argc >4) {
+	test_loop = simple_strtoul(argv[4], &endp, 16);
+		if (*argv[4] == 0 || *endp != 0)
+			{
+			test_loop = 1;
+			}
+		 if	((strcmp(argv[4], "l") == 0) || (strcmp(argv[4], "L") == 0))
+			{
+			test_loop = 100000;
+			}
+	}
+
+
+		 printf("\nchannel_a_en== 0x%08x\n", channel_a_en);
+		 printf("\nchannel_b_en== 0x%08x\n", channel_b_en);
+			printf("\nddr_test_size== 0x%08x\n", ddr_test_size);
+			printf("\ntest_loop== 0x%08x\n", test_loop);
+if ( channel_a_en)
+{
+writel((readl(P_DDR0_CLK_CTRL)|0x12b), P_DDR0_CLK_CTRL);
+}
+if ( channel_b_en)
+{
+writel((readl(P_DDR1_CLK_CTRL)|0x12b), P_DDR1_CLK_CTRL);
+}
+
+
+//save and print org training dqs value
+if (channel_a_en || channel_b_en)
+{
+
+
+	//dcache_disable();
+ //serial_puts("\ndebug for ddrtest ,jiaxing disable dcache");
+
+{
+for ((testing_channel=0);(testing_channel<(channel_a_en+channel_b_en));(testing_channel++))
+{
+if (( channel_a_en) && ( channel_b_en == 0))
+{
+reg_base_adj=CHANNEL_A_REG_BASE;
+}
+else if(( channel_b_en)&&( channel_a_en==0))
+{
+reg_base_adj=CHANNEL_B_REG_BASE;
+}
+else if ((channel_a_en+channel_b_en)==2)
+ {
+if ( testing_channel == CHANNEL_A)
+	{
+reg_base_adj=CHANNEL_A_REG_BASE;
+	}
+else if( testing_channel==CHANNEL_B)
+	{
+reg_base_adj=CHANNEL_B_REG_BASE;
+	}
+ }
+
+for ((temp_count_i=0);(temp_count_i<DATX8_DQ_LANE_WIDTH);(temp_count_i++))
+	{
+
+	if (temp_count_i == DATX8_DQ_LANE_LANE00)
+		{
+	reg_add=P_DDR0_PUB_DX0BDLR0+reg_base_adj;}
+
+		else	if(temp_count_i==DATX8_DQ_LANE_LANE01)
+		{
+	reg_add=P_DDR0_PUB_DX1BDLR0+reg_base_adj;}
+
+	else		 if(temp_count_i==DATX8_DQ_LANE_LANE02)
+		{
+	reg_add=P_DDR0_PUB_DX2BDLR0+reg_base_adj;}
+	 else	if(temp_count_i==DATX8_DQ_LANE_LANE03)
+		{
+	reg_add=P_DDR0_PUB_DX3BDLR0+reg_base_adj;}
+
+
+
+		for ((temp_count_j=0);(temp_count_j<DATX8_DQ_LCD_BDL_REG_WIDTH);(temp_count_j++))
+		{
+		dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j]=readl(reg_add+4*temp_count_j);
+dq_lcd_bdl_reg_index[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j]=reg_add+4*temp_count_j;
+		printf("\n org add	0x%08x reg== 0x%08x\n",(reg_add+4*temp_count_j), (dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j]));
+dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j]
+ =dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j];
+dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j]
+ =dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j];
+
+		}
+	}
+
+}
+
+}
+
+}////save and print org training dqs value
+
+
+for (test_times=0;(test_times<test_loop);(test_times++))
+{
+////tune and save training dqs value
+if (channel_a_en || channel_b_en)
+
+{
+for ((testing_channel=0);(testing_channel<(channel_a_en+channel_b_en));(testing_channel++))
+{
+
+if (( channel_a_en) && ( channel_b_en == 0))
+{
+reg_base_adj=CHANNEL_A_REG_BASE;
+}
+else if(( channel_b_en)&&( channel_a_en==0))
+{
+reg_base_adj=CHANNEL_B_REG_BASE;
+}
+else if ((channel_a_en+channel_b_en)==2)
+ {
+if ( testing_channel == CHANNEL_A)
+	{
+reg_base_adj=CHANNEL_A_REG_BASE;
+	}
+else if( testing_channel==CHANNEL_B)
+	{
+reg_base_adj=CHANNEL_B_REG_BASE;
+	}
+ }
+
+for ((temp_count_i=0);(temp_count_i<DATX8_DQ_LANE_WIDTH);(temp_count_i++))
+{
+	{
+
+	if (temp_count_i == DATX8_DQ_LANE_LANE00)
+		{
+	reg_add=P_DDR0_PUB_DX0BDLR0+reg_base_adj;}
+
+		else	if(temp_count_i==DATX8_DQ_LANE_LANE01)
+		{
+	reg_add=P_DDR0_PUB_DX1BDLR0+reg_base_adj;}
+
+	else		 if(temp_count_i==DATX8_DQ_LANE_LANE02)
+		{
+	reg_add=P_DDR0_PUB_DX2BDLR0+reg_base_adj;}
+	 else	if(temp_count_i==DATX8_DQ_LANE_LANE03)
+		{
+	reg_add=P_DDR0_PUB_DX3BDLR0+reg_base_adj;}
+}
+
+	for ((temp_count_k=0);(temp_count_k<2);(temp_count_k++))
+		{
+
+if (temp_count_k == 0)
+{
+	dq_lcd_bdl_temp_reg_value_dqs=readl(reg_add+4*DATX8_DQ_DXNLCDLR1);
+		dq_lcd_bdl_temp_reg_value_wdqd=(dq_lcd_bdl_temp_reg_value_dqs&0xff);
+		dq_lcd_bdl_temp_reg_value_rdqsd=((dq_lcd_bdl_temp_reg_value_dqs&0xff00))>>8;
+	 //	dq_lcd_bdl_temp_reg_value_rdqsnd=((dq_lcd_bdl_temp_reg_value_dqs&0xff0000))>>16;
+
+while (dq_lcd_bdl_temp_reg_value_wdqd>0)
+{
+temp_test_error=0;
+dq_lcd_bdl_temp_reg_value_wdqd--;
+	dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+	 writel(dq_lcd_bdl_temp_reg_value_dqs,(reg_add+4*DATX8_DQ_DXNLCDLR1));
+	temp_test_error=ddr_test_s_cross_talk_pattern(ddr_test_size);
+	if (temp_test_error)
+		{
+		//printf("\nwdqd left edge detect \n");
+		dq_lcd_bdl_temp_reg_value_wdqd++;
+		break;
+		}
+}
+printf("\nwdqd left edge detect \n");
+printf("\nwdqd left edge==0x%08x\n ",dq_lcd_bdl_temp_reg_value_wdqd);
+dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+//only update dq_lcd_bdl_temp_reg_value_wdqd
+dq_lcd_bdl_temp_reg_value=dq_lcd_bdl_reg_left[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+dq_lcd_bdl_temp_reg_value_dqs=((dq_lcd_bdl_temp_reg_value&0x00)|dq_lcd_bdl_temp_reg_value_wdqd);
+dq_lcd_bdl_reg_left[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]=dq_lcd_bdl_temp_reg_value_dqs;
+
+
+dq_lcd_bdl_temp_reg_lef_min_value=dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+if (dq_lcd_bdl_temp_reg_value_wdqd>(dq_lcd_bdl_temp_reg_lef_min_value&0xff)) 	//update wdqd min value
+{
+dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]
+=((dq_lcd_bdl_temp_reg_lef_min_value&0xffff00)|dq_lcd_bdl_temp_reg_value_wdqd)	;
+}
+
+
+writel(dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1],(reg_add+4*DATX8_DQ_DXNLCDLR1));
+
+ dq_lcd_bdl_temp_reg_value_dqs=readl(reg_add+4*DATX8_DQ_DXNLCDLR1);
+		dq_lcd_bdl_temp_reg_value_wdqd=(dq_lcd_bdl_temp_reg_value_dqs&0xff);
+		dq_lcd_bdl_temp_reg_value_rdqsd=((dq_lcd_bdl_temp_reg_value_dqs&0xff00))>>8;
+
+
+while (dq_lcd_bdl_temp_reg_value_wdqd<0xff)
+{
+temp_test_error=0;
+dq_lcd_bdl_temp_reg_value_wdqd++;
+	dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+	 writel(dq_lcd_bdl_temp_reg_value_dqs,(reg_add+4*DATX8_DQ_DXNLCDLR1));
+	temp_test_error=ddr_test_s_cross_talk_pattern(ddr_test_size);
+	if (temp_test_error)
+		{
+		//printf("\nwdqd right edge detect \n");
+		dq_lcd_bdl_temp_reg_value_wdqd--;
+		break;
+		}
+}
+printf("\nwdqd right edge detect \n");
+printf("\nwdqd right edge==0x%08x\n ",dq_lcd_bdl_temp_reg_value_wdqd);
+dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+//only update dq_lcd_bdl_temp_reg_value_wdqd
+dq_lcd_bdl_temp_reg_value=dq_lcd_bdl_reg_right[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+dq_lcd_bdl_temp_reg_value_dqs=((dq_lcd_bdl_temp_reg_value&0x00)|dq_lcd_bdl_temp_reg_value_wdqd);
+
+dq_lcd_bdl_reg_right[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]=dq_lcd_bdl_temp_reg_value_dqs;
+
+dq_lcd_bdl_temp_reg_rig_min_value=dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+if (dq_lcd_bdl_temp_reg_value_wdqd<(dq_lcd_bdl_temp_reg_rig_min_value&0xff)) 	//update wdqd min value
+{
+dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]
+=((dq_lcd_bdl_temp_reg_rig_min_value&0xffff00)|dq_lcd_bdl_temp_reg_value_wdqd)	;
+}
+
+
+
+writel(dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1],(reg_add+4*DATX8_DQ_DXNLCDLR1));
+
+
+}
+else if(temp_count_k==1)
+{
+
+ dq_lcd_bdl_temp_reg_value_dqs=readl(reg_add+4*DATX8_DQ_DXNLCDLR1);
+		dq_lcd_bdl_temp_reg_value_wdqd=(dq_lcd_bdl_temp_reg_value_dqs&0xff);
+		dq_lcd_bdl_temp_reg_value_rdqsd=((dq_lcd_bdl_temp_reg_value_dqs&0xff00))>>8;
+
+while (dq_lcd_bdl_temp_reg_value_rdqsd>0)
+{
+temp_test_error=0;
+dq_lcd_bdl_temp_reg_value_rdqsd--;
+	dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+	 writel(dq_lcd_bdl_temp_reg_value_dqs,(reg_add+4*DATX8_DQ_DXNLCDLR1));
+	temp_test_error=ddr_test_s_cross_talk_pattern(ddr_test_size);
+	if (temp_test_error)
+		{
+		//printf("\nrdqsd left edge detect \n");
+		dq_lcd_bdl_temp_reg_value_rdqsd++;
+		break;
+		}
+}
+printf("\nrdqsd left edge detect \n");
+printf("\nrdqsd left edge==0x%08x\n ",dq_lcd_bdl_temp_reg_value_rdqsd);
+dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+//only update dq_lcd_bdl_temp_reg_value_rdqsd rdqsnd
+dq_lcd_bdl_temp_reg_value=dq_lcd_bdl_reg_left[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+dq_lcd_bdl_temp_reg_value_dqs=((dq_lcd_bdl_temp_reg_value&0x0000ff)|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+
+dq_lcd_bdl_reg_left[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]=dq_lcd_bdl_temp_reg_value_dqs;
+
+
+dq_lcd_bdl_temp_reg_lef_min_value=dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+if (dq_lcd_bdl_temp_reg_value_rdqsd>((dq_lcd_bdl_temp_reg_lef_min_value>>8)&0xff)) 	//update wdqd min value
+{
+dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]
+=((dq_lcd_bdl_temp_reg_lef_min_value&0xff)|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16))	;
+}
+
+
+writel(dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1],(reg_add+4*DATX8_DQ_DXNLCDLR1));
+
+ dq_lcd_bdl_temp_reg_value_dqs=readl(reg_add+4*DATX8_DQ_DXNLCDLR1);
+		dq_lcd_bdl_temp_reg_value_wdqd=(dq_lcd_bdl_temp_reg_value_dqs&0xff);
+		dq_lcd_bdl_temp_reg_value_rdqsd=((dq_lcd_bdl_temp_reg_value_dqs&0xff00))>>8;
+
+while (dq_lcd_bdl_temp_reg_value_rdqsd<0xff)
+{
+temp_test_error=0;
+dq_lcd_bdl_temp_reg_value_rdqsd++;
+	dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+	 writel(dq_lcd_bdl_temp_reg_value_dqs,(reg_add+4*DATX8_DQ_DXNLCDLR1));
+	temp_test_error=ddr_test_s_cross_talk_pattern(ddr_test_size);
+	if (temp_test_error)
+		{
+		//printf("\nrdqsd right edge detect \n");
+		dq_lcd_bdl_temp_reg_value_rdqsd--;
+		break;
+		}
+}
+printf("\nrdqsd right edge detect \n");
+printf("\nrdqsd right edge==0x%08x\n ",dq_lcd_bdl_temp_reg_value_rdqsd);
+dq_lcd_bdl_temp_reg_value_dqs=(dq_lcd_bdl_temp_reg_value_wdqd|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+//only update dq_lcd_bdl_temp_reg_value_rdqsd rdqsnd
+dq_lcd_bdl_temp_reg_value=dq_lcd_bdl_reg_right[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+dq_lcd_bdl_temp_reg_value_dqs=((dq_lcd_bdl_temp_reg_value&0x0000ff)|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16));
+dq_lcd_bdl_reg_right[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]=dq_lcd_bdl_temp_reg_value_dqs;
+
+
+dq_lcd_bdl_temp_reg_rig_min_value=dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1];
+if (dq_lcd_bdl_temp_reg_value_rdqsd<((dq_lcd_bdl_temp_reg_rig_min_value>>8)&0xff)) 	//update wdqd min value
+{
+dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]
+=((dq_lcd_bdl_temp_reg_rig_min_value&0xff)|(dq_lcd_bdl_temp_reg_value_rdqsd<<8)|(dq_lcd_bdl_temp_reg_value_rdqsd<<16))	;
+}
+
+
+
+writel(dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1],(reg_add+4*DATX8_DQ_DXNLCDLR1));
+
+
+
+
+	}
+
+ }
+}
+
+}
+}
+
+////tune and save training dqs value
+
+
+
+
+////calculate and print	dqs value
+for ((testing_channel=0);(testing_channel<(channel_a_en+channel_b_en));(testing_channel++))
+{
+if (( channel_a_en) && ( channel_b_en == 0))
+{
+reg_base_adj=CHANNEL_A_REG_BASE;
+}
+else if(( channel_b_en)&&( channel_a_en==0))
+{
+reg_base_adj=CHANNEL_B_REG_BASE;
+}
+else if ((channel_a_en+channel_b_en)==2)
+ {
+if ( testing_channel == CHANNEL_A)
+	{
+reg_base_adj=CHANNEL_A_REG_BASE;
+	}
+else if( testing_channel==CHANNEL_B)
+	{
+reg_base_adj=CHANNEL_B_REG_BASE;
+	}
+ }
+reg_add=P_DDR0_PUB_DX0BDLR0+reg_base_adj;
+
+
+	for ((temp_count_j=0);(temp_count_j<DQ_LCD_BDL_REG_NUM_PER_CHANNEL);(temp_count_j++))
+		{
+	 //	dq_lcd_bdl_reg_index[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+temp_count_j]=reg_add+4*temp_count_j;
+
+			printf("\n org add	0x%08x reg== 0x%08x\n",(dq_lcd_bdl_reg_index[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_j]), (dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_j]));
+		}
+
+	for ((temp_count_j=0);(temp_count_j<DQ_LCD_BDL_REG_NUM_PER_CHANNEL);(temp_count_j++))
+		{
+			printf("\n lef add	0x%08x reg== 0x%08x\n",(dq_lcd_bdl_reg_index[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_j]), (dq_lcd_bdl_reg_left[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_j]));
+		}
+
+	for ((temp_count_j=0);(temp_count_j<DQ_LCD_BDL_REG_NUM_PER_CHANNEL);(temp_count_j++))
+		{
+			printf("\n rig add	0x%08x reg== 0x%08x\n",(dq_lcd_bdl_reg_index[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_j]), (dq_lcd_bdl_reg_right[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_j]));
+		}
+
+printf("\n ddrtest size ==0x%08x, test times==0x%08x,test_loop==0x%08x\n",ddr_test_size,(test_times+1),test_loop);
+printf("\n add	0x00000000 reg==	org			lef			rig			center		win			lef_m		 rig_m		 min_c		 min_win		\n");
+for ((temp_count_i=0);(temp_count_i<DATX8_DQ_LANE_WIDTH);(temp_count_i++))
+{
+	{
+
+	if (temp_count_i == DATX8_DQ_LANE_LANE00)
+		{
+	reg_add=P_DDR0_PUB_DX0BDLR0+reg_base_adj+DATX8_DQ_DXNLCDLR1*4;}
+
+		else	if(temp_count_i==DATX8_DQ_LANE_LANE01)
+		{
+	reg_add=P_DDR0_PUB_DX1BDLR0+reg_base_adj+DATX8_DQ_DXNLCDLR1*4;}
+
+	else		 if(temp_count_i==DATX8_DQ_LANE_LANE02)
+		{
+	reg_add=P_DDR0_PUB_DX2BDLR0+reg_base_adj+DATX8_DQ_DXNLCDLR1*4;}
+	 else	if(temp_count_i==DATX8_DQ_LANE_LANE03)
+		{
+	reg_add=P_DDR0_PUB_DX3BDLR0+reg_base_adj+DATX8_DQ_DXNLCDLR1*4;}
+}
+
+dq_lcd_bdl_temp_reg_lef=(dq_lcd_bdl_reg_left[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]);
+dq_lcd_bdl_temp_reg_rig=(dq_lcd_bdl_reg_right[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]);
+
+if (test_times == 0)
+{
+(dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1])=dq_lcd_bdl_temp_reg_lef;
+(dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1])=dq_lcd_bdl_temp_reg_rig;
+
+}
+dq_lcd_bdl_temp_reg_lef_min_value=(dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]);
+dq_lcd_bdl_temp_reg_rig_min_value=(dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]);
+
+
+//dq_lcd_bdl_temp_reg_value_wdqd=(dq_lcd_bdl_temp_reg_value&0x0000ff);
+	dq_lcd_bdl_temp_reg_center=( (((dq_lcd_bdl_temp_reg_lef&0xff)+(dq_lcd_bdl_temp_reg_rig&0xff))/2)
+	|(((((dq_lcd_bdl_temp_reg_lef>>8)&0xff)+((dq_lcd_bdl_temp_reg_rig>>8)&0xff))/2)<<8)
+	|(((((dq_lcd_bdl_temp_reg_lef>>16)&0xff)+((dq_lcd_bdl_temp_reg_rig>>8)&0xff))/2)<<16) );
+
+	dq_lcd_bdl_temp_reg_windows=( (((dq_lcd_bdl_temp_reg_rig&0xff)-(dq_lcd_bdl_temp_reg_lef&0xff)))
+	|(((((dq_lcd_bdl_temp_reg_rig>>8)&0xff)-((dq_lcd_bdl_temp_reg_lef>>8)&0xff)))<<8)
+	|(((((dq_lcd_bdl_temp_reg_rig>>16)&0xff)-((dq_lcd_bdl_temp_reg_lef>>8)&0xff)))<<16) );
+
+
+		dq_lcd_bdl_temp_reg_center_min=( (((dq_lcd_bdl_temp_reg_lef_min_value&0xff)+(dq_lcd_bdl_temp_reg_rig_min_value&0xff))/2)
+	|(((((dq_lcd_bdl_temp_reg_lef_min_value>>8)&0xff)+((dq_lcd_bdl_temp_reg_rig_min_value>>8)&0xff))/2)<<8)
+	|(((((dq_lcd_bdl_temp_reg_lef_min_value>>16)&0xff)+((dq_lcd_bdl_temp_reg_rig_min_value>>8)&0xff))/2)<<16) );
+
+	dq_lcd_bdl_temp_reg_windows_min=( (((dq_lcd_bdl_temp_reg_rig_min_value&0xff)-(dq_lcd_bdl_temp_reg_lef_min_value&0xff)))
+	|(((((dq_lcd_bdl_temp_reg_rig_min_value>>8)&0xff)-((dq_lcd_bdl_temp_reg_lef_min_value>>8)&0xff)))<<8)
+	|(((((dq_lcd_bdl_temp_reg_rig_min_value>>16)&0xff)-((dq_lcd_bdl_temp_reg_lef_min_value>>8)&0xff)))<<16) );
+
+printf("\n add	0x%08x reg==	0x%08x	0x%08x	0x%08x	0x%08x	0x%08x	0x%08x	0x%08x	0x%08x	0x%08x\n",
+	(dq_lcd_bdl_reg_index[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]),
+		(dq_lcd_bdl_reg_org[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]),
+		(dq_lcd_bdl_reg_left[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]),
+		(dq_lcd_bdl_reg_right[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]),
+		dq_lcd_bdl_temp_reg_center,dq_lcd_bdl_temp_reg_windows,
+		(dq_lcd_bdl_reg_left_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]),
+		(dq_lcd_bdl_reg_right_min[testing_channel*DQ_LCD_BDL_REG_NUM_PER_CHANNEL+temp_count_i*DATX8_DQ_LCD_BDL_REG_WIDTH+DATX8_DQ_DXNLCDLR1]),
+		dq_lcd_bdl_temp_reg_center_min,dq_lcd_bdl_temp_reg_windows_min
+);
+		}
+
+
+}
+
+}
+
+
+
+
+ return 0;
+
+usage:
+	cmd_usage(cmdtp);
+	return 1;
+
+}
+
+
+
+
+U_BOOT_CMD(
+	ddr_tune_dqs,	5,	1,	do_ddr_test_fine_tune_dqs,
+	"DDR tune dqs function",
+	"ddr_tune_dqs a 0 0x80000 3 or ddr_tune_dqs b 0 0x80000 5 or ddr_tune_dqs a b 0x80000 l\n dcache off ? \n"
+);
+
+*/
+
diff --git a/common/cmd_defenv_without.c b/common/cmd_defenv_without.c
new file mode 100644
index 0000000..cc0d84b
--- /dev/null
+++ b/common/cmd_defenv_without.c
@@ -0,0 +1,135 @@
+/*
+ * \file        cmd_defenv_without.c
+ * \brief       use this cmd but not 'env default',
+ *               to reserve some envs after defaulting envs
+ *
+ * \version     1.0.0
+ * \date        15/09/29
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <cli.h>
+#include <errno.h>
+#include <malloc.h>
+#include <linux/stddef.h>
+#include <asm/byteorder.h>
+
+static const char*  const temp_for_compile[] = {"__test1","__test2","__test3",NULL};
+extern const char * const _env_args_reserve_[0] __attribute__((weak, alias("temp_for_compile")));
+
+#define ModPrefix(pre) printf(pre"[def_wi]")
+#define debugP(fmt...) //ModPrefix("Dbg"),printf("L%d:", __LINE__),printf(fmt)
+#define errorP(fmt...) ModPrefix("Err"), printf("L%d:", __LINE__),printf(fmt)
+#define wrnP(fmt...)   ModPrefix("Err"), printf(fmt)
+#define MsgP(fmt...)   ModPrefix("Err"), printf(fmt)
+
+static int _reserve_env_list_after_defenv(const int reservNum, const char* const reservNameList[])
+{
+        int ret = 0;
+        int index = 0;
+        unsigned sumOfEnvVal = 0;//sum of strlen(getenv(env_i))
+        const int MaxReservNum = CONFIG_SYS_MAXARGS - 1;
+        const char* valListBuf[MaxReservNum];//store at most 64 envs
+        char* tmpEnvBuf = NULL;
+
+        if (reservNum > MaxReservNum) {
+                errorP("max reserved env list num %d < wanted %d\n", MaxReservNum, reservNum);
+                return __LINE__;
+        }
+        //1, cal the total buf size needed to save the envs
+        for (index = 0; index < reservNum; ++index)
+        {
+                const char* cfgEnvKey = reservNameList[index];
+                const char* cfgEnvVal = getenv(cfgEnvKey);
+
+                if (cfgEnvVal) {
+                        sumOfEnvVal += strlen(cfgEnvKey) + 1;
+                }
+                valListBuf[index] = cfgEnvVal;
+        }
+
+        //2, transfer the env values to buffer
+        if (sumOfEnvVal)
+        {
+                tmpEnvBuf = (char*)malloc(sumOfEnvVal);
+                if (!tmpEnvBuf) {
+                        errorP("Fail in malloc(%d)\n", sumOfEnvVal);
+                        return __LINE__;
+                }
+                memset(tmpEnvBuf, 0, sumOfEnvVal);
+
+                char* tmpbuf    = tmpEnvBuf;
+                for (index = 0; index < reservNum; ++index )
+                {
+                        const char*    valBeforeDef     = valListBuf[index];
+
+                        if (!valBeforeDef) continue;
+
+                        const unsigned thisValLen       = strlen(valBeforeDef) + 1;
+                        memcpy(tmpbuf, valBeforeDef, thisValLen);
+                        valListBuf[index] = tmpbuf;
+                        tmpbuf += thisValLen ;
+                        debugP("tmpEnvBuf=%p, tmpbuf=%p, thisValLen=%d\n", tmpEnvBuf, tmpbuf, thisValLen);
+                        debugP("cp:k[%s]%s-->%s\n", reservNameList[index], valBeforeDef, tmpEnvBuf);
+                }
+        }
+
+        set_default_env("## defenv_reserve\n");
+
+        if (sumOfEnvVal)
+        {
+                for (index = 0; index < reservNum; ++index)
+                {
+                        const char* cfgEnvKey           = reservNameList[index];
+                        const char* valAftDef           = valListBuf[index];
+
+                        if (valAftDef)
+                        {
+                                setenv(cfgEnvKey, valAftDef);
+                                debugP("set[%s=%s]\n", cfgEnvKey, valAftDef);
+                        }
+                }
+        }
+
+        if (tmpEnvBuf) free(tmpEnvBuf) ;
+        return ret;
+}
+
+static int do_defenv_reserv(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int envListNum = argc - 1;
+        const char** envListArr = (const char**)(argv + 1);
+
+        if (!envListNum)
+        {
+                envListArr = (const char**)_env_args_reserve_;
+
+                const char** pArr = (const char**)envListArr;
+                while (*pArr++) ++envListNum;
+        }
+
+        int ret = _reserve_env_list_after_defenv(envListNum, envListArr);
+
+        return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+   defenv_reserv,       //command name
+   CONFIG_SYS_MAXARGS,  //maxargs
+   0,                   //repeatable
+   do_defenv_reserv,    //command function
+   "reserve some specified envs after defaulting env",           //description
+   "    argv: defenv_reserve <reserv_en0 reserv_env1 ...> \n"   //usage
+   "    - e.g. \n"
+   "        defenv_reserve :\n"   //usage
+   "               NOT env list , reserv cfg array '_env_args_reserve_' in gxbb_p200.c\n"
+   "        defenv_reserve reserv_en0, reserv_env1, ...\n"   //usage
+   "               reserve specified envs after defaulting env\n"   //usage
+);
+
diff --git a/common/cmd_efuse.c b/common/cmd_efuse.c
new file mode 100644
index 0000000..f05f3e9
--- /dev/null
+++ b/common/cmd_efuse.c
@@ -0,0 +1,233 @@
+
+/*
+ * common/cmd_efuse.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/arch/efuse.h>
+#include <asm/arch/bl31_apis.h>
+
+#define CMD_EFUSE_WRITE            0
+#define CMD_EFUSE_READ             1
+#define CMD_EFUSE_SECURE_BOOT_SET  6
+#define CMD_EFUSE_PASSWORD_SET     7
+#define CMD_EFUSE_CUSTOMER_ID_SET  8
+
+
+
+int cmd_efuse(int argc, char * const argv[], char *buf)
+{
+	int i, action = -1;
+	uint32_t offset;
+	uint32_t size, max_size;
+	char *end;
+	char *s;
+	int ret;
+	long lAddr1, lAddr2;
+
+	if (strncmp(argv[1], "read", 4) == 0) {
+		action = CMD_EFUSE_READ;
+	} else if (strncmp(argv[1], "write", 5) == 0) {
+		action = CMD_EFUSE_WRITE;
+	} else if (strncmp(argv[1], "secure_boot_set", 15) == 0) {
+		action = CMD_EFUSE_SECURE_BOOT_SET;
+		goto efuse_action;
+	} else if (strncmp(argv[1], "password_set", 12) == 0) {
+		action = CMD_EFUSE_PASSWORD_SET;
+		goto efuse_action;
+	} else if (strncmp(argv[1], "customer_id_set", 15) == 0) {
+		action = CMD_EFUSE_CUSTOMER_ID_SET;
+		goto efuse_action;
+	} else{
+		printf("%s arg error\n", argv[1]);
+		return CMD_RET_USAGE;
+	}
+
+	if (argc < 4)
+		return CMD_RET_USAGE;
+	/*check efuse user data max size*/
+	offset = simple_strtoul(argv[2], &end, 16);
+	size = simple_strtoul(argv[3], &end, 16);
+	printf("%s: offset is %d  size is  %d\n", __func__, offset, size);
+	max_size = efuse_get_max();
+	if (!size) {
+		printf("\n error: size is zero!!!\n");
+		return -1;
+	}
+	if (offset > max_size) {
+		printf("\n error: offset is too large!!!\n");
+		printf("\n offset should be less than %d!\n", max_size);
+		return -1;
+	}
+	if (offset+size > max_size) {
+		printf("\n error: offset + size is too large!!!\n");
+		printf("\n offset + size should be less than %d!\n", max_size);
+		return -1;
+	}
+
+efuse_action:
+
+	/* efuse read */
+	if (action == CMD_EFUSE_READ) {
+		memset(buf, 0, size);
+		ret = efuse_read_usr(buf, size, (loff_t *)&offset);
+		if (ret == -1) {
+			printf("ERROR: efuse read user data fail!\n");
+			return -1;
+		}
+
+		if (ret != size)
+			printf("ERROR: read %d byte(s) not %d byte(s) data\n",
+			       ret, size);
+		printf("efuse read data");
+		for (i = 0; i < size; i++) {
+			if (i%16 == 0)
+				printf("\n");
+			printf(":%02x", buf[i]);
+		}
+		printf("\n");
+	}
+
+	/* efuse write */
+	else if (action == CMD_EFUSE_WRITE) {
+		if (argc < 5) {
+			printf("arg count error\n");
+			return CMD_RET_USAGE;
+		}
+		memset(buf, 0, size);
+
+		s = argv[4];
+		memcpy(buf, s, strlen(s));
+		if (efuse_write_usr(buf, size, (loff_t *)&offset) < 0) {
+			printf("error: efuse write fail.\n");
+			return -1;
+		} else {
+			printf("%s written done.\n", __func__);
+		}
+	} else if (CMD_EFUSE_SECURE_BOOT_SET == action) {
+		/*efuse secure_boot_set*/
+
+		lAddr1 = GXB_IMG_LOAD_ADDR;
+
+		if (argc > 2)
+			lAddr1 = simple_strtoul(argv[2], &end, 16);
+
+		lAddr2 = get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+		memcpy((void *)lAddr2, (void *)lAddr1, GXB_EFUSE_PATTERN_SIZE);
+		flush_cache(lAddr2,GXB_EFUSE_PATTERN_SIZE);
+
+		ret = aml_sec_boot_check(AML_D_P_W_EFUSE_SECURE_BOOT, lAddr2,
+			GXB_EFUSE_PATTERN_SIZE, 0);
+
+		if (ret)
+			printf("aml log : Secure boot EFUSE pattern programming fail [%d]!\n",
+			       ret);
+		else
+			printf("aml log : Secure boot EFUSE pattern programming success!\n");
+
+		return ret;
+	} else if(CMD_EFUSE_PASSWORD_SET == action)	{
+		/*efuse password_set*/
+
+		lAddr1 = GXB_IMG_LOAD_ADDR;
+
+		if (argc > 2)
+			lAddr1 = simple_strtoul(argv[2], &end, 16);
+
+		lAddr2 = get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+		memcpy((void *)lAddr2, (void *)lAddr1, GXB_EFUSE_PATTERN_SIZE);
+		flush_cache(lAddr2,GXB_EFUSE_PATTERN_SIZE);
+
+		ret = aml_sec_boot_check(AML_D_P_W_EFUSE_PASSWORD, lAddr2,
+			GXB_EFUSE_PATTERN_SIZE, 0);
+
+		if (ret)
+			printf("aml log : Password EFUSE pattern programming fail [%d]!\n",
+			       ret);
+		else
+			printf("aml log : Password EFUSE pattern programming success!\n");
+
+		return ret;
+	}else if(CMD_EFUSE_CUSTOMER_ID_SET == action)	{
+		/*efuse customer_id_set*/
+
+		lAddr1 = GXB_IMG_LOAD_ADDR;
+
+		if (argc > 2)
+			lAddr1 = simple_strtoul(argv[2], &end, 16);
+
+		lAddr2 = get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+		memcpy((void *)lAddr2, (void *)lAddr1, GXB_EFUSE_PATTERN_SIZE);
+		flush_cache(lAddr2,GXB_EFUSE_PATTERN_SIZE);
+
+		ret = aml_sec_boot_check(AML_D_P_W_EFUSE_CUSTOMER_ID, lAddr2,
+			GXB_EFUSE_PATTERN_SIZE, 0);
+
+		if (ret)
+			printf("aml log : Customer ID EFUSE pattern programming fail [%d]!\n",
+			       ret);
+		else
+			printf("aml log : Customer ID EFUSE pattern programming success!\n");
+
+		return ret;
+	}
+	else
+	{
+		printf("arg error\n");
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+
+int do_efuse(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char buf[EFUSE_BYTES];
+
+	memset(buf, 0, sizeof(buf));
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	return cmd_efuse(argc, argv, buf);
+}
+
+static char efuse_help_text[] =
+	"[read/write offset size [data]]\n"
+	"  [read/wirte]  - read or write 'size' data from\n"
+	"                  'offset' from efuse user data ;\n"
+	"  [offset]      - the offset byte from the beginning\n"
+	"                  of efuse user data zone;\n"
+	"  [size]        - data size\n"
+	"  [data]        - the optional argument for 'write',\n"
+	"                  data is treated as characters\n"
+	"  examples: efuse write 0xc 0xd abcdABCD1234\n";
+
+U_BOOT_CMD(
+	efuse,	5,	1,	do_efuse,
+	"efuse read/write data commands", efuse_help_text
+);
+
+
+/****************************************************/
diff --git a/common/cmd_fastboot.c b/common/cmd_fastboot.c
index b72f4f3..896be31 100644
--- a/common/cmd_fastboot.c
+++ b/common/cmd_fastboot.c
@@ -10,16 +10,32 @@
 #include <common.h>
 #include <command.h>
 #include <g_dnl.h>
+#if defined(CONFIG_MACH_ODROIDC2)
+#include <usb.h>
+#endif
+#include <usb/fastboot.h>
 
 static int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	int ret;
 
+#if defined(CONFIG_MACH_ODROIDC2)
+	/* Initiate USB device port for fastboot */
+	if (board_usb_init(0, USB_INIT_DEVICE)) {
+		error("Couldn't init USB controller.");
+		return CMD_RET_FAILURE;
+	}
+#endif
+
+	board_partition_init();
+
 	g_dnl_clear_detach();
 	ret = g_dnl_register("usb_dnl_fastboot");
 	if (ret)
 		return ret;
 
+	fastboot_flash_dump_ptn();
+
 	while (1) {
 		if (g_dnl_detach())
 			break;
diff --git a/common/cmd_hdmitx.c b/common/cmd_hdmitx.c
new file mode 100644
index 0000000..48144f0
--- /dev/null
+++ b/common/cmd_hdmitx.c
@@ -0,0 +1,164 @@
+/*
+ * (C) Copyright 2012
+ * Amlogic. Inc. zongdong.jiao@amlogic.com
+ *
+ * This file is used to prefetch/varify/compare HDCP keys
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+#include <amlogic/hdmi.h>
+
+static int do_hpd_detect(cmd_tbl_t *cmdtp, int flag, int argc,
+	char *const argv[])
+{
+	int st = hdmitx_device.HWOp.get_hpd_state();
+	printf("hpd_state=%c\n", st ? '1' : '0');
+
+	if (st) {
+		setenv("outputmode", getenv("hdmimode"));
+	} else {
+		setenv("outputmode", getenv("cvbsmode"));
+	}
+	return st;
+}
+
+static unsigned char edid_raw_buf[256] = {0};
+static void dump_edid_raw(unsigned char *buf)
+{
+	int i = 0;
+	for (i = 0 ; i < 8; i++)
+		printf("%02x ", buf[i]);
+	printf("\n");
+}
+
+static int do_edid(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	unsigned int tmp_addr = 0;
+	unsigned char edid_addr = 0;
+	unsigned char st = 0;
+
+	memset(edid_raw_buf, 0, ARRAY_SIZE(edid_raw_buf));
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+	if (strcmp(argv[1], "read") == 0) {
+		tmp_addr = simple_strtoul(argv[2], NULL, 16);
+		if (tmp_addr > 0xff)
+			return cmd_usage(cmdtp);
+		edid_addr = tmp_addr;
+		/* read edid raw data */
+		/* current only support read 1 byte edid data */
+		st = hdmitx_device.HWOp.read_edid(
+			&edid_raw_buf[edid_addr & 0xf8], edid_addr & 0xf8, 8);
+		printf("edid[0x%02x]: 0x%02x\n", edid_addr,
+			edid_raw_buf[edid_addr]);
+		if (0) /* Debug only */
+			dump_edid_raw(&edid_raw_buf[edid_addr & 0xf8]);
+		if (!st)
+			printf("edid read failed\n");
+	}
+	return st;
+}
+
+static int do_output(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	if (argc < 1)
+		return cmd_usage(cmdtp);
+
+	if (strcmp(argv[1], "list") == 0)
+		hdmitx_device.HWOp.list_support_modes();
+	else if (strcmp(argv[1], "bist") == 0) {
+		unsigned int mode;
+		mode = simple_strtoul(argv[2], NULL, 16);
+		hdmitx_device.HWOp.test_bist(mode);
+	} else { /* "output" */
+		hdmitx_device.vic = hdmi_get_fmt_vic(argv[1]);
+		if (hdmitx_device.vic == HDMI_unkown) {
+			/* Not find VIC */
+			printf("Not find '%s' mapped VIC\n", argv[1]);
+			return CMD_RET_FAILURE;
+		} else
+			printf("set hdmitx VIC = %d\n", hdmitx_device.vic);
+
+		if (strstr(argv[1], "hz420") != NULL)
+			hdmitx_device.mode420 = 1;
+		else
+			hdmitx_device.mode420 = 0;
+		hdmi_tx_set(&hdmitx_device);
+	}
+	return CMD_RET_SUCCESS;
+}
+
+static int do_off(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	hdmitx_device.vic = HDMI_unkown;
+	hdmitx_device.HWOp.turn_off();
+	printf("turn off hdmitx\n");
+	return 1;
+}
+
+static int do_dump(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	hdmitx_device.HWOp.dump_regs();
+	return 1;
+}
+
+static cmd_tbl_t cmd_hdmi_sub[] = {
+	U_BOOT_CMD_MKENT(hpd, 1, 1, do_hpd_detect, "", ""),
+	U_BOOT_CMD_MKENT(edid, 3, 1, do_edid, "", ""),
+	U_BOOT_CMD_MKENT(output, 3, 1, do_output, "", ""),
+	U_BOOT_CMD_MKENT(off, 1, 1, do_off, "", ""),
+	U_BOOT_CMD_MKENT(dump, 1, 1, do_dump, "", ""),
+};
+
+static int do_hdmitx(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	cmd_tbl_t *c;
+
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	argc--;
+	argv++;
+
+	c = find_cmd_tbl(argv[0], &cmd_hdmi_sub[0], ARRAY_SIZE(cmd_hdmi_sub));
+
+	if (c)
+		return  c->cmd(cmdtp, flag, argc, argv);
+	else
+		return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(hdmitx, CONFIG_SYS_MAXARGS, 1, do_hdmitx,
+	   "HDMITX sub-system",
+	"hdmitx hpd\n"
+	"    Detect hdmi rx plug-in\n"
+#if 0
+	"hdmitx edid read ADDRESS\n"
+	"    Read hdmi rx edid from ADDRESS(0x00~0xff)\n"
+#endif
+	"hdmitx output [list | FORMAT | bist MODE]\n"
+	"    list: list support formats\n"
+	"    FORMAT can be 720p60/50hz, 1080i60/50hz, 1080p60hz, etc\n"
+	"    bist MODE: 1 Color bar  2 Line  3 Dots  0 default\n"
+	"hdmitx off\n"
+	"    Turn off hdmitx output\n"
+);
diff --git a/common/cmd_imgread.c b/common/cmd_imgread.c
new file mode 100644
index 0000000..f7af8cc
--- /dev/null
+++ b/common/cmd_imgread.c
@@ -0,0 +1,469 @@
+/*
+ * \file        cmd_imgread.c
+ * \brief       command to read the actual size of boot.img/recovery.img and logo.img
+ *
+ * \version     1.0.0
+ * \date        2013/10/29
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+#include <config.h>
+#include <common.h>
+#include <amlogic/storage_if.h>
+#include <image.h>
+#include <android_image.h>
+#ifdef CONFIG_OF_LIBFDT
+#include <libfdt.h>
+#define DTB_PRELOAD_SZ  (4U<<10) //Total read 4k at first to read the image header
+#endif//#ifdef CONFIG_OF_LIBFDT
+
+typedef struct andr_img_hdr boot_img_hdr;
+
+#define debugP(fmt...) //printf("[Dbg imgread]L%d:", __LINE__),printf(fmt)
+#define errorP(fmt...) printf("Err imgread(L%d):", __LINE__),printf(fmt)
+#define wrnP(fmt...)   printf("wrn:"fmt)
+#define MsgP(fmt...)   printf("[imgread]"fmt)
+
+#define IMG_PRELOAD_SZ  (1U<<20) //Total read 1M at first to read the image header
+#define PIC_PRELOAD_SZ  (8U<<10) //Total read 4k at first to read the image header
+#define RES_OLD_FMT_READ_SZ (8U<<20)
+
+typedef struct __aml_enc_blk{
+        unsigned int  nOffset;
+        unsigned int  nRawLength;
+        unsigned int  nSigLength;
+        unsigned int  nAlignment;
+        unsigned int  nTotalLength;
+        unsigned char szPad[12];
+        unsigned char szSHA2IMG[32];
+        unsigned char szSHA2KeyID[32];
+}t_aml_enc_blk;
+
+#define AML_SECU_BOOT_IMG_HDR_MAGIC        "AMLSECU!"
+#define AML_SECU_BOOT_IMG_HDR_MAGIC_SIZE   (8)
+#define AML_SECU_BOOT_IMG_HDR_VESRION      (0x0905)
+
+typedef struct {
+
+        unsigned char magic[AML_SECU_BOOT_IMG_HDR_MAGIC_SIZE];//magic to identify whether it is a encrypted boot image
+
+        unsigned int  version;                  //ersion for this header struct
+        unsigned int  nBlkCnt;
+
+        unsigned char szTimeStamp[16];
+
+        t_aml_enc_blk   amlKernel;
+        t_aml_enc_blk   amlRamdisk;
+        t_aml_enc_blk   amlDTB;
+
+}AmlEncryptBootImgInfo;
+
+typedef struct _boot_img_hdr_secure_boot
+{
+    unsigned char           reserve4ImgHdr[1024];
+
+    AmlEncryptBootImgInfo   encrypteImgInfo;
+
+}AmlSecureBootImgHeader;
+
+/*#define COMPILE_TYPE_CHK(expr, t)       typedef char t[(expr) ? 1 : -1]*/
+/*COMPILE_TYPE_CHK(2048  == sizeof(AmlSecureBootImgHeader), _cc);*/
+
+static int _aml_get_secure_boot_kernel_size(const void* pLoadaddr, unsigned* pTotalEncKernelSz)
+{
+    const AmlSecureBootImgHeader* amlSecureBootImgHead = (const AmlSecureBootImgHeader*)pLoadaddr;
+    const AmlEncryptBootImgInfo*  amlEncrypteBootimgInfo = &amlSecureBootImgHead->encrypteImgInfo;
+    int rc = 0;
+    unsigned secureKernelImgSz = 2048;
+    unsigned int nBlkCnt = amlEncrypteBootimgInfo->nBlkCnt;
+    const t_aml_enc_blk* pBlkInf = NULL;
+
+    *pTotalEncKernelSz = 0;
+    rc = memcmp(AML_SECU_BOOT_IMG_HDR_MAGIC, amlEncrypteBootimgInfo->magic, AML_SECU_BOOT_IMG_HDR_MAGIC_SIZE);
+    if (rc) {
+            return 0;
+    }
+    if (AML_SECU_BOOT_IMG_HDR_VESRION != amlEncrypteBootimgInfo->version) {
+            errorP("magic ok but version err, err ver=0x%x\n", amlEncrypteBootimgInfo->version);
+            return __LINE__;
+    }
+    MsgP("szTimeStamp[%s]\n", (char*)&amlEncrypteBootimgInfo->szTimeStamp);
+    debugP("nBlkCnt=%d\n", nBlkCnt);
+
+    for (pBlkInf = &amlEncrypteBootimgInfo->amlKernel;nBlkCnt--; ++pBlkInf)
+    {
+            const unsigned int thisBlkLen = pBlkInf->nTotalLength;
+            debugP("thisBlkLen=0x%x\n", thisBlkLen);
+            secureKernelImgSz += thisBlkLen;
+    }
+
+    *pTotalEncKernelSz = secureKernelImgSz;
+    return rc;
+}
+
+static int do_image_read_kernel(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    unsigned    kernel_size;
+    unsigned    ramdisk_size;
+    boot_img_hdr *hdr_addr = NULL;
+    int genFmt = 0;
+    unsigned actualBootImgSz = 0;
+    unsigned dtbSz = 0;
+    const char* const partName = argv[1];
+    unsigned char* loadaddr = 0;
+    int rc = 0;
+    uint64_t flashReadOff = 0;
+    unsigned secureKernelImgSz = 0;
+
+    if (2 < argc) {
+        loadaddr = (unsigned char*)simple_strtoul(argv[2], NULL, 16);
+    }
+    else{
+        loadaddr = (unsigned char*)simple_strtoul(getenv("loadaddr"), NULL, 16);
+    }
+    hdr_addr = (boot_img_hdr*)loadaddr;
+
+    rc = store_read_ops((unsigned char*)partName, loadaddr, flashReadOff, IMG_PRELOAD_SZ);
+    if (rc) {
+        errorP("Fail to read 0x%xB from part[%s] at offset 0\n", IMG_PRELOAD_SZ, partName);
+        return __LINE__;
+    }
+    flashReadOff = IMG_PRELOAD_SZ;
+
+    genFmt = genimg_get_format(hdr_addr);
+    if (IMAGE_FORMAT_ANDROID != genFmt) {
+        errorP("Fmt unsupported!genFmt 0x%x != 0x%x\n", genFmt, IMAGE_FORMAT_ANDROID);
+        return __LINE__;
+    }
+
+    //Check if encrypted image
+    rc = _aml_get_secure_boot_kernel_size(loadaddr, &secureKernelImgSz);
+    if (rc) {
+            errorP("Fail in _aml_get_secure_boot_kernel_size, rc=%d\n", rc);
+            return __LINE__;
+    }
+    if (secureKernelImgSz)
+    {
+        actualBootImgSz = secureKernelImgSz;
+        MsgP("secureKernelImgSz=0x%x\n", actualBootImgSz);
+    }
+    else
+    {
+        kernel_size     =(hdr_addr->kernel_size + (hdr_addr->page_size-1)+hdr_addr->page_size)&(~(hdr_addr->page_size -1));
+        ramdisk_size    =(hdr_addr->ramdisk_size + (hdr_addr->page_size-1))&(~(hdr_addr->page_size -1));
+        dtbSz           = hdr_addr->second_size;
+        actualBootImgSz = kernel_size + ramdisk_size + dtbSz;
+        debugP("kernel_size 0x%x, page_size 0x%x, totalSz 0x%x\n", hdr_addr->kernel_size, hdr_addr->page_size, kernel_size);
+        debugP("ramdisk_size 0x%x, totalSz 0x%x\n", hdr_addr->ramdisk_size, ramdisk_size);
+        debugP("dtbSz 0x%x, Total actualBootImgSz 0x%x\n", dtbSz, actualBootImgSz);
+    }
+
+    if (actualBootImgSz > IMG_PRELOAD_SZ)
+    {
+        const unsigned leftSz = actualBootImgSz - IMG_PRELOAD_SZ;
+
+        debugP("Left sz 0x%x\n", leftSz);
+        rc = store_read_ops((unsigned char*)partName, loadaddr + (unsigned)flashReadOff, flashReadOff, leftSz);
+        if (rc) {
+            errorP("Fail to read 0x%xB from part[%s] at offset 0x%x\n", leftSz, partName, IMG_PRELOAD_SZ);
+            return __LINE__;
+        }
+    }
+    debugP("totalSz=0x%x\n", actualBootImgSz);
+
+    //because secure boot will use DMA which need disable MMU temp
+    //here must update the cache, otherwise nand will fail (eMMC is OK)
+    flush_cache((unsigned long)loadaddr,(unsigned long)actualBootImgSz);
+
+    return 0;
+}
+
+#define AML_RES_IMG_VERSION_V1      (0x01)
+#define AML_RES_IMG_VERSION_V2      (0x02)
+#define AML_RES_IMG_V1_MAGIC_LEN    8
+#define AML_RES_IMG_V1_MAGIC        "AML_RES!"//8 chars
+#define AML_RES_IMG_ITEM_ALIGN_SZ   16
+#define AML_RES_IMG_HEAD_SZ         (AML_RES_IMG_ITEM_ALIGN_SZ * 4)//64
+#define AML_RES_ITEM_HEAD_SZ        (AML_RES_IMG_ITEM_ALIGN_SZ * 4)//64
+
+//typedef for amlogic resource image
+#pragma pack(push, 4)
+typedef struct {
+    __u32   crc;    //crc32 value for the resouces image
+    __s32   version;//current version is 0x01
+
+    __u8    magic[AML_RES_IMG_V1_MAGIC_LEN];  //resources images magic
+
+    __u32   imgSz;  //total image size in byte
+    __u32   imgItemNum;//total item packed in the image
+
+    __u32   alignSz;//AML_RES_IMG_ITEM_ALIGN_SZ
+    __u8    reserv[AML_RES_IMG_HEAD_SZ - 8 * 3 - 4];
+
+}AmlResImgHead_t;
+#pragma pack(pop)
+
+#define LOGO_OLD_FMT_READ_SZ (8U<<20)//if logo format old, read 8M
+
+static int img_res_check_log_header(const AmlResImgHead_t* pResImgHead)
+{
+    int rc = 0;
+
+    rc = memcmp(pResImgHead->magic, AML_RES_IMG_V1_MAGIC, AML_RES_IMG_V1_MAGIC_LEN);
+    if (rc) {
+        debugP("Magic error for res\n");
+        return 1;
+    }
+    if (AML_RES_IMG_VERSION_V2 != pResImgHead->version) {
+        errorP("res version 0x%x != 0x%x\n", pResImgHead->version, AML_RES_IMG_VERSION_V2);
+        return 2;
+    }
+
+    return 0;
+}
+
+static int do_image_read_res(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    const char* const partName = argv[1];
+    unsigned char* loadaddr = 0;
+    int rc = 0;
+    AmlResImgHead_t* pResImgHead = NULL;
+    unsigned totalSz    = 0;
+    uint64_t flashReadOff = 0;
+
+    if (2 < argc) {
+        loadaddr = (unsigned char*)simple_strtoul(argv[2], NULL, 16);
+    }
+    else{
+        loadaddr = (unsigned char*)simple_strtoul(getenv("loadaddr"), NULL, 16);
+    }
+    pResImgHead = (AmlResImgHead_t*)loadaddr;
+
+    rc = store_read_ops((unsigned char*)partName, loadaddr, flashReadOff, IMG_PRELOAD_SZ);
+    if (rc) {
+        errorP("Fail to read 0x%xB from part[%s] at offset 0\n", IMG_PRELOAD_SZ, partName);
+        return __LINE__;
+    }
+    flashReadOff = IMG_PRELOAD_SZ;
+
+    if (img_res_check_log_header(pResImgHead)) {
+        errorP("Logo header err.\n");
+        return __LINE__;
+    }
+
+    //Read the actual size of the new version res imgae
+    totalSz = pResImgHead->imgSz;
+    if (totalSz > IMG_PRELOAD_SZ )
+    {
+        const unsigned leftSz = totalSz - flashReadOff;
+
+        rc = store_read_ops((unsigned char*)partName, loadaddr + (unsigned)flashReadOff, flashReadOff, leftSz);
+        if (rc) {
+            errorP("Fail to read 0x%xB from part[%s] at offset 0x%x\n", leftSz, partName, IMG_PRELOAD_SZ);
+            return __LINE__;
+        }
+    }
+    debugP("totalSz=0x%x\n", totalSz);
+
+    return 0;
+}
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number		*/
+#define IH_NMLEN		32	/* Image Name Length		*/
+
+#pragma pack(push, 1)
+typedef struct pack_header{
+	unsigned int 	magic;	/* Image Header Magic Number	*/
+	unsigned int 	hcrc;	/* Image Header CRC Checksum	*/
+	unsigned int	size;	/* Image Data Size		*/
+	unsigned int	start;	/* item data offset in the image*/
+	unsigned int	end;		/* Entry Point Address		*/
+	unsigned int	next;	/* Next item head offset in the image*/
+	unsigned int	dcrc;	/* Image Data CRC Checksum	*/
+	unsigned char	index;		/* Operating System		*/
+	unsigned char	nums;	/* CPU architecture		*/
+	unsigned char   type;	/* Image Type			*/
+	unsigned char 	comp;	/* Compression Type		*/
+	char 	name[IH_NMLEN];	/* Image Name		*/
+}AmlResItemHead_t;
+#pragma pack(pop)
+
+//[imgread pic] logo bootup $loadaddr_misc
+static int do_image_read_pic(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    const char* const partName = argv[1];
+    unsigned char* loadaddr = 0;
+    int rc = 0;
+    const AmlResImgHead_t* pResImgHead = NULL;
+    //unsigned totalSz    = 0;
+    uint64_t flashReadOff = 0;
+    const unsigned PreloadSz = PIC_PRELOAD_SZ;//preload 8k, 124-1 pic header, If you need pack more than 123 items,  fix this
+    unsigned itemIndex = 0;
+    const AmlResItemHead_t* pItem = NULL;
+    const char* picName = argv[2];
+
+    loadaddr = (unsigned char*)simple_strtoul(argc > 3 ? argv[3] : getenv("loadaddr_misc"), NULL, 16);
+
+    pResImgHead = (AmlResImgHead_t*)loadaddr;
+
+    rc = store_read_ops((unsigned char*)partName, loadaddr, flashReadOff, PreloadSz);
+    if (rc) {
+        errorP("Fail to read 0x%xB from part[%s] at offset 0\n", PreloadSz, partName);
+        return __LINE__;
+    }
+    flashReadOff = PreloadSz;
+
+    if (img_res_check_log_header(pResImgHead)) {
+        errorP("Logo header err.\n");
+        return __LINE__;
+    }
+
+    //correct bootup for mbox
+    while (!strcmp("bootup", picName))
+    {
+            char* outputmode = getenv("outputmode");
+            if (!outputmode)break;//not env outputmode
+
+            rc = !strncmp("720", outputmode, 3) || !strncmp("576", outputmode, 3) || !strncmp("480", outputmode, 3);
+            if (rc) {
+                    picName = "bootup_720";
+                    break;
+            }
+
+            picName = "bootup_1080";
+            break;
+    }
+
+    pItem = (AmlResItemHead_t*)(pResImgHead + 1);
+    for (itemIndex = 0; itemIndex < pResImgHead->imgItemNum; ++itemIndex, ++pItem)
+    {
+            if (IH_MAGIC != pItem->magic) {
+                    errorP("item magic 0x%x != 0x%x\n", pItem->magic, IH_MAGIC);
+                    return __LINE__;
+            }
+            if (!strcmp(picName, pItem->name) || !strcmp(argv[2], pItem->name))
+            {
+                    char env_name[IH_NMLEN*2];
+                    char env_data[IH_NMLEN*2];
+                    unsigned long picLoadAddr = (unsigned long)loadaddr + (unsigned)pItem->start;
+
+                    if (pItem->start + pItem->size > flashReadOff)
+                    {
+                        //emmc read can't support offset not align 512
+                        rc = store_read_ops((unsigned char*)partName, (unsigned char *)((picLoadAddr>>9)<<9),
+                                ((pItem->start>>9)<<9), pItem->size + (picLoadAddr & 0x1ff));
+                        if (rc) {
+                            errorP("Fail to read pic at offset 0x%x\n", pItem->start);
+                            return __LINE__;
+                        }
+                    }
+
+                    sprintf(env_name, "%s_offset", argv[2]);//be bootup_offset ,not bootup_720_offset
+                    sprintf(env_data, "0x%lx", picLoadAddr);
+                    setenv(env_name, env_data);
+
+                    sprintf(env_name, "%s_size", argv[2]);
+                    sprintf(env_data, "0x%x", pItem->size);
+                    setenv(env_name, env_data);
+
+                    return 0;//success
+            }
+    }
+
+    return __LINE__;//fail
+}
+
+static cmd_tbl_t cmd_imgread_sub[] = {
+	U_BOOT_CMD_MKENT(kernel, 3, 0, do_image_read_kernel, "", ""),
+	U_BOOT_CMD_MKENT(res,    3, 0, do_image_read_res, "", ""),
+	U_BOOT_CMD_MKENT(pic,    4, 0, do_image_read_pic, "", ""),
+};
+
+static int do_image_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cmd_tbl_t *c;
+
+	/* Strip off leading 'bmp' command argument */
+	argc--;
+	argv++;
+
+	c = find_cmd_tbl(argv[0], &cmd_imgread_sub[0], ARRAY_SIZE(cmd_imgread_sub));
+
+	if (c) {
+		return	c->cmd(cmdtp, flag, argc, argv);
+	} else {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+}
+
+U_BOOT_CMD(
+   imgread,         //command name
+   5,               //maxargs
+   0,               //repeatable
+   do_image_read,   //command function
+   "Read the image from internal flash with actual size",           //description
+   "    argv: <imageType> <part_name> <loadaddr> \n"   //usage
+   "    - <image_type> Current support is kernel/res(ource).\n"
+   "imgread kernel  --- Read image in fomart IMAGE_FORMAT_ANDROID\n"
+   "imgread res     --- Read image packed by 'Amlogic resource packer'\n"
+   "imgread picture --- Read one picture from Amlogic logo"
+   "    - e.g. \n"
+   "        to read boot.img     from part boot     from flash: <imgread kernel boot loadaddr> \n"   //usage
+   "        to read recovery.img from part recovery from flash: <imgread kernel recovery loadaddr> \n"   //usage
+   "        to read logo.img     from part logo     from flash: <imgread res    logo loadaddr> \n"   //usage
+   "        to read one picture named 'bootup' from logo.img    from logo: <imgread pic logo bootup loadaddr> \n"   //usage
+);
+
+//[imgread pic] logo bootup $loadaddr_misc
+static int do_unpackimg(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    unsigned char* loadaddr = 0;
+    const AmlResImgHead_t* pResImgHead = NULL;
+    unsigned itemIndex = 0;
+    const AmlResItemHead_t* pItem = NULL;
+
+    loadaddr = (unsigned char*)simple_strtoul(argc > 1 ? argv[1] : getenv("loadaddr_misc"), NULL, 16);
+
+    pResImgHead = (AmlResImgHead_t*)loadaddr;
+
+    if (img_res_check_log_header(pResImgHead)) {
+        errorP("Logo header err.\n");
+        return __LINE__;
+    }
+
+    pItem = (AmlResItemHead_t*)(pResImgHead + 1);
+    for (itemIndex = 0; itemIndex < pResImgHead->imgItemNum; ++itemIndex, ++pItem)
+    {
+        if (IH_MAGIC != pItem->magic) {
+            errorP("item magic 0x%x != 0x%x\n", pItem->magic, IH_MAGIC);
+            return __LINE__;
+        }
+        char env_name[IH_NMLEN*2];
+        char env_data[IH_NMLEN*2];
+        unsigned long picLoadAddr = (unsigned long)loadaddr + (unsigned)pItem->start;
+
+        sprintf(env_name, "%s_offset", pItem->name);//be bootup_offset ,not bootup_720_offset
+        sprintf(env_data, "0x%lx", picLoadAddr);
+        setenv(env_name, env_data);
+
+        sprintf(env_name, "%s_size", pItem->name);
+        sprintf(env_data, "0x%x", pItem->size);
+        setenv(env_name, env_data);
+    }
+
+    return 0;//success
+}
+
+U_BOOT_CMD(
+   unpackimg,           //command name
+   2,                   //maxargs
+   0,                   //repeatable
+   do_unpackimg,   //command function
+   "un pack logo image into pictures",           //description
+   "    argv: unpackimg <imgLoadaddr> \n"   //usage
+   "    un pack the logo image, which already loaded at <imgLoadaddr>.\n"
+);
+
diff --git a/common/cmd_ini.c b/common/cmd_ini.c
index 727fd1c..7787182 100644
--- a/common/cmd_ini.c
+++ b/common/cmd_ini.c
@@ -90,7 +90,9 @@ static char *memgets(char *str, int num, char **mem, size_t *memsize)
 		end = *mem + *memsize;
 		newline = 0;
 	}
-	len = min((end - *mem) + newline, num);
+
+	len = min((int)(end - *mem) + newline, num);
+
 	memcpy(str, *mem, len);
 	if (len < num)
 		str[len] = '\0';
diff --git a/common/cmd_irkey.c b/common/cmd_irkey.c
new file mode 100644
index 0000000..6ea54a3
--- /dev/null
+++ b/common/cmd_irkey.c
@@ -0,0 +1,91 @@
+#include <asm/io.h>
+#include <common.h>
+#include <command.h>
+#include <asm/arch/secure_apb.h>
+
+unsigned int keycode;
+
+extern uint32_t get_time(void);
+
+void init_custom_trigger(void)
+{
+    printf("ir init\n");
+
+    setbits_le32(P_AO_RTI_PIN_MUX_REG, 1 << 0); // SET IR_DEC_INPUT
+    clrbits_le32(P_AO_RTI_PIN_MUX_REG, 1 << 21); // CLEAR IR_REMOTE_OUTPU
+
+    writel((readl(P_AO_IR_DEC_REG1) | (1 << 15)), P_AO_IR_DEC_REG1);
+    //printf("P_AO_IR_DEC_REG0:%x, P_AO_IR_DEC_REG1:%x\n", readl(P_AO_IR_DEC_REG0),readl(P_AO_IR_DEC_REG1));
+}
+
+void ir_release(void)
+{
+    clrbits_le32(P_AO_RTI_PIN_MUX_REG, 1 << 0);
+}
+
+uint32_t read_key(void)
+{
+    if (!(readl(P_AO_IR_DEC_STATUS) & (1<<3))) {
+        return 0;
+    }
+
+    keycode = readl(P_AO_IR_DEC_FRAME);
+
+    printf("keycode = %x\n",keycode);
+    return keycode;
+}
+
+static int do_irkey(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    uint32_t key = 0, key1 = 0, key2 = 0;
+    uint32_t time_out = 0;
+    uint32_t time_base = 0;
+    char *endp;
+    char str[8];
+
+    if (argc < 4) {
+        goto usage;
+    }
+
+   key1 = simple_strtoul(argv[1], &endp, 0);
+   printf("key1 = %x\n",key1);
+   if (*argv[1] == 0 || *endp != 0)
+       goto usage;
+
+   key2 = simple_strtoul(argv[2], &endp, 0);
+   printf("key2 = %x\n",key2);
+   if (*argv[2] == 0 || *endp != 0)
+       goto usage;
+
+   time_out = simple_strtoul(argv[3], &endp, 0);
+   printf("time_out = %x\n",time_out);
+   if (*argv[3] == 0 || *endp != 0)
+       goto usage;
+
+    init_custom_trigger();
+
+    time_base = get_time();
+    while ((get_time() - time_base) < time_out)
+    {
+       key = read_key();
+       if (key == key1 || key == key2)
+       {
+            printf("ok\n");
+            sprintf(str, "0x%x", key);
+            setenv("irkey_value",str);
+            ir_release();
+            return 0;
+        }
+    }
+   ir_release();
+    return -1;
+usage:
+    puts("Usage: irkey key_value1 key_value2 time_value \n");
+    return -1;
+}
+
+U_BOOT_CMD(
+    irkey, 4, 0, do_irkey,
+    "irkey key_value1 key_value2 time_value",
+    ""
+);
diff --git a/common/cmd_jtag.c b/common/cmd_jtag.c
new file mode 100644
index 0000000..ea95105
--- /dev/null
+++ b/common/cmd_jtag.c
@@ -0,0 +1,69 @@
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/arch/bl31_apis.h>
+
+static int get_jtag_sel(const char *argv)
+{
+	int sel;
+	if (strcmp(argv, "apao") == 0)
+		sel = JTAG_A53_AO;
+	else if (strcmp(argv, "apee") == 0)
+		sel = JTAG_A53_EE;
+	else if (strcmp(argv, "scpao") == 0)
+		sel = JTAG_M3_AO;
+	else if (strcmp(argv, "scpee") == 0)
+		sel = JTAG_M3_EE;
+	else
+		sel = -1;
+
+	return sel;
+}
+
+int do_jtagon(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int sel;
+	if (argc < 2) {
+		printf("invalid argument count!\n");
+		return -1;
+	}
+	sel = get_jtag_sel(argv[1]);
+	if (sel < 0) {
+		printf("invalid argument!\n");
+		return -1;
+	}
+
+	aml_set_jtag_state(JTAG_STATE_ON, sel);
+	return 0;
+}
+
+U_BOOT_CMD(
+	jtagon,	2,	1,	do_jtagon,
+	"enable jtag",
+	"jtagon [apao|apee|scpao|scpee]"
+);
+
+int do_jtagoff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int sel;
+	if (argc < 2) {
+		printf("invalid argument count!\n");
+		return -1;
+	}
+	sel = get_jtag_sel(argv[1]);
+	if (sel < 0) {
+		printf("invalid argument!\n");
+		return -1;
+	}
+
+	aml_set_jtag_state(JTAG_STATE_OFF, sel);
+	return 0;
+}
+
+U_BOOT_CMD(
+	jtagoff,	2,	1,	do_jtagoff,
+	"disable jtag",
+	"jtagoff [apao|apee|scpao|scpee]"
+);
diff --git a/common/cmd_mmc.c b/common/cmd_mmc.c
index 96478e4..3072cb7 100644
--- a/common/cmd_mmc.c
+++ b/common/cmd_mmc.c
@@ -592,6 +592,27 @@ static int do_mmc_setdsr(cmd_tbl_t *cmdtp, int flag,
 	return ret;
 }
 
+unsigned int get_mmc_size(void)
+{
+	struct mmc *mmc;
+
+	if (curr_device < 0) {
+		if (get_mmc_num() > 0)
+			curr_device = 0;
+		else {
+			puts("No MMC device available\n");
+			return 1;
+		}
+	}
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc) {
+		return CMD_RET_FAILURE;
+	}
+
+	return (unsigned int) (mmc->capacity >> 30);
+}
+
 static cmd_tbl_t cmd_mmc[] = {
 	U_BOOT_CMD_MKENT(info, 1, 0, do_mmcinfo, "", ""),
 	U_BOOT_CMD_MKENT(read, 4, 1, do_mmc_read, "", ""),
diff --git a/common/cmd_movi.c b/common/cmd_movi.c
new file mode 100644
index 0000000..928612a
--- /dev/null
+++ b/common/cmd_movi.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <watchdog.h>
+#include <malloc.h>
+#include <linux/ctype.h>    /* isalpha, isdigit */
+#include <linux/err.h>
+#include <usb/fastboot.h>
+#include <mmc.h>
+
+static int isstring(const char *p)
+{
+	if (!isalpha(*p))
+		return 0;
+
+	++p;
+	while (isalnum(*p))
+		++p;
+
+	return *p == '\0';
+}
+
+static int do_movi(cmd_tbl_t* cmdtp, int flag, int argc, char *const argv[])
+{
+	fastboot_ptentry *ptn = NULL;
+	unsigned long addr, start, length;
+	char cmd[128];
+
+	if ((argc < 2) ||
+			(strcmp(argv[1], "read") && strcmp(argv[1], "write")))
+		goto err_usage;
+
+	if (isstring(argv[2])) {
+		if (argc < 5)
+			goto err_usage;
+
+		ptn = fastboot_flash_find_ptn(argv[2]);
+		if (ptn == NULL) {
+			printf("movi: not registered partition name, %s\n", argv[2]);
+			goto err_usage;
+		}
+
+		start = ptn->start;
+		length = ptn->length;
+	} else {
+		if (argc < 6)
+			goto err_usage;
+
+		start = simple_strtoul(argv[2], NULL, 16);
+		length = simple_strtoul(argv[5], NULL, 16);
+	}
+
+	start += simple_strtoul(argv[3], NULL, 16);
+	addr = simple_strtoul(argv[4], NULL, 16);
+
+	if (argc >= 6) {
+		length = simple_strtoul(argv[5], NULL, 16) / 512;
+		if (0 == length) {
+			printf("movi: zero-length is ignored.\n");
+			return -EINVAL;
+		}
+	}
+
+	sprintf(cmd, "mmc %s 0x%08x 0x%08x 0x%08x",
+			argv[1], (unsigned int)addr, (unsigned int)start,
+			(unsigned int)length);
+
+	/* Accessing the storage by partition name */
+	if (ptn)
+		printf("movi: the partiton '%s' is %sing...\n", ptn->name, argv[1]);
+
+	return run_command(cmd, 0);
+
+err_usage:
+	cmd_usage(cmdtp);
+	return -EINVAL;
+}
+
+U_BOOT_CMD(
+		movi,			7,		0,		do_movi,
+		"Read/write command from/to SD/MMC for ODROID-C board",
+		"<read|write> <parition|sector> <offset> <address> [<length>]\n"
+		"    - read the partitoin/sector of storage to memory\n"
+		"    - write the partiton/sector of storage from memory\n"
+		"    - all parameters must be hexa-decimal only\n"
+);
+
+#define		_1GB_BLOCK_CNT  		(2*1024*1024)
+
+/////////////////////////////////////////////////////////////////
+int get_mmc_block_count(char *device_name)
+{
+	struct mmc *mmc;
+	int block_count = 0;
+	int dev_num;
+
+	dev_num = simple_strtoul(device_name, NULL, 0);
+
+	mmc = find_mmc_device(dev_num);
+	if (!mmc)
+	{
+		printf("mmc/sd device is NOT founded.\n");
+		return -1;
+	}
+
+	block_count = mmc->capacity / mmc->read_bl_len;
+
+	return block_count;
+}
+
+static int do_get_mmc_size(cmd_tbl_t* cmdtp, int flag, int argc, char *const argv[])
+{
+	int total_block_count = 0;
+	char   mmc_size[5];
+
+	if ( argc == 2 )
+	{
+		total_block_count = get_mmc_block_count(argv[1]);
+		memset(mmc_size, 0x00, sizeof(mmc_size));
+
+		if 	(total_block_count > (200 * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 256);
+		else if (total_block_count > (100 * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 128);
+		else if (total_block_count > (50  * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 64);
+		else if (total_block_count > (25  * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 32);
+		else if (total_block_count > (10  * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 16);
+		else if (total_block_count > (5   * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 8);
+		else if (total_block_count > (3   * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 4);
+		else if (total_block_count > (1   * _1GB_BLOCK_CNT))    sprintf(mmc_size, "%d", 2);
+		else 							sprintf(mmc_size, "%d", 1);
+
+		if (total_block_count < 0)  {
+			printf("error total block count == 0\n");
+			return -1;
+		}
+		setenv("mmc_size_gb", mmc_size);
+	}
+	else
+	{
+	           printf("Usage:\nget_mmc_size <device_num>\n");
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	get_mmc_size, 2, 0, do_get_mmc_size,
+	"get_mmc_size\t- mmc size check for sd/mmc.\n",
+	"env mmc_size_gb = 1, 2, 4, 8, 16, 32, 64, 128.\n"
+	"get_mmc_size <device_num>\n"
+);
+
+/* vim: set ts=4 sw=4 tw=80: */
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
index 855808c..8b481e7 100644
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -49,9 +49,11 @@ DECLARE_GLOBAL_DATA_PTR;
 	!defined(CONFIG_ENV_IS_IN_SPI_FLASH)	&& \
 	!defined(CONFIG_ENV_IS_IN_REMOTE)	&& \
 	!defined(CONFIG_ENV_IS_IN_UBI)		&& \
-	!defined(CONFIG_ENV_IS_NOWHERE)
+	!defined(CONFIG_ENV_IS_NOWHERE)		&& \
+	!defined(CONFIG_ENV_IS_IN_AMLNAND)  && \
+	!defined(CONFIG_STORE_COMPATIBLE)
 # error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|DATAFLASH|ONENAND|\
-SPI_FLASH|NVRAM|MMC|FAT|REMOTE|UBI} or CONFIG_ENV_IS_NOWHERE
+SPI_FLASH|NVRAM|MMC|FAT|REMOTE|UBI|AMLNAND} or CONFIG_ENV_IS_NOWHERE
 #endif
 
 /*
diff --git a/common/cmd_osd.c b/common/cmd_osd.c
new file mode 100644
index 0000000..26bbe24
--- /dev/null
+++ b/common/cmd_osd.c
@@ -0,0 +1,174 @@
+#include <common.h>
+#include <lcd.h>
+#include <command.h>
+#include <asm/byteorder.h>
+#include <malloc.h>
+#include <splash.h>
+#include <video_fb.h>
+#include <video.h>
+
+/* Graphic Device */
+static GraphicDevice *gdev = NULL;
+
+extern void osd_debug(void);
+extern void osd_set_log_level(int);
+extern void osd_test(void);
+extern void osd_enable_hw(u32 index, u32 enable);
+extern void osd_set_free_scale_enable_hw(u32 index, u32 enable);
+
+static int do_osd_open(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char *const argv[])
+{
+	gdev = video_hw_init();
+	if (gdev == NULL) {
+		printf("Initialize video device failed!\n");
+		return 1;
+	}
+	return 0;
+}
+
+static int do_osd_enable(cmd_tbl_t *cmdtp, int flag, int argc,
+			char *const argv[])
+{
+	ulong index = 0;
+
+	index = simple_strtoul(getenv("display_layer"), NULL, 0);
+	osd_enable_hw(index, 0);
+
+	return 0;
+}
+
+static int do_osd_close(cmd_tbl_t *cmdtp, int flag, int argc,
+			char *const argv[])
+{
+	gdev = NULL;
+	osd_enable_hw(0, 0);
+	osd_enable_hw(1, 0);
+	osd_set_free_scale_enable_hw(0, 0);
+	osd_set_free_scale_enable_hw(1, 0);
+
+	return 0;
+}
+
+static int do_osd_clear(cmd_tbl_t *cmdtp, int flag, int argc,
+			char *const argv[])
+{
+	if (gdev == NULL) {
+		printf("Please enable osd device first!\n");
+		return 1;
+	}
+
+#ifdef CONFIG_OSD_SCALE_ENABLE
+	memset((void *)(long long)(gdev->frameAdrs), 0,
+	       (gdev->fb_width * gdev->fb_height)*gdev->gdfBytesPP);
+
+	flush_cache(gdev->frameAdrs,
+		    ((gdev->fb_width * gdev->fb_height)*gdev->gdfBytesPP));
+#else
+	memset((void *)(long long)(gdev->frameAdrs), 0,
+	       (gdev->winSizeX * gdev->winSizeY)*gdev->gdfBytesPP);
+
+	flush_cache(gdev->frameAdrs,
+		    ((gdev->winSizeX * gdev->winSizeY)*gdev->gdfBytesPP));
+#endif
+	return 0;
+}
+
+static int do_osd_debug(cmd_tbl_t *cmdtp, int flag, int argc,
+			char *const argv[])
+{
+	int ret = 0;
+	int level = 0;
+
+	switch (argc) {
+	case 1:
+		osd_debug();
+		break;
+	case 2:
+		level = simple_strtoul(argv[1], NULL, 10);
+		osd_set_log_level(level);
+		break;
+	default:
+		return CMD_RET_USAGE;
+	}
+
+	return ret;
+}
+
+static int do_osd_test(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = 0;
+
+	osd_test();
+
+	return ret;
+}
+
+static int do_osd_display(cmd_tbl_t *cmdtp, int flag, int argc,
+			  char *const argv[])
+{
+	int ret = 0;
+	int x = 0, y = 0;
+	ulong addr;
+
+	splash_get_pos(&x, &y);
+
+	switch (argc) {
+	case 1:		/* use load_addr as default address */
+		addr = load_addr;
+		break;
+	case 2:		/* use argument */
+		addr = simple_strtoul(argv[1], NULL, 16);
+		break;
+	case 4:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		x = simple_strtoul(argv[2], NULL, 10);
+		y = simple_strtoul(argv[3], NULL, 10);
+		break;
+	default:
+		return CMD_RET_USAGE;
+	}
+
+	ret = video_display_bitmap((unsigned long)addr, x, y);
+
+	return ret;
+}
+
+static cmd_tbl_t cmd_osd_sub[] = {
+	U_BOOT_CMD_MKENT(open, 2, 0, do_osd_open, "", ""),
+	U_BOOT_CMD_MKENT(enable, 2, 0, do_osd_enable, "", ""),
+	U_BOOT_CMD_MKENT(close, 2, 0, do_osd_close, "", ""),
+	U_BOOT_CMD_MKENT(clear, 2, 0, do_osd_clear, "", ""),
+	U_BOOT_CMD_MKENT(debug, 2, 0, do_osd_debug, "", ""),
+	U_BOOT_CMD_MKENT(test, 2, 0, do_osd_test, "", ""),
+	U_BOOT_CMD_MKENT(display, 5, 0, do_osd_display, "", ""),
+};
+
+static int do_osd(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	cmd_tbl_t *c;
+
+	/* Strip off leading 'osd' command argument */
+	argc--;
+	argv++;
+
+	c = find_cmd_tbl(argv[0], &cmd_osd_sub[0], ARRAY_SIZE(cmd_osd_sub));
+
+	if (c)
+		return  c->cmd(cmdtp, flag, argc, argv);
+	else
+		return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	osd,	5,	1,	do_osd,
+	"osd sub-system",
+	"open                      - open osd device\n"
+	"osd enable                    - enable osd device\n"
+	"osd close                     - close osd device\n"
+	"osd clear                     - clear osd framebuffer\n"
+	"osd debug                     - debug osd device\n"
+	"osd test                      - test osd device\n"
+	"osd display <imageAddr> [x y] - display image\n"
+);
+
diff --git a/common/cmd_reboot.c b/common/cmd_reboot.c
new file mode 100644
index 0000000..b6102f6
--- /dev/null
+++ b/common/cmd_reboot.c
@@ -0,0 +1,188 @@
+
+/*
+ * common/cmd_reboot.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/reboot.h>
+#include <asm/arch/secure_apb.h>
+#include <asm/io.h>
+#include <asm/arch/bl31_apis.h>
+#include <asm/arch/watchdog.h>
+
+/*
+run get_rebootmode  //set reboot_mode env with current mode
+*/
+
+int do_get_rebootmode (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	uint32_t reboot_mode_val;
+	reboot_mode_val = ((readl(AO_SEC_SD_CFG15) >> 12) & 0xf);
+
+	debug("reboot_mode(0x%x)=0x%x\n", AO_SEC_SD_CFG15, reboot_mode_val);
+
+	switch (reboot_mode_val)
+	{
+		case AMLOGIC_COLD_BOOT:
+		{
+			setenv("reboot_mode","cold_boot");
+			break;
+		}
+		case AMLOGIC_NORMAL_BOOT:
+		{
+			setenv("reboot_mode","normal");
+			break;
+		}
+		case AMLOGIC_FACTORY_RESET_REBOOT:
+		{
+			setenv("reboot_mode","factory_reset");
+			break;
+		}
+		case AMLOGIC_UPDATE_REBOOT:
+		{
+			setenv("reboot_mode","update");
+			break;
+		}
+		case AMLOGIC_USB_BURNING_REBOOT:
+		{
+			setenv("reboot_mode","usb_burning");
+			break;
+		}
+		case AMLOGIC_SUSPEND_REBOOT:
+		{
+			setenv("reboot_mode","suspend_off");
+			break;
+		}
+		case AMLOGIC_HIBERNATE_REBOOT:
+		{
+			setenv("reboot_mode","hibernate");
+			break;
+		}
+		case AMLOGIC_CRASH_REBOOT:
+		{
+			setenv("reboot_mode","crash_dump");
+			break;
+		}
+		case AMLOGIC_KERNEL_PANIC:
+		{
+			setenv("reboot_mode","kernel_panic");
+			break;
+		}
+		default:
+		{
+			setenv("reboot_mode","charging");
+			break;
+		}
+	}
+	return 0;
+}
+
+int do_reboot (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	uint32_t reboot_mode_val = AMLOGIC_NORMAL_BOOT;
+	if (argc <= 1) {
+		printf("reboot use default mode: normal\n");
+	}
+	else {
+		printf("reboot mode: %s\n", argv[1]);
+		char * mode = argv[1];
+		if (strcmp(mode, "cold_boot") == 0)
+			reboot_mode_val = AMLOGIC_COLD_BOOT;
+		else if (strcmp(mode, "normal") == 0)
+			reboot_mode_val = AMLOGIC_NORMAL_BOOT;
+		else if (strcmp(mode, "recovery") == 0 || strcmp(mode, "factory_reset") == 0)
+			reboot_mode_val = AMLOGIC_FACTORY_RESET_REBOOT;
+		else if (strcmp(mode, "update") == 0)
+			reboot_mode_val = AMLOGIC_UPDATE_REBOOT;
+		else if (strcmp(mode, "usb_burning") == 0)
+			reboot_mode_val = AMLOGIC_USB_BURNING_REBOOT;
+		else if (strcmp(mode, "suspend_off") == 0)
+			reboot_mode_val = AMLOGIC_SUSPEND_REBOOT;
+		else if (strcmp(mode, "hibernate") == 0)
+			reboot_mode_val = AMLOGIC_HIBERNATE_REBOOT;
+		else if (strcmp(mode, "crash_dump") == 0)
+			reboot_mode_val = AMLOGIC_CRASH_REBOOT;
+		else if (strcmp(mode, "kernel_panic") == 0)
+			reboot_mode_val = AMLOGIC_KERNEL_PANIC;
+		else {
+			printf("Can not find match reboot mode, use normal by default\n");
+			reboot_mode_val = AMLOGIC_NORMAL_BOOT;
+		}
+	}
+	aml_reboot (PSCI_SYS_REBOOT, reboot_mode_val, 0, 0);
+	return 0;
+}
+
+/* USB BOOT FUNC sub command list*/
+#define CLEAR_USB_BOOT			1
+#define FORCE_USB_BOOT			2
+#define RUN_COMD_USB_BOOT		3
+#define PANIC_DUMP_USB_BOOT		4
+
+int do_set_usb_boot(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int usb_mode = 0;
+	if (argc <= 1) {
+		printf("usb flag default 0\n");
+	}
+	else {
+		usb_mode = simple_strtoul(argv[1], NULL, 16);
+	}
+	printf("usb flag: %d\n", usb_mode);
+	set_usb_boot_function(usb_mode);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	get_rebootmode,	1,	0,	do_get_rebootmode,
+	"get reboot mode",
+	"/N\n"
+	"  This command will get and setenv 'reboot_mode'\n"
+	"get_rebootmode\n"
+);
+
+U_BOOT_CMD(
+	reboot,	2,	0,	do_reboot,
+	"set reboot mode and reboot system",
+	"[rebootmode]/N\n"
+	"  This command will set reboot mode and reboot system\n"
+	"\n"
+	"  support following [rebootmode]:\n"
+	"    cold_boot\n"
+	"    normal[default]\n"
+	"    factory_reset/recovery\n"
+	"    update\n"
+	"    usb_burning\n"
+	"    suspend_off\n"
+	"    hibernate\n"
+	"    crash_dump\n"
+);
+
+U_BOOT_CMD(
+	set_usb_boot,	2,	0,	do_set_usb_boot,
+	"set usb boot mode",
+	"[usb boot mode]/N\n"
+	"  support following [usb boot mode]:\n"
+	"    1: CLEAR_USB_BOOT\n"
+	"    2: FORCE_USB_BOOT[default]\n"
+	"    3: RUN_COMD_USB_BOOT/recovery\n"
+	"    4: PANIC_DUMP_USB_BOOT\n"
+);
\ No newline at end of file
diff --git a/common/cmd_saradc.c b/common/cmd_saradc.c
new file mode 100644
index 0000000..0fed73c
--- /dev/null
+++ b/common/cmd_saradc.c
@@ -0,0 +1,108 @@
+/*
+ * Command for SARADC.
+ *
+ * Copyright (C) 2012 Amlogic.
+ * Elvis Yu <elvis.yu@amlogic.com>
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/saradc.h>
+
+#define SARADC_VALUE "saradc_val"
+
+
+static int current_channel = -1;
+
+static int do_saradc_open(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int channel;
+	channel = simple_strtoul(argv[1], NULL, 10);
+	if ((channel < 0) || (channel >= AML_ADC_SARADC_CHAN_NUM))
+	{
+		printf("No such channel(%d) in SARADC! open failed!\n", channel);
+		return -1;
+	}
+	saradc_enable();
+	current_channel = channel;
+//	printf("SARADC open channel(%d).\n", channel);
+	return 0;
+}
+
+static int do_saradc_close(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	saradc_disable();
+	current_channel = -1;
+	printf("SARADC closed.\n");
+	return 0;
+}
+
+static int do_saradc_getval(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char value_str[10];
+	int val = get_adc_sample_gxbb(current_channel);
+	printf("SARADC channel(%d) is 0x%x.\n", current_channel, val);
+	sprintf(value_str, "0x%x", val);
+	setenv(SARADC_VALUE, value_str);
+	return 0;
+}
+
+static int do_saradc_get_in_range(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char value_str[10];
+	int max, min;
+	int val = get_adc_sample_gxbb(current_channel);
+	min = simple_strtoul(argv[1], NULL, 10);
+	max = simple_strtoul(argv[2], NULL, 10);
+	int donot_setenv = 0;
+	if (argc>3)
+    {
+		donot_setenv = simple_strtoul(argv[2], NULL, 10);
+	}
+	if ((val<min) || (val>max))
+	{
+		debug("SARADC channel(%d) is 0x%x, Out of range(0x%x~0x%x)!\n",
+			current_channel, val, min, max);
+		return -1;
+	}
+	debug("SARADC channel(%d) is 0x%x (0x%x~0x%x).\n",
+		current_channel, val, min, max);
+	sprintf(value_str, "0x%x", val);
+	if (!donot_setenv)
+		setenv(SARADC_VALUE, value_str);
+	return 0;
+}
+
+static cmd_tbl_t cmd_saradc_sub[] = {
+	U_BOOT_CMD_MKENT(open, 2, 0, do_saradc_open, "", ""),
+	U_BOOT_CMD_MKENT(close, 1, 0, do_saradc_close, "", ""),
+	U_BOOT_CMD_MKENT(getval, 1, 0, do_saradc_getval, "", ""),
+	U_BOOT_CMD_MKENT(get_in_range, 3, 0, do_saradc_get_in_range, "", ""),
+};
+
+
+static int do_saradc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cmd_tbl_t *c;
+	/* Strip off leading 'bmp' command argument */
+	argc--;
+	argv++;
+	c = find_cmd_tbl(argv[0], &cmd_saradc_sub[0], ARRAY_SIZE(cmd_saradc_sub));
+	if (c) {
+		return	c->cmd(cmdtp, flag, argc, argv);
+	} else {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+}
+
+U_BOOT_CMD(
+	saradc,	8,	0,	do_saradc,
+	"saradc sub-system",
+	"saradc open <channel>		- open a SARADC channel\n"
+	"saradc close	- close the SARADC\n"
+	"saradc getval	- get the value in current channel\n"
+	"saradc get_in_range <min> <max>	- return 0 if current value in the range of current channel\n"
+);
+
+
diff --git a/common/cmd_scp.c b/common/cmd_scp.c
new file mode 100644
index 0000000..e2b7d78
--- /dev/null
+++ b/common/cmd_scp.c
@@ -0,0 +1,19 @@
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/arch/mailbox.h>
+
+int do_open_scp_log(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	open_scp_log();
+	printf("open SCP log!\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+	open_scp_log,	1,	1,	do_open_scp_log,
+	"print SCP messgage",
+	"print SCP log"
+);
diff --git a/common/cmd_showlogo.c b/common/cmd_showlogo.c
new file mode 100644
index 0000000..8ca9ab1
--- /dev/null
+++ b/common/cmd_showlogo.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/errno.h>
+
+#ifdef CONFIG_DISPLAY_LOGO
+static int display_logo(const char* mode)
+{
+	int ret;
+
+	if (!strncmp("720", mode, 3)) {
+		setenv("fb_width", "1280");
+		setenv("fb_height", "720");
+	} else if (!strncmp("1080", mode, 4)) {
+		setenv("fb_width", "1920");
+		setenv("fb_height", "1080");
+	} else if (!strncmp("2160", mode, 4)) {
+		setenv("fb_width", "3840");
+		setenv("fb_height", "2160");
+	} else {
+		printf("error: '%s' is invalid resolution.\n", mode);
+		return 1;
+	}
+
+	setenv("bootlogo_addr", "0x20000000"); /* initrd load address + 0xD0000000 */
+#ifdef CONFIG_VIDEO_BMP_GZIP
+	ret = run_command("fatload mmc 0 ${bootlogo_addr} boot-logo.bmp.gz", 1);
+	if (!ret)	goto display_logo;
+#endif
+	ret = run_command("fatload mmc 0 ${bootlogo_addr} boot-logo.bmp", 1);
+	if (!ret)	goto display_logo;
+
+	ret = run_command("movi read logo 0 ${bootlogo_addr}", 1);
+	if (!ret)
+		goto display_logo;
+
+	return 1;
+
+display_logo:
+	/* for video_hw_init in osd_fb.c */
+	setenv("fb_addr", "0x3f800000");
+	setenv("display_bpp", "24");
+	setenv("display_color_index", "24");
+	setenv("display_layer", "osd1");
+	setenv("display_color_fg", "0xffff");
+	setenv("display_color_bg", "0");
+	setenv("cvbsmode", "576cvbs");
+	setenv("hdmimode", mode);
+	setenv("outputmode", mode);
+
+	setenv("display_width", getenv("fb_width"));
+	setenv("display_height", getenv("fb_height"));
+
+	run_command("hdmitx hpd; osd open; osd clear", 0);
+	run_command("vout output ${outputmode}; hdmitx output ${outputmode}", 0);
+	run_command("bmp display ${bootlogo_addr}", 0);
+	run_command("setenv logoopt ${display_layer},loaded,${fb_addr},${hdmimode}", 0);
+
+	return 0;
+}
+
+static int do_showlogo(cmd_tbl_t *cmdtp, int flag, int argc,
+		char *const argv[])
+{
+	char *mode;
+
+	if (argc <= 1) {
+		mode = getenv("hdmimode");
+		display_logo((NULL == mode) ? "720p60hz" : mode);
+	} else {
+		display_logo(argv[1]);
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+		showlogo,		2,		0,	do_showlogo,
+		"Displaying BMP logo file to HDMI screen with the specified resolution",
+		"<resolution>\n"
+		"    resolution - screen resoltuion on HDMI screen\n"
+		"                 '720p60hz' will be used by default if missing"
+);
+#endif  /* CONFIG_DISPLAY_LOGO */
+
+/* vim: set ts=4 sw=4 tw=80: */
diff --git a/common/cmd_test.c b/common/cmd_test.c
index c93fe78..920e56a 100644
--- a/common/cmd_test.c
+++ b/common/cmd_test.c
@@ -66,7 +66,7 @@ static int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	int i, op, left, adv, expr, last_expr, last_unop, last_binop;
 
 	/* args? */
-	if (argc < 3)
+	if (argc < 4)
 		return 1;
 
 #ifdef DEBUG
diff --git a/common/cmd_vout.c b/common/cmd_vout.c
new file mode 100644
index 0000000..b9e668c
--- /dev/null
+++ b/common/cmd_vout.c
@@ -0,0 +1,109 @@
+/*
+ * (C) Copyright 2012
+ * Amlogic. Inc. jets.yan@amlogic.com
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+
+#ifdef CONFIG_AML_CVBS
+#include <amlogic/cvbs.h>
+#endif
+
+static int do_vout_list(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+#ifdef CONFIG_AML_HDMITX20
+	printf("\nvalid hdmi mode:\n");
+	hdmitx_device.HWOp.list_support_modes();
+#endif
+
+#ifdef CONFIG_AML_CVBS
+	printf("\nvalid cvbs mode:\n");
+	cvbs_show_valid_vmode();
+	printf("\n");
+#endif
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_vout_output(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	if (argc != 2)
+		return CMD_RET_FAILURE;
+
+#ifdef CONFIG_AML_CVBS
+	cvbs_set_vmode(argv[1]);
+#endif
+
+#ifdef CONFIG_AML_HDMITX20
+	hdmitx_device.vic = hdmi_get_fmt_vic(argv[1]);
+	if (hdmitx_device.vic == HDMI_unkown) {
+		/* Not find VIC */
+		printf("Not find '%s' mapped VIC\n", argv[1]);
+		return CMD_RET_SUCCESS;
+	} else
+		printf("set hdmitx VIC = %d\n", hdmitx_device.vic);
+
+	if (strstr(argv[1], "hz420") != NULL)
+		hdmitx_device.mode420 = 1;
+	else
+		hdmitx_device.mode420 = 0;
+	hdmi_tx_set(&hdmitx_device);
+#endif
+
+	return CMD_RET_SUCCESS;
+}
+
+
+static cmd_tbl_t cmd_vout_sub[] = {
+	U_BOOT_CMD_MKENT(list, 1, 1, do_vout_list, "", ""),
+	U_BOOT_CMD_MKENT(output, 3, 1, do_vout_output, "", ""),
+};
+
+static int do_vout(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	cmd_tbl_t *c;
+
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	argc--;
+	argv++;
+
+	c = find_cmd_tbl(argv[0], &cmd_vout_sub[0], ARRAY_SIZE(cmd_vout_sub));
+
+	if (c)
+		return  c->cmd(cmdtp, flag, argc, argv);
+	else
+		return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(vout, CONFIG_SYS_MAXARGS, 1, do_vout,
+	"VOUT sub-system",
+	"vout output [list | format]\n"
+	"    list : list for valid video mode names.\n"
+	"    format : perfered output video mode\n"
+);
diff --git a/common/cmd_vpu.c b/common/cmd_vpu.c
new file mode 100644
index 0000000..49553ca
--- /dev/null
+++ b/common/cmd_vpu.c
@@ -0,0 +1,79 @@
+#include <common.h>
+#include <command.h>
+#include <vpu.h>
+
+#ifdef CONFIG_AML_VPU
+static int do_vpu_enable(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	vpu_probe();
+	return 0;
+}
+
+static int do_vpu_disable(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	vpu_remove();
+	return 0;
+}
+
+static int do_vpu_clk(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int level;
+	int ret = 0;
+
+	if (argc == 1) {
+		return -1;
+	}
+	if (strcmp(argv[1], "set") == 0) {
+		if (argc == 3) {
+			level = (int)simple_strtoul(argv[2], NULL, 10);
+			ret = vpu_clk_change(level);
+		} else {
+			ret = -1;
+		}
+	} else if (strcmp(argv[1], "get") == 0) {
+		vpu_clk_get();
+	} else {
+		ret = -1;
+	}
+	return ret;
+}
+
+static int do_vpu_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	vcbus_test();
+	return 0;
+}
+
+static cmd_tbl_t cmd_vpu_sub[] = {
+	U_BOOT_CMD_MKENT(probe, 2, 0, do_vpu_enable, "", ""),
+	U_BOOT_CMD_MKENT(remove, 2, 0, do_vpu_disable, "", ""),
+	U_BOOT_CMD_MKENT(clk, 3, 0, do_vpu_clk, "", ""),
+	U_BOOT_CMD_MKENT(test, 2, 0, do_vpu_test, "", ""),
+};
+
+static int do_vpu(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cmd_tbl_t *c;
+
+	/* Strip off leading 'bmp' command argument */
+	argc--;
+	argv++;
+
+	c = find_cmd_tbl(argv[0], &cmd_vpu_sub[0], ARRAY_SIZE(cmd_vpu_sub));
+
+	if (c) {
+		return c->cmd(cmdtp, flag, argc, argv);
+	} else {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+}
+
+U_BOOT_CMD(
+	vpu,	5,	0,	do_vpu,
+	"vpu sub-system",
+	"vpu probe        - enable vpu layer\n"
+	"vpu remove       - disable vpu layer\n"
+	"vpu test         - test vcbus access\n"
+);
+#endif
diff --git a/common/cmd_wipeisb.c b/common/cmd_wipeisb.c
new file mode 100644
index 0000000..b23b4ce
--- /dev/null
+++ b/common/cmd_wipeisb.c
@@ -0,0 +1,41 @@
+#include <common.h>
+#include <amlogic/storage_if.h>
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE 4096
+#endif
+
+unsigned char w_buf[PAGE_SIZE];
+extern int has_instaboot_part(void);
+static int do_wipeisb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rc = 0;
+	u64 partSz = 0;
+
+	if (!has_instaboot_part())
+		return 0;
+	rc = store_get_partititon_size((unsigned char*)"instaboot", &partSz);
+	if (rc || !partSz) {
+	    printf("can not get instaboot part size\n");
+	    return -1;
+	}
+
+	memset(w_buf, 0, PAGE_SIZE);
+	rc = store_write_ops((unsigned char*)"instaboot",
+		w_buf, 0, PAGE_SIZE);
+	if (rc) {
+	    printf("wipe instaboot header error\n");
+	    return -1;
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+   wipeisb,         //command name
+   1,               //maxargs
+   0,               //repeatable
+   do_wipeisb,   //command function
+   "wipeisb",
+   "wipe the insaboot image header"
+);
+
diff --git a/common/env_amlnand.c b/common/env_amlnand.c
new file mode 100644
index 0000000..db42a81
--- /dev/null
+++ b/common/env_amlnand.c
@@ -0,0 +1,160 @@
+/*
+ * (C) Copyright 2000-2010
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2008
+ * Stuart Wood, Lab X Technologies <stuart.wood@labxtechnologies.com>
+ *
+ * (C) Copyright 2004
+ * Jian Zhang, Texas Instruments, jzhang@ti.com.
+ *
+ * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Andreas Heppel <aheppel@sysgo.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+#include <malloc.h>
+//#include <nand.h>	/* fixme, using header's of amlnand */
+#include <search.h>
+#include <errno.h>
+
+#if defined(CONFIG_CMD_SAVEENV) && defined(CONFIG_AML_NAND)
+#define CMD_SAVEENV
+#elif defined(CONFIG_ENV_OFFSET_REDUND)
+#error CONFIG_ENV_OFFSET_REDUND must have CONFIG_CMD_SAVEENV & CONFIG_AML_NAND
+#endif
+
+#if defined(CONFIG_ENV_SIZE_REDUND) &&	\
+	(CONFIG_ENV_SIZE_REDUND != CONFIG_ENV_SIZE)
+#error CONFIG_ENV_SIZE_REDUND should be the same as CONFIG_ENV_SIZE
+#endif
+
+#ifndef CONFIG_ENV_RANGE
+#define CONFIG_ENV_RANGE	CONFIG_ENV_SIZE
+#endif
+
+#ifdef CONFIG_AML_NAND
+extern int amlnf_env_read(u_char *buf, int len);
+extern int amlnf_env_save(u_char *buf, int len);
+
+#ifndef CONFIG_STORE_COMPATIBLE
+char *env_name_spec = "aml-nand";
+#if defined(ENV_IS_EMBEDDED)
+env_t *env_ptr = &environment;
+#elif defined(CONFIG_NAND_ENV_DST)
+env_t *env_ptr = (env_t *)CONFIG_NAND_ENV_DST;
+#else /* ! ENV_IS_EMBEDDED */
+env_t *env_ptr;
+#endif /* ENV_IS_EMBEDDED */
+#endif /* CONFIG_STORE_COMPATIBLE */
+DECLARE_GLOBAL_DATA_PTR;
+/*
+ * This is called before nand_init() so we can't read NAND to
+ * validate env data.
+ *
+ * Mark it OK for now. env_relocate() in env_common.c will call our
+ * relocate function which does the real validation.
+ *
+ * When using a NAND boot image (like sequoia_nand), the environment
+ * can be embedded or attached to the U-Boot image in NAND flash.
+ * This way the SPL loads not only the U-Boot image from NAND but
+ * also the environment.
+ */
+#ifdef CONFIG_STORE_COMPATIBLE
+int amlnand_env_int(void)
+#else
+int env_init(void)
+#endif
+{
+#if defined(ENV_IS_EMBEDDED) || defined(CONFIG_NAND_ENV_DST)
+	int crc1_ok = 0, crc2_ok = 0;
+	env_t *tmp_env1;
+
+	tmp_env1 = env_ptr;
+	crc1_ok = crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc;
+
+	if (!crc1_ok && !crc2_ok) {
+		gd->env_addr	= 0;
+		gd->env_valid	= 0;
+
+		return 0;
+	} else if (crc1_ok && !crc2_ok) {
+		gd->env_valid = 1;
+	}
+
+	if (gd->env_valid == 1)
+		env_ptr = tmp_env1;
+
+	gd->env_addr = (ulong)env_ptr->data;
+
+#else /* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */
+	gd->env_addr	= (ulong)&default_environment[0];
+	gd->env_valid	= 1;
+#endif /* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */
+
+	return 0;
+}
+
+#ifdef CMD_SAVEENV
+#ifdef CONFIG_STORE_COMPATIBLE
+int amlnand_saveenv(void)
+#else
+int saveenv(void)
+#endif
+{
+	int	ret = 0;
+	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
+
+	ret = env_export(env_new);
+	if (ret)
+		return ret;
+
+	ret = amlnf_env_save((u_char *)env_new, CONFIG_ENV_SIZE);
+
+	return ret;
+}
+#endif /* CMD_SAVEENV */
+
+static int readenv(u_char *buf)
+{
+	int ret;
+
+	ret = amlnf_env_read(buf, CONFIG_ENV_SIZE);
+	if (ret) {
+		printf("%s() return %d\n", __func__, ret);
+	}
+	return ret;
+}
+
+/*
+ * The legacy NAND code saved the environment in the first NAND
+ * device i.e., nand_dev_desc + 0. This is also the behaviour using
+ * the new NAND code.
+ */
+#ifdef CONFIG_STORE_COMPATIBLE
+void amlnand_env_relocate_spec(void)
+#else
+void env_relocate_spec(void)
+#endif
+{
+#if !defined(ENV_IS_EMBEDDED)
+	int ret;
+	ALLOC_CACHE_ALIGN_BUFFER(u_char, buf, CONFIG_ENV_SIZE);
+
+	ret = readenv(buf);
+	if (ret) {
+		set_default_env("!readenv() failed");
+		//saveenv();
+		return;
+	}
+
+	env_import((char *)buf, 1);
+#endif /* ! ENV_IS_EMBEDDED */
+}
+
+#endif
diff --git a/common/env_common.c b/common/env_common.c
index af59c72..bcd7d89 100644
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -200,6 +200,7 @@ int env_import(const char *buf, int check)
 
 		if (crc32(0, ep->data, ENV_SIZE) != crc) {
 			set_default_env("!bad CRC");
+			run_command("saveenv", 0);
 			return 0;
 		}
 	}
diff --git a/common/env_mmc.c b/common/env_mmc.c
index 14648e3..d1e8b60 100644
--- a/common/env_mmc.c
+++ b/common/env_mmc.c
@@ -16,19 +16,24 @@
 #include <search.h>
 #include <errno.h>
 
+#ifdef CONFIG_STORE_COMPATIBLE
+	#include <emmc_partitions.h>
+	#include <partition_table.h>
+#endif
+
 #if defined(CONFIG_ENV_SIZE_REDUND) &&  \
 	(CONFIG_ENV_SIZE_REDUND != CONFIG_ENV_SIZE)
 #error CONFIG_ENV_SIZE_REDUND should be the same as CONFIG_ENV_SIZE
 #endif
 
+#ifndef CONFIG_STORE_COMPATIBLE
 char *env_name_spec = "MMC";
-
 #ifdef ENV_IS_EMBEDDED
 env_t *env_ptr = &environment;
 #else /* ! ENV_IS_EMBEDDED */
 env_t *env_ptr;
 #endif /* ENV_IS_EMBEDDED */
-
+#endif /* CONFIG_STORE_COMPATIBLE */
 DECLARE_GLOBAL_DATA_PTR;
 
 #if !defined(CONFIG_ENV_OFFSET)
@@ -38,13 +43,27 @@ DECLARE_GLOBAL_DATA_PTR;
 __weak int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr)
 {
 	s64 offset;
+#ifdef  CONFIG_STORE_COMPATIBLE
+	char *name = "env";
+	struct partitions *part_info = NULL;
+#endif
 
+#ifndef CONFIG_STORE_COMPATIBLE
 	offset = CONFIG_ENV_OFFSET;
 #ifdef CONFIG_ENV_OFFSET_REDUND
 	if (copy)
 		offset = CONFIG_ENV_OFFSET_REDUND;
 #endif
 
+#else /* CONFIG_STORE_COMPATIBLE */
+	part_info = find_mmc_partition_by_name(name);
+	if (part_info == NULL) {
+		printf("get partition info failed !!\n");
+		return -1;
+	}
+	offset = part_info->offset;
+	printf("mmc env offset: 0x%llx \n",offset);
+#endif
 	if (offset < 0)
 		offset += mmc->capacity;
 
@@ -53,7 +72,11 @@ __weak int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr)
 	return 0;
 }
 
+#ifdef CONFIG_STORE_COMPATIBLE
+int mmc_env_init(void)
+#else
 int env_init(void)
+#endif
 {
 	/* use default */
 	gd->env_addr	= (ulong)&default_environment[0];
@@ -137,7 +160,11 @@ static inline int write_env(struct mmc *mmc, unsigned long size,
 static unsigned char env_flags;
 #endif
 
+#ifdef CONFIG_STORE_COMPATIBLE
+int mmc_saveenv(void)
+#else
 int saveenv(void)
+#endif
 {
 	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
 	struct mmc *mmc = find_mmc_device(CONFIG_SYS_MMC_ENV_DEV);
@@ -203,7 +230,11 @@ static inline int read_env(struct mmc *mmc, unsigned long size,
 }
 
 #ifdef CONFIG_ENV_OFFSET_REDUND
+#ifdef CONFIG_STORE_COMPATIBLE
+void mmc_env_relocate_spec(void)
+#else
 void env_relocate_spec(void)
+#endif
 {
 #if !defined(ENV_IS_EMBEDDED)
 	struct mmc *mmc;
@@ -289,7 +320,12 @@ err:
 #endif
 }
 #else /* ! CONFIG_ENV_OFFSET_REDUND */
+
+#ifdef CONFIG_STORE_COMPATIBLE
+void mmc_env_relocate_spec(void)
+#else
 void env_relocate_spec(void)
+#endif
 {
 #if !defined(ENV_IS_EMBEDDED)
 	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
diff --git a/common/env_storage.c b/common/env_storage.c
new file mode 100644
index 0000000..a6f5af8
--- /dev/null
+++ b/common/env_storage.c
@@ -0,0 +1,94 @@
+/*
+ * (C) Copyright 2000-2010
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2008
+ * Stuart Wood, Lab X Technologies <stuart.wood@labxtechnologies.com>
+ *
+ * (C) Copyright 2004
+ * Jian Zhang, Texas Instruments, jzhang@ti.com.
+ *
+ * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Andreas Heppel <aheppel@sysgo.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+#include <malloc.h>
+#include <search.h>
+#include <errno.h>
+
+
+#ifdef CONFIG_STORE_COMPATIBLE
+#include <emmc_partitions.h>
+#include <partition_table.h>
+
+#ifdef ENV_IS_EMBEDDED
+env_t *env_ptr = &environment;
+#else /* ! ENV_IS_EMBEDDED */
+env_t *env_ptr;
+#endif /* ENV_IS_EMBEDDED */
+DECLARE_GLOBAL_DATA_PTR;
+
+char *env_name_spec = "aml-storage";
+
+/* env_init */
+extern int amlnand_env_int(void);
+extern int mmc_env_init(void);
+int env_init(void)
+{
+	/* use default */
+	gd->env_addr	= (ulong)&default_environment[0];
+	gd->env_valid	= 1;
+
+	return 0;
+}
+
+/* saveenv */
+#ifdef CONFIG_CMD_SAVEENV
+extern int amlnand_saveenv(void);
+extern int mmc_saveenv(void);
+int saveenv(void)
+{
+	int ret;
+
+	if (EMMC_BOOT_FLAG == device_boot_flag) {
+		ret = mmc_saveenv();
+#ifdef CONFIG_AML_NAND
+	} else if (NAND_BOOT_FLAG == device_boot_flag) {
+		ret = amlnand_saveenv();
+#endif
+	} else {
+		printf("%s() %d: device_boot_flag %d not exsit!\n",
+			__func__, __LINE__, device_boot_flag);
+		ret = -1;
+	}
+	return ret;
+}
+#endif /* CONFIG_CMD_SAVEENV */
+
+
+/* env_relocate_spec */
+extern void amlnand_env_relocate_spec(void);
+extern void mmc_env_relocate_spec(void);
+void env_relocate_spec(void)
+{
+	if (EMMC_BOOT_FLAG == device_boot_flag) {
+		mmc_env_relocate_spec();
+#ifdef CONFIG_AML_NAND
+	} else if (NAND_BOOT_FLAG == device_boot_flag) {
+		amlnand_env_relocate_spec();
+#endif
+	} else {
+		printf("%s() %d: device_boot_flag %d not exsit!\n",
+			__func__, __LINE__, device_boot_flag);
+	}
+	return;
+}
+
+
+#endif /* CONFIG_STORE_COMPATIBLE */
\ No newline at end of file
diff --git a/common/fb_mmc.c b/common/fb_mmc.c
index 6ea3938..32ad6c3 100644
--- a/common/fb_mmc.c
+++ b/common/fb_mmc.c
@@ -10,10 +10,16 @@
 #include <part.h>
 #include <aboot.h>
 #include <sparse_format.h>
+#include <usb/fastboot.h>
 
+__weak int board_fastboot_pre_flash(block_dev_desc_t *dev_desc, lbaint_t start,
+		void *buffer) { return 0; }
+
+#if !defined(CONFIG_DOS_PARTITION) || !defined(CONFIG_CMD_FASTBOOT)
 #ifndef CONFIG_FASTBOOT_GPT_NAME
 #define CONFIG_FASTBOOT_GPT_NAME GPT_ENTRY_NAME
 #endif
+#endif
 
 /* The 64 defined bytes plus the '\0' */
 #define RESPONSE_LEN	(64 + 1)
@@ -80,6 +86,24 @@ void fb_mmc_flash_write(const char *cmd, void *download_buffer,
 		return;
 	}
 
+#if defined(CONFIG_DOS_PARTITION) && defined(CONFIG_CMD_FASTBOOT)
+	fastboot_ptentry *ptn = fastboot_flash_find_ptn(cmd);
+	if (ptn == 0) {
+		printf("Partition:[%s] does not exist\n", cmd);
+		sprintf(response, "FAILpartition does not exist");
+	} else if (((download_bytes + (dev_desc->blksz - 1))
+				/ dev_desc->blksz > ptn->length) &&
+			!(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+		printf("Image too large for the partition\n");
+		sprintf(response, "FAILimage too large for partition");
+	} else {
+		info.start = ptn->start;
+		info.size = ptn->length;
+		info.blksz = dev_desc->blksz;
+
+		board_fastboot_pre_flash(dev_desc, ptn->start, download_buffer);
+	}
+#else
 	if (strcmp(cmd, CONFIG_FASTBOOT_GPT_NAME) == 0) {
 		printf("%s: updating MBR, Primary and Backup GPT(s)\n",
 		       __func__);
@@ -102,6 +126,7 @@ void fb_mmc_flash_write(const char *cmd, void *download_buffer,
 		fastboot_fail("cannot find partition");
 		return;
 	}
+#endif
 
 	if (is_sparse_image(download_buffer))
 		write_sparse_image(dev_desc, &info, cmd, download_buffer,
diff --git a/common/fdt_support.c b/common/fdt_support.c
index 8266bca..e2202b4 100644
--- a/common/fdt_support.c
+++ b/common/fdt_support.c
@@ -255,6 +255,80 @@ int fdt_initrd(void *fdt, ulong initrd_start, ulong initrd_end)
 	return 0;
 }
 
+#ifdef CONFIG_INSTABOOT
+#include <amlogic/instaboot.h>
+
+int fdt_instaboot(void *fdt)
+{
+	int   nodeoffset;
+	struct instaboot_info ib_info;
+	int err;
+	u32   tmp;
+	/* Find the "chosen" node.  */
+	nodeoffset = fdt_path_offset (fdt, "/chosen");
+
+	/* If there is no "chosen" node in the blob return */
+	if (nodeoffset < 0) {
+		printf("fdt_instaboot: %s\n", fdt_strerror(nodeoffset));
+		return nodeoffset;
+	}
+
+	err = get_instaboot_header(&ib_info);
+	if (err < 0) {
+		printf("fdt_instaboot: get header err\n");
+		return err;
+	}
+
+	err = fdt_setprop(fdt, nodeoffset,
+		"instaboot,sysname", ib_info.uts.sysname,
+			strlen(ib_info.uts.sysname)+1);
+	if (err < 0) {
+		printf("WARNING: could not set instaboot,sysname %s.\n",
+				fdt_strerror(err));
+		return err;
+	}
+
+	err = fdt_setprop(fdt, nodeoffset,
+		"instaboot,release", ib_info.uts.release,
+			strlen(ib_info.uts.release)+1);
+	if (err < 0) {
+		printf("WARNING: could not set instaboot,release %s.\n",
+				fdt_strerror(err));
+		return err;
+	}
+
+	err = fdt_setprop(fdt, nodeoffset,
+		"instaboot,version", ib_info.uts.version,
+			strlen(ib_info.uts.version)+1);
+	if (err < 0) {
+		printf("WARNING: could not set instaboot,version %s.\n",
+				fdt_strerror(err));
+		return err;
+	}
+
+	err = fdt_setprop(fdt, nodeoffset,
+		"instaboot,machine", ib_info.uts.machine,
+			strlen(ib_info.uts.machine)+1);
+	if (err < 0) {
+		printf("WARNING: could not set instaboot,machine %s.\n",
+				fdt_strerror(err));
+		return err;
+	}
+
+	tmp = __cpu_to_be32(ib_info.version_code);
+	err = fdt_setprop(fdt, nodeoffset,
+		"instaboot,version_code", &tmp, sizeof(tmp));
+	if (err < 0) {
+		printf("WARNING: could not set instaboot,version_code %s.\n",
+			fdt_strerror(err));
+
+		return err;
+	}
+	return 0;
+}
+
+#endif /* CONFIG_INSTABOOT */
+
 int fdt_chosen(void *fdt)
 {
 	int   nodeoffset;
diff --git a/common/hdmi_parameters.c b/common/hdmi_parameters.c
new file mode 100644
index 0000000..d1e118f
--- /dev/null
+++ b/common/hdmi_parameters.c
@@ -0,0 +1,582 @@
+#include <common.h>
+#include <linux/stddef.h>
+#include <amlogic/hdmi.h>
+
+static struct hdmi_format_para fmt_para_1920x1080p60_16x9 = {
+	.vic = HDMI_1920x1080p60_16x9,
+	.name = "1920x1080p60hz",
+	.sname = "1080p60hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 148500,
+	.timing = {
+		.pixel_freq = 148500,
+		.h_freq = 67500,
+		.v_freq = 60000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 1920,
+		.h_total = 2200,
+		.h_blank = 280,
+		.h_front = 88,
+		.h_sync = 44,
+		.h_back = 148,
+		.v_active = 1080,
+		.v_total = 1125,
+		.v_blank = 45,
+		.v_front = 4,
+		.v_sync = 5,
+		.v_back = 36,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_1920x1080p50_16x9 = {
+	.vic = HDMI_1920x1080p50_16x9,
+	.name = "1920x1080p50hz",
+	.sname = "1080p50hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 148500,
+	.timing = {
+		.pixel_freq = 148500,
+		.h_freq = 56250,
+		.v_freq = 50000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 1920,
+		.h_total = 2640,
+		.h_blank = 720,
+		.h_front = 528,
+		.h_sync = 44,
+		.h_back = 148,
+		.v_active = 1080,
+		.v_total = 1125,
+		.v_blank = 45,
+		.v_front = 4,
+		.v_sync = 5,
+		.v_back = 36,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_1920x1080p24_16x9 = {
+	.vic = HDMI_1920x1080p24_16x9,
+	.name = "1920x1080p24hz",
+	.sname = "1080p24hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 74250,
+	.timing = {
+		.pixel_freq = 74250,
+		.h_freq = 27000,
+		.v_freq = 24000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 1920,
+		.h_total = 2750,
+		.h_blank = 830,
+		.h_front = 638,
+		.h_sync = 44,
+		.h_back = 148,
+		.v_active = 1080,
+		.v_total = 1125,
+		.v_blank = 45,
+		.v_front = 4,
+		.v_sync = 5,
+		.v_back = 36,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p30_16x9 = {
+	.vic = HDMI_3840x2160p30_16x9,
+	.name = "3840x2160p30hz",
+	.sname = "2160p30hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 297000,
+	.timing = {
+		.pixel_freq = 297000,
+		.h_freq = 67500,
+		.v_freq = 30000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 3840,
+		.h_total = 4400,
+		.h_blank = 560,
+		.h_front = 176,
+		.h_sync = 88,
+		.h_back = 296,
+		.v_active = 2160,
+		.v_total = 2250,
+		.v_blank = 90,
+		.v_front = 8,
+		.v_sync = 10,
+		.v_back = 72,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p60_16x9 = {
+	.vic = HDMI_3840x2160p60_16x9,
+	.name = "3840x2160p60hz",
+	.sname = "2160p60hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 1,
+	.tmds_clk_div40 = 1,
+	.tmds_clk = 594000,
+	.timing = {
+		.pixel_freq = 594000,
+		.h_freq = 135000,
+		.v_freq = 60000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 3840,
+		.h_total = 4400,
+		.h_blank = 560,
+		.h_front = 176,
+		.h_sync = 88,
+		.h_back = 296,
+		.v_active = 2160,
+		.v_total = 2250,
+		.v_blank = 90,
+		.v_front = 8,
+		.v_sync = 10,
+		.v_back = 72,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p50_16x9 = {
+	.vic = HDMI_3840x2160p50_16x9,
+	.name = "3840x2160p50hz",
+	.sname = "2160p50hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 1,
+	.tmds_clk_div40 = 1,
+	.tmds_clk = 594000,
+	.timing = {
+		.pixel_freq = 594000,
+		.h_freq = 112500,
+		.v_freq = 50000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 3840,
+		.h_total = 5280,
+		.h_blank = 1440,
+		.h_front = 1056,
+		.h_sync = 88,
+		.h_back = 296,
+		.v_active = 2160,
+		.v_total = 2250,
+		.v_blank = 90,
+		.v_front = 8,
+		.v_sync = 10,
+		.v_back = 72,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p25_16x9 = {
+	.vic = HDMI_3840x2160p25_16x9,
+	.name = "3840x2160p25hz",
+	.sname = "2160p25hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 297000,
+	.timing = {
+		.pixel_freq = 297000,
+		.h_freq = 56250,
+		.v_freq = 25000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 3840,
+		.h_total = 5280,
+		.h_blank = 1440,
+		.h_front = 1056,
+		.h_sync = 88,
+		.h_back = 296,
+		.v_active = 2160,
+		.v_total = 2250,
+		.v_blank = 90,
+		.v_front = 8,
+		.v_sync = 10,
+		.v_back = 72,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p24_16x9 = {
+	.vic = HDMI_3840x2160p24_16x9,
+	.name = "3840x2160p24hz",
+	.sname = "2160p24hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 297000,
+	.timing = {
+		.pixel_freq = 297000,
+		.h_freq = 54000,
+		.v_freq = 24000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 3840,
+		.h_total = 5500,
+		.h_blank = 1660,
+		.h_front = 1276,
+		.h_sync = 88,
+		.h_back = 296,
+		.v_active = 2160,
+		.v_total = 2250,
+		.v_blank = 90,
+		.v_front = 8,
+		.v_sync = 10,
+		.v_back = 72,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_4096x2160p24_256x135 = {
+	.vic = HDMI_4096x2160p24_256x135,
+	.name = "4096x2160p24hz",
+	.sname = "smpte24hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 297000,
+	.timing = {
+		.pixel_freq = 297000,
+		.h_freq = 54000,
+		.v_freq = 24000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 4096,
+		.h_total = 5500,
+		.h_blank = 1404,
+		.h_front = 1020,
+		.h_sync = 88,
+		.h_back = 296,
+		.v_active = 2160,
+		.v_total = 2250,
+		.v_blank = 90,
+		.v_front = 8,
+		.v_sync = 10,
+		.v_back = 72,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_1920x1080i60_16x9 = {
+	.vic = HDMI_1920x1080i60_16x9,
+	.name = "1920x1080i60hz",
+	.sname = "1080i60hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 0,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 74250,
+	.timing = {
+		.pixel_freq = 74250,
+		.h_freq = 33750,
+		.v_freq = 60000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 1920,
+		.h_total = 2200,
+		.h_blank = 280,
+		.h_front = 88,
+		.h_sync = 44,
+		.h_back = 148,
+		.v_active = 1080/2,
+		.v_total = 1125,
+		.v_blank = 45/2,
+		.v_front = 2,
+		.v_sync = 5,
+		.v_back = 15,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_1920x1080i50_16x9 = {
+	.vic = HDMI_1920x1080i50_16x9,
+	.name = "1920x1080i50hz",
+	.sname = "1080i50hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 0,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 74250,
+	.timing = {
+		.pixel_freq = 74250,
+		.h_freq = 28125,
+		.v_freq = 50000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 1920,
+		.h_total = 2640,
+		.h_blank = 720,
+		.h_front = 528,
+		.h_sync = 44,
+		.h_back = 148,
+		.v_active = 1080/2,
+		.v_total = 1125,
+		.v_blank = 45/2,
+		.v_front = 2,
+		.v_sync = 5,
+		.v_back = 15,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_1280x720p60_16x9 = {
+	.vic = HDMI_1280x720p60_16x9,
+	.name = "1280x720p60hz",
+	.sname = "720p60hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 74250,
+	.timing = {
+		.pixel_freq = 74250,
+		.h_freq = 45000,
+		.v_freq = 60000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 1280,
+		.h_total = 1650,
+		.h_blank = 370,
+		.h_front = 110,
+		.h_sync = 40,
+		.h_back = 220,
+		.v_active = 720,
+		.v_total = 750,
+		.v_blank = 30,
+		.v_front = 5,
+		.v_sync = 5,
+		.v_back = 20,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_1280x720p50_16x9 = {
+	.vic = HDMI_1280x720p50_16x9,
+	.name = "1280x720p50hz",
+	.sname = "720p50hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 74250,
+	.timing = {
+		.pixel_freq = 74250,
+		.h_freq = 37500,
+		.v_freq = 50000,
+		.vsync_polarity = 1,
+		.hsync_polarity = 1,
+		.h_active = 1280,
+		.h_total = 1980,
+		.h_blank = 700,
+		.h_front = 440,
+		.h_sync = 40,
+		.h_back = 220,
+		.v_active = 720,
+		.v_total = 750,
+		.v_blank = 30,
+		.v_front = 5,
+		.v_sync = 5,
+		.v_back = 20,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_720x480p60_16x9 = {
+	.vic = HDMI_720x480p60_16x9,
+	.name = "720x480p60hz",
+	.sname = "480p60hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 27000,
+	.timing = {
+		.pixel_freq = 27000,
+		.h_freq = 31469,
+		.v_freq = 59940,
+		.vsync_polarity = 0,
+		.hsync_polarity = 0,
+		.h_active = 720,
+		.h_total = 858,
+		.h_blank = 138,
+		.h_front = 16,
+		.h_sync = 62,
+		.h_back = 60,
+		.v_active = 480,
+		.v_total = 525,
+		.v_blank = 45,
+		.v_front = 9,
+		.v_sync = 6,
+		.v_back = 30,
+		.v_sync_ln = 7,
+	},
+};
+
+static struct hdmi_format_para fmt_para_720x480i60_16x9 = {
+	.vic = HDMI_720x480i60_16x9,
+	.name = "720x480i60hz",
+	.sname = "480i60hz",
+	.pixel_repetition_factor = 1,
+	.progress_mode = 0,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 27000,
+	.timing = {
+		.pixel_freq = 27000,
+		.h_freq = 15734,
+		.v_freq = 59940,
+		.vsync_polarity = 0,
+		.hsync_polarity = 0,
+		.h_active = 1440,
+		.h_total = 1716,
+		.h_blank = 276,
+		.h_front = 38,
+		.h_sync = 124,
+		.h_back = 114,
+		.v_active = 480/2,
+		.v_total = 525,
+		.v_blank = 45/2,
+		.v_front = 4,
+		.v_sync = 3,
+		.v_back = 15,
+		.v_sync_ln = 4,
+	},
+};
+
+static struct hdmi_format_para fmt_para_720x576p50_16x9 = {
+	.vic = HDMI_720x576p50_16x9,
+	.name = "720x576p50hz",
+	.sname = "576p50hz",
+	.pixel_repetition_factor = 0,
+	.progress_mode = 1,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 27000,
+	.timing = {
+		.pixel_freq = 27000,
+		.h_freq = 31250,
+		.v_freq = 50000,
+		.vsync_polarity = 0,
+		.hsync_polarity = 0,
+		.h_active = 720,
+		.h_total = 864,
+		.h_blank = 144,
+		.h_front = 12,
+		.h_sync = 64,
+		.h_back = 68,
+		.v_active = 576,
+		.v_total = 625,
+		.v_blank = 49,
+		.v_front = 5,
+		.v_sync = 5,
+		.v_back = 39,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para fmt_para_720x576i50_16x9 = {
+	.vic = HDMI_720x576i50_16x9,
+	.name = "720x576i50hz",
+	.sname = "576i50hz",
+	.pixel_repetition_factor = 1,
+	.progress_mode = 0,
+	.scrambler_en = 0,
+	.tmds_clk_div40 = 0,
+	.tmds_clk = 27000,
+	.timing = {
+		.pixel_freq = 27000,
+		.h_freq = 15625,
+		.v_freq = 50000,
+		.vsync_polarity = 0,
+		.hsync_polarity = 0,
+		.h_active = 1440,
+		.h_total = 1728,
+		.h_blank = 288,
+		.h_front = 24,
+		.h_sync = 126,
+		.h_back = 138,
+		.v_active = 576/2,
+		.v_total = 625,
+		.v_blank = 49/2,
+		.v_front = 2,
+		.v_sync = 3,
+		.v_back = 19,
+		.v_sync_ln = 1,
+	},
+};
+
+static struct hdmi_format_para *all_fmt_paras[] = {
+	&fmt_para_3840x2160p60_16x9,
+	&fmt_para_3840x2160p50_16x9,
+	&fmt_para_3840x2160p30_16x9,
+	&fmt_para_3840x2160p25_16x9,
+	&fmt_para_3840x2160p24_16x9,
+	&fmt_para_4096x2160p24_256x135,
+	&fmt_para_1920x1080p50_16x9,
+	&fmt_para_1920x1080p60_16x9,
+	&fmt_para_1920x1080p24_16x9,
+	&fmt_para_1920x1080i60_16x9,
+	&fmt_para_1920x1080i50_16x9,
+	&fmt_para_1280x720p60_16x9,
+	&fmt_para_1280x720p50_16x9,
+	&fmt_para_720x480p60_16x9,
+	&fmt_para_720x480i60_16x9,
+	&fmt_para_720x576p50_16x9,
+	&fmt_para_720x576i50_16x9,
+};
+
+struct hdmi_format_para *hdmi_get_fmt_paras(enum hdmi_vic vic)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(all_fmt_paras); i++) {
+		if (vic == all_fmt_paras[i]->vic)
+			return all_fmt_paras[i];
+	}
+	return NULL;
+}
+
+/*
+ * Paramter 'name' can be 1080p60hz, or 1920x1080p60hz
+ * or 3840x2160p60hz, 2160p60hz
+ * or 3840x2160p60hz420, 2160p60hz420 (Y420 mode)
+ */
+enum hdmi_vic hdmi_get_fmt_vic(char const *name)
+{
+	int i;
+	char *lname;
+
+	for (i = 0; i < ARRAY_SIZE(all_fmt_paras); i++) {
+		lname = all_fmt_paras[i]->name;
+		if (strncmp(lname, name, strlen(lname)) == 0)
+			return all_fmt_paras[i]->vic;
+		lname = all_fmt_paras[i]->sname;
+		if (strncmp(lname, name, strlen(lname)) == 0)
+			return all_fmt_paras[i]->vic;
+	}
+	return HDMI_unkown;
+}
diff --git a/common/image-android.c b/common/image-android.c
index 59079fc..e82ff2b 100644
--- a/common/image-android.c
+++ b/common/image-android.c
@@ -9,6 +9,9 @@
 #include <android_image.h>
 #include <malloc.h>
 #include <errno.h>
+static const unsigned char lzop_magic[] = {
+	0x89, 0x4c, 0x5a, 0x4f, 0x00, 0x0d, 0x0a, 0x1a, 0x0a
+};
 
 static char andr_tmp_str[ANDR_BOOT_ARGS_SIZE + 1];
 
@@ -35,13 +38,14 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 	 * sha1 (or anything) so we don't check it. It is not obvious that the
 	 * string is null terminated so we take care of this.
 	 */
+	ulong end;
 	strncpy(andr_tmp_str, hdr->name, ANDR_BOOT_NAME_SIZE);
 	andr_tmp_str[ANDR_BOOT_NAME_SIZE] = '\0';
 	if (strlen(andr_tmp_str))
 		printf("Android's image name: %s\n", andr_tmp_str);
 
-	printf("Kernel load addr 0x%08x size %u KiB\n",
-	       hdr->kernel_addr, DIV_ROUND_UP(hdr->kernel_size, 1024));
+	debug("Kernel load addr 0x%08x size %u KiB\n",
+	      hdr->kernel_addr, DIV_ROUND_UP(hdr->kernel_size, 1024));
 
 	int len = 0;
 	if (*hdr->cmdline) {
@@ -75,6 +79,17 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 	}
 	if (os_len)
 		*os_len = hdr->kernel_size;
+
+#if defined(CONFIG_ANDROID_IMG)
+			images.ft_len = (ulong)(hdr->second_size);
+			end = (ulong)hdr;
+			end += hdr->page_size;
+			end += ALIGN(hdr->kernel_size, hdr->page_size);
+			images.rd_start = end;
+			end += ALIGN(hdr->ramdisk_size, hdr->page_size);
+			images.ft_addr = (char *)end;
+#endif
+
 	return 0;
 }
 
@@ -110,8 +125,8 @@ int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
 	if (!hdr->ramdisk_size)
 		return -1;
 
-	printf("RAM disk load addr 0x%08x size %u KiB\n",
-	       hdr->ramdisk_addr, DIV_ROUND_UP(hdr->ramdisk_size, 1024));
+	debug("RAM disk load addr 0x%08x size %u KiB\n",
+	      hdr->ramdisk_addr, DIV_ROUND_UP(hdr->ramdisk_size, 1024));
 
 	*rd_data = (unsigned long)hdr;
 	*rd_data += hdr->page_size;
@@ -120,3 +135,44 @@ int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
 	*rd_len = hdr->ramdisk_size;
 	return 0;
 }
+
+ulong android_image_get_comp(const struct andr_img_hdr *os_hdr)
+{
+	int i;
+	unsigned char *src = (unsigned char *)os_hdr + os_hdr->page_size;
+	/* read magic: 9 first bytes */
+	for (i = 0; i < ARRAY_SIZE(lzop_magic); i++) {
+		if (*src++ != lzop_magic[i])
+				break;
+	}
+	if (i == ARRAY_SIZE(lzop_magic))
+		return IH_COMP_LZO;
+	else
+		return IH_COMP_NONE;
+}
+int android_image_need_move(ulong *img_addr, const struct andr_img_hdr *hdr)
+{
+	ulong kernel_load_addr = android_image_get_kload(hdr);
+	ulong img_start = *img_addr;
+	ulong val = 0;
+	if (kernel_load_addr > img_start)
+		val = kernel_load_addr - img_start;
+	else
+		val = img_start - kernel_load_addr;
+	if (android_image_get_comp(hdr) == IH_COMP_NONE)
+		return 0;
+	if (val < 32*1024*1024) {
+		ulong total_size = android_image_get_end(hdr)-(ulong)hdr;
+		void *reloc_addr = malloc(total_size);
+		if (!reloc_addr) {
+			puts("Error: malloc in  android_image_need_move failed!\n");
+			return -ENOMEM;
+		}
+		printf("reloc_addr =%lx\n", (ulong)reloc_addr);
+		memset(reloc_addr, 0, total_size);
+		memmove(reloc_addr, hdr, total_size);
+		*img_addr = (ulong)reloc_addr;
+		printf("copy done\n");
+	}
+	return 0;
+}
diff --git a/common/image-fdt.c b/common/image-fdt.c
index e3f06cd..835d341 100644
--- a/common/image-fdt.c
+++ b/common/image-fdt.c
@@ -15,6 +15,9 @@
 #include <image.h>
 #include <libfdt.h>
 #include <asm/io.h>
+#ifdef CONFIG_INSTABOOT
+#include <amlogic/instaboot.h>
+#endif
 
 #ifndef CONFIG_SYS_FDT_PAD
 #define CONFIG_SYS_FDT_PAD 0x3000
@@ -238,12 +241,14 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 #endif
 	const char *select = NULL;
 	int		ok_no_fdt = 0;
-
+#ifndef CONFIG_ANDROID_IMG
 	*of_flat_tree = NULL;
 	*of_size = 0;
+#endif
 
 	if (argc > 2)
 		select = argv[2];
+
 	if (select || genimg_has_config(images)) {
 #if defined(CONFIG_FIT)
 		if (select) {
@@ -417,8 +422,24 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 			goto no_fdt;
 		}
 	} else {
+		#if defined(CONFIG_ANDROID_IMG)
+		if (images->ft_len) {
+			fdt_blob = (char *)images->ft_addr;
+
+			if (fdt_check_header(fdt_blob) != 0) {
+				fdt_error("image is not a fdt");
+				goto error;
+			}
+			/*
+			if (fdt_totalsize(fdt_blob) != images->ft_len) {
+				fdt_error("fdt size != image size");
+				goto error;
+			}*/
+		}
+		#else
 		debug("## No Flattened Device Tree\n");
 		goto no_fdt;
+		#endif
 	}
 
 	*of_flat_tree = fdt_blob;
@@ -515,6 +536,10 @@ int image_setup_libfdt(bootm_headers_t *images, void *blob,
 	if (!ft_verify_fdt(blob))
 		goto err;
 
+#ifdef CONFIG_INSTABOOT
+	fdt_instaboot(blob);
+#endif
+
 #if defined(CONFIG_SOC_KEYSTONE)
 	if (IMAGE_OF_BOARD_SETUP)
 		ft_board_setup_ex(blob, gd->bd);
diff --git a/common/instaboot.c b/common/instaboot.c
new file mode 100644
index 0000000..c821599
--- /dev/null
+++ b/common/instaboot.c
@@ -0,0 +1,60 @@
+#include <common.h>
+#include <amlogic/storage_if.h>
+#include <amlogic/instaboot.h>
+#include <partition_table.h>
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE 4096
+#endif
+struct instaboot_header {
+	char reserved[PAGE_SIZE - 10 -
+		sizeof(struct new_utsname) - sizeof(u32)];
+	struct new_utsname uts;
+	u32 version_code;
+	char	sig[10];
+} __attribute__((packed));
+
+static struct instaboot_header ib_header;
+
+int has_instaboot_part(void)
+{
+	struct partitions *part_table = NULL;
+	int i, name_len, ret = 0;
+	int part_num = get_partitions_table(&part_table);
+	name_len = strlen("instaboot");
+	for (i = 0; i < part_num; i++) {
+		if (!strncmp(part_table[i].name, "instaboot", name_len)) {
+			ret = 1;
+			break;
+		}
+	}
+	return ret;
+}
+int get_instaboot_header(struct instaboot_info* ib_info)
+{
+	int rc = 0;
+	u64 partSz = 0;
+
+	if (!has_instaboot_part())
+		return -1;
+	rc = store_get_partititon_size((unsigned char*)"instaboot", &partSz);
+	if (rc || !partSz) {
+	    //printf("can not get instaboot part size\n");
+	    return -1;
+	}
+	rc = store_read_ops((unsigned char*)"instaboot",
+		(unsigned char*)&ib_header, 0, PAGE_SIZE);
+	if (rc) {
+	    printf("read instaboo header error\n");
+	    return -1;
+	}
+	if (!strncmp(ib_header.sig, INSTABOOT_SIG, strlen(INSTABOOT_SIG))) {
+		memcpy(&ib_info->uts, &ib_header.uts, sizeof(struct new_utsname));
+		ib_info->version_code = ib_header.version_code;
+	} else {
+		printf("signature: %s\n", ib_header.sig);
+		return -1;
+	}
+
+	return 0;
+}
\ No newline at end of file
diff --git a/common/main.c b/common/main.c
index 2979fbe..5034c3d 100644
--- a/common/main.c
+++ b/common/main.c
@@ -82,6 +82,37 @@ void main_loop(void)
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
 
+#if defined(CONFIG_AML_UBOOT_AUTO_TEST)
+	//stick 0 and stick 1 will be used to check the boot process of uboot
+	//stick 0 is the start counter (0xC8834400 + 0x7C<<2) = 0xc88345f0
+	//stick 1 is the end counter   (0xC8834400 + 0x7D<<2) = 0xc88345f4
+	if (*((volatile unsigned int*)(0xc88345f0)))
+	{
+		printf("\n\naml log : TE = %d\n",*((volatile unsigned int*)0xc1109988));
+		*((volatile unsigned int*)(0xc88345f4)) += 1; //stick 1
+		printf("\n\naml log : Boot success %d times @ %d\n",*((volatile unsigned int*)(0xc88345f4)),
+			*((volatile unsigned int*)(0xc88345f0))); //stick 0 set in bl2_main.c
+		int ndelay = 10;
+		int nabort = 0;
+		while (ndelay)
+		{
+			udelay(1);
+			if (tstc())
+			switch (getc())
+			{
+			//case 0x20: /* Space */
+			case 0x0d: /* Enter */
+				nabort = 1;
+				break;
+			}
+			ndelay -= 1;
+		}
+		if (!nabort)
+			run_command("reset",0);
+	}
+#endif //#if defined(CONFIG_AML_UBOOT_AUTO_TEST)
+
+
 	autoboot_command(s);
 
 	cli_loop();
diff --git a/common/partitions.c b/common/partitions.c
new file mode 100644
index 0000000..5f755eb
--- /dev/null
+++ b/common/partitions.c
@@ -0,0 +1,114 @@
+#include <common.h>
+#include <malloc.h>
+#include <linux/err.h>
+#include <partition_table.h>
+#include <libfdt.h>
+
+
+struct partitions_data{
+	int nr;
+	struct partitions *parts;
+};
+
+struct partitions *part_table = NULL;
+static int parts_total_num;
+
+int get_partitions_table(struct partitions **table)
+{
+	int ret = 0;
+	if (part_table && parts_total_num) {
+		*table = part_table;
+		ret = parts_total_num;
+	}
+	return ret;
+}
+
+int get_partition_from_dts(unsigned char * buffer)
+{
+	char * dt_addr;
+	int nodeoffset,poffset=0;
+	int* parts_num;
+	char propname[8];
+	const uint32_t *phandle;
+	const char* uname;
+	const char* usize;
+	const char* umask;
+	int index;
+	int ret = -1;
+
+	if ( buffer == NULL)
+		goto _err;
+#ifdef CONFIG_MULTI_DTB
+	extern unsigned long get_multi_dt_entry(unsigned long fdt_addr);
+	dt_addr = (char *)get_multi_dt_entry((unsigned long)buffer);
+#else
+	dt_addr = (char *)buffer;
+#endif
+	printf("start dts,buffer=%p,dt_addr=%p\n", buffer, dt_addr);
+	ret = fdt_check_header(dt_addr);
+	if ( ret < 0 )
+	{
+		printf("%s: %s\n",__func__,fdt_strerror(ret));
+		goto _err;
+	}
+	nodeoffset = fdt_path_offset(dt_addr, "/partitions");
+	if (nodeoffset < 0)
+	{
+		printf("%s: not find /partitions node %s.\n",__func__,fdt_strerror(nodeoffset));
+		ret = -1;
+		goto _err;
+	}
+	parts_num = (int *)fdt_getprop(dt_addr, nodeoffset, "parts", NULL);
+	printf("parts: %d\n",be32_to_cpup((u32*)parts_num));
+
+	if (parts_num > 0)
+	{
+		part_table = (struct partitions *)malloc(sizeof(struct partitions)*(be32_to_cpup((u32*)parts_num)));
+		if (!part_table) {
+			printk("%s part_table alloc _err\n",__func__);
+			//kfree(data);
+			return -1;
+		}
+		memset(part_table, 0, sizeof(struct partitions)*(be32_to_cpup((u32*)parts_num)));
+		parts_total_num = be32_to_cpup((u32*)parts_num);
+	}
+	for (index = 0; index < be32_to_cpup((u32*)parts_num); index++)
+	{
+		sprintf(propname,"part-%d", index);
+
+		phandle = fdt_getprop(dt_addr, nodeoffset, propname, NULL);
+		if (!phandle) {
+			printf("don't find  match part-%d\n",index);
+			goto _err;
+		}
+		if (phandle) {
+			poffset = fdt_node_offset_by_phandle(dt_addr, be32_to_cpup((u32*)phandle));
+			if (!poffset) {
+				printf("%s:%d,can't find device node\n",__func__,__LINE__);
+				goto _err;
+			}
+		}
+		uname = fdt_getprop(dt_addr, poffset, "pname", NULL);
+		//printf("%s:%d  uname: %s\n",__func__,__LINE__, uname);
+		/* a string but not */
+		usize = fdt_getprop(dt_addr, poffset, "size", NULL);
+		//printf("%s:%d size: 0x%x  0x%x\n",__func__,__LINE__, be32_to_cpup((u32*)usize), be32_to_cpup((((u32*)usize)+1)));
+		umask = fdt_getprop(dt_addr, poffset, "mask", NULL);
+		//printf("%s:%d mask: 0x%x\n",__func__,__LINE__, be32_to_cpup((u32*)umask));
+		/* fill parition table */
+		if (uname != NULL)
+			memcpy(part_table[index].name, uname, strlen(uname));
+		part_table[index].size = ((unsigned long)be32_to_cpup((u32*)usize) << 32) | (unsigned long)be32_to_cpup((((u32*)usize)+1));
+		part_table[index].mask_flags = be32_to_cpup((u32*)umask);
+		printf("%02d:%10s\t%016llx %01x\n", index, uname, part_table[index].size, part_table[index].mask_flags);
+	}
+	return 0;
+
+_err:
+	if (part_table != NULL) {
+		free(part_table);
+		part_table = NULL;
+	}
+	return ret;
+}
+
diff --git a/common/store_interface.c b/common/store_interface.c
new file mode 100644
index 0000000..5e97990
--- /dev/null
+++ b/common/store_interface.c
@@ -0,0 +1,1370 @@
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <watchdog.h>
+#include <malloc.h>
+#if defined(CONFIG_AML_NAND)
+#include <nand.h>
+#include <asm/arch/nand.h>
+#endif
+#include <mmc.h>
+#include <linux/ctype.h>
+#include <asm/byteorder.h>
+#include <div64.h>
+#include <linux/err.h>
+#include<partition_table.h>
+#include <libfdt.h>
+#include <linux/string.h>
+
+#if defined(CONFIG_AML_NAND)
+extern int amlnf_init(unsigned flag);
+extern int amlnf_key_write(u8 *buf, int len);
+extern int amlnf_key_read(u8 * buf, int len);
+#endif
+extern int get_partition_from_dts(unsigned char * buffer);
+extern int mmc_key_read(unsigned char *buf, unsigned int size);
+extern int mmc_key_write(unsigned char *buf, unsigned int size);
+extern int mmc_key_erase(void);
+
+#define MsgP(fmt...)   printf("[store]"fmt)
+#define ErrP(fmt...)   printf("[store]Err:%s,L%d:", __func__, __LINE__),printf(fmt)
+
+#define NAND_INIT_FAILED 20
+#define STORE_BOOT_NORMAL					0
+#define STORE_BOOT_UPGRATE					1
+#define STORE_BOOT_ERASE_PROTECT_CACHE       	          2
+#define STORE_BOOT_ERASE_ALL   				          3
+#define STORE_BOOT_SCRUB_ALL				          4
+
+#define _SPI_FLASH_ERASE_SZ      (CONFIG_ENV_IN_SPI_OFFSET + CONFIG_ENV_SIZE)
+#define CONFIG_ENV_IN_SPI_OFFSET 0
+//Ignore mbr since mmc driver already handled
+//#define MMC_UBOOT_CLEAR_MBR
+#define MMC_BOOT_PARTITION_SUPPORT
+
+#ifdef MMC_UBOOT_CLEAR_MBR
+static char _mbrFlag[4] ;
+#endif
+
+//extern void get_device_boot_flag(void);
+static int _info_disprotect_back_before_mmcinfo1 = 0;//mmcinfo 1 will clear info_disprotect before run_command("mmc erase 1")
+int info_disprotect = 0;
+static inline int isstring(char *p)
+{
+	char *endptr = p;
+	while (*endptr != '\0') {
+		if (!(((*endptr >= '0') && (*endptr <= '9'))
+			|| ((*endptr >= 'a') && (*endptr <= 'f'))
+			|| ((*endptr >= 'A') && (*endptr <= 'F'))
+			|| (*endptr == 'x') || (*endptr == 'X')))
+			return 1;
+		endptr++;
+	}
+
+	return 0;
+}
+
+static inline int str2long(char *p, ulong *num)
+{
+	char *endptr;
+	*num = simple_strtoul(p, &endptr, 16);
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+static inline int str2longlong(char *p, unsigned long long *num)
+{
+	char *endptr;
+
+	*num = simple_strtoull(p, &endptr, 16);
+	if (*endptr != '\0')
+	{
+	    switch (*endptr)
+	    {
+	        case 'g':
+	        case 'G':
+	            *num<<=10;
+	        case 'm':
+	        case 'M':
+	            *num<<=10;
+	        case 'k':
+	        case 'K':
+	            *num<<=10;
+	            endptr++;
+	            break;
+	    }
+	}
+
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static int emmc_init(void)
+{
+	int ret = -1;
+	struct mmc *mmc = NULL;
+	mmc = find_mmc_device(1);
+	if (mmc) {
+		ret = mmc_init(mmc); // init eMMC/tSD+
+	}
+	return ret;
+}
+
+static int get_device_boot_flag(void)
+{
+	int ret=0;
+    if (1) {//nand and emmc
+		//try eMMC init
+		device_boot_flag = EMMC_BOOT_FLAG;
+		ret = emmc_init();
+        if (!ret) {
+			printf("XXXXXXX======enter EMMC boot======XXXXXX\n");
+			return 0;
+		}
+		printf("EMMC init failed\n");
+
+#if defined(CONFIG_AML_NAND)
+
+		//try nand first
+		device_boot_flag = NAND_BOOT_FLAG;
+		ret = amlnf_init(0x5);
+        if (!ret) {
+			printf("XXXXXXX======enter NAND boot======XXXXXX\n");
+			return 0;
+		}
+		printf("NAND init failed\n");
+#endif //CONFIG_AML_NAND
+	}
+
+	printf("device_boot_flag=%d\n",device_boot_flag);
+	return -1;
+}
+
+static int get_off_size(int argc, char *argv[],  loff_t *off, loff_t *size)
+{
+        if (argc >= 1) {
+            if (!(str2longlong(argv[0], (unsigned long long*)off))) {
+			store_msg("'%s' is not a number\n", argv[0]);
+				return -1;
+			}
+		} else {
+				*off = 0;
+				*size = 0;
+		}
+
+        if (argc >= 2) {
+                if (!(str2longlong(argv[1], (unsigned long long *)size))) {
+						store_msg("'%s' is not a number\n", argv[1]);
+						return -1;
+				}
+		}else{
+				*size = 0;
+		}
+
+		store_dbg("offset 0x%llx, size 0x%llx", *off, *size);
+
+		return 0;
+}
+
+//store dtb read/write buff size
+static int do_store_dtb_ops(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+        int ret = 0;
+        char _cmdBuf[128];
+        char* ops = argv[2];
+        const unsigned maxDtbSz = 256 * 1024;
+        unsigned actualDtbSz = 0;
+        char* devCmd = NULL;
+        char* dtbLoadaddr = argv[3];
+
+        if (argc < 4) return CMD_RET_USAGE;
+
+        const int is_write = !strcmp("write", ops);
+        if (!is_write) {
+                ret = !strcmp("read", ops) || !strcmp("iread", ops);//must be 0
+                if (!ret) return CMD_RET_USAGE;
+        }
+
+        actualDtbSz = maxDtbSz;
+        if (argc > 4) {
+                const unsigned bufSz = simple_strtoul(argv[4], NULL, 0);
+                if (bufSz > maxDtbSz) {
+                        ErrP("bufSz (%s) > max 0x%x\n", argv[4], maxDtbSz);
+                        return CMD_RET_FAILURE;
+                }
+        }
+
+        ops = is_write ? "dtb_write" : "dtb_read";
+
+        switch (device_boot_flag)
+        {
+                case NAND_BOOT_FLAG:
+                case SPI_NAND_FLAG:
+                        {
+                                devCmd = "amlnf";
+                        }
+                        break;
+
+                case EMMC_BOOT_FLAG:
+                case SPI_EMMC_FLAG:
+                        {
+                                devCmd = "emmc";
+                        }
+                        break;
+
+                default:
+                        ErrP("device_boot_flag=0x%x err\n", device_boot_flag);
+                        return CMD_RET_FAILURE;
+        }
+
+        sprintf(_cmdBuf, "%s %s %s 0x%x", devCmd, ops, dtbLoadaddr, actualDtbSz);
+        MsgP("To run cmd[%s]\n", _cmdBuf);
+        ret = run_command(_cmdBuf, 0);
+
+#ifdef CONFIG_MULTI_DTB
+        if (!is_write && strcmp("iread", ops))
+        {
+                extern unsigned long get_multi_dt_entry(unsigned long fdt_addr);
+                unsigned long dtImgAddr = simple_strtoul(dtbLoadaddr, NULL, 16);
+
+                unsigned long fdtAddr = get_multi_dt_entry(dtImgAddr);
+                ret = fdt_check_header((char*)fdtAddr);
+                if (ret) {
+                        ErrP("Fail in fdt check header\n");
+                        return CMD_RET_FAILURE;
+                }
+                unsigned fdtsz    = fdt_totalsize((char*)fdtAddr);
+                memmove((char*)dtImgAddr, (char*)fdtAddr, fdtsz);
+        }
+#endif// #ifdef CONFIG_MULTI_DTB
+
+        return ret;
+}
+
+static int do_store_key_ops(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	char _cmdBuf[128];
+	char* ops = argv[2];
+	const unsigned maxKyeSz = 256 * 1024;
+	unsigned actualDtbSz = 0;
+	char* devCmd = NULL;
+
+    if (argc < 4) return CMD_RET_USAGE;
+
+	const int is_write = !strcmp("write", ops);
+    if (!is_write) {
+		ret = strcmp("read", ops);//must be 0
+        if (ret) return CMD_RET_USAGE;
+	}
+
+	actualDtbSz = maxKyeSz;
+    if (argc > 4) {
+		const unsigned bufSz = simple_strtoul(argv[4], NULL, 0);
+        if (bufSz > maxKyeSz) {
+			ErrP("bufSz (%s) > max 0x%x\n", argv[4], maxKyeSz);
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	ops = is_write ? "key_write" : "key_read";
+
+    switch (device_boot_flag)
+	{
+		case NAND_BOOT_FLAG:
+		case SPI_NAND_FLAG:
+			{
+				devCmd = "amlnf";
+			}
+			break;
+
+		case EMMC_BOOT_FLAG:
+		case SPI_EMMC_FLAG:
+			{
+				devCmd = "emmc";
+			}
+			break;
+
+		default:
+			ErrP("device_boot_flag=0x%x err\n", device_boot_flag);
+			return CMD_RET_FAILURE;
+	}
+
+	sprintf(_cmdBuf, "%s %s %s 0x%x", devCmd, ops, argv[3], actualDtbSz);
+	MsgP("To run cmd[%s]\n", _cmdBuf);
+	ret = run_command(_cmdBuf, 0);
+
+	return ret;
+}
+
+int store_key_read(uint8_t * buffer,  uint32_t length)
+{
+	int ret = 0;
+	switch (device_boot_flag)
+	{
+#if defined(CONFIG_AML_NAND)
+		case NAND_BOOT_FLAG:
+		case SPI_NAND_FLAG:
+		ret = amlnf_key_read(buffer, (int) length);
+		break;
+#endif
+		case EMMC_BOOT_FLAG:
+		case SPI_EMMC_FLAG:
+		ret = mmc_key_read(buffer, (int) length);
+		break;
+		default:
+		ErrP("device_boot_flag=0x%x err\n", device_boot_flag);
+			return CMD_RET_FAILURE;
+	}
+	return ret;
+}
+
+int store_key_write(uint8_t * buffer, uint32_t length)
+{
+	int ret = 0;
+	switch (device_boot_flag)
+	{
+#if defined(CONFIG_AML_NAND)
+		case NAND_BOOT_FLAG:
+		case SPI_NAND_FLAG:
+		ret = amlnf_key_write(buffer, (int) length);
+		break;
+#endif
+		case EMMC_BOOT_FLAG:
+		case SPI_EMMC_FLAG:
+		ret = mmc_key_write(buffer, (int) length);
+		break;
+		default:
+		ErrP("device_boot_flag=0x%x err\n", device_boot_flag);
+			return CMD_RET_FAILURE;
+	}
+	return ret;
+}
+
+static int do_store_init(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int i, init_flag=0, ret = 0;
+	char *cmd = "";
+	char	str[128];
+
+	init_flag = (argc > 2) ? (int)simple_strtoul(argv[2], NULL, 16) : 0;
+	store_dbg("init_flag %d",init_flag);
+
+    if (device_boot_flag == _AML_DEVICE_BOOT_FLAG_DEFAULT ) {
+		i = get_device_boot_flag();
+        if (i) {
+			MsgP("ERR:FAILED in get_device_boot_flag\n");
+			return __LINE__;
+		}
+	}
+
+    switch (device_boot_flag)
+	{
+#if defined(CONFIG_AML_NAND)
+		case NAND_BOOT_FLAG:
+			{
+                if ((init_flag >=STORE_BOOT_ERASE_PROTECT_CACHE) && (init_flag <=STORE_BOOT_SCRUB_ALL)) {
+					sprintf(str, "amlnf  init  %d ",init_flag);
+					run_command(str, 0);
+				}
+
+				sprintf(str, "amlnf  init  %d ",1);
+				printf("command:	%s <- %d\n", str, init_flag);
+				device_boot_flag = NAND_BOOT_FLAG;
+				ret = run_command(str, 0);
+                if (ret != 0) {
+#if	0
+                    if ((ret == NAND_INIT_FAILED) && (init_flag == STORE_BOOT_ERASE_ALL)) {
+						sprintf(str, "amlnf  init  %d ",4);
+						ret = run_command(str, 0);
+					}
+                    if (ret) {
+						store_msg("nand cmd %s failed,ret=%d ",cmd,ret);
+						return -1;
+					}
+					return 0;
+#else
+					return -1;
+#endif
+                }
+                return ret;
+            }
+            break;
+#endif
+        case EMMC_BOOT_FLAG:
+            {
+                store_dbg("MMC BOOT, %s %d \n",__func__,__LINE__);
+                device_boot_flag = EMMC_BOOT_FLAG;
+                run_command("mmc dev 1",0);
+                ret = run_command("mmcinfo", 0);
+                if (ret != 0) {
+                    store_msg("amlmmc cmd %s failed \n",cmd);
+                    return -1;
+                }
+                if (init_flag == STORE_BOOT_ERASE_PROTECT_CACHE) { // OTA upgrade protect cache
+                    ret = run_command("amlmmc erase non_cache", 0);
+                }else if(init_flag >= STORE_BOOT_ERASE_ALL){ // erase all except  reserved area
+                    if (_info_disprotect_back_before_mmcinfo1 & DISPROTECT_KEY) {
+                        MsgP("amlmmc key\n");
+                        run_command("amlmmc key", 0);
+                    }
+                    MsgP("amlmmc erase 1");
+                    ret = run_command("amlmmc erase 1", 0);
+                }
+
+                return ret;
+            }
+            break;
+        case SPI_EMMC_FLAG:
+        case SPI_NAND_FLAG:
+            {
+                /*
+                   if (device_boot_flag == -1)
+                   {
+                   ret = run_command("sf probe 2", 0);
+                   if (ret) {
+                   store_msg(" cmd %s failed \n",cmd);
+                   return -1;
+                   }
+                   if ((init_flag > STORE_BOOT_ERASE_PROTECT_CACHE) && (init_flag <= STORE_BOOT_SCRUB_ALL)) {
+                   sprintf(str, "sf erase 0 0x%x", _SPI_FLASH_ERASE_SZ);
+                   ret = run_command(str,0);
+                   }
+                   sprintf(str, "amlnf  init  %d ",init_flag);
+                   store_dbg("command:	%s", str);
+                   ret = run_command(str, 0);
+                   if (ret < 0) //fail to init NAND flash
+                   {
+                   store_msg("nand cmd %s failed \n",cmd);
+                   device_boot_flag = SPI_EMMC_FLAG;
+                   store_dbg("spi+mmc , %s %d ",__func__,__LINE__);
+                   ret = run_command("mmcinfo 1", 0);
+                   if (ret != 0) {
+                   store_msg("mmc cmd %s failed \n",cmd);
+                   return -2;
+                   }
+                   if (init_flag == STORE_BOOT_ERASE_PROTECT_CACHE) { // OTA upgrade protect cache
+                   store_msg("mmc erase non_cache \n");
+                   ret = run_command("mmc erase non_cache", 0);
+                   }else if(init_flag >= STORE_BOOT_ERASE_ALL){ // erase all except  reserved area
+                   if (_info_disprotect_back_before_mmcinfo1 & DISPROTECT_KEY) {
+                   MsgP("mmc key;\n");
+                   run_command("mmc key", 0);
+                   }
+                   MsgP("mmc erase 1 \n");
+                   ret = run_command("mmc erase 1", 0);
+                   }
+                   return 0;
+                   }
+                   else if((ret == NAND_INIT_FAILED)&&(init_flag == STORE_BOOT_ERASE_ALL)){
+                   sprintf(str, "amlnf  init  %d ",4);
+                   ret = run_command(str, 0);
+                   }
+                   device_boot_flag = SPI_NAND_FLAG;
+                   return 0;
+                   }
+                   */
+                if (device_boot_flag == SPI_NAND_FLAG) {
+                    store_dbg("spi+nand , %s %d ",__func__,__LINE__);
+#if defined(CONFIG_AML_NAND)
+                    if ((init_flag >=STORE_BOOT_ERASE_PROTECT_CACHE) && (init_flag <=STORE_BOOT_SCRUB_ALL)) {
+                        sprintf(str, "amlnf  init  %d ",init_flag);
+                        run_command(str, 0);
+                    }
+                    sprintf(str, "amlnf  init  %d ",1);
+                    store_dbg("command:	%s", str);
+                    ret = run_command(str, 0);
+#else
+                    ret = NAND_INIT_FAILED;
+#endif
+#if	0
+                    if ((ret == NAND_INIT_FAILED) && (init_flag == STORE_BOOT_ERASE_ALL)) {
+                        sprintf(str, "amlnf  init  %d ",4);
+                        ret = run_command(str, 0);
+                    }
+#else
+                    if (ret == NAND_INIT_FAILED) {
+                        return -1;
+                    }
+#endif
+                    if ((init_flag > STORE_BOOT_ERASE_PROTECT_CACHE) && (init_flag <= STORE_BOOT_SCRUB_ALL)) {
+                        ret = run_command("sf probe 2", 0);
+                        sprintf(str, "sf erase  0 0x%x", _SPI_FLASH_ERASE_SZ);
+                        ret = run_command(str,0);
+                    }
+                }
+                if (device_boot_flag == SPI_EMMC_FLAG) {
+                    store_dbg("spi+mmc , %s %d ",__func__,__LINE__);
+                    ret = run_command("mmcinfo 1", 0);
+
+                    if (init_flag == STORE_BOOT_ERASE_PROTECT_CACHE) { // OTA upgrade protect cache
+                        store_msg("amlmmc erase non_cache \n");
+                        ret = run_command("amlmmc erase non_cache", 0);
+                    }else if(init_flag == STORE_BOOT_ERASE_ALL){ // erase all except  reserved area
+                        if (_info_disprotect_back_before_mmcinfo1 & DISPROTECT_KEY) {
+                            run_command("mmc key", 0);
+                        }
+                        MsgP("amlmmc erase 1 \n");
+                        ret = run_command("amlmmc erase 1", 0);
+                    }
+                    if ((init_flag > STORE_BOOT_ERASE_PROTECT_CACHE) && (init_flag <= STORE_BOOT_SCRUB_ALL)) {
+                        ret = run_command("sf probe 2", 0);
+                        sprintf(str, "sf erase  0 0x%x", _SPI_FLASH_ERASE_SZ);
+                        ret = run_command(str,0);
+                    }
+                }
+
+                if (ret != 0) {
+                    store_msg("cmd %s failed \n",cmd);
+                    return -1;
+                }
+
+                return ret;
+            }
+        default:
+            store_dbg("CARD BOOT, %s %d",__func__,__LINE__);
+            return CMD_RET_FAILURE;
+    }
+
+    return 0;
+}
+
+static int do_store_exit(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+#if defined(CONFIG_AML_NAND)
+    if (device_boot_flag == NAND_BOOT_FLAG) {
+        int ret = run_command("amlnf exit", 0);
+        if (ret != 0) {
+            MsgP("amlnf exit failed");
+            return -1;
+        }
+    }
+#endif
+    return 0;
+}
+
+static int do_store_disprotect(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    char *area;
+
+    area = argv[2];
+    if (strcmp(area, "key") == 0) {
+        MsgP("disprotect key\n");
+        info_disprotect |= DISPROTECT_KEY;
+        _info_disprotect_back_before_mmcinfo1 |= DISPROTECT_KEY;
+    }
+    if (strcmp(area, "fbbt") == 0) {
+        store_msg("disprotect fbbt");
+        info_disprotect |= DISPROTECT_FBBT;
+    }
+    if (strcmp(area, "hynix") == 0) {
+        store_msg("disprotect hynix");
+        info_disprotect |= DISPROTECT_HYNIX;
+    }
+
+    return 0;
+}
+
+static int do_store_size(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    uint64_t addr;
+    char *cmd = NULL, *s = NULL;
+    char	str[128];
+
+    if (argc < 4) return CMD_RET_USAGE;
+
+    s = argv[2];
+    addr = (ulong)simple_strtoul(argv[3], NULL, 16);
+    if (device_boot_flag == NAND_BOOT_FLAG) {
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  size  %s %llx",s,addr);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag == SPI_NAND_FLAG){
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  size  %s %llx",s,addr);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag == SPI_EMMC_FLAG){
+        store_dbg("MMC , %s %d ",__func__,__LINE__);
+        sprintf(str, "amlmmc  size  %s %llx",s,addr);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag==EMMC_BOOT_FLAG){
+        store_dbg("MMC , %s %d ",__func__,__LINE__);
+        sprintf(str, "amlmmc  size  %s %llx",s,addr);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag==CARD_BOOT_FLAG){
+        store_dbg("CARD BOOT , %s %d ",__func__,__LINE__);
+        return CMD_RET_FAILURE;
+    }
+
+    return CMD_RET_FAILURE;
+}
+
+static int do_store_erase(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    int i, ret = 0;
+    loff_t size=0;
+    char *cmd = NULL, *area;
+    char	str[128];
+    loff_t off;
+
+    if (argc < 3) return CMD_RET_USAGE;
+
+    off = off;
+    area = argv[2];
+    if (strcmp(area, "boot") == 0) {
+        if (device_boot_flag == NAND_BOOT_FLAG) {
+            #if defined(CONFIG_AML_NAND)
+            off =  simple_strtoul(argv[3], NULL, 16);
+            size =  simple_strtoul(argv[4], NULL, 16);
+            store_dbg("NAND BOOT,erase uboot : %s %d  off =%llx ,size=%llx",__func__,__LINE__, off, size);
+
+            ret = run_command("amlnf deverase boot 0",0);
+            #else
+            ret = -1;
+            #endif
+            if (ret != 0) {
+                store_msg("nand cmd %s failed ",cmd);
+                return -1;
+            }
+            return ret;
+        }else if((device_boot_flag==SPI_EMMC_FLAG)||(device_boot_flag==SPI_NAND_FLAG)){
+            off =  simple_strtoul(argv[3], NULL, 16);
+            size =  simple_strtoul(argv[4], NULL, 16);
+
+            store_dbg("SPI BOOT,erase uboot :  %s %d  off =%llx ,size=%llx",__func__,__LINE__,off,size);
+
+            ret = run_command("sf probe 2",0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed",cmd);
+                return -1;
+            }
+            sprintf(str, "sf erase  0 0x%x", CONFIG_ENV_IN_SPI_OFFSET);//store erase boot shoould NOT erase ENV in flash!
+            ret = run_command(str,0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed",cmd);
+                return -1;
+            }
+            return ret;
+        }else if(device_boot_flag == EMMC_BOOT_FLAG){
+            off =  simple_strtoul(argv[3], NULL, 16);
+            size =  simple_strtoul(argv[4], NULL, 16);
+
+            store_dbg("MMC BOOT,erase uboot :  %s %d  off =%llx ,size=%llx",__func__,__LINE__,off,size);
+
+            sprintf(str, "amlmmc  erase bootloader");
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("amlmmc cmd %s failed",cmd);
+                return -1;
+            }
+
+#ifdef MMC_BOOT_PARTITION_SUPPORT
+
+            for (i=0; i<2; i++) {
+                //switch to boot partition here
+                sprintf(str, "amlmmc switch 1 boot%d", i);
+                store_dbg("command: %s\n", str);
+                ret = run_command(str, 0);
+                if (ret == -1) {
+                    //store_msg("mmc cmd %s failed \n",cmd);
+                    return 0;
+                }
+                else if(ret != 0){
+                    store_msg("amlmmc cmd %s failed",cmd);
+                    //return -1;
+                    goto E_SWITCH_BACK;
+                }
+
+                //erase boot partition
+                sprintf(str, "amlmmc erase bootloader");
+                ret = run_command(str, 0);
+                if (ret != 0) {
+                    store_msg("amlmmc cmd %s failed",cmd);
+                    //return -1;
+                    goto E_SWITCH_BACK;
+                }
+            }
+
+E_SWITCH_BACK:
+            //switch back to urs partition
+            sprintf(str, "amlmmc switch 1 user");
+            store_dbg("command: %s\n", str);
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("amlmmc cmd %s failed \n",cmd);
+                return -1;
+            }
+
+#endif
+
+            return ret;
+        }else{
+            store_dbg("CARD BOOT,erase uboot :  %s %d  off =%llx ,size=%llx",__func__,__LINE__,off,size);
+            return 0;
+        }
+    }
+    else if (strcmp(area, "data") == 0){
+
+        if (device_boot_flag == NAND_BOOT_FLAG) {
+            store_dbg("NAND BOOT,erase data : %s %d  off =%llx ,size=%llx",__func__,__LINE__, off, size);
+
+            #if defined(CONFIG_AML_NAND)
+            ret = run_command("amlnf  deverase data 0",0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed ",cmd);
+                return -1;
+            }
+            ret = run_command("amlnf  deverase code 0",0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed ",cmd);
+                return -1;
+            }
+            ret = run_command("amlnf  deverase cache 0",0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed ",cmd);
+                return -1;
+            }
+            #endif
+            return ret;
+        }
+        else if(device_boot_flag == SPI_NAND_FLAG){
+            store_dbg("spi+nand , %s %d ",__func__,__LINE__);
+            #if defined(CONFIG_AML_NAND)
+            ret = run_command("amlnf  deverase data 0",0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed ",cmd);
+                return -1;
+            }
+
+            ret = run_command("amlnf  deverase code 0",0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed ",cmd);
+                return -1;
+            }
+            ret = run_command("amlnf  deverase cache 0",0);
+            if (ret != 0) {
+                store_msg("nand cmd %s failed ",cmd);
+                return -1;
+            }
+            #endif
+            return ret;
+        }
+        else if(device_boot_flag == SPI_EMMC_FLAG){
+            store_dbg("spi+mmc , %s %d ",__func__,__LINE__);
+            off = size =0;
+            ret = run_command("mmc  erase  1",0); // whole
+            if (ret != 0) {
+                store_msg("mmc cmd %s failed ",cmd);
+                return -1;
+            }
+
+            return ret;
+        }
+        else if(device_boot_flag==EMMC_BOOT_FLAG){
+            store_dbg("MMC BOOT,erase data : %s %d  off =%llx ,size=%llx",__func__,__LINE__, off, size);
+            off = size =0;
+            ret = run_command("amlmmc erase 1",0); //whole
+            if (ret != 0) {
+                store_msg("amlmmc cmd %s failed ",cmd);
+                return -1;
+            }
+            return ret;
+        }else{
+            store_dbg("CARD BOOT,erase data : %s %d  off =%llx ,size=%llx",__func__,__LINE__, off, size);
+            return 0;
+        }
+    }
+    else if (strcmp(area, "key") == 0){
+        if (device_boot_flag == EMMC_BOOT_FLAG) {
+            sprintf(str, "emmc erase key");
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("emmc cmd %s failed",cmd);
+                return CMD_RET_USAGE;
+            }
+        } else if (device_boot_flag == NAND_BOOT_FLAG) {
+        #if defined(CONFIG_AML_NAND)
+            sprintf(str, "amlnf key_erase");
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("emmc cmd %s failed",cmd);
+                return CMD_RET_USAGE;
+            }
+        #endif
+        }
+    }
+    else if (strcmp(area, "dtb") == 0) {
+        if (device_boot_flag == EMMC_BOOT_FLAG) {
+            sprintf(str, "emmc erase dtb");
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("emmc cmd %s failed",cmd);
+                return CMD_RET_USAGE;
+            }
+        } else if (device_boot_flag == NAND_BOOT_FLAG) {
+        #if defined(CONFIG_AML_NAND)
+            sprintf(str, "amlnf dtb_erase");
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("emmc cmd %s failed",cmd);
+                return CMD_RET_USAGE;
+            }
+        #endif
+        }
+    }
+    return 0;
+}
+
+static int do_store_scrub(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    loff_t off=0;
+    char *cmd = NULL;
+    char	str[128];
+
+    off = (ulong)simple_strtoul(argv[2], NULL, 16);
+    sprintf(str, "amlnf  scrub %d", (int)off);
+    if (device_boot_flag == NAND_BOOT_FLAG) {
+        #if defined(CONFIG_AML_NAND)
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+    }
+    else if(device_boot_flag == SPI_NAND_FLAG){
+        store_dbg("spi+nand , %s %d ",__func__,__LINE__);
+        #if defined(CONFIG_AML_NAND)
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        #endif
+
+        ret = run_command("sf probe 2", 0);
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        sprintf(str, "sf erase  0 0x%x", _SPI_FLASH_ERASE_SZ);
+        ret = run_command(str,0);
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag == SPI_EMMC_FLAG){
+        store_dbg("spi+mmc , %s %d ",__func__,__LINE__);
+        ret = run_command("amlmmc erase whole",0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag==EMMC_BOOT_FLAG){
+        store_dbg("MMC BOOT, %s %d \n",__func__,__LINE__);
+        device_boot_flag = EMMC_BOOT_FLAG;
+        run_command("mmc dev 1", 0);
+        ret = run_command("mmcinfo", 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+        if (_info_disprotect_back_before_mmcinfo1 & DISPROTECT_KEY) {
+            MsgP("mmc key\n");
+            run_command("mmc key", 0);
+        }
+        MsgP("amlmmc erase 1");
+        ret = run_command("amlmmc erase 1", 0);
+    }
+
+    return ret;
+}
+
+static int do_store_rom_protect(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+
+#if defined(CONFIG_AML_NAND)
+    char *cmd = NULL;
+    char	str[128];
+    char *area = argv[2];
+#endif
+
+    if (argc < 3)return CMD_RET_USAGE;
+
+    if (device_boot_flag == NAND_BOOT_FLAG) {
+#if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  rom_protect  %s", area);
+        store_dbg("command:	%s", str);
+        int ret = run_command(str, 0);
+		if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+#else
+        return -1;
+#endif
+    }
+
+    return CMD_RET_SUCCESS;
+}
+
+static int do_store_rom_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    uint64_t addr;
+    loff_t off=0, size=0;
+    char *cmd = NULL;
+    char	str[128];
+    int ret = 0;
+    int i = 0;
+
+    if (argc < 5) return CMD_RET_USAGE;
+
+    addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+    if (get_off_size(argc - 3, (char **)(argv + 3), &off, &size) != 0) return CMD_RET_FAILURE;
+
+    if (device_boot_flag == NAND_BOOT_FLAG) {
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  rom_write  0x%llx  0x%llx  0x%llx",  addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if ((device_boot_flag==SPI_EMMC_FLAG)||(device_boot_flag==SPI_NAND_FLAG)){
+        ret = run_command("sf  probe 2",0);
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        sprintf(str, "sf  erase  0x%llx  0x%llx ", off, size);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        sprintf(str, "sf  write 0x%llx  0x%llx  0x%llx ",addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag==EMMC_BOOT_FLAG){
+        store_dbg("MMC BOOT, %s %d \n",__func__,__LINE__);
+
+#ifndef CONFIG_AML_SECU_BOOT_V2
+#ifdef MMC_UBOOT_CLEAR_MBR
+        //modify the 55 AA info for emmc uboot
+        unsigned char *tmp_buf= (unsigned char *)addr;
+        _mbrFlag[0] = tmp_buf[510];
+        _mbrFlag[1] = tmp_buf[511];
+        tmp_buf[510]=0;
+        tmp_buf[511]=0;
+#endif
+#endif// #if defined(CONFIG_AML_SECU_BOOT_V2)
+        sprintf(str, "amlmmc  write bootloader 0x%llx  0x%llx  0x%llx", addr, off, size);
+        store_dbg("command: %s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+#ifdef MMC_BOOT_PARTITION_SUPPORT
+
+        for (i=0; i<2; i++) {
+            //switch to boot partition here
+            sprintf(str, "amlmmc switch 1 boot%d", i);
+            store_dbg("command: %s\n", str);
+            ret = run_command(str, 0);
+            if (ret == -1) {
+                //store_msg("mmc cmd %s failed \n",cmd);
+                ret = 0;
+                return ret;
+            }
+            else if(ret != 0){
+                store_msg("amlmmc cmd %s failed",cmd);
+                //return -1;
+                goto W_SWITCH_BACK;
+            }
+
+            //write uboot to boot partition
+            sprintf(str, "amlmmc  write bootloader 0x%llx  0x%llx  0x%llx", addr, off, size);
+            store_dbg("command: %s\n", str);
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("amlmmc cmd %s failed \n",cmd);
+                //return -1;
+                goto W_SWITCH_BACK;
+            }
+        }
+
+W_SWITCH_BACK:
+        //switch back to urs partition
+        sprintf(str, "amlmmc switch 1 user");
+        store_dbg("command: %s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+
+#endif
+        return ret;
+    }else{
+        store_dbg("CARD BOOT, %s %d",__func__,__LINE__);
+        return 0;
+    }
+
+}
+
+static int do_store_rom_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    uint64_t addr;
+    loff_t off=0, size=0;
+    char *cmd = NULL;
+    char	str[128];
+    int ret = 0;
+    int i = 0;
+
+    if (argc < 5) return CMD_RET_USAGE;
+
+    addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+    if (get_off_size(argc - 3, (char **)(argv + 3), &off, &size) != 0) return CMD_RET_FAILURE;
+
+    if (device_boot_flag == NAND_BOOT_FLAG) {
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  rom_read  0x%llx  0x%llx  0x%llx",  addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }else if ((device_boot_flag==SPI_EMMC_FLAG)||(device_boot_flag==SPI_NAND_FLAG)){
+        ret = run_command("sf  probe 2",0);
+        if (ret != 0) {
+            return -1;
+        }
+        sprintf(str, "sf  read 0x%llx  0x%llx  0x%llx ",addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("nand cmd %s failed",cmd);
+            return -1;
+        }
+        return ret;
+    }else if (device_boot_flag==EMMC_BOOT_FLAG){
+        store_dbg("MMC BOOT, %s %d \n",__func__,__LINE__);
+        sprintf(str, "amlmmc  read bootloader 0x%llx  0x%llx  0x%llx", addr, off, size);
+        store_dbg("command: %s\n", str);
+        //tmp_buf= (unsigned char *)addr;
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+
+#ifdef MMC_BOOT_PARTITION_SUPPORT
+
+        for (i=0; i<2; i++) {
+            //switch to boot partition here
+            sprintf(str, "amlmmc switch 1 boot%d", i);
+            store_dbg("command: %s\n", str);
+            ret = run_command(str, 0);
+            if (ret == -1) {
+                //store_msg("mmc cmd %s failed \n",cmd);
+                return 0;
+            }
+            else if(ret != 0){
+                store_msg("amlmmc cmd %s failed",cmd);
+                goto R_SWITCH_BACK;
+                //return -1;
+            }
+
+            //write uboot to boot partition
+            sprintf(str, "amlmmc  read bootloader 0x%llx  0x%llx  0x%llx", addr, off, size);
+            store_dbg("command: %s\n", str);
+            ret = run_command(str, 0);
+            if (ret != 0) {
+                store_msg("amlmmc cmd %s failed \n",cmd);
+                //return -1;
+                goto R_SWITCH_BACK;
+            }
+        }
+
+R_SWITCH_BACK:
+        //switch back to urs partition
+        sprintf(str, "amlmmc switch 1 user");
+        store_dbg("command: %s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+
+#endif
+#ifndef CONFIG_AML_SECU_BOOT_V2
+#ifdef MMC_UBOOT_CLEAR_MBR
+        unsigned char *tmp_buf= (unsigned char *)addr;
+        tmp_buf[510]= _mbrFlag[0];
+        tmp_buf[511]= _mbrFlag[1];
+#endif
+#endif// #ifndef CONFIG_AML_SECU_BOOT_V2
+        return ret;
+    }else{
+        store_dbg("CARD BOOT, %s %d ",__func__,__LINE__);
+        return 0;
+    }
+
+}
+
+static int do_store_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    uint64_t addr;
+    loff_t off=0, size=0;
+    char *cmd = NULL;
+    char	str[128];
+    int ret = 0;
+    char * s = argv[2];
+
+    if (argc < 6) return CMD_RET_USAGE;
+
+    addr = (ulong)simple_strtoul(argv[3], NULL, 16);
+
+    if (get_off_size(argc - 4, (char **)(argv + 4), &off, &size) != 0) return CMD_RET_FAILURE;
+
+    store_dbg("addr = %llx off= 0x%llx  size=0x%llx",addr,off,size);
+    if ((device_boot_flag == NAND_BOOT_FLAG)) {
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  read_byte %s 0x%llx  0x%llx  0x%llx",s, addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed ",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag == SPI_NAND_FLAG){
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  read_byte %s 0x%llx  0x%llx  0x%llx", s, addr, off, size);
+        store_dbg("command:	%s\n", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed \n",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag == SPI_EMMC_FLAG){
+        store_dbg("spi+mmc , %s %d ",__func__,__LINE__);
+        sprintf(str, "amlmmc  read %s 0x%llx  0x%llx  0x%llx", s, addr, off, size);
+        store_dbg("command:	%s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag==EMMC_BOOT_FLAG) {
+        store_dbg("MMC BOOT, %s %d \n",__func__,__LINE__);
+        sprintf(str, "amlmmc  read %s 0x%llx  0x%llx  0x%llx", s, addr, off, size);
+        store_dbg("command:	%s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+        return ret;
+    }else{
+        store_dbg("CARD BOOT, %s %d ",__func__,__LINE__);
+
+        return 0;
+    }
+}
+
+static int do_store_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    uint64_t addr;
+    loff_t off=0, size=0;
+    char *cmd = NULL;
+    char	str[128];
+    int ret = 0;
+    char * s = argv[2];
+
+    if (argc < 6) return CMD_RET_USAGE;
+
+    addr = (ulong)simple_strtoul(argv[3], NULL, 16);
+    if (get_off_size(argc - 4, (char **)(argv + 4), &off, &size) != 0) return CMD_RET_FAILURE;
+
+    if (device_boot_flag == NAND_BOOT_FLAG) {
+
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  write_byte %s 0x%llx  0x%llx  0x%llx", s, addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed ",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag == SPI_NAND_FLAG){
+        store_dbg("spi+nand , %s %d ",__func__,__LINE__);
+        #if defined(CONFIG_AML_NAND)
+        sprintf(str, "amlnf  write_byte %s 0x%llx  0x%llx  0x%llx", s, addr, off, size);
+        store_dbg("command:	%s", str);
+        ret = run_command(str, 0);
+        #else
+        ret = -1;
+        #endif
+        if (ret != 0) {
+            store_msg("nand cmd %s failed \n",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag == SPI_EMMC_FLAG){
+        store_dbg("spi+mmc , %s %d ",__func__,__LINE__);
+        sprintf(str, "amlmmc  write %s 0x%llx  0x%llx  0x%llx", s, addr, off, size);
+        store_dbg("command: %s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+        return ret;
+    }
+    else if(device_boot_flag==EMMC_BOOT_FLAG){
+        store_dbg("MMC BOOT, %s %d \n",__func__,__LINE__);
+        sprintf(str, "amlmmc  write %s 0x%llx  0x%llx  0x%llx", s, addr, off, size);
+        store_dbg("command: %s\n", str);
+        ret = run_command(str, 0);
+        if (ret != 0) {
+            store_msg("amlmmc cmd %s failed \n",cmd);
+            return -1;
+        }
+        return ret;
+    }else{
+        store_dbg("CARD BOOT, %s %d ",__func__,__LINE__);
+        return CMD_RET_FAILURE;
+    }
+    return ret;
+}
+
+static cmd_tbl_t cmd_store_sub[] = {
+    U_BOOT_CMD_MKENT(init,          4, 0, do_store_init, "", ""),
+    U_BOOT_CMD_MKENT(exit,          3, 0, do_store_exit, "", ""),
+    U_BOOT_CMD_MKENT(disprotect,    3, 0, do_store_disprotect, "", ""),
+    U_BOOT_CMD_MKENT(rom_protect,   5, 0, do_store_rom_protect, "", ""),
+    U_BOOT_CMD_MKENT(size,          5, 0, do_store_size, "", ""),
+    U_BOOT_CMD_MKENT(scrub,         3, 0, do_store_scrub, "", ""),
+    U_BOOT_CMD_MKENT(erase,         5, 0, do_store_erase, "", ""),
+    U_BOOT_CMD_MKENT(read,          6, 0, do_store_read, "", ""),
+    U_BOOT_CMD_MKENT(write,         6, 0, do_store_write, "", ""),
+    U_BOOT_CMD_MKENT(rom_read,      5, 0, do_store_rom_read, "", ""),
+    U_BOOT_CMD_MKENT(rom_write,     5, 0, do_store_rom_write, "", ""),
+    U_BOOT_CMD_MKENT(dtb,           5, 0, do_store_dtb_ops, "", ""),
+    U_BOOT_CMD_MKENT(key,           5, 0, do_store_key_ops, "", ""),
+};
+
+static int do_store(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    cmd_tbl_t *c;
+
+    if (argc < 2) return CMD_RET_USAGE;
+
+    c = find_cmd_tbl(argv[1], cmd_store_sub, ARRAY_SIZE(cmd_store_sub));
+
+	if (c) {
+        return	c->cmd(cmdtp, flag, argc, argv);
+    }
+
+    return CMD_RET_USAGE;
+}
+
+
+U_BOOT_CMD(store, CONFIG_SYS_MAXARGS, 1, do_store,
+	"STORE sub-system",
+	"store init flag\n"
+	"store read name addr off|partition size\n"
+	"    read 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"store write name addr off|partition size\n"
+	"    write 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"store rom_write add off size.\n"
+	"	write uboot to the boot device\n"
+	"store erase boot/data: \n"
+	"	erase the area which is uboot or data \n"
+	"store erase dtb \n"
+	"store erase key \n"
+	"store scrub off|partition size\n"
+	"	scrub the area from offset and size \n"
+	"store dtb iread/read/write <size>\n"
+	"	read/write dtb, size is optional \n"
+	"store key read/write <size>\n"
+	"	read/write key, size is optional \n"
+);
+
diff --git a/common/usb.c b/common/usb.c
index 736cd9f..c816f71 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -35,6 +35,7 @@
 #include <asm/unaligned.h>
 #include <errno.h>
 #include <usb.h>
+#include <asm/arch/usb.h>
 #ifdef CONFIG_4xx
 #include <asm/4xx_pci.h>
 #endif
@@ -51,6 +52,27 @@ char usb_started; /* flag for the started/stopped USB status */
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 1
 #endif
 
+extern int usb_lowlevel_init(int index,enum usb_init_type init, void **controller);
+extern int usb_lowlevel_stop(int index);
+extern int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer, int len, int interval);
+extern int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+                   int len, struct devrequest *setup);
+extern int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buf, int len);
+
+/***********************************************************************
+ * wait_ms
+
+void wait_ms(unsigned long ms)
+{
+	while (ms-- > 0)
+		_udelay(1000);
+}*/
+void _mdelay(unsigned long ms)
+{
+	while (ms-- > 0)
+		_udelay(1000);
+}
+
 /***************************************************************************
  * Init USB Device
  */
@@ -60,7 +82,7 @@ int usb_init(void)
 	struct usb_device *dev;
 	int i, start_index = 0;
 	int ret;
-
+	int usb_count = get_usb_count();
 	dev_index = 0;
 	asynch_allowed = 1;
 	usb_hub_reset();
@@ -72,7 +94,7 @@ int usb_init(void)
 	}
 
 	/* init low_level USB */
-	for (i = 0; i < CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
+	for (i = 0; i < usb_count; i++) {
 		/* init low_level USB */
 		printf("USB%d:   ", i);
 		ret = usb_lowlevel_init(i, USB_INIT_HOST, &ctrl);
@@ -101,11 +123,13 @@ int usb_init(void)
 
 		if (start_index == dev_index)
 			puts("No USB Device found\n");
-		else
+		else {
 			printf("%d USB Device(s) found\n",
 				dev_index - start_index);
 
-		usb_started = 1;
+			usb_started = 1;
+			break;
+		}
 	}
 
 	debug("scan end\n");
@@ -212,7 +236,7 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 	while (timeout--) {
 		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
 			break;
-		mdelay(1);
+		_mdelay(1);
 	}
 	if (dev->status)
 		return -1;
@@ -237,7 +261,7 @@ int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
 	while (timeout--) {
 		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
 			break;
-		mdelay(1);
+		_mdelay(1);
 	}
 	*actual_length = dev->act_len;
 	if (dev->status == 0)
@@ -998,7 +1022,7 @@ int usb_new_device(struct usb_device *dev)
 		return 1;
 	}
 
-	mdelay(10);	/* Let the SET_ADDRESS settle */
+	_mdelay(10);	/* Let the SET_ADDRESS settle */
 
 	tmp = sizeof(dev->descriptor);
 
@@ -1058,9 +1082,4 @@ int usb_new_device(struct usb_device *dev)
 	return 0;
 }
 
-__weak
-int board_usb_init(int index, enum usb_init_type init)
-{
-	return 0;
-}
 /* EOF */
diff --git a/common/usb_hub.c b/common/usb_hub.c
index 66b4a72..f6cb8f9 100644
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -39,7 +39,7 @@
 
 static struct usb_hub_device hub_dev[USB_MAX_HUB];
 static int usb_hub_index;
-
+extern void _mdelay(unsigned long ms);
 __weak void usb_hub_reset_devices(int port)
 {
 	return;
@@ -99,7 +99,7 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 	 * Wait for power to become stable,
 	 * plus spec-defined max time for device to connect
 	 */
-	mdelay(pgood_delay + 1000);
+	_mdelay(pgood_delay + 1000);
 }
 
 void usb_hub_reset(void)
@@ -151,7 +151,7 @@ int hub_port_reset(struct usb_device *dev, int port,
 	for (tries = 0; tries < MAX_TRIES; tries++) {
 
 		usb_set_port_feature(dev, port + 1, USB_PORT_FEAT_RESET);
-		mdelay(200);
+		_mdelay(200);
 
 		if (usb_get_port_status(dev, port + 1, portsts) < 0) {
 			debug("get_port_status failed status %lX\n",
@@ -190,7 +190,7 @@ int hub_port_reset(struct usb_device *dev, int port,
 		if (portstatus & USB_PORT_STAT_ENABLE)
 			break;
 
-		mdelay(200);
+		_mdelay(200);
 	}
 
 	if (tries == MAX_TRIES) {
@@ -235,7 +235,7 @@ void usb_hub_port_connect_change(struct usb_device *dev, int port)
 		if (!(portstatus & USB_PORT_STAT_CONNECTION))
 			return;
 	}
-	mdelay(200);
+	_mdelay(200);
 
 	/* Reset the port */
 	if (hub_port_reset(dev, port, &portstatus) < 0) {
@@ -243,7 +243,7 @@ void usb_hub_port_connect_change(struct usb_device *dev, int port)
 		return;
 	}
 
-	mdelay(200);
+	_mdelay(200);
 
 	/* Allocate a new device struct for it */
 	usb = usb_alloc_new_device(dev->controller);
@@ -262,7 +262,8 @@ void usb_hub_port_connect_change(struct usb_device *dev, int port)
 		usb->speed = USB_SPEED_FULL;
 		break;
 	}
-
+	if ((usb->speed != USB_SPEED_HIGH) && (usb->speed != USB_SPEED_SUPER))
+		return;
 	dev->children[port] = usb;
 	usb->parent = dev;
 	usb->portnr = port + 1;
@@ -410,7 +411,7 @@ static int usb_hub_configure(struct usb_device *dev)
 		ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
 		unsigned short portstatus, portchange;
 		int ret;
-		ulong start = get_timer(0);
+		ulong start = get_time();
 
 		/*
 		 * Wait for (whichever finishes first)
@@ -434,7 +435,7 @@ static int usb_hub_configure(struct usb_device *dev)
 				(portstatus & USB_PORT_STAT_CONNECTION))
 				break;
 
-		} while (get_timer(start) < CONFIG_SYS_HZ * 10);
+		} while (get_time()-start < CONFIG_SYS_HZ * 10);
 
 		if (ret < 0)
 			continue;
diff --git a/common/usb_kbd.c b/common/usb_kbd.c
index bc7145e..4bd85d1 100644
--- a/common/usb_kbd.c
+++ b/common/usb_kbd.c
@@ -350,9 +350,9 @@ static int usb_kbd_testc(struct stdio_dev *sdev)
 	 * then we check key-pressed every second (first check may be
 	 * less than 1 second) to improve TFTP booting performance.
 	 */
-	if (net_busy_flag && (get_timer(kbd_testc_tms) < CONFIG_SYS_HZ))
+	if (net_busy_flag && ((get_time()-kbd_testc_tms) < CONFIG_SYS_HZ))
 		return 0;
-	kbd_testc_tms = get_timer(0);
+	kbd_testc_tms = get_time();
 #endif
 	dev = stdio_get_by_name(DEVNAME);
 	usb_kbd_dev = (struct usb_device *)dev->priv;
diff --git a/common/usb_storage.c b/common/usb_storage.c
index 1411737..4cb2acf 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -122,7 +122,7 @@ struct us_data {
 	unsigned char	attention_done;		/* force attn on first cmd */
 	unsigned short	ip_data;		/* interrupt data */
 	int		action;			/* what to do */
-	int		ip_wanted;		/* needed */
+	uint32_t ip_wanted;		/* needed */
 	int		*irq_handle;		/* for USB int requests */
 	unsigned int	irqpipe;	 	/* pipe for release_irq */
 	unsigned char	irqmaxp;		/* max packed for irq Pipe */
@@ -150,6 +150,9 @@ static struct us_data usb_stor[USB_MAX_STOR_DEV];
 #define USB_STOR_TRANSPORT_FAILED -1
 #define USB_STOR_TRANSPORT_ERROR  -2
 
+extern int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer, int len, int interval);
+extern void _mdelay(unsigned long ms);
+
 int usb_stor_get_info(struct usb_device *dev, struct us_data *us,
 		      block_dev_desc_t *dev_desc);
 int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
@@ -336,8 +339,8 @@ static int us_one_transfer(struct us_data *us, int pipe, char *buf, int length)
 		/* set up the transfer loop */
 		do {
 			/* transfer the data */
-			debug("Bulk xfer 0x%x(%d) try #%d\n",
-			      (unsigned int)buf, this_xfer, 11 - maxtry);
+			debug("Bulk xfer 0x%llx(%d) try #%d\n",
+			      (uint64_t)buf, this_xfer, 11 - maxtry);
 			result = usb_bulk_msg(us->pusb_dev, pipe, buf,
 					      this_xfer, &partial,
 					      USB_CNTL_TIMEOUT * 5);
@@ -424,19 +427,19 @@ static int usb_stor_BBB_reset(struct us_data *us)
 	}
 
 	/* long wait for reset */
-	mdelay(150);
+	_mdelay(150);
 	debug("BBB_reset result %d: status %lX reset\n",
 	      result, us->pusb_dev->status);
 	pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
 	result = usb_clear_halt(us->pusb_dev, pipe);
 	/* long wait for reset */
-	mdelay(150);
+	_mdelay(150);
 	debug("BBB_reset result %d: status %lX clearing IN endpoint\n",
 	      result, us->pusb_dev->status);
 	/* long wait for reset */
 	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
 	result = usb_clear_halt(us->pusb_dev, pipe);
-	mdelay(150);
+	_mdelay(150);
 	debug("BBB_reset result %d: status %lX clearing OUT endpoint\n",
 	      result, us->pusb_dev->status);
 	debug("BBB_reset done\n");
@@ -463,7 +466,7 @@ static int usb_stor_CB_reset(struct us_data *us)
 				 USB_CNTL_TIMEOUT * 5);
 
 	/* long wait for reset */
-	mdelay(1500);
+	_mdelay(1500);
 	debug("CB_reset result %d: status %lX clearing endpoint halt\n",
 	      result, us->pusb_dev->status);
 	usb_clear_halt(us->pusb_dev, usb_rcvbulkpipe(us->pusb_dev, us->ep_in));
@@ -603,9 +606,9 @@ static int usb_stor_CBI_get_status(ccb *srb, struct us_data *us)
 			(void *) &us->ip_data, us->irqmaxp, us->irqinterval);
 	timeout = 1000;
 	while (timeout--) {
-		if ((volatile int *) us->ip_wanted == NULL)
+		if ((volatile int *)(unsigned long long)us->ip_wanted == NULL)
 			break;
-		mdelay(10);
+		_mdelay(10);
 	}
 	if (us->ip_wanted) {
 		printf("	Did not get interrupt on CBI\n");
@@ -676,7 +679,7 @@ static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
 		return USB_STOR_TRANSPORT_FAILED;
 	}
 	if (!(us->flags & USB_READY))
-		mdelay(5);
+		_mdelay(5);
 	pipein = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
 	pipeout = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
 	/* DATA phase + error handling */
@@ -868,7 +871,7 @@ do_retry:
 				srb->sense_buf[12], srb->sense_buf[13]);
 			return USB_STOR_TRANSPORT_FAILED;
 		} else {
-			mdelay(100);
+			_mdelay(100);
 			goto do_retry;
 		}
 		break;
@@ -914,7 +917,6 @@ static int usb_inquiry(ccb *srb, struct us_data *ss)
 static int usb_request_sense(ccb *srb, struct us_data *ss)
 {
 	char *ptr;
-
 	ptr = (char *)srb->pdata;
 	memset(&srb->cmd[0], 0, 12);
 	srb->cmd[0] = SCSI_REQ_SENSE;
@@ -934,7 +936,6 @@ static int usb_request_sense(ccb *srb, struct us_data *ss)
 static int usb_test_unit_ready(ccb *srb, struct us_data *ss)
 {
 	int retries = 10;
-
 	do {
 		memset(&srb->cmd[0], 0, 12);
 		srb->cmd[0] = SCSI_TST_U_RDY;
@@ -956,7 +957,7 @@ static int usb_test_unit_ready(ccb *srb, struct us_data *ss)
 		if ((srb->sense_buf[2] == 0x02) &&
 		    (srb->sense_buf[12] == 0x3a))
 			return -1;
-		mdelay(100);
+		_mdelay(100);
 	} while (retries--);
 
 	return -1;
@@ -1334,9 +1335,9 @@ int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
 		      block_dev_desc_t *dev_desc)
 {
 	unsigned char perq, modi;
-	ALLOC_CACHE_ALIGN_BUFFER(unsigned long, cap, 2);
+	ALLOC_CACHE_ALIGN_BUFFER(unsigned int, cap, 2);
 	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, usb_stor_buf, 36);
-	unsigned long *capacity, *blksz;
+	unsigned int *capacity, *blksz;
 	ccb *pccb = &usb_ccb;
 
 	pccb->pdata = usb_stor_buf;
@@ -1393,7 +1394,7 @@ int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
 		cap[1] = 0x200;
 	}
 	ss->flags &= ~USB_READY;
-	debug("Read Capacity returns: 0x%lx, 0x%lx\n", cap[0], cap[1]);
+	debug("Read Capacity returns: 0x%x, 0x%x\n", cap[0], cap[1]);
 #if 0
 	if (cap[0] > (0x200000 * 10)) /* greater than 10 GByte */
 		cap[0] >>= 16;
@@ -1405,7 +1406,7 @@ int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
 	cap[0] += 1;
 	capacity = &cap[0];
 	blksz = &cap[1];
-	debug("Capacity = 0x%lx, blocksz = 0x%lx\n", *capacity, *blksz);
+	debug("Capacity = 0x%x, blocksz = 0x%x\n", *capacity, *blksz);
 	dev_desc->lba = *capacity;
 	dev_desc->blksz = *blksz;
 	dev_desc->log2blksz = LOG2(dev_desc->blksz);
diff --git a/config.mk b/config.mk
index 64c2951..9ab5ec6 100644
--- a/config.mk
+++ b/config.mk
@@ -76,6 +76,17 @@ PLATFORM_CPPFLAGS += -pipe
 LDFLAGS += $(PLATFORM_LDFLAGS)
 LDFLAGS_FINAL += -Bstatic
 
+FIRMWARE_CPPFLAGS += -I$(buildsrc)/include
+FIRMWARE_CPPFLAGS += -I$(buildsrc)/arch/$(ARCH)/include
+FIRMWARE_CPPFLAGS += -I$(buildtree)/include2 -I$(buildtree)/include
+FIRMWARE_CPPFLAGS += -include $(buildtree)/include/config.h
+FIRMWARE_CPPFLAGS += -include $(buildtree)/include/generated/autoconf.h
+FIRMWARE_CPPFLAGS += -include $(buildtree)/include/generated/version_autogenerated.h
+FIRMWARE_CPPFLAGS += -fno-builtin -ffreestanding -nostdinc	\
+	-isystem $(gccincdir) -pipe $(PLATFORM_CPPFLAGS)
+FIRMWARE_CPPFLAGS += -I$(buildsrc)/board/$(BOARDDIR)/firmware
+
+export FIRMWARE_CPPFLAGS
 export PLATFORM_CPPFLAGS
 export RELFLAGS
 export LDFLAGS_FINAL
diff --git a/configs/gxb_p200_v1_defconfig b/configs/gxb_p200_v1_defconfig
new file mode 100644
index 0000000..e614a34
--- /dev/null
+++ b/configs/gxb_p200_v1_defconfig
@@ -0,0 +1,6 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GX=y
+CONFIG_GXB_P200_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
diff --git a/configs/gxb_p201_v1_defconfig b/configs/gxb_p201_v1_defconfig
new file mode 100644
index 0000000..f5f4aec
--- /dev/null
+++ b/configs/gxb_p201_v1_defconfig
@@ -0,0 +1,6 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GX=y
+CONFIG_GXB_P201_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
diff --git a/configs/gxb_pxp_defconfig b/configs/gxb_pxp_defconfig
new file mode 100644
index 0000000..db96c0f
--- /dev/null
+++ b/configs/gxb_pxp_defconfig
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GX=y
+CONFIG_GXB_SKT_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
+CONFIG_PXP_EMULATOR=y
diff --git a/configs/gxb_skt_v1_defconfig b/configs/gxb_skt_v1_defconfig
new file mode 100644
index 0000000..1e15c03
--- /dev/null
+++ b/configs/gxb_skt_v1_defconfig
@@ -0,0 +1,6 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GX=y
+CONFIG_GXB_SKT_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
diff --git a/configs/odroidc2_defconfig b/configs/odroidc2_defconfig
new file mode 100644
index 0000000..4d64cb3
--- /dev/null
+++ b/configs/odroidc2_defconfig
@@ -0,0 +1,6 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GX=y
+CONFIG_ODROID_C2=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
diff --git a/disk/Makefile b/disk/Makefile
index 6970cec..4b7a9ef 100644
--- a/disk/Makefile
+++ b/disk/Makefile
@@ -13,3 +13,4 @@ obj-$(CONFIG_DOS_PARTITION)   += part_dos.o
 obj-$(CONFIG_ISO_PARTITION)   += part_iso.o
 obj-$(CONFIG_AMIGA_PARTITION) += part_amiga.o
 obj-$(CONFIG_EFI_PARTITION)   += part_efi.o
+obj-$(CONFIG_CMD_FASTBOOT)    += part_fastboot.o
diff --git a/disk/part_fastboot.c b/disk/part_fastboot.c
new file mode 100644
index 0000000..d2a50e4
--- /dev/null
+++ b/disk/part_fastboot.c
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <usb/fastboot.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <environment.h>
+#include <mmc.h>
+#include <dfu.h>
+#include <part_dos.h>
+
+#define NR_PARTITIONS		4
+
+static struct mmc *mmc = NULL;
+
+static block_dev_desc_t *fastboot_block_dev(void)
+{
+#if defined(CONFIG_FASTBOOT_FLASH_MMC_DEV)
+	if (mmc == NULL)
+		mmc = find_mmc_device(CONFIG_FASTBOOT_FLASH_MMC_DEV);
+
+	if (mmc == NULL) {
+		printf("fastboot: no mmc device at slot %d", CONFIG_FASTBOOT_FLASH_MMC_DEV);
+		return NULL;
+	}
+
+	if (&mmc->block_dev == NULL) {
+		printf("fastboot: block device mmc %d not supported\n",
+				CONFIG_FASTBOOT_FLASH_MMC_DEV);
+	}
+
+	return &mmc->block_dev;
+#else
+	return NULL;
+#endif
+}
+
+static void print_fastboot_dev(void)
+{
+	if (mmc) {
+		printf("fastboot: mmc capacity is: %llu\n", mmc->capacity);
+		printf("fastboot: number of blocks:%lu\n", mmc->block_dev.lba);
+		printf("fastboot: block size:%lu\n", mmc->block_dev.blksz);
+	}
+}
+
+int fastboot_load_dos_partition(void)
+{
+	int n;
+	int nr_parts = 0;
+	block_dev_desc_t *dev_desc = fastboot_block_dev();
+
+	if (dev_desc == NULL)
+		return -EIO;
+
+	for (n = 1; n <= NR_PARTITIONS; n++) {
+		fastboot_ptentry ptn;
+		disk_partition_t part_info;
+
+		if (get_partition_info(dev_desc, n, &part_info))
+			continue;
+
+		if (board_dos_partition_name(n, ptn.name) == NULL)
+			sprintf(ptn.name, "part-%d", n);
+
+		ptn.start = part_info.start;
+		ptn.length = part_info.size;
+
+		fastboot_flash_add_ptn(&ptn);
+		nr_parts++;
+	}
+
+	return nr_parts;
+}
+
+static void dos_partition_entry(dos_partition_t *part,
+		u32 start, u32 size, u8 type)
+{
+	part->boot_ind = 0x00;
+	part->head = 0;
+	part->sector = 1;
+	part->cyl = 1;
+	part->sys_ind = type;
+	part->end_head = 0;
+	part->end_sector = 0;
+	part->end_cyl = 0;
+
+	u32 *p = (u32 *)part->start4;
+	*p = start;
+	p = (u32 *)part->size4;
+	*p = size;
+}
+
+int do_format(void)
+{
+	u8 mbr[512];
+	lbaint_t next;
+	int n;
+	block_dev_desc_t *dev_desc = fastboot_block_dev();
+
+	/* Read the first sector, MBR, to buffer */
+	if (dev_desc && dev_desc->block_read(dev_desc->dev, 0, 1, mbr) != 1) {
+		printf("fastboot: can't read MBR from device %d\n",
+				dev_desc->dev);
+		return -EIO;
+	}
+
+	/* Initiate MBR sector for parititons and its type */
+	memset(mbr + 0x1be, 0, sizeof(dos_partition_t) * NR_PARTITIONS);
+	mbr[0x1fe] = 0x55;
+	mbr[0x1ff] = 0xaa;
+
+	print_fastboot_dev();
+
+	next = board_dos_partition_start();
+
+	for (n = 1; n <= NR_PARTITIONS; n++) {
+		lbaint_t sz = 0;
+		int part;
+		u8 type;
+		dos_partition_t *ptn;
+
+		sz = board_dos_partition_next(&part, &type);
+		if (sz == 0)
+			continue;
+
+		if (sz == -1)
+			sz = dev_desc->lba - next;
+
+		ptn = (dos_partition_t*)(mbr + 0x1be
+			+ (sizeof(dos_partition_t) * (part - 1)));
+
+		dos_partition_entry(ptn, next, sz, type);
+
+		next += sz;
+	}
+
+	/* Write the MBR with new partition details */
+	if (dev_desc->block_write(dev_desc->dev, 0, 1, mbr) != 1) {
+		printf("fastboot: can't write MBR to device %d\n",
+				dev_desc->dev);
+		return -EIO;
+	}
+
+	return 0;
+}
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 128736d..5c1ac72 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -48,4 +48,7 @@ source "drivers/dma/Kconfig"
 
 source "drivers/crypto/Kconfig"
 
+source "drivers/vpu/Kconfig"
+
+source "drivers/nand/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 5ef58c0..9132137 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -14,6 +14,7 @@ obj-y += sound/
 obj-y += tpm/
 obj-y += twserial/
 obj-y += video/
+obj-y += vpu/
 obj-y += watchdog/
 obj-$(CONFIG_QE) += qe/
 obj-$(CONFIG_U_QE) += qe/
@@ -23,3 +24,10 @@ obj-y += input/
 # SOC specific infrastructure drivers.
 obj-y += soc/
 obj-y += thermal/
+obj-$(CONFIG_EFUSE) += efuse/
+obj-$(CONFIG_UNIFY_KEY_MANAGE) += keymanage/
+obj-$(CONFIG_AML_V2_FACTORY_BURN)	+= usb/gadget/v2_burning/
+obj-y += display/
+obj-$(CONFIG_SECURE_STORAGE) += securestorage/
+obj-$(CONFIG_SECURE_STORAGE) += storagekey/
+obj-$(CONFIG_CMD_SARADC) += adc/
diff --git a/drivers/adc/Makefile b/drivers/adc/Makefile
new file mode 100644
index 0000000..9a318d0
--- /dev/null
+++ b/drivers/adc/Makefile
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+obj-$(CONFIG_CMD_SARADC) += saradc.o
+#obj-y += saradc.o
diff --git a/drivers/adc/saradc.c b/drivers/adc/saradc.c
new file mode 100644
index 0000000..ddef63b
--- /dev/null
+++ b/drivers/adc/saradc.c
@@ -0,0 +1,271 @@
+/*
+ * Copyright C 2011 by Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * Remark: migrate from trunk by Hisun Bao 2011.07.29
+ *
+ */
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+#include <asm/saradc.h>
+
+//#define ENABLE_DYNAMIC_POWER
+
+
+#define CONFIG_GXBB 1
+
+
+#if defined(CONFIG_GXBB)
+
+#define WRITE_REG(reg, val) writel(val, reg)
+#define READ_REG(reg)       readl(reg)
+
+#define GXBB_ADC   1
+#define AML_ADC_SAMPLE_DEBUG 0
+#define GXBB_CLK_REG                (volatile unsigned int *)0xc883c3d8
+
+#define P_SAR_SAR_ADC_REG0		    (volatile unsigned int *)0xc1108680
+#define P_SAR_ADC_CHAN_LIST		    (volatile unsigned int *)0xc1108684
+#define P_SAR_ADC_AVG_CNTL		    (volatile unsigned int *)0xc1108688
+#define P_SAR_ADC_REG3				(volatile unsigned int *)0xc110868c
+#define P_SAR_ADC_DELAY			    (volatile unsigned int *)0xc1108690
+#define P_SAR_ADC_LAST_RD			(volatile unsigned int *)0xc1108694
+#define P_SAR_ADC_FIFO_RD			(volatile unsigned int *)0xc1108698
+#define P_SAR_ADC_AUX_SW			(volatile unsigned int *)0xc110869c
+#define P_SAR_ADC_CHAN_10_SW		(volatile unsigned int *)0xc11086a0
+#define P_SAR_ADC_DETECT_IDLE_SW	(volatile unsigned int *)0xc11086a4
+#define P_SAR_ADC_DELTA_10	        (volatile unsigned int *)0xc11086a8
+#define P_SAR_ADC_DELTA_11          (volatile unsigned int *)0xc11086aC
+
+/*
+#define P_SAR_ADC_DELTA_11		    (volatile unsigned int *)0xc11086a8
+#define P_SAR_ADC_TEMP_SES		    (volatile unsigned int *)0xc11086ac
+#define P_SAR_ADC_CLOCK			    (volatile unsigned int *)0xc883c3d8
+#define P_SAR_FIFO_READ			    (volatile unsigned int *)0xc1108698
+*/
+
+#define PP_SAR_ADC_REG0					P_SAR_SAR_ADC_REG0
+#define PP_SAR_ADC_CHAN_LIST 			P_SAR_ADC_CHAN_LIST
+#define PP_SAR_ADC_AVG_CNTL				P_SAR_ADC_AVG_CNTL
+#define PP_SAR_ADC_REG3					P_SAR_ADC_REG3
+#define PP_SAR_ADC_DELAY				P_SAR_ADC_DELAY
+#define PP_SAR_ADC_LAST_RD				P_SAR_ADC_LAST_RD
+#define PP_SAR_ADC_FIFO_RD				P_SAR_ADC_FIFO_RD
+#define PP_SAR_ADC_AUX_SW				P_SAR_ADC_AUX_SW
+#define PP_SAR_ADC_CHAN_10_SW			P_SAR_ADC_CHAN_10_SW
+#define PP_SAR_ADC_DETECT_IDLE_SW	    P_SAR_ADC_DETECT_IDLE_SW
+#define PP_SAR_ADC_DELTA_10				P_SAR_ADC_DELTA_10
+#define PP_SAR_ADC_DELTA_11				P_SAR_ADC_DELTA_11
+
+
+static __inline__ void aml_set_reg32_bits(volatile unsigned int *_reg, const uint32_t _value, const uint32_t _start, const uint32_t _len)
+{
+	writel(( (readl((volatile unsigned int *)_reg) & ~((( 1L << (_len) )-1) << (_start))) | ((unsigned)((_value)&((1L<<(_len))-1)) << (_start))), (volatile void *)_reg );
+}
+static __inline__ uint32_t aml_get_reg32_bits(volatile unsigned int *_reg, const uint32_t _start, const uint32_t _len)
+{
+	return	( (readl((volatile unsigned int *)_reg) >> (_start)) & (( 1L << (_len) ) - 1) );
+}
+static __inline__ void aml_write_reg32( volatile unsigned int *_reg, const uint32_t _value)
+{
+	writel( _value,(volatile unsigned int *)_reg );
+};
+static __inline__ uint32_t aml_read_reg32(volatile unsigned int *_reg)
+{
+	return readl((volatile unsigned int *)_reg);
+};
+
+
+#define set_bits	aml_set_reg32_bits
+#define get_bits	aml_get_reg32_bits
+#define set_reg	    aml_write_reg32
+#define get_reg	    aml_read_reg32
+
+
+#endif
+
+#define SARADC_STATE_IDLE 0
+#define SARADC_STATE_BUSY 1
+#define SARADC_STATE_SUSPEND 2
+
+#define FLAG_INITIALIZED (1<<28)
+#define FLAG_BUSY (1<<29)
+
+
+//static u8 g_chan_mux[AML_ADC_SARADC_CHAN_NUM] = {0,1,2,3,4,5,6,7};
+
+
+
+static inline void saradc_power_control(int on)
+{
+	//struct saradc_reg3 *reg3 = (struct saradc_reg3 *)&adc->regs->reg3;
+
+	if (on) {
+        aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,1,13,1);
+        aml_set_reg32_bits(PP_SAR_ADC_REG3,1,21,1);
+
+		udelay(5);
+
+        #if GXBB_ADC
+            aml_set_reg32_bits(GXBB_CLK_REG,1,8,1);
+        #else
+            aml_set_reg32_bits(PP_SAR_ADC_REG3,1,30,1);
+        #endif
+	}	else {
+		#if GXBB_ADC
+			aml_set_reg32_bits(GXBB_CLK_REG,0,8,1);
+		#else
+			aml_set_reg32_bits(PP_SAR_ADC_REG3,0,30,1);
+        #endif
+		aml_set_reg32_bits(PP_SAR_ADC_REG3,0,30,1);
+        aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,0,13,1); /* disable bandgap */
+	}
+}
+
+
+
+void saradc_enable(void)
+{
+    set_reg(P_SAR_SAR_ADC_REG0, 0x84004040);
+    set_reg(PP_SAR_ADC_CHAN_LIST, 0);
+    /* REG2: all chanel set to 8-samples & median averaging mode */
+    set_reg(PP_SAR_ADC_AVG_CNTL, 0);
+
+    set_reg(PP_SAR_ADC_REG3, 0x9388000a);
+    aml_set_reg32_bits(PP_SAR_ADC_REG3, 0x14,10,5);
+
+    #if GXBB_ADC
+    aml_write_reg32(GXBB_CLK_REG, (0<<9) | (20 << 0));
+    #endif
+    set_reg(PP_SAR_ADC_DELAY, 0x10a000a);
+    set_reg(PP_SAR_ADC_AUX_SW, 0x3eb1a0c);
+    set_reg(PP_SAR_ADC_CHAN_10_SW, 0x8c000c);
+    set_reg(PP_SAR_ADC_DETECT_IDLE_SW, 0xc000c);
+
+#if AML_ADC_SAMPLE_DEBUG
+	printf("ADCREG reg0 =%x\n",   get_reg(PP_SAR_ADC_REG0));
+	printf("ADCREG ch list =%x\n",get_reg(PP_SAR_ADC_CHAN_LIST));
+	printf("ADCREG avg  =%x\n",   get_reg(PP_SAR_ADC_AVG_CNTL));
+	printf("ADCREG reg3 =%x\n",   get_reg(PP_SAR_ADC_REG3));
+	printf("ADCREG ch72 sw =%x\n",get_reg(PP_SAR_ADC_AUX_SW));
+	printf("ADCREG ch10 sw =%x\n",get_reg(PP_SAR_ADC_CHAN_10_SW));
+	printf("ADCREG detect&idle=%x\n",get_reg(PP_SAR_ADC_DETECT_IDLE_SW));
+    printf("ADCREG GXBB_CLK_REG=%x\n",get_reg(GXBB_CLK_REG));
+#endif //AML_ADC_SAMPLE_DEBUG
+
+
+    saradc_power_control(1);
+}
+
+
+/*
+static int saradc_get_cal_value(struct saradc *adc, int val)
+{
+	int nominal;
+
+//	((nominal - ref_nominal) << 10) / (val - ref_val) = coef
+//	==> nominal = ((val - ref_val) * coef >> 10) + ref_nominal
+
+	nominal = val;
+	if ((adc->coef > 0) && (val > 0)) {
+		nominal = (val - adc->ref_val) * adc->coef;
+		nominal >>= 12;
+		nominal += adc->ref_nominal;
+	}
+	if (nominal < 0)
+		nominal = 0;
+	if (nominal > 1023)
+		nominal = 1023;
+	return nominal;
+}
+*/
+
+int get_adc_sample_gxbb(int ch)
+{
+	int value, count, sum;
+	//unsigned long flags;
+
+	//int adc_state = SARADC_STATE_BUSY;
+
+	count = 0;
+	while (aml_read_reg32(PP_SAR_ADC_REG3) & FLAG_BUSY) {
+		udelay(100);
+		if (++count > 100) {
+			printf("bl30 busy error\n");
+			value = -1;
+			goto end1;
+		}
+	}
+	aml_set_reg32_bits(PP_SAR_ADC_REG3,1,29,1);
+
+    set_reg(PP_SAR_ADC_CHAN_LIST, ch);
+    set_reg(PP_SAR_ADC_DETECT_IDLE_SW, (0xc000c | (ch<<23) | (ch<<7)));
+    aml_set_reg32_bits(PP_SAR_ADC_REG0, 1,0,1);
+    aml_set_reg32_bits(PP_SAR_ADC_REG0, 1,2,1);
+
+    count = 0;
+	do {
+		udelay(10);
+		if (!(aml_read_reg32(P_SAR_SAR_ADC_REG0) & 0x70000000))
+			break;
+		else if (++count > 10000) {
+			printf("busy error=%x\n", aml_read_reg32(P_SAR_SAR_ADC_REG0));
+			value = -1;
+			goto end;
+		}
+	} while (1);
+
+	count = 0;
+	sum = 0;
+	while (aml_get_reg32_bits(PP_SAR_ADC_REG0,21,5) && (count < 32)) {
+		if (aml_get_reg32_bits(PP_SAR_ADC_REG0,26,1))
+			printf("fifo_count, but fifo empty\n");
+
+        value = aml_read_reg32(PP_SAR_ADC_FIFO_RD);
+		if (((value>>12) & 0x07) == ch) {
+			sum += value & 0x3ff;
+			count++;
+		}	else
+			printf("chanel error\n");
+	}
+	if (!aml_get_reg32_bits(PP_SAR_ADC_REG0,26,1))
+		printf("fifo_count=0, but fifo not empty\n");
+	if (!count) {
+		value = -1;
+		goto end;
+	}
+	value = sum / count;
+	//printf("before cal: %d, count=%d\n", value, count);
+
+    //value = saradc_get_cal_value(adc, value);
+end:
+    aml_set_reg32_bits(PP_SAR_ADC_REG0,1,14,1);
+    aml_set_reg32_bits(PP_SAR_ADC_REG0,0,0,1);
+
+end1:
+    aml_set_reg32_bits(PP_SAR_ADC_REG3,0,29,1);
+    //adc_state = SARADC_STATE_IDLE;
+
+	return value;
+}
+
+int saradc_disable(void)
+{
+	saradc_power_control(0);
+	return 0;
+}
diff --git a/drivers/display/Makefile b/drivers/display/Makefile
new file mode 100644
index 0000000..f5975ef
--- /dev/null
+++ b/drivers/display/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_AML_CANVAS) += canvas/
+obj-$(CONFIG_AML_OSD) += osd/
+obj-$(CONFIG_AML_VOUT) += vout/
diff --git a/drivers/display/canvas/Makefile b/drivers/display/canvas/Makefile
new file mode 100644
index 0000000..af286e4
--- /dev/null
+++ b/drivers/display/canvas/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_AML_CANVAS) += canvas.o
diff --git a/drivers/display/canvas/canvas.c b/drivers/display/canvas/canvas.c
new file mode 100644
index 0000000..85462a6
--- /dev/null
+++ b/drivers/display/canvas/canvas.c
@@ -0,0 +1,143 @@
+/*
+ * AMLOGIC Canvas management driver.
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* System Headers */
+#include <common.h>
+#include <asm/arch/io.h>
+
+/* Amlogic Headers */
+#include <amlogic/canvas.h>
+
+#define CANVAS_DEBUG_ENABLE
+#ifdef CANVAS_DEBUG_ENABLE
+#define canvas_log(fmt, args...) \
+	do { \
+		printf("[CANVAS]"fmt"\n", ##args); \
+	} while (0)
+#else
+#define canvas_log(fmt, args...)
+#endif
+
+#define canvas_reg_read(reg) readl(DMC_REG_BASE + reg)
+#define canvas_reg_write(val, reg) writel(val, (DMC_REG_BASE + reg))
+
+#define CANVAS_NUM 192
+static canvas_t canvasPool[CANVAS_NUM];
+
+void canvas_config(u32 index, ulong addr, u32 width,
+		   u32 height, u32 wrap, u32 blkmode)
+{
+	canvas_t *canvasP = &canvasPool[index];
+
+	if (index >= CANVAS_NUM)
+		return;
+
+	canvas_log("addr=0x%08lx width=%d, height=%d\n", addr, width, height);
+
+	canvas_reg_write((((addr + 7) >> 3) & CANVAS_ADDR_LMASK) |
+			 ((((width + 7) >> 3) & CANVAS_WIDTH_LMASK) << CANVAS_WIDTH_LBIT),
+			 DC_CAV_LUT_DATAL);
+	canvas_reg_write(((((width + 7) >> 3) >> CANVAS_WIDTH_LWID) <<
+			  CANVAS_WIDTH_HBIT) |
+			 ((height & CANVAS_HEIGHT_MASK) << CANVAS_HEIGHT_BIT)	|
+			 ((wrap & CANVAS_XWRAP) ? CANVAS_XWRAP : 0)              |
+			 ((wrap & CANVAS_YWRAP) ? CANVAS_YWRAP : 0)              |
+			 ((blkmode & CANVAS_BLKMODE_MASK) << CANVAS_BLKMODE_BIT),
+			 DC_CAV_LUT_DATAH);
+	canvas_reg_write(CANVAS_LUT_WR_EN | index, DC_CAV_LUT_ADDR);
+	// read a cbus to make sure last write finish.
+	canvas_reg_read(DC_CAV_LUT_DATAH);
+
+	canvasP->addr = addr;
+	canvasP->width = width;
+	canvasP->height = height;
+	canvasP->wrap = wrap;
+	canvasP->blkmode = blkmode;
+
+}
+
+void canvas_read(u32 index, canvas_t *p)
+{
+	if (index < CANVAS_NUM)
+		*p = canvasPool[index];
+}
+
+void canvas_copy(u32 src, u32 dst)
+{
+	unsigned long addr;
+	unsigned width, height, wrap, blkmode;
+
+	if ((src >= CANVAS_NUM) || (dst >= CANVAS_NUM))
+		return;
+
+	addr = canvasPool[src].addr;
+	width = canvasPool[src].width;
+	height = canvasPool[src].height;
+	wrap = canvasPool[src].wrap;
+	blkmode = canvasPool[src].blkmode;
+
+	canvas_reg_write((((addr + 7) >> 3) & CANVAS_ADDR_LMASK) |
+			 ((((width + 7) >> 3) & CANVAS_WIDTH_LMASK) << CANVAS_WIDTH_LBIT),
+			 DC_CAV_LUT_DATAL);
+	canvas_reg_write(((((width + 7) >> 3) >> CANVAS_WIDTH_LWID) <<
+			  CANVAS_WIDTH_HBIT) |
+			 ((height & CANVAS_HEIGHT_MASK) << CANVAS_HEIGHT_BIT)    |
+			 ((wrap & CANVAS_XWRAP) ? CANVAS_XWRAP : 0)              |
+			 ((wrap & CANVAS_YWRAP) ? CANVAS_YWRAP : 0)              |
+			 ((blkmode & CANVAS_BLKMODE_MASK) << CANVAS_BLKMODE_BIT),
+			 DC_CAV_LUT_DATAH);
+	canvas_reg_write(CANVAS_LUT_WR_EN | dst, DC_CAV_LUT_ADDR);
+	// read a cbus to make sure last write finish.
+	canvas_reg_read(DC_CAV_LUT_DATAH);
+
+	canvasPool[dst].addr = addr;
+	canvasPool[dst].width = width;
+	canvasPool[dst].height = height;
+	canvasPool[dst].wrap = wrap;
+	canvasPool[dst].blkmode = blkmode;
+
+	return;
+}
+
+void canvas_update_addr(u32 index, u32 addr)
+{
+	if (index >= CANVAS_NUM)
+		return;
+
+	canvasPool[index].addr = addr;
+
+	canvas_reg_write((((canvasPool[index].addr + 7) >> 3) & CANVAS_ADDR_LMASK) |
+			 ((((canvasPool[index].width + 7) >> 3) & CANVAS_WIDTH_LMASK) <<
+			  CANVAS_WIDTH_LBIT), DC_CAV_LUT_DATAL);
+	canvas_reg_write(((((canvasPool[index].width + 7) >> 3) >> CANVAS_WIDTH_LWID) <<
+			  CANVAS_WIDTH_HBIT) |
+			 ((canvasPool[index].height & CANVAS_HEIGHT_MASK) << CANVAS_HEIGHT_BIT)   |
+			 ((canvasPool[index].wrap & CANVAS_XWRAP) ? CANVAS_XWRAP : 0)             |
+			 ((canvasPool[index].wrap & CANVAS_YWRAP) ? CANVAS_YWRAP : 0)             |
+			 ((canvasPool[index].blkmode & CANVAS_BLKMODE_MASK) << CANVAS_BLKMODE_BIT),
+			 DC_CAV_LUT_DATAH);
+	canvas_reg_write(CANVAS_LUT_WR_EN | index, DC_CAV_LUT_ADDR);
+	// read a cbus to make sure last write finish.
+	canvas_reg_read(DC_CAV_LUT_DATAH);
+
+	return;
+}
+
+unsigned int canvas_get_addr(u32 index)
+{
+	return canvasPool[index].addr;
+}
diff --git a/drivers/display/canvas/canvas_reg.h b/drivers/display/canvas/canvas_reg.h
new file mode 100644
index 0000000..cd0af47
--- /dev/null
+++ b/drivers/display/canvas/canvas_reg.h
@@ -0,0 +1,53 @@
+/*
+ * drivers/canvas/canvas_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CANVAS_REG_HEADER_
+#define CANVAS_REG_HEADER_
+
+#define DMC_REG_BASE            0xc8838000
+#define DC_CAV_LUT_DATAL        (0x12 << 2)
+#define DC_CAV_LUT_DATAH        (0x13 << 2)
+#define DC_CAV_LUT_ADDR         (0x14 << 2)
+#define DC_CAV_LUT_RDATAL       (0x15 << 2)
+#define DC_CAV_LUT_RDATAH       (0x16 << 2)
+
+#define CANVAS_ADDR_LMASK       0x1fffffff
+#define CANVAS_WIDTH_LMASK      0x7
+#define CANVAS_WIDTH_LWID       3
+#define CANVAS_WIDTH_LBIT       29
+
+#define CANVAS_WIDTH_HMASK      0x1ff
+#define CANVAS_WIDTH_HBIT       0
+#define CANVAS_HEIGHT_MASK      0x1fff
+#define CANVAS_HEIGHT_BIT       9
+#define CANVAS_YWRAP            (1<<23)
+#define CANVAS_XWRAP            (1<<22)
+#define CANVAS_ADDR_NOWRAP      0x00
+#define CANVAS_ADDR_WRAPX       0x01
+#define CANVAS_ADDR_WRAPY       0x02
+#define CANVAS_BLKMODE_MASK     3
+#define CANVAS_BLKMODE_BIT      24
+#define CANVAS_BLKMODE_LINEAR   0x00
+#define CANVAS_BLKMODE_32X32    0x01
+#define CANVAS_BLKMODE_64X32    0x02
+
+#define CANVAS_LUT_INDEX_BIT    0
+#define CANVAS_LUT_INDEX_MASK   0x7
+#define CANVAS_LUT_WR_EN        (0x2 << 8)
+#define CANVAS_LUT_RD_EN        (0x1 << 8)
+
+#endif
diff --git a/drivers/display/osd/Makefile b/drivers/display/osd/Makefile
new file mode 100644
index 0000000..4321ebd
--- /dev/null
+++ b/drivers/display/osd/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_AML_OSD) += osd_hw.o osd_fb.o osd_debug.o
diff --git a/drivers/display/osd/cpu_version.h b/drivers/display/osd/cpu_version.h
new file mode 100644
index 0000000..a1135a8
--- /dev/null
+++ b/drivers/display/osd/cpu_version.h
@@ -0,0 +1,81 @@
+/*
+ * drivers/osd/cpu_version.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CPU_VERSION_H
+#define CPU_VERSION_H
+
+#define MESON_CPU_MAJOR_ID_M6		0x16
+#define MESON_CPU_MAJOR_ID_M6TV		0x17
+#define MESON_CPU_MAJOR_ID_M6TVL	0x18
+#define MESON_CPU_MAJOR_ID_M8		0x19
+#define MESON_CPU_MAJOR_ID_MTVD		0x1A
+#define MESON_CPU_MAJOR_ID_M8B		0x1B
+#define MESON_CPU_MAJOR_ID_MG9TV	0x1C
+#define MESON_CPU_MAJOR_ID_M8M2		0x1D
+#define MESON_CPU_MAJOR_ID_GXBB		0x1F
+
+#define MESON_CPU_VERSION_LVL_MAJOR	0
+#define MESON_CPU_VERSION_LVL_MINOR	1
+#define MESON_CPU_VERSION_LVL_PACK	2
+#define MESON_CPU_VERSION_LVL_MISC	3
+#define MESON_CPU_VERSION_LVL_MAX	MESON_CPU_VERSION_LVL_MISC
+
+static inline int get_meson_cpu_version(int level)
+{
+	return MESON_CPU_MAJOR_ID_GXBB;
+}
+static inline bool is_meson_m8_cpu(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
+	       MESON_CPU_MAJOR_ID_M8;
+}
+
+static inline bool is_meson_mtvd_cpu(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
+	       MESON_CPU_MAJOR_ID_MTVD;
+}
+
+static inline bool is_meson_m8b_cpu(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
+	       MESON_CPU_MAJOR_ID_M8B;
+}
+
+static inline bool is_meson_m8m2_cpu(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
+	       MESON_CPU_MAJOR_ID_M8M2;
+}
+
+static inline bool is_meson_g9tv_cpu(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
+	       MESON_CPU_MAJOR_ID_MG9TV;
+}
+
+static inline bool is_meson_gxbb_cpu(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
+	       MESON_CPU_MAJOR_ID_GXBB;
+}
+
+static inline u32 get_cpu_type(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR);
+}
+#endif
diff --git a/drivers/display/osd/osd.h b/drivers/display/osd/osd.h
new file mode 100644
index 0000000..c8fb800
--- /dev/null
+++ b/drivers/display/osd/osd.h
@@ -0,0 +1,267 @@
+/*
+ * drivers/display/osd/osd.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * Author: Platform-BJ @platform.bj@amlogic.com
+ *
+*/
+
+#ifndef _OSD_H_
+#define _OSD_H_
+
+#include <amlogic/color.h>
+
+/* OSD device ioctl definition */
+#define FBIOPUT_OSD_SRCKEY_ENABLE        0x46fa
+#define FBIOPUT_OSD_SRCCOLORKEY          0x46fb
+#define FBIOPUT_OSD_SET_GBL_ALPHA        0x4500
+#define FBIOGET_OSD_GET_GBL_ALPHA        0x4501
+#define FBIOPUT_OSD_2X_SCALE             0x4502
+#define FBIOPUT_OSD_ENABLE_3D_MODE       0x4503
+#define FBIOPUT_OSD_FREE_SCALE_ENABLE    0x4504
+#define FBIOPUT_OSD_FREE_SCALE_WIDTH     0x4505
+#define FBIOPUT_OSD_FREE_SCALE_HEIGHT    0x4506
+#define FBIOPUT_OSD_ORDER                0x4507
+#define FBIOGET_OSD_ORDER                0x4508
+#define FBIOGET_OSD_SCALE_AXIS           0x4509
+#define FBIOPUT_OSD_SCALE_AXIS           0x450a
+#define FBIOGET_OSD_BLOCK_WINDOWS        0x450b
+#define FBIOPUT_OSD_BLOCK_WINDOWS        0x450c
+#define FBIOGET_OSD_BLOCK_MODE           0x450d
+#define FBIOPUT_OSD_BLOCK_MODE           0x450e
+#define FBIOGET_OSD_FREE_SCALE_AXIS      0x450f
+#define FBIOPUT_OSD_FREE_SCALE_AXIS      0x4510
+#define FBIOPUT_OSD_FREE_SCALE_MODE      0x4511
+#define FBIOGET_OSD_WINDOW_AXIS          0x4512
+#define FBIOPUT_OSD_WINDOW_AXIS          0x4513
+#define FBIOGET_OSD_FLUSH_RATE           0x4514
+#define FBIOPUT_OSD_REVERSE              0x4515
+#define FBIOPUT_OSD_ROTATE_ON            0x4516
+#define FBIOPUT_OSD_ROTATE_ANGLE         0x4517
+#define FBIOPUT_OSD_SYNC_ADD             0x4518
+
+/* OSD color definition */
+#define KEYCOLOR_FLAG_TARGET  1
+#define KEYCOLOR_FLAG_ONHOLD  2
+#define KEYCOLOR_FLAG_CURRENT 4
+
+#define HW_OSD_COUNT 2
+/* OSD block definition */
+#define HW_OSD_BLOCK_COUNT 4
+#define HW_OSD_BLOCK_REG_COUNT (HW_OSD_BLOCK_COUNT*2)
+#define HW_OSD_BLOCK_ENABLE_MASK        0x000F
+#define HW_OSD_BLOCK_ENABLE_0           0x0001 /* osd blk0 enable */
+#define HW_OSD_BLOCK_ENABLE_1           0x0002 /* osd blk1 enable */
+#define HW_OSD_BLOCK_ENABLE_2           0x0004 /* osd blk2 enable */
+#define HW_OSD_BLOCK_ENABLE_3           0x0008 /* osd blk3 enable */
+#define HW_OSD_BLOCK_LAYOUT_MASK        0xFFFF0000
+#define HW_OSD_BLOCK_LAYOUT_HORIZONTAL  0x00010000
+#define HW_OSD_BLOCK_LAYOUT_VERTICAL    0x00020000
+#define HW_OSD_BLOCK_LAYOUT_GRID        0x00030000
+#define HW_OSD_BLOCK_LAYOUT_CUSTOMER    0xFFFF0000
+
+#define OSD_LEFT 0
+#define OSD_RIGHT 1
+#define OSD_ORDER_01 1
+#define OSD_ORDER_10 2
+#define OSD_GLOBAL_ALPHA_DEF 0xff
+#define OSD_DATA_BIG_ENDIAN 0
+#define OSD_DATA_LITTLE_ENDIAN 1
+#define OSD_TC_ALPHA_ENABLE_DEF 0  /* disable tc_alpha */
+
+#define INT_VIU_VSYNC 35
+#define INT_VIU2_VSYNC 45
+extern int int_rdma;
+
+#define OSD_MAX_BUF_NUM 3  /* fence relative */
+
+enum osd_index_e {
+	OSD1 = 0,
+	OSD2
+};
+
+enum osd_enable_e {
+	DISABLE = 0,
+	ENABLE
+};
+
+enum scan_mode_e {
+	SCAN_MODE_INTERLACE,
+	SCAN_MODE_PROGRESSIVE
+};
+
+struct color_bit_define_s {
+	enum color_index_e color_index;
+	u8 hw_colormat;
+	u8 hw_blkmode;
+
+	u8 red_offset;
+	u8 red_length;
+	u8 red_msb_right;
+
+	u8 green_offset;
+	u8 green_length;
+	u8 green_msb_right;
+
+	u8 blue_offset;
+	u8 blue_length;
+	u8 blue_msb_right;
+
+	u8 transp_offset;
+	u8 transp_length;
+	u8 transp_msb_right;
+
+	u8 color_type;
+	u8 bpp;
+};
+
+struct osd_ctl_s {
+	u32 xres_virtual;
+	u32 yres_virtual;
+	u32 xres;
+	u32 yres;
+	u32 disp_start_x; /* coordinate of screen */
+	u32 disp_start_y;
+	u32 disp_end_x;
+	u32 disp_end_y;
+	u32 addr;
+	u32 index;
+};
+
+struct osd_info_s {
+	u32 index;
+	u32 osd_reverse;
+};
+
+struct para_osd_info_s {
+	char *name;
+	u32 info;
+	u32 prev_idx;
+	u32 next_idx;
+	u32 cur_group_start;
+	u32 cur_group_end;
+};
+
+enum osd_dev_e {
+	DEV_OSD0 = 0,
+	DEV_OSD1,
+	DEV_ALL,
+	DEV_MAX
+};
+
+enum reverse_info_e {
+	REVERSE_FALSE = 0,
+	REVERSE_TRUE,
+	REVERSE_MAX
+};
+
+enum hw_reg_index_e {
+	OSD_COLOR_MODE = 0,
+	OSD_ENABLE,
+	OSD_COLOR_KEY,
+	OSD_COLOR_KEY_ENABLE,
+	OSD_GBL_ALPHA,
+	OSD_CHANGE_ORDER,
+	OSD_FREESCALE_COEF,
+	DISP_GEOMETRY,
+	DISP_SCALE_ENABLE,
+	DISP_FREESCALE_ENABLE,
+	DISP_OSD_REVERSE,
+	DISP_OSD_ROTATE,
+	HW_REG_INDEX_MAX
+};
+
+struct pandata_s {
+	s32 x_start;
+	s32 x_end;
+	s32 y_start;
+	s32 y_end;
+};
+
+struct fb_geometry_s {
+	u32 width;  /* in byte unit */
+	u32 height;
+	u32 canvas_idx;
+	u32 addr;
+};
+
+struct osd_scale_s {
+	u16 h_enable;
+	u16 v_enable;
+};
+
+struct osd_3d_mode_s {
+	struct osd_scale_s origin_scale;
+	u16 enable;
+	u16 left_right;
+	u16 l_start;
+	u16 l_end;
+	u16 r_start;
+	u16 r_end;
+};
+
+struct osd_rotate_s {
+	u32 on_off;
+	u32 angle;
+};
+
+typedef void (*update_func_t)(void);
+struct hw_list_s {
+	update_func_t update_func;
+};
+
+struct hw_para_s {
+	struct pandata_s pandata[HW_OSD_COUNT];
+	struct pandata_s dispdata[HW_OSD_COUNT];
+	struct pandata_s scaledata[HW_OSD_COUNT];
+	struct pandata_s free_scale_data[HW_OSD_COUNT];
+	struct pandata_s free_dst_data[HW_OSD_COUNT];
+	struct pandata_s rotation_pandata[HW_OSD_COUNT];
+	struct pandata_s cursor_dispdata[HW_OSD_COUNT];
+
+	u32 gbl_alpha[HW_OSD_COUNT];
+	u32 color_key[HW_OSD_COUNT];
+	u32 color_key_enable[HW_OSD_COUNT];
+	u32 enable[HW_OSD_COUNT];
+	u32 reg_status_save;
+#ifdef FIQ_VSYNC
+	bridge_item_t fiq_handle_item;
+#endif
+	struct osd_scale_s scale[HW_OSD_COUNT];
+	struct osd_scale_s free_scale[HW_OSD_COUNT];
+	u32 free_scale_enable[HW_OSD_COUNT];
+	u32 free_scale_width[HW_OSD_COUNT];
+	u32 free_scale_height[HW_OSD_COUNT];
+	struct fb_geometry_s fb_gem[HW_OSD_COUNT];
+	const struct color_bit_define_s *color_info[HW_OSD_COUNT];
+	u32 scan_mode;
+	u32 order;
+	struct osd_3d_mode_s mode_3d[HW_OSD_COUNT];
+	u32 updated[HW_OSD_COUNT];
+	u32 block_windows[HW_OSD_COUNT][HW_OSD_BLOCK_REG_COUNT];
+	u32 block_mode[HW_OSD_COUNT];
+	u32 free_scale_mode[HW_OSD_COUNT];
+	u32 osd_reverse[HW_OSD_COUNT];
+	struct osd_rotate_s rotate[HW_OSD_COUNT];
+	struct hw_list_s reg[HW_OSD_COUNT][HW_REG_INDEX_MAX];
+	u32 field_out_en;
+	u32 scale_workaround;
+	u32 fb_for_4k2k;
+	u32 antiflicker_mode;
+	u32 angle[HW_OSD_COUNT];
+	u32 clone[HW_OSD_COUNT];
+	u32 bot_type;
+};
+
+#endif /* _OSD_H_ */
diff --git a/drivers/display/osd/osd_canvas.h b/drivers/display/osd/osd_canvas.h
new file mode 100644
index 0000000..ee6ca69
--- /dev/null
+++ b/drivers/display/osd/osd_canvas.h
@@ -0,0 +1,28 @@
+/*
+ * drivers/amlogic/display/osd/osd_canvas.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _OSD_CANVAS_H_
+#define _OSD_CANVAS_H_
+
+#define OSD1_CANVAS_INDEX 0x40
+#define OSD2_CANVAS_INDEX 0x43
+#define OSD3_CANVAS_INDEX 0x41
+#define OSD4_CANVAS_INDEX 0x42
+#define ALLOC_CANVAS_INDEX 0x44
+
+#endif
diff --git a/drivers/display/osd/osd_debug.c b/drivers/display/osd/osd_debug.c
new file mode 100644
index 0000000..188c553
--- /dev/null
+++ b/drivers/display/osd/osd_debug.c
@@ -0,0 +1,220 @@
+/*
+ * drivers/osd/osd_hw.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/* System Headers */
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <asm/arch/io.h>
+
+/* Local Headers */
+#ifdef CONFIG_AML_CANVAS
+#include <amlogic/canvas.h>
+#endif
+
+/* Local Headers */
+#include "osd_reg.h"
+#include "osd_log.h"
+#include "osd_io.h"
+#include "osd_hw.h"
+
+#define OSD_TEST_DURATION 500
+
+#define msleep(a) mdelay(a)
+
+static void osd_debug_dump_value(void)
+{
+	u32 index = 0;
+	struct hw_para_s *hwpara = NULL;
+	struct pandata_s *pdata = NULL;
+
+	osd_get_hw_para(&hwpara);
+	if (hwpara == NULL)
+		return;
+
+	osd_logi("--- OSD ---\n");
+	osd_logi("scan_mode: %s\n", (hwpara->scan_mode == SCAN_MODE_INTERLACE) ? "interlace" : "progressive");
+	osd_logi("order: %d\n", hwpara->order);
+	osd_logi("bot_type: %d\n", hwpara->bot_type);
+	osd_logi("field_out_en: %d\n", hwpara->field_out_en);
+
+	for (index = 0; index < HW_OSD_COUNT; index++) {
+		osd_logi("\n--- OSD%d ---\n", index);
+		osd_logi("enable: %d\n", hwpara->enable[index]);
+		osd_logi("2x-scale enable.h:%d .v: %d\n",
+			 hwpara->scale[index].h_enable,
+			 hwpara->scale[index].v_enable);
+		osd_logi("free-scale-mode: %d\n",
+			 hwpara->free_scale_mode[index]);
+		osd_logi("free-scale enable.h:%d .v: %d\n",
+			 hwpara->free_scale[index].h_enable,
+			 hwpara->free_scale[index].v_enable);
+		pdata = &hwpara->pandata[index];
+		osd_logi("pan data:\n");
+		osd_logi("\tx_start: %10d, x_end: %10d\n",
+			 pdata->x_start, pdata->x_end);
+		osd_logi("\ty_start: %10d, y_end: %10d\n",
+			 pdata->y_start, pdata->y_end);
+
+		pdata = &hwpara->dispdata[index];
+		osd_logi("disp data:\n");
+		osd_logi("\tx_start: 0x%08x, x_end: 0x%08x\n",
+			 pdata->x_start, pdata->x_end);
+		osd_logi("\ty_start: 0x%08x, y_end: 0x%08x\n",
+			 pdata->y_start, pdata->y_end);
+
+		pdata = &hwpara->scaledata[index];
+		osd_logi("2x-scale data:\n");
+		osd_logi("\tx_start: 0x%08x, x_end: 0x%08x\n",
+			 pdata->x_start, pdata->x_end);
+		osd_logi("\ty_start: 0x%08x, y_end: 0x%08x\n",
+			 pdata->y_start, pdata->y_end);
+
+		pdata = &hwpara->free_scale_data[index];
+		osd_logi("free-scale src data:\n");
+		osd_logi("\tx_start: 0x%08x, x_end: 0x%08x\n",
+			 pdata->x_start, pdata->x_end);
+		osd_logi("\ty_start: 0x%08x, y_end: 0x%08x\n",
+			 pdata->y_start, pdata->y_end);
+
+		pdata = &hwpara->free_dst_data[index];
+		osd_logi("free-scale dst data:\n");
+		osd_logi("\tx_start: 0x%08x, x_end: 0x%08x\n",
+			 pdata->x_start, pdata->x_end);
+		osd_logi("\ty_start: 0x%08x, y_end: 0x%08x\n",
+			 pdata->y_start, pdata->y_end);
+	}
+
+}
+
+static void osd_debug_dump_register_all(void)
+{
+	u32 reg = 0;
+	u32 offset = 0;
+	u32 index = 0;
+
+	reg = VPU_VIU_VENC_MUX_CTRL;
+	osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+	reg = VPP_MISC;
+	osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+	reg = VPP_OFIFO_SIZE;
+	osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+	reg = VPP_HOLD_LINES;
+	osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+	reg = VPP_OSD_SC_CTRL0;
+	osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+	reg = VPP_OSD_SCI_WH_M1;
+	osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+	reg = VPP_OSD_SCO_H_START_END;
+	osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+	reg = VPP_OSD_SCO_V_START_END;
+	osd_logi("reg[0x%x]: 0x%08x\n\n", reg, osd_reg_read(reg));
+	reg = VPP_POSTBLEND_H_SIZE;
+	osd_logi("reg[0x%x]: 0x%08x\n\n", reg, osd_reg_read(reg));
+
+	for (index = 0; index < 2; index++) {
+		if (index == 1)
+			offset = REG_OFFSET;
+		reg = offset + VIU_OSD1_FIFO_CTRL_STAT;
+		osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+		reg = offset + VIU_OSD1_CTRL_STAT;
+		osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+		reg = offset + VIU_OSD1_BLK0_CFG_W0;
+		osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+		reg = offset + VIU_OSD1_BLK0_CFG_W1;
+		osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+		reg = offset + VIU_OSD1_BLK0_CFG_W2;
+		osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+		reg = offset + VIU_OSD1_BLK0_CFG_W3;
+		osd_logi("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+		reg = VIU_OSD1_BLK0_CFG_W4;
+		if (index == 1)
+			reg = VIU_OSD2_BLK0_CFG_W4;
+		osd_logi("reg[0x%x]: 0x%08x\n\n", reg, osd_reg_read(reg));
+	}
+}
+
+static void osd_test_colorbar(void)
+{
+	u32 encp_video_adv = 0;
+
+	encp_video_adv = osd_reg_read(ENCP_VIDEO_MODE_ADV);
+
+	/* start test mode */
+	osd_logi("--- OSD TEST COLORBAR ---\n");
+	osd_reg_write(ENCP_VIDEO_MODE_ADV, 0);
+	osd_reg_write(VENC_VIDEO_TST_EN, 1);
+	/* TST_MODE COLORBAR */
+	osd_logi("- COLORBAR -\n");
+	osd_reg_write(VENC_VIDEO_TST_MDSEL, 1);
+	msleep(OSD_TEST_DURATION);
+
+	/* TST_MODE THINLINE */
+	osd_logi("- THINLINE -\n");
+	osd_reg_write(VENC_VIDEO_TST_MDSEL, 2);
+	msleep(OSD_TEST_DURATION);
+	/* TST_MODE DOTGRID */
+	osd_logi("- DOTGRID -\n");
+	osd_reg_write(VENC_VIDEO_TST_MDSEL, 3);
+	msleep(OSD_TEST_DURATION);
+
+	/* stop test mode */
+	osd_reg_write(ENCP_VIDEO_MODE_ADV, encp_video_adv);
+	osd_reg_write(VENC_VIDEO_TST_EN, 0);
+	osd_reg_write(VENC_VIDEO_TST_MDSEL, 0);
+}
+
+static void osd_reset(void)
+{
+	osd_set_free_scale_enable_hw(0, 0);
+	osd_enable_hw(0, 1);
+}
+
+static void osd_test_dummydata(void)
+{
+	u32 dummy_data = 0;
+
+	dummy_data = osd_reg_read(VPP_DUMMY_DATA1);
+	osd_reset();
+	osd_logi("--- OSD TEST DUMMYDATA ---\n");
+	osd_reg_write(VPP_DUMMY_DATA1, 0xFF);
+	msleep(OSD_TEST_DURATION);
+	osd_reg_write(VPP_DUMMY_DATA1, 0);
+	msleep(OSD_TEST_DURATION);
+	osd_reg_write(VPP_DUMMY_DATA1, 0xFF00);
+	msleep(OSD_TEST_DURATION);
+	osd_reg_write(VPP_DUMMY_DATA1, dummy_data);
+}
+
+static void osd_debug_auto_test(void)
+{
+	osd_test_colorbar();
+
+	osd_test_dummydata();
+}
+
+void osd_debug(void)
+{
+	osd_debug_dump_value();
+	osd_logi("\n");
+	osd_debug_dump_register_all();
+}
+
+void osd_test(void)
+{
+	osd_debug_auto_test();
+}
diff --git a/drivers/display/osd/osd_fb.c b/drivers/display/osd/osd_fb.c
new file mode 100644
index 0000000..5c9614e
--- /dev/null
+++ b/drivers/display/osd/osd_fb.c
@@ -0,0 +1,505 @@
+/*
+ * drivers/osd/osd_fb.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/* System Headers */
+#include <common.h>
+#include <video_fb.h>
+#include <stdio_dev.h>
+#include <malloc.h>
+#include <bmp_layout.h>
+
+/* Local Headers */
+#include <amlogic/fb.h>
+#include <amlogic/color.h>
+#include <amlogic/vinfo.h>
+#include <amlogic/vout.h>
+
+/* Local Headers */
+#include "osd.h"
+#include "osd_log.h"
+#include "osd_hw.h"
+
+#define INVALID_BPP_ITEM {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+static const struct color_bit_define_s default_color_format_array[] = {
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	{
+		COLOR_INDEX_02_PAL4, 0, 0,
+		0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0,
+		FB_VISUAL_PSEUDOCOLOR, 2,
+	},
+	INVALID_BPP_ITEM,
+	{
+		COLOR_INDEX_04_PAL16, 0, 1,
+		0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0,
+		FB_VISUAL_PSEUDOCOLOR, 4,
+	},
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	{
+		COLOR_INDEX_08_PAL256, 0, 2,
+		0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0,
+		FB_VISUAL_PSEUDOCOLOR, 8,
+	},
+	/*16 bit color*/
+	{
+		COLOR_INDEX_16_655, 0, 4,
+		10, 6, 0, 5, 5, 0, 0, 5, 0, 0, 0, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	{
+		COLOR_INDEX_16_844, 1, 4,
+		8, 8, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	{
+		COLOR_INDEX_16_6442, 2, 4,
+		10, 6, 0, 6, 4, 0, 2, 4, 0, 0, 2, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	{
+		COLOR_INDEX_16_4444_R, 3, 4,
+		12, 4, 0, 8, 4, 0, 4, 4, 0, 0, 4, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	{
+		COLOR_INDEX_16_4642_R, 7, 4,
+		12, 4, 0, 6, 6, 0, 2, 4, 0, 0, 2, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	{
+		COLOR_INDEX_16_1555_A, 6, 4,
+		10, 5, 0, 5, 5, 0, 0, 5, 0, 15, 1, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	{
+		COLOR_INDEX_16_4444_A, 5, 4,
+		8, 4, 0, 4, 4, 0, 0, 4, 0, 12, 4, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	{
+		COLOR_INDEX_16_565, 4, 4,
+		11, 5, 0, 5, 6, 0, 0, 5, 0, 0, 0, 0,
+		FB_VISUAL_TRUECOLOR, 16
+	},
+	/*24 bit color*/
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	{
+		COLOR_INDEX_24_6666_A, 4, 7,
+		12, 6, 0, 6, 6, 0, 0, 6, 0, 18, 6, 0,
+		FB_VISUAL_TRUECOLOR, 24
+	},
+	{
+		COLOR_INDEX_24_6666_R, 3, 7,
+		18, 6, 0, 12, 6, 0, 6, 6, 0, 0, 6, 0,
+		FB_VISUAL_TRUECOLOR, 24
+	},
+	{
+		COLOR_INDEX_24_8565, 2, 7,
+		11, 5, 0, 5, 6, 0, 0, 5, 0, 16, 8, 0,
+		FB_VISUAL_TRUECOLOR, 24
+	},
+	{
+		COLOR_INDEX_24_5658, 1, 7,
+		19, 5, 0, 13, 6, 0, 8, 5, 0, 0, 8, 0,
+		FB_VISUAL_TRUECOLOR, 24
+	},
+	{
+		COLOR_INDEX_24_888_B, 5, 7,
+		0, 8, 0, 8, 8, 0, 16, 8, 0, 0, 0, 0,
+		FB_VISUAL_TRUECOLOR, 24
+	},
+	{
+		COLOR_INDEX_24_RGB, 0, 7,
+		16, 8, 0, 8, 8, 0, 0, 8, 0, 0, 0, 0,
+		FB_VISUAL_TRUECOLOR, 24
+	},
+	/*32 bit color*/
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	{
+		COLOR_INDEX_32_BGRA, 3, 5,
+		8, 8, 0, 16, 8, 0, 24, 8, 0, 0, 8, 0,
+		FB_VISUAL_TRUECOLOR, 32
+	},
+	{
+		COLOR_INDEX_32_ABGR, 2, 5,
+		0, 8, 0, 8, 8, 0, 16, 8, 0, 24, 8, 0,
+		FB_VISUAL_TRUECOLOR, 32
+	},
+	{
+		COLOR_INDEX_32_RGBA, 0, 5,
+		24, 8, 0, 16, 8, 0, 8, 8, 0, 0, 8, 0,
+		FB_VISUAL_TRUECOLOR, 32
+	},
+	{
+		COLOR_INDEX_32_ARGB, 1, 5,
+		16, 8, 0, 8, 8, 0, 0, 8, 0, 24, 8, 0,
+		FB_VISUAL_TRUECOLOR, 32
+	},
+	/*YUV color*/
+	{COLOR_INDEX_YUV_422, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16},
+};
+
+GraphicDevice fb_gdev;
+
+static void osd_layer_init(GraphicDevice gdev, int layer)
+{
+	u32 index = layer;
+	u32 xoffset = 0;
+	u32 yoffset = 0;
+	u32 xres = 0;
+	u32 yres = 0;
+	u32 xres_virtual = 0;
+	u32 yres_virtual = 0;
+	u32 disp_start_x = 0;
+	u32 disp_start_y = 0;
+	u32 disp_end_x = 0;
+	u32 disp_end_y = 0;
+	u32 fbmem = gdev.frameAdrs;
+	const struct color_bit_define_s *color =
+			&default_color_format_array[gdev.gdfIndex];
+
+#ifdef CONFIG_OSD_SCALE_ENABLE
+	xres = gdev.fb_width;
+	yres = gdev.fb_height;
+	xres_virtual = gdev.fb_width;
+	yres_virtual = gdev.fb_height * 2;
+	disp_end_x = gdev.fb_width - 1;
+	disp_end_y = gdev.fb_height - 1;
+#else
+	xres = gdev.winSizeX;
+	yres = gdev.winSizeY;
+	xres_virtual = gdev.winSizeX;
+	yres_virtual = gdev.winSizeY * 2;
+	disp_end_x = gdev.winSizeX - 1;
+	disp_end_y = gdev.winSizeY - 1;
+#endif
+
+	osd_init_hw();
+	osd_setup_hw(index,
+		     xoffset,
+		     yoffset,
+		     xres,
+		     yres,
+		     xres_virtual ,
+		     yres_virtual,
+		     disp_start_x,
+		     disp_start_y,
+		     disp_end_x,
+		     disp_end_y,
+		     fbmem,
+		     color);
+}
+
+static unsigned long env_strtoul(const char *name, int base)
+{
+	unsigned long ret = 0;
+	char *str = NULL;
+
+	str = getenv(name);
+	if (str)
+		ret = simple_strtoul(str, NULL, base);
+
+	if (base == 16)
+		osd_logd("%s: 0x%lx\n", name, ret);
+	else if (base == 10)
+		osd_logd("%s: %ld\n", name, ret);
+
+	return ret;
+}
+
+void *video_hw_init(void)
+{
+	u32 fb_addr = 0;
+	u32 display_width = 0;
+	u32 display_height = 0;
+	u32 display_bpp = 0;
+	u32 color_index = 0;
+	u32 fg = 0;
+	u32 bg = 0;
+	u32 fb_width = 0;
+	u32 fb_height = 0;;
+	char *layer_str;
+
+	vout_init();
+	fb_addr = env_strtoul("fb_addr", 16);
+#ifdef CONFIG_OSD_SCALE_ENABLE
+	fb_width = env_strtoul("fb_width", 10);
+	fb_height = env_strtoul("fb_height", 10);
+#endif
+	display_width = env_strtoul("display_width", 10);
+	display_height = env_strtoul("display_height", 10);
+	display_bpp = env_strtoul("display_bpp", 10);
+	color_index = env_strtoul("display_color_index", 10);
+	fg = env_strtoul("display_color_fg", 10);
+	bg = env_strtoul("display_color_bg", 10);
+	layer_str = getenv("display_layer");
+
+	/* fill in Graphic Device */
+	fb_gdev.frameAdrs = fb_addr;
+	fb_gdev.fb_width = fb_width;
+	fb_gdev.fb_height = fb_height;
+	fb_gdev.winSizeX = display_width;
+	fb_gdev.winSizeY = display_height;
+	fb_gdev.gdfBytesPP = display_bpp / 8;
+	fb_gdev.fg = fg;
+	fb_gdev.bg = bg;
+
+	if ((color_index < ARRAY_SIZE(default_color_format_array))
+	    && (default_color_format_array[color_index].color_index !=
+		COLOR_INDEX_NULL))
+		fb_gdev.gdfIndex = color_index;
+	else {
+		osd_loge("color_index %d invalid\n", color_index);
+		return NULL;
+	}
+
+	if (strcmp(layer_str, "osd0") == 0)
+		osd_layer_init(fb_gdev, OSD1);
+	else if (strcmp(layer_str, "osd1") == 0)
+		osd_layer_init(fb_gdev, OSD2);
+	else {
+		osd_loge("display_layer(%s) invalid\n", layer_str);
+		return NULL;
+	}
+
+	return (void *)&fb_gdev;
+}
+
+int video_display_bitmap(ulong bmp_image, int x, int y)
+{
+	vidinfo_t *info = NULL;
+#if defined CONFIG_AML_VOUT
+	info = vout_get_current_vinfo();
+#endif
+	ushort *cmap_base = NULL;
+	unsigned long byte_width;
+	ushort i, j;
+	uchar *fb;
+	bmp_image_t *bmp = (bmp_image_t *)bmp_image;
+	uchar *bmap;
+	ushort padded_line;
+	unsigned long width, height;
+#ifdef CONFIG_OSD_SCALE_ENABLE
+	unsigned long pheight = fb_gdev.fb_height;
+	unsigned long pwidth = fb_gdev.fb_width;
+#else
+	unsigned long pheight = info->vl_row;
+	unsigned long pwidth = info->vl_col;
+#endif
+	unsigned colors, bpix, bmp_bpix;
+	int lcd_line_length = (pwidth * NBITS(info->vl_bpix)) / 8;
+	char *layer_str = NULL;
+	int osd_index = -1;
+
+	layer_str = getenv("display_layer");
+	if (strcmp(layer_str, "osd0") == 0)
+		osd_index = 0;
+	else if (strcmp(layer_str, "osd1") == 0)
+		osd_index = 1;
+
+	if (!((bmp->header.signature[0] == 'B') &&
+	      (bmp->header.signature[1] == 'M'))) {
+		osd_loge("no valid bmp image at 0x%lx\n", bmp_image);
+		return 1;
+	}
+
+	width = le32_to_cpu(bmp->header.width);
+	height = le32_to_cpu(bmp->header.height);
+	bmp_bpix = le16_to_cpu(bmp->header.bit_count);
+	colors = 1 << bmp_bpix;
+
+	bpix = NBITS(info->vl_bpix);
+
+	if ((x == -1) && (y == -1)) {
+		if ((width > pwidth) || (height > pheight)) {
+			x = 0;
+			y = 0;
+		} else {
+			x = (pwidth - width) / 2;
+			y = (pheight - height) / 2;
+		}
+	}
+
+	if ((bpix != 1) && (bpix != 8) && (bpix != 16) && (bpix != 24) &&
+	    (bpix != 32)) {
+		osd_loge("%d bit/pixel mode, but BMP has %d bit/pixel\n",
+			 bpix, bmp_bpix);
+		return 1;
+	}
+
+	/* We support displaying 8bpp BMPs on 16bpp LCDs */
+	if (bpix != bmp_bpix && (bmp_bpix != 8 || bpix != 16)) {
+		osd_loge("%d bit/pixel mode, but BMP has %d bit/pixel\n",
+			 bpix,
+			 le16_to_cpu(bmp->header.bit_count));
+		return 1;
+	}
+
+	osd_logd("Display-bmp: %d x %d  with %d colors\n",
+		 (int)width, (int)height, (int)colors);
+
+	/*
+	 *  BMP format for Monochrome assumes that the state of a
+	 * pixel is described on a per Bit basis, not per Byte.
+	 *  So, in case of Monochrome BMP we should align widths
+	 * on a byte boundary and convert them from Bit to Byte
+	 * units.
+	 *  Probably, PXA250 and MPC823 process 1bpp BMP images in
+	 * their own ways, so make the converting to be MCC200
+	 * specific.
+	 */
+	padded_line = (width & 0x3) ? ((width & ~0x3) + 4) : (width);
+
+#ifdef CONFIG_SPLASH_SCREEN_ALIGN
+	if (x == BMP_ALIGN_CENTER)
+		x = max(0, (pwidth - width) / 2);
+	else if (x < 0)
+		x = max(0, pwidth - width + x + 1);
+
+	if (y == BMP_ALIGN_CENTER)
+		y = max(0, (info->vl_row - height) / 2);
+	else if (y < 0)
+		y = max(0, info->vl_row - height + y + 1);
+#endif /* CONFIG_SPLASH_SCREEN_ALIGN */
+
+	if ((x + width) > pwidth)
+		width = pwidth - x;
+	if ((y + height) > pheight)
+		height = pheight - y;
+
+	osd_enable_hw(osd_index, 1);
+
+	bmap = (uchar *)bmp + le32_to_cpu(bmp->header.data_offset);
+	fb   = (uchar *)(info->vd_base +
+			 (y + height - 1) * lcd_line_length + x * fb_gdev.gdfBytesPP);
+
+	osd_logd("fb=0x%p; bmap=0x%p, width=%ld, height= %ld, lcd_line_length=%d, padded_line=%d\n",
+		 fb, bmap, width, height, lcd_line_length, padded_line);
+	switch (bmp_bpix) {
+	case 8:
+		if (bpix != 16)
+			byte_width = width;
+		else
+			byte_width = width * 2;
+
+		for (i = 0; i < height; ++i) {
+			for (j = 0; j < width; j++) {
+				if (bpix != 16)
+					*(fb++) = *(bmap++);
+				else {
+					*(uint16_t *)fb = cmap_base[*(bmap++)];
+					fb += sizeof(uint16_t) / sizeof(*fb);
+				}
+			}
+			bmap += (width - padded_line);
+			fb   -= (byte_width + lcd_line_length);
+		}
+		break;
+	case 16:
+		for (i = 0; i < height; ++i) {
+			for (j = 0; j < width; j++) {
+
+				*(fb++) = *(bmap++);
+				*(fb++) = *(bmap++);
+			}
+			bmap += (padded_line - width) * 2;
+			fb   -= (width * 2 + lcd_line_length);
+		}
+		break;
+	case 24:
+		for (i = 0; i < height; ++i) {
+			for (j = 0; j < width; j++) {
+
+				*(fb++) = *(bmap++);
+				*(fb++) = *(bmap++);
+				*(fb++) = *(bmap++);
+			}
+			bmap += (padded_line - width);
+			fb   -= (width * 3 + lcd_line_length);
+		}
+		break;
+	case 32:
+		for (i = 0; i < height; ++i) {
+			for (j = 0; j < width; j++) {
+
+				*(fb++) = *(bmap++);
+				*(fb++) = *(bmap++);
+				*(fb++) = *(bmap++);
+				*(fb++) = *(bmap++);
+			}
+			bmap += (padded_line - width);
+			fb   -= (width * 4 + lcd_line_length);
+		}
+		break;
+	default:
+		osd_loge("error: gdev.bpp %d, but bmp.bpp %d\n", fb_gdev.gdfBytesPP, bmp_bpix);
+		return (-1);
+	}
+#if 0
+	flush_cache((unsigned long)info->vd_base,
+		    info->vl_col * info->vl_row * info->vl_bpix / 8);
+#else
+	flush_cache((unsigned long)info->vd_base,
+		    pheight * pwidth * info->vl_bpix / 8);
+
+#endif
+
+	return (0);
+}
+
+#ifdef CONFIG_OSD_SCALE_ENABLE
+int video_scale_bitmap(void)
+{
+	char *layer_str = NULL;
+	int osd_index = -1;
+	int axis[4] = {};
+
+	osd_logd2("video_scale_bitmap src w=%d, h=%d, dst w=%d, dst h=%d\n",
+		fb_gdev.fb_width, fb_gdev.fb_height, fb_gdev.winSizeX, fb_gdev.winSizeY);
+
+	layer_str = getenv("display_layer");
+	vout_get_current_axis(axis);
+	if (strcmp(layer_str, "osd0") == 0)
+		osd_index = 0;
+	else if (strcmp(layer_str, "osd1") == 0)
+		osd_index = 1;
+#ifdef CONFIG_OSD_SUPERSCALE_ENABLE
+	if ((fb_gdev.fb_width * 2 != fb_gdev.winSizeX) ||
+	    (fb_gdev.fb_height * 2 != fb_gdev.winSizeY)) {
+		osd_enable_hw(osd_index, 1);
+		return (-1);
+	}
+	osd_set_free_scale_mode_hw(osd_index, 2);
+#else
+	osd_set_free_scale_mode_hw(osd_index, 1);
+#endif
+	osd_set_free_scale_axis_hw(osd_index, 0, 0, fb_gdev.fb_width - 1,
+				   fb_gdev.fb_height - 1);
+	osd_set_window_axis_hw(osd_index, axis[0], axis[1], axis[0] + axis[2] - 1,
+			       axis[1] + axis[3] - 1);
+	osd_set_free_scale_enable_hw(osd_index, 0x10001);
+	osd_enable_hw(osd_index, 1);
+
+	return (1);
+}
+#endif
diff --git a/drivers/display/osd/osd_hw.c b/drivers/display/osd/osd_hw.c
new file mode 100644
index 0000000..3040bca
--- /dev/null
+++ b/drivers/display/osd/osd_hw.c
@@ -0,0 +1,2356 @@
+/*
+ * drivers/osd/osd_hw.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+/* System Headers */
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+
+/* Local Headers */
+#include <amlogic/vmode.h>
+#ifdef CONFIG_AML_CANVAS
+#include <amlogic/canvas.h>
+#endif
+#ifdef CONFIG_AML_VOUT
+#include <amlogic/vout.h>
+#endif
+
+/* Local Headers */
+#include "osd_canvas.h"
+#include "osd_reg.h"
+#include "osd_log.h"
+#include "osd_io.h"
+#include "osd_hw.h"
+#include "osd_hw_def.h"
+
+#include "cpu_version.h"
+#include "vpp.h"
+
+static bool vsync_hit;
+static bool osd_vf_need_update;
+
+unsigned int osd_log_level = 0;
+static unsigned int logo_loaded = 0;
+
+#ifdef CONFIG_AM_VIDEO
+static struct vframe_s vf;
+static struct vframe_provider_s osd_vf_prov;
+static unsigned char osd_vf_prov_init;
+#endif
+static int g_vf_visual_width;
+static int g_vf_width;
+static int g_vf_height;
+
+static int g_rotation_width;
+static int g_rotation_height;
+
+static int use_h_filter_mode = -1;
+static int use_v_filter_mode = -1;
+
+static unsigned int osd_h_filter_mode = 1;
+static unsigned int osd_v_filter_mode = 1;
+
+static unsigned int osd_filter_coefs_bicubic_sharp[] = {
+	0x01fa008c, 0x01fa0100, 0xff7f0200, 0xfe7f0300,
+	0xfd7e0500, 0xfc7e0600, 0xfb7d0800, 0xfb7c0900,
+	0xfa7b0b00, 0xfa7a0dff, 0xf9790fff, 0xf97711ff,
+	0xf87613ff, 0xf87416fe, 0xf87218fe, 0xf8701afe,
+	0xf76f1dfd, 0xf76d1ffd, 0xf76b21fd, 0xf76824fd,
+	0xf76627fc, 0xf76429fc, 0xf7612cfc, 0xf75f2ffb,
+	0xf75d31fb, 0xf75a34fb, 0xf75837fa, 0xf7553afa,
+	0xf8523cfa, 0xf8503ff9, 0xf84d42f9, 0xf84a45f9,
+	0xf84848f8
+};
+
+static unsigned int osd_filter_coefs_bicubic[] = { /* bicubic	coef0 */
+	0x00800000, 0x007f0100, 0xff7f0200, 0xfe7f0300, 0xfd7e0500, 0xfc7e0600,
+	0xfb7d0800, 0xfb7c0900, 0xfa7b0b00, 0xfa7a0dff, 0xf9790fff, 0xf97711ff,
+	0xf87613ff, 0xf87416fe, 0xf87218fe, 0xf8701afe, 0xf76f1dfd, 0xf76d1ffd,
+	0xf76b21fd, 0xf76824fd, 0xf76627fc, 0xf76429fc, 0xf7612cfc, 0xf75f2ffb,
+	0xf75d31fb, 0xf75a34fb, 0xf75837fa, 0xf7553afa, 0xf8523cfa, 0xf8503ff9,
+	0xf84d42f9, 0xf84a45f9, 0xf84848f8
+};
+
+static unsigned int osd_filter_coefs_bilinear[] = { /* 2 point bilinear	coef1 */
+	0x00800000, 0x007e0200, 0x007c0400, 0x007a0600, 0x00780800, 0x00760a00,
+	0x00740c00, 0x00720e00, 0x00701000, 0x006e1200, 0x006c1400, 0x006a1600,
+	0x00681800, 0x00661a00, 0x00641c00, 0x00621e00, 0x00602000, 0x005e2200,
+	0x005c2400, 0x005a2600, 0x00582800, 0x00562a00, 0x00542c00, 0x00522e00,
+	0x00503000, 0x004e3200, 0x004c3400, 0x004a3600, 0x00483800, 0x00463a00,
+	0x00443c00, 0x00423e00, 0x00404000
+};
+
+static unsigned int osd_filter_coefs_2point_binilear[] = {
+	/* 2 point bilinear, bank_length == 2	coef2 */
+	0x80000000, 0x7e020000, 0x7c040000, 0x7a060000, 0x78080000, 0x760a0000,
+	0x740c0000, 0x720e0000, 0x70100000, 0x6e120000, 0x6c140000, 0x6a160000,
+	0x68180000, 0x661a0000, 0x641c0000, 0x621e0000, 0x60200000, 0x5e220000,
+	0x5c240000, 0x5a260000, 0x58280000, 0x562a0000, 0x542c0000, 0x522e0000,
+	0x50300000, 0x4e320000, 0x4c340000, 0x4a360000, 0x48380000, 0x463a0000,
+	0x443c0000, 0x423e0000, 0x40400000
+};
+
+/* filt_triangle, point_num =3, filt_len =2.6, group_num = 64 */
+static unsigned int osd_filter_coefs_3point_triangle_sharp[] = {
+	0x40400000, 0x3e420000, 0x3d430000, 0x3b450000,
+	0x3a460000, 0x38480000, 0x37490000, 0x354b0000,
+	0x344c0000, 0x324e0000, 0x314f0000, 0x2f510000,
+	0x2e520000, 0x2c540000, 0x2b550000, 0x29570000,
+	0x28580000, 0x265a0000, 0x245c0000, 0x235d0000,
+	0x215f0000, 0x20600000, 0x1e620000, 0x1d620100,
+	0x1b620300, 0x19630400, 0x17630600, 0x15640700,
+	0x14640800, 0x12640a00, 0x11640b00, 0x0f650c00,
+	0x0d660d00
+};
+
+static unsigned int osd_filter_coefs_3point_triangle[] = {
+	0x40400000, 0x3f400100, 0x3d410200, 0x3c410300,
+	0x3a420400, 0x39420500, 0x37430600, 0x36430700,
+	0x35430800, 0x33450800, 0x32450900, 0x31450a00,
+	0x30450b00, 0x2e460c00, 0x2d460d00, 0x2c470d00,
+	0x2b470e00, 0x29480f00, 0x28481000, 0x27481100,
+	0x26491100, 0x25491200, 0x24491300, 0x234a1300,
+	0x224a1400, 0x214a1500, 0x204a1600, 0x1f4b1600,
+	0x1e4b1700, 0x1d4b1800, 0x1c4c1800, 0x1b4c1900,
+	0x1a4c1a00
+};
+
+static unsigned int osd_filter_coefs_4point_triangle[] = {
+	0x20402000, 0x20402000, 0x1f3f2101, 0x1f3f2101,
+	0x1e3e2202, 0x1e3e2202, 0x1d3d2303, 0x1d3d2303,
+	0x1c3c2404, 0x1c3c2404, 0x1b3b2505, 0x1b3b2505,
+	0x1a3a2606, 0x1a3a2606, 0x19392707, 0x19392707,
+	0x18382808, 0x18382808, 0x17372909, 0x17372909,
+	0x16362a0a, 0x16362a0a, 0x15352b0b, 0x15352b0b,
+	0x14342c0c, 0x14342c0c, 0x13332d0d, 0x13332d0d,
+	0x12322e0e, 0x12322e0e, 0x11312f0f, 0x11312f0f,
+	0x10303010
+};
+
+/* 4th order (cubic) b-spline */
+/* filt_cubic point_num =4, filt_len =4, group_num = 64 */
+static unsigned int vpp_filter_coefs_4point_bspline[] = {
+	0x15561500, 0x14561600, 0x13561700, 0x12561800,
+	0x11551a00, 0x11541b00, 0x10541c00, 0x0f541d00,
+	0x0f531e00, 0x0e531f00, 0x0d522100, 0x0c522200,
+	0x0b522300, 0x0b512400, 0x0a502600, 0x0a4f2700,
+	0x094e2900, 0x084e2a00, 0x084d2b00, 0x074c2c01,
+	0x074b2d01, 0x064a2f01, 0x06493001, 0x05483201,
+	0x05473301, 0x05463401, 0x04453601, 0x04433702,
+	0x04423802, 0x03413a02, 0x03403b02, 0x033f3c02,
+	0x033d3d03
+};
+
+/* filt_quadratic, point_num =3, filt_len =3, group_num = 64 */
+static unsigned int osd_filter_coefs_3point_bspline[] = {
+	0x40400000, 0x3e420000, 0x3c440000, 0x3a460000,
+	0x38480000, 0x364a0000, 0x344b0100, 0x334c0100,
+	0x314e0100, 0x304f0100, 0x2e500200, 0x2c520200,
+	0x2a540200, 0x29540300, 0x27560300, 0x26570300,
+	0x24580400, 0x23590400, 0x215a0500, 0x205b0500,
+	0x1e5c0600, 0x1d5c0700, 0x1c5d0700, 0x1a5e0800,
+	0x195e0900, 0x185e0a00, 0x175f0a00, 0x15600b00,
+	0x14600c00, 0x13600d00, 0x12600e00, 0x11600f00,
+	0x10601000
+};
+
+static unsigned int *filter_table[] = {
+	osd_filter_coefs_bicubic_sharp,
+	osd_filter_coefs_bicubic,
+	osd_filter_coefs_bilinear,
+	osd_filter_coefs_2point_binilear,
+	osd_filter_coefs_3point_triangle_sharp,
+	osd_filter_coefs_3point_triangle,
+	osd_filter_coefs_4point_triangle,
+	vpp_filter_coefs_4point_bspline,
+	osd_filter_coefs_3point_bspline
+};
+
+#define OSD_TYPE_TOP_FIELD 0
+#define OSD_TYPE_BOT_FIELD 1
+
+static void osd_vpu_power_on(void)
+{
+}
+
+static void osd_super_scale_mem_power_on(void)
+{
+}
+
+static void osd_super_scale_mem_power_off(void)
+{
+}
+
+void osd_set_log_level(int level)
+{
+	osd_log_level = level;
+}
+
+void osd_get_hw_para(struct hw_para_s **para)
+{
+	*para = &osd_hw;
+	return;
+}
+
+#ifdef CONFIG_AM_VIDEO
+static struct vframe_s *osd_vf_peek(void *arg)
+{
+	if (osd_vf_need_update && (vf.width > 0) && (vf.height > 0))
+		return &vf;
+	else
+		return NULL;
+}
+
+static struct vframe_s *osd_vf_get(void *arg)
+{
+	if (osd_vf_need_update) {
+		vf_ext_light_unreg_provider(&osd_vf_prov);
+		osd_vf_need_update = false;
+		return &vf;
+	}
+	return NULL;
+}
+
+#define PROVIDER_NAME   "osd"
+static const struct vframe_operations_s osd_vf_provider = {
+	.peek = osd_vf_peek,
+	.get  = osd_vf_get,
+	.put  = NULL,
+};
+
+#endif
+
+static inline void  osd_update_3d_mode(int enable_osd1, int enable_osd2)
+{
+	if (enable_osd1)
+		osd1_update_disp_3d_mode();
+	if (enable_osd2)
+		osd2_update_disp_3d_mode();
+}
+
+static inline void wait_vsync_wakeup(void)
+{
+	vsync_hit = true;
+}
+
+static inline void walk_through_update_list(void)
+{
+	u32  i, j;
+	for (i = 0; i < HW_OSD_COUNT; i++) {
+		j = 0;
+		while (osd_hw.updated[i] && j < 32) {
+			if (osd_hw.updated[i] & (1 << j)) {
+				osd_hw.reg[i][j].update_func();
+				remove_from_update_list(i, j);
+			}
+			j++;
+		}
+	}
+}
+
+static void osd_check_scan_mode(void)
+{
+#define	VOUT_ENCI	1
+#define	VOUT_ENCP	2
+#define	VOUT_ENCT	3
+	int vmode = -1;
+
+	osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
+#ifdef CONFIG_AML_VOUT
+	vmode = vout_get_current_vmode();
+#endif
+	switch (vmode) {
+	case VMODE_480I:
+	case VMODE_480CVBS:
+	case VMODE_576I:
+	case VMODE_576CVBS:
+	case VMODE_1080I:
+	case VMODE_1080I_50HZ:
+		osd_hw.scan_mode = SCAN_MODE_INTERLACE;
+		break;
+	default:
+		break;
+	}
+}
+
+static void vsync_isr(void)
+{
+	unsigned int odd_even;
+	unsigned int scan_line_number = 0;
+	unsigned int fb0_cfg_w0, fb1_cfg_w0;
+
+	osd_check_scan_mode();
+	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+		fb0_cfg_w0 = osd_reg_read(VIU_OSD1_BLK0_CFG_W0);
+		fb1_cfg_w0 = osd_reg_read(VIU_OSD2_BLK0_CFG_W0);
+		if (osd_reg_read(ENCP_VIDEO_MODE) & (1 << 12)) {
+			/* 1080I */
+			scan_line_number = ((osd_reg_read(ENCP_INFO_READ))
+					    & 0x1fff0000) >> 16;
+			if ((osd_hw.pandata[OSD1].y_start % 2) == 0) {
+				if (scan_line_number >= 562) {
+					/* bottom field, odd lines*/
+					odd_even = 1;
+				} else {
+					/* top field, even lines*/
+					odd_even = 0;
+				}
+			} else {
+				if (scan_line_number >= 562) {
+					/* top field, even lines*/
+					odd_even = 0;
+				} else {
+					/* bottom field, odd lines*/
+					odd_even = 1;
+				}
+			}
+		} else {
+			if ((osd_hw.pandata[OSD1].y_start % 2) == 0)
+				odd_even = osd_reg_read(ENCI_INFO_READ) & 1;
+			else
+				odd_even = !(osd_reg_read(ENCI_INFO_READ) & 1);
+		}
+		fb0_cfg_w0 &= ~1;
+		fb1_cfg_w0 &= ~1;
+		fb0_cfg_w0 |= odd_even;
+		fb1_cfg_w0 |= odd_even;
+		osd_reg_write(VIU_OSD1_BLK0_CFG_W0, fb0_cfg_w0);
+		osd_reg_write(VIU_OSD2_BLK0_CFG_W0, fb1_cfg_w0);
+	}
+	/* go through update list */
+	walk_through_update_list();
+	osd_update_3d_mode(osd_hw.mode_3d[OSD1].enable,
+			   osd_hw.mode_3d[OSD2].enable);
+
+	if (!vsync_hit)
+		wait_vsync_wakeup();
+}
+
+void osd_wait_vsync_hw(void)
+{
+	mdelay(16);
+	vsync_isr();
+	vsync_hit = false;
+}
+
+int osd_set_scan_mode(u32 index)
+{
+	u32 data32 = 0x0;
+	int vmode = -1;
+	int real_scan_mode = SCAN_MODE_INTERLACE;
+
+#ifdef CONFIG_AML_VOUT
+	vmode = vout_get_current_vmode();
+#endif
+	osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
+	osd_hw.scale_workaround = 0;
+	switch (vmode) {
+	case VMODE_480I:
+	case VMODE_480CVBS:
+	case VMODE_576I:
+	case VMODE_576CVBS:
+		if (osd_hw.free_scale_mode[index]) {
+			osd_hw.field_out_en = 1;
+			switch (osd_hw.free_scale_data[index].y_end) {
+			case 719:
+				osd_hw.bot_type = 2;
+				break;
+			case 1079:
+				osd_hw.bot_type = 3;
+				break;
+			default:
+				osd_hw.bot_type = 2;
+				break;
+			}
+		}
+		osd_hw.scan_mode = real_scan_mode = SCAN_MODE_INTERLACE;
+		break;
+	case VMODE_1080I:
+	case VMODE_1080I_50HZ:
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	case VMODE_1080I_59HZ:
+#endif
+		if (osd_hw.free_scale_mode[index]) {
+			osd_hw.field_out_en = 1;
+			switch (osd_hw.free_scale_data[index].y_end) {
+			case 719:
+				osd_hw.bot_type = 1;
+				break;
+			case 1079:
+				osd_hw.bot_type = 2;
+				break;
+			default:
+				osd_hw.bot_type = 1;
+				break;
+			}
+		}
+		osd_hw.scan_mode = real_scan_mode = SCAN_MODE_INTERLACE;
+		break;
+	case VMODE_4K2K_24HZ:
+	case VMODE_4K2K_25HZ:
+	case VMODE_4K2K_30HZ:
+	case VMODE_4K2K_SMPTE:
+		if (osd_hw.fb_for_4k2k) {
+			if (osd_hw.free_scale_enable[index])
+				osd_hw.scale_workaround = 1;
+		}
+		osd_hw.field_out_en = 0;
+		break;
+	default:
+		if (osd_hw.free_scale_mode[index])
+			osd_hw.field_out_en = 0;
+		break;
+	}
+	if (osd_hw.free_scale_enable[index])
+		osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
+	if (index == OSD2) {
+		if (real_scan_mode == SCAN_MODE_INTERLACE)
+			return 1;
+		data32 = (osd_reg_read(VIU_OSD2_BLK0_CFG_W0) & 3) >> 1;
+	} else
+		data32 = (osd_reg_read(VIU_OSD1_BLK0_CFG_W0) & 3) >> 1;
+	if (data32 == osd_hw.scan_mode)
+		return 1;
+	else
+		return 0;
+}
+
+void  osd_set_gbl_alpha_hw(u32 index, u32 gbl_alpha)
+{
+	if (osd_hw.gbl_alpha[index] != gbl_alpha) {
+		osd_hw.gbl_alpha[index] = gbl_alpha;
+		add_to_update_list(index, OSD_GBL_ALPHA);
+		osd_wait_vsync_hw();
+	}
+}
+
+u32 osd_get_gbl_alpha_hw(u32  index)
+{
+	return osd_hw.gbl_alpha[index];
+}
+
+void osd_set_color_key_hw(u32 index, u32 color_index, u32 colorkey)
+{
+	u8 r = 0, g = 0, b = 0, a = (colorkey & 0xff000000) >> 24;
+	u32 data32;
+	colorkey &= 0x00ffffff;
+	switch (color_index) {
+	case COLOR_INDEX_16_655:
+		r = (colorkey >> 10 & 0x3f) << 2;
+		g = (colorkey >> 5 & 0x1f) << 3;
+		b = (colorkey & 0x1f) << 3;
+		break;
+	case COLOR_INDEX_16_844:
+		r = colorkey >> 8 & 0xff;
+		g = (colorkey >> 4 & 0xf) << 4;
+		b = (colorkey & 0xf) << 4;
+		break;
+	case COLOR_INDEX_16_565:
+		r = (colorkey >> 11 & 0x1f) << 3;
+		g = (colorkey >> 5 & 0x3f) << 2;
+		b = (colorkey & 0x1f) << 3;
+		break;
+	case COLOR_INDEX_24_888_B:
+		b = colorkey >> 16 & 0xff;
+		g = colorkey >> 8 & 0xff;
+		r = colorkey & 0xff;
+		break;
+	case COLOR_INDEX_24_RGB:
+	case COLOR_INDEX_YUV_422:
+		r = colorkey >> 16 & 0xff;
+		g = colorkey >> 8 & 0xff;
+		b = colorkey & 0xff;
+		break;
+	}
+	data32 = r << 24 | g << 16 | b << 8 | a;
+	if (osd_hw.color_key[index] != data32) {
+		osd_hw.color_key[index] = data32;
+		osd_logd2("bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\n",
+			  color_index, r, g, b, a);
+		add_to_update_list(index, OSD_COLOR_KEY);
+		osd_wait_vsync_hw();
+	}
+	return;
+}
+void  osd_srckey_enable_hw(u32  index, u8 enable)
+{
+	if (enable != osd_hw.color_key_enable[index]) {
+		osd_hw.color_key_enable[index] = enable;
+		add_to_update_list(index, OSD_COLOR_KEY_ENABLE);
+		osd_wait_vsync_hw();
+	}
+}
+
+void osd_set_color_mode(u32 index, const struct color_bit_define_s *color)
+{
+	if (color != osd_hw.color_info[index]) {
+		osd_hw.color_info[index] = color;
+		add_to_update_list(index, OSD_COLOR_MODE);
+	}
+}
+
+void osd_update_disp_axis_hw(
+	u32 index,
+	u32 display_h_start,
+	u32 display_h_end,
+	u32 display_v_start,
+	u32 display_v_end,
+	u32 xoffset,
+	u32 yoffset,
+	u32 mode_change)
+{
+	struct pandata_s disp_data;
+	struct pandata_s pan_data;
+
+	if (is_meson_m8_cpu()) {
+		if (index == OSD2)
+			return;
+	}
+	if (NULL == osd_hw.color_info[index])
+		return;
+	disp_data.x_start = display_h_start;
+	disp_data.y_start = display_v_start;
+	disp_data.x_end = display_h_end;
+	disp_data.y_end = display_v_end;
+	pan_data.x_start = xoffset;
+	pan_data.x_end = xoffset + (display_h_end - display_h_start);
+	pan_data.y_start = yoffset;
+	pan_data.y_end = yoffset + (display_v_end - display_v_start);
+	/* if output mode change then reset pan ofFfset. */
+	memcpy(&osd_hw.pandata[index], &pan_data, sizeof(struct pandata_s));
+	memcpy(&osd_hw.dispdata[index], &disp_data, sizeof(struct pandata_s));
+	if (mode_change) /* modify pandata . */
+		add_to_update_list(index, OSD_COLOR_MODE);
+	osd_hw.reg[index][DISP_GEOMETRY].update_func();
+	osd_wait_vsync_hw();
+}
+
+void osd_setup_hw(u32 index,
+		  u32 xoffset,
+		  u32 yoffset,
+		  u32 xres,
+		  u32 yres,
+		  u32 xres_virtual,
+		  u32 yres_virtual,
+		  u32 disp_start_x,
+		  u32 disp_start_y,
+		  u32 disp_end_x,
+		  u32 disp_end_y,
+		  u32 fbmem,
+		  const struct color_bit_define_s *color)
+{
+	struct pandata_s disp_data;
+	struct pandata_s pan_data;
+	int update_color_mode = 0;
+	int update_geometry = 0;
+	u32 w = (color->bpp * xres_virtual + 7) >> 3;
+
+	pan_data.x_start = xoffset;
+	pan_data.y_start = yoffset;
+	disp_data.x_start = disp_start_x;
+	disp_data.y_start = disp_start_y;
+	if (osd_hw.free_scale_enable[OSD1] && index == OSD1) {
+		if (!(osd_hw.free_scale_mode[OSD1])) {
+			pan_data.x_end = xoffset + g_vf_visual_width;
+			pan_data.y_end = yoffset + g_vf_height;
+			disp_data.x_end = disp_start_x + g_vf_width;
+			disp_data.y_end = disp_start_y + g_vf_height;
+		} else {
+			pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
+			pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
+			disp_data.x_end = disp_end_x;
+			disp_data.y_end = disp_end_y;
+		}
+	} else {
+		pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
+		pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
+		if (likely(osd_hw.rotate[index].on_off
+			   && osd_hw.rotate[index].on_off > 0)) {
+			disp_data.x_end = disp_start_x + g_rotation_height;
+			disp_data.y_end = disp_start_y + g_rotation_width;
+		} else {
+			disp_data.x_end = disp_end_x;
+			disp_data.y_end = disp_end_y;
+		}
+	}
+	if (osd_hw.fb_gem[index].addr != fbmem
+	    || osd_hw.fb_gem[index].width != w
+	    ||  osd_hw.fb_gem[index].height != yres_virtual) {
+		osd_hw.fb_gem[index].addr = fbmem;
+		osd_hw.fb_gem[index].width = w;
+		osd_hw.fb_gem[index].height = yres_virtual;
+		osd_logd("osd[%d] canvas.idx =0x%x\n",
+			 index, osd_hw.fb_gem[index].canvas_idx);
+		osd_logd("osd[%d] canvas.addr=0x%x\n",
+			 index, osd_hw.fb_gem[index].addr);
+		osd_logd("osd[%d] canvas.width=%d\n",
+			 index, osd_hw.fb_gem[index].width);
+		osd_logd("osd[%d] canvas.height=%d\n",
+			 index, osd_hw.fb_gem[index].height);
+#ifdef CONFIG_AML_CANVAS
+		canvas_config(osd_hw.fb_gem[index].canvas_idx,
+			      osd_hw.fb_gem[index].addr,
+			      osd_hw.fb_gem[index].width,
+			      osd_hw.fb_gem[index].height,
+			      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+#endif
+	}
+	if (color != osd_hw.color_info[index]) {
+		update_color_mode = 1;
+		osd_hw.color_info[index] = color;
+	}
+	/* osd blank only control by /sys/class/graphcis/fbx/blank */
+#if 0
+	if (osd_hw.enable[index] == DISABLE) {
+		osd_hw.enable[index] = ENABLE;
+		add_to_update_list(index, OSD_ENABLE);
+	}
+#endif
+
+	if (memcmp(&pan_data, &osd_hw.pandata[index],
+		   sizeof(struct pandata_s)) != 0 ||
+	    memcmp(&disp_data, &osd_hw.dispdata[index],
+		   sizeof(struct pandata_s)) != 0) {
+		update_geometry = 1;
+		memcpy(&osd_hw.pandata[index], &pan_data,
+		       sizeof(struct pandata_s));
+		memcpy(&osd_hw.dispdata[index], &disp_data,
+		       sizeof(struct pandata_s));
+	}
+	if (update_color_mode)
+		add_to_update_list(index, OSD_COLOR_MODE);
+	if (update_geometry)
+		add_to_update_list(index, DISP_GEOMETRY);
+
+	osd_wait_vsync_hw();
+}
+
+void osd_setpal_hw(u32 index,
+		   unsigned regno,
+		   unsigned red,
+		   unsigned green,
+		   unsigned blue,
+		   unsigned transp
+		  )
+{
+	if (regno < 256) {
+		u32 pal;
+		pal = ((red   & 0xff) << 24) |
+		      ((green & 0xff) << 16) |
+		      ((blue  & 0xff) <<  8) |
+		      (transp & 0xff);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_COLOR_ADDR + REG_OFFSET * index,
+				     regno);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_COLOR + REG_OFFSET * index, pal);
+	}
+}
+
+void osd_get_order_hw(u32 index, u32 *order)
+{
+	*order = osd_hw.order & 0x3;
+}
+
+void osd_set_order_hw(u32 index, u32 order)
+{
+	if ((order != OSD_ORDER_01) && (order != OSD_ORDER_10))
+		return;
+	osd_hw.order = order;
+	add_to_update_list(index, OSD_CHANGE_ORDER);
+	osd_wait_vsync_hw();
+}
+
+/* vpu free scale mode */
+static void osd_set_free_scale_enable_mode0(u32 index, u32 enable)
+{
+	static struct pandata_s save_disp_data = {0, 0, 0, 0};
+#ifdef CONFIG_AM_VIDEO
+#ifdef CONFIG_POST_PROCESS_MANAGER
+	int mode_changed = 0;
+	if ((index == OSD1) && (osd_hw.free_scale_enable[index] != enable))
+		mode_changed = 1;
+#endif
+#endif
+	osd_logi("osd%d free scale %s\n",
+		 index, enable ? "ENABLE" : "DISABLE");
+	enable = (enable & 0xffff ? 1 : 0);
+	osd_hw.free_scale_enable[index] = enable;
+	if (index == OSD1) {
+		if (enable) {
+			osd_vf_need_update = true;
+#ifdef CONFIG_AM_VIDEO
+			if ((osd_hw.free_scale_data[OSD1].x_end > 0)
+			    && (osd_hw.free_scale_data[OSD1].x_end > 0)) {
+				vf.width = osd_hw.free_scale_data[index].x_end -
+					   osd_hw.free_scale_data[index].x_start + 1;
+				vf.height =
+					osd_hw.free_scale_data[index].y_end -
+					osd_hw.free_scale_data[index].y_start + 1;
+			} else {
+				vf.width = osd_hw.free_scale_width[OSD1];
+				vf.height = osd_hw.free_scale_height[OSD1];
+			}
+			vf.type = (VIDTYPE_NO_VIDEO_ENABLE | VIDTYPE_PROGRESSIVE
+				   | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE);
+			vf.ratio_control = DISP_RATIO_FORCECONFIG
+					   | DISP_RATIO_NO_KEEPRATIO;
+			if (osd_vf_prov_init == 0) {
+				vf_provider_init(&osd_vf_prov,
+						 PROVIDER_NAME, &osd_vf_provider, NULL);
+				osd_vf_prov_init = 1;
+			}
+			vf_reg_provider(&osd_vf_prov);
+			memcpy(&save_disp_data, &osd_hw.dispdata[OSD1],
+			       sizeof(struct pandata_s));
+			g_vf_visual_width =
+				vf.width - 1 - osd_hw.dispdata[OSD1].x_start;
+			g_vf_width = vf.width - 1;
+			g_vf_height = vf.height - 1;
+			osd_hw.dispdata[OSD1].x_end =
+				osd_hw.dispdata[OSD1].x_start + vf.width - 1;
+			osd_hw.dispdata[OSD1].y_end =
+				osd_hw.dispdata[OSD1].y_start + vf.height - 1;
+#endif
+			osd_set_scan_mode(index);
+			osd_hw.reg[index][DISP_GEOMETRY].update_func();
+			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+			osd_hw.reg[index][OSD_ENABLE].update_func();
+		} else {
+			osd_vf_need_update = false;
+			osd_set_scan_mode(index);
+			if (save_disp_data.x_end <= save_disp_data.x_start ||
+			    save_disp_data.y_end <= save_disp_data.y_start)
+				return;
+			memcpy(&osd_hw.dispdata[OSD1], &save_disp_data,
+			       sizeof(struct pandata_s));
+			osd_hw.reg[index][DISP_GEOMETRY].update_func();
+			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+			osd_hw.reg[index][OSD_ENABLE].update_func();
+#ifdef CONFIG_AM_VIDEO
+			vf_unreg_provider(&osd_vf_prov);
+#endif
+		}
+	} else {
+		osd_hw.reg[index][DISP_GEOMETRY].update_func();
+		osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+		osd_hw.reg[index][OSD_ENABLE].update_func();
+	}
+	osd_wait_vsync_hw();
+#ifdef CONFIG_AM_VIDEO
+#ifdef CONFIG_POST_PROCESS_MANAGER
+	if (mode_changed) {
+		/* extern void vf_ppmgr_reset(int type); */
+		vf_ppmgr_reset(1);
+	}
+#endif
+#endif
+}
+
+/* osd free scale mode */
+static void osd_set_free_scale_enable_mode1(u32 index, u32 enable)
+{
+	unsigned int h_enable = 0;
+	unsigned int v_enable = 0;
+	int ret = 0;
+
+	h_enable = (enable & 0xffff0000 ? 1 : 0);
+	v_enable = (enable & 0xffff ? 1 : 0);
+	osd_hw.free_scale[index].h_enable = h_enable;
+	osd_hw.free_scale[index].v_enable = v_enable;
+	osd_hw.free_scale_enable[index] = enable;
+	if (osd_hw.free_scale_enable[index]) {
+		if ((osd_hw.free_scale_data[index].x_end > 0) && h_enable) {
+			osd_hw.free_scale_width[index] =
+				osd_hw.free_scale_data[index].x_end -
+				osd_hw.free_scale_data[index].x_start + 1;
+		}
+		if ((osd_hw.free_scale_data[index].y_end > 0) && v_enable) {
+			osd_hw.free_scale_height[index] =
+				osd_hw.free_scale_data[index].y_end -
+				osd_hw.free_scale_data[index].y_start + 1;
+		}
+		ret = osd_set_scan_mode(index);
+		if (ret)
+			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+		osd_hw.reg[index][OSD_FREESCALE_COEF].update_func();
+		osd_hw.reg[index][DISP_GEOMETRY].update_func();
+		osd_hw.reg[index][DISP_FREESCALE_ENABLE].update_func();
+		osd_hw.reg[index][OSD_ENABLE].update_func();
+	} else {
+		ret = osd_set_scan_mode(index);
+		if (ret)
+			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+		osd_hw.reg[index][DISP_GEOMETRY].update_func();
+		osd_hw.reg[index][DISP_FREESCALE_ENABLE].update_func();
+		osd_hw.reg[index][OSD_ENABLE].update_func();
+	}
+	osd_wait_vsync_hw();
+}
+
+void osd_set_free_scale_enable_hw(u32 index, u32 enable)
+{
+	if (osd_hw.free_scale_mode[index])
+		osd_set_free_scale_enable_mode1(index, enable);
+	else
+		osd_set_free_scale_enable_mode0(index, enable);
+}
+
+void osd_get_free_scale_enable_hw(u32 index, u32 *free_scale_enable)
+{
+	*free_scale_enable = osd_hw.free_scale_enable[index];
+}
+
+void osd_set_free_scale_mode_hw(u32 index, u32 freescale_mode)
+{
+	osd_hw.free_scale_mode[index] = freescale_mode;
+}
+
+void osd_get_free_scale_mode_hw(u32 index, u32 *freescale_mode)
+{
+	*freescale_mode = osd_hw.free_scale_mode[index];
+}
+
+void osd_set_4k2k_fb_mode_hw(u32 fb_for_4k2k)
+{
+	osd_hw.fb_for_4k2k = fb_for_4k2k;
+}
+
+void osd_set_free_scale_width_hw(u32 index, u32 width)
+{
+	osd_hw.free_scale_width[index] = width;
+	if (osd_hw.free_scale_enable[index] &&
+	    (!osd_hw.free_scale_mode[index])) {
+		osd_vf_need_update = true;
+#ifdef CONFIG_AM_VIDEO
+		vf.width = osd_hw.free_scale_width[index];
+#endif
+	}
+}
+
+void osd_get_free_scale_width_hw(u32 index, u32 *free_scale_width)
+{
+	*free_scale_width = osd_hw.free_scale_width[index];
+}
+
+void osd_set_free_scale_height_hw(u32 index, u32 height)
+{
+	osd_hw.free_scale_height[index] = height;
+	if (osd_hw.free_scale_enable[index] &&
+	    (!osd_hw.free_scale_mode[index])) {
+		osd_vf_need_update = true;
+#ifdef CONFIG_AM_VIDEO
+		vf.height = osd_hw.free_scale_height[index];
+#endif
+	}
+}
+
+void osd_get_free_scale_height_hw(u32 index, u32 *free_scale_height)
+{
+	*free_scale_height = osd_hw.free_scale_height[index];
+}
+
+void osd_get_free_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1)
+{
+	*x0 = osd_hw.free_scale_data[index].x_start;
+	*y0 = osd_hw.free_scale_data[index].y_start;
+	*x1 = osd_hw.free_scale_data[index].x_end;
+	*y1 = osd_hw.free_scale_data[index].y_end;
+}
+
+void osd_set_free_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
+{
+	osd_hw.free_scale_data[index].x_start = x0;
+	osd_hw.free_scale_data[index].y_start = y0;
+	osd_hw.free_scale_data[index].x_end = x1;
+	osd_hw.free_scale_data[index].y_end = y1;
+}
+
+void osd_get_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1)
+{
+	*x0 = osd_hw.scaledata[index].x_start;
+	*x1 = osd_hw.scaledata[index].x_end;
+	*y0 = osd_hw.scaledata[index].y_start;
+	*y1 = osd_hw.scaledata[index].y_end;
+}
+
+void osd_set_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
+{
+	osd_hw.scaledata[index].x_start = x0;
+	osd_hw.scaledata[index].x_end = x1;
+	osd_hw.scaledata[index].y_start = y0;
+	osd_hw.scaledata[index].y_end = y1;
+}
+
+void osd_get_window_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1)
+{
+	int vmode = -1;
+
+#ifdef CONFIG_AML_VOUT
+	vmode = vout_get_current_vmode();
+#endif
+	switch (vmode) {
+	case VMODE_480I:
+	case VMODE_480CVBS:
+	case VMODE_576I:
+	case VMODE_576CVBS:
+	case VMODE_1080I:
+	case VMODE_1080I_50HZ:
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	case VMODE_1080I_59HZ:
+#endif
+		*y0 = osd_hw.free_dst_data[index].y_start * 2;
+		*y1 = osd_hw.free_dst_data[index].y_end * 2;
+		break;
+	default:
+		*y0 = osd_hw.free_dst_data[index].y_start;
+		*y1 = osd_hw.free_dst_data[index].y_end;
+		break;
+	}
+	*x0 = osd_hw.free_dst_data[index].x_start;
+	*x1 = osd_hw.free_dst_data[index].x_end;
+}
+
+void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
+{
+	int vmode = -1;
+#ifdef CONFIG_AML_VOUT
+	vmode = vout_get_current_vmode();
+#endif
+	switch (vmode) {
+	case VMODE_480I:
+	case VMODE_480CVBS:
+	case VMODE_576I:
+	case VMODE_576CVBS:
+	case VMODE_1080I:
+	case VMODE_1080I_50HZ:
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	case VMODE_1080I_59HZ:
+#endif
+		osd_hw.free_dst_data[index].y_start = y0 / 2;
+		osd_hw.free_dst_data[index].y_end = y1 / 2;
+		break;
+	default:
+		osd_hw.free_dst_data[index].y_start = y0;
+		osd_hw.free_dst_data[index].y_end = y1;
+		break;
+	}
+	osd_hw.free_dst_data[index].x_start = x0;
+	osd_hw.free_dst_data[index].x_end = x1;
+#if defined(CONFIG_FB_OSD2_CURSOR)
+	osd_hw.cursor_dispdata[index].x_start = x0;
+	osd_hw.cursor_dispdata[index].x_end = x1;
+	osd_hw.cursor_dispdata[index].y_start = y0;
+	osd_hw.cursor_dispdata[index].y_end = y1;
+#endif
+}
+
+void osd_get_block_windows_hw(u32 index, u32 *windows)
+{
+	memcpy(windows, osd_hw.block_windows[index],
+	       sizeof(osd_hw.block_windows[index]));
+}
+
+void osd_set_block_windows_hw(u32 index, u32 *windows)
+{
+	memcpy(osd_hw.block_windows[index], windows,
+	       sizeof(osd_hw.block_windows[index]));
+	add_to_update_list(index, DISP_GEOMETRY);
+	osd_wait_vsync_hw();
+}
+
+void osd_get_block_mode_hw(u32 index, u32 *mode)
+{
+	*mode = osd_hw.block_mode[index];
+}
+
+void osd_set_block_mode_hw(u32 index, u32 mode)
+{
+	osd_hw.block_mode[index] = mode;
+	add_to_update_list(index, DISP_GEOMETRY);
+	osd_wait_vsync_hw();
+}
+
+void osd_enable_3d_mode_hw(u32 index, u32 enable)
+{
+	osd_hw.mode_3d[index].enable = enable;
+	if (enable) {
+		/* when disable 3d mode ,we should return to stardard state. */
+		osd_hw.mode_3d[index].left_right = OSD_LEFT;
+		osd_hw.mode_3d[index].l_start = osd_hw.pandata[index].x_start;
+		osd_hw.mode_3d[index].l_end = (osd_hw.pandata[index].x_end +
+					       osd_hw.pandata[index].x_start) >> 1;
+		osd_hw.mode_3d[index].r_start = osd_hw.mode_3d[index].l_end + 1;
+		osd_hw.mode_3d[index].r_end = osd_hw.pandata[index].x_end;
+		osd_hw.mode_3d[index].origin_scale.h_enable =
+			osd_hw.scale[index].h_enable;
+		osd_hw.mode_3d[index].origin_scale.v_enable =
+			osd_hw.scale[index].v_enable;
+		osd_set_2x_scale_hw(index, 1, 0);
+	} else {
+		osd_set_2x_scale_hw(index,
+				    osd_hw.mode_3d[index].origin_scale.h_enable,
+				    osd_hw.mode_3d[index].origin_scale.v_enable);
+	}
+}
+
+void osd_enable_hw(u32 index, u32 enable)
+{
+	osd_logd("osd[%d] enable: %d\n", index, enable);
+
+	osd_hw.enable[index] = enable;
+	add_to_update_list(index, OSD_ENABLE);
+	osd_wait_vsync_hw();
+}
+
+void osd_set_2x_scale_hw(u32 index, u16 h_scale_enable, u16 v_scale_enable)
+{
+	osd_logi("osd[%d] set scale, h_scale: %s, v_scale: %s\n",
+		 index, h_scale_enable ? "ENABLE" : "DISABLE",
+		 v_scale_enable ? "ENABLE" : "DISABLE");
+	osd_logi("osd[%d].scaledata: %d %d %d %d\n",
+		 index,
+		 osd_hw.scaledata[index].x_start,
+		 osd_hw.scaledata[index].x_end,
+		 osd_hw.scaledata[index].y_start,
+		 osd_hw.scaledata[index].y_end);
+	osd_logi("osd[%d].pandata: %d %d %d %d\n",
+		 index,
+		 osd_hw.pandata[index].x_start,
+		 osd_hw.pandata[index].x_end,
+		 osd_hw.pandata[index].y_start,
+		 osd_hw.pandata[index].y_end);
+	osd_hw.scale[index].h_enable = h_scale_enable;
+	osd_hw.scale[index].v_enable = v_scale_enable;
+	osd_hw.reg[index][DISP_SCALE_ENABLE].update_func();
+	osd_hw.reg[index][DISP_GEOMETRY].update_func();
+	osd_wait_vsync_hw();
+}
+
+void osd_set_rotate_angle_hw(u32 index, u32 angle)
+{
+	osd_hw.rotate[index].angle = angle;
+	add_to_update_list(index, DISP_OSD_ROTATE);
+	osd_wait_vsync_hw();
+}
+
+void osd_get_rotate_angle_hw(u32 index, u32 *angle)
+{
+	*angle = osd_hw.rotate[index].angle;
+}
+void osd_set_rotate_on_hw(u32 index, u32 on_off)
+{
+	osd_hw.rotate[index].on_off = on_off;
+	if (on_off) {
+		g_rotation_width = osd_hw.rotation_pandata[index].x_end -
+				   osd_hw.rotation_pandata[index].x_start;
+		g_rotation_height = osd_hw.rotation_pandata[index].y_end -
+				    osd_hw.rotation_pandata[index].y_start;
+		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start +
+					       g_rotation_height;
+		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start +
+					       g_rotation_width;
+	} else {
+		if (is_meson_m8_cpu()) {
+			osd_reg_set_mask(VPU_SW_RESET, 1 << 8);
+			osd_reg_clr_mask(VPU_SW_RESET, 1 << 8);
+		}
+		if (index == OSD1) {
+			if (is_meson_m8_cpu()) {
+				osd_reg_set_mask(VIU_SW_RESET, 1 << 0);
+				osd_reg_clr_mask(VIU_SW_RESET, 1 << 0);
+			}
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_FIFO_CTRL_STAT,
+						   1 << 0);
+		} else {
+			osd_reg_set_mask(VIU_SW_RESET, 1 << 1);
+			osd_reg_clr_mask(VIU_SW_RESET, 1 << 1);
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_FIFO_CTRL_STAT,
+						   1 << 0);
+		}
+	}
+	osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+	osd_hw.reg[index][DISP_GEOMETRY].update_func();
+	osd_hw.reg[index][DISP_OSD_ROTATE].update_func();
+	osd_wait_vsync_hw();
+}
+
+void osd_get_rotate_on_hw(u32 index, u32 *on_off)
+{
+	*on_off = osd_hw.rotate[index].on_off;
+}
+
+void osd_get_update_state_hw(u32 index, u32 *up_free)
+{
+	if (osd_vf_need_update)
+		*up_free = 1;
+	else
+		*up_free = 0;
+}
+
+void osd_set_update_state_hw(u32 index, u32 up_free)
+{
+	if (up_free > 0)
+		osd_vf_need_update = true;
+	else
+		osd_vf_need_update = false;
+}
+
+void osd_set_reverse_hw(u32 index, u32 reverse)
+{
+	osd_hw.osd_reverse[index] = reverse;
+	add_to_update_list(index, DISP_OSD_REVERSE);
+	osd_wait_vsync_hw();
+}
+
+void osd_get_reverse_hw(u32 index, u32 *reverse)
+{
+	*reverse = osd_hw.osd_reverse[index];
+}
+
+void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32 x_end,
+			    s32 y_end)
+{
+	osd_hw.rotation_pandata[index].x_start = x_start;
+	osd_hw.rotation_pandata[index].y_start = y_start;
+	osd_hw.rotation_pandata[index].x_end = x_end;
+	osd_hw.rotation_pandata[index].y_end = y_end;
+	if (osd_hw.rotate[index].on_off && osd_hw.rotate[index].angle > 0) {
+		g_rotation_width = osd_hw.rotation_pandata[index].x_end -
+				   osd_hw.rotation_pandata[index].x_start;
+		g_rotation_height = osd_hw.rotation_pandata[index].y_end -
+				    osd_hw.rotation_pandata[index].y_start;
+		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start +
+					       g_rotation_height;
+		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start +
+					       g_rotation_width;
+		osd_hw.reg[index][DISP_GEOMETRY].update_func();
+		osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+	}
+}
+
+void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_end,
+			    s32 *y_end)
+{
+	*x_start = osd_hw.rotation_pandata[index].x_start;
+	*y_start = osd_hw.rotation_pandata[index].y_start;
+	*x_end = osd_hw.rotation_pandata[index].x_end;
+	*y_end = osd_hw.rotation_pandata[index].y_end;
+}
+
+void osd_pan_display_hw(u32 index, unsigned int xoffset, unsigned int yoffset)
+{
+	long diff_x, diff_y;
+#if defined(CONFIG_FB_OSD2_CURSOR)
+	if (index >= 1)
+#else
+	if (index >= 2)
+#endif
+		return;
+	if (xoffset != osd_hw.pandata[index].x_start
+	    || yoffset != osd_hw.pandata[index].y_start) {
+		diff_x = xoffset - osd_hw.pandata[index].x_start;
+		diff_y = yoffset - osd_hw.pandata[index].y_start;
+		osd_hw.pandata[index].x_start += diff_x;
+		osd_hw.pandata[index].x_end   += diff_x;
+		osd_hw.pandata[index].y_start += diff_y;
+		osd_hw.pandata[index].y_end   += diff_y;
+		add_to_update_list(index, DISP_GEOMETRY);
+		osd_wait_vsync_hw();
+	}
+#ifdef CONFIG_AM_FB_EXT
+	osd_ext_clone_pan(index);
+#endif
+	osd_logd2("offset[%d-%d]x[%d-%d]y[%d-%d]\n",
+		  xoffset, yoffset,
+		  osd_hw.pandata[index].x_start,
+		  osd_hw.pandata[index].x_end,
+		  osd_hw.pandata[index].y_start,
+		  osd_hw.pandata[index].y_end);
+}
+
+static  void  osd1_update_disp_scale_enable(void)
+{
+	if (osd_hw.scale[OSD1].h_enable)
+		VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 12);
+	else
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 12);
+	if (osd_hw.scan_mode != SCAN_MODE_INTERLACE) {
+		if (osd_hw.scale[OSD1].v_enable)
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0,
+						   1 << 14);
+		else
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0,
+						   1 << 14);
+	}
+}
+
+static  void  osd2_update_disp_scale_enable(void)
+{
+	if (osd_hw.scale[OSD2].h_enable) {
+#if defined(CONFIG_FB_OSD2_CURSOR)
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 12);
+#else
+		VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 12);
+#endif
+	} else
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 12);
+	if (osd_hw.scan_mode != SCAN_MODE_INTERLACE) {
+		if (osd_hw.scale[OSD2].v_enable) {
+#if defined(CONFIG_FB_OSD2_CURSOR)
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0,
+						   1 << 14);
+#else
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0,
+						   1 << 14);
+#endif
+		} else
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0,
+						   1 << 14);
+	}
+}
+
+static void osd_super_scale_enable(u32 index)
+{
+	u32 data32 = 0x0;
+
+	osd_super_scale_mem_power_on();
+	/* enable osd scaler path */
+	if (index == OSD1)
+		data32 = 8;
+	else {
+		data32 = 1;       /* select osd2 input */
+		data32 |= 1 << 3; /* enable osd scaler path */
+	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, data32);
+	/* enable osd super scaler */
+	data32 = (1 << 0)
+		 | (1 << 1)
+		 | (1 << 2);
+	VSYNCOSD_WR_MPEG_REG(OSDSR_CTRL_MODE, data32);
+	/* config osd super scaler setting */
+	VSYNCOSD_WR_MPEG_REG(OSDSR_UK_GRAD2DDIAG_LIMIT, 0xffffff);
+	VSYNCOSD_WR_MPEG_REG(OSDSR_UK_GRAD2DADJA_LIMIT, 0xffffff);
+	VSYNCOSD_WR_MPEG_REG(OSDSR_UK_BST_GAIN, 0x7a7a3a50);
+	/* config osd super scaler input size */
+	data32 = (osd_hw.free_scale_height[index] & 0x1fff)
+		 | (osd_hw.free_scale_width[index] & 0x1fff) << 16;
+	VSYNCOSD_WR_MPEG_REG(OSDSR_HV_SIZEIN, data32);
+	/* config osd super scaler output size */
+	data32 = ((osd_hw.free_dst_data[index].x_end & 0xfff) |
+		  (osd_hw.free_dst_data[index].x_start & 0xfff) << 16);
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_H_START_END, data32);
+	data32 = ((osd_hw.free_dst_data[index].y_end & 0xfff) |
+		  (osd_hw.free_dst_data[index].y_start & 0xfff) << 16);
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_V_START_END, data32);
+}
+
+static void osd_super_scale_disable(void)
+{
+	/* disable osd scaler path */
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0);
+	/* disable osd super scaler */
+	VSYNCOSD_WR_MPEG_REG(OSDSR_HV_SIZEIN, 0);
+	VSYNCOSD_WR_MPEG_REG(OSDSR_CTRL_MODE, 0);
+	osd_super_scale_mem_power_off();
+}
+
+static void osd1_update_disp_freescale_enable(void)
+{
+	int hf_phase_step, vf_phase_step;
+	int src_w, src_h, dst_w, dst_h;
+	int bot_ini_phase;
+	int vsc_ini_rcv_num, vsc_ini_rpt_p0_num;
+	int vsc_bot_rcv_num = 0, vsc_bot_rpt_p0_num = 0;
+	int hsc_ini_rcv_num, hsc_ini_rpt_p0_num;
+	int hf_bank_len = 4;
+	int vf_bank_len = 0;
+	u32 data32 = 0x0;
+
+	if (osd_hw.scale_workaround)
+		vf_bank_len = 2;
+	else
+		vf_bank_len = 4;
+	if (osd_hw.bot_type == 1) {
+		vsc_bot_rcv_num = 4;
+		vsc_bot_rpt_p0_num = 1;
+	} else if (osd_hw.bot_type == 2) {
+		vsc_bot_rcv_num = 6;
+		vsc_bot_rpt_p0_num = 2;
+	} else if (osd_hw.bot_type == 3) {
+		vsc_bot_rcv_num = 8;
+		vsc_bot_rpt_p0_num = 3;
+	}
+	hsc_ini_rcv_num = hf_bank_len;
+	vsc_ini_rcv_num = vf_bank_len;
+	hsc_ini_rpt_p0_num =
+		(hf_bank_len / 2 - 1) > 0 ? (hf_bank_len / 2 - 1) : 0;
+	vsc_ini_rpt_p0_num =
+		(vf_bank_len / 2 - 1) > 0 ? (vf_bank_len / 2 - 1) : 0;
+	src_w = osd_hw.free_scale_width[OSD1];
+	src_h = osd_hw.free_scale_height[OSD1];
+	dst_w = osd_hw.free_dst_data[OSD1].x_end -
+		osd_hw.free_dst_data[OSD1].x_start + 1;
+	dst_h = osd_hw.free_dst_data[OSD1].y_end -
+		osd_hw.free_dst_data[OSD1].y_start + 1;
+	if (is_meson_g9tv_cpu()) {
+		/* super scaler mode */
+		if (osd_hw.free_scale_mode[OSD1] & 0x2) {
+			if (osd_hw.free_scale_enable[OSD1])
+				osd_super_scale_enable(OSD1);
+			else
+				osd_super_scale_disable();
+			remove_from_update_list(OSD1, DISP_FREESCALE_ENABLE);
+			return;
+		}
+	}
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD1]) {
+		/* enable osd scaler */
+		if (osd_hw.free_scale_mode[OSD1] & 0x1) {
+			data32 |= 1 << 2; /* enable osd scaler */
+			data32 |= 1 << 3; /* enable osd scaler path */
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, data32);
+		}
+	} else {
+		/* disable osd scaler path */
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0);
+	}
+	hf_phase_step = (src_w << 18) / dst_w;
+	hf_phase_step = (hf_phase_step << 6);
+	vf_phase_step = (src_h << 20) / dst_h;
+	if (osd_hw.field_out_en)   /* interlace output */
+		bot_ini_phase = ((vf_phase_step / 2) >> 4);
+	else
+		bot_ini_phase = 0;
+	vf_phase_step = (vf_phase_step << 4);
+	/* config osd scaler in/out hv size */
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD1]) {
+		data32 = (((src_h - 1) & 0x1fff)
+			  | ((src_w - 1) & 0x1fff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCI_WH_M1, data32);
+		data32 = ((osd_hw.free_dst_data[OSD1].x_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD1].x_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_H_START_END, data32);
+		data32 = ((osd_hw.free_dst_data[OSD1].y_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD1].y_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_V_START_END, data32);
+	}
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD1].v_enable) {
+		data32 |= (vf_bank_len & 0x7)
+			  | ((vsc_ini_rcv_num & 0xf) << 3)
+			  | ((vsc_ini_rpt_p0_num & 0x3) << 8);
+		if (osd_hw.field_out_en)
+			data32 |= ((vsc_bot_rcv_num & 0xf) << 11)
+				  | ((vsc_bot_rpt_p0_num & 0x3) << 16)
+				  | (1 << 23);
+		if (osd_hw.scale_workaround)
+			data32 |= 1 << 21;
+		data32 |= 1 << 24;
+	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_CTRL0, data32);
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD1].h_enable) {
+		data32 |= (hf_bank_len & 0x7)
+			  | ((hsc_ini_rcv_num & 0xf) << 3)
+			  | ((hsc_ini_rpt_p0_num & 0x3) << 8);
+		data32 |= 1 << 22;
+	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_HSC_CTRL0, data32);
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD1]) {
+		data32 |= (bot_ini_phase & 0xffff) << 16;
+		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_PHASE_STEP,
+					  hf_phase_step, 0, 28);
+		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_INI_PHASE, 0, 0, 16);
+		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_PHASE_STEP,
+					  vf_phase_step, 0, 28);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_INI_PHASE, data32);
+	}
+	remove_from_update_list(OSD1, DISP_FREESCALE_ENABLE);
+}
+
+static void osd1_update_coef(void)
+{
+	int i;
+	bool need_update_coef = false;
+	int hf_coef_wren = 1;
+	int vf_coef_wren = 1;
+	unsigned int *hf_coef, *vf_coef;
+	if (osd_hw.scale_workaround) {
+		if (use_v_filter_mode != 3) {
+			use_v_filter_mode = 3;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
+	} else {
+		if (use_v_filter_mode != osd_v_filter_mode) {
+			use_v_filter_mode = osd_v_filter_mode;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
+	}
+	if (need_update_coef) {
+		vf_coef = filter_table[use_v_filter_mode];
+		if (vf_coef_wren) {
+			osd_reg_set_bits(VPP_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
+			for (i = 0; i < 33; i++)
+				osd_reg_write(VPP_OSD_SCALE_COEF, vf_coef[i]);
+		}
+	}
+	need_update_coef = false;
+	if (use_h_filter_mode != osd_h_filter_mode) {
+		use_h_filter_mode = osd_h_filter_mode;
+		need_update_coef = true;
+	}
+	hf_coef = filter_table[use_h_filter_mode];
+	if (need_update_coef) {
+		if (hf_coef_wren) {
+			osd_reg_set_bits(VPP_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
+			for (i = 0; i < 33; i++)
+				osd_reg_write(VPP_OSD_SCALE_COEF, hf_coef[i]);
+		}
+	}
+	remove_from_update_list(OSD1, OSD_FREESCALE_COEF);
+}
+
+static void osd2_update_disp_freescale_enable(void)
+{
+	int hf_phase_step, vf_phase_step;
+	int src_w, src_h, dst_w, dst_h;
+	int bot_ini_phase;
+	int vsc_ini_rcv_num, vsc_ini_rpt_p0_num;
+	int vsc_bot_rcv_num = 6, vsc_bot_rpt_p0_num = 2;
+	int hsc_ini_rcv_num, hsc_ini_rpt_p0_num;
+	int hf_bank_len = 4;
+	int vf_bank_len = 4;
+	u32 data32 = 0x0;
+	if (osd_hw.scale_workaround)
+		vf_bank_len = 2;
+	hsc_ini_rcv_num = hf_bank_len;
+	vsc_ini_rcv_num = vf_bank_len;
+	hsc_ini_rpt_p0_num =
+		(hf_bank_len / 2 - 1) > 0 ? (hf_bank_len / 2 - 1) : 0;
+	vsc_ini_rpt_p0_num =
+		(vf_bank_len / 2 - 1) > 0 ? (vf_bank_len / 2 - 1) : 0;
+	src_w = osd_hw.free_scale_width[OSD2];
+	src_h = osd_hw.free_scale_height[OSD2];
+	dst_w = osd_hw.free_dst_data[OSD2].x_end -
+		osd_hw.free_dst_data[OSD2].x_start + 1;
+	dst_h = osd_hw.free_dst_data[OSD2].y_end -
+		osd_hw.free_dst_data[OSD2].y_start + 1;
+	if (is_meson_g9tv_cpu()) {
+		/* super scaler mode */
+		if (osd_hw.free_scale_mode[OSD2] & 0x2) {
+			if (osd_hw.free_scale_enable[OSD2])
+				osd_super_scale_enable(OSD2);
+			else
+				osd_super_scale_disable();
+			remove_from_update_list(OSD2, DISP_FREESCALE_ENABLE);
+			return;
+		}
+	}
+	/* config osd sc control reg */
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD2]) {
+		/* enable osd scaler */
+		if (osd_hw.free_scale_mode[OSD2] & 0x1) {
+			data32 |= 1;      /* select osd2 input */
+			data32 |= 1 << 2; /* enable osd scaler */
+			data32 |= 1 << 3; /* enable osd scaler path */
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, data32);
+		}
+	} else {
+		/* disable osd scaler path */
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0);
+	}
+	hf_phase_step = (src_w << 18) / dst_w;
+	hf_phase_step = (hf_phase_step << 6);
+	vf_phase_step = (src_h << 20) / dst_h;
+	if (osd_hw.field_out_en)   /* interlace output */
+		bot_ini_phase = ((vf_phase_step / 2) >> 4);
+	else
+		bot_ini_phase = 0;
+	vf_phase_step = (vf_phase_step << 4);
+	/* config osd scaler in/out hv size */
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD2]) {
+		data32 = (((src_h - 1) & 0x1fff)
+			  | ((src_w - 1) & 0x1fff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCI_WH_M1, data32);
+		data32 = ((osd_hw.free_dst_data[OSD2].x_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD2].x_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_H_START_END, data32);
+		data32 = ((osd_hw.free_dst_data[OSD2].y_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD2].y_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_V_START_END, data32);
+	}
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD2].h_enable) {
+		data32 |= (hf_bank_len & 0x7)
+			  | ((hsc_ini_rcv_num & 0xf) << 3)
+			  | ((hsc_ini_rpt_p0_num & 0x3) << 8);
+		data32 |= 1 << 22;
+	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_HSC_CTRL0, data32);
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD2].v_enable) {
+		data32 |= (vf_bank_len & 0x7)
+			  | ((vsc_ini_rcv_num & 0xf) << 3)
+			  | ((vsc_ini_rpt_p0_num & 0x3) << 8);
+		if (osd_hw.field_out_en)   /* interface output */
+			data32 |= ((vsc_bot_rcv_num & 0xf) << 11)
+				  | ((vsc_bot_rpt_p0_num & 0x3) << 16)
+				  | (1 << 23);
+		if (osd_hw.scale_workaround)
+			data32 |= 1 << 21;
+		data32 |= 1 << 24;
+	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_CTRL0, data32);
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD2]) {
+		data32 |= (bot_ini_phase & 0xffff) << 16;
+		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_PHASE_STEP,
+					  hf_phase_step, 0, 28);
+		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_INI_PHASE, 0, 0, 16);
+		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_PHASE_STEP,
+					  vf_phase_step, 0, 28);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_INI_PHASE, data32);
+	}
+	remove_from_update_list(OSD2, DISP_FREESCALE_ENABLE);
+}
+
+static void osd2_update_coef(void)
+{
+	int i;
+	bool need_update_coef = false;
+	int hf_coef_wren = 1;
+	int vf_coef_wren = 1;
+	unsigned int *hf_coef, *vf_coef;
+	if (osd_hw.scale_workaround) {
+		if (use_v_filter_mode != 3) {
+			use_v_filter_mode = 3;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
+	} else {
+		if (use_v_filter_mode != osd_v_filter_mode) {
+			use_v_filter_mode = osd_v_filter_mode;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
+	}
+	vf_coef = filter_table[use_v_filter_mode];
+	if (need_update_coef) {
+		if (vf_coef_wren) {
+			osd_reg_set_bits(VPP_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
+			for (i = 0; i < 33; i++)
+				osd_reg_write(VPP_OSD_SCALE_COEF, vf_coef[i]);
+		}
+	}
+	need_update_coef = false;
+	if (use_h_filter_mode != osd_h_filter_mode) {
+		use_h_filter_mode = osd_h_filter_mode;
+		need_update_coef = true;
+	}
+	hf_coef = filter_table[use_h_filter_mode];
+	if (need_update_coef) {
+		if (hf_coef_wren) {
+			osd_reg_set_bits(VPP_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
+			for (i = 0; i < 33; i++)
+				osd_reg_write(VPP_OSD_SCALE_COEF, hf_coef[i]);
+		}
+	}
+	remove_from_update_list(OSD2, OSD_FREESCALE_COEF);
+}
+
+static   void  osd1_update_color_mode(void)
+{
+	u32 data32 = 0;
+	if (osd_hw.color_info[OSD1] != NULL) {
+		data32 = (osd_hw.scan_mode == SCAN_MODE_INTERLACE) ? 2 : 0;
+		data32 |= VSYNCOSD_RD_MPEG_REG(VIU_OSD1_BLK0_CFG_W0)
+			  & 0x30007040;
+		data32 |= osd_hw.fb_gem[OSD1].canvas_idx << 16;
+		if (!osd_hw.rotate[OSD1].on_off)
+			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
+		data32 |= osd_hw.color_info[OSD1]->hw_colormat << 2;
+		if (osd_hw.color_info[OSD1]->color_index < COLOR_INDEX_YUV_422)
+			data32 |= 1 << 7; /* rgb enable */
+		/* osd_blk_mode */
+		data32 |=  osd_hw.color_info[OSD1]->hw_blkmode << 8;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, data32);
+	}
+	remove_from_update_list(OSD1, OSD_COLOR_MODE);
+}
+static void osd2_update_color_mode(void)
+{
+	u32 data32 = 0;
+
+	if (osd_hw.color_info[OSD2] != NULL) {
+		data32 = (osd_hw.scan_mode == SCAN_MODE_INTERLACE) ? 2 : 0;
+		data32 |= VSYNCOSD_RD_MPEG_REG(VIU_OSD2_BLK0_CFG_W0)
+			  & 0x30007040;
+		data32 |= osd_hw.fb_gem[OSD2].canvas_idx << 16;
+		if (!osd_hw.rotate[OSD2].on_off)
+			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
+		data32 |= osd_hw.color_info[OSD2]->hw_colormat << 2;
+		if (osd_hw.color_info[OSD2]->color_index < COLOR_INDEX_YUV_422)
+			data32 |= 1 << 7; /* rgb enable */
+		/* osd_blk_mode */
+		data32 |=  osd_hw.color_info[OSD2]->hw_blkmode << 8;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, data32);
+	}
+	remove_from_update_list(OSD2, OSD_COLOR_MODE);
+}
+
+static void osd1_update_enable(void)
+{
+	u32 video_enable = 0;
+
+	if (osd_hw.free_scale_mode[OSD1]) {
+		if (osd_hw.enable[OSD1] == ENABLE) {
+			VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+						   VPP_OSD1_POSTBLEND | VPP_POSTBLEND_EN);
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 21);
+		} else {
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 21);
+			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+						   VPP_OSD1_POSTBLEND);
+		}
+	} else {
+		video_enable |= VSYNCOSD_RD_MPEG_REG(VPP_MISC)&VPP_VD1_PREBLEND;
+		if (osd_hw.enable[OSD1] == ENABLE) {
+			if (osd_hw.free_scale_enable[OSD1]) {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_PREBLEND
+							   | VPP_VD1_POSTBLEND
+							   | VPP_PREBLEND_EN);
+			} else {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_PREBLEND);
+				if (!video_enable)
+					VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+								   VPP_VD1_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_POSTBLEND);
+			}
+		} else {
+			if (osd_hw.free_scale_enable[OSD1])
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_PREBLEND);
+			else
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_POSTBLEND);
+		}
+	}
+	remove_from_update_list(OSD1, OSD_ENABLE);
+}
+
+static void osd2_update_enable(void)
+{
+	u32 video_enable = 0;
+
+	if (osd_hw.free_scale_mode[OSD2]) {
+		if (osd_hw.enable[OSD2] == ENABLE) {
+			if (osd_hw.free_scale_enable[OSD2]) {
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_POSTBLEND
+							   | VPP_POSTBLEND_EN);
+				VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT,
+							   1 << 21);
+			} else {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT,
+							   1 << 21);
+#ifndef CONFIG_FB_OSD2_CURSOR
+				/*
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+						VPP_OSD1_POSTBLEND);
+				*/
+#endif
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_POSTBLEND
+							   | VPP_POSTBLEND_EN);
+			}
+		} else {
+			if (osd_hw.enable[OSD1] == ENABLE)
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_POSTBLEND);
+			else
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_POSTBLEND
+							   | VPP_OSD2_POSTBLEND);
+		}
+	} else {
+		video_enable |= VSYNCOSD_RD_MPEG_REG(VPP_MISC)&VPP_VD1_PREBLEND;
+		if (osd_hw.enable[OSD2] == ENABLE) {
+			if (osd_hw.free_scale_enable[OSD2]) {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_PREBLEND
+							   | VPP_VD1_POSTBLEND);
+			} else {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_PREBLEND);
+				if (!video_enable)
+					VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+								   VPP_VD1_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_POSTBLEND);
+			}
+		} else {
+			if (osd_hw.free_scale_enable[OSD2])
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_PREBLEND);
+			else
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD2_POSTBLEND);
+		}
+	}
+	remove_from_update_list(OSD2, OSD_ENABLE);
+}
+
+static void osd1_update_disp_osd_reverse(void)
+{
+	if (osd_hw.osd_reverse[OSD1])
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD1_BLK0_CFG_W0, 3, 28, 2);
+	else
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 28);
+	remove_from_update_list(OSD1, DISP_OSD_REVERSE);
+}
+
+static void osd2_update_disp_osd_reverse(void)
+{
+	if (osd_hw.osd_reverse[OSD2])
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD2_BLK0_CFG_W0, 3, 28, 2);
+	else
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 28);
+	remove_from_update_list(OSD2, DISP_OSD_REVERSE);
+}
+static void osd1_update_disp_osd_rotate(void)
+{
+#if 0
+	unsigned char	x_rev = 0, y_rev = 0;
+	unsigned char	bpp = 32;
+	unsigned int	x_start;
+	unsigned int	x_end;
+	unsigned int	y_start;
+	unsigned int	y_end;
+	unsigned int	y_len_m1;
+	if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_08_PAL256)
+		bpp = 8;
+	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_16_565)
+		bpp = 16;
+	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_24_RGB)
+		bpp = 24;
+	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_32_ARGB)
+		bpp = 32;
+	switch (osd_hw.rotate[OSD1].angle) {
+	case 0:/* clockwise H flip (dst ) */
+		x_rev = 0;
+		y_rev = 0;
+		break;/* clockwise */
+	case 1:
+		y_rev = 1;
+		break;
+	case 2:/* anti-clockwise */
+		x_rev = 1;
+		break;
+	case 3:/* anti-clockwise H flip(dst) */
+		x_rev = 1;
+		y_rev = 1;
+		break;
+	}
+	x_start = osd_hw.rotation_pandata[OSD1].x_start;
+	x_end = osd_hw.rotation_pandata[OSD1].x_end;
+	y_start = osd_hw.rotation_pandata[OSD1].y_start;
+	y_end = osd_hw.rotation_pandata[OSD1].y_end;
+	y_len_m1 = y_end - y_start;
+	if (is_meson_m8_cpu()) {
+		osd_set_prot(
+			x_rev,
+			y_rev,
+			(bpp >> 3) - 1,
+			0, /* conv_422to444, */
+			OSD_DATA_LITTLE_ENDIAN,
+			HOLD_LINES,
+			x_start,
+			x_end,
+			y_start,
+			y_end,
+			y_len_m1,
+			Y_STEP,
+			PAT_START_PTR,
+			PAT_END_PTR,
+			PAT_VAL,
+			osd_hw.fb_gem[OSD1].canvas_idx,
+			CID_VALUE,
+			CID_MODE,
+			CUGT, /* urgent bit */
+			REQ_ONOFF_EN,
+			REQ_ON_MAX,
+			REQ_OFF_MIN,
+			OSD1,
+			osd_hw.rotate[OSD1].on_off);
+	}
+#endif
+	remove_from_update_list(OSD1, DISP_OSD_ROTATE);
+}
+
+static void osd2_update_disp_osd_rotate(void)
+{
+#if 0
+	unsigned char	x_rev = 0, y_rev = 0;
+	unsigned char	bpp = 32;
+	unsigned int	x_start;
+	unsigned int	x_end;
+	unsigned int	y_start;
+	unsigned int	y_end;
+	unsigned int	y_len_m1;
+	if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_08_PAL256)
+		bpp = 8;
+	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_16_565)
+		bpp = 16;
+	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_24_RGB)
+		bpp = 24;
+	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_32_ARGB)
+		bpp = 32;
+	switch (osd_hw.rotate[OSD2].angle) {
+	case 0:/* clockwise H flip (dst ) */
+		x_rev = 0;
+		y_rev = 0;
+		break;/* clockwise */
+	case 1:
+		y_rev = 1;
+		break;
+	case 2:/* anti-clockwise */
+		x_rev = 1;
+		break;
+	case 3:/* anti-clockwise H flip(dst) */
+		x_rev = 1;
+		y_rev = 1;
+		break;
+	}
+	x_start = osd_hw.rotation_pandata[OSD2].x_start;
+	x_end = osd_hw.rotation_pandata[OSD2].x_end;
+	y_start = osd_hw.rotation_pandata[OSD2].y_start;
+	y_end = osd_hw.rotation_pandata[OSD2].y_end;
+	y_len_m1 = y_end - y_start;
+	if (is_meson_m8_cpu()) {
+		osd_set_prot(
+			x_rev,
+			y_rev,
+			(bpp >> 3) - 1, /* bytes_per_pixel, */
+			0, /* conv_422to444, */
+			OSD_DATA_LITTLE_ENDIAN,
+			HOLD_LINES,
+			x_start,
+			x_end,
+			y_start,
+			y_end,
+			y_len_m1,
+			Y_STEP,
+			PAT_START_PTR,
+			PAT_END_PTR,
+			PAT_VAL,
+			osd_hw.fb_gem[OSD2].canvas_idx,
+			CID_VALUE,
+			CID_MODE,
+			CUGT, /* urgent bit */
+			REQ_ONOFF_EN,
+			REQ_ON_MAX,
+			REQ_OFF_MIN,
+			OSD2,
+			osd_hw.rotate[OSD2].on_off);
+	}
+#endif
+	remove_from_update_list(OSD2, DISP_OSD_ROTATE);
+}
+
+
+static void osd1_update_color_key(void)
+{
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_TCOLOR_AG0, osd_hw.color_key[OSD1]);
+	remove_from_update_list(OSD1, OSD_COLOR_KEY);
+}
+
+static void osd2_update_color_key(void)
+{
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_TCOLOR_AG0, osd_hw.color_key[OSD2]);
+	remove_from_update_list(OSD2, OSD_COLOR_KEY);
+}
+
+static void osd1_update_color_key_enable(void)
+{
+	u32  data32;
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD1_BLK0_CFG_W0);
+	data32 &= ~(1 << 6);
+	data32 |= (osd_hw.color_key_enable[OSD1] << 6);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, data32);
+	remove_from_update_list(OSD1, OSD_COLOR_KEY_ENABLE);
+}
+
+static void osd2_update_color_key_enable(void)
+{
+	u32  data32;
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD2_BLK0_CFG_W0);
+	data32 &= ~(1 << 6);
+	data32 |= (osd_hw.color_key_enable[OSD2] << 6);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, data32);
+	remove_from_update_list(OSD2, OSD_COLOR_KEY_ENABLE);
+}
+static   void  osd1_update_gbl_alpha(void)
+{
+	u32  data32;
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
+	data32 &= ~(0x1ff << 12);
+	data32 |= osd_hw.gbl_alpha[OSD1] << 12;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_CTRL_STAT, data32);
+	remove_from_update_list(OSD1, OSD_GBL_ALPHA);
+}
+static   void  osd2_update_gbl_alpha(void)
+{
+	u32  data32;
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD2_CTRL_STAT);
+	data32 &= ~(0x1ff << 12);
+	data32 |= osd_hw.gbl_alpha[OSD2] << 12;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_CTRL_STAT, data32);
+	remove_from_update_list(OSD2, OSD_GBL_ALPHA);
+}
+static   void  osd2_update_order(void)
+{
+	switch (osd_hw.order) {
+	case  OSD_ORDER_01:
+		osd_reg_clr_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	case  OSD_ORDER_10:
+		osd_reg_set_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	default:
+		break;
+	}
+	remove_from_update_list(OSD2, OSD_CHANGE_ORDER);
+}
+static   void  osd1_update_order(void)
+{
+	switch (osd_hw.order) {
+	case  OSD_ORDER_01:
+		osd_reg_clr_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	case  OSD_ORDER_10:
+		osd_reg_set_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	default:
+		break;
+	}
+	remove_from_update_list(OSD1, OSD_CHANGE_ORDER);
+}
+
+static void osd1_2x_scale_update_geometry(void)
+{
+	u32 data32;
+
+	data32 = (osd_hw.scaledata[OSD1].x_start & 0x1fff) |
+		 (osd_hw.scaledata[OSD1].x_end & 0x1fff) << 16;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+	data32 = ((osd_hw.scaledata[OSD1].y_start
+		   + osd_hw.pandata[OSD1].y_start) & 0x1fff)
+		 | ((osd_hw.scaledata[OSD1].y_end
+		     + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
+	/* adjust display x-axis */
+	if (osd_hw.scale[OSD1].h_enable) {
+		data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
+			 | ((osd_hw.dispdata[OSD1].x_start
+			     + (osd_hw.scaledata[OSD1].x_end
+				- osd_hw.scaledata[OSD1].x_start) * 2 + 1)
+			    & 0xfff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+		if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+			data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff)
+				 | (((((osd_hw.dispdata[OSD1].y_start
+					+ (osd_hw.scaledata[OSD1].y_end
+					   - osd_hw.scaledata[OSD1].y_start) * 2)
+				       + 1) >> 1) - 1) & 0xfff) << 16;
+		} else {
+			data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
+				 | (((osd_hw.dispdata[OSD1].y_start
+				      + (osd_hw.scaledata[OSD1].y_end
+					 - osd_hw.scaledata[OSD1].y_start) * 2))
+				    & 0xfff) << 16;
+		}
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+	}
+	/* adjust display y-axis */
+	if (osd_hw.scale[OSD1].v_enable) {
+		data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
+			 | ((osd_hw.dispdata[OSD1].x_start
+			     + (osd_hw.scaledata[OSD1].x_end
+				- osd_hw.scaledata[OSD1].x_start) * 2 + 1)
+			    & 0xfff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+		if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+			data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff)
+				 | (((((osd_hw.dispdata[OSD1].y_start
+					+ (osd_hw.scaledata[OSD1].y_end
+					   - osd_hw.scaledata[OSD1].y_start) * 2)
+				       + 1) >> 1) - 1) & 0xfff) << 16;
+		} else {
+			data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
+				 | (((osd_hw.dispdata[OSD1].y_start
+				      + (osd_hw.scaledata[OSD1].y_end
+					 - osd_hw.scaledata[OSD1].y_start) * 2))
+				    & 0xfff) << 16;
+		}
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+	}
+}
+
+static void osd1_basic_update_disp_geometry(void)
+{
+	u32 data32;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
+		data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
+			 | (osd_hw.dispdata[OSD1].x_end & 0xfff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+		if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+			data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff)
+				 | ((((osd_hw.dispdata[OSD1].y_end + 1)
+				      >> 1) - 1) & 0xfff) << 16;
+		else
+			data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
+				 | (osd_hw.dispdata[OSD1].y_end
+				    & 0xfff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+	} else {
+		if (osd_hw.free_scale_mode[OSD1] == 0) {
+			if (osd_hw.free_scale_enable[OSD1] == 1) {
+				data32 = (osd_hw.free_scale_data[OSD1].x_start
+					  & 0xfff)
+					 | (osd_hw.free_scale_data[OSD1].x_end
+					    & 0xfff) << 16;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3,
+						     data32);
+				data32 = (osd_hw.free_scale_data[OSD1].y_start
+					  & 0xfff)
+					 | (osd_hw.free_scale_data[OSD1].y_end
+					    & 0xfff) << 16;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4,
+						     data32);
+			} else {
+				data32 = (osd_hw.dispdata[OSD1].x_start
+					  & 0xfff)
+					 | (osd_hw.dispdata[OSD1].x_end
+					    & 0xfff) << 16;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3,
+						     data32);
+				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+					data32 = ((osd_hw.dispdata[OSD1].y_start
+						   >> 1) & 0xfff)
+						 | ((((osd_hw.dispdata[OSD1].y_end
+						       + 1) >> 1) - 1)
+						    & 0xfff) << 16;
+				else
+					data32 = (osd_hw.dispdata[OSD1].y_start
+						  & 0xfff)
+						 | (osd_hw.dispdata[OSD1].y_end
+						    & 0xfff) << 16;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4,
+						     data32);
+			}
+		} else {
+			data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
+				 | (osd_hw.dispdata[OSD1].x_end & 0xfff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+			if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+				data32 = ((osd_hw.dispdata[OSD1].y_start >> 1)
+					  & 0xfff)
+					 | ((((osd_hw.dispdata[OSD1].y_end + 1)
+					      >> 1) - 1) & 0xfff) << 16;
+			else
+				data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
+					 | (osd_hw.dispdata[OSD1].y_end
+					    & 0xfff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+		}
+	}
+	/* enable osd 2x scale */
+	if (osd_hw.scale[OSD1].h_enable || osd_hw.scale[OSD1].v_enable)
+		osd1_2x_scale_update_geometry();
+	else if (osd_hw.free_scale_enable[OSD1]
+		 && (osd_hw.free_scale_data[OSD1].x_end > 0)
+		 && (osd_hw.free_scale_data[OSD1].y_end > 0)
+		 && (!osd_hw.rotate[OSD1].on_off)) {
+		/* enable osd free scale */
+		data32 = (osd_hw.free_scale_data[OSD1].x_start & 0x1fff) |
+			 (osd_hw.free_scale_data[OSD1].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+		data32 = ((osd_hw.free_scale_data[OSD1].y_start
+			   + osd_hw.pandata[OSD1].y_start) & 0x1fff)
+			 | ((osd_hw.free_scale_data[OSD1].y_end
+			     + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
+	} else if (osd_hw.free_scale_enable[OSD1]
+		   && (osd_hw.free_scale_data[OSD1].x_end > 0)
+		   && (osd_hw.free_scale_data[OSD1].y_end > 0)
+		   && (osd_hw.rotate[OSD1].on_off
+		       && osd_hw.rotate[OSD1].angle > 0)) {
+		data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) |
+			 (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+		data32 = ((osd_hw.rotation_pandata[OSD1].y_start
+			   + osd_hw.pandata[OSD1].y_start) & 0x1fff)
+			 | ((osd_hw.rotation_pandata[OSD1].y_end
+			     + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
+		if (is_meson_m8_cpu())
+			VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END, data32);
+	} else if (osd_hw.rotate[OSD1].on_off
+		   && osd_hw.rotate[OSD1].angle > 0) {
+		/* enable osd rotation */
+		data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) |
+			 (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+		data32 = ((osd_hw.rotation_pandata[OSD1].y_start
+			   + osd_hw.pandata[OSD1].y_start) & 0x1fff)
+			 | ((osd_hw.rotation_pandata[OSD1].y_end
+			     + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
+		if (is_meson_m8_cpu())
+			VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END, data32);
+	} else {
+		/* normal mode */
+		data32 = (osd_hw.pandata[OSD1].x_start & 0x1fff)
+			 | (osd_hw.pandata[OSD1].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+		data32 = (osd_hw.pandata[OSD1].y_start & 0x1fff)
+			 | (osd_hw.pandata[OSD1].y_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
+	}
+	data32 = osd_reg_read(VIU_OSD1_CTRL_STAT);
+	data32 &= 0xfffffff0;
+	data32 |= HW_OSD_BLOCK_ENABLE_0;
+	osd_reg_write(VIU_OSD1_CTRL_STAT, data32);
+}
+
+static void osd1_update_disp_geometry(void)
+{
+	osd1_basic_update_disp_geometry();
+	remove_from_update_list(OSD1, DISP_GEOMETRY);
+}
+
+static void osd2_update_disp_geometry(void)
+{
+	u32 data32;
+	data32 = (osd_hw.dispdata[OSD2].x_start & 0xfff)
+		 | (osd_hw.dispdata[OSD2].x_end & 0xfff) << 16;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W3 , data32);
+	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+		data32 = ((osd_hw.dispdata[OSD2].y_start >> 1) & 0xfff)
+			 | ((((osd_hw.dispdata[OSD2].y_end + 1) >> 1) - 1)
+			    & 0xfff) << 16;
+	else
+		data32 = (osd_hw.dispdata[OSD2].y_start & 0xfff)
+			 | (osd_hw.dispdata[OSD2].y_end & 0xfff) << 16;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W4, data32);
+	if (osd_hw.scale[OSD2].h_enable || osd_hw.scale[OSD2].v_enable) {
+#if defined(CONFIG_FB_OSD2_CURSOR)
+		data32 = (osd_hw.pandata[OSD2].x_start & 0x1fff)
+			 | (osd_hw.pandata[OSD2].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = (osd_hw.pandata[OSD2].y_start & 0x1fff)
+			 | (osd_hw.pandata[OSD2].y_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
+#else
+		data32 = (osd_hw.scaledata[OSD2].x_start & 0x1fff) |
+			 (osd_hw.scaledata[OSD2].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = ((osd_hw.scaledata[OSD2].y_start
+			   + osd_hw.pandata[OSD2].y_start) & 0x1fff)
+			 | ((osd_hw.scaledata[OSD2].y_end
+			     + osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
+#endif
+	} else if (osd_hw.free_scale_enable[OSD2]
+		   && (osd_hw.free_scale_data[OSD2].x_end > 0)
+		   && (osd_hw.free_scale_data[OSD2].y_end > 0)) {
+		/* enable osd free scale */
+		data32 = (osd_hw.free_scale_data[OSD2].x_start & 0x1fff)
+			 | (osd_hw.free_scale_data[OSD2].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = ((osd_hw.free_scale_data[OSD2].y_start
+			   + osd_hw.pandata[OSD2].y_start) & 0x1fff)
+			 | ((osd_hw.free_scale_data[OSD2].y_end
+			     + osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
+	} else {
+		data32 = (osd_hw.pandata[OSD2].x_start & 0x1fff)
+			 | (osd_hw.pandata[OSD2].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = (osd_hw.pandata[OSD2].y_start & 0x1fff)
+			 | (osd_hw.pandata[OSD2].y_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
+	}
+	remove_from_update_list(OSD2, DISP_GEOMETRY);
+}
+static  void  osd1_update_disp_3d_mode(void)
+{
+	/*step 1 . set pan data */
+	u32  data32;
+	if (osd_hw.mode_3d[OSD1].left_right == OSD_LEFT) {
+		data32 = (osd_hw.mode_3d[OSD1].l_start & 0x1fff)
+			 | (osd_hw.mode_3d[OSD1].l_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+	} else {
+		data32 = (osd_hw.mode_3d[OSD1].r_start & 0x1fff)
+			 | (osd_hw.mode_3d[OSD1].r_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+	}
+	osd_hw.mode_3d[OSD1].left_right ^= 1;
+}
+
+static void osd2_update_disp_3d_mode(void)
+{
+	u32 data32;
+	if (osd_hw.mode_3d[OSD2].left_right == OSD_LEFT) {
+		data32 = (osd_hw.mode_3d[OSD2].l_start & 0x1fff)
+			 | (osd_hw.mode_3d[OSD2].l_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+	} else {
+		data32 = (osd_hw.mode_3d[OSD2].r_start & 0x1fff)
+			 | (osd_hw.mode_3d[OSD2].r_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+	}
+	osd_hw.mode_3d[OSD2].left_right ^= 1;
+}
+
+void osd_init_hw(void)
+{
+	u32 group, idx, data32;
+
+	for (group = 0; group < HW_OSD_COUNT; group++)
+		for (idx = 0; idx < HW_REG_INDEX_MAX; idx++)
+			osd_hw.reg[group][idx].update_func =
+				hw_func_array[group][idx];
+	osd_hw.updated[OSD1] = 0;
+	osd_hw.updated[OSD2] = 0;
+
+	osd_vpu_power_on();
+
+	/* here we will init default value ,these value only set once . */
+	if (!logo_loaded) {
+		/* init vpu fifo control register */
+		data32 = osd_reg_read(VPP_OFIFO_SIZE);
+		data32 |= 0x77f;
+		osd_reg_write(VPP_OFIFO_SIZE, data32);
+		data32 = 0x08080808;
+		osd_reg_write(VPP_HOLD_LINES, data32);
+
+		/* init osd fifo control register */
+		/* set DDR request priority to be urgent */
+		data32 = 1;
+		if ((get_cpu_type() == MESON_CPU_MAJOR_ID_M6TV)
+		    || (get_cpu_type() == MESON_CPU_MAJOR_ID_MTVD)) {
+			data32 |= 18 << 5;  /* hold_fifo_lines */
+		} else {
+			data32 |= 4 << 5;  /* hold_fifo_lines */
+		}
+		/* burst_len_sel: 3=64 */
+		data32 |= 3  << 10;
+		/* fifo_depth_val: 32*8=256 */
+		data32 |= 32 << 12;
+		if (is_meson_gxbb_cpu()) {
+			/*
+			 * bit 23:22, fifo_ctrl
+			 * 00 : for 1 word in 1 burst
+			 * 01 : for 2 words in 1 burst
+			 * 10 : for 4 words in 1 burst
+			 * 11 : reserved
+			 */
+			data32 |= 2 << 22;
+			/* bit 28:24, fifo_lim */
+			data32 |= 2 << 24;
+		}
+		osd_reg_write(VIU_OSD1_FIFO_CTRL_STAT, data32);
+		osd_reg_write(VIU_OSD2_FIFO_CTRL_STAT, data32);
+		osd_reg_set_mask(VPP_MISC, VPP_POSTBLEND_EN);
+		osd_reg_clr_mask(VPP_MISC, VPP_PREBLEND_EN);
+		osd_reg_clr_mask(VPP_MISC,
+				 VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND | VPP_VD1_POSTBLEND);
+		/* just disable osd to avoid booting hang up */
+		if ((get_cpu_type() == MESON_CPU_MAJOR_ID_M6TV)
+		    || (get_cpu_type() == MESON_CPU_MAJOR_ID_MTVD)) {
+			data32 = 0x0 << 0; /* osd_blk_enable */
+		} else
+			data32 = 0x1 << 0;
+		data32 |= OSD_GLOBAL_ALPHA_DEF << 12;
+		data32 |= (1 << 21);
+		osd_reg_write(VIU_OSD1_CTRL_STAT , data32);
+		osd_reg_write(VIU_OSD2_CTRL_STAT , data32);
+	}
+	osd_reg_clr_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+	osd_hw.order = OSD_ORDER_01;
+	osd_hw.enable[OSD2] = osd_hw.enable[OSD1] = DISABLE;
+	osd_hw.fb_gem[OSD1].canvas_idx = OSD1_CANVAS_INDEX;
+	osd_hw.fb_gem[OSD2].canvas_idx = OSD2_CANVAS_INDEX;
+	osd_hw.gbl_alpha[OSD1] = OSD_GLOBAL_ALPHA_DEF;
+	osd_hw.gbl_alpha[OSD2] = OSD_GLOBAL_ALPHA_DEF;
+	osd_hw.color_info[OSD1] = NULL;
+	osd_hw.color_info[OSD2] = NULL;
+	osd_hw.color_key[OSD1] = osd_hw.color_key[OSD2] = 0xffffffff;
+	osd_hw.free_scale_enable[OSD1] = osd_hw.free_scale_enable[OSD2] = 0;
+	osd_hw.scale[OSD1].h_enable = osd_hw.scale[OSD1].v_enable = 0;
+	osd_hw.scale[OSD2].h_enable = osd_hw.scale[OSD2].v_enable = 0;
+	osd_hw.mode_3d[OSD2].enable = osd_hw.mode_3d[OSD1].enable = 0;
+	osd_hw.block_mode[OSD1] = osd_hw.block_mode[OSD2] = 0;
+	osd_hw.free_scale[OSD1].h_enable = 0;
+	osd_hw.free_scale[OSD1].h_enable = 0;
+	osd_hw.free_scale[OSD2].v_enable = 0;
+	osd_hw.free_scale[OSD2].v_enable = 0;
+	osd_hw.osd_reverse[OSD1] = osd_hw.osd_reverse[OSD2] = 0;
+	osd_hw.rotation_pandata[OSD1].x_start = 0;
+	osd_hw.rotation_pandata[OSD1].y_start = 0;
+	osd_hw.rotation_pandata[OSD2].x_start = 0;
+	osd_hw.rotation_pandata[OSD2].y_start = 0;
+	osd_hw.antiflicker_mode = 0;
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
+		osd_hw.free_scale_data[OSD1].x_start = 0;
+		osd_hw.free_scale_data[OSD1].x_end = 0;
+		osd_hw.free_scale_data[OSD1].y_start = 0;
+		osd_hw.free_scale_data[OSD1].y_end = 0;
+		osd_hw.free_scale_data[OSD2].x_start = 0;
+		osd_hw.free_scale_data[OSD2].x_end = 0;
+		osd_hw.free_scale_data[OSD2].y_start = 0;
+		osd_hw.free_scale_data[OSD2].y_end = 0;
+		osd_hw.free_scale_mode[OSD1] = 1;
+		osd_hw.free_scale_mode[OSD2] = 1;
+		osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
+	} else {
+		osd_hw.free_scale_mode[OSD1] = 0;
+		osd_hw.free_scale_mode[OSD2] = 0;
+	}
+	memset(osd_hw.rotate, 0, sizeof(struct osd_rotate_s));
+
+	return;
+}
+
+
diff --git a/drivers/display/osd/osd_hw.h b/drivers/display/osd/osd_hw.h
new file mode 100644
index 0000000..19f73b2
--- /dev/null
+++ b/drivers/display/osd/osd_hw.h
@@ -0,0 +1,113 @@
+/*
+ * drivers/amlogic/display/osd/osd_hw.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef _OSD_HW_H_
+#define _OSD_HW_H_
+
+#include "osd.h"
+
+#define REG_OFFSET (0x20)
+#define OSD_RELATIVE_BITS 0x33370
+
+extern void osd_init_hw(void);
+extern void osd_set_color_key_hw(u32 index, u32 bpp, u32 colorkey);
+extern void osd_srckey_enable_hw(u32  index, u8 enable);
+extern void osd_set_gbl_alpha_hw(u32 index, u32 gbl_alpha);
+extern u32 osd_get_gbl_alpha_hw(u32  index);
+extern int read_rdma_table(void);
+extern void osd_set_color_mode(u32 index,
+			       const struct color_bit_define_s *color);
+extern void osd_update_disp_axis_hw(
+	u32 index,
+	u32 display_h_start,
+	u32 display_h_end,
+	u32 display_v_start,
+	u32 display_v_end,
+	u32 xoffset,
+	u32 yoffset,
+	u32 mode_change);
+extern void osd_setup_hw(u32 index,
+			 u32 xoffset,
+			 u32 yoffset,
+			 u32 xres,
+			 u32 yres,
+			 u32 xres_virtual ,
+			 u32 yres_virtual,
+			 u32 disp_start_x,
+			 u32 disp_start_y,
+			 u32 disp_end_x,
+			 u32 disp_end_y,
+			 u32 fbmem,
+			 const struct color_bit_define_s *color);
+extern void osd_set_order_hw(u32 index, u32 order);
+extern void osd_get_order_hw(u32 index, u32 *order);
+extern void osd_set_free_scale_enable_hw(u32 index, u32 enable);
+extern void osd_get_free_scale_enable_hw(u32 index, u32 *free_scale_enable);
+extern void osd_set_free_scale_mode_hw(u32 index, u32 freescale_mode);
+extern void osd_get_free_scale_mode_hw(u32 index, u32 *freescale_mode);
+extern void osd_set_4k2k_fb_mode_hw(u32 fb_for_4k2k);
+extern void osd_get_free_scale_mode_hw(u32 index, u32 *freescale_mode);
+extern void osd_set_free_scale_width_hw(u32 index, u32 width);
+extern void osd_get_free_scale_width_hw(u32 index, u32 *free_scale_width);
+extern void osd_set_free_scale_height_hw(u32 index, u32 height);
+extern void osd_get_free_scale_height_hw(u32 index, u32 *free_scale_height);
+extern void osd_get_free_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1,
+				       s32 *y1);
+extern void osd_set_free_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1,
+				       s32 y1);
+extern void osd_get_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1,
+				  s32 *y1);
+extern void osd_get_window_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1,
+				   s32 *y1);
+extern void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osd_set_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osd_get_block_windows_hw(u32 index, u32 *windows);
+extern void osd_set_block_windows_hw(u32 index, u32 *windows);
+extern void osd_get_block_mode_hw(u32 index, u32 *mode);
+extern void osd_set_block_mode_hw(u32 index, u32 mode);
+extern void osd_enable_3d_mode_hw(u32 index, u32 enable);
+extern void osd_set_2x_scale_hw(u32 index, u16 h_scale_enable,
+				u16 v_scale_enable);
+extern void osd_get_flush_rate_hw(u32 *break_rate);
+extern void osd_set_reverse_hw(u32 index, u32 reverse);
+extern void osd_get_reverse_hw(u32 index, u32 *reverse);
+extern void osd_set_rotate_on_hw(u32 index, u32 on_off);
+extern void osd_get_rotate_on_hw(u32 index, u32 *on_off);
+extern void osd_set_antiflicker_hw(u32 index, u32 vmode, u32 yres);
+extern void osd_get_antiflicker_hw(u32 index, u32 *on_off);
+extern void osd_set_update_state_hw(u32 index, u32 up_free);
+extern void osd_get_update_state_hw(u32 index, u32 *up_free);
+extern void osd_get_angle_hw(u32 index, u32 *angle);
+extern void osd_set_angle_hw(u32 index, u32 angle, u32  virtual_osd1_yres,
+			     u32 virtual_osd2_yres);
+extern void osd_get_clone_hw(u32 index, u32 *clone);
+extern void osd_set_clone_hw(u32 index, u32 clone);
+extern void osd_set_update_pan_hw(u32 index);
+extern void osd_set_rotate_angle_hw(u32 index, u32 angle);
+extern void osd_get_rotate_angle_hw(u32 index, u32 *angle);
+extern void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start,
+				   s32 *x_end, s32 *y_end);
+extern void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start,
+				   s32 x_end, s32 y_end);
+extern void osd_setpal_hw(u32 index, unsigned regno, unsigned red,
+			  unsigned green, unsigned blue, unsigned transp);
+extern void osd_enable_hw(u32 index, u32 enable);
+extern void osd_pan_display_hw(u32 index, unsigned int xoffset,
+			       unsigned int yoffset);
+extern void osd_get_hw_para(struct hw_para_s **para);
+
+#endif
diff --git a/drivers/display/osd/osd_hw_def.h b/drivers/display/osd/osd_hw_def.h
new file mode 100644
index 0000000..4c55ca6
--- /dev/null
+++ b/drivers/display/osd/osd_hw_def.h
@@ -0,0 +1,91 @@
+/*
+ * drivers/amlogic/display/osd/osd_hw_def.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef _OSD_HW_DEF_H_
+#define	_OSD_HW_DEF_H_
+
+#include "osd_hw.h"
+
+static void osd1_update_color_mode(void);
+static void osd1_update_enable(void);
+static void osd1_update_color_key(void);
+static void osd1_update_color_key_enable(void);
+static void osd1_update_gbl_alpha(void);
+static void osd1_update_order(void);
+static void osd1_update_disp_geometry(void);
+static void osd1_update_coef(void);
+static void osd1_update_disp_freescale_enable(void);
+static void osd1_update_disp_osd_reverse(void);
+static void osd1_update_disp_osd_rotate(void);
+static void osd1_update_disp_scale_enable(void);
+static void osd1_update_disp_3d_mode(void);
+
+static void osd2_update_color_mode(void);
+static void osd2_update_enable(void);
+static void osd2_update_color_key(void);
+static void osd2_update_color_key_enable(void);
+static void osd2_update_gbl_alpha(void);
+static void osd2_update_order(void);
+static void osd2_update_disp_geometry(void);
+static void osd2_update_coef(void);
+static void osd2_update_disp_freescale_enable(void);
+static void osd2_update_disp_osd_reverse(void);
+static void osd2_update_disp_osd_rotate(void);
+static void osd2_update_disp_scale_enable(void);
+static void osd2_update_disp_3d_mode(void);
+
+static struct hw_para_s osd_hw;
+static update_func_t hw_func_array[HW_OSD_COUNT][HW_REG_INDEX_MAX] = {
+	{
+		osd1_update_color_mode,
+		osd1_update_enable,
+		osd1_update_color_key,
+		osd1_update_color_key_enable,
+		osd1_update_gbl_alpha,
+		osd1_update_order,
+		osd1_update_coef,
+		osd1_update_disp_geometry,
+		osd1_update_disp_scale_enable,
+		osd1_update_disp_freescale_enable,
+		osd1_update_disp_osd_reverse,
+		osd1_update_disp_osd_rotate,
+	},
+	{
+		osd2_update_color_mode,
+		osd2_update_enable,
+		osd2_update_color_key,
+		osd2_update_color_key_enable,
+		osd2_update_gbl_alpha,
+		osd2_update_order,
+		osd2_update_coef,
+		osd2_update_disp_geometry,
+		osd2_update_disp_scale_enable,
+		osd2_update_disp_freescale_enable,
+		osd2_update_disp_osd_reverse,
+		osd2_update_disp_osd_rotate,
+	},
+};
+
+#define add_to_update_list(osd_idx, cmd_idx) \
+	do { \
+		osd_hw.updated[osd_idx] |= (1<<cmd_idx); \
+	} while (0)
+
+#define remove_from_update_list(osd_idx, cmd_idx) \
+	(osd_hw.updated[osd_idx] &= ~(1<<cmd_idx))
+
+#endif
diff --git a/drivers/display/osd/osd_io.h b/drivers/display/osd/osd_io.h
new file mode 100644
index 0000000..0a6d36d
--- /dev/null
+++ b/drivers/display/osd/osd_io.h
@@ -0,0 +1,84 @@
+/*
+ * drivers/display/osd/osd_io.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _OSD_IO_H_
+#define _OSD_IO_H_
+
+#include <asm/arch/io.h>
+
+#define REG_BASE_CBUS                   (0xc1100000L)
+#define REG_BASE_VCBUS                  (0xd0100000L)
+#define REG_OFFSET_CBUS(reg)            ((reg << 2))
+#define REG_OFFSET_VCBUS(reg)           ((reg << 2))
+
+#define REG_ADDR_CBUS(reg)              (REG_BASE_CBUS + REG_OFFSET_CBUS(reg))
+#define REG_ADDR_VCBUS(reg)             (REG_BASE_VCBUS + REG_OFFSET_VCBUS(reg))
+
+static inline u32 osd_cbus_read(u32 reg)
+{
+	return (*(volatile unsigned int *)REG_ADDR_CBUS(reg));
+}
+
+static inline void osd_cbus_write(u32 reg,
+				  const u32 val)
+{
+	*(volatile unsigned int *)REG_ADDR_CBUS(reg) = (val);
+}
+
+
+static inline u32 osd_reg_read(u32 reg)
+{
+	return (*(volatile unsigned int *)REG_ADDR_VCBUS(reg));
+}
+
+static inline void osd_reg_write(u32 reg,
+				 const u32 val)
+{
+	*(volatile unsigned int *)REG_ADDR_VCBUS(reg) = (val);
+}
+
+static inline void osd_reg_set_mask(u32 reg,
+				    const u32 mask)
+{
+	osd_reg_write(reg, (osd_reg_read(reg) | (mask)));
+}
+
+static inline void osd_reg_clr_mask(u32 reg,
+				    const u32 mask)
+{
+	osd_reg_write(reg, (osd_reg_read(reg) & (~(mask))));
+}
+
+static inline void osd_reg_set_bits(u32 reg,
+				    const u32 value,
+				    const u32 start,
+				    const u32 len)
+{
+	osd_reg_write(reg, ((osd_reg_read(reg) &
+			     ~(((1L << (len)) - 1) << (start))) |
+			    (((value) & ((1L << (len)) - 1)) << (start))));
+}
+
+#define VSYNCOSD_RD_MPEG_REG(reg) osd_reg_read(reg)
+#define VSYNCOSD_WR_MPEG_REG(reg, val) osd_reg_write(reg, val)
+#define VSYNCOSD_WR_MPEG_REG_BITS(reg, val, start, len) \
+	osd_reg_set_bits(reg, val, start, len)
+#define VSYNCOSD_SET_MPEG_REG_MASK(reg, mask) osd_reg_set_mask(reg, mask)
+#define VSYNCOSD_CLR_MPEG_REG_MASK(reg, mask) osd_reg_clr_mask(reg, mask)
+
+#endif
diff --git a/drivers/display/osd/osd_log.h b/drivers/display/osd/osd_log.h
new file mode 100644
index 0000000..fedac46
--- /dev/null
+++ b/drivers/display/osd/osd_log.h
@@ -0,0 +1,66 @@
+/*
+ * drivers/amlogic/display/osd/osd_log.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _OSD_LOG_H_
+#define _OSD_LOG_H_
+
+#include <common.h>
+
+#define OSD_LOG_TAG "[OSD]"
+
+#define OSD_LOG_LEVEL_NULL 0
+#define OSD_LOG_LEVEL_DEBUG 1
+#define OSD_LOG_LEVEL_DEBUG2 2
+#define OSD_LOG_LEVEL_DEBUG3 3
+
+extern unsigned int osd_log_level;
+
+#define osd_logl() \
+	printf(OSD_LOG_TAG "%s:%d\n", __func__, __LINE__)
+
+#define osd_logv(fmt, ...) \
+	printf(OSD_LOG_TAG "%s:%d " fmt, __func__, __LINE__, ##__VA_ARGS__)
+
+#define osd_logi(fmt, ...) \
+	printf(OSD_LOG_TAG fmt, ##__VA_ARGS__)
+
+#define osd_loge(fmt, ...) \
+	printf(OSD_LOG_TAG "ERR: " fmt, ##__VA_ARGS__)
+
+#define osd_logd(fmt, ...) \
+	do { \
+		if (osd_log_level >= OSD_LOG_LEVEL_DEBUG) { \
+			printf(OSD_LOG_TAG fmt, ##__VA_ARGS__); \
+		} \
+	} while (0)
+
+#define osd_logd2(fmt, ...) \
+	do { \
+		if (osd_log_level >= OSD_LOG_LEVEL_DEBUG2) { \
+			printf(OSD_LOG_TAG fmt, ##__VA_ARGS__); \
+		} \
+	} while (0)
+
+#define osd_logd3(fmt, ...) \
+	do { \
+		if (osd_log_level >= OSD_LOG_LEVEL_DEBUG3) { \
+			printf(OSD_LOG_TAG fmt, ##__VA_ARGS__); \
+		} \
+	} while (0)
+
+#endif
diff --git a/drivers/display/osd/osd_reg.h b/drivers/display/osd/osd_reg.h
new file mode 100644
index 0000000..aeeb3d1
--- /dev/null
+++ b/drivers/display/osd/osd_reg.h
@@ -0,0 +1,1342 @@
+/*
+ * drivers/amlogic/display/osd/osd_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _OSD_REG_H_
+#define _OSD_REG_H_
+
+/* vpp2 */
+#define VPP2_DUMMY_DATA 0x1900
+#define VPP2_LINE_IN_LENGTH 0x1901
+#define VPP2_PIC_IN_HEIGHT 0x1902
+#define VPP2_SCALE_COEF_IDX 0x1903
+#define VPP2_SCALE_COEF 0x1904
+#define VPP2_VSC_REGION12_STARTP 0x1905
+#define VPP2_VSC_REGION34_STARTP 0x1906
+#define VPP2_VSC_REGION4_ENDP 0x1907
+#define VPP2_VSC_START_PHASE_STEP 0x1908
+#define VPP2_VSC_REGION0_PHASE_SLOPE 0x1909
+#define VPP2_VSC_REGION1_PHASE_SLOPE 0x190a
+#define VPP2_VSC_REGION3_PHASE_SLOPE 0x190b
+#define VPP2_VSC_REGION4_PHASE_SLOPE 0x190c
+#define VPP2_VSC_PHASE_CTRL 0x190d
+#define VPP2_VSC_INI_PHASE 0x190e
+#define VPP2_HSC_REGION12_STARTP 0x1910
+#define VPP2_HSC_REGION34_STARTP 0x1911
+#define VPP2_HSC_REGION4_ENDP 0x1912
+#define VPP2_HSC_START_PHASE_STEP 0x1913
+#define VPP2_HSC_REGION0_PHASE_SLOPE 0x1914
+#define VPP2_HSC_REGION1_PHASE_SLOPE 0x1915
+#define VPP2_HSC_REGION3_PHASE_SLOPE 0x1916
+#define VPP2_HSC_REGION4_PHASE_SLOPE 0x1917
+#define VPP2_HSC_PHASE_CTRL 0x1918
+#define VPP2_SC_MISC 0x1919
+#define VPP2_PREBLEND_VD1_H_START_END 0x191a
+#define VPP2_PREBLEND_VD1_V_START_END 0x191b
+#define VPP2_POSTBLEND_VD1_H_START_END 0x191c
+#define VPP2_POSTBLEND_VD1_V_START_END 0x191d
+#define VPP2_PREBLEND_H_SIZE 0x1920
+#define VPP2_POSTBLEND_H_SIZE 0x1921
+#define VPP2_HOLD_LINES 0x1922
+#define VPP2_BLEND_ONECOLOR_CTRL 0x1923
+#define VPP2_PREBLEND_CURRENT_XY 0x1924
+#define VPP2_POSTBLEND_CURRENT_XY 0x1925
+#define VPP2_MISC 0x1926
+#define VPP2_OFIFO_SIZE 0x1927
+#define VPP2_FIFO_STATUS 0x1928
+#define VPP2_SMOKE_CTRL 0x1929
+#define VPP2_SMOKE1_VAL 0x192a
+#define VPP2_SMOKE2_VAL 0x192b
+#define VPP2_SMOKE1_H_START_END 0x192d
+#define VPP2_SMOKE1_V_START_END 0x192e
+#define VPP2_SMOKE2_H_START_END 0x192f
+#define VPP2_SMOKE2_V_START_END 0x1930
+#define VPP2_SCO_FIFO_CTRL 0x1933
+#define VPP2_HSC_PHASE_CTRL1 0x1934
+#define VPP2_HSC_INI_PAT_CTRL 0x1935
+#define VPP2_VADJ_CTRL 0x1940
+#define VPP2_VADJ1_Y 0x1941
+#define VPP2_VADJ1_MA_MB 0x1942
+#define VPP2_VADJ1_MC_MD 0x1943
+#define VPP2_VADJ2_Y 0x1944
+#define VPP2_VADJ2_MA_MB 0x1945
+#define VPP2_VADJ2_MC_MD 0x1946
+#define VPP2_MATRIX_PROBE_COLOR 0x195c
+#define VPP2_MATRIX_HL_COLOR 0x195d
+#define VPP2_MATRIX_PROBE_POS 0x195e
+#define VPP2_MATRIX_CTRL 0x195f
+#define VPP2_MATRIX_COEF00_01 0x1960
+#define VPP2_MATRIX_COEF02_10 0x1961
+#define VPP2_MATRIX_COEF11_12 0x1962
+#define VPP2_MATRIX_COEF20_21 0x1963
+#define VPP2_MATRIX_COEF22 0x1964
+#define VPP2_MATRIX_OFFSET0_1 0x1965
+#define VPP2_MATRIX_OFFSET2 0x1966
+#define VPP2_MATRIX_PRE_OFFSET0_1 0x1967
+#define VPP2_MATRIX_PRE_OFFSET2 0x1968
+#define VPP2_DUMMY_DATA1 0x1969
+#define VPP2_GAINOFF_CTRL0 0x196a
+#define VPP2_GAINOFF_CTRL1 0x196b
+#define VPP2_GAINOFF_CTRL2 0x196c
+#define VPP2_GAINOFF_CTRL3 0x196d
+#define VPP2_GAINOFF_CTRL4 0x196e
+#define VPP2_CHROMA_ADDR_PORT 0x1970
+#define VPP2_CHROMA_DATA_PORT 0x1971
+#define VPP2_GCLK_CTRL0 0x1972
+#define VPP2_GCLK_CTRL1 0x1973
+#define VPP2_SC_GCLK_CTRL 0x1974
+#define VPP2_MISC1 0x1976
+#define VPP2_DNLP_CTRL_00 0x1981
+#define VPP2_DNLP_CTRL_01 0x1982
+#define VPP2_DNLP_CTRL_02 0x1983
+#define VPP2_DNLP_CTRL_03 0x1984
+#define VPP2_DNLP_CTRL_04 0x1985
+#define VPP2_DNLP_CTRL_05 0x1986
+#define VPP2_DNLP_CTRL_06 0x1987
+#define VPP2_DNLP_CTRL_07 0x1988
+#define VPP2_DNLP_CTRL_08 0x1989
+#define VPP2_DNLP_CTRL_09 0x198a
+#define VPP2_DNLP_CTRL_10 0x198b
+#define VPP2_DNLP_CTRL_11 0x198c
+#define VPP2_DNLP_CTRL_12 0x198d
+#define VPP2_DNLP_CTRL_13 0x198e
+#define VPP2_DNLP_CTRL_14 0x198f
+#define VPP2_DNLP_CTRL_15 0x1990
+#define VPP2_VE_ENABLE_CTRL 0x19a1
+#define VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH 0x19a2
+#define VPP2_VE_DEMO_CENTER_BAR 0x19a3
+#define VPP2_VE_H_V_SIZE 0x19a4
+#define VPP2_VDO_MEAS_CTRL 0x19a8
+#define VPP2_VDO_MEAS_VS_COUNT_HI 0x19a9
+#define VPP2_VDO_MEAS_VS_COUNT_LO 0x19aa
+#define VPP2_OSD_VSC_PHASE_STEP 0x19c0
+#define VPP2_OSD_VSC_INI_PHASE 0x19c1
+#define VPP2_OSD_VSC_CTRL0 0x19c2
+#define VPP2_OSD_HSC_PHASE_STEP 0x19c3
+#define VPP2_OSD_HSC_INI_PHASE 0x19c4
+#define VPP2_OSD_HSC_CTRL0 0x19c5
+#define VPP2_OSD_HSC_INI_PAT_CTRL 0x19c6
+#define VPP2_OSD_SC_DUMMY_DATA 0x19c7
+#define VPP2_OSD_SC_CTRL0 0x19c8
+#define VPP2_OSD_SCI_WH_M1 0x19c9
+#define VPP2_OSD_SCO_H_START_END 0x19ca
+#define VPP2_OSD_SCO_V_START_END 0x19cb
+#define VPP2_OSD_SCALE_COEF_IDX 0x19cc
+#define VPP2_OSD_SCALE_COEF 0x19cd
+#define VPP2_INT_LINE_NUM 0x19ce
+
+/* viu */
+#define VIU_ADDR_START 0x1a00
+#define VIU_ADDR_END 0x1aff
+#define VIU_SW_RESET 0x1a01
+#define VIU_MISC_CTRL0 0x1a06
+#define D2D3_INTF_LENGTH 0x1a08
+#define D2D3_INTF_CTRL0 0x1a09
+#define VIU_OSD1_CTRL_STAT 0x1a10
+#define VIU_OSD1_CTRL_STAT2 0x1a2d
+#define VIU_OSD1_COLOR_ADDR 0x1a11
+#define VIU_OSD1_COLOR 0x1a12
+#define VIU_OSD1_TCOLOR_AG0 0x1a17
+#define VIU_OSD1_TCOLOR_AG1 0x1a18
+#define VIU_OSD1_TCOLOR_AG2 0x1a19
+#define VIU_OSD1_TCOLOR_AG3 0x1a1a
+#define VIU_OSD1_BLK0_CFG_W0 0x1a1b
+#define VIU_OSD1_BLK1_CFG_W0 0x1a1f
+#define VIU_OSD1_BLK2_CFG_W0 0x1a23
+#define VIU_OSD1_BLK3_CFG_W0 0x1a27
+#define VIU_OSD1_BLK0_CFG_W1 0x1a1c
+#define VIU_OSD1_BLK1_CFG_W1 0x1a20
+#define VIU_OSD1_BLK2_CFG_W1 0x1a24
+#define VIU_OSD1_BLK3_CFG_W1 0x1a28
+#define VIU_OSD1_BLK0_CFG_W2 0x1a1d
+#define VIU_OSD1_BLK1_CFG_W2 0x1a21
+#define VIU_OSD1_BLK2_CFG_W2 0x1a25
+#define VIU_OSD1_BLK3_CFG_W2 0x1a29
+#define VIU_OSD1_BLK0_CFG_W3 0x1a1e
+#define VIU_OSD1_BLK1_CFG_W3 0x1a22
+#define VIU_OSD1_BLK2_CFG_W3 0x1a26
+#define VIU_OSD1_BLK3_CFG_W3 0x1a2a
+#define VIU_OSD1_BLK0_CFG_W4 0x1a13
+#define VIU_OSD1_BLK1_CFG_W4 0x1a14
+#define VIU_OSD1_BLK2_CFG_W4 0x1a15
+#define VIU_OSD1_BLK3_CFG_W4 0x1a16
+#define VIU_OSD1_FIFO_CTRL_STAT 0x1a2b
+#define VIU_OSD1_TEST_RDDATA 0x1a2c
+#define VIU_OSD1_PROT_CTRL 0x1a2e
+#define VIU_OSD2_CTRL_STAT 0x1a30
+#define VIU_OSD2_CTRL_STAT2 0x1a4d
+#define VIU_OSD2_COLOR_ADDR 0x1a31
+#define VIU_OSD2_COLOR 0x1a32
+#define VIU_OSD2_HL1_H_START_END 0x1a33
+#define VIU_OSD2_HL1_V_START_END 0x1a34
+#define VIU_OSD2_HL2_H_START_END 0x1a35
+#define VIU_OSD2_HL2_V_START_END 0x1a36
+#define VIU_OSD2_TCOLOR_AG0 0x1a37
+#define VIU_OSD2_TCOLOR_AG1 0x1a38
+#define VIU_OSD2_TCOLOR_AG2 0x1a39
+#define VIU_OSD2_TCOLOR_AG3 0x1a3a
+#define VIU_OSD2_BLK0_CFG_W0 0x1a3b
+#define VIU_OSD2_BLK1_CFG_W0 0x1a3f
+#define VIU_OSD2_BLK2_CFG_W0 0x1a43
+#define VIU_OSD2_BLK3_CFG_W0 0x1a47
+#define VIU_OSD2_BLK0_CFG_W1 0x1a3c
+#define VIU_OSD2_BLK1_CFG_W1 0x1a40
+#define VIU_OSD2_BLK2_CFG_W1 0x1a44
+#define VIU_OSD2_BLK3_CFG_W1 0x1a48
+#define VIU_OSD2_BLK0_CFG_W2 0x1a3d
+#define VIU_OSD2_BLK1_CFG_W2 0x1a41
+#define VIU_OSD2_BLK2_CFG_W2 0x1a45
+#define VIU_OSD2_BLK3_CFG_W2 0x1a49
+#define VIU_OSD2_BLK0_CFG_W3 0x1a3e
+#define VIU_OSD2_BLK1_CFG_W3 0x1a42
+#define VIU_OSD2_BLK2_CFG_W3 0x1a46
+#define VIU_OSD2_BLK3_CFG_W3 0x1a4a
+#define VIU_OSD2_BLK0_CFG_W4 0x1a64
+#define VIU_OSD2_BLK1_CFG_W4 0x1a65
+#define VIU_OSD2_BLK2_CFG_W4 0x1a66
+#define VIU_OSD2_BLK3_CFG_W4 0x1a67
+#define VIU_OSD2_FIFO_CTRL_STAT 0x1a4b
+#define VIU_OSD2_TEST_RDDATA 0x1a4c
+#define VIU_OSD2_PROT_CTRL 0x1a4e
+
+#define VD1_IF0_GEN_REG 0x1a50
+#define VD1_IF0_CANVAS0 0x1a51
+#define VD1_IF0_CANVAS1 0x1a52
+#define VD1_IF0_LUMA_X0 0x1a53
+#define VD1_IF0_LUMA_Y0 0x1a54
+#define VD1_IF0_CHROMA_X0 0x1a55
+#define VD1_IF0_CHROMA_Y0 0x1a56
+#define VD1_IF0_LUMA_X1 0x1a57
+#define VD1_IF0_LUMA_Y1 0x1a58
+#define VD1_IF0_CHROMA_X1 0x1a59
+#define VD1_IF0_CHROMA_Y1 0x1a5a
+#define VD1_IF0_RPT_LOOP 0x1a5b
+#define VD1_IF0_LUMA0_RPT_PAT 0x1a5c
+#define VD1_IF0_CHROMA0_RPT_PAT 0x1a5d
+#define VD1_IF0_LUMA1_RPT_PAT 0x1a5e
+#define VD1_IF0_CHROMA1_RPT_PAT 0x1a5f
+#define VD1_IF0_LUMA_PSEL 0x1a60
+#define VD1_IF0_CHROMA_PSEL 0x1a61
+#define VD1_IF0_DUMMY_PIXEL 0x1a62
+#define VD1_IF0_LUMA_FIFO_SIZE 0x1a63
+#define VD1_IF0_RANGE_MAP_Y 0x1a6a
+#define VD1_IF0_RANGE_MAP_CB 0x1a6b
+#define VD1_IF0_RANGE_MAP_CR 0x1a6c
+#define VD1_IF0_GEN_REG2 0x1a6d
+#define VD1_IF0_PROT_CNTL 0x1a6e
+#define VIU_VD1_FMT_CTRL 0x1a68
+#define VIU_VD1_FMT_W 0x1a69
+#define VD2_IF0_GEN_REG 0x1a70
+#define VD2_IF0_CANVAS0 0x1a71
+#define VD2_IF0_CANVAS1 0x1a72
+#define VD2_IF0_LUMA_X0 0x1a73
+#define VD2_IF0_LUMA_Y0 0x1a74
+#define VD2_IF0_CHROMA_X0 0x1a75
+#define VD2_IF0_CHROMA_Y0 0x1a76
+#define VD2_IF0_LUMA_X1 0x1a77
+#define VD2_IF0_LUMA_Y1 0x1a78
+#define VD2_IF0_CHROMA_X1 0x1a79
+#define VD2_IF0_CHROMA_Y1 0x1a7a
+#define VD2_IF0_RPT_LOOP 0x1a7b
+#define VD2_IF0_LUMA0_RPT_PAT 0x1a7c
+#define VD2_IF0_CHROMA0_RPT_PAT 0x1a7d
+#define VD2_IF0_LUMA1_RPT_PAT 0x1a7e
+#define VD2_IF0_CHROMA1_RPT_PAT 0x1a7f
+#define VD2_IF0_LUMA_PSEL 0x1a80
+#define VD2_IF0_CHROMA_PSEL 0x1a81
+#define VD2_IF0_DUMMY_PIXEL 0x1a82
+#define VD2_IF0_LUMA_FIFO_SIZE 0x1a83
+#define VD2_IF0_RANGE_MAP_Y 0x1a8a
+#define VD2_IF0_RANGE_MAP_CB 0x1a8b
+#define VD2_IF0_RANGE_MAP_CR 0x1a8c
+#define VD2_IF0_GEN_REG2 0x1a8d
+#define VD2_IF0_PROT_CNTL 0x1a8e
+#define VIU_VD2_FMT_CTRL 0x1a88
+#define VIU_VD2_FMT_W 0x1a89
+
+/* vpp */
+#define VPP_DUMMY_DATA 0x1d00
+#define VPP_LINE_IN_LENGTH 0x1d01
+#define VPP_PIC_IN_HEIGHT 0x1d02
+#define VPP_SCALE_COEF_IDX 0x1d03
+#define VPP_SCALE_COEF 0x1d04
+#define VPP_VSC_REGION12_STARTP 0x1d05
+#define VPP_VSC_REGION34_STARTP 0x1d06
+#define VPP_VSC_REGION4_ENDP 0x1d07
+#define VPP_VSC_START_PHASE_STEP 0x1d08
+#define VPP_VSC_REGION0_PHASE_SLOPE 0x1d09
+#define VPP_VSC_REGION1_PHASE_SLOPE 0x1d0a
+#define VPP_VSC_REGION3_PHASE_SLOPE 0x1d0b
+#define VPP_VSC_REGION4_PHASE_SLOPE 0x1d0c
+#define VPP_VSC_PHASE_CTRL 0x1d0d
+#define VPP_VSC_INI_PHASE 0x1d0e
+#define VPP_HSC_REGION12_STARTP 0x1d10
+#define VPP_HSC_REGION34_STARTP 0x1d11
+#define VPP_HSC_REGION4_ENDP 0x1d12
+#define VPP_HSC_START_PHASE_STEP 0x1d13
+#define VPP_HSC_REGION0_PHASE_SLOPE 0x1d14
+#define VPP_HSC_REGION1_PHASE_SLOPE 0x1d15
+#define VPP_HSC_REGION3_PHASE_SLOPE 0x1d16
+#define VPP_HSC_REGION4_PHASE_SLOPE 0x1d17
+#define VPP_HSC_PHASE_CTRL 0x1d18
+#define VPP_SC_MISC 0x1d19
+#define VPP_PREBLEND_VD1_H_START_END 0x1d1a
+#define VPP_PREBLEND_VD1_V_START_END 0x1d1b
+#define VPP_POSTBLEND_VD1_H_START_END 0x1d1c
+#define VPP_POSTBLEND_VD1_V_START_END 0x1d1d
+#define VPP_BLEND_VD2_H_START_END 0x1d1e
+#define VPP_BLEND_VD2_V_START_END 0x1d1f
+#define VPP_PREBLEND_H_SIZE 0x1d20
+#define VPP_POSTBLEND_H_SIZE 0x1d21
+#define VPP_HOLD_LINES 0x1d22
+#define VPP_BLEND_ONECOLOR_CTRL 0x1d23
+#define VPP_PREBLEND_CURRENT_XY 0x1d24
+#define VPP_POSTBLEND_CURRENT_XY 0x1d25
+#define VPP_MISC 0x1d26
+#define VPP_OFIFO_SIZE 0x1d27
+#define VPP_FIFO_STATUS 0x1d28
+#define VPP_SMOKE_CTRL 0x1d29
+#define VPP_SMOKE1_VAL 0x1d2a
+#define VPP_SMOKE2_VAL 0x1d2b
+#define VPP_SMOKE3_VAL 0x1d2c
+#define VPP_SMOKE1_H_START_END 0x1d2d
+#define VPP_SMOKE1_V_START_END 0x1d2e
+#define VPP_SMOKE2_H_START_END 0x1d2f
+#define VPP_SMOKE2_V_START_END 0x1d30
+#define VPP_SMOKE3_H_START_END 0x1d31
+#define VPP_SMOKE3_V_START_END 0x1d32
+#define VPP_SCO_FIFO_CTRL 0x1d33
+#define VPP_HSC_PHASE_CTRL1 0x1d34
+#define VPP_HSC_INI_PAT_CTRL 0x1d35
+#define VPP_VADJ_CTRL 0x1d40
+#define VPP_VADJ1_Y 0x1d41
+#define VPP_VADJ1_MA_MB 0x1d42
+#define VPP_VADJ1_MC_MD 0x1d43
+#define VPP_VADJ2_Y 0x1d44
+#define VPP_VADJ2_MA_MB 0x1d45
+#define VPP_VADJ2_MC_MD 0x1d46
+#define VPP_HSHARP_CTRL 0x1d50
+#define VPP_HSHARP_LUMA_THRESH01 0x1d51
+#define VPP_HSHARP_LUMA_THRESH23 0x1d52
+#define VPP_HSHARP_CHROMA_THRESH01 0x1d53
+#define VPP_HSHARP_CHROMA_THRESH23 0x1d54
+#define VPP_HSHARP_LUMA_GAIN 0x1d55
+#define VPP_HSHARP_CHROMA_GAIN 0x1d56
+#define VPP_MATRIX_PROBE_COLOR 0x1d5c
+#define VPP_MATRIX_HL_COLOR 0x1d5d
+#define VPP_MATRIX_PROBE_POS 0x1d5e
+#define VPP_MATRIX_CTRL 0x1d5f
+#define VPP_MATRIX_COEF00_01 0x1d60
+#define VPP_MATRIX_COEF02_10 0x1d61
+#define VPP_MATRIX_COEF11_12 0x1d62
+#define VPP_MATRIX_COEF20_21 0x1d63
+#define VPP_MATRIX_COEF22 0x1d64
+#define VPP_MATRIX_OFFSET0_1 0x1d65
+#define VPP_MATRIX_OFFSET2 0x1d66
+#define VPP_MATRIX_PRE_OFFSET0_1 0x1d67
+#define VPP_MATRIX_PRE_OFFSET2 0x1d68
+#define VPP_DUMMY_DATA1 0x1d69
+#define VPP_GAINOFF_CTRL0 0x1d6a
+#define VPP_GAINOFF_CTRL1 0x1d6b
+#define VPP_GAINOFF_CTRL2 0x1d6c
+#define VPP_GAINOFF_CTRL3 0x1d6d
+#define VPP_GAINOFF_CTRL4 0x1d6e
+#define VPP_CHROMA_ADDR_PORT 0x1d70
+#define VPP_CHROMA_DATA_PORT 0x1d71
+#define VPP_GCLK_CTRL0 0x1d72
+#define VPP_GCLK_CTRL1 0x1d73
+#define VPP_SC_GCLK_CTRL 0x1d74
+#define VPP_MISC1 0x1d76
+#define VPP_BLACKEXT_CTRL 0x1d80
+#define VPP_DNLP_CTRL_00 0x1d81
+#define VPP_DNLP_CTRL_01 0x1d82
+#define VPP_DNLP_CTRL_02 0x1d83
+#define VPP_DNLP_CTRL_03 0x1d84
+#define VPP_DNLP_CTRL_04 0x1d85
+#define VPP_DNLP_CTRL_05 0x1d86
+#define VPP_DNLP_CTRL_06 0x1d87
+#define VPP_DNLP_CTRL_07 0x1d88
+#define VPP_DNLP_CTRL_08 0x1d89
+#define VPP_DNLP_CTRL_09 0x1d8a
+#define VPP_DNLP_CTRL_10 0x1d8b
+#define VPP_DNLP_CTRL_11 0x1d8c
+#define VPP_DNLP_CTRL_12 0x1d8d
+#define VPP_DNLP_CTRL_13 0x1d8e
+#define VPP_DNLP_CTRL_14 0x1d8f
+#define VPP_DNLP_CTRL_15 0x1d90
+#define VPP_PEAKING_HGAIN 0x1d91
+#define VPP_PEAKING_VGAIN 0x1d92
+#define VPP_PEAKING_NLP_1 0x1d93
+#define VPP_PEAKING_NLP_2 0x1d94
+#define VPP_PEAKING_NLP_3 0x1d95
+#define VPP_PEAKING_NLP_4 0x1d96
+#define VPP_PEAKING_NLP_5 0x1d97
+#define VPP_SHARP_LIMIT 0x1d98
+#define VPP_VLTI_CTRL 0x1d99
+#define VPP_HLTI_CTRL 0x1d9a
+#define VPP_CTI_CTRL 0x1d9b
+#define VPP_BLUE_STRETCH_1 0x1d9c
+#define VPP_BLUE_STRETCH_2 0x1d9d
+#define VPP_BLUE_STRETCH_3 0x1d9e
+#define VPP_CCORING_CTRL 0x1da0
+#define VPP_VE_ENABLE_CTRL 0x1da1
+#define VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH 0x1da2
+#define VPP_VE_DEMO_CENTER_BAR 0x1da3
+#define VPP_VE_H_V_SIZE 0x1da4
+#define VPP_VDO_MEAS_CTRL 0x1da8
+#define VPP_VDO_MEAS_VS_COUNT_HI 0x1da9
+#define VPP_VDO_MEAS_VS_COUNT_LO 0x1daa
+#define VPP_INPUT_CTRL 0x1dab
+#define VPP_CTI_CTRL2 0x1dac
+#define VPP_PEAKING_SAT_THD1 0x1dad
+#define VPP_PEAKING_SAT_THD2 0x1dae
+#define VPP_PEAKING_SAT_THD3 0x1daf
+#define VPP_PEAKING_SAT_THD4 0x1db0
+#define VPP_PEAKING_SAT_THD5 0x1db1
+#define VPP_PEAKING_SAT_THD6 0x1db2
+#define VPP_PEAKING_SAT_THD7 0x1db3
+#define VPP_PEAKING_SAT_THD8 0x1db4
+#define VPP_PEAKING_SAT_THD9 0x1db5
+#define VPP_PEAKING_GAIN_ADD1 0x1db6
+#define VPP_PEAKING_GAIN_ADD2 0x1db7
+#define VPP_PEAKING_DNLP 0x1db8
+#define VPP_SHARP_DEMO_WIN_CTRL1 0x1db9
+#define VPP_SHARP_DEMO_WIN_CTRL2 0x1dba
+#define VPP_FRONT_HLTI_CTRL 0x1dbb
+#define VPP_FRONT_CTI_CTRL 0x1dbc
+#define VPP_FRONT_CTI_CTRL2 0x1dbd
+#define VPP_OSD_VSC_PHASE_STEP 0x1dc0
+#define VPP_OSD_VSC_INI_PHASE 0x1dc1
+#define VPP_OSD_VSC_CTRL0 0x1dc2
+#define VPP_OSD_HSC_PHASE_STEP 0x1dc3
+#define VPP_OSD_HSC_INI_PHASE 0x1dc4
+#define VPP_OSD_HSC_CTRL0 0x1dc5
+#define VPP_OSD_HSC_INI_PAT_CTRL 0x1dc6
+#define VPP_OSD_SC_DUMMY_DATA 0x1dc7
+#define VPP_OSD_SC_CTRL0 0x1dc8
+#define VPP_OSD_SCI_WH_M1 0x1dc9
+#define VPP_OSD_SCO_H_START_END 0x1dca
+#define VPP_OSD_SCO_V_START_END 0x1dcb
+#define VPP_OSD_SCALE_COEF_IDX 0x1dcc
+#define VPP_OSD_SCALE_COEF 0x1dcd
+#define VPP_INT_LINE_NUM 0x1dce
+
+/* viu2 */
+#define VIU2_ADDR_START 0x1e00
+#define VIU2_ADDR_END 0x1eff
+#define VIU2_SW_RESET 0x1e01
+#define VIU2_OSD1_CTRL_STAT 0x1e10
+#define VIU2_OSD1_CTRL_STAT2 0x1e2d
+#define VIU2_OSD1_COLOR_ADDR 0x1e11
+#define VIU2_OSD1_COLOR 0x1e12
+#define VIU2_OSD1_TCOLOR_AG0 0x1e17
+#define VIU2_OSD1_TCOLOR_AG1 0x1e18
+#define VIU2_OSD1_TCOLOR_AG2 0x1e19
+#define VIU2_OSD1_TCOLOR_AG3 0x1e1a
+#define VIU2_OSD1_BLK0_CFG_W0 0x1e1b
+#define VIU2_OSD1_BLK1_CFG_W0 0x1e1f
+#define VIU2_OSD1_BLK2_CFG_W0 0x1e23
+#define VIU2_OSD1_BLK3_CFG_W0 0x1e27
+#define VIU2_OSD1_BLK0_CFG_W1 0x1e1c
+#define VIU2_OSD1_BLK1_CFG_W1 0x1e20
+#define VIU2_OSD1_BLK2_CFG_W1 0x1e24
+#define VIU2_OSD1_BLK3_CFG_W1 0x1e28
+#define VIU2_OSD1_BLK0_CFG_W2 0x1e1d
+#define VIU2_OSD1_BLK1_CFG_W2 0x1e21
+#define VIU2_OSD1_BLK2_CFG_W2 0x1e25
+#define VIU2_OSD1_BLK3_CFG_W2 0x1e29
+#define VIU2_OSD1_BLK0_CFG_W3 0x1e1e
+#define VIU2_OSD1_BLK1_CFG_W3 0x1e22
+#define VIU2_OSD1_BLK2_CFG_W3 0x1e26
+#define VIU2_OSD1_BLK3_CFG_W3 0x1e2a
+#define VIU2_OSD1_BLK0_CFG_W4 0x1e13
+#define VIU2_OSD1_BLK1_CFG_W4 0x1e14
+#define VIU2_OSD1_BLK2_CFG_W4 0x1e15
+#define VIU2_OSD1_BLK3_CFG_W4 0x1e16
+#define VIU2_OSD1_FIFO_CTRL_STAT 0x1e2b
+#define VIU2_OSD1_TEST_RDDATA 0x1e2c
+#define VIU2_OSD1_PROT_CTRL 0x1e2e
+#define VIU2_OSD2_CTRL_STAT 0x1e30
+#define VIU2_OSD2_CTRL_STAT2 0x1e4d
+#define VIU2_OSD2_COLOR_ADDR 0x1e31
+#define VIU2_OSD2_COLOR 0x1e32
+#define VIU2_OSD2_HL1_H_START_END 0x1e33
+#define VIU2_OSD2_HL1_V_START_END 0x1e34
+#define VIU2_OSD2_HL2_H_START_END 0x1e35
+#define VIU2_OSD2_HL2_V_START_END 0x1e36
+#define VIU2_OSD2_TCOLOR_AG0 0x1e37
+#define VIU2_OSD2_TCOLOR_AG1 0x1e38
+#define VIU2_OSD2_TCOLOR_AG2 0x1e39
+#define VIU2_OSD2_TCOLOR_AG3 0x1e3a
+#define VIU2_OSD2_BLK0_CFG_W0 0x1e3b
+#define VIU2_OSD2_BLK1_CFG_W0 0x1e3f
+#define VIU2_OSD2_BLK2_CFG_W0 0x1e43
+#define VIU2_OSD2_BLK3_CFG_W0 0x1e47
+#define VIU2_OSD2_BLK0_CFG_W1 0x1e3c
+#define VIU2_OSD2_BLK1_CFG_W1 0x1e40
+#define VIU2_OSD2_BLK2_CFG_W1 0x1e44
+#define VIU2_OSD2_BLK3_CFG_W1 0x1e48
+#define VIU2_OSD2_BLK0_CFG_W2 0x1e3d
+#define VIU2_OSD2_BLK1_CFG_W2 0x1e41
+#define VIU2_OSD2_BLK2_CFG_W2 0x1e45
+#define VIU2_OSD2_BLK3_CFG_W2 0x1e49
+#define VIU2_OSD2_BLK0_CFG_W3 0x1e3e
+#define VIU2_OSD2_BLK1_CFG_W3 0x1e42
+#define VIU2_OSD2_BLK2_CFG_W3 0x1e46
+#define VIU2_OSD2_BLK3_CFG_W3 0x1e4a
+#define VIU2_OSD2_BLK0_CFG_W4 0x1e64
+#define VIU2_OSD2_BLK1_CFG_W4 0x1e65
+#define VIU2_OSD2_BLK2_CFG_W4 0x1e66
+#define VIU2_OSD2_BLK3_CFG_W4 0x1e67
+#define VIU2_OSD2_FIFO_CTRL_STAT 0x1e4b
+#define VIU2_OSD2_TEST_RDDATA 0x1e4c
+#define VIU2_OSD2_PROT_CTRL 0x1e4e
+#define VIU2_VD1_IF0_GEN_REG 0x1e50
+#define VIU2_VD1_IF0_CANVAS0 0x1e51
+#define VIU2_VD1_IF0_CANVAS1 0x1e52
+#define VIU2_VD1_IF0_LUMA_X0 0x1e53
+#define VIU2_VD1_IF0_LUMA_Y0 0x1e54
+#define VIU2_VD1_IF0_CHROMA_X0 0x1e55
+#define VIU2_VD1_IF0_CHROMA_Y0 0x1e56
+#define VIU2_VD1_IF0_LUMA_X1 0x1e57
+#define VIU2_VD1_IF0_LUMA_Y1 0x1e58
+#define VIU2_VD1_IF0_CHROMA_X1 0x1e59
+#define VIU2_VD1_IF0_CHROMA_Y1 0x1e5a
+#define VIU2_VD1_IF0_RPT_LOOP 0x1e5b
+#define VIU2_VD1_IF0_LUMA0_RPT_PAT 0x1e5c
+#define VIU2_VD1_IF0_CHROMA0_RPT_PAT 0x1e5d
+#define VIU2_VD1_IF0_LUMA1_RPT_PAT 0x1e5e
+#define VIU2_VD1_IF0_CHROMA1_RPT_PAT 0x1e5f
+#define VIU2_VD1_IF0_LUMA_PSEL 0x1e60
+#define VIU2_VD1_IF0_CHROMA_PSEL 0x1e61
+#define VIU2_VD1_IF0_DUMMY_PIXEL 0x1e62
+#define VIU2_VD1_IF0_LUMA_FIFO_SIZE 0x1e63
+#define VIU2_VD1_IF0_RANGE_MAP_Y 0x1e6a
+#define VIU2_VD1_IF0_RANGE_MAP_CB 0x1e6b
+#define VIU2_VD1_IF0_RANGE_MAP_CR 0x1e6c
+#define VIU2_VD1_IF0_GEN_REG2 0x1e6d
+#define VIU2_VD1_IF0_PROT_CNTL 0x1e6e
+#define VIU2_VD1_FMT_CTRL 0x1e68
+#define VIU2_VD1_FMT_W 0x1e69
+
+/* encode */
+#define ENCP_VFIFO2VD_CTL 0x1b58
+#define ENCP_VFIFO2VD_PIXEL_START 0x1b59
+#define ENCP_VFIFO2VD_PIXEL_END 0x1b5a
+#define ENCP_VFIFO2VD_LINE_TOP_START 0x1b5b
+#define ENCP_VFIFO2VD_LINE_TOP_END 0x1b5c
+#define ENCP_VFIFO2VD_LINE_BOT_START 0x1b5d
+#define ENCP_VFIFO2VD_LINE_BOT_END 0x1b5e
+#define VENC_SYNC_ROUTE 0x1b60
+#define VENC_VIDEO_EXSRC 0x1b61
+#define VENC_DVI_SETTING 0x1b62
+#define VENC_C656_CTRL 0x1b63
+#define VENC_UPSAMPLE_CTRL0 0x1b64
+#define VENC_UPSAMPLE_CTRL1 0x1b65
+#define VENC_UPSAMPLE_CTRL2 0x1b66
+#define TCON_INVERT_CTL 0x1b67
+#define VENC_VIDEO_PROG_MODE 0x1b68
+#define VENC_ENCI_LINE 0x1b69
+#define VENC_ENCI_PIXEL 0x1b6a
+#define VENC_ENCP_LINE 0x1b6b
+#define VENC_ENCP_PIXEL 0x1b6c
+#define VENC_STATA 0x1b6d
+#define VENC_INTCTRL 0x1b6e
+#define VENC_INTFLAG 0x1b6f
+#define VENC_VIDEO_TST_EN 0x1b70
+#define VENC_VIDEO_TST_MDSEL 0x1b71
+#define VENC_VIDEO_TST_Y 0x1b72
+#define VENC_VIDEO_TST_CB 0x1b73
+#define VENC_VIDEO_TST_CR 0x1b74
+#define VENC_VIDEO_TST_CLRBAR_STRT 0x1b75
+#define VENC_VIDEO_TST_CLRBAR_WIDTH 0x1b76
+#define VENC_VIDEO_TST_VDCNT_STSET 0x1b77
+#define VENC_VDAC_DACSEL0 0x1b78
+#define VENC_VDAC_DACSEL1 0x1b79
+#define VENC_VDAC_DACSEL2 0x1b7a
+#define VENC_VDAC_DACSEL3 0x1b7b
+#define VENC_VDAC_DACSEL4 0x1b7c
+#define VENC_VDAC_DACSEL5 0x1b7d
+#define VENC_VDAC_SETTING 0x1b7e
+#define VENC_VDAC_TST_VAL 0x1b7f
+#define VENC_VDAC_DAC0_GAINCTRL 0x1bf0
+#define VENC_VDAC_DAC0_OFFSET 0x1bf1
+#define VENC_VDAC_DAC1_GAINCTRL 0x1bf2
+#define VENC_VDAC_DAC1_OFFSET 0x1bf3
+#define VENC_VDAC_DAC2_GAINCTRL 0x1bf4
+#define VENC_VDAC_DAC2_OFFSET 0x1bf5
+#define VENC_VDAC_DAC3_GAINCTRL 0x1bf6
+#define VENC_VDAC_DAC3_OFFSET 0x1bf7
+#define VENC_VDAC_DAC4_GAINCTRL 0x1bf8
+#define VENC_VDAC_DAC4_OFFSET 0x1bf9
+#define VENC_VDAC_DAC5_GAINCTRL 0x1bfa
+#define VENC_VDAC_DAC5_OFFSET 0x1bfb
+#define VENC_VDAC_FIFO_CTRL 0x1bfc
+#define ENCL_TCON_INVERT_CTL 0x1bfd
+#define ENCP_VIDEO_EN 0x1b80
+#define ENCP_VIDEO_SYNC_MODE 0x1b81
+#define ENCP_MACV_EN 0x1b82
+#define ENCP_VIDEO_Y_SCL 0x1b83
+#define ENCP_VIDEO_PB_SCL 0x1b84
+#define ENCP_VIDEO_PR_SCL 0x1b85
+#define ENCP_VIDEO_SYNC_SCL 0x1b86
+#define ENCP_VIDEO_MACV_SCL 0x1b87
+#define ENCP_VIDEO_Y_OFFST 0x1b88
+#define ENCP_VIDEO_PB_OFFST 0x1b89
+#define ENCP_VIDEO_PR_OFFST 0x1b8a
+#define ENCP_VIDEO_SYNC_OFFST 0x1b8b
+#define ENCP_VIDEO_MACV_OFFST 0x1b8c
+#define ENCP_VIDEO_MODE 0x1b8d
+#define ENCP_VIDEO_MODE_ADV 0x1b8e
+#define ENCP_DBG_PX_RST 0x1b90
+#define ENCP_DBG_LN_RST 0x1b91
+#define ENCP_DBG_PX_INT 0x1b92
+#define ENCP_DBG_LN_INT 0x1b93
+#define ENCP_VIDEO_YFP1_HTIME 0x1b94
+#define ENCP_VIDEO_YFP2_HTIME 0x1b95
+#define ENCP_VIDEO_YC_DLY 0x1b96
+#define ENCP_VIDEO_MAX_PXCNT 0x1b97
+#define ENCP_VIDEO_HSPULS_BEGIN 0x1b98
+#define ENCP_VIDEO_HSPULS_END 0x1b99
+#define ENCP_VIDEO_HSPULS_SWITCH 0x1b9a
+#define ENCP_VIDEO_VSPULS_BEGIN 0x1b9b
+#define ENCP_VIDEO_VSPULS_END 0x1b9c
+#define ENCP_VIDEO_VSPULS_BLINE 0x1b9d
+#define ENCP_VIDEO_VSPULS_ELINE 0x1b9e
+#define ENCP_VIDEO_EQPULS_BEGIN 0x1b9f
+#define ENCP_VIDEO_EQPULS_END 0x1ba0
+#define ENCP_VIDEO_EQPULS_BLINE 0x1ba1
+#define ENCP_VIDEO_EQPULS_ELINE 0x1ba2
+#define ENCP_VIDEO_HAVON_END 0x1ba3
+#define ENCP_VIDEO_HAVON_BEGIN 0x1ba4
+#define ENCP_VIDEO_VAVON_ELINE 0x1baf
+#define ENCP_VIDEO_VAVON_BLINE 0x1ba6
+#define ENCP_VIDEO_HSO_BEGIN 0x1ba7
+#define ENCP_VIDEO_HSO_END 0x1ba8
+#define ENCP_VIDEO_VSO_BEGIN 0x1ba9
+#define ENCP_VIDEO_VSO_END 0x1baa
+#define ENCP_VIDEO_VSO_BLINE 0x1bab
+#define ENCP_VIDEO_VSO_ELINE 0x1bac
+#define ENCP_VIDEO_SYNC_WAVE_CURVE 0x1bad
+#define ENCP_VIDEO_MAX_LNCNT 0x1bae
+#define ENCP_VIDEO_SY_VAL 0x1bb0
+#define ENCP_VIDEO_SY2_VAL 0x1bb1
+#define ENCP_VIDEO_BLANKY_VAL 0x1bb2
+#define ENCP_VIDEO_BLANKPB_VAL 0x1bb3
+#define ENCP_VIDEO_BLANKPR_VAL 0x1bb4
+#define ENCP_VIDEO_HOFFST 0x1bb5
+#define ENCP_VIDEO_VOFFST 0x1bb6
+#define ENCP_VIDEO_RGB_CTRL 0x1bb7
+#define ENCP_VIDEO_FILT_CTRL 0x1bb8
+#define ENCP_VIDEO_OFLD_VPEQ_OFST 0x1bb9
+#define ENCP_VIDEO_OFLD_VOAV_OFST 0x1bba
+#define ENCP_VIDEO_MATRIX_CB 0x1bbb
+#define ENCP_VIDEO_MATRIX_CR 0x1bbc
+#define ENCP_VIDEO_RGBIN_CTRL 0x1bbd
+#define ENCP_MACV_BLANKY_VAL 0x1bc0
+#define ENCP_MACV_MAXY_VAL 0x1bc1
+#define ENCP_MACV_1ST_PSSYNC_STRT 0x1bc2
+#define ENCP_MACV_PSSYNC_STRT 0x1bc3
+#define ENCP_MACV_AGC_STRT 0x1bc4
+#define ENCP_MACV_AGC_END 0x1bc5
+#define ENCP_MACV_WAVE_END 0x1bc6
+#define ENCP_MACV_STRTLINE 0x1bc7
+#define ENCP_MACV_ENDLINE 0x1bc8
+#define ENCP_MACV_TS_CNT_MAX_L 0x1bc9
+#define ENCP_MACV_TS_CNT_MAX_H 0x1bca
+#define ENCP_MACV_TIME_DOWN 0x1bcb
+#define ENCP_MACV_TIME_LO 0x1bcc
+#define ENCP_MACV_TIME_UP 0x1bcd
+#define ENCP_MACV_TIME_RST 0x1bce
+#define ENCP_VBI_CTRL 0x1bd0
+#define ENCP_VBI_SETTING 0x1bd1
+#define ENCP_VBI_BEGIN 0x1bd2
+#define ENCP_VBI_WIDTH 0x1bd3
+#define ENCP_VBI_HVAL 0x1bd4
+#define ENCP_VBI_DATA0 0x1bd5
+#define ENCP_VBI_DATA1 0x1bd6
+#define C656_HS_ST 0x1be0
+#define C656_HS_ED 0x1be1
+#define C656_VS_LNST_E 0x1be2
+#define C656_VS_LNST_O 0x1be3
+#define C656_VS_LNED_E 0x1be4
+#define C656_VS_LNED_O 0x1be5
+#define C656_FS_LNST 0x1be6
+#define C656_FS_LNED 0x1be7
+#define ENCI_VIDEO_MODE 0x1b00
+#define ENCI_VIDEO_MODE_ADV 0x1b01
+#define ENCI_VIDEO_FSC_ADJ 0x1b02
+#define ENCI_VIDEO_BRIGHT 0x1b03
+#define ENCI_VIDEO_CONT 0x1b04
+#define ENCI_VIDEO_SAT 0x1b05
+#define ENCI_VIDEO_HUE 0x1b06
+#define ENCI_VIDEO_SCH 0x1b07
+#define ENCI_SYNC_MODE 0x1b08
+#define ENCI_SYNC_CTRL 0x1b09
+#define ENCI_SYNC_HSO_BEGIN 0x1b0a
+#define ENCI_SYNC_HSO_END 0x1b0b
+#define ENCI_SYNC_VSO_EVN 0x1b0c
+#define ENCI_SYNC_VSO_ODD 0x1b0d
+#define ENCI_SYNC_VSO_EVNLN 0x1b0e
+#define ENCI_SYNC_VSO_ODDLN 0x1b0f
+#define ENCI_SYNC_HOFFST 0x1b10
+#define ENCI_SYNC_VOFFST 0x1b11
+#define ENCI_SYNC_ADJ 0x1b12
+#define ENCI_RGB_SETTING 0x1b13
+#define ENCI_DE_H_BEGIN 0x1b16
+#define ENCI_DE_H_END 0x1b17
+#define ENCI_DE_V_BEGIN_EVEN 0x1b18
+#define ENCI_DE_V_END_EVEN 0x1b19
+#define ENCI_DE_V_BEGIN_ODD 0x1b1a
+#define ENCI_DE_V_END_ODD 0x1b1b
+#define ENCI_VBI_SETTING 0x1b20
+#define ENCI_VBI_CCDT_EVN 0x1b21
+#define ENCI_VBI_CCDT_ODD 0x1b22
+#define ENCI_VBI_CC525_LN 0x1b23
+#define ENCI_VBI_CC625_LN 0x1b24
+#define ENCI_VBI_WSSDT 0x1b25
+#define ENCI_VBI_WSS_LN 0x1b26
+#define ENCI_VBI_CGMSDT_L 0x1b27
+#define ENCI_VBI_CGMSDT_H 0x1b28
+#define ENCI_VBI_CGMS_LN 0x1b29
+#define ENCI_VBI_TTX_HTIME 0x1b2a
+#define ENCI_VBI_TTX_LN 0x1b2b
+#define ENCI_VBI_TTXDT0 0x1b2c
+#define ENCI_VBI_TTXDT1 0x1b2d
+#define ENCI_VBI_TTXDT2 0x1b2e
+#define ENCI_VBI_TTXDT3 0x1b2f
+#define ENCI_MACV_N0 0x1b30
+#define ENCI_MACV_N1 0x1b31
+#define ENCI_MACV_N2 0x1b32
+#define ENCI_MACV_N3 0x1b33
+#define ENCI_MACV_N4 0x1b34
+#define ENCI_MACV_N5 0x1b35
+#define ENCI_MACV_N6 0x1b36
+#define ENCI_MACV_N7 0x1b37
+#define ENCI_MACV_N8 0x1b38
+#define ENCI_MACV_N9 0x1b39
+#define ENCI_MACV_N10 0x1b3a
+#define ENCI_MACV_N11 0x1b3b
+#define ENCI_MACV_N12 0x1b3c
+#define ENCI_MACV_N13 0x1b3d
+#define ENCI_MACV_N14 0x1b3e
+#define ENCI_MACV_N15 0x1b3f
+#define ENCI_MACV_N16 0x1b40
+#define ENCI_MACV_N17 0x1b41
+#define ENCI_MACV_N18 0x1b42
+#define ENCI_MACV_N19 0x1b43
+#define ENCI_MACV_N20 0x1b44
+#define ENCI_MACV_N21 0x1b45
+#define ENCI_MACV_N22 0x1b46
+#define ENCI_DBG_PX_RST 0x1b48
+#define ENCI_DBG_FLDLN_RST 0x1b49
+#define ENCI_DBG_PX_INT 0x1b4a
+#define ENCI_DBG_FLDLN_INT 0x1b4b
+#define ENCI_DBG_MAXPX 0x1b4c
+#define ENCI_DBG_MAXLN 0x1b4d
+#define ENCI_MACV_MAX_AMP 0x1b50
+#define ENCI_MACV_PULSE_LO 0x1b51
+#define ENCI_MACV_PULSE_HI 0x1b52
+#define ENCI_MACV_BKP_MAX 0x1b53
+#define ENCI_CFILT_CTRL 0x1b54
+#define ENCI_CFILT7 0x1b55
+#define ENCI_YC_DELAY 0x1b56
+#define ENCI_VIDEO_EN 0x1b57
+#define ENCI_DVI_HSO_BEGIN 0x1c00
+#define ENCI_DVI_HSO_END 0x1c01
+#define ENCI_DVI_VSO_BLINE_EVN 0x1c02
+#define ENCI_DVI_VSO_BLINE_ODD 0x1c03
+#define ENCI_DVI_VSO_ELINE_EVN 0x1c04
+#define ENCI_DVI_VSO_ELINE_ODD 0x1c05
+#define ENCI_DVI_VSO_BEGIN_EVN 0x1c06
+#define ENCI_DVI_VSO_BEGIN_ODD 0x1c07
+#define ENCI_DVI_VSO_END_EVN 0x1c08
+#define ENCI_DVI_VSO_END_ODD 0x1c09
+#define ENCI_CFILT_CTRL2 0x1c0a
+#define ENCI_DACSEL_0 0x1c0b
+#define ENCI_DACSEL_1 0x1c0c
+#define ENCP_DACSEL_0 0x1c0d
+#define ENCP_DACSEL_1 0x1c0e
+#define ENCP_MAX_LINE_SWITCH_POINT 0x1c0f
+#define ENCI_TST_EN 0x1c10
+#define ENCI_TST_MDSEL 0x1c11
+#define ENCI_TST_Y 0x1c12
+#define ENCI_TST_CB 0x1c13
+#define ENCI_TST_CR 0x1c14
+#define ENCI_TST_CLRBAR_STRT 0x1c15
+#define ENCI_TST_CLRBAR_WIDTH 0x1c16
+#define ENCI_TST_VDCNT_STSET 0x1c17
+#define ENCI_VFIFO2VD_CTL 0x1c18
+#define ENCI_VFIFO2VD_PIXEL_START 0x1c19
+#define ENCI_VFIFO2VD_PIXEL_END 0x1c1a
+#define ENCI_VFIFO2VD_LINE_TOP_START 0x1c1b
+#define ENCI_VFIFO2VD_LINE_TOP_END 0x1c1c
+#define ENCI_VFIFO2VD_LINE_BOT_START 0x1c1d
+#define ENCI_VFIFO2VD_LINE_BOT_END 0x1c1e
+#define ENCI_VFIFO2VD_CTL2 0x1c1f
+#define ENCT_VFIFO2VD_CTL 0x1c20
+#define ENCT_VFIFO2VD_PIXEL_START 0x1c21
+#define ENCT_VFIFO2VD_PIXEL_END 0x1c22
+#define ENCT_VFIFO2VD_LINE_TOP_START 0x1c23
+#define ENCT_VFIFO2VD_LINE_TOP_END 0x1c24
+#define ENCT_VFIFO2VD_LINE_BOT_START 0x1c25
+#define ENCT_VFIFO2VD_LINE_BOT_END 0x1c26
+#define ENCT_VFIFO2VD_CTL2 0x1c27
+#define ENCT_TST_EN 0x1c28
+#define ENCT_TST_MDSEL 0x1c29
+#define ENCT_TST_Y 0x1c2a
+#define ENCT_TST_CB 0x1c2b
+#define ENCT_TST_CR 0x1c2c
+#define ENCT_TST_CLRBAR_STRT 0x1c2d
+#define ENCT_TST_CLRBAR_WIDTH 0x1c2e
+#define ENCT_TST_VDCNT_STSET 0x1c2f
+#define ENCP_DVI_HSO_BEGIN 0x1c30
+#define ENCP_DVI_HSO_END 0x1c31
+#define ENCP_DVI_VSO_BLINE_EVN 0x1c32
+#define ENCP_DVI_VSO_BLINE_ODD 0x1c33
+#define ENCP_DVI_VSO_ELINE_EVN 0x1c34
+#define ENCP_DVI_VSO_ELINE_ODD 0x1c35
+#define ENCP_DVI_VSO_BEGIN_EVN 0x1c36
+#define ENCP_DVI_VSO_BEGIN_ODD 0x1c37
+#define ENCP_DVI_VSO_END_EVN 0x1c38
+#define ENCP_DVI_VSO_END_ODD 0x1c39
+#define ENCP_DE_H_BEGIN 0x1c3a
+#define ENCP_DE_H_END 0x1c3b
+#define ENCP_DE_V_BEGIN_EVEN 0x1c3c
+#define ENCP_DE_V_END_EVEN 0x1c3d
+#define ENCP_DE_V_BEGIN_ODD 0x1c3e
+#define ENCP_DE_V_END_ODD 0x1c3f
+#define ENCI_SYNC_LINE_LENGTH 0x1c40
+#define ENCI_SYNC_PIXEL_EN 0x1c41
+#define ENCI_SYNC_TO_LINE_EN 0x1c42
+#define ENCI_SYNC_TO_PIXEL 0x1c43
+#define ENCP_SYNC_LINE_LENGTH 0x1c44
+#define ENCP_SYNC_PIXEL_EN 0x1c45
+#define ENCP_SYNC_TO_LINE_EN 0x1c46
+#define ENCP_SYNC_TO_PIXEL 0x1c47
+#define ENCT_SYNC_LINE_LENGTH 0x1c48
+#define ENCT_SYNC_PIXEL_EN 0x1c49
+#define ENCT_SYNC_TO_LINE_EN 0x1c4a
+#define ENCT_SYNC_TO_PIXEL 0x1c4b
+#define ENCL_SYNC_LINE_LENGTH 0x1c4c
+#define ENCL_SYNC_PIXEL_EN 0x1c4d
+#define ENCL_SYNC_TO_LINE_EN 0x1c4e
+#define ENCL_SYNC_TO_PIXEL 0x1c4f
+#define ENCP_VFIFO2VD_CTL2 0x1c50
+#define VENC_DVI_SETTING_MORE 0x1c51
+#define VENC_VDAC_DAC4_FILT_CTRL0 0x1c54
+#define VENC_VDAC_DAC4_FILT_CTRL1 0x1c55
+#define VENC_VDAC_DAC5_FILT_CTRL0 0x1c56
+#define VENC_VDAC_DAC5_FILT_CTRL1 0x1c57
+#define VENC_VDAC_DAC0_FILT_CTRL0 0x1c58
+#define VENC_VDAC_DAC0_FILT_CTRL1 0x1c59
+#define VENC_VDAC_DAC1_FILT_CTRL0 0x1c5a
+#define VENC_VDAC_DAC1_FILT_CTRL1 0x1c5b
+#define VENC_VDAC_DAC2_FILT_CTRL0 0x1c5c
+#define VENC_VDAC_DAC2_FILT_CTRL1 0x1c5d
+#define VENC_VDAC_DAC3_FILT_CTRL0 0x1c5e
+#define VENC_VDAC_DAC3_FILT_CTRL1 0x1c5f
+#define ENCT_VIDEO_EN 0x1c60
+#define ENCT_VIDEO_Y_SCL 0x1c61
+#define ENCT_VIDEO_PB_SCL 0x1c62
+#define ENCT_VIDEO_PR_SCL 0x1c63
+#define ENCT_VIDEO_Y_OFFST 0x1c64
+#define ENCT_VIDEO_PB_OFFST 0x1c65
+#define ENCT_VIDEO_PR_OFFST 0x1c66
+#define ENCT_VIDEO_MODE 0x1c67
+#define ENCT_VIDEO_MODE_ADV 0x1c68
+#define ENCT_DBG_PX_RST 0x1c69
+#define ENCT_DBG_LN_RST 0x1c6a
+#define ENCT_DBG_PX_INT 0x1c6b
+#define ENCT_DBG_LN_INT 0x1c6c
+#define ENCT_VIDEO_YFP1_HTIME 0x1c6d
+#define ENCT_VIDEO_YFP2_HTIME 0x1c6e
+#define ENCT_VIDEO_YC_DLY 0x1c6f
+#define ENCT_VIDEO_MAX_PXCNT 0x1c70
+#define ENCT_VIDEO_HAVON_END 0x1c71
+#define ENCT_VIDEO_HAVON_BEGIN 0x1c72
+#define ENCT_VIDEO_VAVON_ELINE 0x1c73
+#define ENCT_VIDEO_VAVON_BLINE 0x1c74
+#define ENCT_VIDEO_HSO_BEGIN 0x1c75
+#define ENCT_VIDEO_HSO_END 0x1c76
+#define ENCT_VIDEO_VSO_BEGIN 0x1c77
+#define ENCT_VIDEO_VSO_END 0x1c78
+#define ENCT_VIDEO_VSO_BLINE 0x1c79
+#define ENCT_VIDEO_VSO_ELINE 0x1c7a
+#define ENCT_VIDEO_MAX_LNCNT 0x1c7b
+#define ENCT_VIDEO_BLANKY_VAL 0x1c7c
+#define ENCT_VIDEO_BLANKPB_VAL 0x1c7d
+#define ENCT_VIDEO_BLANKPR_VAL 0x1c7e
+#define ENCT_VIDEO_HOFFST 0x1c7f
+#define ENCT_VIDEO_VOFFST 0x1c80
+#define ENCT_VIDEO_RGB_CTRL 0x1c81
+#define ENCT_VIDEO_FILT_CTRL 0x1c82
+#define ENCT_VIDEO_OFLD_VPEQ_OFST 0x1c83
+#define ENCT_VIDEO_OFLD_VOAV_OFST 0x1c84
+#define ENCT_VIDEO_MATRIX_CB 0x1c85
+#define ENCT_VIDEO_MATRIX_CR 0x1c86
+#define ENCT_VIDEO_RGBIN_CTRL 0x1c87
+#define ENCT_MAX_LINE_SWITCH_POINT 0x1c88
+#define ENCT_DACSEL_0 0x1c89
+#define ENCT_DACSEL_1 0x1c8a
+#define ENCL_VFIFO2VD_CTL 0x1c90
+#define ENCL_VFIFO2VD_PIXEL_START 0x1c91
+#define ENCL_VFIFO2VD_PIXEL_END 0x1c92
+#define ENCL_VFIFO2VD_LINE_TOP_START 0x1c93
+#define ENCL_VFIFO2VD_LINE_TOP_END 0x1c94
+#define ENCL_VFIFO2VD_LINE_BOT_START 0x1c95
+#define ENCL_VFIFO2VD_LINE_BOT_END 0x1c96
+#define ENCL_VFIFO2VD_CTL2 0x1c97
+#define ENCL_TST_EN 0x1c98
+#define ENCL_TST_MDSEL 0x1c99
+#define ENCL_TST_Y 0x1c9a
+#define ENCL_TST_CB 0x1c9b
+#define ENCL_TST_CR 0x1c9c
+#define ENCL_TST_CLRBAR_STRT 0x1c9d
+#define ENCL_TST_CLRBAR_WIDTH 0x1c9e
+#define ENCL_TST_VDCNT_STSET 0x1c9f
+#define ENCL_VIDEO_EN 0x1ca0
+#define ENCL_VIDEO_Y_SCL 0x1ca1
+#define ENCL_VIDEO_PB_SCL 0x1ca2
+#define ENCL_VIDEO_PR_SCL 0x1ca3
+#define ENCL_VIDEO_Y_OFFST 0x1ca4
+#define ENCL_VIDEO_PB_OFFST 0x1ca5
+#define ENCL_VIDEO_PR_OFFST 0x1ca6
+#define ENCL_VIDEO_MODE 0x1ca7
+#define ENCL_VIDEO_MODE_ADV 0x1ca8
+#define ENCL_DBG_PX_RST 0x1ca9
+#define ENCL_DBG_LN_RST 0x1caa
+#define ENCL_DBG_PX_INT 0x1cab
+#define ENCL_DBG_LN_INT 0x1cac
+#define ENCL_VIDEO_YFP1_HTIME 0x1cad
+#define ENCL_VIDEO_YFP2_HTIME 0x1cae
+#define ENCL_VIDEO_YC_DLY 0x1caf
+#define ENCL_VIDEO_MAX_PXCNT 0x1cb0
+#define ENCL_VIDEO_HAVON_END 0x1cb1
+#define ENCL_VIDEO_HAVON_BEGIN 0x1cb2
+#define ENCL_VIDEO_VAVON_ELINE 0x1cb3
+#define ENCL_VIDEO_VAVON_BLINE 0x1cb4
+#define ENCL_VIDEO_HSO_BEGIN 0x1cb5
+#define ENCL_VIDEO_HSO_END 0x1cb6
+#define ENCL_VIDEO_VSO_BEGIN 0x1cb7
+#define ENCL_VIDEO_VSO_END 0x1cb8
+#define ENCL_VIDEO_VSO_BLINE 0x1cb9
+#define ENCL_VIDEO_VSO_ELINE 0x1cba
+#define ENCL_VIDEO_MAX_LNCNT 0x1cbb
+#define ENCL_VIDEO_BLANKY_VAL 0x1cbc
+#define ENCL_VIDEO_BLANKPB_VAL 0x1cbd
+#define ENCL_VIDEO_BLANKPR_VAL 0x1cbe
+#define ENCL_VIDEO_HOFFST 0x1cbf
+#define ENCL_VIDEO_VOFFST 0x1cc0
+#define ENCL_VIDEO_RGB_CTRL 0x1cc1
+#define ENCL_VIDEO_FILT_CTRL 0x1cc2
+#define ENCL_VIDEO_OFLD_VPEQ_OFST 0x1cc3
+#define ENCL_VIDEO_OFLD_VOAV_OFST 0x1cc4
+#define ENCL_VIDEO_MATRIX_CB 0x1cc5
+#define ENCL_VIDEO_MATRIX_CR 0x1cc6
+#define ENCL_VIDEO_RGBIN_CTRL 0x1cc7
+#define ENCL_MAX_LINE_SWITCH_POINT 0x1cc8
+#define ENCL_DACSEL_0 0x1cc9
+#define ENCL_DACSEL_1 0x1cca
+#define RDMA_AHB_START_ADDR_MAN 0x1100
+#define RDMA_AHB_END_ADDR_MAN 0x1101
+#define RDMA_AHB_START_ADDR_1 0x1102
+#define RDMA_AHB_END_ADDR_1 0x1103
+#define RDMA_AHB_START_ADDR_2 0x1104
+#define RDMA_AHB_END_ADDR_2 0x1105
+#define RDMA_AHB_START_ADDR_3 0x1106
+#define RDMA_AHB_END_ADDR_3 0x1107
+#define RDMA_AHB_START_ADDR_4 0x1108
+#define RDMA_AHB_END_ADDR_4 0x1109
+#define RDMA_AHB_START_ADDR_5 0x110a
+#define RDMA_AHB_END_ADDR_5 0x110b
+#define RDMA_AHB_START_ADDR_6 0x110c
+#define RDMA_AHB_END_ADDR_6 0x110d
+#define RDMA_AHB_START_ADDR_7 0x110e
+#define RDMA_AHB_END_ADDR_7 0x110f
+#define RDMA_ACCESS_AUTO 0x1110
+#define RDMA_ACCESS_AUTO2 0x1111
+#define RDMA_ACCESS_AUTO3 0x1112
+#define RDMA_ACCESS_MAN 0x1113
+#define RDMA_CTRL 0x1114
+#define RDMA_STATUS 0x1115
+#define RDMA_STATUS2 0x1116
+#define RDMA_STATUS3 0x1117
+#define L_GAMMA_CNTL_PORT 0x1400
+#define L_GAMMA_DATA_PORT 0x1401
+#define L_GAMMA_ADDR_PORT 0x1402
+#define L_GAMMA_VCOM_HSWITCH_ADDR 0x1403
+#define L_RGB_BASE_ADDR 0x1405
+#define L_RGB_COEFF_ADDR 0x1406
+#define L_POL_CNTL_ADDR 0x1407
+#define L_DITH_CNTL_ADDR 0x1408
+#define L_GAMMA_PROBE_CTRL 0x1409
+#define L_GAMMA_PROBE_COLOR_L 0x140a
+#define L_GAMMA_PROBE_COLOR_H 0x140b
+#define L_GAMMA_PROBE_HL_COLOR 0x140c
+#define L_GAMMA_PROBE_POS_X 0x140d
+#define L_GAMMA_PROBE_POS_Y 0x140e
+#define L_STH1_HS_ADDR 0x1410
+#define L_STH1_HE_ADDR 0x1411
+#define L_STH1_VS_ADDR 0x1412
+#define L_STH1_VE_ADDR 0x1413
+#define L_STH2_HS_ADDR 0x1414
+#define L_STH2_HE_ADDR 0x1415
+#define L_STH2_VS_ADDR 0x1416
+#define L_STH2_VE_ADDR 0x1417
+#define L_OEH_HS_ADDR 0x1418
+#define L_OEH_HE_ADDR 0x1419
+#define L_OEH_VS_ADDR 0x141a
+#define L_OEH_VE_ADDR 0x141b
+#define L_VCOM_HSWITCH_ADDR 0x141c
+#define L_VCOM_VS_ADDR 0x141d
+#define L_VCOM_VE_ADDR 0x141e
+#define L_CPV1_HS_ADDR 0x141f
+#define L_CPV1_HE_ADDR 0x1420
+#define L_CPV1_VS_ADDR 0x1421
+#define L_CPV1_VE_ADDR 0x1422
+#define L_CPV2_HS_ADDR 0x1423
+#define L_CPV2_HE_ADDR 0x1424
+#define L_CPV2_VS_ADDR 0x1425
+#define L_CPV2_VE_ADDR 0x1426
+#define L_STV1_HS_ADDR 0x1427
+#define L_STV1_HE_ADDR 0x1428
+#define L_STV1_VS_ADDR 0x1429
+#define L_STV1_VE_ADDR 0x142a
+#define L_STV2_HS_ADDR 0x142b
+#define L_STV2_HE_ADDR 0x142c
+#define L_STV2_VS_ADDR 0x142d
+#define L_STV2_VE_ADDR 0x142e
+#define L_OEV1_HS_ADDR 0x142f
+#define L_OEV1_HE_ADDR 0x1430
+#define L_OEV1_VS_ADDR 0x1431
+#define L_OEV1_VE_ADDR 0x1432
+#define L_OEV2_HS_ADDR 0x1433
+#define L_OEV2_HE_ADDR 0x1434
+#define L_OEV2_VS_ADDR 0x1435
+#define L_OEV2_VE_ADDR 0x1436
+#define L_OEV3_HS_ADDR 0x1437
+#define L_OEV3_HE_ADDR 0x1438
+#define L_OEV3_VS_ADDR 0x1439
+#define L_OEV3_VE_ADDR 0x143a
+#define L_LCD_PWR_ADDR 0x143b
+#define L_LCD_PWM0_LO_ADDR 0x143c
+#define L_LCD_PWM0_HI_ADDR 0x143d
+#define L_LCD_PWM1_LO_ADDR 0x143e
+#define L_LCD_PWM1_HI_ADDR 0x143f
+#define L_INV_CNT_ADDR 0x1440
+#define L_TCON_MISC_SEL_ADDR 0x1441
+#define L_DUAL_PORT_CNTL_ADDR 0x1442
+#define MLVDS_CLK_CTL1_HI 0x1443
+#define MLVDS_CLK_CTL1_LO 0x1444
+#define L_TCON_DOUBLE_CTL 0x1449
+#define L_TCON_PATTERN_HI 0x144a
+#define L_TCON_PATTERN_LO 0x144b
+#define LDIM_BL_ADDR_PORT 0x144e
+#define LDIM_BL_DATA_PORT 0x144f
+#define L_DE_HS_ADDR 0x1451
+#define L_DE_HE_ADDR 0x1452
+#define L_DE_VS_ADDR 0x1453
+#define L_DE_VE_ADDR 0x1454
+#define L_HSYNC_HS_ADDR 0x1455
+#define L_HSYNC_HE_ADDR 0x1456
+#define L_HSYNC_VS_ADDR 0x1457
+#define L_HSYNC_VE_ADDR 0x1458
+#define L_VSYNC_HS_ADDR 0x1459
+#define L_VSYNC_HE_ADDR 0x145a
+#define L_VSYNC_VS_ADDR 0x145b
+#define L_VSYNC_VE_ADDR 0x145c
+#define L_LCD_MCU_CTL 0x145d
+#define DUAL_MLVDS_CTL 0x1460
+#define DUAL_MLVDS_LINE_START 0x1461
+#define DUAL_MLVDS_LINE_END 0x1462
+#define DUAL_MLVDS_PIXEL_W_START_L 0x1463
+#define DUAL_MLVDS_PIXEL_W_END_L 0x1464
+#define DUAL_MLVDS_PIXEL_W_START_R 0x1465
+#define DUAL_MLVDS_PIXEL_W_END_R 0x1466
+#define DUAL_MLVDS_PIXEL_R_START_L 0x1467
+#define DUAL_MLVDS_PIXEL_R_CNT_L 0x1468
+#define DUAL_MLVDS_PIXEL_R_START_R 0x1469
+#define DUAL_MLVDS_PIXEL_R_CNT_R 0x146a
+#define V_INVERSION_PIXEL 0x1470
+#define V_INVERSION_LINE 0x1471
+#define V_INVERSION_CONTROL 0x1472
+#define MLVDS2_CONTROL 0x1474
+#define MLVDS2_CONFIG_HI 0x1475
+#define MLVDS2_CONFIG_LO 0x1476
+#define MLVDS2_DUAL_GATE_WR_START 0x1477
+#define MLVDS2_DUAL_GATE_WR_END 0x1478
+#define MLVDS2_DUAL_GATE_RD_START 0x1479
+#define MLVDS2_DUAL_GATE_RD_END 0x147a
+#define MLVDS2_SECOND_RESET_CTL 0x147b
+#define MLVDS2_DUAL_GATE_CTL_HI 0x147c
+#define MLVDS2_DUAL_GATE_CTL_LO 0x147d
+#define MLVDS2_RESET_CONFIG_HI 0x147e
+#define MLVDS2_RESET_CONFIG_LO 0x147f
+#define GAMMA_CNTL_PORT 0x1480
+#define GAMMA_DATA_PORT 0x1481
+#define GAMMA_ADDR_PORT 0x1482
+#define GAMMA_VCOM_HSWITCH_ADDR 0x1483
+#define RGB_BASE_ADDR 0x1485
+#define RGB_COEFF_ADDR 0x1486
+#define POL_CNTL_ADDR 0x1487
+#define DITH_CNTL_ADDR 0x1488
+#define GAMMA_PROBE_CTRL 0x1489
+#define GAMMA_PROBE_COLOR_L 0x148a
+#define GAMMA_PROBE_COLOR_H 0x148b
+#define GAMMA_PROBE_HL_COLOR 0x148c
+#define GAMMA_PROBE_POS_X 0x148d
+#define GAMMA_PROBE_POS_Y 0x148e
+#define STH1_HS_ADDR 0x1490
+#define STH1_HE_ADDR 0x1491
+#define STH1_VS_ADDR 0x1492
+#define STH1_VE_ADDR 0x1493
+#define STH2_HS_ADDR 0x1494
+#define STH2_HE_ADDR 0x1495
+#define STH2_VS_ADDR 0x1496
+#define STH2_VE_ADDR 0x1497
+#define OEH_HS_ADDR 0x1498
+#define OEH_HE_ADDR 0x1499
+#define OEH_VS_ADDR 0x149a
+#define OEH_VE_ADDR 0x149b
+#define VCOM_HSWITCH_ADDR 0x149c
+#define VCOM_VS_ADDR 0x149d
+#define VCOM_VE_ADDR 0x149e
+#define CPV1_HS_ADDR 0x149f
+#define CPV1_HE_ADDR 0x14a0
+#define CPV1_VS_ADDR 0x14a1
+#define CPV1_VE_ADDR 0x14a2
+#define CPV2_HS_ADDR 0x14a3
+#define CPV2_HE_ADDR 0x14a4
+#define CPV2_VS_ADDR 0x14a5
+#define CPV2_VE_ADDR 0x14a6
+#define STV1_HS_ADDR 0x14a7
+#define STV1_HE_ADDR 0x14a8
+#define STV1_VS_ADDR 0x14a9
+#define STV1_VE_ADDR 0x14aa
+#define STV2_HS_ADDR 0x14ab
+#define STV2_HE_ADDR 0x14ac
+#define STV2_VS_ADDR 0x14ad
+#define STV2_VE_ADDR 0x14ae
+#define OEV1_HS_ADDR 0x14af
+#define OEV1_HE_ADDR 0x14b0
+#define OEV1_VS_ADDR 0x14b1
+#define OEV1_VE_ADDR 0x14b2
+#define OEV2_HS_ADDR 0x14b3
+#define OEV2_HE_ADDR 0x14b4
+#define OEV2_VS_ADDR 0x14b5
+#define OEV2_VE_ADDR 0x14b6
+#define OEV3_HS_ADDR 0x14b7
+#define OEV3_HE_ADDR 0x14b8
+#define OEV3_VS_ADDR 0x14b9
+#define OEV3_VE_ADDR 0x14ba
+#define LCD_PWR_ADDR 0x14bb
+#define LCD_PWM0_LO_ADDR 0x14bc
+#define LCD_PWM0_HI_ADDR 0x14bd
+#define LCD_PWM1_LO_ADDR 0x14be
+#define LCD_PWM1_HI_ADDR 0x14bf
+#define INV_CNT_ADDR 0x14c0
+#define TCON_MISC_SEL_ADDR 0x14c1
+#define DUAL_PORT_CNTL_ADDR 0x14c2
+#define MLVDS_CONTROL 0x14c3
+#define MLVDS_RESET_PATTERN_HI 0x14c4
+#define MLVDS_RESET_PATTERN_LO 0x14c5
+#define MLVDS_RESET_PATTERN_EXT 0x14c6
+#define MLVDS_CONFIG_HI 0x14c7
+#define MLVDS_CONFIG_LO 0x14c8
+#define TCON_DOUBLE_CTL 0x14c9
+#define TCON_PATTERN_HI 0x14ca
+#define TCON_PATTERN_LO 0x14cb
+#define TCON_CONTROL_HI 0x14cc
+#define TCON_CONTROL_LO 0x14cd
+#define LVDS_BLANK_DATA_HI 0x14ce
+#define LVDS_BLANK_DATA_LO 0x14cf
+#define LVDS_PACK_CNTL_ADDR 0x14d0
+#define DE_HS_ADDR 0x14d1
+#define DE_HE_ADDR 0x14d2
+#define DE_VS_ADDR 0x14d3
+#define DE_VE_ADDR 0x14d4
+#define HSYNC_HS_ADDR 0x14d5
+#define HSYNC_HE_ADDR 0x14d6
+#define HSYNC_VS_ADDR 0x14d7
+#define HSYNC_VE_ADDR 0x14d8
+#define VSYNC_HS_ADDR 0x14d9
+#define VSYNC_HE_ADDR 0x14da
+#define VSYNC_VS_ADDR 0x14db
+#define VSYNC_VE_ADDR 0x14dc
+#define LCD_MCU_CTL 0x14dd
+#define LCD_MCU_DATA_0 0x14de
+#define LCD_MCU_DATA_1 0x14df
+#define LVDS_GEN_CNTL 0x14e0
+#define LVDS_PHY_CNTL0 0x14e1
+#define LVDS_PHY_CNTL1 0x14e2
+#define LVDS_PHY_CNTL2 0x14e3
+#define LVDS_PHY_CNTL3 0x14e4
+#define LVDS_PHY_CNTL4 0x14e5
+#define LVDS_PHY_CNTL5 0x14e6
+#define LVDS_SRG_TEST 0x14e8
+#define LVDS_BIST_MUX0 0x14e9
+#define LVDS_BIST_MUX1 0x14ea
+#define LVDS_BIST_FIXED0 0x14eb
+#define LVDS_BIST_FIXED1 0x14ec
+#define LVDS_BIST_CNTL0 0x14ed
+#define LVDS_CLKB_CLKA 0x14ee
+#define LVDS_PHY_CLK_CNTL 0x14ef
+#define LVDS_SER_EN 0x14f0
+#define LVDS_PHY_CNTL6 0x14f1
+#define LVDS_PHY_CNTL7 0x14f2
+#define LVDS_PHY_CNTL8 0x14f3
+#define MLVDS_CLK_CTL0_HI 0x14f4
+#define MLVDS_CLK_CTL0_LO 0x14f5
+#define MLVDS_DUAL_GATE_WR_START 0x14f6
+#define MLVDS_DUAL_GATE_WR_END 0x14f7
+#define MLVDS_DUAL_GATE_RD_START 0x14f8
+#define MLVDS_DUAL_GATE_RD_END 0x14f9
+#define MLVDS_SECOND_RESET_CTL 0x14fa
+#define MLVDS_DUAL_GATE_CTL_HI 0x14fb
+#define MLVDS_DUAL_GATE_CTL_LO 0x14fc
+#define MLVDS_RESET_CONFIG_HI 0x14fd
+#define MLVDS_RESET_CONFIG_LO 0x14fe
+#define VPU_OSD1_MMC_CTRL 0x2701
+#define VPU_OSD2_MMC_CTRL 0x2702
+#define VPU_VD1_MMC_CTRL 0x2703
+#define VPU_VD2_MMC_CTRL 0x2704
+#define VPU_DI_IF1_MMC_CTRL 0x2705
+#define VPU_DI_MEM_MMC_CTRL 0x2706
+#define VPU_DI_INP_MMC_CTRL 0x2707
+#define VPU_DI_MTNRD_MMC_CTRL 0x2708
+#define VPU_DI_CHAN2_MMC_CTRL 0x2709
+#define VPU_DI_MTNWR_MMC_CTRL 0x270a
+#define VPU_DI_NRWR_MMC_CTRL 0x270b
+#define VPU_DI_DIWR_MMC_CTRL 0x270c
+#define VPU_VDIN0_MMC_CTRL 0x270d
+#define VPU_VDIN1_MMC_CTRL 0x270e
+#define VPU_BT656_MMC_CTRL 0x270f
+#define VPU_TVD3D_MMC_CTRL 0x2710
+#define VPU_TVDVBI_MMC_CTRL 0x2711
+#define VPU_TVDVBI_VSLATCH_ADDR 0x2712
+#define VPU_TVDVBI_WRRSP_ADDR 0x2713
+#define VPU_VDIN_PRE_ARB_CTRL 0x2714
+#define VPU_VDISP_PRE_ARB_CTRL 0x2715
+#define VPU_VPUARB2_PRE_ARB_CTRL 0x2716
+#define VPU_OSD3_MMC_CTRL 0x2717
+#define VPU_OSD4_MMC_CTRL 0x2718
+#define VPU_VD3_MMC_CTRL 0x2719
+#define VPU_VIU_VENC_MUX_CTRL 0x271a
+#define VPU_HDMI_SETTING 0x271b
+#define ENCI_INFO_READ 0x271c
+#define ENCP_INFO_READ 0x271d
+#define ENCT_INFO_READ 0x271e
+#define ENCL_INFO_READ 0x271f
+#define VPU_SW_RESET 0x2720
+#define VPU_D2D3_MMC_CTRL 0x2721
+#define VPU_CONT_MMC_CTRL 0x2722
+#define VPU_CLK_GATE 0x2723
+#define VPU_RDMA_MMC_CTRL 0x2724
+#define VPU_MEM_PD_REG0 0x2725
+#define VPU_MEM_PD_REG1 0x2726
+#define VPU_HDMI_DATA_OVR 0x2727
+#define VPU_PROT1_MMC_CTRL 0x2728
+#define VPU_PROT2_MMC_CTRL 0x2729
+#define VPU_PROT3_MMC_CTRL 0x272a
+#define VPU_ARB4_V1_MMC_CTRL 0x272b
+#define VPU_ARB4_V2_MMC_CTRL 0x272c
+#define VPU_VPU_PWM_V0 0x2730
+#define VPU_VPU_PWM_V1 0x2731
+#define VPU_VPU_PWM_V2 0x2732
+#define VPU_VPU_PWM_V3 0x2733
+#define VPU_VPU_PWM_H0 0x2734
+#define VPU_VPU_PWM_H1 0x2735
+#define VPU_VPU_PWM_H2 0x2736
+#define VPU_VPU_PWM_H3 0x2737
+#define VPU_MISC_CTRL 0x2740
+#define VPU_ISP_GCLK_CTRL0 0x2741
+#define VPU_ISP_GCLK_CTRL1 0x2742
+#define VPU_VDIN_ASYNC_HOLD_CTRL 0x2743
+#define VPU_VDISP_ASYNC_HOLD_CTRL 0x2744
+#define VPU_VPUARB2_ASYNC_HOLD_CTRL 0x2745
+
+#define VPU_PROT1_CLK_GATE 0x2750
+#define VPU_PROT1_GEN_CNTL 0x2751
+#define VPU_PROT1_X_START_END 0x2752
+#define VPU_PROT1_Y_START_END 0x2753
+#define VPU_PROT1_Y_LEN_STEP 0x2754
+#define VPU_PROT1_RPT_LOOP 0x2755
+#define VPU_PROT1_RPT_PAT 0x2756
+#define VPU_PROT1_DDR 0x2757
+#define VPU_PROT1_RBUF_ROOM 0x2758
+#define VPU_PROT1_STAT_0 0x2759
+#define VPU_PROT1_STAT_1 0x275a
+#define VPU_PROT1_STAT_2 0x275b
+#define VPU_PROT1_REQ_ONOFF 0x275c
+#define VPU_PROT2_CLK_GATE 0x2760
+#define VPU_PROT2_GEN_CNTL 0x2761
+#define VPU_PROT2_X_START_END 0x2762
+#define VPU_PROT2_Y_START_END 0x2763
+#define VPU_PROT2_Y_LEN_STEP 0x2764
+#define VPU_PROT2_RPT_LOOP 0x2765
+#define VPU_PROT2_RPT_PAT 0x2766
+#define VPU_PROT2_DDR 0x2767
+#define VPU_PROT2_RBUF_ROOM 0x2768
+#define VPU_PROT2_STAT_0 0x2769
+#define VPU_PROT2_STAT_1 0x276a
+#define VPU_PROT2_STAT_2 0x276b
+#define VPU_PROT2_REQ_ONOFF 0x276c
+#define VPU_PROT3_CLK_GATE 0x2770
+#define VPU_PROT3_GEN_CNTL 0x2771
+#define VPU_PROT3_X_START_END 0x2772
+#define VPU_PROT3_Y_START_END 0x2773
+#define VPU_PROT3_Y_LEN_STEP 0x2774
+#define VPU_PROT3_RPT_LOOP 0x2775
+#define VPU_PROT3_RPT_PAT 0x2776
+#define VPU_PROT3_DDR 0x2777
+#define VPU_PROT3_RBUF_ROOM 0x2778
+#define VPU_PROT3_STAT_0 0x2779
+#define VPU_PROT3_STAT_1 0x277a
+#define VPU_PROT3_STAT_2 0x277b
+#define VPU_PROT3_REQ_ONOFF 0x277c
+
+/* osd super scale */
+#define OSDSR_HV_SIZEIN 0x3130
+#define OSDSR_CTRL_MODE 0x3131
+#define OSDSR_ABIC_HCOEF 0x3132
+#define OSDSR_YBIC_HCOEF 0x3133
+#define OSDSR_CBIC_HCOEF 0x3134
+#define OSDSR_ABIC_VCOEF 0x3135
+#define OSDSR_YBIC_VCOEF 0x3136
+#define OSDSR_CBIC_VCOEF 0x3137
+#define OSDSR_VAR_PARA 0x3138
+#define OSDSR_CONST_PARA 0x3139
+#define OSDSR_RKE_EXTWIN 0x313a
+#define OSDSR_UK_GRAD2DDIAG_TH_RATE 0x313b
+#define OSDSR_UK_GRAD2DDIAG_LIMIT 0x313c
+#define OSDSR_UK_GRAD2DADJA_TH_RATE 0x313d
+#define OSDSR_UK_GRAD2DADJA_LIMIT 0x313e
+#define OSDSR_UK_BST_GAIN 0x313f
+#define OSDSR_HVBLEND_TH 0x3140
+#define OSDSR_DEMO_WIND_TB 0x3141
+#define OSDSR_DEMO_WIND_LR 0x3142
+#define OSDSR_INT_BLANK_NUM 0x3143
+#define OSDSR_FRM_END_STAT 0x3144
+#define OSDSR_ABIC_HCOEF0 0x3145
+#define OSDSR_YBIC_HCOEF0 0x3146
+#define OSDSR_CBIC_HCOEF0 0x3147
+#define OSDSR_ABIC_VCOEF0 0x3148
+#define OSDSR_YBIC_VCOEF0 0x3149
+#define OSDSR_CBIC_VCOEF0 0x314a
+
+#endif
diff --git a/drivers/display/osd/vpp.h b/drivers/display/osd/vpp.h
new file mode 100644
index 0000000..6aa747a
--- /dev/null
+++ b/drivers/display/osd/vpp.h
@@ -0,0 +1,35 @@
+/*
+ * drivers/osd/vpp.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _VPP_H_
+#define _VPP_H_
+
+#define VPP_OSD2_PREBLEND           (1 << 17)
+#define VPP_OSD1_PREBLEND           (1 << 16)
+#define VPP_VD2_PREBLEND            (1 << 15)
+#define VPP_VD1_PREBLEND            (1 << 14)
+#define VPP_OSD2_POSTBLEND          (1 << 13)
+#define VPP_OSD1_POSTBLEND          (1 << 12)
+#define VPP_VD2_POSTBLEND           (1 << 11)
+#define VPP_VD1_POSTBLEND           (1 << 10)
+#define VPP_POSTBLEND_EN            (1 << 7)
+#define VPP_PRE_FG_OSD2             (1 << 5)
+#define VPP_PREBLEND_EN             (1 << 6)
+#define VPP_POST_FG_OSD2            (1 << 4)
+
+#endif
diff --git a/drivers/display/vout/Makefile b/drivers/display/vout/Makefile
new file mode 100644
index 0000000..236d050
--- /dev/null
+++ b/drivers/display/vout/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_AML_VOUT) += vout.o
+obj-$(CONFIG_AML_CVBS) += cvbs.o
\ No newline at end of file
diff --git a/drivers/display/vout/cvbs.c b/drivers/display/vout/cvbs.c
new file mode 100644
index 0000000..cf15285
--- /dev/null
+++ b/drivers/display/vout/cvbs.c
@@ -0,0 +1,442 @@
+/*
+ * drivers/display/vout/cvbs.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * Author: jets.yan@amlogic.com
+ *
+*/
+#include <common.h>
+#include <asm/arch/io.h>
+#include "cvbs_regs.h"
+#include "cvbs_config.h"
+
+/*----------------------------------------------------------------------------*/
+// global variables
+unsigned int cvbs_mode = 0xff; // default to 0xff as invalid vmode
+
+
+/*----------------------------------------------------------------------------*/
+// interface for registers of soc
+
+static int cvbs_write_reg_linear(unsigned int addr_linear, unsigned int value)
+{
+	writel((unsigned long)value, (unsigned long)addr_linear);
+
+	return 0;
+}
+
+static unsigned int cvbs_read_reg_linear(unsigned int addr_linear)
+{
+	return (unsigned int)readl((unsigned long)addr_linear);
+}
+
+static int cvbs_set_reg_bits(unsigned int addr_linear, unsigned int value, unsigned int start, unsigned int len)
+{
+	unsigned int data = 0;
+
+	data = cvbs_read_reg_linear(addr_linear);
+	data &= ~(((1<<len)-1)<<start);
+	data |= (value & ((1<<len)-1)) << start;
+	cvbs_write_reg_linear(addr_linear, data);
+
+	return 0;
+}
+
+static unsigned int cvbs_get_reg_bits(unsigned int addr_linear, unsigned int start, unsigned int len)
+{
+	unsigned int data;
+
+	data = cvbs_read_reg_linear(addr_linear);
+	data = (data>>start) & ((1<<len)-1);
+
+	return data;
+}
+
+static unsigned int cvbs_get_logic_addr(unsigned int bus, unsigned int addr_offset)
+{
+	unsigned int ret;
+
+	if (bus == BUS_TYPE_HIU)
+		ret = (HIU_BASE + ((addr_offset&0xff)<<2));
+	else if (bus == BUS_TYPE_VCBUS)
+		ret = (VCBUS_BASE + (addr_offset<<2));
+
+	return ret;
+}
+
+static int cvbs_write_hiu(unsigned int addr_offset, unsigned int value)
+{
+	return cvbs_write_reg_linear(cvbs_get_logic_addr(BUS_TYPE_HIU, addr_offset), value);
+}
+
+static int cvbs_read_hiu(unsigned int addr_offset)
+{
+	return cvbs_read_reg_linear(cvbs_get_logic_addr(BUS_TYPE_HIU, addr_offset));
+}
+
+static int cvbs_set_hiu_bits(unsigned int addr_offset, unsigned int value, unsigned int start, unsigned int len)
+{
+	return cvbs_set_reg_bits(cvbs_get_logic_addr(BUS_TYPE_HIU, addr_offset), value, start, len);
+}
+
+static int cvbs_get_hiu_bits(unsigned int addr_offset, unsigned int start, unsigned int len)
+{
+	return cvbs_get_reg_bits(cvbs_get_logic_addr(BUS_TYPE_HIU, addr_offset), start, len);
+}
+
+static unsigned int cvbs_read_vcbus(unsigned int addr_offset)
+{
+	return cvbs_read_reg_linear(cvbs_get_logic_addr(BUS_TYPE_VCBUS, addr_offset));
+}
+
+static int cvbs_write_vcbus(unsigned int addr_offset, unsigned int value)
+{
+	return cvbs_write_reg_linear(cvbs_get_logic_addr(BUS_TYPE_VCBUS, addr_offset), value);
+}
+
+static int cvbs_set_vcbus_bits(unsigned int addr_offset, unsigned int value, unsigned int start, unsigned int len)
+{
+	return cvbs_set_reg_bits(cvbs_get_logic_addr(BUS_TYPE_VCBUS, addr_offset), value, start, len);
+}
+#if 0
+static int cvbs_get_vcbus_bits(unsigned int addr_offset, unsigned int start, unsigned int len)
+{
+	return cvbs_get_reg_bits(cvbs_get_logic_addr(BUS_TYPE_VCBUS, addr_offset), start, len);
+}
+#endif
+
+/*----------------------------------------------------------------------------*/
+// configuration for enci bist
+int cvbs_set_bist(char* bist_mode)
+{
+	if (!strcmp(bist_mode, "off"))
+	{
+		cvbs_write_vcbus(ENCI_VIDEO_MODE_ADV,	0x26);
+		cvbs_write_vcbus(ENCI_TST_EN,			0x0);
+	} else
+	{
+		unsigned int mode = 0;
+
+		if (!strcmp(bist_mode, "fixval") || !strcmp(bist_mode, "0"))
+			mode = 0;
+		else if (!strcmp(bist_mode, "colorbar") || !strcmp(bist_mode, "1"))
+			mode = 1;
+		else if (!strcmp(bist_mode, "thinline") || !strcmp(bist_mode, "2"))
+			mode = 2;
+		else if (!strcmp(bist_mode, "dotgrid") || !strcmp(bist_mode, "3"))
+			mode = 3;
+
+		cvbs_write_vcbus(ENCI_VIDEO_MODE_ADV,	0x2);
+		cvbs_write_vcbus(ENCI_TST_MDSEL, 		mode);
+		cvbs_write_vcbus(ENCI_TST_CLRBAR_STRT,	0x112);
+		cvbs_write_vcbus(ENCI_TST_CLRBAR_WIDTH,	0xb4);
+		cvbs_write_vcbus(ENCI_TST_EN,			0x1);
+	}
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+// configuration for vdac pin of the soc.
+// config vdac path:
+//	0 : close
+//	1 : enci
+//	2 : atv
+//	3 : passthrough
+int cvbs_set_vdac(int status)
+{
+	switch (status)
+	{
+	case 0:// close vdac
+		cvbs_write_hiu(HHI_VDAC_CNTL0, 0);
+		cvbs_write_hiu(HHI_VDAC_CNTL1, 8);
+		break;
+	case 1:// from enci to vdac
+		cvbs_set_vcbus_bits(VENC_VDAC_DACSEL0, 5, 1, 0);
+		cvbs_write_hiu(HHI_VDAC_CNTL0, 1);
+		cvbs_write_hiu(HHI_VDAC_CNTL1, 0);
+		break;
+	case 2:// from atv to vdac
+		cvbs_set_vcbus_bits(VENC_VDAC_DACSEL0, 5, 1, 1);
+		cvbs_write_hiu(HHI_VDAC_CNTL0, 1);
+		cvbs_write_hiu(HHI_VDAC_CNTL1, 0);
+		break;
+	case 3:// from cvbs_in passthrough to cvbs_out with vdac disabled
+		cvbs_write_hiu(HHI_VDAC_CNTL0, 0x400);
+		cvbs_write_hiu(HHI_VDAC_CNTL1, 8);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+// interface for debug
+static void cvbs_dump_cvbs_regs(void)
+{
+	struct reg_s *p = NULL;
+
+	if (0 == cvbs_mode) {
+		// 576cvbs
+		p = (struct reg_s*)&tvregs_576cvbs_enc[0];
+
+	} else if (1 == cvbs_mode) {
+		// 480cvbs
+		p = (struct reg_s*)&tvregs_480cvbs_enc[0];
+	}
+
+	if (NULL == p) {
+		printf("it's not in cvbs mode!\n");
+		return;
+	}
+
+	if (MREG_END_MARKER != p->reg)
+		printf("cvbs enci registers:\n");
+	while (MREG_END_MARKER != p->reg) {
+		printf("    vcbus[0x%.2x] = 0x%.4x\n", p->reg, cvbs_read_vcbus(p->reg));
+		p ++;
+	}
+
+	return;
+}
+
+unsigned int cvbs_clk_regs[] = {
+	HHI_HDMI_PLL_CNTL,
+	HHI_HDMI_PLL_CNTL2,
+	HHI_HDMI_PLL_CNTL3,
+	HHI_HDMI_PLL_CNTL4,
+	HHI_HDMI_PLL_CNTL5,
+	HHI_HDMI_PLL_CNTL6,
+	HHI_VID_PLL_CLK_DIV,
+	HHI_VIID_CLK_DIV,
+	HHI_VIID_CLK_CNTL,
+	HHI_VID_CLK_DIV,
+	HHI_VID_CLK_CNTL2,
+	MREG_END_MARKER
+};
+
+static void cvbs_dump_clock_regs(void)
+{
+	unsigned int *p = &cvbs_clk_regs[0];
+
+	if (MREG_END_MARKER != *p)
+		printf("cvbs clock registers:\n");
+	while (MREG_END_MARKER != *p) {
+		printf("    hiu[0x%.2x] = 0x%.4x\n", *p, cvbs_read_hiu(*p));
+		p ++;
+	}
+
+	return;
+}
+
+int cvbs_reg_debug(int argc, char* const argv[])
+{
+	unsigned int addr, start, end, value;
+
+	if (!strcmp(argv[1], "r"))
+	{
+		if (argc != 4)
+			goto fail_cmd;
+
+		if (!strcmp(argv[2], "h"))
+		{
+			addr = simple_strtoul(argv[3], NULL, 16);
+			printf("cvbs read hiu[0x%.2x] = 0x%.4x\n", addr, cvbs_read_hiu(addr));
+		} else if (!strcmp(argv[2], "v"))
+		{
+			addr = simple_strtoul(argv[3], NULL, 16);
+			printf("cvbs read vcbus[0x%.2x] = 0x%.4x\n", addr, cvbs_read_vcbus(addr));
+		}
+	} else if (!strcmp(argv[1], "w")) {
+		if (argc != 5)
+			goto fail_cmd;
+
+		if (!strcmp(argv[3], "h"))
+		{
+			addr = simple_strtoul(argv[4], NULL, 16);
+			value = simple_strtoul(argv[2], NULL, 16);
+			cvbs_write_hiu(addr, value);
+			printf("cvbs write hiu[0x%.2x] = 0x%.4x\n", addr, cvbs_read_hiu(addr));
+		} else if (!strcmp(argv[3], "v"))
+		{
+			addr = simple_strtoul(argv[4], NULL, 16);
+			value = simple_strtoul(argv[2], NULL, 16);
+			cvbs_write_vcbus(addr, value);
+			printf("cvbs write hiu[0x%.2x] = 0x%.4x\n", addr, cvbs_read_vcbus(addr));
+		}
+	} else if (!strcmp(argv[1], "dump")) {
+		unsigned int i = 0;
+		unsigned int type = 0xff;
+
+		if (argc != 5)
+			goto fail_cmd;
+
+		if (!strcmp(argv[2], "h"))
+			type = 0;
+		else if (!strcmp(argv[2], "v"))
+			type = 1;
+
+		if (type == 0xff)
+			goto fail_cmd;
+
+		start = simple_strtoul(argv[3], NULL, 16);
+		end = simple_strtoul(argv[4], NULL, 16);
+
+		if (type == 0) {
+			for (i=start; i<=end; i++)
+				printf("cvbs read hiu[0x%.2x] = 0x%.4x\n", i, cvbs_read_hiu(i));
+		} else if (type == 1) {
+			for (i=start; i<=end; i++)
+				printf("cvbs read vcbus[0x%.2x] = 0x%.4x\n", i, cvbs_read_vcbus(i));
+		}
+	} else if (!strcmp(argv[1], "clock")) {
+		if (argc != 2)
+			goto fail_cmd;
+
+		cvbs_dump_clock_regs();
+	} else if (!strcmp(argv[1], "enci")) {
+		if (argc != 2)
+			goto fail_cmd;
+
+		cvbs_dump_cvbs_regs();
+	}
+
+	return 0;
+
+fail_cmd:
+	return 1;
+}
+
+/*----------------------------------------------------------------------------*/
+// configuration for clock
+#define WAIT_FOR_PLL_LOCKED(reg)                \
+	do {                                        \
+		unsigned int cnt = 10;                  \
+		unsigned int time_out = 0;              \
+		while (cnt --) {                        \
+		time_out = 0;                           \
+		while (!cvbs_get_hiu_bits(reg, 31, 1)	\
+			& (time_out < 10000))               \
+			time_out ++;                        \
+		}                                       \
+		if (cnt < 9)                            \
+			printf("pll[0x%x] reset %d times\n", reg, 9 - cnt);\
+	} while(0);
+
+static int cvbs_config_clock(void)
+{
+	cvbs_write_hiu(HHI_HDMI_PLL_CNTL,	0x5800023d);
+	cvbs_write_hiu(HHI_HDMI_PLL_CNTL2,	0x00404e00);
+	cvbs_write_hiu(HHI_HDMI_PLL_CNTL3,	0x0d5c5091);
+	cvbs_write_hiu(HHI_HDMI_PLL_CNTL4,	0x801da72c);
+	cvbs_write_hiu(HHI_HDMI_PLL_CNTL5,	0x71486980);
+	cvbs_write_hiu(HHI_HDMI_PLL_CNTL6,	0x00000e55);
+	cvbs_write_hiu(HHI_HDMI_PLL_CNTL,	0x4800023d);
+	WAIT_FOR_PLL_LOCKED(HHI_HDMI_PLL_CNTL);
+
+	cvbs_set_hiu_bits(HHI_VIID_CLK_CNTL, 0, VCLK2_EN, 1);
+	//udelay(5);
+
+	/* Disable the div output clock */
+	cvbs_set_hiu_bits(HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+	cvbs_set_hiu_bits(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+	cvbs_set_hiu_bits(HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+	/* Enable the final output clock */
+	cvbs_set_hiu_bits(HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+
+	/* setup the XD divider value */
+	cvbs_set_hiu_bits(HHI_VIID_CLK_DIV, (55 - 1), VCLK2_XD, 8);
+	//udelay(5);
+	/* Bit[18:16] - v2_cntl_clk_in_sel */
+	cvbs_set_hiu_bits(HHI_VIID_CLK_CNTL, 4, VCLK2_CLK_IN_SEL, 3);
+	cvbs_set_hiu_bits(HHI_VIID_CLK_CNTL, 1, VCLK2_EN, 1);
+	//udelay(2);
+
+	/* [15:12] encl_clk_sel, select vclk2_div1 */
+	cvbs_set_hiu_bits(HHI_VID_CLK_DIV, 8, 28, 4);
+	cvbs_set_hiu_bits(HHI_VIID_CLK_DIV, 8, 28, 4);
+	/* release vclk2_div_reset and enable vclk2_div */
+	cvbs_set_hiu_bits(HHI_VIID_CLK_DIV, 1, VCLK2_XD_EN, 2);
+	//udelay(5);
+
+	cvbs_set_hiu_bits(HHI_VIID_CLK_CNTL, 1, VCLK2_DIV1_EN, 1);
+	cvbs_set_hiu_bits(HHI_VIID_CLK_CNTL, 1, VCLK2_SOFT_RST, 1);
+	//udelay(10);
+	cvbs_set_hiu_bits(HHI_VIID_CLK_CNTL, 0, VCLK2_SOFT_RST, 1);
+	//udelay(5);
+
+	cvbs_set_hiu_bits(HHI_VID_CLK_CNTL2, 1, 0, 1);
+	cvbs_set_hiu_bits(HHI_VID_CLK_CNTL2, 1, 4, 1);
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+// configuration for enci
+static void cvbs_write_vcbus_array(struct reg_s *s)
+{
+	if (s == NULL)
+		return ;
+
+	while (s && (MREG_END_MARKER != s->reg))
+	{
+		cvbs_write_vcbus(s->reg, s->val);
+		//printf("reg[0x%.2x] = 0x%.4x\n", s->reg, s->val);
+		s ++;
+	}
+	return ;
+}
+
+static int cvbs_config_enci(int vmode)
+{
+	if (0 == vmode)
+		cvbs_write_vcbus_array((struct reg_s*)&tvregs_576cvbs_enc[0]);
+	else if (1 == vmode)
+		cvbs_write_vcbus_array((struct reg_s*)&tvregs_480cvbs_enc[0]);
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+// configuration for output
+// output vmode: 576cvbs, 480cvbs
+int cvbs_set_vmode(char* vmode_name)
+{
+	if (!strncmp(vmode_name, "576cvbs", strlen("576cvbs"))) {
+		cvbs_mode = 0;
+		cvbs_config_enci(0);
+		cvbs_config_clock();
+		cvbs_set_vdac(1);
+	} else if (!strncmp(vmode_name, "480cvbs", strlen("480cvbs"))) {
+		cvbs_mode = 1;
+		cvbs_config_enci(1);
+		cvbs_config_clock();
+		cvbs_set_vdac(1);
+	} else
+		printf("[%s] is invalid for cvbs.\n", vmode_name);
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+// list for valid video mode
+void cvbs_show_valid_vmode(void)
+{
+	printf("576cvbs\n""480cvbs\n");
+	return;
+}
+
diff --git a/drivers/display/vout/cvbs_config.h b/drivers/display/vout/cvbs_config.h
new file mode 100644
index 0000000..4d45a6b
--- /dev/null
+++ b/drivers/display/vout/cvbs_config.h
@@ -0,0 +1,125 @@
+/*
+ * drivers/display/vout/cvbs_config.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#include "cvbs_regs.h"
+
+struct reg_s {
+	unsigned int reg;
+	unsigned int val;
+};
+
+#define MREG_END_MARKER 0xFFFF
+
+static const struct reg_s tvregs_576cvbs_enc[] = {
+	{ENCI_CFILT_CTRL,                 0x12,      },
+	{ENCI_CFILT_CTRL2,                0x12,    	 },
+	{VENC_DVI_SETTING,                0,         },
+	{ENCI_VIDEO_MODE,                 0,         },
+	{ENCI_VIDEO_MODE_ADV,             0,         },
+	{ENCI_SYNC_HSO_BEGIN,             3,         },
+	{ENCI_SYNC_HSO_END,               129,       },
+	{ENCI_SYNC_VSO_EVNLN,             0x0003     },
+	{ENCI_SYNC_VSO_ODDLN,             0x0104     },
+	{ENCI_MACV_MAX_AMP,               0x8107     },
+	{VENC_VIDEO_PROG_MODE,            0xff       },
+	{ENCI_VIDEO_MODE,                 0x13       },
+	{ENCI_VIDEO_MODE_ADV,             0x26,      },
+	{ENCI_VIDEO_SCH,                  0x28,      },
+	{ENCI_SYNC_MODE,                  0x07,      },
+	{ENCI_YC_DELAY,                   0x333,     },
+	{ENCI_VFIFO2VD_PIXEL_START,       0x0fb	     },
+	{ENCI_VFIFO2VD_PIXEL_END,         0x069b     },
+	{ENCI_VFIFO2VD_LINE_TOP_START,    0x0016     },
+	{ENCI_VFIFO2VD_LINE_TOP_END,      0x0136     },
+	{ENCI_VFIFO2VD_LINE_BOT_START,    0x0017     },
+	{ENCI_VFIFO2VD_LINE_BOT_END,      0x0137     },
+	{VENC_SYNC_ROUTE,                 0,         },
+	{ENCI_DBG_PX_RST,                 0,         },
+	{VENC_INTCTRL,                    0x2,       },
+	{ENCI_VFIFO2VD_CTL,               0x4e01,    },
+	{VENC_VDAC_SETTING,               0,         },
+	{VENC_UPSAMPLE_CTRL0,             0x0061,    },
+	{VENC_UPSAMPLE_CTRL1,             0x4061,    },
+	{VENC_UPSAMPLE_CTRL2,             0x5061,    },
+	{VENC_VDAC_DACSEL0,               0x0000,    },
+	{VENC_VDAC_DACSEL1,               0x0000,    },
+	{VENC_VDAC_DACSEL2,               0x0000,    },
+	{VENC_VDAC_DACSEL3,               0x0000,    },
+	{VENC_VDAC_DACSEL4,               0x0000,    },
+	{VENC_VDAC_DACSEL5,               0x0000,    },
+	{VPU_VIU_VENC_MUX_CTRL,           0x0005,    },
+	{VENC_VDAC_FIFO_CTRL,             0x2000,    },
+	{ENCI_DACSEL_0,                   0x0011     },
+	{ENCI_DACSEL_1,                   0x11       },
+	{ENCI_VIDEO_EN,                   1,         },
+	{ENCI_VIDEO_SAT,                  0x7        },
+	{VENC_VDAC_DAC0_FILT_CTRL0,       0x1        },
+	{VENC_VDAC_DAC0_FILT_CTRL1,       0xfc48     },
+	{ENCI_MACV_N0,                    0x0        },
+	{MREG_END_MARKER,                 0          }
+};
+
+static const struct reg_s tvregs_480cvbs_enc[] = {
+	{ENCI_CFILT_CTRL,                 0x12,      },
+	{ENCI_CFILT_CTRL2,                0x12,      },
+	{VENC_DVI_SETTING,                0,         },
+	{ENCI_VIDEO_MODE,                 0,         },
+	{ENCI_VIDEO_MODE_ADV,             0,         },
+	{ENCI_SYNC_HSO_BEGIN,             5,         },
+	{ENCI_SYNC_HSO_END,               129,       },
+	{ENCI_SYNC_VSO_EVNLN,             0x0003     },
+	{ENCI_SYNC_VSO_ODDLN,             0x0104     },
+	{ENCI_MACV_MAX_AMP,               0x810b     },
+	{VENC_VIDEO_PROG_MODE,            0xf0       },
+	{ENCI_VIDEO_MODE,                 0x08       },
+	{ENCI_VIDEO_MODE_ADV,             0x26,      },
+	{ENCI_VIDEO_SCH,                  0x20,      },
+	{ENCI_SYNC_MODE,                  0x07,      },
+	{ENCI_YC_DELAY,                   0x333,     },
+	{ENCI_VFIFO2VD_PIXEL_START,       0xe3,      },
+	{ENCI_VFIFO2VD_PIXEL_END,         0x0683,    },
+	{ENCI_VFIFO2VD_LINE_TOP_START,    0x12,      },
+	{ENCI_VFIFO2VD_LINE_TOP_END,      0x102,     },
+	{ENCI_VFIFO2VD_LINE_BOT_START,    0x13,      },
+	{ENCI_VFIFO2VD_LINE_BOT_END,      0x103,     },
+	{VENC_SYNC_ROUTE,                 0,         },
+	{ENCI_DBG_PX_RST,                 0,         },
+	{VENC_INTCTRL,                    0x2,       },
+	{ENCI_VFIFO2VD_CTL,               0x4e01,    },
+	{VENC_VDAC_SETTING,               0,         },
+	{VENC_UPSAMPLE_CTRL0,             0x0061,    },
+	{VENC_UPSAMPLE_CTRL1,             0x4061,    },
+	{VENC_UPSAMPLE_CTRL2,             0x5061,    },
+	{VENC_VDAC_DACSEL0,               0x0000,    },
+	{VENC_VDAC_DACSEL1,               0x0000,    },
+	{VENC_VDAC_DACSEL2,               0x0000,    },
+	{VENC_VDAC_DACSEL3,               0x0000,    },
+	{VENC_VDAC_DACSEL4,               0x0000,    },
+	{VENC_VDAC_DACSEL5,               0x0000,    },
+	{VPU_VIU_VENC_MUX_CTRL,           0x0005,    },
+	{VENC_VDAC_FIFO_CTRL,             0x2000,    },
+	{ENCI_DACSEL_0,                   0x0011     },
+	{ENCI_DACSEL_1,                   0x11       },
+	{ENCI_VIDEO_EN,                   1,         },
+	{ENCI_VIDEO_SAT,                  0x12       },
+	{VENC_VDAC_DAC0_FILT_CTRL0,       0x1        },
+	{VENC_VDAC_DAC0_FILT_CTRL1,       0xfc48     },
+	{ENCI_MACV_N0,                    0x0        },
+	{ENCI_SYNC_ADJ,                   0x9c00     },
+	{ENCI_VIDEO_CONT,                 0x3        },
+	{MREG_END_MARKER,                 0          }
+};
+
diff --git a/drivers/display/vout/cvbs_regs.h b/drivers/display/vout/cvbs_regs.h
new file mode 100644
index 0000000..fc21a53
--- /dev/null
+++ b/drivers/display/vout/cvbs_regs.h
@@ -0,0 +1,242 @@
+/*
+ * drivers/display/vout/cvbs_regs.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/*-------------------------------------------------------------------------------*/
+// hiu registers
+
+/*-------------------------------------------------------------------------------*/
+// encoder registers
+#define BUS_TYPE_HIU	0
+#define BUS_TYPE_VCBUS	1
+
+#define HIU_BASE	0xc883c000
+#define VCBUS_BASE	0xd0100000
+
+#define HHI_HDMI_PLL_CNTL 		0x10c8
+#define HHI_HDMI_PLL_CNTL2		0x10c9
+#define HHI_HDMI_PLL_CNTL3		0x10ca
+#define HHI_HDMI_PLL_CNTL4		0x10cb
+#define HHI_HDMI_PLL_CNTL5		0x10cc
+#define HHI_HDMI_PLL_CNTL6		0x10cd
+
+#define HHI_VIID_DIVIDER_CNTL	0x104c
+#define HHI_VIID_CLK_DIV		0x104a
+    #define DAC0_CLK_SEL            28
+    #define DAC1_CLK_SEL            24
+    #define DAC2_CLK_SEL            20
+    #define VCLK2_XD_RST            17
+    #define VCLK2_XD_EN             16
+    #define ENCL_CLK_SEL            12
+    #define VCLK2_XD                 0
+#define HHI_VIID_CLK_CNTL		0x104b
+	#define VCLK2_EN                19
+    #define VCLK2_CLK_IN_SEL        16
+    #define VCLK2_SOFT_RST          15
+    #define VCLK2_DIV12_EN           4
+    #define VCLK2_DIV6_EN            3
+    #define VCLK2_DIV4_EN            2
+    #define VCLK2_DIV2_EN            1
+    #define VCLK2_DIV1_EN            0
+#define HHI_VID_CLK_DIV 		0x1059
+#define HHI_VID_CLK_CNTL 		0x105f
+#define HHI_VID_CLK_CNTL2		0x1065
+#define HHI_VID_DIVIDER_CNTL 	0x1066
+#define HHI_VID_PLL_CLK_DIV  	0x1068
+
+#define HHI_VID2_PLL_CNTL 		0x10e0
+#define HHI_VID2_PLL_CNTL2 		0x10e1
+#define HHI_VID2_PLL_CNTL3 		0x10e2
+#define HHI_VID2_PLL_CNTL4 		0x10e3
+#define HHI_VID2_PLL_CNTL5 		0x10e4
+
+#define HHI_VDAC_CNTL0 			0x10bd
+#define HHI_VDAC_CNTL1 			0x10be
+
+#define HHI_GCLK_OTHER    		0x1054
+#define HHI_VID_CLK_CNTL2 		0x1065
+
+
+#define ENCI_VIDEO_MODE         0x1b00
+#define ENCI_VIDEO_MODE_ADV     0x1b01
+#define ENCI_VIDEO_FSC_ADJ      0x1b02
+#define ENCI_VIDEO_BRIGHT       0x1b03
+#define ENCI_VIDEO_CONT         0x1b04
+#define ENCI_VIDEO_SAT          0x1b05
+#define ENCI_VIDEO_HUE          0x1b06
+#define ENCI_VIDEO_SCH          0x1b07
+#define ENCI_SYNC_MODE          0x1b08
+#define ENCI_SYNC_CTRL          0x1b09
+#define ENCI_SYNC_HSO_BEGIN     0x1b0a
+#define ENCI_SYNC_HSO_END       0x1b0b
+#define ENCI_SYNC_VSO_EVN       0x1b0c
+#define ENCI_SYNC_VSO_ODD       0x1b0d
+#define ENCI_SYNC_VSO_EVNLN     0x1b0e
+#define ENCI_SYNC_VSO_ODDLN     0x1b0f
+#define ENCI_SYNC_HOFFST        0x1b10
+#define ENCI_SYNC_VOFFST        0x1b11
+#define ENCI_SYNC_ADJ           0x1b12
+#define ENCI_RGB_SETTING        0x1b13
+
+#define ENCI_DE_H_BEGIN         0x1b16
+#define ENCI_DE_H_END           0x1b17
+#define ENCI_DE_V_BEGIN_EVEN    0x1b18
+#define ENCI_DE_V_END_EVEN      0x1b19
+#define ENCI_DE_V_BEGIN_ODD     0x1b1a
+#define ENCI_DE_V_END_ODD       0x1b1b
+#define ENCI_VBI_SETTING        0x1b20
+#define ENCI_VBI_CCDT_EVN       0x1b21
+#define ENCI_VBI_CCDT_ODD       0x1b22
+#define ENCI_VBI_CC525_LN       0x1b23
+#define ENCI_VBI_CC625_LN       0x1b24
+#define ENCI_VBI_WSSDT          0x1b25
+#define ENCI_VBI_WSS_LN         0x1b26
+#define ENCI_VBI_CGMSDT_L       0x1b27
+#define ENCI_VBI_CGMSDT_H       0x1b28
+#define ENCI_VBI_CGMS_LN        0x1b29
+#define ENCI_VBI_TTX_HTIME      0x1b2a
+#define ENCI_VBI_TTX_LN         0x1b2b
+#define ENCI_VBI_TTXDT0         0x1b2c
+#define ENCI_VBI_TTXDT1         0x1b2d
+#define ENCI_VBI_TTXDT2         0x1b2e
+#define ENCI_VBI_TTXDT3         0x1b2f
+#define ENCI_MACV_N0            0x1b30
+#define ENCI_MACV_N1            0x1b31
+#define ENCI_MACV_N2            0x1b32
+#define ENCI_MACV_N3            0x1b33
+#define ENCI_MACV_N4            0x1b34
+#define ENCI_MACV_N5            0x1b35
+#define ENCI_MACV_N6            0x1b36
+#define ENCI_MACV_N7            0x1b37
+#define ENCI_MACV_N8            0x1b38
+#define ENCI_MACV_N9            0x1b39
+#define ENCI_MACV_N10           0x1b3a
+#define ENCI_MACV_N11           0x1b3b
+#define ENCI_MACV_N12           0x1b3c
+#define ENCI_MACV_N13           0x1b3d
+#define ENCI_MACV_N14           0x1b3e
+#define ENCI_MACV_N15           0x1b3f
+#define ENCI_MACV_N16           0x1b40
+#define ENCI_MACV_N17           0x1b41
+#define ENCI_MACV_N18           0x1b42
+#define ENCI_MACV_N19           0x1b43
+#define ENCI_MACV_N20           0x1b44
+#define ENCI_MACV_N21           0x1b45
+#define ENCI_MACV_N22           0x1b46
+
+#define ENCI_DBG_PX_RST         0x1b48
+#define ENCI_DBG_FLDLN_RST      0x1b49
+#define ENCI_DBG_PX_INT         0x1b4a
+#define ENCI_DBG_FLDLN_INT      0x1b4b
+#define ENCI_DBG_MAXPX          0x1b4c
+#define ENCI_DBG_MAXLN          0x1b4d
+#define ENCI_MACV_MAX_AMP       0x1b50
+#define ENCI_MACV_PULSE_LO      0x1b51
+#define ENCI_MACV_PULSE_HI      0x1b52
+#define ENCI_MACV_BKP_MAX       0x1b53
+#define ENCI_CFILT_CTRL         0x1b54
+#define ENCI_CFILT7             0x1b55
+#define ENCI_YC_DELAY           0x1b56
+#define ENCI_VIDEO_EN           0x1b57
+
+#define ENCI_DVI_HSO_BEGIN      0x1c00
+#define ENCI_DVI_HSO_END        0x1c01
+#define ENCI_DVI_VSO_BLINE_EVN  0x1c02
+#define ENCI_DVI_VSO_BLINE_ODD  0x1c03
+#define ENCI_DVI_VSO_ELINE_EVN  0x1c04
+#define ENCI_DVI_VSO_ELINE_ODD  0x1c05
+#define ENCI_DVI_VSO_BEGIN_EVN  0x1c06
+#define ENCI_DVI_VSO_BEGIN_ODD  0x1c07
+#define ENCI_DVI_VSO_END_EVN    0x1c08
+#define ENCI_DVI_VSO_END_ODD    0x1c09
+
+#define ENCI_CFILT_CTRL2        0x1c0a
+#define ENCI_DACSEL_0           0x1c0b
+#define ENCI_DACSEL_1           0x1c0c
+#define ENCI_TST_EN             0x1c10
+#define ENCI_TST_MDSEL          0x1c11
+#define ENCI_TST_Y              0x1c12
+#define ENCI_TST_CB             0x1c13
+#define ENCI_TST_CR             0x1c14
+#define ENCI_TST_CLRBAR_STRT    0x1c15
+#define ENCI_TST_CLRBAR_WIDTH   0x1c16
+#define ENCI_TST_VDCNT_STSET    0x1c17
+
+#define ENCI_VFIFO2VD_CTL               0x1c18
+#define ENCI_VFIFO2VD_PIXEL_START       0x1c19
+#define ENCI_VFIFO2VD_PIXEL_END         0x1c1a
+#define ENCI_VFIFO2VD_LINE_TOP_START    0x1c1b
+#define ENCI_VFIFO2VD_LINE_TOP_END      0x1c1c
+#define ENCI_VFIFO2VD_LINE_BOT_START    0x1c1d
+#define ENCI_VFIFO2VD_LINE_BOT_END      0x1c1e
+#define ENCI_VFIFO2VD_CTL2              0x1c1f
+
+#define ENCI_SYNC_LINE_LENGTH           0x1c40
+#define ENCI_SYNC_PIXEL_EN              0x1c41
+#define ENCI_SYNC_TO_LINE_EN            0x1c42
+#define ENCI_SYNC_TO_PIXEL              0x1c43
+
+#define VENC_VDAC_DAC4_FILT_CTRL0       0x1c54
+#define VENC_VDAC_DAC4_FILT_CTRL1       0x1c55
+#define VENC_VDAC_DAC5_FILT_CTRL0       0x1c56
+#define VENC_VDAC_DAC5_FILT_CTRL1       0x1c57
+
+#define VENC_VDAC_DAC0_FILT_CTRL0       0x1c58
+#define VENC_VDAC_DAC0_FILT_CTRL1       0x1c59
+#define VENC_VDAC_DAC1_FILT_CTRL0       0x1c5a
+#define VENC_VDAC_DAC1_FILT_CTRL1       0x1c5b
+#define VENC_VDAC_DAC2_FILT_CTRL0       0x1c5c
+#define VENC_VDAC_DAC2_FILT_CTRL1       0x1c5d
+#define VENC_VDAC_DAC3_FILT_CTRL0       0x1c5e
+#define VENC_VDAC_DAC3_FILT_CTRL1       0x1c5f
+
+
+#define VENC_SYNC_ROUTE                 0x1b60
+#define VENC_VIDEO_EXSRC                0x1b61
+#define VENC_DVI_SETTING                0x1b62
+#define VENC_C656_CTRL                  0x1b63
+#define VENC_UPSAMPLE_CTRL0             0x1b64
+#define VENC_UPSAMPLE_CTRL1             0x1b65
+#define VENC_UPSAMPLE_CTRL2             0x1b66
+#define VENC_VIDEO_PROG_MODE            0x1b68
+
+#define VENC_INTCTRL                    0x1b6e
+#define VENC_INTFLAG                    0x1b6f
+
+#define VENC_VDAC_DACSEL0               0x1b78
+#define VENC_VDAC_DACSEL1               0x1b79
+#define VENC_VDAC_DACSEL2               0x1b7a
+#define VENC_VDAC_DACSEL3               0x1b7b
+#define VENC_VDAC_DACSEL4               0x1b7c
+#define VENC_VDAC_DACSEL5               0x1b7d
+#define VENC_VDAC_SETTING               0x1b7e
+#define VENC_VDAC_TST_VAL               0x1b7f
+#define VENC_VDAC_DAC0_GAINCTRL         0x1bf0
+#define VENC_VDAC_DAC0_OFFSET           0x1bf1
+#define VENC_VDAC_DAC1_GAINCTRL         0x1bf2
+#define VENC_VDAC_DAC1_OFFSET           0x1bf3
+#define VENC_VDAC_DAC2_GAINCTRL         0x1bf4
+#define VENC_VDAC_DAC2_OFFSET           0x1bf5
+#define VENC_VDAC_DAC3_GAINCTRL         0x1bf6
+#define VENC_VDAC_DAC3_OFFSET           0x1bf7
+#define VENC_VDAC_DAC4_GAINCTRL         0x1bf8
+#define VENC_VDAC_DAC4_OFFSET           0x1bf9
+#define VENC_VDAC_DAC5_GAINCTRL         0x1bfa
+#define VENC_VDAC_DAC5_OFFSET           0x1bfb
+#define VENC_VDAC_FIFO_CTRL             0x1bfc
+
+#define VPU_VIU_VENC_MUX_CTRL           0x271a
+
diff --git a/drivers/display/vout/vout.c b/drivers/display/vout/vout.c
new file mode 100644
index 0000000..744b91b
--- /dev/null
+++ b/drivers/display/vout/vout.c
@@ -0,0 +1,398 @@
+/*
+ * drivers/display/vout/vout.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * Author: Platform-BJ @platform.bj@amlogic.com
+ *
+*/
+
+
+#include <common.h>
+#include <asm/arch/io.h>
+
+#include <amlogic/vmode.h>
+#include <amlogic/vout.h>
+
+#define VOUT_LOG_DBG 0
+#define VOUT_LOG_TAG "[VOUT]"
+#define vout_log(fmt, ...) printf(VOUT_LOG_TAG fmt, ##__VA_ARGS__)
+#define vout_logl() \
+	do { \
+		if (VOUT_LOG_DBG > 0) \
+			vout_log("%s:%d\n", __func__, __LINE__); \
+	} while (0)
+
+
+#define REG_BASE_VCBUS                  (0xd0100000L)
+#define VPP_POSTBLEND_H_SIZE 0x1d21
+#define REG_OFFSET_VCBUS(reg)           ((reg << 2))
+#define REG_ADDR_VCBUS(reg)             (REG_BASE_VCBUS + REG_OFFSET_VCBUS(reg))
+
+
+static int g_vmode = -1;
+
+typedef struct vout_set_s {
+	char *name;
+	int mode;
+	ulong width;
+	ulong height;
+} vout_set_t;
+
+
+static const vout_set_t vout_sets[] = {
+	{ /* VMODE_480I */
+		.name              = "480i",
+		.mode              = VMODE_480I,
+		.width             = 720,
+		.height            = 480,
+	},
+	{ /* VMODE_480CVBS*/
+		.name              = "480cvbs",
+		.mode              = VMODE_480CVBS,
+		.width             = 720,
+		.height            = 480,
+	},
+	{ /* VMODE_480P */
+		.name              = "480p",
+		.mode              = VMODE_480P,
+		.width             = 720,
+		.height            = 480,
+	},
+	{ /* VMODE_576I */
+		.name              = "576i",
+		.mode              = VMODE_576I,
+		.width             = 720,
+		.height            = 576,
+	},
+	{ /* VMODE_576I */
+		.name              = "576cvbs",
+		.mode              = VMODE_576CVBS,
+		.width             = 720,
+		.height            = 576,
+	},
+	{ /* VMODE_576P */
+		.name              = "576p",
+		.mode              = VMODE_576P,
+		.width             = 720,
+		.height            = 576,
+	},
+	{ /* VMODE_720P */
+		.name              = "720p",
+		.mode              = VMODE_720P,
+		.width             = 1280,
+		.height            = 720,
+	},
+	{ /* VMODE_1080I */
+		.name              = "1080i",
+		.mode              = VMODE_1080I,
+		.width             = 1920,
+		.height            = 1080,
+	},
+	{ /* VMODE_1080P */
+		.name              = "1080p",
+		.mode              = VMODE_1080P,
+		.width             = 1920,
+		.height            = 1080,
+	},
+	{ /* VMODE_4K2K_60HZ */
+		.name              = "2160p",
+		.mode              = VMODE_4K2K_60HZ,
+		.width             = 3840,
+		.height            = 2160,
+	},
+	{ /* VMODE_4K2K_SMPTE */
+		.name              = "smpte24hz",
+		.mode              = VMODE_4K2K_SMPTE,
+		.width             = 4096,
+		.height            = 2160,
+	},
+	{ /* VMODE_vga */
+		.name              = "vga",
+		.mode              = VMODE_VGA,
+		.width             = 640,
+		.height            = 480,
+	},
+	{ /* VMODE_SVGA */
+		.name              = "svga",
+		.mode              = VMODE_SVGA,
+		.width             = 800,
+		.height            = 600,
+	},
+	{ /* VMODE_XGA */
+		.name              = "xga",
+		.mode              = VMODE_XGA,
+		.width             = 1024,
+		.height            = 768,
+	},
+	{ /* VMODE_sxga */
+		.name              = "sxga",
+		.mode              = VMODE_SXGA,
+		.width             = 1280,
+		.height            = 1024,
+	},
+	{ /* VMODE_wsxga */
+		.name              = "wsxga",
+		.mode              = VMODE_WSXGA,
+		.width             = 1440,
+		.height            = 900,
+	},
+	{ /* VMODE_fhdvga */
+		.name              = "fhdvga",
+		.mode              = VMODE_FHDVGA,
+		.width             = 1920,
+		.height            = 1080,
+	},
+};
+
+vidinfo_t tv_info = {
+	.vl_col	= 1280,              /* Number of columns (i.e. 160) */
+	.vl_row	= 720,               /* Number of rows (i.e. 100) */
+	.vl_bpix = 24,               /* Bits per pixel */
+	.vd_base = NULL,             /* Start of framebuffer memory	*/
+	.vd_console_address = NULL,  /* Start of console buffer	*/
+	.console_col = 0,
+	.console_row = 0,
+
+	.vd_color_fg = 0xffff,
+	.vd_color_bg = 0,
+	.max_bl_level = 255,
+	.cmap = NULL,                /* Pointer to the colormap */
+	.priv = NULL,                /* Pointer to driver-specific data */
+};
+
+static inline void vout_reg_write(u32 reg,
+				 const u32 val)
+{
+	*(volatile unsigned int *)REG_ADDR_VCBUS(reg) = (val);
+}
+
+static int vout_find_mode_by_name(const char *name)
+{
+	int mode = -1;
+	int i = 0;
+
+	for (i = 0; i < sizeof(vout_sets) / sizeof(struct vout_set_s); i++) {
+		if (strncmp(name, vout_sets[i].name, strlen(vout_sets[i].name)) == 0) {
+			mode = vout_sets[i].mode;
+			return mode;
+		}
+	}
+
+	vout_log("mode: %s not found\n", name);
+	return -1;
+}
+
+static int vout_find_width_by_name(const char* name)
+{
+	int i = 0;
+	ulong width = 0;
+
+	for (i = 0; i < sizeof(vout_sets) / sizeof(struct vout_set_s); i++) {
+		if (strncmp(name, vout_sets[i].name, strlen(vout_sets[i].name)) == 0) {
+			width = vout_sets[i].width;
+			return width;
+		}
+	}
+
+	return width;
+}
+
+static int vout_find_height_by_name(const char* name)
+{
+	int height = 0;
+	int i = 0;
+
+	for (i = 0; i < sizeof(vout_sets) / sizeof(struct vout_set_s); i++) {
+		if (strncmp(name, vout_sets[i].name, strlen(vout_sets[i].name)) == 0) {
+			height = vout_sets[i].height;
+			return height;
+		}
+	}
+
+	return height;
+}
+
+static void vout_vinfo_init(void)
+{
+	tv_info.vd_base = (void *)simple_strtoul(getenv("fb_addr"), NULL, 0);
+	tv_info.vl_col = simple_strtoul(getenv("display_width"), NULL, 0);
+	tv_info.vl_row = simple_strtoul(getenv("display_height"), NULL, 0);
+	tv_info.vl_bpix = simple_strtoul(getenv("display_bpp"), NULL, 10);
+	tv_info.vd_color_fg = simple_strtoul(getenv("display_color_fg"), NULL, 0);
+	tv_info.vd_color_bg = simple_strtoul(getenv("display_color_bg"), NULL, 0);
+}
+
+static void vout_axis_init(ulong w, ulong h)
+{
+	ulong width = w;
+	ulong height = h;
+
+	setenv_ulong("display_width", width);
+	setenv_ulong("display_height", height);
+}
+
+static void vout_vmode_init(void)
+{
+	char *outputmode = NULL;
+	int vmode = -1;
+	ulong width = 0;
+	ulong height = 0;
+
+	outputmode = getenv("outputmode");
+	vmode = vout_find_mode_by_name(outputmode);
+	vout_set_current_vmode(vmode);
+	width = vout_find_width_by_name(outputmode);
+	height = vout_find_height_by_name(outputmode);
+	vout_reg_write(VPP_POSTBLEND_H_SIZE, width);
+	vout_axis_init(width, height);
+}
+
+static int my_atoi(const char *str)
+{
+	int result = 0;
+	int signal = 1;
+
+	if ((*str >= '0' && *str <= '9') || *str == '-' || *str == '+') {
+		if (*str == '-' || *str == '+') {
+			if (*str == '-')
+				signal = -1;
+			str++;
+		}
+	} else
+		return 0;
+
+	while (*str >= '0' && *str <= '9')
+		result = result * 10 + (*str++ -'0');
+
+	return signal * result;
+}
+
+static int getenv_int(char *env, int def)
+{
+	if (getenv(env) == NULL)
+		return def;
+	else
+		return my_atoi(getenv(env));
+}
+
+static int get_window_axis(int *axis)
+{
+	int ret = 0;
+	char *mode = getenv("outputmode");
+
+	if (strncmp(mode, "480i", 4) == 0 || strcmp(mode, "480cvbs") == 0) {
+		axis[0] = getenv_int("480i_x", 0);
+		axis[1] = getenv_int("480i_y", 0);
+		axis[2] = getenv_int("480i_w", 720);
+		axis[3] = getenv_int("480i_h", 480);
+	} else if (strncmp(mode, "480p", 4) == 0) {
+		axis[0] = getenv_int("480p_x", 0);
+		axis[1] = getenv_int("480p_y", 0);
+		axis[2] = getenv_int("480p_w", 720);
+		axis[3] = getenv_int("480p_h", 480);
+	} else if (strncmp(mode, "576i", 4) == 0 || strcmp(mode, "576cvbs") == 0) {
+		axis[0] = getenv_int("576i_x", 0);
+		axis[1] = getenv_int("576i_y", 0);
+		axis[2] = getenv_int("576i_w", 720);
+		axis[3] = getenv_int("576i_h", 576);
+	} else if (strncmp(mode, "576p", 4) == 0) {
+		axis[0] = getenv_int("576p_x", 0);
+		axis[1] = getenv_int("576p_y", 0);
+		axis[2] = getenv_int("576p_w", 720);
+		axis[3] = getenv_int("576p_h", 576);
+	} else if (strncmp(mode, "720p", 4) == 0) {
+		axis[0] = getenv_int("720p_x", 0);
+		axis[1] = getenv_int("720p_y", 0);
+		axis[2] = getenv_int("720p_w", 1280);
+		axis[3] = getenv_int("720p_h", 720);
+	} else if (strncmp(mode, "1080i", 5) == 0) {
+		axis[0] = getenv_int("1080i_x", 0);
+		axis[1] = getenv_int("1080i_y", 0);
+		axis[2] = getenv_int("1080i_w", 1920);
+		axis[3] = getenv_int("1080i_h", 1080);
+	} else if (strncmp(mode, "1080p", 5) == 0) {
+		axis[0] = getenv_int("1080p_x", 0);
+		axis[1] = getenv_int("1080p_y", 0);
+		axis[2] = getenv_int("1080p_w", 1920);
+		axis[3] = getenv_int("1080p_h", 1080);
+	} else if (strncmp(mode, "2160p", 5) == 0) {
+		axis[0] = getenv_int("2160p_x", 0);
+		axis[1] = getenv_int("2160p_y", 0);
+		axis[2] = getenv_int("2160p_w", 3840);
+		axis[3] = getenv_int("2160p_h", 2160);
+	} else if (strcmp(mode, "smpte24hz") == 0) {
+		axis[0] = getenv_int("4k2ksmpte_x", 0);
+		axis[1] = getenv_int("4k2ksmpte_y", 0);
+		axis[2] = getenv_int("4k2ksmpte_w", 4096);
+		axis[3] = getenv_int("4k2ksmpte_h", 2160);
+	} else {
+		axis[0] = getenv_int("1080p_x", 0);
+		axis[1] = getenv_int("1080p_y", 0);
+		axis[2] = getenv_int("1080p_w", 1920);
+		axis[3] = getenv_int("1080p_h", 1080);
+	}
+
+	return ret;
+}
+
+void vout_set_current_vmode(int mode)
+{
+	g_vmode = mode;
+}
+
+int vout_get_current_vmode(void)
+{
+	vout_logl();
+	return g_vmode;
+}
+
+vidinfo_t *vout_get_current_vinfo(void)
+{
+	vidinfo_t *info = &tv_info;
+
+	vout_logl();
+
+#if defined CONFIG_VIDEO_AMLLCD
+	extern vidinfo_t tv_info;
+	info = &panel_info;
+#endif
+
+	return info;
+}
+
+int vout_get_current_axis(int *axis)
+{
+	return get_window_axis(axis);
+}
+
+void vout_vinfo_dump(void)
+{
+	vidinfo_t *info = NULL;
+
+	vout_logl();
+	info = vout_get_current_vinfo();
+	vout_log("vinfo.vd_base: 0x%p\n", info->vd_base);
+	vout_log("vinfo.vl_col: %d\n", info->vl_col);
+	vout_log("vinfo.vl_row: %d\n", info->vl_row);
+	vout_log("vinfo.vl_bpix: %d\n", info->vl_bpix);
+	vout_log("vinfo.vd_color_fg: %d\n", info->vd_color_fg);
+	vout_log("vinfo.vd_color_bg: %d\n", info->vd_color_bg);
+}
+
+void vout_init(void)
+{
+	vout_logl();
+	vout_vmode_init();
+	vout_vinfo_init();
+}
diff --git a/drivers/efuse/Makefile b/drivers/efuse/Makefile
new file mode 100644
index 0000000..83988eb
--- /dev/null
+++ b/drivers/efuse/Makefile
@@ -0,0 +1,27 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+obj-$(CONFIG_EFUSE) += efuse.o
+ifdef CONFIG_OF_LIBFDT
+obj-$(CONFIG_EFUSE) += efuse_usr_space_api.o
+endif
diff --git a/drivers/efuse/efuse.c b/drivers/efuse/efuse.c
new file mode 100644
index 0000000..8fd9dc4
--- /dev/null
+++ b/drivers/efuse/efuse.c
@@ -0,0 +1,139 @@
+
+/*
+ * drivers/efuse/efuse.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/arch/io.h>
+#include <asm/arch/efuse.h>
+#include "efuse_regs.h"
+
+char efuse_buf[EFUSE_BYTES] = {0};
+
+ssize_t efuse_read(char *buf, size_t count, loff_t *ppos)
+{
+	unsigned pos = *ppos;
+
+	struct efuse_hal_api_arg arg;
+	unsigned int retcnt;
+	int ret;
+	arg.cmd = EFUSE_HAL_API_READ;
+	arg.offset = pos;
+	arg.size = count;
+	arg.buffer_phy = (unsigned long)buf;
+	arg.retcnt_phy = (unsigned long)&retcnt;
+	ret = meson_trustzone_efuse(&arg);
+	if (ret == 0) {
+		*ppos += retcnt;
+		return retcnt;
+	} else{
+		return ret;
+	}
+}
+
+ssize_t efuse_write(const char *buf, size_t count, loff_t *ppos)
+{
+	unsigned pos = *ppos;
+
+	if ((pos&0xffff) >= EFUSE_BYTES)
+		return 0;	/* Past EOF */
+	if (count > EFUSE_BYTES - pos)
+		count = EFUSE_BYTES - pos;
+	if (count > EFUSE_BYTES)
+		return -1;
+
+	struct efuse_hal_api_arg arg;
+	unsigned int retcnt;
+	arg.cmd = EFUSE_HAL_API_WRITE;
+	arg.offset = pos;
+	arg.size = count;
+	arg.buffer_phy = (unsigned long)buf;
+	arg.retcnt_phy = (unsigned long)&retcnt;
+	int ret;
+	ret = meson_trustzone_efuse(&arg);
+	if (ret == 0) {
+		*ppos = retcnt;
+		return retcnt;
+	} else{
+		return ret;
+	}
+}
+
+int efuse_read_usr(char *buf, size_t count, loff_t *ppos)
+{
+	char data[EFUSE_BYTES];
+	char *pdata = NULL;
+	int ret;
+	loff_t pos;
+
+	memset(data, 0, count);
+
+	pdata = data;
+	pos = *ppos;
+	ret = efuse_read(pdata, count, (loff_t *)&pos);
+
+	memcpy(buf, data, count);
+
+	return ret;
+}
+
+int efuse_write_usr(char *buf, size_t count, loff_t *ppos)
+{
+	char data[EFUSE_BYTES];
+	char *pdata = NULL;
+	char *penc = NULL;
+	int ret;
+	loff_t pos;
+
+	if (count == 0) {
+		printf("data length: 0 is error!\n");
+		return -1;
+	}
+
+	memset(data, 0, EFUSE_BYTES);
+	memset(efuse_buf, 0, EFUSE_BYTES);
+
+	memcpy(data, buf, count);
+	pdata = data;
+	penc = efuse_buf;
+
+	memcpy(penc, pdata, count);
+	pos = *ppos;
+
+	ret = efuse_write(efuse_buf, count, (loff_t *)&pos);
+
+	return ret;
+}
+
+uint32_t efuse_get_max(void)
+{
+	struct efuse_hal_api_arg arg;
+	int ret;
+	arg.cmd = EFUSE_HAL_API_USER_MAX;
+
+	ret = meson_trustzone_efuse_get_max(&arg);
+	if (ret == 0) {
+		printf("ERROR: can not get efuse user max bytes!!!\n");
+		return -1;
+	} else{
+		return ret;
+	}
+}
diff --git a/drivers/efuse/efuse_regs.h b/drivers/efuse/efuse_regs.h
new file mode 100644
index 0000000..64aeb11
--- /dev/null
+++ b/drivers/efuse/efuse_regs.h
@@ -0,0 +1,47 @@
+
+/*
+ * drivers/efuse/efuse_regs.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __EFUSE_REG_H
+#define __EFUSE_REG_H
+#include <asm/io.h>
+//#define EFUSE_DEBUG
+
+#define WRITE_EFUSE_REG(reg, val)  __raw_writel(val, reg)
+#define READ_EFUSE_REG(reg)  (__raw_readl(reg))
+#define WRITE_EFUSE_REG_BITS(reg, val, start, len) \
+	WRITE_EFUSE_REG(reg,	(READ_EFUSE_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_EFUSE_REG_BITS(reg, start, len) \
+	((READ_EFUSE_REG(reg) >> (start)) & ((1L<<(len))-1))
+
+// EFUSE version constant definition
+
+#define GXBB_EFUSE_VERSION_SERIALNUM_V1	0 /*TO DO*/
+#define GXBB_EFUSE_VERSION_OFFSET 0 /*TO DO*/
+#define GXBB_EFUSE_VERSION_ENC_LEN 0 /*TO DO*/
+#define GXBB_EFUSE_VERSION_DATA_LEN 0 /*TO DO*/
+
+typedef enum {
+	EFUSE_SOC_CHIP_GXBB,
+	EFUSE_SOC_CHIP_UNKNOW,
+}efuse_socchip_type_e;
+
+#endif
+
diff --git a/drivers/efuse/efuse_usr_space_api.c b/drivers/efuse/efuse_usr_space_api.c
new file mode 100644
index 0000000..76bde84
--- /dev/null
+++ b/drivers/efuse/efuse_usr_space_api.c
@@ -0,0 +1,381 @@
+/*
+ * \file        efuse_usr_space_api.c
+ * \brief       support read/write user space using keyname mode
+ *              mapping keyname to offset by looking /efusekey in dtb
+ *
+ * \version     1.0.0
+ * \date        15/07/14
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <linux/ctype.h>
+
+#define EFUSE_DBG(fmt...)   //printf("[EFUSE_DBG]"fmt)
+#define EFUSE_MSG(fmt...)   printf("[EFUSE_MSG]"fmt)
+#define EFUSE_ERR(fmt...)   printf("[EFUSE_ERR]f(%s)L%d:", __func__, __LINE__),printf(fmt)
+
+extern uint32_t efuse_get_max(void);
+extern int efuse_read_usr(char *buf, size_t count, loff_t *ppos);
+extern int efuse_write_usr(char *buf, size_t count, loff_t *ppos);
+
+struct efusekey_info{
+	char keyname[32];
+	unsigned offset;
+	unsigned size;
+};
+
+static struct _efuseCfgInf{
+    unsigned                initMaigc;//magic to indicate whether inited
+    unsigned                totalCfgKeyNums;
+    struct efusekey_info *  pKeyInf;
+}
+_efuseKeyInfos = {.totalCfgKeyNums = 0, .pKeyInf = NULL};
+
+int efuse_usr_api_init_dtb(const char*  dt_addr)
+{
+	int nodeoffset, poffset = 0;
+	char propname[32];
+	const void* phandle;
+	int ret;
+	int index;
+	uint32_t max_size;
+    unsigned efusekeynum = 0;
+    struct efusekey_info * efusekey_infos = NULL;
+
+	ret = fdt_check_header(dt_addr);
+	if (ret < 0) {
+		EFUSE_ERR("fdt check failed [%s]\n", fdt_strerror(ret));
+        return __LINE__;
+    }
+    _efuseKeyInfos.initMaigc = 0;
+
+	nodeoffset = fdt_path_offset(dt_addr, "/efusekey");
+	if (nodeoffset < 0) {
+		EFUSE_ERR("not find /efusekey node [%s].\n", fdt_strerror(nodeoffset));
+        return __LINE__;
+    }
+
+	phandle = fdt_getprop(dt_addr, nodeoffset, "keynum", NULL);
+	efusekeynum = be32_to_cpup((u32 *)phandle);
+	EFUSE_MSG("keynum is %x\n", efusekeynum);
+
+    if (efusekey_infos) free(efusekey_infos) ;
+    efusekey_infos = (struct efusekey_info *)malloc(sizeof (struct efusekey_info) *efusekeynum);
+    if (!efusekey_infos) {
+        EFUSE_ERR("malloc err\n");
+        return __LINE__;
+    }
+
+	max_size = efuse_get_max();
+
+	for (index = 0; index < efusekeynum; index++)
+    {
+        struct efusekey_info* theKeyInf = efusekey_infos + index;
+		sprintf(propname, "key%d", index);
+		/* printf("%s: propname: %s\n",__func__,propname); */
+		phandle = fdt_getprop(dt_addr, nodeoffset, propname, NULL);
+		if (!phandle) {
+			EFUSE_ERR("don't find  match %s\n", propname);
+			goto err;
+		}
+        poffset = fdt_node_offset_by_phandle(dt_addr,
+                be32_to_cpup((u32 *)phandle));
+        if (!poffset) {
+            EFUSE_ERR("can't find device node for key[%s]\n", propname);
+            goto err;
+        }
+
+
+		phandle = fdt_getprop(dt_addr, poffset, "keyname", NULL);
+        if (!phandle) {
+            EFUSE_ERR("Can't find keyname for key[%d]\n", index);
+            goto err;
+        }
+		strcpy(theKeyInf->keyname, phandle);
+
+		phandle = fdt_getprop(dt_addr, poffset, "offset", NULL);
+        if (!phandle) {
+            EFUSE_ERR("Can't find offset for key[%s]\n", theKeyInf->keyname);
+            goto err;
+        }
+		theKeyInf->offset = be32_to_cpup((u32 *)phandle);
+
+		phandle = fdt_getprop(dt_addr, poffset, "size", NULL);
+        if (!phandle) {
+            EFUSE_ERR("Can't find size for key[%s]\n", theKeyInf->keyname);
+            goto err;
+        }
+		theKeyInf->size = be32_to_cpup((u32 *)phandle);
+
+		EFUSE_DBG("key[%02d] name=%12s, offset=0x%04x, size=0x%04x\n",
+                index, theKeyInf->keyname, theKeyInf->offset, theKeyInf->size);
+        if (theKeyInf->offset + theKeyInf->size > max_size) {
+            EFUSE_ERR("\n offset (0x%x) + size (0x%x) > max [0x%x]!\n", theKeyInf->offset, theKeyInf->size, max_size);
+            return __LINE__;
+        }
+	}
+
+    _efuseKeyInfos.totalCfgKeyNums = efusekeynum;
+    _efuseKeyInfos.pKeyInf         = efusekey_infos;
+    EFUSE_DBG("%s success!\n", __func__);
+    _efuseKeyInfos.initMaigc = 0xee;
+	return 0;
+
+err:
+	free(efusekey_infos);
+	EFUSE_ERR("%s error!\n", __func__);
+	return -1;
+}
+
+static int _get_cfg_key_inf_byname(const char* keyname, const struct efusekey_info ** pKeyInf)
+{
+    int index = 0;
+    struct efusekey_info* theKeyInf = _efuseKeyInfos.pKeyInf;
+    int ret = 0;
+
+    if (0xee != _efuseKeyInfos.initMaigc) {
+        EFUSE_ERR("Pls init first.\n");
+        return __LINE__;
+    }
+    for (; index < _efuseKeyInfos.totalCfgKeyNums; ++index, ++theKeyInf)
+    {
+        const char* theKeyname = theKeyInf->keyname;
+        ret = strcmp(theKeyname, keyname);
+        if (ret) continue;
+
+        *pKeyInf = theKeyInf;
+        return 0;
+    }
+
+    EFUSE_ERR("efuse keyname(%s) not configured\n", keyname);
+    return __LINE__;//Not found the matched name
+}
+
+int efuse_usr_api_get_cfg_key_size(const char* keyname, unsigned* pSz)
+{
+    int ret = 0;
+    const struct efusekey_info* theCfgKeyInf = NULL;
+
+    ret = _get_cfg_key_inf_byname(keyname, &theCfgKeyInf);
+    if (ret) {
+        EFUSE_ERR("not name cfg in dts.\n");
+        return __LINE__;
+    }
+
+    *pSz = theCfgKeyInf->size;
+    return 0;
+}
+
+int efuse_usr_api_write_key(const char* keyname, const void* keydata, const unsigned dataSz)
+{
+    int ret = 0;
+    const struct efusekey_info* theCfgKeyInf = NULL;
+
+    ret = _get_cfg_key_inf_byname(keyname, &theCfgKeyInf);
+    if (ret) {
+        EFUSE_ERR("not name cfg in dts.\n");
+        return __LINE__;
+    }
+    if (dataSz != theCfgKeyInf->size) {
+        EFUSE_ERR("dataSz 0x%x != cfg size 0x%x\n", dataSz, theCfgKeyInf->size);
+        return __LINE__;
+    }
+
+    ret = efuse_write_usr((char*)keydata, theCfgKeyInf->size, (loff_t*)&theCfgKeyInf->offset);
+    if (ret < 0) {
+        EFUSE_ERR("error: efuse write fail.\n");
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+//usrefuse read mac $loadaddr (size)
+int efuse_usr_api_read_key(const char* keyname, void* databuf, const unsigned bufSz)
+{
+    int ret = 0;
+    const struct efusekey_info* theCfgKeyInf = NULL;
+    loff_t offset = 0;
+
+    ret = _get_cfg_key_inf_byname(keyname, &theCfgKeyInf);
+    if (ret) {
+        EFUSE_ERR("not name cfg in dts.\n");
+        return __LINE__;
+    }
+    const unsigned cfgCnt = theCfgKeyInf->size;
+    if (cfgCnt > bufSz && bufSz) {
+        EFUSE_ERR("cfg size 0x%x > bufsz 0x%x\n", cfgCnt, bufSz);
+        return __LINE__;
+    }
+    EFUSE_DBG("keyname=%s, databuf=%p, bufSz=%d, cfgCnt=%u\n", keyname, databuf, bufSz, cfgCnt);
+
+    offset = theCfgKeyInf->offset;
+    memset(databuf, cfgCnt, 0);
+    ret = efuse_read_usr((char*)databuf, cfgCnt, &offset);
+    if (ret == -1) {
+        EFUSE_ERR("ERROR: efuse read user data fail!, size=%u, offset=%llu\n", cfgCnt, offset);
+        return __LINE__;
+    }
+
+    if (ret != cfgCnt) {
+        EFUSE_ERR("ERROR: read %d byte(s) not wanted %d byte(s) data\n", ret, cfgCnt);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+static int hex_ascii_to_buf(const char* input, uint8_t* buf, const unsigned bufSz)
+{
+    int ret = 0;
+    const char* tmpStr = input;
+    const unsigned inputLen = strlen(input);
+    int i = 0;
+
+    if (!inputLen) {
+        EFUSE_ERR("err input len 0\n");
+        return __LINE__;
+    }
+    if ( ((inputLen>>1)<<1) != inputLen ) {
+        EFUSE_ERR("inputLen %d not even\n", inputLen);
+        return __LINE__;
+    }
+    if (bufSz * 2 > inputLen) {
+        EFUSE_ERR("bufSz %d not enough\n", bufSz);
+        return __LINE__;
+    }
+    for (tmpStr = input; *tmpStr; ++tmpStr)
+    {
+        char c = *tmpStr;
+        ret = isxdigit(c);
+        if (!ret) {
+            EFUSE_ERR("input(%s) contain non xdigit, c=%c\n", input, c);
+            return __LINE__;
+        }
+    }
+
+    for (i = 0; i < inputLen; i += 2)
+    {
+        char tmpByte[8];
+        tmpByte[2] = '\0';
+        tmpByte[0] = input[i];
+        tmpByte[1] = input[i + 1];
+
+        const unsigned val = simple_strtoul(tmpByte, NULL, 16);
+        if (val > 0xff) {
+            EFUSE_ERR("Exception: val 0x%x > 0xff\n", val);
+            return __LINE__;
+        }
+        buf[i>>1] = val;
+    }
+
+    return 0;
+}
+
+static int do_usr_efuse_api(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* subcmd = argv[1];
+    if (argc < 2) return CMD_RET_USAGE;
+
+    if (!strcmp("init", subcmd))
+    {
+        const char* dtbLoadAddr = NULL;
+        if (argc > 2)
+        {
+            dtbLoadAddr = (char*)simple_strtoul(argv[2], NULL, 0);
+        }
+        else
+        {
+            dtbLoadAddr = getenv("dtb_mem_addr");
+            if (!dtbLoadAddr) {
+                setenv("dtb_mem_addr", simple_itoa(CONFIG_SYS_SDRAM_BASE + (16U<<20)));
+            }
+            dtbLoadAddr = (char*)simple_strtoul(dtbLoadAddr, NULL, 0);
+        }
+        ret = efuse_usr_api_init_dtb(dtbLoadAddr);
+    }
+    else if(!strcmp("size", subcmd))
+    {
+        const char* keyname = argv[2];
+        unsigned keysize = argc > 3 ? simple_strtoul(argv[3], NULL, 0) : 0;
+
+        ret = efuse_usr_api_get_cfg_key_size(keyname, &keysize);
+        EFUSE_MSG("keysize=%d\n", keysize);
+    }
+    else if(!strcmp("read", subcmd))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+        const char* keyname = argv[2];
+        char* databuf = (char*)simple_strtoul(argv[3], NULL, 16);
+        unsigned bufSz = argc > 4 ? simple_strtoul(argv[4], NULL, 0) : 0;
+
+        if (!bufSz)
+        {
+            ret =  efuse_usr_api_get_cfg_key_size(keyname, &bufSz);
+            if (ret) {
+                EFUSE_ERR("Fail in get sz for key[%s]\n", keyname);
+                return __LINE__;
+            }
+        }
+
+        ret = efuse_usr_api_read_key(keyname, databuf, bufSz);
+        if (!ret)
+        {
+            int i = 0;
+            printf("efuse read data");
+            for (i = 0; i < bufSz; i++) {
+                if (i%8 == 0) printf("\n[0x%02x]:", i);
+                printf("%02x ", databuf[i]);
+            }
+            printf("\n");
+        }
+    }
+    else if(!strcmp("write", subcmd))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+        const char* keyname = argv[2];
+        char* keydata = (char*)simple_strtoul(argv[3], NULL, 16);
+        unsigned bufSz = argc > 4 ? simple_strtoul(argv[4], NULL, 0) : 0;
+        uint8_t* tmpBuf = NULL;
+
+        if (!bufSz)
+        {
+            const char* input = argv[3];
+            bufSz = ( strlen(input) >> 1 );
+            tmpBuf = malloc(bufSz);
+
+            ret = hex_ascii_to_buf(input, tmpBuf, bufSz);
+            if (ret) {
+                EFUSE_ERR("Failed in change hex ascii to buf\n");
+                return __LINE__;
+            }
+            keydata = (char*)tmpBuf;
+        }
+        ret = efuse_usr_api_write_key(keyname, keydata, bufSz);
+        if (tmpBuf) free(tmpBuf) ;
+    }
+
+    return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+	efuse_user,
+    5,  //max argc
+    1,	//repeatable
+    do_usr_efuse_api,
+	"efuse user space read write ops",
+	"init <dtbAddr>  --- init efuse user space\n"
+	"size keyname <addr>  --- get key size configured in dts\n"
+	"read keyname addr <size> --- read key value to mem addr \n"
+	"write --- write key value\n"
+	"       efuse_user write keyname hexstring --- write key value in hex string\n"
+	"       efuse_user write keyname addr size --- write key value, U need load you key value into mem addr first\n"
+);
+
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index d21302f..5f1cea6 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -4,3 +4,9 @@ config DM_GPIO
 	help
 	  If you want to use driver model for GPIO drivers, say Y.
 	  To use legacy GPIO drivers, say N.
+
+config AML_GPIO
+	bool "Enable Amlogic GPIO drivers"
+	depends on DM_GPIO
+	help
+	  If you want to use Amlogic gpio driver say yes
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index aa11f15..8d95da9 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -37,3 +37,4 @@ obj-$(CONFIG_ADI_GPIO2)	+= adi_gpio2.o
 obj-$(CONFIG_TCA642X)		+= tca642x.o
 oby-$(CONFIG_SX151X)		+= sx151x.o
 obj-$(CONFIG_SUNXI_GPIO)	+= sunxi_gpio.o
+obj-$(CONFIG_AML_GPIO)		+= amlogic_gpio.o
diff --git a/drivers/gpio/amlogic_gpio.c b/drivers/gpio/amlogic_gpio.c
new file mode 100644
index 0000000..2054b27
--- /dev/null
+++ b/drivers/gpio/amlogic_gpio.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2015 Amlogic Inc
+ * Written by Xing Xu <xing.xu@amlogic.com>
+ */
+#include <common.h>
+#include <dm.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <aml_gpio.h>
+extern int  clear_pinmux(unsigned int pin);
+/* set GPIO pin 'gpio' as an input */
+static int aml_gpio_direction_input(struct udevice *dev, unsigned offset)
+{
+	struct meson_bank *plat = dev_get_platdata(dev);
+	unsigned int reg = plat->regs[REG_DIR].reg;
+	unsigned int bit = plat->regs[REG_DIR].bit + offset;
+	regmap_update_bits(reg,BIT(bit),BIT(bit));
+	return 0;
+}
+
+/* set GPIO pin 'gpio' as an output, with polarity 'value' */
+static int aml_gpio_direction_output(struct udevice *dev, unsigned offset,
+				       int value)
+{
+	struct meson_bank *plat = dev_get_platdata(dev);
+	unsigned long reg = plat->regs[REG_OUT].reg;
+	unsigned int bit = plat->regs[REG_OUT].bit + offset;
+	regmap_update_bits(reg,BIT(bit),value ? BIT(bit) : 0);
+	reg = plat->regs[REG_DIR].reg;
+	bit = plat->regs[REG_DIR].bit + offset;
+	regmap_update_bits(reg,BIT(bit),0);
+
+	return 0;
+}
+
+/* read GPIO IN value of pin 'gpio' */
+static int aml_gpio_get_value(struct udevice *dev, unsigned offset)
+{
+	struct meson_bank *plat = dev_get_platdata(dev);
+	unsigned long reg = plat->regs[REG_IN].reg;
+	unsigned int bit = plat->regs[REG_IN].bit + offset;
+	unsigned int val;
+	val = readl(reg);
+
+	return !!(val & BIT(bit));
+}
+
+/* write GPIO OUT value to pin 'gpio' */
+static int aml_gpio_set_value(struct udevice *dev, unsigned offset,
+				 int value)
+{
+	struct meson_bank *plat = dev_get_platdata(dev);
+	unsigned int reg = plat->regs[REG_OUT].reg;
+	unsigned int bit = plat->regs[REG_OUT].bit + offset;
+	regmap_update_bits(reg,BIT(bit),value ? BIT(bit) : 0);
+
+	return 0;
+}
+
+static int aml_gpio_get_function(struct udevice *dev, unsigned offset)
+{
+
+	struct meson_bank *plat = dev_get_platdata(dev);
+	unsigned long reg = plat->regs[REG_DIR].reg;
+	unsigned int bit = plat->regs[REG_DIR].bit + offset;
+	unsigned int val;
+	val = readl(reg);
+	bool dir = !!(val * BIT(bit));
+
+
+	/* GPIOF_FUNC is not implemented yet */
+	if (dir)
+		return GPIOF_INPUT;
+	else
+		return GPIOF_OUTPUT;
+}
+static int aml_gpio_request(struct udevice *dev, unsigned offset, const char *label)
+{
+	struct meson_bank *plat = dev_get_platdata(dev);
+	clear_pinmux(plat->first + offset);
+	return 0;
+}
+static const struct dm_gpio_ops gpio_aml_ops = {
+	.request			= aml_gpio_request,
+	.direction_input	= aml_gpio_direction_input,
+	.direction_output	= aml_gpio_direction_output,
+	.get_value		= aml_gpio_get_value,
+	.set_value		= aml_gpio_set_value,
+	.get_function		= aml_gpio_get_function,
+};
+
+static int aml_gpio_probe(struct udevice *dev)
+{
+	struct meson_bank *plat = dev_get_platdata(dev);
+	struct gpio_dev_priv *uc_priv = dev->uclass_priv;
+
+	uc_priv->bank_name = plat->name;
+	uc_priv->gpio_base = plat->first;
+	uc_priv->gpio_count = plat->last - plat->first +1;
+
+	return 0;
+}
+
+U_BOOT_DRIVER(gpio_aml) = {
+	.name	= "gpio_aml",
+	.id	= UCLASS_GPIO,
+	.ops	= &gpio_aml_ops,
+	.probe	= aml_gpio_probe,
+};
+
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index 6f3c86c..fbbec22 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -32,3 +32,4 @@ obj-$(CONFIG_SYS_I2C_SH) += sh_i2c.o
 obj-$(CONFIG_SYS_I2C_SOFT) += soft_i2c.o
 obj-$(CONFIG_SYS_I2C_TEGRA) += tegra_i2c.o
 obj-$(CONFIG_SYS_I2C_ZYNQ) += zynq_i2c.o
+obj-$(CONFIG_SYS_I2C_AML) += aml_i2c.o
diff --git a/drivers/i2c/aml_i2c.c b/drivers/i2c/aml_i2c.c
new file mode 100644
index 0000000..0f89adb
--- /dev/null
+++ b/drivers/i2c/aml_i2c.c
@@ -0,0 +1,976 @@
+
+/*
+ * drivers/i2c/aml_i2c.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <linux/types.h>
+//#include <linux/mtd/compat.h>
+#include <asm-generic/errno.h>
+
+#include <asm/arch/clock.h>
+#include <asm/arch/i2c.h>
+#include <asm/arch/io.h>
+
+#include <aml_i2c.h>
+
+
+#define AML_I2C_CTRL_CLK_DELAY_MASK    (0x3FF)
+#define AML_I2C_SLAVE_ADDR_MASK        (0xFF)
+#define AML_I2C_SLAVE_ADDR_MASK_7BIT   (0x7F)
+
+#define AML_I2C_ASSERT(X)							\
+do {												\
+	if (unlikely(!(X))) {							\
+		printf("\n");								\
+		printf("CacheFiles: Assertion failed\n");	\
+		BUG();										\
+	}												\
+} while (0)
+
+
+#define AML_I2C_DBG(level,fmt,args... ) do { \
+	if (g_aml_i2c_data.i2c_debug > level) 	 \
+		printf(fmt,##args); 				 \
+}while(0)
+
+static unsigned char g_bAmlogicI2CInitialized = 0; //I2C initialized flag
+
+static struct aml_i2c g_aml_i2c_data = {
+	.i2c_debug     = 0,
+	.cur_slave_addr= 0,
+	.wait_count    = 0,
+	.wait_ack_interval = 0,
+	.wait_read_interval= 0,
+	.wait_xfer_interval= 0,
+	.master_no = 0,
+	.msg_flags = 0,
+	.ops       = 0,
+	.master_regs = 0,
+	.reg_base    = 0,
+	.use_pio     = 0,
+	.master_i2c_speed= 0,
+};
+
+static void aml_i2c_set_clk(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	unsigned int i2c_clock_set;
+	unsigned int sys_clk;
+	struct aml_i2c_reg_ctrl* ctrl;
+	//have not thought about sleep mode, sleep mode is low system clock
+	sys_clk = get_clk81();
+	AML_I2C_DBG(1, "clk81 is 0x%x\n", sys_clk);
+
+	i2c_clock_set = sys_clk / i2c->master_i2c_speed;
+
+	AML_I2C_DBG(1, "i2c->master_i2c_speed is 0x%x\n", i2c->master_i2c_speed);
+#if 1
+	i2c_clock_set >>= 1;
+	ctrl = (struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl);
+	if (i2c_clock_set > 0xfff) i2c_clock_set = 0xfff;
+	ctrl->clk_delay = i2c_clock_set & 0x3ff;
+	ctrl->clk_delay_ext = i2c_clock_set >> 10;
+	i2c->master_regs->i2c_slave_addr &= ~(0xfff<<16);
+	i2c->master_regs->i2c_slave_addr |= (i2c_clock_set>>1)<<16;
+	i2c->master_regs->i2c_slave_addr |= 1<<28;
+	i2c->master_regs->i2c_slave_addr &= ~(0x3f<<8); //no filter on scl&sda
+#else
+	i2c_clock_set >>= 2;
+
+	AML_I2C_DBG(1, "i2c_clock_set is 0x%x\n", i2c_clock_set);
+
+	ctrl = (struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl);
+	ctrl->clk_delay = i2c_clock_set & AML_I2C_CTRL_CLK_DELAY_MASK;
+#endif
+}
+
+static void aml_i2c_set_platform_data(struct aml_i2c *i2c,
+										struct aml_i2c_platform *plat)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	i2c->master_i2c_speed = plat->master_i2c_speed;
+	i2c->wait_count = plat->wait_count;
+	i2c->wait_ack_interval = plat->wait_ack_interval;
+	i2c->wait_read_interval = plat->wait_read_interval;
+	i2c->wait_xfer_interval = plat->wait_xfer_interval;
+
+	if (I2C_MASTER_A == i2c->master_no) {
+		i2c->master_pinmux.scl_reg = plat->master_a_pinmux.scl_reg;
+		i2c->master_pinmux.scl_bit = plat->master_a_pinmux.scl_bit;
+		i2c->master_pinmux.sda_reg = plat->master_a_pinmux.sda_reg;
+		i2c->master_pinmux.sda_bit = plat->master_a_pinmux.sda_bit;
+	}
+	else if(I2C_MASTER_B == i2c->master_no){
+		i2c->master_pinmux.scl_reg = plat->master_b_pinmux.scl_reg;
+		i2c->master_pinmux.scl_bit = plat->master_b_pinmux.scl_bit;
+		i2c->master_pinmux.sda_reg = plat->master_b_pinmux.sda_reg;
+		i2c->master_pinmux.sda_bit = plat->master_b_pinmux.sda_bit;
+	}
+#ifdef HAS_AO_MODULE
+	else if(I2C_MASTER_AO == i2c->master_no){
+		i2c->master_pinmux.scl_reg = plat->master_ao_pinmux.scl_reg;
+		i2c->master_pinmux.scl_bit = plat->master_ao_pinmux.scl_bit;
+		i2c->master_pinmux.sda_reg = plat->master_ao_pinmux.sda_reg;
+		i2c->master_pinmux.sda_bit = plat->master_ao_pinmux.sda_bit;
+	}
+#endif
+
+}
+
+static void aml_i2c_pinmux_master(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	unsigned int scl_pinmux;
+	unsigned int sda_pinmux;
+
+	scl_pinmux = readl(i2c->master_pinmux.scl_reg);
+	scl_pinmux |= i2c->master_pinmux.scl_bit;
+	writel(scl_pinmux, i2c->master_pinmux.scl_reg);
+
+	sda_pinmux = readl(i2c->master_pinmux.sda_reg);
+	sda_pinmux |= i2c->master_pinmux.sda_bit;
+	writel(sda_pinmux, i2c->master_pinmux.sda_reg);
+}
+
+static void aml_i2c_dbg(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	int i;
+	struct aml_i2c_reg_ctrl* ctrl;
+
+	if (i2c->i2c_debug == 0)
+		return ;
+
+	printf( "i2c_slave_addr:  0x%x\n",
+								i2c->master_regs->i2c_slave_addr);
+	printf( "i2c_token_list_0:  0x%x\n",
+								i2c->master_regs->i2c_token_list_0);
+	printf( "i2c_token_list_1:  0x%x\n",
+								i2c->master_regs->i2c_token_list_1);
+	printf( "i2c_token_wdata_0:  0x%x\n",
+								i2c->master_regs->i2c_token_wdata_0);
+	printf( "i2c_token_wdata_1:  0x%x\n",
+								i2c->master_regs->i2c_token_wdata_1);
+	printf( "i2c_token_rdata_0:  0x%x\n",
+								i2c->master_regs->i2c_token_rdata_0);
+	printf( "i2c_token_rdata_1:  0x%x\n",
+								i2c->master_regs->i2c_token_rdata_1);
+	for (i=0; i<AML_I2C_MAX_TOKENS; i++)
+		printf("token_tag[%d]  %d\n", i, i2c->token_tag[i]);
+
+	ctrl = ((struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl));
+	printf( "i2c_ctrl:  0x%x\n", i2c->master_regs->i2c_ctrl);
+	printf( "ctrl.rdsda  0x%x\n", ctrl->rdsda);
+	printf( "ctrl.rdscl  0x%x\n", ctrl->rdscl);
+	printf( "ctrl.wrsda  0x%x\n", ctrl->wrsda);
+	printf( "ctrl.wrscl  0x%x\n", ctrl->wrscl);
+	printf( "ctrl.manual_en  0x%x\n", ctrl->manual_en);
+	printf( "ctrl.clk_delay  0x%x\n", ctrl->clk_delay);
+	printf( "ctrl.rd_data_cnt  0x%x\n", ctrl->rd_data_cnt);
+	printf( "ctrl.cur_token  0x%x\n", ctrl->cur_token);
+	printf( "ctrl.error  0x%x\n", ctrl->error);
+	printf( "ctrl.status  0x%x\n", ctrl->status);
+	printf( "ctrl.ack_ignore  0x%x\n", ctrl->ack_ignore);
+	printf( "ctrl.start  0x%x\n", ctrl->start);
+
+}
+
+static void aml_i2c_clear_token_list(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	i2c->master_regs->i2c_token_list_0 = 0;
+	i2c->master_regs->i2c_token_list_1 = 0;
+	memset(i2c->token_tag, TOKEN_END, AML_I2C_MAX_TOKENS);
+}
+
+static void aml_i2c_set_token_list(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	int i;
+	unsigned int token_reg=0;
+
+	for (i=0; i<AML_I2C_MAX_TOKENS; i++)
+		token_reg |= i2c->token_tag[i]<<(i*4);
+
+	i2c->master_regs->i2c_token_list_0=token_reg;
+}
+
+static void aml_i2c_hw_init(struct aml_i2c *i2c, unsigned int use_pio)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	struct aml_i2c_reg_ctrl* ctrl;
+
+	aml_i2c_set_clk(i2c);
+
+	/*manual mode*/
+	if (use_pio) {
+		ctrl = (struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl);
+		ctrl->manual_en = 1;
+	}
+}
+
+static int aml_i2c_check_error(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	struct aml_i2c_reg_ctrl* ctrl;
+	ctrl = (struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl);
+
+	if (ctrl->error)
+	{
+		//printf( "ctrl.cur_token  0x%x\n", ctrl->cur_token);
+		return -EIO;
+	}
+	else
+		return 0;
+}
+
+/*poll status*/
+static int aml_i2c_wait_ack(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	int i;
+	struct aml_i2c_reg_ctrl* ctrl;
+
+	for (i=0; i<i2c->wait_count; i++) {
+		udelay(i2c->wait_ack_interval);
+		ctrl = (struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl);
+		if (I2C_IDLE == ctrl->status)
+			return aml_i2c_check_error(i2c);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static void aml_i2c_get_read_data(struct aml_i2c *i2c, unsigned char *buf,
+														size_t len)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	int i;
+	unsigned long rdata0 = i2c->master_regs->i2c_token_rdata_0;
+	unsigned long rdata1 = i2c->master_regs->i2c_token_rdata_1;
+
+	for (i=0; i< min_t(size_t, len, AML_I2C_MAX_TOKENS>>1); i++)
+		*buf++ = (rdata0 >> (i*8)) & 0xff;
+
+	for (; i< min_t(size_t, len, AML_I2C_MAX_TOKENS); i++)
+		*buf++ = (rdata1 >> ((i - (AML_I2C_MAX_TOKENS>>1))*8)) & 0xff;
+}
+
+static void aml_i2c_fill_data(struct aml_i2c *i2c, unsigned char *buf,
+							size_t len)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	int i;
+	unsigned int wdata0 = 0;
+	unsigned int wdata1 = 0;
+
+	for (i=0; i< min_t(size_t, len, AML_I2C_MAX_TOKENS>>1); i++)
+		wdata0 |= (*buf++) << (i*8);
+
+	for (; i< min_t(size_t, len, AML_I2C_MAX_TOKENS); i++)
+		wdata1 |= (*buf++) << ((i - (AML_I2C_MAX_TOKENS>>1))*8);
+
+	i2c->master_regs->i2c_token_wdata_0 = wdata0;
+	i2c->master_regs->i2c_token_wdata_1 = wdata1;
+}
+
+static void aml_i2c_xfer_prepare(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	aml_i2c_pinmux_master(i2c);
+	aml_i2c_set_clk(i2c);
+}
+
+static void aml_i2c_start_token_xfer(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+
+	i2c->master_regs->i2c_ctrl &= ~1;  /*clear*/
+	i2c->master_regs->i2c_ctrl |= 1;   /*set*/
+
+	udelay(i2c->wait_xfer_interval);
+}
+
+/*Amlogic I2C controller will send write data with slave addr in the token list,
+    and set addr into addr reg is enough*/
+static int aml_i2c_do_address(struct aml_i2c *i2c, unsigned int addr)
+{
+    AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+
+    i2c->cur_slave_addr = addr & AML_I2C_SLAVE_ADDR_MASK_7BIT;
+#if 1
+    i2c->master_regs->i2c_slave_addr &=(~AML_I2C_SLAVE_ADDR_MASK);
+
+    i2c->master_regs->i2c_slave_addr |=(i2c->cur_slave_addr<<1);
+#else
+	i2c->master_regs->i2c_slave_addr = i2c->cur_slave_addr<<1;
+#endif
+    return 0;
+}
+
+static void aml_i2c_stop(struct aml_i2c *i2c)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	// aml_i2c_clear_token_list(i2c);
+	// i2c->token_tag[0]=TOKEN_STOP;
+	// aml_i2c_set_token_list(i2c);
+	// aml_i2c_start_token_xfer(i2c);
+	// aml_i2c_wait_ack(i2c);
+	struct aml_i2c_reg_ctrl* ctrl;
+	ctrl = (struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl);
+	if (!ctrl->error) {
+		AML_I2C_DBG(1, "FILE1:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+		aml_i2c_clear_token_list(i2c);
+		i2c->token_tag[0]=TOKEN_STOP;
+		aml_i2c_set_token_list(i2c);
+		aml_i2c_start_token_xfer(i2c);
+		aml_i2c_wait_ack(i2c);
+	}
+}
+
+static long aml_i2c_read(struct aml_i2c *i2c, unsigned char *buf,
+							size_t len)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	int i;
+	int ret;
+	size_t rd_len;
+	int tagnum=0;
+
+	aml_i2c_clear_token_list(i2c);
+
+	if (!(i2c->msg_flags & I2C_M_NOSTART)) {
+		i2c->token_tag[tagnum++]=TOKEN_START;
+		i2c->token_tag[tagnum++]=TOKEN_SLAVE_ADDR_READ;
+
+		aml_i2c_set_token_list(i2c);
+		aml_i2c_dbg(i2c);
+		aml_i2c_start_token_xfer(i2c);
+
+		udelay(i2c->wait_ack_interval);
+
+		ret = aml_i2c_wait_ack(i2c);
+		if (ret<0)
+			return ret;
+		aml_i2c_clear_token_list(i2c);
+	}
+
+	while (len) {
+		tagnum = 0;
+		rd_len = min_t(size_t, len, AML_I2C_MAX_TOKENS);
+		if (rd_len == 1)
+			i2c->token_tag[tagnum++]=TOKEN_DATA_LAST;
+		else{
+			for (i=0; i<rd_len-1; i++)
+				i2c->token_tag[tagnum++]=TOKEN_DATA;
+			if (len > rd_len)
+				i2c->token_tag[tagnum++]=TOKEN_DATA;
+			else
+				i2c->token_tag[tagnum++]=TOKEN_DATA_LAST;
+		}
+		aml_i2c_set_token_list(i2c);
+		aml_i2c_dbg(i2c);
+		aml_i2c_start_token_xfer(i2c);
+
+		udelay(i2c->wait_ack_interval);
+
+		ret = aml_i2c_wait_ack(i2c);
+		if (ret<0)
+			return ret;
+
+		aml_i2c_get_read_data(i2c, buf, rd_len);
+		len -= rd_len;
+		buf += rd_len;
+
+		aml_i2c_dbg(i2c);
+		udelay(i2c->wait_read_interval);
+		aml_i2c_clear_token_list(i2c);
+	}
+	return 0;
+}
+
+static long aml_i2c_write(struct aml_i2c *i2c, unsigned char *buf,
+							size_t len)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	int i;
+	int ret;
+	size_t wr_len;
+	int tagnum=0;
+
+	aml_i2c_clear_token_list(i2c);
+
+	if (!(i2c->msg_flags & I2C_M_NOSTART)) {
+		i2c->token_tag[tagnum++]=TOKEN_START;
+		i2c->token_tag[tagnum++]=TOKEN_SLAVE_ADDR_WRITE;
+	}
+	while (len) {
+		wr_len = min_t(size_t, len, AML_I2C_MAX_TOKENS-tagnum);
+		for (i=0; i<wr_len; i++)
+			i2c->token_tag[tagnum++]=TOKEN_DATA;
+
+		aml_i2c_set_token_list(i2c);
+
+		aml_i2c_fill_data(i2c, buf, wr_len);
+
+		aml_i2c_dbg(i2c);
+		aml_i2c_start_token_xfer(i2c);
+
+		len -= wr_len;
+		buf += wr_len;
+		tagnum = 0;
+
+		ret = aml_i2c_wait_ack(i2c);
+		if (ret<0)
+			return ret;
+
+		aml_i2c_clear_token_list(i2c);
+		}
+	return 0;
+}
+
+static struct aml_i2c_ops g_aml_i2c_m1_ops = {
+	.xfer_prepare = aml_i2c_xfer_prepare,
+	.read 		  = aml_i2c_read,
+	.write 		  = aml_i2c_write,
+	.do_address	  = aml_i2c_do_address,
+	.stop		  = aml_i2c_stop,
+};
+
+/*General i2c master transfer*/
+int aml_i2c_xfer(struct i2c_msg *msgs,
+							int num)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+
+	if (0 == g_bAmlogicI2CInitialized) {
+		return -ENXIO; //device not initialized
+		}
+
+	struct aml_i2c *i2c = &g_aml_i2c_data;
+	struct i2c_msg * p=0;
+	unsigned int i;
+	unsigned int ret=0;
+
+	i2c->ops->xfer_prepare(i2c);
+
+	for (i = 0; !ret && i < num; i++) {
+		p = &msgs[i];
+		i2c->msg_flags = p->flags;
+		ret = i2c->ops->do_address(i2c, p->addr);
+		if (ret || !p->len)
+		{
+			continue;
+		}
+		if (p->flags & I2C_M_RD)
+			ret = i2c->ops->read(i2c, p->buf, p->len);
+		else
+			ret = i2c->ops->write(i2c, p->buf, p->len);
+	}
+
+	i2c->ops->stop(i2c);
+
+
+	if (p->flags & I2C_M_RD) {
+		AML_I2C_DBG(0, "read ");
+	}
+	else {
+		AML_I2C_DBG(0, "write ");
+	}
+	for (i=0;i<p->len;i++)
+		AML_I2C_DBG(0, "%x-",*(p->buf)++);
+	AML_I2C_DBG(0, "\n");
+
+	/* Return the number of messages processed, or the error code*/
+	if (ret == 0)
+		return num;
+	else {
+		printf("[aml_i2c_xfer] error ret = %d \t", ret);
+		printf("i2c master %s current slave addr is 0x%x\n",
+						i2c->master_no?"a":"b", i2c->cur_slave_addr);
+		return ret;
+	}
+}
+
+/*General i2c master transfer 100k*/
+int aml_i2c_xfer_slow(struct i2c_msg *msgs,
+							int num)
+{
+	AML_I2C_DBG(1, "FILE:%s:%d, FUNC:%s\n", __FILE__,__LINE__,__func__);
+	struct aml_i2c *i2c = &g_aml_i2c_data;
+	struct i2c_msg * p=0;
+	unsigned int i;
+	unsigned int ret=0;
+	unsigned int last_speed = i2c->master_i2c_speed;
+
+
+	i2c->master_i2c_speed = AML_I2C_SPPED_100K;/* change speed in i2c->lock*/
+	i2c->ops->xfer_prepare(i2c);
+
+	for (i = 0; !ret && i < num; i++) {
+		p = &msgs[i];
+		i2c->msg_flags = p->flags;
+		//ret = i2c->ops->do_address(i2c, p->addr, p->buf, p->flags & I2C_M_RD, p->len);
+		ret = i2c->ops->do_address(i2c, p->addr);
+		if (ret || !p->len)
+			continue;
+		if (p->flags & I2C_M_RD)
+			ret = i2c->ops->read(i2c, p->buf, p->len);
+		else
+			ret = i2c->ops->write(i2c, p->buf, p->len);
+	}
+
+	i2c->ops->stop(i2c);
+
+
+	AML_I2C_DBG(0, "aml_i2c_xfer_slow");
+	if (p->flags & I2C_M_RD) {
+		AML_I2C_DBG(0, "read ");
+	}
+	else {
+		AML_I2C_DBG(0, "write ");
+	}
+	for (i=0;i<p->len;i++)
+		AML_I2C_DBG(0, "%x-",*(p->buf)++);
+	AML_I2C_DBG(0, "\n");
+
+	i2c->master_i2c_speed = last_speed;
+	/* Return the number of messages processed, or the error code*/
+	if (ret == 0)
+		return num;
+	else
+		return ret;
+}
+
+
+/***************i2c class****************/
+
+__attribute__((unused))  static ssize_t show_i2c_debug(void)
+{
+	struct aml_i2c *i2c = &g_aml_i2c_data;
+	printf("i2c debug is 0x%x\n", i2c->i2c_debug);
+	return 0;
+}
+
+__attribute__((unused))  static ssize_t show_i2c_info(void)
+{
+	struct aml_i2c *i2c = &g_aml_i2c_data;
+	struct aml_i2c_reg_ctrl* ctrl;
+
+	printf( "i2c master %s current slave addr is 0x%x\n",
+						i2c->master_no?"b":"a", i2c->cur_slave_addr);
+	printf( "wait ack timeout is 0x%x\n",
+							i2c->wait_count * i2c->wait_ack_interval);
+	printf( "master regs base is 0x%lx \n",
+								(unsigned long)(i2c->master_regs));
+
+	ctrl = ((struct aml_i2c_reg_ctrl*)&(i2c->master_regs->i2c_ctrl));
+	printf( "i2c_ctrl:  0x%x\n", i2c->master_regs->i2c_ctrl);
+	printf( "ctrl.rdsda  0x%x\n", ctrl->rdsda);
+	printf( "ctrl.rdscl  0x%x\n", ctrl->rdscl);
+	printf( "ctrl.wrsda  0x%x\n", ctrl->wrsda);
+	printf( "ctrl.wrscl  0x%x\n", ctrl->wrscl);
+	printf( "ctrl.manual_en  0x%x\n", ctrl->manual_en);
+	printf( "ctrl.clk_delay  0x%x\n", ctrl->clk_delay);
+	printf( "ctrl.rd_data_cnt  0x%x\n", ctrl->rd_data_cnt);
+	printf( "ctrl.cur_token  0x%x\n", ctrl->cur_token);
+	printf( "ctrl.error  0x%x\n", ctrl->error);
+	printf( "ctrl.status  0x%x\n", ctrl->status);
+	printf( "ctrl.ack_ignore  0x%x\n", ctrl->ack_ignore);
+	printf( "ctrl.start  0x%x\n", ctrl->start);
+
+	printf( "i2c_slave_addr:  0x%x\n",
+								i2c->master_regs->i2c_slave_addr);
+	printf( "i2c_token_list_0:  0x%x\n",
+								i2c->master_regs->i2c_token_list_0);
+	printf( "i2c_token_list_1:  0x%x\n",
+								i2c->master_regs->i2c_token_list_1);
+	printf( "i2c_token_wdata_0:  0x%x\n",
+								i2c->master_regs->i2c_token_wdata_0);
+	printf( "i2c_token_wdata_1:  0x%x\n",
+								i2c->master_regs->i2c_token_wdata_1);
+	printf( "i2c_token_rdata_0:  0x%x\n",
+								i2c->master_regs->i2c_token_rdata_0);
+	printf( "i2c_token_rdata_1:  0x%x\n",
+								i2c->master_regs->i2c_token_rdata_1);
+
+	printf( "master pinmux\n");
+	printf( "scl_reg:  0x%lx\n", i2c->master_pinmux.scl_reg);
+	printf( "scl_bit:  0x%x\n", i2c->master_pinmux.scl_bit);
+	printf( "sda_reg:  0x%lx\n", i2c->master_pinmux.sda_reg);
+	printf( "sda_bit:  0x%x\n", i2c->master_pinmux.sda_bit);
+
+	return 0;
+}
+
+static const unsigned long g_aml_i2c_reg_start[] = {
+	[0] = MESON_I2C_MASTER_AO_START,/*master a*/
+	[1] = MESON_I2C_MASTER_A_START,/*master a*/
+	[2] = MESON_I2C_MASTER_B_START,/*master b*/
+	[3] = MESON_I2C_MASTER_C_START,/*master b*/
+	[4] = MESON_I2C_MASTER_D_START,/*master b*/
+	//    [2] = MESON_I2C_SLAVE_START,/*slave*/
+
+#ifdef HAS_AO_MODULE
+	[3] = MESON_I2C_MASTER_AO_START,/*master ao*/
+#endif
+};
+
+static int __i2c_init_flag = 0;
+
+int aml_i2c_init(void)
+{
+	extern struct aml_i2c_platform g_aml_i2c_plat;
+
+	struct aml_i2c_platform *plat = &g_aml_i2c_plat;
+	struct aml_i2c *i2c = &g_aml_i2c_data;
+
+    if (__i2c_init_flag) {
+        return 1;
+    }
+
+	if (plat == NULL)
+	{
+	  printf("\nERROR! struct aml_i2c_platform *plat is a NULL pointer!\n");
+	  return	-1;
+	}
+
+	i2c->ops = &g_aml_i2c_m1_ops;
+	i2c->master_no = plat->master_no;
+	i2c->use_pio = plat->use_pio;
+	AML_I2C_ASSERT((i2c->master_no >= 0) && (i2c->master_no <= 3));
+
+	/*master a or master b*/
+	  if (i2c->master_no >= ARRAY_SIZE(g_aml_i2c_reg_start))
+	{
+	  printf("\nERROR!	overflow: i2c->master_no = %d\n", i2c->master_no);
+	  return	-1;
+	}
+
+	i2c->master_regs = (struct aml_i2c_reg_master __iomem*)(g_aml_i2c_reg_start[i2c->master_no]);
+
+	AML_I2C_ASSERT(i2c->master_regs);
+	AML_I2C_ASSERT(plat);
+	aml_i2c_set_platform_data(i2c, plat);
+
+	aml_i2c_hw_init(i2c , i2c->use_pio);
+
+	g_bAmlogicI2CInitialized = 1;
+
+    __i2c_init_flag = 1;
+	return 0;
+}
+
+/*****************************
+ ** add by wch for cmd_i2c **
+ ****************************/
+/*
+ * i2c read cmd
+ */
+int i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	int ret = 0;
+
+    /*
+	 * I2C data address within the chip.  This can be 1 or
+	 * 2 bytes long.  Some day it might be 3 bytes long :-).
+	 * here,if it has 2 bytes long at most.
+	 */
+	uint8_t devaddr[2];
+
+	switch (alen)
+	{
+		case 0:							 //NO I2C data address within the chip.
+			   puts ("'*.0' shows no i2c data or register address within the chip. \n");
+			return -1;
+			   break;
+
+		case 1:							 //I2C data address:1 byte long within the chip.
+			   if (addr>0xff)
+			   {
+					puts ("'*.1' shows i2c data or register address 1 byte long within the chip. \n");
+					return -1;
+			   }
+			   else
+					devaddr[0] = addr & 0xff;
+			   break;
+
+		case 2:							 //I2C data address:2 bytes long within the chip.
+			   if (addr>0xffff || addr<0x1ff)
+			   {
+					puts ("'*.2' shows i2c data or register address 2 bytes long within the chip. \n");
+					return -1;
+			   }
+			   else
+			   {
+					devaddr[0] = addr & 0xff;
+					devaddr[1] = (addr >> 8) & 0xff;
+			   }
+			   break;
+
+		case 3:							 //I2C data address:3 bytes long within the chip.
+		                                 //Here,if it has 2 bytes long at most.
+			   puts ("Here,we have set i2c data address or register address 2 bytes long at most.\n");
+			   return -1;
+			   break;
+	}
+
+
+		struct i2c_msg msg[] = {
+			{
+				.addr = chip,
+				.flags = 0,
+				.len = alen,             //I2C data address length.
+				.buf = devaddr,
+			},
+			{
+				.addr = chip,
+				.flags = 1,
+				.len = len,              //read len bytes from I2C data address.
+				.buf = buffer,
+			}
+		};
+
+	ret = aml_i2c_xfer((struct i2c_msg *)msg, 2);
+    if (ret < 0) {
+        printf("%s: i2c transfer failed\n", __FUNCTION__);
+		return ret;
+    }
+
+/*
+	printf("chip=0x%x,addr=0x%x,alen=%d,len=%d",chip,addr,alen,len);
+    for (ret=0;ret<len;ret++)
+		printf(",buffer[%d]=0x%x",ret,*buffer++);
+	printf("\n");
+*/
+
+	return 0;
+}
+
+
+
+/*
+ * i2c write cmd
+ */
+int i2c_write(unsigned char chip, unsigned int addr, int alen,unsigned char *buffer, int len)
+{
+	int ret;
+	int length = 0;
+	uint8_t buff[3];
+
+    /*
+	 * I2C data address within the chip.  This can be 1 or
+	 * 2 bytes long.  Some day it might be 3 bytes long :-).
+	 * here,if it has 2 bytes long at most.
+	 */
+	uint8_t devaddr[2] = {0};
+
+	switch (alen)
+	{
+		case 0:							//NO I2C data address within the chip.
+			   puts ("'*.0' shows no i2c data or register address within the chip. \n");
+			   return -1;
+			   break;
+
+		case 1:							//I2C data address:1 byte long within the chip.
+			   if (addr>0xff)
+			   {
+					puts ("'*.1' shows i2c data or register address 1 byte long within the chip. \n");
+					return -1;
+			   }
+			   else
+					devaddr[0] = addr & 0xff;
+			   break;
+
+		case 2:							//I2C data address:2 bytes long within the chip.
+			   if (addr>0xffff || addr<0x1ff)
+			   {
+					puts ("'*.2' shows i2c data or register address 2 bytes long within the chip. \n");
+					return -1;
+			   }
+			   else
+			   {
+					devaddr[0] = addr & 0xff;
+					devaddr[1] = (addr >> 8) & 0xff;
+			   }
+			   break;
+
+		case 3:							//I2C data address:3 bytes long within the chip.
+		                                //Here,if it has 2 bytes long at most.
+			   puts ("Here,we have set i2c data address or register address 2 bytes long at most.\n");
+			   return -1;
+			   break;
+	}
+
+	if (len == 1)
+	{
+		switch (alen)
+		{
+
+			case 1:
+				   buff[0] = devaddr[0];
+				   buff[1] = *buffer;
+				   length = 2;
+			       break;
+
+			case 2:
+			       buff[0] = devaddr[0];
+			       buff[1] = devaddr[1];
+			       buff[2] = *buffer;
+			       length = 3;
+			       break;
+			/*
+			case 3:
+				   //when i2c data address or register address 3 bytes long ,here should be completed.
+				   break;
+			*/
+
+		}
+
+		struct i2c_msg msg[] = {
+			{
+			.addr = chip,
+			.flags = 0,
+			.len = length,
+			.buf = buff,
+			}
+		};
+
+		ret = aml_i2c_xfer((struct i2c_msg *)msg, 1);
+		if (ret < 0) {
+		    printf("%s: i2c transfer failed\n", __FUNCTION__);
+			    return ret;
+		}
+
+	}
+	else
+	{
+	    /*
+		 * This section may be modified when len > 1.
+	     */
+		printf("I2C write data length is %d. \n",len);
+		return -1;
+	}
+
+
+
+	return 0;
+}
+
+
+
+/*
+ * i2c probe cmd
+ * return 0:i2c probe ok, non 0:i2c probe failed.
+ */
+int i2c_probe(uchar chip)
+{
+	int ret;
+    unsigned int addr=0x00;		//i2c data or register address
+	struct aml_i2c *i2c = &g_aml_i2c_data;
+	struct i2c_msg * p=0;
+
+    struct i2c_msg msg[] = {
+			{
+			.addr = chip,
+			.flags = 0,			//write
+			.len = 1,
+			.buf = (unsigned char *)&addr,
+			}
+		};
+
+
+	i2c->ops->xfer_prepare(i2c);
+
+
+	p = &msg[0];
+	i2c->msg_flags = p->flags;
+	ret = i2c->ops->do_address(i2c, p->addr);
+
+	if (p->flags & I2C_M_RD)
+		ret = i2c->ops->read(i2c, p->buf, p->len);
+	else
+		ret = i2c->ops->write(i2c, p->buf, p->len);
+
+	i2c->ops->stop(i2c);
+
+	if (ret == 0)
+		return 0;          	 	//This chip valid.
+	else
+		return ret;         	//This chip invalid.
+}
+
+
+
+/*
+ * i2c reset cmd
+ */
+void i2c_init(int speed, int slaveaddr)
+{
+	#define AML_I2C_SPPED_400K 400000		 //The initial value of amlogic i2c speed
+
+	extern struct aml_i2c_platform g_aml_i2c_plat;
+    g_aml_i2c_plat.master_i2c_speed = AML_I2C_SPPED_400K;
+    aml_i2c_init();
+}
+
+
+
+/*
+ * i2c speed cmd
+ * get i2c speed
+ */
+unsigned int i2c_get_bus_speed(void)
+{
+
+	extern struct aml_i2c_platform g_aml_i2c_plat;
+	return g_aml_i2c_plat.master_i2c_speed;
+}
+
+
+
+/*
+ * i2c speed xxx cmd
+ * set i2c speed
+ */
+int i2c_set_bus_speed(unsigned int speed)
+{
+/*
+#define AML_I2C_SPPED_50K			50000
+#define AML_I2C_SPPED_100K			100000
+#define AML_I2C_SPPED_200K			200000
+#define AML_I2C_SPPED_300K			300000
+#define AML_I2C_SPPED_400K			400000
+*/
+	extern struct aml_i2c_platform g_aml_i2c_plat;
+
+	if ((speed == 50000) || (speed == 100000) || (speed == 200000) || (speed == 300000) || (speed == 400000))
+    {
+		g_aml_i2c_plat.master_i2c_speed = speed;
+		aml_i2c_init();
+		return 0;
+	}
+	else
+	{
+		printf("The I2C speed setting don't match,should choose:50000,100000,200000,300000 or 400000.\n");
+		return -1;
+	}
+
+}
+
diff --git a/drivers/keymanage/Makefile b/drivers/keymanage/Makefile
new file mode 100644
index 0000000..21864fa
--- /dev/null
+++ b/drivers/keymanage/Makefile
@@ -0,0 +1,31 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+obj-$(CONFIG_UNIFY_KEY_MANAGE) += aml_key_manage.o
+
+aml_key_manage-y 						 		= key_unify.o
+aml_key_manage-y 						 	   += key_manage.o
+aml_key_manage-$(CONFIG_OF_LIBFDT) 				+= km_dts.o
+aml_key_manage-$(CONFIG_AML_SECURITY_KEY) 		+= km_secure_key.o
+aml_key_manage-$(CONFIG_EFUSE) 					+= km_efuse_key.o
+
diff --git a/drivers/keymanage/key_manage.c b/drivers/keymanage/key_manage.c
new file mode 100644
index 0000000..f3e5533
--- /dev/null
+++ b/drivers/keymanage/key_manage.c
@@ -0,0 +1,794 @@
+/*
+ * \file        key_encrypt_decrypt.c
+ * \brief       encrypt a key before burn to target deive,
+ *              decrypt a key after read from target device
+ *
+ * \version     1.0.0
+ * \date        15/07/17
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "key_manage_i.h"
+#include <u-boot/sha1.h>
+#include <linux/ctype.h>
+
+enum _KmUsrKeyType{
+    KM_USER_KEY_TYPE_MAC        = 0 ,//key format is all ascii, and splitted by :
+    KM_USER_KEY_TYPE_SHA1           ,//key format is end with 20 bytes sha1sum
+    KM_USER_KEY_TYPE_HDCP2          ,//special case, can only identified with name
+    KM_USER_KEY_TYPE_RAW            ,//raw format which can burn to target directly
+};
+
+static const char* _cfgKeyTypes[] = {
+    [KM_USER_KEY_TYPE_MAC]          = "mac"     ,
+    [KM_USER_KEY_TYPE_SHA1]         = "sha1"    ,
+    [KM_USER_KEY_TYPE_HDCP2]        = "hdcp2"   ,
+    [KM_USER_KEY_TYPE_RAW]          = "raw"     ,
+};
+#define _SUPPORTED_CFG_TYPES_NUM    ( sizeof(_cfgKeyTypes) / sizeof(char*) )
+
+
+static int km_get_user_key_format(const char* srcKeyName, int* key_type)
+{
+    int ret                 = 0;
+    int   srcKeyType        = 0;
+    const char* cfgType     = NULL;
+
+    cfgType = keymanage_dts_get_key_type (srcKeyName) ;
+    if (NULL == cfgType) {
+        KM_ERR("Fail in get keytype cfg in dts for key[%s]\n", srcKeyName);
+        return __LINE__;
+    }
+
+    for (srcKeyType = 0; srcKeyType < _SUPPORTED_CFG_TYPES_NUM; ++srcKeyType)
+    {
+        ret = strcmp(cfgType, _cfgKeyTypes[srcKeyType]);
+        if (!ret) break;
+    }
+    if (srcKeyType == _SUPPORTED_CFG_TYPES_NUM) {
+        KM_ERR("prop key-type[%s] unsupported in key[%s]\n", cfgType, srcKeyName);
+        return __LINE__;
+    }
+
+    if (KM_USER_KEY_TYPE_RAW == srcKeyType)
+    {
+        do
+        {
+            ret = !strcmp(srcKeyName, "mac") || !strcmp(srcKeyName, "mac_bt") || !strcmp(srcKeyName, "mac_wifi");
+            if (ret) { srcKeyType = KM_USER_KEY_TYPE_MAC; break; }
+
+            ret = !strcmp(srcKeyName, "hdcp") ;
+            if (ret) { srcKeyType = KM_USER_KEY_TYPE_SHA1; break; }
+
+            ret = !strcmp(srcKeyName, "hdcp2") ;
+            if (ret) { srcKeyType = KM_USER_KEY_TYPE_HDCP2; break; }
+
+        }while(0);
+    }
+
+    *key_type = srcKeyType;
+    return 0;
+}
+
+#if 1//START MAC
+const int _UsrMacKeyLen = 17;
+
+//key manager user interface: mac format check and change format if needed
+static int _burn_key_in_type_mac(const char* keyname, const char* srcKeyVal, const unsigned srcKeyLen, void* decryptBuf)
+{
+    int ret = 0;
+    int index = 0;
+    ssize_t     targetKeyLen    = 0;
+    char*       dstKeyVal       = (char*)decryptBuf;
+
+    if (_UsrMacKeyLen != srcKeyLen) {
+        KM_ERR("mac len %d is invalid, must be %d\n", srcKeyLen, _UsrMacKeyLen);
+        return -EINVAL;
+    }
+
+    for (index = 0; index < _UsrMacKeyLen; index += 3)
+    {
+        int k = 0;
+        const char* p = srcKeyVal + index;
+        for (k = 0; k < 2; ++k) {
+            const char c = *p++;
+            if (!isxdigit(c)) {
+                KM_ERR("mac str(%s) fmt err at index[%d]\n", srcKeyVal, index + k);
+                return __LINE__;
+            }
+        }
+        if (':' != *p && index + k < _UsrMacKeyLen) {
+            KM_ERR("mac str(%s) fmt err at index[%d], must be :, but %c\n", srcKeyVal, index + 2, *p);
+            return __LINE__;
+        }
+    }
+
+    enum key_manager_dev_e keyDev = keymanage_dts_get_key_device(keyname);
+    if (KEY_M_MAX_DEV == keyDev) {
+        KM_ERR("Fail get key dev for key[%s]\n", keyname);
+        return __LINE__;
+    }
+    if (KEY_M_EFUSE_NORMAL != keyDev) { targetKeyLen = _UsrMacKeyLen; }
+    else
+    {//efusekey, check configure size
+        ret = key_unify_query_size(keyname, &targetKeyLen);
+        if (ret) {
+            KM_ERR("Fail at get key size, ret=%d\n", ret);
+            return __LINE__;
+        }
+
+        if (6 != targetKeyLen && targetKeyLen != _UsrMacKeyLen) {
+            KM_ERR("efuse key[%s] len %zd err\n", keyname, targetKeyLen);
+            return __LINE__;
+        }
+    }
+
+    if (_UsrMacKeyLen == targetKeyLen) {//say its target not efuse ?
+        ret =  key_unify_write(keyname, srcKeyVal, srcKeyLen);
+        return ret;
+    }
+
+    KM_DBG("targetKeyLen=%zd\n", targetKeyLen);
+    for (index = 0; index < targetKeyLen; ++index) {
+        const char *theByteStr = srcKeyVal + index * 3;
+        unsigned byteSum = 0;
+
+        byteSum = simple_strtoul(theByteStr, NULL, 16);
+        KM_DBG("byteSum[%d]=0x%x\n", index, byteSum);
+        if (byteSum > 0xff) {
+            KM_ERR("theByteStr=%s err\n", theByteStr);
+            return __LINE__;
+        }
+        dstKeyVal[index] = byteSum;
+    }
+
+    ret = key_unify_write(keyname, dstKeyVal, targetKeyLen);
+    return ret;
+}
+
+//Return value: key size that user wanted, ok if > 0
+static int _read_key_in_type_mac(const char* keyname, char* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    int ret = 0;
+    int index = 0;
+    ssize_t keyDevSz = 0;
+
+    if (_UsrMacKeyLen > bufLen) {
+        KM_ERR("mac len %d is invalid, must be %d\n", bufLen, _UsrMacKeyLen);
+        return -__LINE__;
+    }
+
+    ret = key_unify_query_size (keyname, &keyDevSz) ;
+    if (ret) {
+        KM_ERR("Fail in get key sz, ret=%d\n", ret);
+        return -__LINE__;
+    }
+
+    ret = key_unify_read (keyname, decryptBuf, (unsigned)keyDevSz) ;
+    if (ret) {
+        KM_ERR("fail in read key[%s]\n", keyname);
+        return -__LINE__;
+    }
+
+    if (_UsrMacKeyLen == keyDevSz) {
+        memcpy(databuf, decryptBuf, keyDevSz);
+        return 0;
+    }
+
+    databuf[0] = '\0';
+    for (index = 0; index < keyDevSz; ++index)
+    {
+        const unsigned byteSum = decryptBuf[index];
+
+        sprintf(databuf, "%s%02x:", databuf, byteSum);
+    }
+
+    return ret;
+}
+#endif//END MAC
+
+#if 1//Start sha1sum
+//key value which end up 20 bytes sha1sum
+//check the sha1sum and remove it after checked ok
+static int _burn_key_in_type_sha1(const char* keyname, void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    int ret = 0;
+    const unsigned srcKeyLen    = bufLen;
+    const char* srcKeyVal       = (char*)databuf;
+    const unsigned shaSumLen = 20;
+    const unsigned licLen = srcKeyLen - shaSumLen;
+    const u8* orgSum = (u8*)srcKeyVal + licLen;
+    u8 genSum[shaSumLen];
+
+    if (srcKeyLen <= 20) {
+        KM_ERR("Err key len %d for sha1 fmt\n", srcKeyLen);
+        return __LINE__;
+    }
+
+    sha1_csum((u8*)srcKeyVal, licLen, genSum);
+
+    ret = memcmp(orgSum, genSum, shaSumLen);
+    if (ret) {
+        const unsigned fmtStrLen = shaSumLen * 2 + 2;
+        char org_sha1Str[fmtStrLen + 2];
+        char gen_sha1Str[fmtStrLen + 2];
+        int byteIndex = 0;
+
+        org_sha1Str[0] = gen_sha1Str[0] = '\0';
+        for (byteIndex = 0; byteIndex < shaSumLen; ++byteIndex)
+        {
+            sprintf(org_sha1Str, "%s%02x", org_sha1Str, orgSum[byteIndex]);
+            sprintf(gen_sha1Str, "%s%02x", gen_sha1Str, genSum[byteIndex]);
+        }
+        KM_ERR("sha1sum, orgSum[%s] != genSum[%s]\n", org_sha1Str, gen_sha1Str);
+
+        return __LINE__;
+    }
+    KM_MSG("Verify key with sha1sum OK\n");
+
+    ret = key_unify_write(keyname, srcKeyVal, licLen);
+    return ret;
+}
+#endif//END sha1sum
+
+#if 1//hdcp2 rx start
+#define HDCP2_RX_LC128_LEN         (36)
+#define HDCP2_RX_KEY_LEN           (862)
+#pragma pack(push, 1)
+typedef struct _Hdcp2RxKeyFmt{
+    unsigned                version;
+    char                    lc128[HDCP2_RX_LC128_LEN];
+    char                    keyVal[HDCP2_RX_KEY_LEN];
+}Hdcp2RxKeyFmt_t;
+#pragma pack(pop)
+
+#define HDCP2_RX_KEY_TOTAL_LEN        sizeof(Hdcp2RxKeyFmt_t)
+#define HDCP2_RX_KEY_LC128_NAME       "hdcp2lc128"
+#define HDCP2_RX_KEY_NAME             "hdcp2key"
+#define HDCP2_RX_KEY_VERSION           (0x02000000U)
+#define HDCP2_VERSION_LEN               ( 4 )
+
+static char generalDataChange(const char input)
+{
+    int i;
+    char result = 0;
+
+    for (i=0; i<8; i++) {
+        if ((input & (1<<i)) != 0)
+            result |= (1<<(7-i));
+        else
+            result &= ~(1<<(7-i));
+    }
+
+    return result;
+}
+
+static void hdcp2DataEncryption(const unsigned len, const char *input, char *out)
+{
+    int i = 0;
+
+    for (i=0; i<len; i++)
+        *out++ = generalDataChange(*input++);
+}
+
+static void hdcp2DataDecryption(const unsigned len, const char *input, char *out)
+{
+    int i = 0;
+
+    for (i=0; i<len; i++)
+        *out++ = generalDataChange(*input++);
+}
+
+static int _burn_key_in_type_hdcp2(const char* keyname, void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    Hdcp2RxKeyFmt_t* pHdcp2RxKey = (Hdcp2RxKeyFmt_t*)databuf;
+    const int keyLen = HDCP2_RX_KEY_TOTAL_LEN;
+
+    if (keyLen > bufLen) {
+        KM_ERR("hdcp2 rx len unsupported. want %d but get %d\n", keyLen, bufLen);
+        return __LINE__;
+    }
+    if (HDCP2_RX_KEY_VERSION != pHdcp2RxKey->version) {
+        KM_ERR("Version value 0x%x is error, should be 0x%x\n", pHdcp2RxKey->version, HDCP2_RX_KEY_VERSION);
+        return __LINE__;
+    }
+
+    hdcp2DataEncryption(keyLen, databuf, decryptBuf);
+    KM_MSG("Ecnrypt hdcp2 END.\n");
+    pHdcp2RxKey = (Hdcp2RxKeyFmt_t*)decryptBuf;
+
+    const uint8_t* tmpName      = (uint8_t*)HDCP2_RX_KEY_LC128_NAME;
+    unsigned        tmpLen      = HDCP2_RX_LC128_LEN;
+    unsigned        isSecure    = 0;
+    ssize_t retLen = 0;
+    retLen = amlkey_write(tmpName, (uint8_t*)&pHdcp2RxKey->lc128, tmpLen , isSecure);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in write hdcp2 lc128, retLen %zd != want len %d\n", retLen, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpName = (uint8_t*)HDCP2_RX_KEY_NAME;
+    tmpLen = HDCP2_RX_KEY_LEN;
+    retLen = amlkey_write(tmpName, (uint8_t*)&pHdcp2RxKey->keyVal, tmpLen , isSecure);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in write hdcp2 key, retLen %zd != want len %d\n", retLen, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpLen = HDCP2_VERSION_LEN;
+    retLen = amlkey_write((uint8_t*)keyname, (uint8_t*)&pHdcp2RxKey->version, tmpLen, isSecure);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in write hdcp2 key, retLen %zd != want len %d\n", retLen, tmpLen) ;
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+static int _read_key_in_type_hdcp2(const char* keyname, void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    const unsigned srcKeyLen    = HDCP2_RX_KEY_TOTAL_LEN;
+    Hdcp2RxKeyFmt_t* pHdcp2RxKey = (Hdcp2RxKeyFmt_t*)decryptBuf;
+    const uint8_t* tmpName = NULL;
+    int tmpLen = 0;
+
+    if (bufLen < srcKeyLen) {
+        KM_ERR("hdcp2 rx len unsupported. want %d but only %d\n", srcKeyLen, bufLen);
+        return __LINE__;
+    }
+
+    ssize_t retLen = 0;
+    tmpName = (uint8_t*)keyname;
+    tmpLen = HDCP2_VERSION_LEN;
+    retLen = amlkey_read(tmpName, (uint8_t*)&pHdcp2RxKey->version, tmpLen);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in read key[%s] at len %d\n", tmpName, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpName = (uint8_t*)HDCP2_RX_KEY_NAME;
+    tmpLen  = HDCP2_RX_KEY_LEN;
+    retLen = amlkey_read(tmpName, (uint8_t*)&pHdcp2RxKey->keyVal, tmpLen);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in read key[%s] at len %d\n", tmpName, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpName = (uint8_t*)HDCP2_RX_KEY_LC128_NAME;
+    tmpLen  = HDCP2_RX_LC128_LEN;
+    retLen = amlkey_read(tmpName, (uint8_t*)&pHdcp2RxKey->lc128, tmpLen);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in read key[%s] at len %d\n", tmpName, tmpLen) ;
+        return __LINE__;
+    }
+
+    hdcp2DataDecryption(srcKeyLen, (char*)pHdcp2RxKey, databuf);
+
+    return 0;
+}
+#endif//hdcp2 rx end
+
+/* *
+ * APIs of key manage
+*/
+
+int key_manage_init(const char* seednum, const char* dtbaddr)
+{
+    int ret = key_unify_init(seednum, dtbaddr);
+
+    return ret;
+}
+
+int key_manage_exit(void)
+{
+    return key_unify_uninit();
+}
+
+int key_manage_write(const char* keyname, const void* keydata, const unsigned dataLen)
+{
+    int ret = 0;
+    int srcKeyType;
+    char* decryptBuf = NULL;
+    const int DecryptBufMaxLen = 64<<10;
+
+    ret = key_unify_query_key_has_configure(keyname);
+    if (!ret) {
+        KM_ERR ("There isn't cfg for key[%s]\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = km_get_user_key_format(keyname, &srcKeyType);
+    if (ret) {
+        KM_ERR ("Fail in get user key type\n") ;
+        return __LINE__;
+    }
+
+    decryptBuf = (char*)malloc(DecryptBufMaxLen);
+    switch (srcKeyType)
+    {
+        case KM_USER_KEY_TYPE_MAC:
+            {
+                ret = _burn_key_in_type_mac(keyname, (char*)keydata, dataLen, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_SHA1:
+            {
+                ret = _burn_key_in_type_sha1(keyname, (char*)keydata, dataLen, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_HDCP2:
+            {
+                ret = _burn_key_in_type_hdcp2(keyname, (char*)keydata, dataLen, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_RAW:
+            {
+                ret = key_unify_write(keyname, (char*)keydata, dataLen);
+            }
+            break;
+    }
+
+    free(decryptBuf);
+    return ret;
+}
+
+int key_manage_read(const char* keyname, void* keydata, const unsigned bufLen)
+{
+    int ret = 0;
+    ssize_t keysize = 0;
+    int srcKeyType = 0;
+    char* decryptBuf = NULL;
+    const int DecryptBufMaxLen = 64<<10;
+
+    ret = key_manage_query_size(keyname, &keysize);
+    if (ret) {
+        KM_ERR ("Fail in query key size for key[%s]\n", keyname) ;
+        return __LINE__;
+    }
+    if (keysize > bufLen) {
+        KM_ERR ("keysize %zd > bufLen %d\n", keysize, bufLen) ;
+        return __LINE__;
+    }
+
+    ret = km_get_user_key_format(keyname, &srcKeyType);
+    if (ret) {
+        KM_ERR ("Fail in get user key type\n") ;
+        return __LINE__;
+    }
+
+    decryptBuf = (char*)malloc(DecryptBufMaxLen);
+    switch (srcKeyType)
+    {
+        case KM_USER_KEY_TYPE_MAC:
+            {
+                ret = _read_key_in_type_mac(keyname, (char*)keydata, (unsigned)keysize, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_HDCP2:
+            {
+                ret = _read_key_in_type_hdcp2(keyname, keydata, (unsigned)keysize, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_SHA1:
+        case KM_USER_KEY_TYPE_RAW:
+        default:
+            {
+                ret = key_unify_read(keyname, keydata, (unsigned)keysize);
+            }
+            break;
+    }
+
+    free(decryptBuf);
+    return ret;
+}
+
+int key_manage_query_size(const char* keyname, ssize_t* keysize)
+{
+    int ret = 0;
+    int exist = 0;
+    int srcKeyType = 0;
+
+    ret = key_manage_query_exist(keyname, &exist);
+    if (ret) {
+        KM_ERR ("Fail in query key exist\n") ;
+        return __LINE__;
+    }
+    if (!exist) {
+        KM_ERR ("key[%s] not programed yet\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = km_get_user_key_format(keyname, &srcKeyType);
+    if (ret) {
+        KM_ERR ("Fail in get user key type\n") ;
+        return __LINE__;
+    }
+
+    switch (srcKeyType)
+    {
+        case KM_USER_KEY_TYPE_MAC:
+            {
+                *keysize = _UsrMacKeyLen;
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_HDCP2:
+            {
+                *keysize = HDCP2_RX_KEY_TOTAL_LEN;
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_RAW:
+        case KM_USER_KEY_TYPE_SHA1:
+        default:
+            ret = key_unify_query_size(keyname, keysize);
+    }
+
+    return ret;
+}
+
+int key_manage_query_exist(const char* keyname, int* exist)
+{
+    int ret = 0;
+
+    ret = key_unify_query_key_has_configure(keyname);
+    if (!ret) {
+        KM_ERR ("There isn't dts cfg for key[%s]\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = key_unify_query_exist(keyname, exist);
+
+    return ret;
+}
+
+int key_manage_query_secure(const char* keyname, int* isSecure)
+{
+    int ret = 0;
+    int exist = 0;
+
+    ret = key_manage_query_exist(keyname, &exist);
+    if (ret) {
+        KM_ERR ("Fail in query key exist, ret=%d\n", ret) ;
+        return __LINE__;
+    }
+    if (!exist) {
+        KM_ERR ("Key[%s] not programed yet\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = key_unify_query_secure(keyname, isSecure);
+
+    return ret;
+}
+
+int key_manage_query_canOverWrite(const char* keyname, int* canOverWrite)
+{
+    return key_unify_query_canOverWrite(keyname, canOverWrite);
+}
+
+static int do_keyman_init(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* seedNum = argv[1];
+    const char* dtbAddr = argc > 2 ? argv[2] : NULL;
+
+    if (argc < 2) return CMD_RET_USAGE;
+
+    ret = key_manage_init(seedNum, dtbAddr);
+    return ret;
+}
+
+static int do_keyman_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    return key_manage_exit();
+}
+
+//read keyname addr <fmt>
+//fmt can be hex/str, if str, env keyname will be setted
+static int do_keyman_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* keyname = argv[1];
+    char* dataBuf = NULL;
+    const char* dataFmt = argc > 3 ? argv[3] : NULL;
+    ssize_t keyLen = 0;
+    if (argc < 3) return CMD_RET_USAGE;
+
+    dataBuf = (char*)simple_strtoul(argv[2], NULL, 16);
+    if (!dataBuf) {
+        KM_ERR("Fail in parse argv[2] to dataBuf\n");
+        return __LINE__;
+    }
+
+    ret = key_manage_query_size(keyname, &keyLen);
+    if (ret) {
+        KM_DBG("Fail get sz for[%s]\n", keyname);//here occure in booting if key not burned yet!
+        return __LINE__;
+    }
+    ret = key_manage_read(keyname, dataBuf, keyLen);
+    if (ret) {
+        KM_ERR("Fail in read key[%s] at sz %zd\n", keyname, keyLen);
+        return __LINE__;
+    }
+    if (dataFmt)
+    {
+        if (!strcmp("hex", dataFmt))
+        {
+            _keyman_buf_to_hex_ascii((uint8_t*)dataBuf, keyLen, NULL);
+            return 0;
+        }
+        else if(!strcmp("str", dataFmt))
+        {
+            int i = 0;
+
+            dataBuf[keyLen] = '\0';
+            for (; i < keyLen; ++i) {
+                ret = isascii(dataBuf[i]);
+                if (!ret) {
+                    KM_MSG("key value has non ascii, can't pr\n");
+                    return CMD_RET_FAILURE;
+                }
+            }
+            setenv(keyname, dataBuf);//setenv for bootargs
+            KM_DBG("env:%s=%s\n", keyname, dataBuf);
+            return 0;
+        }
+        else KM_MSG("Err key dataFmt(%s)\n", dataFmt);
+    }
+
+    return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+//argv: 1       2       3
+//write keyname size    addr
+//write keyname hex/str value
+static int do_keyman_write(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* keyname     = argv[1];
+    const char* databuf     = NULL;
+    char*       tmpBuf      = NULL;
+    const char* inputFmt    = argv[2];
+    unsigned    dataLen     = 0;
+    if (argc < 4) return CMD_RET_USAGE;
+
+    if (!strcmp("hex", inputFmt))
+    {
+        databuf = argv[3];
+        dataLen = strlen(databuf) / 2;
+
+        tmpBuf = (char*)malloc(dataLen);
+        ret = _keyman_hex_ascii_to_buf(databuf, tmpBuf, dataLen);
+        if (ret) {
+            KM_ERR("Fail in change hex argv[3] to bin, err=%d\n", ret);
+            free(tmpBuf);
+            return CMD_RET_FAILURE;
+        }
+        databuf = tmpBuf;
+    }
+    else if(!strcmp("str", inputFmt))
+    {
+        databuf = argv[3];
+        dataLen = strlen(databuf);
+
+        const char* p = databuf;
+        for (; *p; ++p) {
+            if (!isascii(*p)) {
+                KM_ERR("inputFmt is %s, but argv[3] contain non ascii\n", inputFmt);
+                return CMD_RET_FAILURE;
+            }
+        }
+        KM_DBG("str:%s, len=%d\n", databuf, dataLen);
+    }
+    else
+    {
+        dataLen = simple_strtoul(argv[2], NULL, 0);
+        if (!dataLen) {
+            KM_ERR("dataLen err\n");
+            return __LINE__;
+        }
+        if (dataLen > (64*1024)) {
+            KM_ERR("keylen 0x%x too large!\n", dataLen);
+            return __LINE__;
+        }
+        databuf = (char*)simple_strtoul(argv[3], NULL, 16);
+    }
+
+    ret = key_manage_write(keyname, databuf, dataLen);
+    if (tmpBuf) free(tmpBuf) ;
+    return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+//query: 1          2
+//      exist       keyname
+//      secure      keyname
+//      size        keyname
+static int do_keyman_query(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* cmd     = argv[1];
+    const char* keyname = argv[2];
+    if (argc < 3) return CMD_RET_USAGE;
+
+    if (!strcmp("exist", cmd))
+    {
+        int exist = 0;
+        ret = key_manage_query_exist(keyname, &exist);
+        if (ret) {
+            KM_ERR("Fail in query key exist, err=%d", ret);
+            return CMD_RET_FAILURE;
+        }
+        KM_MSG("key[%s] is %s Exist\n", keyname, exist ? "" : "NOT");
+        ret = exist ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+    }
+    else if(!strcmp("secure", cmd))
+    {
+        int isSecure = 0;
+        ret = key_manage_query_secure(keyname, &isSecure);
+        if (ret) {
+            KM_ERR("Fail in query key secure, err=%d\n", ret);
+            return CMD_RET_FAILURE;
+        }
+        KM_MSG("key[%s] is %s Secure\n", keyname, isSecure ? "" : "NOT");
+        ret = isSecure ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+    }
+    else if(!strcmp("size", cmd))
+    {
+        ssize_t keysize = 0;
+        ret = key_manage_query_size(keyname, &keysize);
+        if (ret) {
+            KM_ERR("Fail in query key size, err=%d\n", ret);
+            return CMD_RET_FAILURE;
+        }
+        KM_MSG("key[%s] size is %zd\n", keyname, keysize);
+        ret = keysize ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+    }
+    else return CMD_RET_USAGE;
+
+    return ret;
+}
+
+static cmd_tbl_t cmd_keyman_sub[] = {
+    U_BOOT_CMD_MKENT(init,          3, 0, do_keyman_init, "", ""),
+    U_BOOT_CMD_MKENT(exit,          2, 0, do_keyman_exit, "", ""),
+    U_BOOT_CMD_MKENT(read,          4, 0, do_keyman_read, "", ""),
+    U_BOOT_CMD_MKENT(write,         4, 0, do_keyman_write, "", ""),
+    U_BOOT_CMD_MKENT(query,         3, 0, do_keyman_query, "", ""),
+};
+
+static int do_keymanage(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    cmd_tbl_t *c;
+
+    if (argc < 2) return CMD_RET_USAGE;
+
+    c = find_cmd_tbl(argv[1], cmd_keyman_sub, ARRAY_SIZE(cmd_keyman_sub));
+
+	if (!c) { return CMD_RET_USAGE;}
+
+    return	c->cmd(cmdtp, flag, --argc, ++argv);
+}
+
+U_BOOT_CMD(
+   keyman,           //command name
+   5,                   //maxargs
+   0,                   //repeatable
+   do_keymanage,   //command function
+   "Unify key ops interfaces based dts cfg",           //description
+   "    argv:  \n"   //usage
+   "    init seedNum <dtbAddr>\n"
+   "    read keyname addr <hex/str>\n"
+   "    write keyname size addr \n"
+   "    write keyname hex/str value\n"
+   "    query exist/secure/size keyname\n"
+   "    exit \n"
+);
+
diff --git a/drivers/keymanage/key_manage.h b/drivers/keymanage/key_manage.h
new file mode 100644
index 0000000..e7577fd
--- /dev/null
+++ b/drivers/keymanage/key_manage.h
@@ -0,0 +1,58 @@
+#ifndef __KEY_MANAGE_H__
+#define __KEY_MANAGE_H__
+
+enum key_manager_dev_e{
+    KEY_M_UNKNOW_DEV=0,
+    KEY_M_EFUSE_NORMAL,
+    KEY_M_SECURE_KEY,       //secure nandkey/emmckey
+    KEY_M_NORAML_KEY,       //non-secure nandkey/emmckey
+    KEY_M_MAX_DEV,
+};
+
+/*key data format*/
+enum key_manager_df_e{
+       KEY_M_HEXDATA=0,
+       KEY_M_HEXASCII,
+       KEY_M_ALLASCII,
+       KEY_M_MAX_DF,
+};
+
+enum key_manager_permit_e{
+       KEY_M_PERMIT_READ = (1<<0),
+       KEY_M_PERMIT_WRITE = (1<<1),
+       KEY_M_PERMIT_DEL    = (1<<2),
+       KEY_M_PERMIT_MASK   = 0Xf,
+};
+
+enum key_manager_type_e{
+    KEY_M_TYPE_NORMAL       = 0 ,
+    KEY_M_TYPE_MAC              ,
+    KEY_M_TYPE_SHA1             ,
+    KEY_M_TYPE_HDCP2            ,
+
+    KEY_M_TYPE_TOTAL_NUM
+};
+
+#define KEY_UNIFY_NAME_LEN	    48
+#define KEY_UNIFY_TYPE_LEN_MAX  ( 16 - 1 )
+
+struct key_item_t{
+    char name[KEY_UNIFY_NAME_LEN];
+    char keyType[KEY_UNIFY_TYPE_LEN_MAX + 1];//mac/sha1/hdcp2/normal
+    int id;
+    unsigned int dev; //key save in device //efuse,
+    unsigned int datFmt;  //data format
+    unsigned int permit;
+    int flag;
+    int reserv;//reserve and align to 64
+};
+
+struct key_info_t{
+    int key_num;
+    int efuse_version;
+    int key_flag;
+};
+
+
+#endif // #ifndef __KEY_MANAGE_H__
+
diff --git a/drivers/keymanage/key_manage_i.h b/drivers/keymanage/key_manage_i.h
new file mode 100644
index 0000000..9bac8e6
--- /dev/null
+++ b/drivers/keymanage/key_manage_i.h
@@ -0,0 +1,54 @@
+/*
+ * \file        key_manage_i.h
+ * \brief       common included files for key manager
+ *
+ * \version     1.0.0
+ * \date        15/06/30
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __KEY_MANAGE_I_H__
+#define __KEY_MANAGE_I_H__
+
+#include <config.h>
+#include <common.h>
+#include <linux/string.h>
+#include <errno.h>
+#include <malloc.h>
+#include "key_manage.h"
+#include <amlogic/keyunify.h>
+#include <amlogic/amlkey_if.h>
+
+#define KM_DBG(fmt ...)     //printf("[KM]Dbg:"fmt)
+#define KM_MSG(fmt ...)     printf("[KM]Msg:"fmt)
+#define KM_ERR(fmt ...)     printf("[KM]Error:f[%s]L%d:", __func__, __LINE__),printf(fmt)
+
+int _keyman_hex_ascii_to_buf(const char* input, char* buf, const unsigned bufSz);
+int _keyman_buf_to_hex_ascii(const uint8_t* pdata, const unsigned dataLen, char* fmtStr/*pr if NULL*/);
+
+int keymanage_dts_parse(const void* dt_addr);
+enum key_manager_df_e keymanage_dts_get_key_fmt(const char *keyname);
+enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname);
+const char* keymanage_dts_get_key_type(const char* keyname);
+char unifykey_get_efuse_version(void);
+
+int keymanage_efuse_init(const char *buf, int len);
+int keymange_efuse_exit(void);
+int keymanage_efuse_write(const char *keyname, const void* keydata, unsigned int datalen);
+int keymanage_efuse_exist(const char* keyname);
+ssize_t keymanage_efuse_size(const char* keyname);
+int keymanage_efuse_query_can_read(const char* keyname);
+int keymanage_efuse_read(const char *keyname, void* databuf, const unsigned bufsz);
+
+int keymanage_securekey_init(const char* buf, int len);
+int keymanage_securekey_exit(void);
+int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned int datalen);
+ssize_t keymanage_secukey_size(const char* keyname);
+int keymanage_secukey_exist(const char* keyname);
+int keymanage_secukey_can_read(const char* keyname);
+int keymanage_secukey_read(const char* keyname, void* databuf,  unsigned buflen);
+
+#endif//#ifndef __KEY_MANAGE_I_H__
+
diff --git a/drivers/keymanage/key_unify.c b/drivers/keymanage/key_unify.c
new file mode 100644
index 0000000..7ca8e70
--- /dev/null
+++ b/drivers/keymanage/key_unify.c
@@ -0,0 +1,577 @@
+/*
+ * Unify interfaces for read/write nandkey/emmckey/efuse key
+ */
+#include "key_manage_i.h"
+#include <amlogic/keyunify.h>
+#include <linux/ctype.h>
+
+#define KEY_NO_EXIST	0
+#define KEY_BURNED		1
+
+#define KEY_READ_PERMIT		10
+#define KEY_READ_PROHIBIT	11
+
+#define KEY_WRITE_MASK		(0x0f<<4)
+#define KEY_WRITE_PERMIT	(10<<4)
+#define KEY_WRITE_PROHIBIT	(11<<4)
+
+typedef struct _devKeyOps{
+    int     (*pInitFunc) (const char* buf, int len);
+    int     (*pUninitFunc)(void);
+    int     (*pWriteFunc)(const char *keyname, const void* keydata, unsigned int datalen);
+    ssize_t (*pGetSize)(const char* keyname);
+    int     (*pKeyExist)(const char* keyname);
+    int     (*pKeyCanRead)(const char* keyname);
+    int     (*pReadFunc)(const char* keyname, void* dataBuf,  unsigned buflen);
+
+    //Fields:
+    int     can_overwrite;//is OTP
+
+}KmDevKeyOps;
+
+static KmDevKeyOps _SecukeyOps = {
+        .pInitFunc           = keymanage_securekey_init        ,
+        .pUninitFunc         = keymanage_securekey_exit        ,
+        .pWriteFunc          = keymanage_secukey_write         ,
+        .pGetSize            = keymanage_secukey_size          ,
+        .pKeyExist           = keymanage_secukey_exist         ,
+        .pKeyCanRead         = keymanage_secukey_can_read      ,
+        .pReadFunc           = keymanage_secukey_read          ,
+
+        .can_overwrite       = 1                               ,
+};
+
+static KmDevKeyOps _efuseKeyOps = {
+        .pInitFunc           = keymanage_efuse_init            ,
+        .pUninitFunc         = keymange_efuse_exit             ,
+        .pWriteFunc          = keymanage_efuse_write           ,
+        .pGetSize            = keymanage_efuse_size            ,
+        .pKeyExist           = keymanage_efuse_exist           ,
+        .pKeyCanRead         = keymanage_efuse_query_can_read  ,
+        .pReadFunc           = keymanage_efuse_read            ,
+
+        .can_overwrite       = 0                               ,
+};
+
+#define _KM_DEV_INDEX_SECUREKEY         0
+#define _KM_DEV_INDEX_EFUSE             1
+
+static KmDevKeyOps* _km_devKeyOpsArr[] = {
+            [_KM_DEV_INDEX_SECUREKEY]      = &_SecukeyOps,
+            [_KM_DEV_INDEX_EFUSE]          = &_efuseKeyOps,
+};
+
+static const int _KM_DEVCNT = sizeof(_km_devKeyOpsArr) / sizeof(_km_devKeyOpsArr[0]);
+
+int _keyman_hex_ascii_to_buf(const char* input, char* buf, const unsigned bufSz)
+{
+    int ret = 0;
+    const char* tmpStr = input;
+    const unsigned inputLen = strlen(input);
+    int i = 0;
+
+    if (!inputLen) {
+        KM_ERR("err input len 0\n");
+        return __LINE__;
+    }
+    if (inputLen & 1) {
+        KM_ERR("inputLen %d not even\n", inputLen);
+        return __LINE__;
+    }
+    if (bufSz * 2 > inputLen) {
+        KM_ERR("bufSz %d not enough\n", bufSz);
+        return __LINE__;
+    }
+    for (tmpStr = input; *tmpStr; ++tmpStr)
+    {
+        char c = *tmpStr;
+        ret = isxdigit(c);
+        if (!ret) {
+            KM_ERR("input(%s) contain non xdigit, c=%c\n", input, c);
+            return __LINE__;
+        }
+    }
+
+    for (i = 0; i < inputLen; i += 2)
+    {
+        char tmpByte[8];
+        tmpByte[2] = '\0';
+        tmpByte[0] = input[i];
+        tmpByte[1] = input[i + 1];
+
+        const unsigned val = simple_strtoul(tmpByte, NULL, 16);
+        if (val > 0xff) {
+            KM_ERR("Exception: val 0x%x > 0xff\n", val);
+            return __LINE__;
+        }
+        buf[i>>1] = val;
+    }
+
+    return 0;
+}
+
+int _keyman_buf_to_hex_ascii(const uint8_t* pdata, const unsigned dataLen, char* fmtStr/*pr if NULL*/)
+{
+    if (NULL == fmtStr) //Only print
+    {
+        int i = 0;
+        KM_MSG("key len is %d, hex value in hexdump:", dataLen);
+        for (; i < dataLen; ++i, ++pdata)
+        {
+            if (!(i & 0xf)) printf("\n\t[0x%04x]:\t\t", i);
+            printf("%02x ", *pdata);
+        }
+        printf("\n");
+    }
+    else
+    {
+        int i = 0;
+
+        *fmtStr = '\0';
+        for (; i < dataLen; ++i, ++pdata)
+        {
+            sprintf(fmtStr, "%s%02x", fmtStr, *pdata);
+        }
+    }
+
+    return 0;
+}
+
+/*
+ * function name: key_unify_init
+ * buf : input
+ * len  : > 0
+ * return : >=0: ok, other: fail
+ * */
+int key_unify_init(const char* seedStr, const char* dtbLoadaddr)
+{
+    int err=EINVAL;
+    int i;
+    uint64_t seedNum = 0;
+
+    if (!dtbLoadaddr)
+    {
+        dtbLoadaddr = getenv("dtb_mem_addr");
+        if (!dtbLoadaddr) {
+            KM_ERR("env dtb_mem_addr not defined, pls set ir or asign dtbLoadaddr\n");
+            return __LINE__;
+        }
+    }
+    dtbLoadaddr = (char*)simple_strtoul(dtbLoadaddr, NULL, 0) ;
+
+    if (keymanage_dts_parse(dtbLoadaddr)) {
+        KM_DBG("Fail parse /unifykey at addr[0x%p]\n", dtbLoadaddr);
+        return err;
+    }
+
+    seedNum = simple_strtoull(seedStr, NULL, 0);
+    if (!seedNum) {
+        KM_ERR("Seed is 0 err\n");
+        return __LINE__;
+    }
+    for (i=0; i < _KM_DEVCNT; i++)
+    {
+        KmDevKeyOps* theDevOps = _km_devKeyOpsArr[i];
+        err = theDevOps->pInitFunc((char*)&seedNum, sizeof(uint64_t)/sizeof(char));
+        if (err) {
+            KM_ERR("Device[%d] init failed, err=%d\n", i, err);
+            return err;
+        }
+    }
+
+    return 0;
+}
+
+/* function name: key_unify_uninit
+ * functiion : uninit
+ * return : >=0 ok, <0 fail
+ * */
+int key_unify_uninit(void)
+{
+    int err=-EINVAL;
+    int i;
+
+    for (i=0; i < _KM_DEVCNT; i++)
+    {
+        KmDevKeyOps* theDevOps = _km_devKeyOpsArr[i];
+        err = theDevOps->pUninitFunc();
+        if (err) {
+            KM_ERR("device[%d] unini fail\n", i);
+            /*return err;*/
+        }
+    }
+
+    return 0;
+}
+
+static const KmDevKeyOps* _get_km_ops_by_name(const char* keyname)
+{
+    KmDevKeyOps* theDevOps  = NULL;
+
+    //step 1: get device ops by configured key-device
+    enum key_manager_dev_e theDevice = keymanage_dts_get_key_device(keyname);
+
+    switch (theDevice)
+    {
+        case KEY_M_EFUSE_NORMAL:
+            {
+                theDevOps = _km_devKeyOpsArr[_KM_DEV_INDEX_EFUSE];
+            }
+            break;
+
+        case KEY_M_NORAML_KEY:
+        case KEY_M_SECURE_KEY:
+            {
+                theDevOps = _km_devKeyOpsArr[_KM_DEV_INDEX_SECUREKEY];
+            }
+            break;
+
+        case KEY_M_UNKNOW_DEV:
+        default:
+            KM_ERR("key %s not know device %d\n", keyname, theDevice);
+            return NULL;
+    }
+
+    return theDevOps;
+}
+
+int key_unify_query_key_has_configure(const char* keyname)
+{
+    return _get_km_ops_by_name(keyname) ? 1 : 0;
+}
+
+/* funtion name: key_unify_write
+ * keyname : key name is ascii string
+ * keydata : key data buf
+ * datalen : key buf len
+ * return  0: ok, -0x1fe: no space, other fail
+ *
+ * Step 1: Get burn target from dtb
+ * Step 2: check whether can burned, OTP can't burned twice
+ *          2.1)check is programmed yet, burn directly if not programmed yet.
+ *          2.2)if programmed yet, check if OTP
+ * Step 3: burn the key to the target
+ * */
+int key_unify_write(const char *keyname, const void* keydata, const unsigned datalen)
+{
+    int err=0;
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    if (!theDevOps->can_overwrite) {
+        KM_DBG("can't overwrite\n");
+        int ret = theDevOps->pKeyExist(keyname);
+        if (ret) {
+            KM_ERR("OTP key[%s] already existed, can't program twice!\n", keyname);
+            return __LINE__;
+        }
+    }
+
+    err = theDevOps->pWriteFunc(keyname, keydata, datalen);
+
+    return err;
+}
+
+/*
+ *function name: key_unify_read
+ * keyname : key name is ascii string
+ * keydata : key data buf
+ * datalen : key buf len
+ * reallen : key real len
+ * return : <0 fail, >=0 ok
+ * */
+int key_unify_read(const char *keyname, void* keydata, const unsigned bufLen)
+{
+    int err=0;
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    int ret = theDevOps->pKeyExist(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] not programed yet\n", keyname);
+        return __LINE__;
+    }
+
+    ret = theDevOps->pKeyCanRead(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] can't read as it's secure\n", keyname);
+        return __LINE__;
+    }
+
+    const ssize_t keySz = theDevOps->pGetSize(keyname);
+    if (keySz > bufLen && bufLen) {
+        KM_ERR("keySz[%lu] > bufLen[%d]\n", keySz, bufLen);
+        return __LINE__;
+    }
+
+    err = theDevOps->pReadFunc(keyname, keydata, keySz);
+
+    return err;
+}
+
+int key_unify_query_size(const char* keyname, ssize_t* keysize)
+{
+    int ret = 0;
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] not cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    ret = theDevOps->pKeyCanRead(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] can't read as it's secure\n", keyname);
+        return __LINE__;
+    }
+
+    *keysize = theDevOps->pGetSize(keyname);
+
+    return 0;
+}
+
+int key_unify_query_exist(const char* keyname, int* exist)
+{
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name (keyname) ;
+    if (!theDevOps) {
+        KM_ERR("key[%s] not cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    *exist = theDevOps->pKeyExist(keyname);
+
+    return 0;
+}
+
+int key_unify_query_secure(const char* keyname, int* isSecure)
+{
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name (keyname) ;
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    int ret = theDevOps->pKeyExist (keyname) ;
+    if (!ret) {
+        KM_ERR("key[%s] not programed yet\n", keyname);
+        return __LINE__;
+    }
+
+    *isSecure = !theDevOps->pKeyCanRead (keyname) ;
+    if (!ret) {
+        KM_ERR ("key[%s] can't read as it's secure\n", keyname) ;
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+int key_unify_query_canOverWrite(const char* keyname, int* canOverWrite)
+{
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    *canOverWrite = theDevOps->can_overwrite;
+    return 0;
+}
+
+int do_keyunify (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    int err;
+    char *cmd;
+    int ret = 0;
+
+    if (argc < 2) return CMD_RET_USAGE;
+
+    cmd = argv[1];
+    //keyman init seedNum <dtbLoadAddr>
+    if (!strcmp(cmd,"init"))
+    {
+        if (argc < 3) {
+            return CMD_RET_USAGE;
+        }
+        const char* seedNum     = argv[2];
+        const char* dtbLoadaddr = argc > 3 ? argv[3] : NULL;
+        err = key_unify_init(seedNum, dtbLoadaddr);
+        return err ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+    }
+
+    //keyunify write keyname addr <size>
+    //keyunify write keyname hexascii
+    if (!strcmp(cmd,"write"))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+
+        const char* keyname = argv[2];
+        const char* keyData = (char*)simple_strtoul(argv[3], NULL, 16);
+        unsigned len  = argc > 4 ? simple_strtoul(argv[4], NULL, 0) : 0;
+        char*  dataBuf = NULL;
+
+        if (argc == 4)
+        {
+            const char* hexascii = argv[3];
+
+            len = strlen(hexascii) / 2;
+            dataBuf = (char*)malloc(len);
+            if (!dataBuf) {
+                KM_ERR("Fail in malloc len %d\n", len);
+                return CMD_RET_FAILURE;
+            }
+
+            err = _keyman_hex_ascii_to_buf(hexascii, dataBuf, len);
+            if (err) {
+                KM_ERR("Fail in decrypt hexascii to buf, err=%d\n", err);
+                free(dataBuf);
+                return CMD_RET_FAILURE;
+            }
+            keyData = dataBuf;
+        }
+
+        KM_DBG("write key[%s], addr=%p, len=%d\n", keyname, keyData, len);
+        err = key_unify_write(keyname, keyData, len);
+        if (err ) {
+            KM_ERR("%s key write fail, err=%d\n", keyname, err);
+            return CMD_RET_FAILURE;
+        }
+        if (dataBuf)free(dataBuf) ;
+
+        return CMD_RET_SUCCESS;
+    }
+
+    //keyman query size/secure/exist keyname
+    if (!strcmp(cmd,"query"))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+
+        const char* subCmd  = argv[2];
+        const char* keyname = argv[3];
+
+        ret = CMD_RET_FAILURE;
+        if (!strcmp("size", subCmd))
+        {
+            ssize_t keysize = 0;
+            err = key_unify_query_size(keyname, &keysize);
+            if (!err) {
+                ret = CMD_RET_SUCCESS;
+                KM_MSG("key[%s] is %u bytes\n", keyname, (unsigned)keysize);
+            }
+        }
+        else if(!strcmp("secure", subCmd))
+        {
+            int isSecure = 0;
+
+            err = key_unify_query_secure(keyname, &isSecure);
+            if (!err) {
+                ret = CMD_RET_SUCCESS;
+                KM_MSG("key[%s] is %s Secure\n", keyname, isSecure ? "DO" : "NON");
+            }
+        }
+        else if(!strcmp("exist", subCmd))
+        {
+            int exist = 0;
+            err = key_unify_query_exist(keyname, &exist);
+            if (!err) {
+                ret = CMD_RET_SUCCESS;
+                KM_MSG("key[%s] is %s existed\n", keyname, exist ? "DO" : "NON");
+            }
+        }
+        else{
+            return CMD_RET_USAGE;
+        }
+
+        return ret;
+    }
+
+    //keyman read keyname memAddr
+    if (!strcmp(cmd,"read"))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+
+        const char* keyname = argv[2];
+        void* keydata = (void*)simple_strtoul(argv[3], NULL, 16);
+
+        ssize_t keysize = 0;
+        err = key_unify_query_size(keyname, &keysize);
+        if (err) {
+            KM_ERR("Fail in get keysz, err=%d\n", err);
+            return __LINE__;
+        }
+
+        err = key_unify_read(keyname, keydata, (unsigned)keysize);
+        if (err) {
+            KM_ERR("%s key read fail\n", keyname);
+            return CMD_RET_FAILURE;
+        }
+        _keyman_buf_to_hex_ascii(keydata, (unsigned)keysize, NULL);
+
+        return err;
+    }
+
+    if (!strcmp(cmd,"uninit"))
+    {
+        return key_unify_uninit();
+    }
+
+    return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+        keyunify, CONFIG_SYS_MAXARGS, 1, do_keyunify,
+        "key unify sub-system",
+        "init seedNum [dtbAddr] --init the drivers\n"
+        "keyunify uninit - init key in device\n"
+        "keyunify write keyname data <len>  ---- wirte key data. len non-exist if data is ascii str\n"
+        "keyunify read keyname data-addr <len> \n"
+);
+
+
+#if !defined(CONFIG_AML_SECURITY_KEY)
+int keymanage_securekey_init(const char* buf, int len) { return -EINVAL; }
+int keymanage_securekey_exit(void){ return -EINVAL; }
+int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned int datalen){ return -EINVAL; }
+ssize_t keymanage_secukey_size(const char* keyname){ return 0; }
+int keymanage_secukey_exist(const char* keyname){ return 0; }
+int keymanage_secukey_can_read(const char* keyname){ return 0; }
+int keymanage_secukey_read(const char* keyname, void* dataBuf,  unsigned buflen){ return -EINVAL; }
+#endif// #if CONFIG_AML_SECURITY_KEY
+
+#if !defined(CONFIG_EFUSE)
+int keymanage_efuse_init(const char *buf, int len) { return -EINVAL; }
+int keymange_efuse_exit(void) {return -EINVAL;}
+int keymanage_efuse_write(const char *keyname, const void* keydata, unsigned int datalen) { return -EINVAL; }
+int keymanage_efuse_exist(const char* keyname) { return -EINVAL; }
+ssize_t keymanage_efuse_size(const char* keyname) { return 0; }
+int keymanage_efuse_query_can_read(const char* keyname){ return 0; }
+int keymanage_efuse_read(const char *keyname, void* dataBuf, const unsigned bufsz) { return -EINVAL; }
+int keymanage_efuse_query_is_burned(const char* keyname) { return -EINVAL; }
+int keymanage_efuse_query_can_read(const char* keyname) { return -EINVAL; }
+#endif// #ifdef CONFIG_EFUSE
+
+#if !defined(CONFIG_OF_LIBFDT)
+int keymanage_dts_parse(const void* dt_addr){ return -EINVAL; }
+enum key_manager_df_e keymanage_dts_get_key_fmt(const char *keyname){ return -EINVAL; }
+enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname){ return -EINVAL; }
+char unifykey_get_efuse_version(void) { return -1; }
+#endif//#ifdef CONFIG_OF_LIBFDT
+
+
diff --git a/drivers/keymanage/km_dts.c b/drivers/keymanage/km_dts.c
new file mode 100644
index 0000000..5b703b1
--- /dev/null
+++ b/drivers/keymanage/km_dts.c
@@ -0,0 +1,300 @@
+#include "key_manage_i.h"
+#include <fdt.h>
+#include <libfdt.h>
+
+#define UNIFYKEY_DATAFORMAT_HEXDATA	    "hexdata"
+#define UNIFYKEY_DATAFORMAT_HEXASCII	"hexascii"
+#define UNIFYKEY_DATAFORMAT_ALLASCII	"allascii"
+
+#define UNIFYKEY_DEVICE_EFUSEKEY	"efuse"
+#define UNIFYKEY_DEVICE_NORMAL		"normal"
+#define UNIFYKEY_DEVICE_SECURESKEY	"secure"
+
+#define UNIFYKEY_PERMIT_READ		"read"
+#define UNIFYKEY_PERMIT_WRITE		"write"
+#define UNIFYKEY_PERMIT_DEL			"del"
+
+static struct key_info_t unify_key_info={.key_num =0, .key_flag = 0, .efuse_version = -1};
+static struct key_item_t *unifykey_item=NULL;
+
+static int unifykey_item_verify_check(struct key_item_t *key_item)
+{
+	if (!key_item) {
+		KM_ERR("unify key item is invalid\n");
+		return -1;
+	}
+
+	if (!key_item->name || (key_item->dev == KEY_M_UNKNOW_DEV) ||(key_item->datFmt == KEY_M_MAX_DF)) {
+		KM_ERR("unify key item is invalid\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static struct key_item_t *unifykey_find_item_by_name(const char *name)
+{
+	struct key_item_t *pre_item;
+    int i = 0;
+    const unsigned cnt = unify_key_info.key_num;
+
+    for (pre_item = unifykey_item; i < cnt; ++pre_item, ++i)
+    {
+        if (!strcmp(pre_item->name,name)) {
+            return pre_item;
+        }
+    }
+	return NULL;
+}
+
+enum key_manager_df_e keymanage_dts_get_key_fmt(const char *keyname)
+{
+	struct key_item_t *key_manage;
+    enum key_manager_df_e keyValFmt = KEY_M_MAX_DF;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return KEY_M_MAX_DF;
+    }
+
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR ("%s key name is not exist\n", keyname) ;
+		return keyValFmt;
+	}
+	if (unifykey_item_verify_check(key_manage)) {
+		KM_ERR ("%s key name is invalid\n", keyname) ;
+		return keyValFmt;
+	}
+
+    keyValFmt = key_manage->datFmt;
+	return keyValFmt;
+}
+
+//which device does the key stored in
+enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname)
+{
+	struct key_item_t *key_manage;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return KEY_M_MAX_DEV;
+    }
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR("%s key name is not exist\n",keyname);
+		return KEY_M_MAX_DEV;
+	}
+	if (unifykey_item_verify_check(key_manage)) {
+		KM_ERR("%s key name is invalid\n",keyname);
+		return KEY_M_MAX_DEV;
+	}
+
+	return key_manage->dev;
+}
+
+const char* keymanage_dts_get_key_type(const char* keyname)
+{
+	struct key_item_t *key_manage;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return NULL;
+    }
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR("%s key name is not exist\n",keyname);
+		return NULL;
+	}
+
+	return key_manage->keyType;
+}
+
+char unifykey_get_efuse_version(void)
+{
+	char ver=0;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return 0;
+    }
+
+	if (unify_key_info.efuse_version != -1) {
+		ver = (char)unify_key_info.efuse_version;
+	}
+	return ver;
+}
+
+static int unifykey_item_dt_parse(const void* dt_addr,int nodeoffset,int id,char *item_path)
+{
+	struct key_item_t *temp_item=NULL;
+	char *propdata;
+	struct fdt_property *prop;
+	int count;
+
+	temp_item = unifykey_item + id;
+
+	propdata = (char*)fdt_getprop(dt_addr, nodeoffset, "key-name",NULL);
+	if (!propdata) {
+		printf("%s get key-name fail,%s:%d\n",item_path,__func__,__LINE__);
+        return __LINE__;
+	}
+
+	count = strlen(propdata);
+	if (count >= KEY_UNIFY_NAME_LEN) {
+        KM_ERR("key-name strlen (%d) > max(%d) at key_%d\n", count, KEY_UNIFY_NAME_LEN - 1, id);
+        return __LINE__;
+	}
+    memcpy(temp_item->name, propdata, count);
+    temp_item->name[count] = 0;
+
+	propdata = (char*)fdt_getprop(dt_addr, nodeoffset, "key-device",NULL);
+	if (!propdata) {
+		KM_ERR("%s get key-device fail at key_%d\n",item_path, id);
+        return __LINE__;
+	}
+
+    if (strcmp(propdata,UNIFYKEY_DEVICE_EFUSEKEY) == 0) {
+        temp_item->dev = KEY_M_EFUSE_NORMAL;
+    }
+    else if(strcmp(propdata,UNIFYKEY_DEVICE_SECURESKEY) == 0){
+        temp_item->dev = KEY_M_SECURE_KEY;
+    }
+    else if(strcmp(propdata,UNIFYKEY_DEVICE_NORMAL) == 0){
+        temp_item->dev = KEY_M_NORAML_KEY;
+    }
+    else{
+        KM_ERR("key-device %s is unknown at key_%d\n", propdata, id);
+        return __LINE__;
+    }
+
+	propdata = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "key-type",NULL);
+	if (!propdata) //prop 'key-type' not configured, default to raw except special names
+    {
+        strcpy(temp_item->keyType, "raw");
+	}
+    else
+    {
+        const int keyTypeLen = strlen(propdata);
+        if (keyTypeLen > KEY_UNIFY_TYPE_LEN_MAX) {
+            KM_ERR("key[%s]cfg key-type[%s] sz %d > max %d\n", temp_item->name, propdata, keyTypeLen, KEY_UNIFY_TYPE_LEN_MAX);
+            return __LINE__;
+        }
+        strcpy(temp_item->keyType, propdata);
+    }
+
+#if 0
+	propdata = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "key-dataformat",NULL);
+	if (!propdata) {
+		KM_ERR("%s get key-dataformat fail at key_%d\n",item_path, id);
+        return __LINE__;
+	}
+#endif
+
+	prop = (struct fdt_property*)fdt_get_property((const void *)dt_addr,nodeoffset,"key-permit",NULL) ;
+	if (!prop) {
+		KM_ERR("%s get key-permit fail at  key_%d\n",item_path, id);
+        return __LINE__;
+	}
+
+    temp_item->permit = 0;
+    const int propLen = prop->len > 512 ? strnlen(prop->data, 512) : prop->len;
+    if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_READ)) {
+        temp_item->permit |= KEY_M_PERMIT_READ;
+    }
+    if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_WRITE)) {
+        temp_item->permit |= KEY_M_PERMIT_WRITE;
+    }
+    if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_DEL)) {
+        temp_item->permit |= KEY_M_PERMIT_DEL;
+    }
+
+	temp_item->id = id;
+
+    KM_DBG("key[%02d] keyname %s, %d\n", id, temp_item->name, temp_item->dev);
+
+	return 0;
+}
+
+static int unifykey_item_create(const void* dt_addr,int num)
+{
+    int ret = 0;
+    int i,nodeoffset;
+    char item_path[100];
+
+    for (i=0;i<num;i++)
+    {
+        sprintf(item_path, "/unifykey/key_%d", i);
+
+        nodeoffset = fdt_path_offset (dt_addr, item_path) ;
+        if (nodeoffset < 0) {
+            KM_ERR(" dts: not find  node %s.\n",fdt_strerror(nodeoffset));
+            return __LINE__;
+        }
+
+        ret = unifykey_item_dt_parse(dt_addr,nodeoffset, i, item_path);
+        if (ret) {
+            KM_ERR("Fail at parse %s\n", item_path);
+            return __LINE__;
+        }
+    }
+
+    //	printf("unifykey-num fact is %x\n",count);
+    return 0;
+}
+
+//parse and cache the dts cfg
+//TODO: check keys names has no duplicated
+int keymanage_dts_parse(const void* dt_addr)
+{
+    int ret = 0;
+	int nodeoffset;
+	char *punifykey_num;
+
+	if (fdt_check_header(dt_addr)!= 0) {
+        KM_ERR("not a fdt at 0x%p\n", dt_addr);
+        return __LINE__;
+    }
+
+	nodeoffset = fdt_path_offset(dt_addr, "/unifykey");
+	if (nodeoffset < 0) {
+		KM_ERR("dts: err(%s) in find /unifykey.\n",fdt_strerror(nodeoffset));
+		return __LINE__;
+	}
+
+	unify_key_info.efuse_version = -1;
+	punifykey_num = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "efuse-version",NULL);
+	if (punifykey_num) {
+		unify_key_info.efuse_version = be32_to_cpup((unsigned int*)punifykey_num);
+		KM_MSG("efuse-version config is %x\n",unify_key_info.efuse_version);
+	}
+
+	unify_key_info.key_num = 0;
+	punifykey_num = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "unifykey-num",NULL);
+	if (punifykey_num) {
+//		printf("unifykey-num config is %x\n",be32_to_cpup((unsigned int*)punifykey_num));
+		unify_key_info.key_num = be32_to_cpup((unsigned int*)punifykey_num);
+	}
+
+	if (unify_key_info.key_num <= 0) {
+		KM_ERR("unifykey-num is not configured\n");
+        return __LINE__;
+	}
+    if (unify_key_info.key_num > 32) {
+        KM_ERR("Cfg key_num is %d > 32,pls check!\n", unify_key_info.key_num);
+        return __LINE__;
+    }
+
+    if (unifykey_item) {
+        free(unifykey_item);
+    }
+    const unsigned keyInfBufLen = unify_key_info.key_num * sizeof(struct key_item_t);
+    unifykey_item = (struct key_item_t*)malloc(keyInfBufLen);
+    memset(unifykey_item, 0 , keyInfBufLen);
+
+    ret = unifykey_item_create(dt_addr,unify_key_info.key_num);
+    unify_key_info.key_flag = ret ? 0 : 1;
+
+	return ret;
+}
+
diff --git a/drivers/keymanage/km_efuse_key.c b/drivers/keymanage/km_efuse_key.c
new file mode 100644
index 0000000..ded4a51
--- /dev/null
+++ b/drivers/keymanage/km_efuse_key.c
@@ -0,0 +1,156 @@
+/*
+ * \file        km_efuse_key.c
+ * \brief       efuse key ops for key manage
+ *
+ * \version     1.0.0
+ * \date        15/06/30
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "key_manage_i.h"
+#include <asm/arch/secure_apb.h>
+#include <asm/io.h>
+
+#define SECURE_BOOT_KEY_NAME    "secure_boot_set"
+
+extern int efuse_usr_api_init_dtb(const char*  dt_addr);
+extern int efuse_usr_api_get_cfg_key_size(const char* keyname, unsigned* pSz);
+extern int efuse_usr_api_write_key(const char* keyname, const void* keydata, const unsigned dataSz);
+extern int efuse_usr_api_read_key(const char* keyname, void* databuf, const unsigned bufSz);
+
+int keymanage_efuse_init(const char *buf, int len)
+{
+    char ver;
+    int ret = 0;
+
+    const char* dtbLoadAddr = getenv("dtb_mem_addr");
+    if (!dtbLoadAddr) {
+        setenv("dtb_mem_addr", simple_itoa(CONFIG_SYS_SDRAM_BASE + (16U<<20)));
+    }
+    dtbLoadAddr = (char*)simple_strtoul(dtbLoadAddr, NULL, 0);
+
+    ret = efuse_usr_api_init_dtb(dtbLoadAddr);
+    if (ret) {
+        KM_ERR("efuse init failed\n");
+        return __LINE__;
+    }
+
+    ver = unifykey_get_efuse_version();
+    if (ver == 0) {
+        KM_DBG("efuse version not cfg\n");
+        return 0;
+    }
+
+    //TODO: program the efuse version
+
+    return ret;
+}
+
+int keymange_efuse_exit(void)
+{
+    return 0;
+}
+
+//must be hexdata if stored in efuse
+int keymanage_efuse_write(const char *keyname, const void* keydata, unsigned int datalen)
+{
+    int ret = 0;
+
+    if (!strcmp(SECURE_BOOT_KEY_NAME, keyname))
+    {
+            char _cmdbuf[96];
+            sprintf(_cmdbuf, "efuse %s %p", keyname, keydata);
+            ret = run_command(_cmdbuf, 0);;
+    }
+    else
+    {
+            ret = efuse_usr_api_write_key(keyname,  keydata, datalen);
+    }
+
+    return ret;
+}
+
+ssize_t keymanage_efuse_size(const char* keyname)
+{
+    int ret = 0;
+    unsigned cfgSz = 0;
+
+    ret = efuse_usr_api_get_cfg_key_size(keyname, &cfgSz);
+    if (ret || !cfgSz) {
+        KM_ERR("Fail at get cfg size for efuse key[%s]\n", keyname);
+        return 0;
+    }
+
+    return cfgSz;
+}
+
+int keymanage_efuse_exist(const char* keyname)
+{
+
+        if (!strcmp(SECURE_BOOT_KEY_NAME, keyname))
+        {
+                const unsigned long cfg10 = readl(AO_SEC_SD_CFG10);
+                KM_MSG("cfg10=0x%lX\n", cfg10);
+                return ( cfg10 & (0x1<< 4) );
+        }
+        else
+        {
+                int ret = 0;
+                const ssize_t cfgSz = keymanage_efuse_size(keyname);
+                char* databuf = NULL;
+                int isEmpty = 1;
+                int i = 0;
+
+                databuf = (char*)malloc(cfgSz);
+                if (!databuf) {
+                        KM_ERR("Fail to alloc bufsz 0x%x for key %s\n", (unsigned)cfgSz, keyname);
+                        return 0;
+                }
+                ret = keymanage_efuse_read(keyname, databuf, cfgSz);
+                if (ret) {
+                        KM_ERR("Fail at read key[%s]\n", keyname);
+                        goto _exit;
+                }
+                for (i = 0; i < cfgSz && isEmpty; ++i) {
+                        isEmpty = !databuf[i];
+                }
+
+_exit:
+                free(databuf);
+                return !isEmpty;
+        }
+
+        return __LINE__;
+}
+
+int keymanage_efuse_query_can_read(const char* keyname)
+{
+        if (!strcmp(SECURE_BOOT_KEY_NAME, keyname))
+        {
+                return 0;
+        }
+        else
+        {
+                return 1;//user space always can be read
+        }
+}
+
+//data format is hexdata
+int keymanage_efuse_read(const char *keyname, void* databuf, const unsigned bufSz)
+{
+    int ret = 0;
+    unsigned cfgSz = 0;
+
+    cfgSz = keymanage_efuse_size(keyname);
+    if (cfgSz > bufSz) {
+        KM_ERR("buf sz 0x%x < dts cfg sz 0x%x\n", bufSz, cfgSz);
+        return __LINE__;
+    }
+
+    ret = efuse_usr_api_read_key(keyname, databuf, cfgSz);
+
+    return ret;
+}
+
diff --git a/drivers/keymanage/km_secure_key.c b/drivers/keymanage/km_secure_key.c
new file mode 100644
index 0000000..66914fe
--- /dev/null
+++ b/drivers/keymanage/km_secure_key.c
@@ -0,0 +1,114 @@
+/*
+ * \file        km_secure_key.c
+ * \brief       secure storage key ops for key manage
+ *
+ * \version     1.0.0
+ * \date        15/06/30
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "key_manage_i.h"
+#include <amlogic/amlkey_if.h>
+#include <u-boot/sha256.h>
+
+int keymanage_securekey_init(const char* buf, int len)
+{
+	return amlkey_init((uint8_t*)buf, len);	//confirm
+}
+
+int keymanage_securekey_exit(void)
+{
+    return 0;
+}
+
+int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned int datalen)
+{
+    int ret = 0;
+    uint8_t origSum[SHA256_SUM_LEN];
+    const int isSecure =  ( KEY_M_SECURE_KEY == keymanage_dts_get_key_device(keyname) ) ;
+    ssize_t writenLen = 0;
+
+    if (isSecure)
+    {
+        sha256_context ctx;
+        sha256_starts(&ctx);
+        sha256_update(&ctx, keydata, datalen);
+        sha256_finish(&ctx, origSum);
+    }
+
+    KM_DBG("%s, keyname=%s, keydata=%p, datalen=%d, isSecure=%d\n", __func__, keyname, keydata, datalen, isSecure);
+    writenLen = amlkey_write((uint8_t*)keyname, (uint8_t*)keydata, datalen, isSecure);
+    if (writenLen != datalen) {
+        KM_ERR("Want to write %u bytes, but only %zd Bytes\n", datalen, writenLen);
+        return __LINE__;
+    }
+
+    if (isSecure)
+    {
+        uint8_t genSum[SHA256_SUM_LEN];
+
+        ret = amlkey_hash_4_secure((uint8_t*)keyname, genSum);
+        if (ret) {
+            KM_ERR("Failed when gen hash for secure key[%s], ret=%d\n", keyname, ret);
+            return __LINE__;
+        }
+
+        ret = memcmp(origSum, genSum, SHA256_SUM_LEN);
+        if (ret)
+        {
+            int index = 0;
+            char origSum_str[SHA256_SUM_LEN * 2 + 2];
+            char genSum_str[SHA256_SUM_LEN * 2 + 2];
+
+            origSum_str[0] = genSum_str[0] = '\0';
+            for (index = 0; index < SHA256_SUM_LEN; ++index) {
+
+                sprintf(origSum_str, "%s%02x", origSum_str, origSum[index]);
+                sprintf(genSum_str, "%s%02x", genSum_str, genSum[index]);
+            }
+
+            KM_ERR("Failed in check hash, origSum[%s] != genSum[%s]\n", origSum_str, genSum_str);
+            return __LINE__;
+        }
+        KM_MSG("OK in check sha1256 in burn key[%s]\n", keyname);
+    }
+
+    return ret;
+}
+
+ssize_t keymanage_secukey_size(const char* keyname)
+{
+	return amlkey_size((uint8_t*)keyname);	//actully size
+}
+
+int keymanage_secukey_exist(const char* keyname)
+{
+	return amlkey_isexsit((uint8_t*)keyname);	//exsit 1, non 0
+}
+
+int keymanage_secukey_can_read(const char* keyname)
+{
+	return !amlkey_issecure((uint8_t*)keyname);	//secure 1, non 0
+}
+
+int keymanage_secukey_read(const char* keyname, void* databuf,  unsigned buflen)
+{
+    int ret = 0;
+
+    ret = keymanage_secukey_can_read(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] can't read, is configured secured?\n", keyname);
+        return __LINE__;
+    }
+
+	const ssize_t readLen = amlkey_read((uint8_t*)keyname, (uint8_t*)databuf, buflen);
+    if (readLen != buflen) {
+        KM_ERR("key[%s], want read %u Bytes, but %zd bytes\n", keyname, buflen, readLen);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 461d7d8..4487e99 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -34,6 +34,11 @@ obj-$(CONFIG_SOCFPGA_DWMMC) += socfpga_dw_mmc.o
 obj-$(CONFIG_SPEAR_SDHCI) += spear_sdhci.o
 obj-$(CONFIG_TEGRA_MMC) += tegra_mmc.o
 obj-$(CONFIG_ZYNQ_SDHCI) += zynq_sdhci.o
+obj-$(CONFIG_AML_SD_EMMC) += aml_sd_emmc.o
+
+ifndef CONFIG_MACH_ODROIDC2
+obj-y += emmc_partitions.o
+endif
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_SPL_MMC_BOOT) += fsl_esdhc_spl.o
diff --git a/drivers/mmc/aml_sd_emmc.c b/drivers/mmc/aml_sd_emmc.c
new file mode 100644
index 0000000..86ce009
--- /dev/null
+++ b/drivers/mmc/aml_sd_emmc.c
@@ -0,0 +1,480 @@
+
+/*
+ * drivers/mmc/aml_sd_emmc.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+//#include <asm/dma-mapping.h>
+#include <asm/io.h>
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+#include <asm/arch/cpu_sdio.h>
+#ifdef CONFIG_STORE_COMPATIBLE
+#include <storage.h>
+#endif
+//#define SD_DEBUG_ENABLE
+
+#ifdef SD_DEBUG_ENABLE
+	#define sd_debug(a...) printf(a);
+#else
+	#define sd_debug(a...)
+#endif
+
+
+
+/*
+ * **********************************************************************************************
+ * board relative
+ * **********************************************************************************************
+ */
+
+unsigned long sd_emmc_base_addr[3] = {SD_EMMC_BASE_A,
+										SD_EMMC_BASE_B,
+										SD_EMMC_BASE_C};
+
+static struct aml_card_sd_info aml_sd_emmc_ports[]={
+    { .sd_emmc_port=SDIO_PORT_A,.name="SDIO Port A"},
+    { .sd_emmc_port=SDIO_PORT_B,.name="SDIO Port B"},
+    { .sd_emmc_port=SDIO_PORT_C,.name="SDIO Port C"},
+};
+
+struct aml_card_sd_info * cpu_sd_emmc_get(unsigned port)
+{
+    if (port<SDIO_PORT_C+1)
+        return &aml_sd_emmc_ports[port];
+    return NULL;
+}
+
+
+void aml_sd_cfg_swth(struct mmc *mmc)
+{
+
+	unsigned sd_emmc_clkc =	0,clk,clk_src,clk_div;
+	unsigned vconf;
+	unsigned bus_width=(mmc->bus_width == 1)?0:mmc->bus_width/4;
+	struct aml_card_sd_info *aml_priv = mmc->priv;
+	struct sd_emmc_global_regs *sd_emmc_reg = aml_priv->sd_emmc_reg;
+	struct sd_emmc_config* sd_emmc_cfg = (struct sd_emmc_config*)&vconf;
+
+	sd_debug("mmc->clock=%d; clk_div=%d\n",mmc->clock ,clk_div);
+
+	if (mmc->clock > 12000000) {
+		clk = SD_EMMC_CLKSRC_DIV2;
+		clk_src = 1;
+	}else{
+		clk = SD_EMMC_CLKSRC_24M;
+		clk_src = 0;
+	}
+	clk_div= clk / mmc->clock;
+
+	if (mmc->clock<mmc->cfg->f_min)
+	    mmc->clock=mmc->cfg->f_min;
+	if (mmc->clock>mmc->cfg->f_max)
+	    mmc->clock=mmc->cfg->f_max;
+
+	sd_emmc_clkc =((0 << Cfg_irq_sdio_sleep_ds) |
+						(0 << Cfg_irq_sdio_sleep) |
+						(1 << Cfg_always_on) |
+						(0 << Cfg_rx_delay) |
+						(0 << Cfg_tx_delay) |
+						(0 << Cfg_sram_pd) |
+						(0 << Cfg_rx_phase) |
+						(0 << Cfg_tx_phase) |
+						(2 << Cfg_co_phase) |
+						(clk_src << Cfg_src) |
+						(clk_div << Cfg_div));
+
+	sd_emmc_reg->gclock = sd_emmc_clkc;
+	vconf = sd_emmc_reg->gcfg;
+
+	sd_emmc_cfg->bus_width = bus_width;     //1bit mode
+    sd_emmc_cfg->bl_len = 9;      //512byte block length
+    sd_emmc_cfg->resp_timeout = 7;      //64 CLK cycle, here 2^8 = 256 clk cycles
+    sd_emmc_cfg->rc_cc = 4;      //1024 CLK cycle, Max. 100mS.
+    /* sd_emmc_cfg->ddr = mmc->ddr_mode; */
+    sd_emmc_reg->gcfg = vconf;
+
+	sd_debug("bus_width=%d; tclk_div=%d; tclk=%d;sd_clk=%d\n",
+	    bus_width,clk_div,clk,mmc->clock);
+
+	sd_debug("port=%d act_clk=%d\n",aml_priv->sd_emmc_port,clk/(clk_div+1));
+	return;
+}
+
+
+
+static int sd_inand_check_insert(struct	mmc	*mmc)
+{
+	int level;
+	struct aml_card_sd_info *sd_inand_info = mmc->priv;
+
+	level = sd_inand_info->sd_emmc_detect(sd_inand_info->sd_emmc_port);
+
+	if (level) {
+
+		if (sd_inand_info->init_retry) {
+			sd_inand_info->sd_emmc_pwr_off(sd_inand_info->sd_emmc_port);
+			sd_inand_info->init_retry = 0;
+		}
+		if (sd_inand_info->inited_flag) {
+			sd_inand_info->sd_emmc_pwr_off(sd_inand_info->sd_emmc_port);
+			sd_inand_info->removed_flag = 1;
+			sd_inand_info->inited_flag = 0;
+		}
+		return 0;				//No card is inserted
+	} else {
+		return 1;				//A	card is	inserted
+	}
+}
+
+//Clear response data buffer
+static void sd_inand_clear_response(unsigned * res_buf)
+{
+	int i;
+	if (res_buf == NULL)
+		return;
+
+	for (i = 0; i < MAX_RESPONSE_BYTES; i++)
+		res_buf[i]=0;
+}
+
+/*
+static int sd_inand_check_response(struct mmc_cmd *cmd)
+{
+	int ret = SD_NO_ERROR;
+	SD_Response_R1_t *r1 = (SD_Response_R1_t *)cmd->response;
+	switch (cmd->resp_type) {
+	case MMC_RSP_R1:
+	case MMC_RSP_R1b:
+		if (r1->card_status.OUT_OF_RANGE)
+			return SD_ERROR_OUT_OF_RANGE;
+		else if (r1->card_status.ADDRESS_ERROR)
+			return SD_ERROR_ADDRESS;
+		else if (r1->card_status.BLOCK_LEN_ERROR)
+			return SD_ERROR_BLOCK_LEN;
+		else if (r1->card_status.ERASE_SEQ_ERROR)
+			return SD_ERROR_ERASE_SEQ;
+		else if (r1->card_status.ERASE_PARAM)
+			return SD_ERROR_ERASE_PARAM;
+		else if (r1->card_status.WP_VIOLATION)
+			return SD_ERROR_WP_VIOLATION;
+		else if (r1->card_status.CARD_IS_LOCKED)
+			return SD_ERROR_CARD_IS_LOCKED;
+		else if (r1->card_status.LOCK_UNLOCK_FAILED)
+			return SD_ERROR_LOCK_UNLOCK_FAILED;
+		else if (r1->card_status.COM_CRC_ERROR)
+			return SD_ERROR_COM_CRC;
+		else if (r1->card_status.ILLEGAL_COMMAND)
+			return SD_ERROR_ILLEGAL_COMMAND;
+		else if (r1->card_status.CARD_ECC_FAILED)
+			return SD_ERROR_CARD_ECC_FAILED;
+		else if (r1->card_status.CC_ERROR)
+			return SD_ERROR_CC;
+		else if (r1->card_status.ERROR)
+			return SD_ERROR_GENERAL;
+		else if (r1->card_status.CID_CSD_OVERWRITE)
+			return SD_ERROR_CID_CSD_OVERWRITE;
+		else if (r1->card_status.AKE_SEQ_ERROR)
+			return SD_ERROR_AKE_SEQ;
+		break;
+	default:
+		break;
+	}
+	return ret;
+}*/
+extern unsigned sd_debug_board_1bit_flag;
+static int sd_inand_staff_init(struct mmc *mmc)
+{
+	struct aml_card_sd_info * sdio=mmc->priv;
+    unsigned base;
+
+	sd_debug("");
+    sdio->sd_emmc_pwr_prepare(sdio->sd_emmc_port);
+	sd_debug("power off");
+	sdio->sd_emmc_pwr_off(sdio->sd_emmc_port);
+
+	//try to init mmc controller clock firstly
+	mmc->clock = 400000;
+	aml_sd_cfg_swth(mmc);
+
+	if (sdio->sd_emmc_port == SDIO_PORT_B) {  //only power ctrl for external tf card
+        base=get_timer(0);
+#if defined(CONFIG_VLSI_EMULATOR)
+	    while (get_timer(base)<1) ;
+#else
+        while (get_timer(base)<200) ;
+#endif
+    }
+    sdio->sd_emmc_pwr_on(sdio->sd_emmc_port);
+    sdio->sd_emmc_init(sdio->sd_emmc_port);
+	if (sd_debug_board_1bit_flag == 1) {
+        struct mmc_config *cfg;
+        cfg = &((struct aml_card_sd_info *)mmc->priv)->cfg;
+        cfg->host_caps = MMC_MODE_HS;
+        mmc->cfg = cfg;
+    }
+
+    if (sdio->sd_emmc_port == SDIO_PORT_B) {   //only power ctrl for external tf card
+        base=get_timer(0);
+#if defined(CONFIG_VLSI_EMULATOR)
+	    while (get_timer(base)<1) ;
+#else
+        while (get_timer(base)<200) ;
+#endif
+    }
+    if (!sdio->inited_flag)
+        sdio->inited_flag = 1;
+	return SD_NO_ERROR;
+}
+
+
+/*
+ * **********************************************************************************************
+ * u-boot interface function
+ * **********************************************************************************************
+ */
+
+/*
+ * Sends a command out on the bus. Takes the mmc pointer,
+ * a command pointer, and an optional data pointer.
+ */
+int aml_sd_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct	mmc_data *data)
+{
+        int ret = SD_NO_ERROR;
+        //u32 vconf;
+        u32 buffer = 0;
+        u32 resp_buffer;
+        u32 vstart = 0;
+        u32 status_irq = 0;
+        //u32 inalign = 0;
+        u32 *write_buffer = NULL;
+        struct sd_emmc_status *status_irq_reg = (void *)&status_irq;
+        struct sd_emmc_start *desc_start = (struct sd_emmc_start*)&vstart;
+        //struct sd_emmc_config* sd_emmc_cfg = (struct sd_emmc_config*)&vconf;
+        struct aml_card_sd_info *aml_priv = mmc->priv;
+        struct sd_emmc_global_regs *sd_emmc_reg = aml_priv->sd_emmc_reg;
+        struct cmd_cfg *des_cmd_cur = NULL;
+        struct sd_emmc_desc_info *desc_cur = (struct sd_emmc_desc_info*)aml_priv->desc_buf;
+
+        //vconf = sd_emmc_reg->gcfg;
+
+        memset(desc_cur, 0, (NEWSD_MAX_DESC_MUN>>2)*sizeof(struct sd_emmc_desc_info));
+
+        des_cmd_cur = (struct cmd_cfg *)&(desc_cur->cmd_info);
+        des_cmd_cur->cmd_index = 0x80 | cmd->cmdidx; //bit:31 owner = 1 bit:24-29 cmdidx
+        desc_cur->cmd_arg = cmd->cmdarg;
+
+        sd_inand_clear_response(cmd->response);
+
+        //check response type
+        if (cmd->resp_type & MMC_RSP_PRESENT) {
+                resp_buffer = (unsigned long)cmd->response;//dma_map_single((void*)cmd->response,sizeof(uint)*4,DMA_FROM_DEVICE);
+                des_cmd_cur->no_resp = 0;
+
+                //save Resp into Resp addr, and check response from register for RSP_136
+                if (cmd->resp_type & MMC_RSP_136)
+                        des_cmd_cur->resp_128 = 1;
+
+                if (cmd->resp_type & MMC_RSP_BUSY)
+                        des_cmd_cur->r1b = 1;    //check data0 busy after R1 reponse
+
+                if (!(cmd->resp_type & MMC_RSP_CRC))
+                        des_cmd_cur->resp_nocrc = 1;
+
+                des_cmd_cur->resp_num = 0;
+                desc_cur->resp_addr = resp_buffer;
+        }else
+                des_cmd_cur->no_resp = 1;
+
+        if (data) {
+                des_cmd_cur->data_io = 1; // cmd has data read or write
+                if (data->flags == MMC_DATA_READ) {
+                        des_cmd_cur->data_wr = 0;  //read data from sd/emmc
+                        buffer = (unsigned long)data->dest;//dma_map_single((void*)data->dest,data->blocks*data->blocksize,DMA_FROM_DEVICE);
+                        invalidate_dcache_range((unsigned long)data->dest, (unsigned long)(data->dest+data->blocks*data->blocksize));
+                }else{
+                        des_cmd_cur->data_wr = 1;
+                        //buffer = (unsigned long)data->src;//dma_map_single((void*)data->src,data->blocks*data->blocksize,DMA_TO_DEVICE);//(char *)data->src;
+                        write_buffer = (u32 *)malloc(128*1024);
+                        memset(write_buffer, 0 ,128*1024);
+                        memcpy(write_buffer, (u32 *)data->src, data->blocks*data->blocksize);
+                        flush_dcache_range((unsigned)(long)write_buffer,(unsigned long)(write_buffer+data->blocks*data->blocksize));
+                }
+
+                if (data->blocks > 1) {
+                        des_cmd_cur->block_mode = 1;
+                        des_cmd_cur->length = data->blocks;
+                }else{
+                        des_cmd_cur->block_mode = 0;
+                        des_cmd_cur->length = data->blocksize;
+                }
+                des_cmd_cur->data_num = 0;
+                if (des_cmd_cur->data_wr == 1)
+                        desc_cur->data_addr = (unsigned long)write_buffer;
+                else
+                        desc_cur->data_addr = buffer;
+                desc_cur->data_addr &= ~(1<<0);   //DDR
+
+        }
+        if (data) {
+                if ((data->blocks*data->blocksize <0x200) && (data->flags == MMC_DATA_READ)) {
+                        desc_cur->data_addr = (unsigned long)sd_emmc_reg->gping;
+                        desc_cur->data_addr |= 1<<0;
+                }
+        }
+        /*Prepare desc for config register*/
+        des_cmd_cur->owner = 1;
+        des_cmd_cur->end_of_chain = 0;
+
+        //sd_emmc_reg->gcfg = vconf;
+
+        des_cmd_cur->end_of_chain = 1; //the end flag of descriptor chain
+
+        sd_emmc_reg->gstatus = NEWSD_IRQ_ALL;
+
+        invalidate_dcache_range((unsigned long)aml_priv->desc_buf,
+                        (unsigned long)(aml_priv->desc_buf+NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info))));
+        //start transfer cmd
+        desc_start->init = 0;
+        desc_start->busy = 1;
+        desc_start->addr = (unsigned long)aml_priv->desc_buf >> 2;
+#if 0
+        sd_emmc_reg->gstart = vstart;
+#else
+        sd_emmc_reg->gcmd_cfg = desc_cur->cmd_info;
+        sd_emmc_reg->gcmd_dat = desc_cur->data_addr;
+        sd_emmc_reg->gcmd_arg = desc_cur->cmd_arg;
+#endif
+        //waiting end of chain
+        while (1) {
+                status_irq = sd_emmc_reg->gstatus;
+                if (status_irq_reg->end_of_chain)
+                        break;
+        }
+
+        if (status_irq_reg->rxd_err)
+                ret |= SD_EMMC_RXD_ERROR;
+        if (status_irq_reg->txd_err)
+                ret |= SD_EMMC_TXD_ERROR;
+        if (status_irq_reg->desc_err)
+                ret |= SD_EMMC_DESC_ERROR;
+        if (status_irq_reg->resp_err)
+                ret |= SD_EMMC_RESP_CRC_ERROR;
+        if (status_irq_reg->resp_timeout)
+                ret |= SD_EMMC_RESP_TIMEOUT_ERROR;
+        if (status_irq_reg->desc_timeout)
+                ret |= SD_EMMC_DESC_TIMEOUT_ERROR;
+        if (data) {
+                if ((data->blocks*data->blocksize <0x200) && (data->flags == MMC_DATA_READ)) {
+                        memcpy(data->dest, (const void *)sd_emmc_reg->gping,data->blocks*data->blocksize);
+                }
+        }
+        /*we get response [0]:bit0~31
+         *        response [1]:bit32~63
+         *        response [2]:bit64~95
+         *        response [3]:bit96~127
+         * actually mmc driver definition is:
+         *		 response [0]:bit96~127
+         *        response [1]:bit64~95
+         *        response [2]:bit32~63
+         *        response [3]:bit0~31
+         */
+
+        if (cmd->resp_type & MMC_RSP_136) {
+                cmd->response[0] = sd_emmc_reg->gcmd_rsp3;
+                cmd->response[1] = sd_emmc_reg->gcmd_rsp2;
+                cmd->response[2] = sd_emmc_reg->gcmd_rsp1;
+                cmd->response[3] = sd_emmc_reg->gcmd_rsp0;
+        } else {
+                cmd->response[0] = sd_emmc_reg->gcmd_rsp0;
+        }
+
+
+        sd_debug("cmd->cmdidx = %d, cmd->cmdarg=0x%x, ret=0x%x\n",cmd->cmdidx,cmd->cmdarg,ret);
+        sd_debug("cmd->response[0]=0x%x;\n",cmd->response[0]);
+        sd_debug("cmd->response[1]=0x%x;\n",cmd->response[1]);
+        sd_debug("cmd->response[2]=0x%x;\n",cmd->response[2]);
+        sd_debug("cmd->response[3]=0x%x;\n",cmd->response[3]);
+        if (des_cmd_cur->data_wr == 1) {
+                free(write_buffer);
+                write_buffer = NULL;
+        }
+        if (ret) {
+                if (status_irq_reg->resp_timeout)
+                        return TIMEOUT;
+                else
+                        return ret;
+        }
+
+        return SD_NO_ERROR;
+}
+
+int aml_sd_init(struct mmc *mmc)
+{
+	struct aml_card_sd_info *sdio=mmc->priv;
+
+    if (sdio->inited_flag) {
+		sdio->sd_emmc_init(sdio->sd_emmc_port);
+		mmc->cfg->ops->set_ios(mmc);
+        return 0;
+    }
+
+	if (sd_inand_check_insert(mmc)) {
+		sd_inand_staff_init(mmc);
+		return 0;
+	} else
+		return 1;
+}
+
+static const struct mmc_ops aml_sd_emmc_ops = {
+	.send_cmd	= aml_sd_send_cmd,
+	.set_ios	= aml_sd_cfg_swth,
+	.init		= aml_sd_init,
+//	.getcd		= ,
+//	.getwp		= ,
+};
+
+void sd_emmc_register(struct aml_card_sd_info * aml_priv)
+{
+	struct mmc_config *cfg;
+
+	aml_priv->removed_flag = 1;
+	aml_priv->inited_flag = 0;
+	aml_priv->sd_emmc_reg = (struct sd_emmc_global_regs *)sd_emmc_base_addr[aml_priv->sd_emmc_port];
+
+	cfg = &aml_priv->cfg;
+	cfg->name = aml_priv->name;
+	cfg->ops = &aml_sd_emmc_ops;
+
+	cfg->voltages = MMC_VDD_33_34|MMC_VDD_32_33|MMC_VDD_31_32|MMC_VDD_165_195;
+	cfg->host_caps = MMC_MODE_8BIT|MMC_MODE_4BIT | MMC_MODE_HS_52MHz | MMC_MODE_HS |
+			     MMC_MODE_HC;
+	cfg->f_min = 400000;
+	cfg->f_max = 50000000;
+	cfg->b_max = 256;
+	mmc_create(cfg,aml_priv);
+}
+
+bool aml_is_emmc_tsd (struct mmc *mmc) // is eMMC OR TSD
+{
+    struct aml_card_sd_info * sdio=mmc->priv;
+
+    return ((sdio->sd_emmc_port == SDIO_PORT_C));
+}
diff --git a/drivers/mmc/emmc_partitions.c b/drivers/mmc/emmc_partitions.c
new file mode 100644
index 0000000..160cac4
--- /dev/null
+++ b/drivers/mmc/emmc_partitions.c
@@ -0,0 +1,556 @@
+#include <common.h>
+#include <malloc.h>
+#include <asm/arch/io.h>
+#include <asm/arch/cpu_sdio.h>
+#include <mmc.h>
+#include <linux/err.h>
+#include <emmc_partitions.h>
+#include <partition_table.h>
+
+#define		POR_BOOT_VALUE 0
+#define		DTB_PART_SIZE	512*1024 //512K
+#define SZ_1M	0x100000
+#define DTB_ADDR_SIZE	(SZ_1M * 40)
+struct mmc_partition_config * mmc_partition_config_of =NULL;
+bool is_partition_checked = false;
+unsigned device_boot_flag = (unsigned)_AML_DEVICE_BOOT_FLAG_DEFAULT;
+extern struct mmc *find_mmc_device_by_port (unsigned sdio_port);
+extern int get_dtb_struct(struct mmc *mmc);
+extern struct partitions *part_table;
+extern int get_partition_from_dts(unsigned char * buffer);
+#if 0
+struct partitions part_table[MAX_PART_NUM]={
+		{
+			.name = "logo",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "recovery",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "dtb",
+			.size = 8*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "tee",
+			.size = 8*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "crypt",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "misc",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+#ifdef CONFIG_INSTABOOT
+		{
+			.name = "instaboot",
+			.size = 1024*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+#endif
+		{
+			.name = "boot",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "system",
+			.size = 1024*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "cache",
+			.size = 512*SZ_1M,
+			.mask_flags = STORE_CACHE,
+		},
+		{
+			.name = "data",
+			.size = NAND_PART_SIZE_FULL,
+			.mask_flags = STORE_DATA,
+		},
+};
+#endif
+
+#define PARTITION_ELEMENT(na, sz, flags) {.name = na, .size = sz, .mask_flags = flags,}
+struct partitions emmc_partition_table[]={
+    PARTITION_ELEMENT(MMC_BOOT_NAME, MMC_BOOT_DEVICE_SIZE, 0),
+    PARTITION_ELEMENT(MMC_RESERVED_NAME, MMC_RESERVED_SIZE, 0),
+    PARTITION_ELEMENT(MMC_CACHE_NAME, 0, 0),                    // the size and flag should be get from spl
+    // PARTITION_ELEMENT(MMC_KEY_NAME, MMC_KEY_SIZE, 0),
+    // PARTITION_ELEMENT(MMC_SECURE_NAME, MMC_SECURE_SIZE, 0),
+    PARTITION_ELEMENT(MMC_ENV_NAME, MMC_ENV_SIZE, 0),
+};
+
+void show_mmc_patition (struct partitions *part, int part_num)
+{
+    int i, cnt_stuff;
+
+    printf("        name                        offset              size              flag\n");
+    printf("===================================================================================\n");
+	for (i=0; i < part_num ; i++) {
+        printf("%4d: %s", i, part[i].name);
+        cnt_stuff = sizeof(part[i].name) - strlen(part[i].name);
+        if (cnt_stuff < 0) // something is wrong
+            cnt_stuff = 0;
+        cnt_stuff += 2;
+        while (cnt_stuff--) {
+            printf(" ");
+        }
+		printf("%18llx%18llx %18d\n", part[i].offset, part[i].size,part[i].mask_flags);
+		// printf("mmc_device->offset : %llx",mmc_partition_config_of->partitions[i].offset);
+		// printf("mmc_device->size : %llx",mmc_partition_config_of->partitions[i].size);
+	}
+}
+
+static struct partitions* find_partition_by_name (struct partitions *part_tbl, int part_num, char *name)
+{
+    int i;
+
+	for (i=0; i < part_num; i++) {
+        if (!part_tbl[i].name || (part_tbl[i].name[0] == '\0'))
+            break;
+
+	    if (!strncmp(part_tbl[i].name, name, MAX_MMC_PART_NAME_LEN)) {
+            return &(part_tbl[i]);
+        }
+	}
+
+    return NULL;
+}
+
+struct partitions* find_mmc_partition_by_name (char *name)
+{
+    struct partitions *p=NULL;
+    if (mmc_partition_config_of == NULL)
+        return p;
+    p = find_partition_by_name(mmc_partition_config_of->partitions, mmc_partition_config_of->part_num, name);
+    if (!p)
+        printf("Can not find partition name \"%s\"\n", name);
+
+    return p;
+}
+
+// set partition info according to what get from the spl
+int set_partition_info (struct partitions *src_tbl, int src_part_num,
+        struct partitions *dst_tbl, int dst_part_num, char *name)
+{
+    struct partitions *src=NULL;
+    struct partitions *dst=NULL;
+
+    src = find_partition_by_name(src_tbl, src_part_num, name);
+    if (!src)
+        return -1; // error
+
+    dst = find_partition_by_name(dst_tbl, dst_part_num, name);
+    if (!src)
+        return -1; // error
+
+    dst->size = src->size;
+    dst->mask_flags = src->mask_flags;
+
+    return 0; // OK
+}
+
+int mmc_get_partition_table (struct mmc *mmc)
+{
+	int i, part_num_left, resv_size, ret=0, part_num=0;
+	struct partitions *part_ptr;
+
+	mmc_partition_config_of = kmalloc((sizeof(struct mmc_partition_config)), 0);
+	if (mmc_partition_config_of == NULL) {
+		aml_mmc_dbg("malloc failed for mmc config!");
+		ret = -1;
+		goto exit_err;
+	}
+
+	memset(mmc_partition_config_of,0x0,(sizeof(struct mmc_partition_config)));
+	part_ptr = mmc_partition_config_of->partitions;
+	ret = get_dtb_struct(mmc);
+	if (ret)
+		goto exit_err;
+    set_partition_info(part_table, MAX_MMC_PART_NUM,
+            emmc_partition_table, ARRAY_SIZE(emmc_partition_table), MMC_ENV_NAME);
+    set_partition_info(part_table, MAX_MMC_PART_NUM,
+            emmc_partition_table, ARRAY_SIZE(emmc_partition_table), MMC_CACHE_NAME);
+
+	for (i=0; i < ARRAY_SIZE(emmc_partition_table); i++) {
+		strncpy(part_ptr[part_num].name, emmc_partition_table[i].name, MAX_MMC_PART_NAME_LEN);
+		part_ptr[part_num].size = emmc_partition_table[i].size;
+		part_ptr[part_num].mask_flags= emmc_partition_table[i].mask_flags;
+
+        if (part_num == 0) { // first partition
+            part_ptr[part_num].offset = 0;
+        } else {
+            if (!strncmp(part_ptr[part_num-1].name, MMC_BOOT_NAME, MAX_MMC_PART_NAME_LEN)) { // eMMC boot partition
+                resv_size = MMC_BOOT_PARTITION_RESERVED;
+                if ((device_boot_flag != EMMC_BOOT_FLAG)) {  //for spi boot case
+                    part_ptr[part_num].name[strlen(MMC_BOOT_NAME)] = 'e';
+                    part_ptr[part_num].name[strlen(MMC_BOOT_NAME)+1] = '\0';
+
+                    printf("change MMC BOOT NAME into 'bootloadere' for none emmc boot case, POR_BOOT_VALUE=%d\n", POR_BOOT_VALUE);
+                }
+            } else {
+                resv_size = PARTITION_RESERVED;
+            }
+            part_ptr[part_num].offset = part_ptr[part_num-1].offset
+                + part_ptr[part_num-1].size + resv_size;
+        }
+		part_num++;
+    }
+
+    part_num_left = MAX_MMC_PART_NUM - part_num;
+	for (i=0; i < part_num_left ; i++) {
+        if (!strncmp(part_table[i].name, MMC_ENV_NAME, MAX_MMC_PART_NAME_LEN)) { // skip env partition
+            printf("[%s] skip %s partition.\n", __FUNCTION__, MMC_ENV_NAME);
+            continue;
+        }
+
+        if (!strncmp(part_table[i].name, MMC_CACHE_NAME, MAX_MMC_PART_NAME_LEN)) { // get the info of cache partition
+            printf("[%s] skip %s partition.\n", __FUNCTION__, MMC_CACHE_NAME);
+            continue;
+        }
+
+		strncpy(part_ptr[part_num].name, part_table[i].name, MAX_MMC_PART_NAME_LEN);
+		part_ptr[part_num].size = part_table[i].size;
+		part_ptr[part_num].mask_flags= part_table[i].mask_flags;
+        part_ptr[part_num].offset = part_ptr[part_num-1].offset
+            + part_ptr[part_num-1].size + PARTITION_RESERVED;
+
+        // printf("*****************%d********************************\n", part_num);
+        // printf("mmc_device->name : %s\n", part_ptr[part_num].name);
+        // printf("mmc_device->offset : %llx\n", part_ptr[part_num].offset);
+        // printf("mmc_device->size : %llx\n", part_ptr[part_num].size);
+
+		if ((part_table[i].size == -1) || ((part_ptr[part_num].offset + part_ptr[part_num].size) > mmc->capacity)) {
+            part_ptr[part_num].size = mmc->capacity - part_ptr[part_num].offset;
+            //printf("mmc->capacity=%llx, mmc_device->size=%llx\n", mmc->capacity, part_ptr[part_num].size);
+			break;
+        }
+		part_num++;
+	}
+	strncpy((char *)(mmc_partition_config_of->version), MMC_UBOOT_VERSION, MAX_MMC_PART_NAME_LEN);
+	mmc_partition_config_of->part_num = part_num + 1;
+	mmc_partition_config_of->private_data = mmc;
+
+//    aml_mmc_msg("mmc_partition_config_of->part_num %d",mmc_partition_config_of->part_num);
+
+	return ret;
+
+exit_err:
+	if (mmc_partition_config_of) {
+		kfree(mmc_partition_config_of);
+		mmc_partition_config_of = NULL;
+        ret = -ENOMEM;
+	}
+
+	return ret;
+}
+
+int mmc_partition_tbl_checksum_calc (struct partitions *part, int part_num)
+{
+    int i, j;
+	u32 checksum = 0, *p;
+
+	for (i = 0; i < part_num; i++) {
+		p = (u32*)part;
+		for (j = sizeof(struct partitions)/sizeof(checksum); j > 0; j--) {
+			checksum += *p;
+			p++;
+	    }
+    }
+
+	return checksum;
+}
+
+int mmc_write_partition_tbl (struct mmc *mmc, struct mmc_partition_config *mmc_cfg, struct mmc_partitions_fmt *pt_fmt)
+{
+    int ret=0, start_blk, size, blk_cnt=0;
+    char *buf, *src;
+    struct partitions *pp;
+
+    buf = kmalloc(mmc->read_bl_len, 0); // size of a block
+    if (buf == NULL) {
+        aml_mmc_dbg("malloc failed for buffer!");
+        ret = -ENOMEM;
+        goto exit_err;
+    }
+    memset(pt_fmt, 0, sizeof(struct mmc_partitions_fmt));
+    memset(buf, 0, mmc->read_bl_len);
+
+    memcpy(pt_fmt->version, mmc_cfg->version, sizeof(pt_fmt->version));
+    pt_fmt->part_num = mmc_cfg->part_num;
+    memcpy(pt_fmt->partitions, mmc_cfg->partitions, MAX_MMC_PART_NUM*sizeof(mmc_cfg->partitions[0]));
+
+    pt_fmt->checksum = mmc_partition_tbl_checksum_calc(pt_fmt->partitions, pt_fmt->part_num);
+    strncpy(pt_fmt->magic, MMC_PARTITIONS_MAGIC, sizeof(pt_fmt->magic));
+
+
+    pp = find_mmc_partition_by_name(MMC_RESERVED_NAME);
+    if (!pp) {
+        ret = -1;
+        goto exit_err;
+    }
+    start_blk = pp->offset/mmc->read_bl_len;
+    size = sizeof(struct mmc_partitions_fmt);
+    src = (char *)pt_fmt;
+    if (size >= mmc->read_bl_len) {
+        blk_cnt = size / mmc->read_bl_len;
+        printf("mmc write lba=%#x, blocks=%#x\n", start_blk, blk_cnt);
+        ret = mmc->block_dev.block_write(mmc->block_dev.dev, start_blk, blk_cnt, src);
+        if (ret == 0) { // error
+            ret = -1;
+            goto exit_err;
+        }
+
+        start_blk += blk_cnt;
+        src += blk_cnt * mmc->read_bl_len;
+        size -= blk_cnt * mmc->read_bl_len;
+    }
+    if (size > 0) { // the last block
+        memcpy(buf, src, size);
+        // buf[mmc->read_bl_len - 2] = 0x55;
+        // buf[mmc->read_bl_len - 1] = 0xaa;
+
+        printf("mmc write lba=%#x, blocks=%#x\n", start_blk, blk_cnt);
+        ret = mmc->block_dev.block_write(mmc->block_dev.dev, start_blk, 1, buf);
+        if (ret == 0) { // error
+            ret = -1;
+            goto exit_err;
+        }
+    }
+
+    ret = 0; // everything is OK now
+
+exit_err:
+    if (buf) {
+        kfree(buf);
+    }
+
+    printf("%s: mmc write partition %s!\n", __FUNCTION__, (ret==0)? "OK": "ERROR");
+
+    return ret;
+}
+
+int mmc_read_partition_tbl (struct mmc *mmc, struct mmc_partitions_fmt *pt_fmt)
+{
+    int ret=0, start_blk, size, blk_cnt=0;
+    char *buf, *dst;
+	struct partitions *pp;
+
+	buf = kmalloc(mmc->read_bl_len, 0); // size of a block
+	if (buf == NULL) {
+		aml_mmc_dbg("malloc failed for buffer!");
+        ret = -ENOMEM;
+		goto exit_err;
+	}
+	memset(pt_fmt, 0, sizeof(struct mmc_partitions_fmt));
+	memset(buf, 0, mmc->read_bl_len);
+
+
+    pp = find_mmc_partition_by_name(MMC_RESERVED_NAME);
+    if (!pp) {
+        ret = -1;
+        goto exit_err;
+    }
+    start_blk = pp->offset/mmc->read_bl_len;
+    size = sizeof(struct mmc_partitions_fmt);
+    dst = (char *)pt_fmt;
+    if (size >= mmc->read_bl_len) {
+        blk_cnt = size / mmc->read_bl_len;
+        printf("mmc read lba=%#x, blocks=%#x\n", start_blk, blk_cnt);
+        ret = mmc->block_dev.block_read(mmc->block_dev.dev, start_blk, blk_cnt, dst);
+        if (ret == 0) { // error
+            ret = -1;
+            goto exit_err;
+        }
+
+        start_blk += blk_cnt;
+        dst += blk_cnt * mmc->read_bl_len;
+        size -= blk_cnt * mmc->read_bl_len;
+    }
+    if (size > 0) { // the last block
+        printf("mmc read lba=%#x, blocks=%#x\n", start_blk, blk_cnt);
+        ret = mmc->block_dev.block_read(mmc->block_dev.dev, start_blk, 1, buf);
+        if (ret == 0) { // error
+            ret = -1;
+            goto exit_err;
+        }
+
+        memcpy(dst, buf, size);
+        // if ((buf[mmc->read_bl_len - 2] != 0x55) || (buf[mmc->read_bl_len - 1] != 0xaa)) { // error
+            // ret = -1;
+            // goto exit_err;
+        // }
+    }
+
+	if ((strncmp(pt_fmt->magic, MMC_PARTITIONS_MAGIC, sizeof(pt_fmt->magic)) == 0) // the same
+       && (pt_fmt->part_num > 0) && (pt_fmt->part_num <= MAX_MMC_PART_NUM)
+       && (pt_fmt->checksum == mmc_partition_tbl_checksum_calc(pt_fmt->partitions, pt_fmt->part_num))) {
+        ret = 0; // everything is OK now
+	} else {
+        ret = -1; // the partition infomation is invalid
+    }
+
+exit_err:
+	if (buf) {
+		kfree(buf);
+	}
+
+	printf("%s: mmc read partition %s!\n", __FUNCTION__, (ret==0)? "OK": "ERROR");
+
+    return ret;
+}
+
+int mmc_partition_verify (struct mmc_partition_config * mmc_cfg, struct mmc_partitions_fmt *pt_fmt)
+{
+    int ret=0, i;
+    struct partitions *pp1, *pp2;
+
+    // printf("Partition table stored in eMMC/TSD: \n");
+    // printf("magic: %s, version: %s, checksum=%#x\n",
+            // pt_fmt->magic, pt_fmt->version, pt_fmt->checksum);
+    // show_mmc_patition(pt_fmt->partitions, pt_fmt->part_num);
+
+    // printf("Partition table get from SPL is : \n");
+    // printf("version: %s\n", mmc_cfg->version);
+    // show_mmc_patition(mmc_cfg->partitions, mmc_cfg->part_num);
+
+    if ((strncmp((const char *)(mmc_cfg->version), (const char *)(pt_fmt->version), sizeof(pt_fmt->version)) == 0x00)
+            && (mmc_cfg->part_num == pt_fmt->part_num)) {
+        pp1 = mmc_cfg->partitions;
+        pp2 = pt_fmt->partitions;
+        for (i = 0; i < pt_fmt->part_num; i++) {
+            if ((pp1[i].size != pp2[i].size)
+                    || (pp1[i].offset != pp2[i].offset)
+                    ||(pp1[i].mask_flags!= pp2[i].mask_flags)
+                    || (strncmp(pp1[i].name, pp2[i].name, sizeof(pp1[i].name)) != 0x00)) {
+                printf("%s: partition[%d] is different \n", __FUNCTION__, i);
+                ret = -1;
+                break;
+            }
+        }
+    } else {
+        printf("%s: version OR part_num is different!\n", __FUNCTION__);
+        ret = -1;
+    }
+
+    return ret;
+}
+
+int mmc_device_init (struct mmc *mmc)
+{
+	int ret=0;
+    struct mmc_partitions_fmt *pt_fmt;
+
+	ret = mmc_get_partition_table(mmc);
+    if (ret == 0) { // ok
+        printf("Partition table get from SPL is : \n");
+        show_mmc_patition(mmc_partition_config_of->partitions, mmc_partition_config_of->part_num);
+    } else {
+        printf("mmc get partition error!\n");
+        return -1;
+    }
+
+    pt_fmt = kmalloc(sizeof(struct mmc_partitions_fmt), 0);
+	if (pt_fmt == NULL) {
+		aml_mmc_dbg("malloc failed for struct mmc_partitions_fmt!");
+		return -ENOMEM;
+	}
+
+    ret = mmc_read_partition_tbl(mmc, pt_fmt);
+    if (ret == 0) { // ok
+        ret = mmc_partition_verify(mmc_partition_config_of, pt_fmt);
+        if (ret == 0) { // ok
+//            printf("Partition table verified OK !\n");
+        } else {
+            printf("Partition table verified ERROR!\n"
+                    "Following is the partition table stored in eMMC/TSD: \n");
+            show_mmc_patition(pt_fmt->partitions, pt_fmt->part_num);
+        }
+    }
+
+    if (ret != 0) { // error happen
+        ret = mmc_write_partition_tbl(mmc, mmc_partition_config_of, pt_fmt); // store mmc partition in tsd/emmc
+    }
+
+	if (pt_fmt) {
+		kfree(pt_fmt);
+	}
+
+	return ret;
+}
+
+
+int find_dev_num_by_partition_name (char *name)
+{
+	int dev_num=-1;
+	//struct mmc *mmc;
+
+    if (!strncmp(name, MMC_CARD_PARTITION_NAME, sizeof(MMC_CARD_PARTITION_NAME))) { // card
+       // port = SDIO_PORT_B;
+        dev_num = 0;
+    } else { // eMMC OR TSD
+        if (find_mmc_partition_by_name(name)) { // partition name is valid
+            //port = SDIO_PORT_C;
+            dev_num = 1;
+        } // else port=-1
+    }
+
+//    if (port > 0) {
+//        mmc = find_mmc_device_by_port((unsigned)port);
+//        if (!mmc) { // not found
+//            dev_num = -1;
+//        } else {
+//            dev_num = mmc->block_dev.dev;
+//        }
+//    } else { // partition name is invalid
+//        dev_num = -1;
+//    }
+
+    return dev_num;
+}
+
+int get_dtb_struct(struct mmc *mmc)
+{
+    int ret=0, start_blk, size, blk_cnt=0;
+    unsigned char *dst = NULL;
+    unsigned char *buffer = NULL;
+
+    //Burning empty emmc flash, dtb downloaded from usb tool
+    if (part_table) return 0;
+
+    buffer = (unsigned char *)malloc(sizeof(unsigned char) * DTB_PART_SIZE);
+    //struct partitions *pp = NULL;
+    start_blk = (DTB_ADDR_SIZE) / mmc->read_bl_len;
+    size = DTB_PART_SIZE;
+    dst = buffer;
+	if (size >= mmc->read_bl_len) {
+        blk_cnt = size / mmc->read_bl_len;
+        printf("mmc read lba=%#x, blocks=%#x\n", start_blk, blk_cnt);
+        ret = mmc->block_dev.block_read(mmc->block_dev.dev, start_blk, blk_cnt, dst);
+		if (ret == 0) { // error
+            ret = -1;
+            goto exit_err;
+        }
+    }
+    ret = get_partition_from_dts(buffer);
+	if (ret) {
+        printf("!!!!get dts FAILED\n");
+        goto exit_err;
+    }
+    printf("%s: Get emmc dtb %s!\n", __FUNCTION__, (ret==0)? "OK": "ERROR");
+exit_err:
+	if (buffer)
+        kfree(buffer);
+
+    return ret;
+}
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 1eb9c27..a410272 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -18,6 +18,11 @@
 #include <div64.h>
 #include "mmc_private.h"
 
+#ifdef CONFIG_STORE_COMPATIBLE
+#include <emmc_partitions.h>
+#include <partition_table.h>
+#endif
+
 static struct list_head mmc_devices;
 static int cur_dev_num = -1;
 
@@ -385,6 +390,9 @@ static int mmc_send_op_cond(struct mmc *mmc)
 
  	/* Asking to the card its capabilities */
 	mmc->op_cond_pending = 1;
+
+	return IN_PROGRESS;
+
 	for (i = 0; i < 2; i++) {
 		err = mmc_send_op_cond_iter(mmc, &cmd, i != 0);
 		if (err)
@@ -1409,6 +1417,23 @@ int mmc_init(struct mmc *mmc)
 	if (!err || err == IN_PROGRESS)
 		err = mmc_complete_init(mmc);
 	debug("%s: %d, time %lu\n", __func__, err, get_timer(start));
+	if (err)
+		return err;
+	printf("[%s] mmc init success\n", __func__);
+#if !defined(CONFIG_MACH_ODROIDC2)
+	if (mmc->block_dev.dev == 1)  {device_boot_flag = EMMC_BOOT_FLAG; }
+#endif
+#ifdef CONFIG_STORE_COMPATIBLE
+	if (mmc->block_dev.dev == 1)  {device_boot_flag = EMMC_BOOT_FLAG; }
+	if (aml_is_emmc_tsd(mmc)) { // eMMC OR TSD
+		if (!is_partition_checked) {
+			if (mmc_device_init(mmc) == 0) {
+				is_partition_checked = true;
+				printf("eMMC/TSD partition table have been checked OK!\n");
+			}
+		}
+	}
+#endif
 	return err;
 }
 
@@ -1618,3 +1643,60 @@ int mmc_set_rst_n_function(struct mmc *mmc, u8 enable)
 			  enable);
 }
 #endif
+
+#ifdef  CONFIG_STORE_COMPATIBLE
+int mmc_key_read(unsigned char *buf, unsigned int size)
+{
+	ulong start, start_blk, blkcnt, ret;
+	unsigned char *temp_buf = buf;
+	start = EMMCKEY_RESERVE_OFFSET + MMC_RESERVED_OFFSET;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	ret = mmc_bread(1, start_blk, blkcnt, temp_buf);
+	if (ret != blkcnt) {
+		printf("[%s] %d, mmc_bread error\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+extern ulong mmc_bwrite(int dev_num, lbaint_t start,
+				lbaint_t blkcnt, const void *src);
+int mmc_key_write(unsigned char *buf, unsigned int size)
+{
+	ulong start, start_blk, blkcnt, ret;
+	unsigned char * temp_buf = buf;
+	int i = 2;
+	start = EMMCKEY_RESERVE_OFFSET + MMC_RESERVED_OFFSET;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	do {
+		ret = mmc_bwrite(1, start_blk, blkcnt, temp_buf);
+		if (ret != blkcnt) {
+			printf("[%s] %d, mmc_bwrite error\n",
+				__func__, __LINE__);
+			return 1;
+		}
+		start_blk += MMC_KEY_SIZE / MMC_BLOCK_SIZE;
+	} while (--i);
+	return 0;
+}
+
+extern unsigned long mmc_berase(int dev_num,
+				lbaint_t start, lbaint_t blkcnt);
+int mmc_key_erase(void)
+{
+	ulong start, start_blk, blkcnt, ret;
+	start = EMMCKEY_RESERVE_OFFSET + MMC_RESERVED_OFFSET;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (MMC_KEY_SIZE / MMC_BLOCK_SIZE) * 2;//key and backup key
+	ret = mmc_berase(1, start_blk, blkcnt);
+	if (ret) {
+		printf("[%s] %d mmc_berase error\n",
+				__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/drivers/mmc/mmc_write.c b/drivers/mmc/mmc_write.c
index 3db9669..4e8655b 100644
--- a/drivers/mmc/mmc_write.c
+++ b/drivers/mmc/mmc_write.c
@@ -24,7 +24,7 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 		end = (start + blkcnt - 1) * mmc->write_bl_len;
 		start *= mmc->write_bl_len;
 	}
-
+	printf("start = %lu,end = %lu\n",start,end);
 	if (IS_SD(mmc)) {
 		start_cmd = SD_CMD_ERASE_WR_BLK_START;
 		end_cmd = SD_CMD_ERASE_WR_BLK_END;
@@ -72,7 +72,10 @@ unsigned long mmc_berase(int dev_num, lbaint_t start, lbaint_t blkcnt)
 
 	if (!mmc)
 		return -1;
-
+	if (blkcnt == 0) {
+		blkcnt = mmc->capacity/512 - (mmc->capacity/512)% mmc->erase_grp_size; // erase whole
+		printf("blkcnt = %lu\n",blkcnt);
+	}
 	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
 		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
 		       "The erase range would be change to "
@@ -82,7 +85,7 @@ unsigned long mmc_berase(int dev_num, lbaint_t start, lbaint_t blkcnt)
 		       & ~(mmc->erase_grp_size - 1)) - 1);
 
 	while (blk < blkcnt) {
-		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
+		blk_r = ((blkcnt - blk) < mmc->erase_grp_size) ?
 			mmc->erase_grp_size : (blkcnt - blk);
 		err = mmc_erase_t(mmc, start + blk, blk_r);
 		if (err)
@@ -92,10 +95,10 @@ unsigned long mmc_berase(int dev_num, lbaint_t start, lbaint_t blkcnt)
 
 		/* Waiting for the ready status */
 		if (mmc_send_status(mmc, timeout))
-			return 0;
+			return 1;
 	}
 
-	return blk;
+	return 0;
 }
 
 static ulong mmc_write_blocks(struct mmc *mmc, lbaint_t start,
diff --git a/drivers/mmc/rpmb.c b/drivers/mmc/rpmb.c
index 9d0b8bc..ca3f64b 100644
--- a/drivers/mmc/rpmb.c
+++ b/drivers/mmc/rpmb.c
@@ -66,7 +66,7 @@ struct s_rpmb {
 	unsigned char mac[RPMB_SZ_MAC];
 	unsigned char data[RPMB_SZ_DATA];
 	unsigned char nonce[RPMB_SZ_NONCE];
-	unsigned long write_counter;
+	unsigned int write_counter;
 	unsigned short address;
 	unsigned short block_count;
 	unsigned short result;
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
index c61b784..336c8a9 100644
--- a/drivers/mtd/spi/Makefile
+++ b/drivers/mtd/spi/Makefile
@@ -7,15 +7,21 @@
 
 obj-$(CONFIG_DM_SPI_FLASH) += sf-uclass.o
 
-ifdef CONFIG_SPL_BUILD
-obj-$(CONFIG_SPL_SPI_LOAD)	+= spi_spl_load.o
-obj-$(CONFIG_SPL_SPI_BOOT)	+= fsl_espi_spl.o
+ifdef CONFIG_AMLOGIC_SPI_FLASH
+obj-$(CONFIG_SPI_FLASH)	+= spi_flash_amlogic.o
+else
+obj-$(CONFIG_SPI_FLASH)	+= spi_flash.o
 endif
-
-#ifndef CONFIG_DM_SPI
-obj-$(CONFIG_SPI_FLASH) += sf_probe.o
-#endif
-obj-$(CONFIG_CMD_SF) += sf.o
-obj-$(CONFIG_SPI_FLASH) += sf_ops.o sf_params.o
-obj-$(CONFIG_SPI_FLASH_SANDBOX) += sandbox.o
+obj-$(CONFIG_SPI_FLASH_ATMEL)	+= atmel.o
+obj-$(CONFIG_SPI_FLASH_EON)	+= eon.o
+obj-$(CONFIG_SPI_FLASH_MACRONIX)	+= macronix.o
+obj-$(CONFIG_SPI_FLASH_SPANSION)	+= spansion.o
+obj-$(CONFIG_SPI_FLASH_SST)	+= sst.o
+obj-$(CONFIG_SPI_FLASH_STMICRO)	+= stmicro.o
+obj-$(CONFIG_SPI_FLASH_WINBOND)	+= winbond.o
+obj-$(CONFIG_SPI_FRAM_RAMTRON)	+= ramtron.o
 obj-$(CONFIG_SPI_M95XXX) += eeprom_m95xxx.o
+obj-$(CONFIG_SPI_FLASH_GIGADEVICE) += gigadevice.o
+obj-$(CONFIG_SPI_FLASH_PMDEVICE) += pmdevice.o
+obj-$(CONFIG_SPI_NOR_SECURE_STORAGE) += spi_secure_storage.o
+obj-$(CONFIG_SPI_FLASH_ESMT) += esmt.o
diff --git a/drivers/mtd/spi/atmel.c b/drivers/mtd/spi/atmel.c
new file mode 100644
index 0000000..b50d0ed
--- /dev/null
+++ b/drivers/mtd/spi/atmel.c
@@ -0,0 +1,552 @@
+/*
+ * Atmel SPI DataFlash support
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include "spi_flash_amlogic.h"
+#include "spi_flash_internal.h"
+
+/* AT45-specific commands */
+#define CMD_AT45_READ_STATUS		0xd7
+#define CMD_AT45_ERASE_PAGE		0x81
+#define CMD_AT45_LOAD_PROG_BUF1		0x82
+#define CMD_AT45_LOAD_BUF1		0x84
+#define CMD_AT45_LOAD_PROG_BUF2		0x85
+#define CMD_AT45_LOAD_BUF2		0x87
+#define CMD_AT45_PROG_BUF1		0x88
+#define CMD_AT45_PROG_BUF2		0x89
+
+/* AT45 status register bits */
+#define AT45_STATUS_P2_PAGE_SIZE	(1 << 0)
+#define AT45_STATUS_READY		(1 << 7)
+
+/* DataFlash family IDs, as obtained from the second idcode byte */
+#define DF_FAMILY_AT26F			0
+#define DF_FAMILY_AT45			1
+#define DF_FAMILY_AT26DF		2	/* AT25DF and AT26DF */
+
+struct atmel_spi_flash_params {
+	u8		idcode1;
+	/* Log2 of page size in power-of-two mode */
+	u8		l2_page_size;
+	u8		pages_per_block;
+	u8		blocks_per_sector;
+	u8		nr_sectors;
+	const char	*name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct atmel_spi_flash {
+	struct spi_flash flash;
+	const struct atmel_spi_flash_params *params;
+};
+
+static inline struct atmel_spi_flash *
+to_atmel_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct atmel_spi_flash, flash);
+}
+
+static const struct atmel_spi_flash_params atmel_spi_flash_table[] = {
+	{
+		.idcode1		= 0x22,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 16,
+		.nr_sectors		= 4,
+		.name			= "AT45DB011D",
+	},
+	{
+		.idcode1		= 0x23,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 16,
+		.nr_sectors		= 8,
+		.name			= "AT45DB021D",
+	},
+	{
+		.idcode1		= 0x24,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 8,
+		.name			= "AT45DB041D",
+	},
+	{
+		.idcode1		= 0x25,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 16,
+		.name			= "AT45DB081D",
+	},
+	{
+		.idcode1		= 0x26,
+		.l2_page_size		= 9,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 16,
+		.name			= "AT45DB161D",
+	},
+	{
+		.idcode1		= 0x27,
+		.l2_page_size		= 9,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 64,
+		.nr_sectors		= 64,
+		.name			= "AT45DB321D",
+	},
+	{
+		.idcode1		= 0x28,
+		.l2_page_size		= 10,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 32,
+		.name			= "AT45DB642D",
+	},
+};
+
+static int at45_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 cmd = CMD_AT45_READ_STATUS;
+	u8 status;
+
+	timebase = get_timer(0);
+
+	ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
+	if (ret)
+		return -1;
+
+	do {
+		ret = spi_xfer(spi, 8, NULL, &status, 0);
+		if (ret)
+			return -1;
+
+		if (status & AT45_STATUS_READY)
+			break;
+	} while (get_timer(timebase) < timeout);
+
+	/* Deactivate CS */
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if (status & AT45_STATUS_READY)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+/*
+ * Assemble the address part of a command for AT45 devices in
+ * non-power-of-two page size mode.
+ */
+static void at45_build_address(struct atmel_spi_flash *asf, u8 *cmd, u32 offset)
+{
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	unsigned int page_shift;
+
+	/*
+	 * The "extra" space per page is the power-of-two page size
+	 * divided by 32.
+	 */
+	page_shift = asf->params->l2_page_size;
+	page_size = (1 << page_shift) + (1 << (page_shift - 5));
+	page_shift++;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	cmd[0] = page_addr >> (16 - page_shift);
+	cmd[1] = page_addr << (page_shift - 8) | (byte_addr >> 8);
+	cmd[2] = byte_addr;
+}
+
+static int dataflash_read_fast_p2(struct spi_flash *flash,
+		u32 offset, size_t len, void *buf)
+{
+	u8 cmd[5];
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = offset >> 16;
+	cmd[2] = offset >> 8;
+	cmd[3] = offset;
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int dataflash_read_fast_at45(struct spi_flash *flash,
+		u32 offset, size_t len, void *buf)
+{
+	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	u8 cmd[5];
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	at45_build_address(asf, cmd + 1, offset);
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+/*
+ * TODO: the two write funcs (_p2/_at45) should get unified ...
+ */
+static int dataflash_write_p2(struct spi_flash *flash,
+		u32 offset, size_t len, const void *buf)
+{
+	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	unsigned long page_size;
+	u32 addr = offset;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * TODO: This function currently uses only page buffer #1.  We can
+	 * speed this up by using both buffers and loading one buffer while
+	 * the other is being programmed into main memory.
+	 */
+
+	page_size = (1 << asf->params->l2_page_size);
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - (addr % page_size));
+
+		/* Use the same address bits for both commands */
+		cmd[0] = CMD_AT45_LOAD_BUF1;
+		cmd[1] = addr >> 16;
+		cmd[2] = addr >> 8;
+		cmd[3] = addr;
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+				buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: Loading AT45 buffer failed\n");
+			goto out;
+		}
+
+		cmd[0] = CMD_AT45_PROG_BUF1;
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: AT45 page programming failed\n");
+			goto out;
+		}
+
+		ret = at45_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: AT45 page programming timed out\n");
+			goto out;
+		}
+
+		addr += chunk_len;
+	}
+
+	debug("SF: AT45: Successfully programmed %zu bytes @ 0x%x\n",
+			len, offset);
+	ret = 0;
+
+out:
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+static int dataflash_write_at45(struct spi_flash *flash,
+		u32 offset, size_t len, const void *buf)
+{
+	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	unsigned int page_shift;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * TODO: This function currently uses only page buffer #1.  We can
+	 * speed this up by using both buffers and loading one buffer while
+	 * the other is being programmed into main memory.
+	 */
+
+	page_shift = asf->params->l2_page_size;
+	page_size = (1 << page_shift) + (1 << (page_shift - 5));
+	page_shift++;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		/* Use the same address bits for both commands */
+		cmd[0] = CMD_AT45_LOAD_BUF1;
+		cmd[1] = page_addr >> (16 - page_shift);
+		cmd[2] = page_addr << (page_shift - 8) | (byte_addr >> 8);
+		cmd[3] = byte_addr;
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+				buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: Loading AT45 buffer failed\n");
+			goto out;
+		}
+
+		cmd[0] = CMD_AT45_PROG_BUF1;
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: AT45 page programming failed\n");
+			goto out;
+		}
+
+		ret = at45_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: AT45 page programming timed out\n");
+			goto out;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: AT45: Successfully programmed %zu bytes @ 0x%x\n",
+			len, offset);
+	ret = 0;
+
+out:
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+/*
+ * TODO: the two erase funcs (_p2/_at45) should get unified ...
+ */
+int dataflash_erase_p2(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	unsigned long page_size;
+
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * TODO: This function currently uses page erase only. We can
+	 * probably speed things up by using block and/or sector erase
+	 * when possible.
+	 */
+
+	page_size = (1 << asf->params->l2_page_size);
+
+	if (offset % page_size || len % page_size) {
+		debug("SF: Erase offset/length not multiple of page size\n");
+		return -1;
+	}
+
+	cmd[0] = CMD_AT45_ERASE_PAGE;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	for (actual = 0; actual < len; actual += page_size) {
+		cmd[1] = offset >> 16;
+		cmd[2] = offset >> 8;
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: AT45 page erase failed\n");
+			goto out;
+		}
+
+		ret = at45_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: AT45 page erase timed out\n");
+			goto out;
+		}
+
+		offset += page_size;
+	}
+
+	debug("SF: AT45: Successfully erased %zu bytes @ 0x%x\n",
+			len, offset);
+	ret = 0;
+
+out:
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int dataflash_erase_at45(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	unsigned int page_shift;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * TODO: This function currently uses page erase only. We can
+	 * probably speed things up by using block and/or sector erase
+	 * when possible.
+	 */
+
+	page_shift = asf->params->l2_page_size;
+	page_size = (1 << page_shift) + (1 << (page_shift - 5));
+	page_shift++;
+	page_addr = offset / page_size;
+
+	if (offset % page_size || len % page_size) {
+		debug("SF: Erase offset/length not multiple of page size\n");
+		return -1;
+	}
+
+	cmd[0] = CMD_AT45_ERASE_PAGE;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	for (actual = 0; actual < len; actual += page_size) {
+		cmd[1] = page_addr >> (16 - page_shift);
+		cmd[2] = page_addr << (page_shift - 8);
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: AT45 page erase failed\n");
+			goto out;
+		}
+
+		ret = at45_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: AT45 page erase timed out\n");
+			goto out;
+		}
+
+		page_addr++;
+	}
+
+	debug("SF: AT45: Successfully erased %zu bytes @ 0x%x\n",
+			len, offset);
+	ret = 0;
+
+out:
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode)
+{
+	const struct atmel_spi_flash_params *params;
+	unsigned page_size;
+	unsigned int family;
+	struct atmel_spi_flash *asf;
+	unsigned int i;
+	int ret;
+	u8 status;
+
+	for (i = 0; i < ARRAY_SIZE(atmel_spi_flash_table); i++) {
+		params = &atmel_spi_flash_table[i];
+		if (params->idcode1 == idcode[1])
+			break;
+	}
+
+	if (i == ARRAY_SIZE(atmel_spi_flash_table)) {
+		debug("SF: Unsupported DataFlash ID %02x\n",
+				idcode[1]);
+		return NULL;
+	}
+
+	asf = malloc(sizeof(struct atmel_spi_flash));
+	if (!asf) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	asf->params = params;
+	asf->flash.spi = spi;
+	asf->flash.name = params->name;
+
+	/* Assuming power-of-two page size initially. */
+	page_size = 1 << params->l2_page_size;
+
+	family = idcode[1] >> 5;
+
+	switch (family) {
+	case DF_FAMILY_AT45:
+		/*
+		 * AT45 chips have configurable page size. The status
+		 * register indicates which configuration is active.
+		 */
+		ret = spi_flash_cmd(spi, CMD_AT45_READ_STATUS, &status, 1);
+		if (ret)
+			goto err;
+
+		debug("SF: AT45 status register: %02x\n", status);
+
+		if (!(status & AT45_STATUS_P2_PAGE_SIZE)) {
+			asf->flash.read = dataflash_read_fast_at45;
+			asf->flash.write = dataflash_write_at45;
+			asf->flash.erase = dataflash_erase_at45;
+			page_size += 1 << (params->l2_page_size - 5);
+		} else {
+			asf->flash.read = dataflash_read_fast_p2;
+			asf->flash.write = dataflash_write_p2;
+			asf->flash.erase = dataflash_erase_p2;
+		}
+
+		break;
+
+	case DF_FAMILY_AT26F:
+	case DF_FAMILY_AT26DF:
+		asf->flash.read = dataflash_read_fast_p2;
+		break;
+
+	default:
+		debug("SF: Unsupported DataFlash family %u\n", family);
+		goto err;
+	}
+
+	asf->flash.size = page_size * params->pages_per_block
+				* params->blocks_per_sector
+				* params->nr_sectors;
+
+	printf("SF: Detected %s with page size %u, total ",
+	       params->name, page_size);
+	print_size(asf->flash.size, "\n");
+
+	return &asf->flash;
+
+err:
+	free(asf);
+	return NULL;
+}
diff --git a/drivers/mtd/spi/eon.c b/drivers/mtd/spi/eon.c
new file mode 100644
index 0000000..7bec3a5
--- /dev/null
+++ b/drivers/mtd/spi/eon.c
@@ -0,0 +1,381 @@
+/*
+ * (C) Copyright 2010, ucRobotics Inc.
+ * Author: Chong Huang <chuang@ucrobotics.com>
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+
+#include "spi_flash_internal.h"
+
+/* EN25Q128-specific commands */
+#define CMD_EN25Q128_WREN	0x06    /* Write Enable */
+#define CMD_EN25Q128_WRDI	0x04    /* Write Disable */
+#define CMD_EN25Q128_RDSR	0x05    /* Read Status Register */
+#define CMD_EN25Q128_WRSR	0x01    /* Write Status Register */
+#define CMD_EN25Q128_READ	0x03    /* Read Data Bytes */
+#define CMD_EN25Q128_FAST_READ	0x0b    /* Read Data Bytes at Higher Speed */
+#define CMD_EN25Q128_PP		0x02    /* Page Program */
+#define CMD_EN25Q128_SE		0x20    /* Sector Erase */
+#define CMD_EN25Q128_BE		0xd8    /* Block Erase */
+#define CMD_EN25Q128_DP		0xb9    /* Deep Power-down */
+#define CMD_EN25Q128_RES	0xab    /* Release from DP, and Read Signature */
+
+#define EON_ID_EN25Q128		0x18
+
+#define EON_SR_WIP		    (1 << 0)	/* Write-in-Progress */
+
+struct eon_spi_flash_params {
+	u8  idcode1;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 sectors_per_block;
+	u16 nr_sectors;
+	const char *name;
+};
+#else /*else CONFIG_AMLOGIC_SPI_FLASH*/
+
+#include "spi_flash_amlogic.h"
+
+struct eon_spi_flash_params {
+	uint32_t	id;
+	uint32_t	sector_size;
+	uint32_t	block_size;
+	uint32_t	chip_size;
+	const char	*name;
+};
+
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct eon_spi_flash {
+	struct spi_flash flash;
+	const struct eon_spi_flash_params *params;
+};
+
+static inline struct eon_spi_flash *to_eon_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct eon_spi_flash, flash);
+}
+
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+
+static const struct eon_spi_flash_params eon_spi_flash_table[] = {
+	{
+		.idcode1 = EON_ID_EN25Q128,
+		.page_size = 256,
+		.pages_per_sector = 16,
+		.sectors_per_block = 16,
+		.nr_sectors = 4096,
+		.name = "EN25Q128",
+	},
+};
+
+#else /*else CONFIG_AMLOGIC_SPI_FLASH*/
+
+#define EON_ID_EN25B16 0x2015
+#define EON_ID_M25X32  0x2016
+#define EON_ID_M25X64  0x2017
+#define EON_ID_EN25F16 0x3115
+#define EON_ID_EN25F40 0x3113
+
+static const struct eon_spi_flash_params eon_spi_flash_table[] = {
+	{	.id			 = EON_ID_EN25F16,
+		.sector_size = 4*1024,
+		.block_size	 = 64*1024 ,
+		.chip_size	 = 2*1024*1024,
+		.name		 = "EN25F16",
+	},
+	{	.id			 = EON_ID_EN25B16,
+		.sector_size = 4*1024,
+		.block_size	 = 64*1024 ,
+		.chip_size	 = 2*1024*1024,
+		.name		 = "EN25B16",
+	},
+	{	.id			 = EON_ID_EN25F40,
+		.sector_size = 4*1024,
+		.block_size	 = 64*1024 ,
+		.chip_size	 = 512*1024,
+		.name		 = "EN25F40",
+	},
+};
+
+//new solution for Amlogic SPI controller
+//
+//
+static int eon_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	int nReturn = 0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+static int eon_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int nReturn =0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+static int eon_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct eon_spi_flash *stm = to_eon_spi_flash(flash);
+	u32 sector_size;
+	int nReturn;
+
+	sector_size = stm->params->sector_size;
+
+	spi_claim_bus(flash->spi);
+
+	nReturn = spi_flash_erase_amlogic(flash, offset, len, sector_size);
+
+	spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+
+/*for CONFIG_AMLOGIC_SPI_FLASH, keep former for rollback verify*/
+
+static int eon_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 cmd = CMD_EN25Q128_RDSR;
+	u8 status;
+
+	ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
+	if (ret) {
+		debug("SF: Failed to send command %02x: %d\n", cmd, ret);
+		return ret;
+	}
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_xfer(spi, 8, NULL, &status, 0);
+		if (ret)
+			return -1;
+
+		if ((status & EON_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if ((status & EON_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int eon_read_fast(struct spi_flash *flash,
+			 u32 offset, size_t len, void *buf)
+{
+	struct eon_spi_flash *eon = to_eon_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = eon->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int eon_write(struct spi_flash *flash,
+		     u32 offset, size_t len, const void *buf)
+{
+	struct eon_spi_flash *eon = to_eon_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = eon->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_EN25Q128_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_EN25Q128_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: EON Page Program failed\n");
+			break;
+		}
+
+		ret = eon_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: EON page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: EON: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int eon_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	/* block erase */
+	struct eon_spi_flash *eon = to_eon_spi_flash(flash);
+	unsigned long block_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+
+	block_size = eon->params->page_size * eon->params->pages_per_sector
+	       * eon->params->sectors_per_block;
+
+	if (offset % block_size || len % block_size) {
+		debug("SF: Erase offset/length not multiple of block size\n");
+		return -1;
+	}
+
+	len /= block_size;
+	cmd[0] = CMD_EN25Q128_BE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual++) {
+		cmd[1] = (offset / block_size) + actual;
+		ret = spi_flash_cmd(flash->spi, CMD_EN25Q128_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: EON page erase failed\n");
+			break;
+		}
+
+		ret = eon_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: EON page erase timed out\n");
+			break;
+		}
+	}
+
+	debug("SF: EON: Successfully erased %u bytes @ 0x%x\n",
+	      len * block_size, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode)
+{
+	const struct eon_spi_flash_params *params;
+	struct eon_spi_flash *eon;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(eon_spi_flash_table); ++i) {
+		params = &eon_spi_flash_table[i];
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+		if (params->idcode1 == idcode[2])
+			break;
+#else
+		if (((idcode[1] << 8) | idcode[2]) == params->id)
+			break;
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+	}
+
+	if (i == ARRAY_SIZE(eon_spi_flash_table)) {
+		debug("SF: Unsupported EON ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	eon = malloc(sizeof(*eon));
+	if (!eon) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	eon->params = params;
+	eon->flash.spi = spi;
+	eon->flash.name = params->name;
+
+	eon->flash.write = eon_write;
+	eon->flash.erase = eon_erase;
+	eon->flash.read  = eon_read_fast;
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+	eon->flash.size = params->page_size * params->pages_per_sector
+	    * params->nr_sectors;
+#else
+	eon->flash.size = params->chip_size;
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+	return &eon->flash;
+}
diff --git a/drivers/mtd/spi/esmt.c b/drivers/mtd/spi/esmt.c
new file mode 100644
index 0000000..a815b66
--- /dev/null
+++ b/drivers/mtd/spi/esmt.c
@@ -0,0 +1,309 @@
+/*
+ * Copyright C 2009 by Amlogic, Inc. All Rights Reserved.
+ * Description: esmt spi chips support
+ * Author:	pfs
+ */
+#define DEBUG
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include "spi_flash_amlogic.h"
+
+struct esmt_spi_flash_params {
+	uint32_t	id;
+	uint32_t	sector_size;
+	uint32_t	block_size;
+	uint32_t	chip_size;
+	const char	*name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct esmt_spi_flash {
+	struct spi_flash flash;
+	const struct esmt_spi_flash_params *params;
+};
+
+static inline struct esmt_spi_flash * to_esmt_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct esmt_spi_flash, flash);
+}
+
+#define ESMT_ID_F25L08QA 0x4014
+#define ESMT_ID_F25L16PA 0x2115
+#define ESMT_ID_F25L32PA 0x2116
+#define ESMT_ID_F25L32QA 0x4116
+
+static const struct esmt_spi_flash_params esmt_spi_flash_table[] = {
+	{
+		.id			= ESMT_ID_F25L08QA,
+		.sector_size= 4*1024,
+		.block_size	=64*1024 ,
+		.chip_size	= 1*1024*1024,
+		.name			= "F25L08QA",
+	},
+	{
+		.id			= ESMT_ID_F25L16PA,
+		.sector_size= 4*1024,
+		.block_size	=64*1024 ,
+		.chip_size	= 2*1024*1024,
+		.name			= "F25L16PA",
+	},
+	{
+		.id			= ESMT_ID_F25L32PA,
+		.sector_size= 4*1024,
+		.block_size	=64*1024 ,
+		.chip_size	=4*1024*1024,
+		.name		= "F25L32PA",
+	},
+	{
+		.id			= ESMT_ID_F25L32QA,
+		.sector_size= 4*1024,
+		.block_size	=64*1024 ,
+		.chip_size	=4*1024*1024,
+		.name		= "F25L32QA",
+	},
+};
+#if 0
+int spi_flash_read_aml_esmt(struct spi_flash *flash,u32 offset, size_t len, void *buf){
+
+	struct spi_slave *spi = flash->spi;
+	//int ret;
+	u32 temp_addr;
+    int temp_length;
+    temp_addr = offset;
+    temp_length = len;
+	unsigned flags;
+
+	spi_claim_bus(spi);															/*FIXME for spi_xfer release bus*/
+	while (temp_length>0) {
+
+		flags=(temp_addr & 0xffffff)|( (temp_length>=32?32:temp_length) << SPI_FLASH_BYTES_LEN);
+
+		spi_flash_adr_write(spi, flags);
+
+		flags=(1<<SPI_FLASH_READ);
+
+		spi_flash_cmd(spi,flags,NULL,0);
+
+		flags=SPI_XFER_READCACHE;
+
+		spi_xfer(spi,(temp_length>=32?32:temp_length)*8,NULL,buf,flags);
+
+        temp_addr   += (temp_length>=32?32:temp_length);
+		buf			+= (temp_length>=32?32:temp_length);
+		temp_length -= (temp_length>=32?32:temp_length);
+
+	}
+
+	return 0;
+
+}
+#endif
+static int esmt_read(struct spi_flash *flash,u32 offset, size_t len, void *buf){
+
+//	struct esmt_spi_flash *stm = to_esmt_spi_flash(flash);
+	int ret;
+
+	spi_claim_bus(flash->spi);
+
+    ret = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return  ret;
+}
+#if 0
+int spi_flash_write_esmt(struct spi_flash *flash,u32 offset, size_t len, const void *buf){
+
+	struct spi_slave *spi = flash->spi;
+	int ret;
+	unsigned temp_addr;
+    int temp_length;
+    temp_addr = offset;
+    temp_length = len;
+	unsigned flags;
+
+	while (temp_length>0) {
+
+		flags=(temp_addr & 0xffffff)|( (temp_length>=32?32:temp_length) << SPI_FLASH_BYTES_LEN);
+
+		spi_flash_adr_write(spi, flags);
+
+		flags=SPI_XFER_WRITECACHE;
+
+		spi_xfer(spi,(temp_length>=32?32:temp_length)*8,buf,NULL,flags);
+
+
+		flags=(1<<SPI_FLASH_WREN);
+		spi_flash_cmd(spi,flags,NULL,0);
+
+		flags=(1<<SPI_FLASH_PP);
+		spi_flash_cmd(spi,flags,NULL,0);
+
+
+		 ret=1;
+		while ( (ret&1) == 1 ) {
+
+			flags=1<<SPI_FLASH_RDSR;
+
+			spi_flash_cmd(spi,flags,&ret,2);		//2 byte status
+
+
+		}
+
+
+        temp_addr   += (temp_length>=32?32:temp_length);
+		buf			+= (temp_length>=32?32:temp_length);
+		temp_length -= (temp_length>=32?32:temp_length);
+
+	}
+
+#ifdef SPI_WRITE_PROTECT
+        spi_enable_write_protect();
+#endif
+	return 0;
+
+
+}
+#endif
+static int esmt_write(struct spi_flash *flash,u32 offset, size_t len, const void *buf){
+
+	int ret;
+//	struct esmt_spi_flash *stm = to_esmt_spi_flash(flash);
+
+	spi_claim_bus(flash->spi);
+
+    ret = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+    return ret;
+
+}
+
+
+
+
+
+/*
+ * This function currently uses sector erase only.
+ * probably speed things up by using bulk erase
+ * when possible.
+ */
+int esmt_erase(struct spi_flash *flash, u32 offset, size_t len){
+
+	struct esmt_spi_flash *stm = to_esmt_spi_flash(flash);
+	u32 sector_size;
+	int ret;
+
+	sector_size = stm->params->sector_size;
+
+	spi_claim_bus(flash->spi);
+
+	ret = spi_flash_erase_amlogic(flash, offset, len, sector_size);
+
+	spi_release_bus(flash->spi);
+
+	return ret;
+#if 0
+	struct spi_slave * slave=flash->spi;
+	unsigned long sector_size;
+	unsigned long page_addr;
+	size_t actual;
+	int ret;
+	unsigned var;
+
+	sector_size = stm->params->sector_size;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	page_addr = offset / sector_size;
+
+	spi_claim_bus(flash->spi);
+  //	CLEAR_PERI_REG_BITS(PERIPHS_SPI_FLASH_CTRL, SPI_ENABLE_AHB);
+
+#ifdef SPI_WRITE_PROTECT
+	spi_disable_write_protect();
+#endif
+
+	for (actual = 0; actual < len; actual+=sector_size) {
+
+		debug("Erase:%x\n",actual);
+
+		var=(offset+actual) & 0xffffff;
+		spi_flash_adr_write(slave,var);
+
+		var=1<<SPI_FLASH_WREN;
+		spi_flash_cmd(slave,var,NULL,0);
+
+		var=1<<SPI_FLASH_SE;
+		spi_flash_cmd(slave,var,NULL,0);
+
+		ret=1;
+		while ( (ret&1) == 1 ) {
+
+		var=1<<SPI_FLASH_RDSR;
+		spi_flash_cmd(slave,var,&ret,2);		//2 byte status
+		}
+
+
+	}
+
+	debug("SF: ESMT: Successfully erased %u bytes @ 0x%x\n",
+			len, offset);
+	ret = 0;
+
+
+	spi_release_bus(flash->spi);
+//	SET_PERI_REG_MASK(P_SPI_FLASH_CTRL, SPI_ENABLE_AHB);
+
+
+	return ret;
+#endif
+}
+
+struct spi_flash *spi_flash_probe_esmt(struct spi_slave *spi, u8 *idcode)
+{
+	const struct esmt_spi_flash_params *params;
+	unsigned long sector_size;
+	struct esmt_spi_flash *stm;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(esmt_spi_flash_table); i++) {
+		params = &esmt_spi_flash_table[i];
+		if (params->id == ((idcode[1] << 8) | idcode[2]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(esmt_spi_flash_table)) {
+		debug("SF: Unsupported ESMT ID %02x%02x\n",
+				idcode[1], idcode[2]);
+		return NULL;
+	}
+
+	stm = malloc(sizeof(struct esmt_spi_flash));
+	if (!stm) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	stm->params = params;
+	stm->flash.spi = spi;
+	stm->flash.name = params->name;
+
+
+	stm->flash.write = esmt_write;
+	stm->flash.erase = esmt_erase;
+	stm->flash.read =  esmt_read;
+	stm->flash.size =  params->chip_size ;
+	sector_size     =  params->sector_size;
+
+	debug("SF: Detected %s with sector size %u, total %u bytes\n",
+			params->name, (unsigned int)sector_size, stm->flash.size);
+
+	return &stm->flash;
+}
diff --git a/drivers/mtd/spi/gigadevice.c b/drivers/mtd/spi/gigadevice.c
new file mode 100644
index 0000000..7359ff7
--- /dev/null
+++ b/drivers/mtd/spi/gigadevice.c
@@ -0,0 +1,135 @@
+/*
+ * (C) Copyright 2012, Amlogic Inc.
+ * Author: Haixiang Bao<haixiang.bao@amlogic.com>
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include "spi_flash_amlogic.h"
+
+struct gigadevice_spi_flash_params {
+	uint32_t	id;
+	uint32_t	sector_size;
+	uint32_t	block_size;
+	uint32_t	chip_size;
+	const char	*name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct gigadevice_spi_flash {
+	struct spi_flash flash;
+	const struct gigadevice_spi_flash_params *params;
+};
+
+static inline struct gigadevice_spi_flash *to_gigadevice_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct gigadevice_spi_flash, flash);
+}
+
+#define GIGADEVICE_ID_GD25Q16 0x4015
+#define GIGADEVICE_ID_GD25Q32 0x4016
+#define GIGADEVICE_ID_GD25Q40 0x4013
+
+static const struct gigadevice_spi_flash_params gigadevice_spi_flash_table[] = {
+	{	.id			 = GIGADEVICE_ID_GD25Q16,
+		.sector_size = 4*1024,
+		.block_size	 = 16*4*1024 ,
+		.chip_size	 = 32*16*4*1024,
+		.name		 = "GD25Q16",
+	},
+	{	.id			 = GIGADEVICE_ID_GD25Q32,
+		.sector_size = 4*1024,
+		.block_size	 = 16*4*1024 ,
+		.chip_size	 = 64*16*4*1024,
+		.name		 = "GD25Q32",
+	},
+	{	.id			 = GIGADEVICE_ID_GD25Q40,
+		.sector_size = 4*1024,
+		.block_size	 = 16*4*1024 ,
+		.chip_size	 = 8*16*4*1024,
+		.name		 = "GD25Q40",
+	},
+};
+
+static int gigadevice_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	int nReturn = 0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+static int gigadevice_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int nReturn =0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+static int gigadevice_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct gigadevice_spi_flash *stm = to_gigadevice_spi_flash(flash);
+	u32 sector_size;
+	int nReturn;
+
+	sector_size = stm->params->sector_size;
+
+	spi_claim_bus(flash->spi);
+
+	nReturn = spi_flash_erase_amlogic(flash, offset, len, sector_size);
+
+	spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+struct spi_flash *spi_flash_probe_gigadevice(struct spi_slave *spi, u8 *idcode)
+{
+	const struct gigadevice_spi_flash_params *params;
+	struct gigadevice_spi_flash *gigadevice;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(gigadevice_spi_flash_table); ++i) {
+		params = &gigadevice_spi_flash_table[i];
+		if (((idcode[1] << 8) | idcode[2]) == params->id)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(gigadevice_spi_flash_table)) {
+		debug("SF: Unsupported GIGADEVICE ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	gigadevice = malloc(sizeof(*gigadevice));
+	if (!gigadevice) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	gigadevice->params = params;
+	gigadevice->flash.spi = spi;
+	gigadevice->flash.name = params->name;
+
+	gigadevice->flash.write = gigadevice_write;
+	gigadevice->flash.erase = gigadevice_erase;
+	gigadevice->flash.read  = gigadevice_read_fast;
+
+	gigadevice->flash.size = params->chip_size;
+
+	debug("SF: Detected %s with page size %u, total %u bytes\n",
+	      params->name, params->page_size, gigadevice->flash.size);
+
+	return &gigadevice->flash;
+}
diff --git a/drivers/mtd/spi/macronix.c b/drivers/mtd/spi/macronix.c
new file mode 100644
index 0000000..f7e81c2
--- /dev/null
+++ b/drivers/mtd/spi/macronix.c
@@ -0,0 +1,369 @@
+/*
+ * Copyright 2009(C) Marvell International Ltd. and its affiliates
+ * Prafulla Wadaskar <prafulla@marvell.com>
+ *
+ * Based on drivers/mtd/spi/stmicro.c
+ *
+ * Copyright 2008, Network Appliance Inc.
+ * Jason McMullan <mcmullan@netapp.com>
+ *
+ * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+#ifdef CONFIG_AMLOGIC_SPI_FLASH
+#include "spi_flash_amlogic.h"
+#endif
+
+struct macronix_spi_flash_params{
+	u16 idcode;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 sectors_per_block;
+	u16 nr_blocks;
+	const char *name;
+};
+
+struct macronix_spi_flash
+{
+    struct spi_flash flash;
+    const struct macronix_spi_flash_params *params;
+};
+
+static inline struct macronix_spi_flash *to_macronix_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct macronix_spi_flash, flash);
+}
+
+static const struct macronix_spi_flash_params macronix_spi_flash_table[] =
+{
+	{
+		.idcode            = 0x2015,
+		.page_size         = 256,
+		.pages_per_sector  = 16,
+		.sectors_per_block = 16,
+		.nr_blocks         = 32,
+		.name = "MX25L1605D",
+	},
+	{
+		.idcode            = 0x2016,
+		.page_size         = 256,
+		.pages_per_sector  = 16,
+		.sectors_per_block = 16,
+		.nr_blocks         = 64,
+		.name = "MX25L3205D",
+	},
+	{
+		.idcode            = 0x2017,
+		.page_size         = 256,
+		.pages_per_sector  = 16,
+		.sectors_per_block = 16,
+		.nr_blocks         = 128,
+		.name = "MX25L6405D",
+	},
+	{
+		.idcode            = 0x2018,
+		.page_size         = 256,
+		.pages_per_sector  = 16,
+		.sectors_per_block = 16,
+		.nr_blocks         = 256,
+		.name = "MX25L12805D",
+	},
+	{
+		.idcode            = 0x2618,
+		.page_size         = 256,
+		.pages_per_sector  = 16,
+		.sectors_per_block = 16,
+		.nr_blocks         = 256,
+		.name = "MX25L12855E",
+	},
+};
+
+#ifdef CONFIG_AMLOGIC_SPI_FLASH //new solution for Amlogic SPI controller
+
+static int macronix_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int ret;
+    spi_claim_bus(flash->spi);
+
+    ret = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+    return  ret;
+}
+
+static int macronix_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	int ret;
+    spi_claim_bus(flash->spi);
+
+    ret = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+    return ret;
+}
+
+int macronix_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct macronix_spi_flash *stm = to_macronix_spi_flash(flash);
+	u32 sector_size;
+	int ret;
+
+	sector_size = stm->params->page_size * stm->params->pages_per_sector;
+
+	spi_claim_bus(flash->spi);
+
+	ret = spi_flash_erase_amlogic(flash, offset, len, sector_size);
+
+	spi_release_bus(flash->spi);
+
+	return ret;
+}
+#else //for version compatible, keep former version for verify
+
+static int macronix_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+	u8 cmd = CMD_MX25XX_RDSR;
+
+	ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
+	if (ret) {
+		debug("SF: Failed to send command %02x: %d\n", cmd, ret);
+		return ret;
+	}
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_xfer(spi, 8, NULL, &status, 0);
+		if (ret)
+			return -1;
+
+		if ((status & MACRONIX_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if ((status & MACRONIX_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int macronix_read_fast(struct spi_flash *flash,
+			      u32 offset, size_t len, void *buf)
+{
+	struct macronix_spi_flash *mcx = to_macronix_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = mcx->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int macronix_write(struct spi_flash *flash,
+			  u32 offset, size_t len, const void *buf)
+{
+	struct macronix_spi_flash *mcx = to_macronix_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = mcx->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_MX25XX_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_MX25XX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: Macronix Page Program failed\n");
+			break;
+		}
+
+		ret = macronix_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: Macronix page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: Macronix: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int macronix_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct macronix_spi_flash *mcx = to_macronix_spi_flash(flash);
+	unsigned long sector_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = mcx->params->page_size * mcx->params->pages_per_sector
+			* mcx->params->sectors_per_block;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	len /= sector_size;
+	cmd[0] = CMD_MX25XX_BE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual++) {
+		cmd[1] = (offset / sector_size) + actual;
+
+		ret = spi_flash_cmd(flash->spi, CMD_MX25XX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Macronix page erase failed\n");
+			break;
+		}
+
+		ret = macronix_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: Macronix page erase timed out\n");
+			break;
+		}
+	}
+
+	debug("SF: Macronix: Successfully erased %u bytes @ 0x%x\n",
+	      len * sector_size, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+#endif //CONFIG_AMLOGIC_SPI_FLASH
+
+struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode)
+{
+	const struct macronix_spi_flash_params *params;
+	struct macronix_spi_flash *mcx;
+	unsigned int i;
+	u16 id = idcode[2] | idcode[1] << 8;
+
+	for (i = 0; i < ARRAY_SIZE(macronix_spi_flash_table); i++) {
+		params = &macronix_spi_flash_table[i];
+		if (params->idcode == id)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(macronix_spi_flash_table)) {
+		debug("SF: Unsupported Macronix ID %04x\n", id);
+		return NULL;
+	}
+
+	mcx = malloc(sizeof(*mcx));
+	if (!mcx) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	mcx->params = params;
+	mcx->flash.spi = spi;
+	mcx->flash.name = params->name;
+
+	mcx->flash.write = macronix_write;
+	mcx->flash.erase = macronix_erase;
+	mcx->flash.read = macronix_read_fast;
+	mcx->flash.size = params->page_size * params->pages_per_sector
+	    * params->sectors_per_block * params->nr_blocks;
+
+	printf("SF: Detected %s with page size %u, total ",
+	       params->name, params->page_size);
+	print_size(mcx->flash.size, "\n");
+
+	return &mcx->flash;
+}
diff --git a/drivers/mtd/spi/pmdevice.c b/drivers/mtd/spi/pmdevice.c
new file mode 100644
index 0000000..de22df9
--- /dev/null
+++ b/drivers/mtd/spi/pmdevice.c
@@ -0,0 +1,122 @@
+/*
+ * (C) Copyright 2012, Amlogic Inc.
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include "spi_flash_amlogic.h"
+
+struct pmdevice_spi_flash_params {
+	uint32_t	id;
+	uint32_t	sector_size;
+	uint32_t	block_size;
+	uint32_t	chip_size;
+	const char	*name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct pmdevice_spi_flash {
+	struct spi_flash flash;
+	const struct pmdevice_spi_flash_params *params;
+};
+
+static inline struct pmdevice_spi_flash *to_pmdevice_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct pmdevice_spi_flash, flash);
+}
+
+#define PM_ID_PM25LQ032C 0x9d46
+
+static const struct pmdevice_spi_flash_params pmdevice_spi_flash_table[] = {
+	{	.id			 = PM_ID_PM25LQ032C,
+		.sector_size = 4*1024,
+		.block_size	 = 16*4*1024 ,
+		.chip_size	 = 4*1024*1024,
+		.name		 = "PM25LQ032C",
+	},
+};
+
+static int pmdevice_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	int nReturn = 0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+static int pmdevice_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int nReturn =0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+static int pmdevice_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct pmdevice_spi_flash *stm = to_pmdevice_spi_flash(flash);
+	u32 sector_size;
+	int nReturn;
+
+	sector_size = stm->params->sector_size;
+
+	spi_claim_bus(flash->spi);
+
+	nReturn = spi_flash_erase_amlogic(flash, offset, len, sector_size);
+
+	spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+struct spi_flash *spi_flash_probe_pmdevice(struct spi_slave *spi, u8 *idcode)
+{
+	const struct pmdevice_spi_flash_params *params;
+	struct pmdevice_spi_flash *pmdevice;
+	unsigned int i;
+
+          printf("spi_flash_probe_pmdevice %02x %02x %02x\n", idcode[0], idcode[1], idcode[2]);
+	for (i = 0; i < ARRAY_SIZE(pmdevice_spi_flash_table); ++i) {
+		params = &pmdevice_spi_flash_table[i];
+		if (((idcode[1] << 8) | idcode[2]) == params->id)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(pmdevice_spi_flash_table)) {
+		debug("SF: Unsupported pmdevice ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	pmdevice = malloc(sizeof(*pmdevice));
+	if (!pmdevice) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	pmdevice->params = params;
+	pmdevice->flash.spi = spi;
+	pmdevice->flash.name = params->name;
+
+	pmdevice->flash.write = pmdevice_write;
+	pmdevice->flash.erase = pmdevice_erase;
+	pmdevice->flash.read  = pmdevice_read_fast;
+
+	pmdevice->flash.size = params->chip_size;
+
+	debug("SF: Detected %s with page size %u, total %u bytes\n",
+	      params->name, params->page_size, pmdevice->flash.size);
+
+	return &pmdevice->flash;
+}
+
diff --git a/drivers/mtd/spi/ramtron.c b/drivers/mtd/spi/ramtron.c
new file mode 100644
index 0000000..62ae9ab
--- /dev/null
+++ b/drivers/mtd/spi/ramtron.c
@@ -0,0 +1,320 @@
+/*
+ * (C) Copyright 2010
+ * Reinhard Meyer, EMK Elektronik, reinhard.meyer@emk-elektronik.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Note: RAMTRON SPI FRAMs are ferroelectric, nonvolatile RAMs
+ * with an interface identical to SPI flash devices.
+ * However since they behave like RAM there are no delays or
+ * busy polls required. They can sustain read or write at the
+ * allowed SPI bus speed, which can be 40 MHz for some devices.
+ *
+ * Unfortunately some RAMTRON devices do not have a means of
+ * identifying them. They will leave the SO line undriven when
+ * the READ-ID command is issued. It is therefore mandatory
+ * that the MISO line has a proper pull-up, so that READ-ID
+ * will return a row of 0xff. This 0xff pseudo-id will cause
+ * probes by all vendor specific functions that are designed
+ * to handle it. If the MISO line is not pulled up, READ-ID
+ * could return any random noise, even mimicking another
+ * device.
+ *
+ * We use CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
+ * to define which device will be assumed after a simple status
+ * register verify. This method is prone to false positive
+ * detection and should therefore be the last to be tried.
+ * Enter it in the last position in the table in spi_flash.c!
+ *
+ * The define CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC both activates
+ * compilation of the special handler and defines the device
+ * to assume.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include "spi_flash_amlogic.h"
+#include "spi_flash_internal.h"
+
+/* RAMTRON commands common to all devices */
+#define CMD_RAMTRON_WREN	0x06	/* Write Enable */
+#define CMD_RAMTRON_WRDI	0x04	/* Write Disable */
+#define CMD_RAMTRON_RDSR	0x05	/* Read Status Register */
+#define CMD_RAMTRON_WRSR	0x01	/* Write Status Register */
+#define CMD_RAMTRON_READ	0x03	/* Read Data Bytes */
+#define CMD_RAMTRON_WRITE	0x02	/* Write Data Bytes */
+/* not all have those: */
+#define CMD_RAMTRON_FSTRD	0x0b	/* Fast Read (for compatibility - not used here) */
+#define CMD_RAMTRON_SLEEP	0xb9	/* Enter Sleep Mode */
+#define CMD_RAMTRON_RDID	0x9f	/* Read ID */
+#define CMD_RAMTRON_SNR		0xc3	/* Read Serial Number */
+
+/*
+ * Properties of supported FRAMs
+ * Note: speed is currently not used because we have no method to deliver that
+ * value to the upper layers
+ */
+struct ramtron_spi_fram_params {
+	u32	size;		/* size in bytes */
+	u8	addr_len;	/* number of address bytes */
+	u8	merge_cmd;	/* some address bits are in the command byte */
+	u8	id1;		/* device ID 1 (family, density) */
+	u8	id2;		/* device ID 2 (sub, rev, rsvd) */
+	u32	speed;		/* max. SPI clock in Hz */
+	const char *name;	/* name for display and/or matching */
+};
+
+struct ramtron_spi_fram {
+	struct spi_flash flash;
+	const struct ramtron_spi_fram_params *params;
+};
+
+static inline struct ramtron_spi_fram *to_ramtron_spi_fram(struct spi_flash
+							     *flash)
+{
+	return container_of(flash, struct ramtron_spi_fram, flash);
+}
+
+/*
+ * table describing supported FRAM chips:
+ * chips without RDID command must have the values 0xff for id1 and id2
+ */
+static const struct ramtron_spi_fram_params ramtron_spi_fram_table[] = {
+	{
+		.size = 32*1024,
+		.addr_len = 2,
+		.merge_cmd = 0,
+		.id1 = 0x22,
+		.id2 = 0x00,
+		.speed = 40000000,
+		.name = "FM25V02",
+	},
+	{
+		.size = 32*1024,
+		.addr_len = 2,
+		.merge_cmd = 0,
+		.id1 = 0x22,
+		.id2 = 0x01,
+		.speed = 40000000,
+		.name = "FM25VN02",
+	},
+	{
+		.size = 64*1024,
+		.addr_len = 2,
+		.merge_cmd = 0,
+		.id1 = 0x23,
+		.id2 = 0x00,
+		.speed = 40000000,
+		.name = "FM25V05",
+	},
+	{
+		.size = 64*1024,
+		.addr_len = 2,
+		.merge_cmd = 0,
+		.id1 = 0x23,
+		.id2 = 0x01,
+		.speed = 40000000,
+		.name = "FM25VN05",
+	},
+	{
+		.size = 128*1024,
+		.addr_len = 3,
+		.merge_cmd = 0,
+		.id1 = 0x24,
+		.id2 = 0x00,
+		.speed = 40000000,
+		.name = "FM25V10",
+	},
+	{
+		.size = 128*1024,
+		.addr_len = 3,
+		.merge_cmd = 0,
+		.id1 = 0x24,
+		.id2 = 0x01,
+		.speed = 40000000,
+		.name = "FM25VN10",
+	},
+#ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
+	{
+		.size = 256*1024,
+		.addr_len = 3,
+		.merge_cmd = 0,
+		.id1 = 0xff,
+		.id2 = 0xff,
+		.speed = 40000000,
+		.name = "FM25H20",
+	},
+#endif
+};
+
+static int ramtron_common(struct spi_flash *flash,
+		u32 offset, size_t len, void *buf, u8 command)
+{
+	struct ramtron_spi_fram *sn = to_ramtron_spi_fram(flash);
+	u8 cmd[4];
+	int cmd_len;
+	int ret;
+
+	if (sn->params->addr_len == 3 && sn->params->merge_cmd == 0) {
+		cmd[0] = command;
+		cmd[1] = offset >> 16;
+		cmd[2] = offset >> 8;
+		cmd[3] = offset;
+		cmd_len = 4;
+	} else if (sn->params->addr_len == 2 && sn->params->merge_cmd == 0) {
+		cmd[0] = command;
+		cmd[1] = offset >> 8;
+		cmd[2] = offset;
+		cmd_len = 3;
+	} else {
+		printf("SF: unsupported addr_len or merge_cmd\n");
+		return -1;
+	}
+
+	/* claim the bus */
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	if (command == CMD_RAMTRON_WRITE) {
+		/* send WREN */
+		ret = spi_flash_cmd(flash->spi, CMD_RAMTRON_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			goto releasebus;
+		}
+	}
+
+	/* do the transaction */
+	if (command == CMD_RAMTRON_WRITE)
+		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len, buf, len);
+	else
+		ret = spi_flash_cmd_read(flash->spi, cmd, cmd_len, buf, len);
+	if (ret < 0)
+		debug("SF: Transaction failed\n");
+
+releasebus:
+	/* release the bus */
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+static int ramtron_read(struct spi_flash *flash,
+		u32 offset, size_t len, void *buf)
+{
+	return ramtron_common(flash, offset, len, buf,
+		CMD_RAMTRON_READ);
+}
+
+static int ramtron_write(struct spi_flash *flash,
+		u32 offset, size_t len, const void *buf)
+{
+	return ramtron_common(flash, offset, len, (void *)buf,
+		CMD_RAMTRON_WRITE);
+}
+
+int ramtron_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	debug("SF: Erase of RAMTRON FRAMs is pointless\n");
+	return -1;
+}
+
+/*
+ * nore: we are called here with idcode pointing to the first non-0x7f byte
+ * already!
+ */
+struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
+{
+	const struct ramtron_spi_fram_params *params;
+	struct ramtron_spi_fram *sn;
+	unsigned int i;
+#ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
+	int ret;
+	u8 sr;
+#endif
+
+	/* NOTE: the bus has been claimed before this function is called! */
+	switch (idcode[0]) {
+	case 0xc2:
+		/* JEDEC conformant RAMTRON id */
+		for (i = 0; i < ARRAY_SIZE(ramtron_spi_fram_table); i++) {
+			params = &ramtron_spi_fram_table[i];
+			if (idcode[1] == params->id1 && idcode[2] == params->id2)
+				goto found;
+		}
+		break;
+#ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
+	case 0xff:
+		/*
+		 * probably open MISO line, pulled up.
+		 * We COULD have a non JEDEC conformant FRAM here,
+		 * read the status register to verify
+		 */
+		ret = spi_flash_cmd(spi, CMD_RAMTRON_RDSR, &sr, 1);
+		if (ret)
+			return NULL;
+
+		/* Bits 5,4,0 are fixed 0 for all devices */
+		if ((sr & 0x31) != 0x00)
+			return NULL;
+		/* now find the device */
+		for (i = 0; i < ARRAY_SIZE(ramtron_spi_fram_table); i++) {
+			params = &ramtron_spi_fram_table[i];
+			if (!strcmp(params->name, CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC))
+				goto found;
+		}
+		debug("SF: Unsupported non-JEDEC RAMTRON device "
+			CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC "\n");
+		break;
+#endif
+	default:
+		break;
+	}
+
+	/* arriving here means no method has found a device we can handle */
+	debug("SF/ramtron: unsupported device id0=%02x id1=%02x id2=%02x\n",
+		idcode[0], idcode[1], idcode[2]);
+	return NULL;
+
+found:
+	sn = malloc(sizeof(*sn));
+	if (!sn) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	sn->params = params;
+	sn->flash.spi = spi;
+	sn->flash.name = params->name;
+
+	sn->flash.write = ramtron_write;
+	sn->flash.read = ramtron_read;
+	sn->flash.erase = ramtron_erase;
+	sn->flash.size = params->size;
+
+	printf("SF: Detected %s with size ", params->name);
+	print_size(sn->flash.size, "\n");
+
+	return &sn->flash;
+}
diff --git a/drivers/mtd/spi/spansion.c b/drivers/mtd/spi/spansion.c
new file mode 100644
index 0000000..21df98e
--- /dev/null
+++ b/drivers/mtd/spi/spansion.c
@@ -0,0 +1,451 @@
+/*
+ * Copyright (C) 2009 Freescale Semiconductor, Inc.
+ *
+ * Author: Mingkai Hu (Mingkai.hu@freescale.com)
+ * Based on stmicro.c by Wolfgang Denk (wd@denx.de),
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com),
+ * and  Jason McMullan (mcmullan@netapp.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+
+#include "spi_flash_internal.h"
+
+/* S25FLxx-specific commands */
+#define CMD_S25FLXX_READ	0x03	/* Read Data Bytes */
+#define CMD_S25FLXX_FAST_READ	0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_S25FLXX_READID	0x90	/* Read Manufacture ID and Device ID */
+#define CMD_S25FLXX_WREN	0x06	/* Write Enable */
+#define CMD_S25FLXX_WRDI	0x04	/* Write Disable */
+#define CMD_S25FLXX_RDSR	0x05	/* Read Status Register */
+#define CMD_S25FLXX_WRSR	0x01	/* Write Status Register */
+#define CMD_S25FLXX_PP		0x02	/* Page Program */
+#define CMD_S25FLXX_SE		0xd8	/* Sector Erase */
+#define CMD_S25FLXX_BE		0xc7	/* Bulk Erase */
+#define CMD_S25FLXX_DP		0xb9	/* Deep Power-down */
+#define CMD_S25FLXX_RES		0xab	/* Release from DP, and Read Signature */
+
+#define SPSN_ID_S25FL008A	0x0213
+#define SPSN_ID_S25FL016A	0x0214
+#define SPSN_ID_S25FL032A	0x0215
+#define SPSN_ID_S25FL064A	0x0216
+#define SPSN_ID_S25FL128P	0x2018
+#define SPSN_EXT_ID_S25FL128P_256KB	0x0300
+#define SPSN_EXT_ID_S25FL128P_64KB	0x0301
+#define SPSN_EXT_ID_S25FL032P		0x4d00
+
+#define SPANSION_SR_WIP		(1 << 0)	/* Write-in-Progress */
+
+struct spansion_spi_flash_params {
+	u16 idcode1;
+	u16 idcode2;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 nr_sectors;
+	const char *name;
+};
+
+#else /*else CONFIG_AMLOGIC_SPI_FLASH*/
+
+#include "spi_flash_amlogic.h"
+
+struct spansion_spi_flash_params {
+	uint32_t	id;
+	uint32_t	sector_size;
+	uint32_t	block_size;
+	uint32_t	chip_size;
+	const char	*name;
+};
+
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+struct spansion_spi_flash {
+	struct spi_flash flash;
+	const struct spansion_spi_flash_params *params;
+};
+
+static inline struct spansion_spi_flash *to_spansion_spi_flash(struct spi_flash
+							     *flash)
+{
+	return container_of(flash, struct spansion_spi_flash, flash);
+}
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+
+static const struct spansion_spi_flash_params spansion_spi_flash_table[] = {
+	{
+		.idcode1 = SPSN_ID_S25FL008A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 16,
+		.name = "S25FL008A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL016A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 32,
+		.name = "S25FL016A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL032A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 64,
+		.name = "S25FL032A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL064A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 128,
+		.name = "S25FL064A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL128P,
+		.idcode2 = SPSN_EXT_ID_S25FL128P_64KB,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 256,
+		.name = "S25FL128P_64K",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL128P,
+		.idcode2 = SPSN_EXT_ID_S25FL128P_256KB,
+		.page_size = 256,
+		.pages_per_sector = 1024,
+		.nr_sectors = 64,
+		.name = "S25FL128P_256K",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL032A,
+		.idcode2 = SPSN_EXT_ID_S25FL032P,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 64,
+		.name = "S25FL032P",
+	},
+};
+
+#else /*else CONFIG_AMLOGIC_SPI_FLASH*/
+
+#define SPSN_ID_S25FL008A	0x0213
+#define SPSN_ID_S25FL016A	0x0214
+#define SPSN_ID_S25FL032A	0x0215
+#define SPSN_ID_S25FL064A	0x0216
+#define SPSN_ID_S25FL128P	0x2018
+#define SPSN_EXT_ID_S25FL128P_256KB	0x0300
+#define SPSN_EXT_ID_S25FL128P_64KB	0x0301
+#define SPSN_EXT_ID_S25FL032P		0x4d00
+
+static const struct spansion_spi_flash_params spansion_spi_flash_table[] = {
+	{	.id			 = SPSN_ID_S25FL032A,
+		.sector_size = 64*1024,
+		.block_size	 = 64*1024 ,
+		.chip_size	 = 64*64*1024,
+		.name		 = "S25FL032A",
+	},
+};
+//new solution for Amlogic SPI controller
+//
+//
+static int spansion_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	int nReturn = 0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+static int spansion_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int nReturn =0;
+
+	spi_claim_bus(flash->spi);
+
+	//dummy read for env load fail ??
+    nReturn = spi_flash_read_amlogic(flash, offset, len,buf);
+	nReturn = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+static int spansion_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct spansion_spi_flash *stm = to_spansion_spi_flash(flash);
+	u32 sector_size;
+	int nReturn;
+
+	sector_size = stm->params->sector_size;
+
+	spi_claim_bus(flash->spi);
+	nReturn = spi_flash_erase_be_amlogic(flash, offset, len, sector_size);
+
+	spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+
+static int spansion_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_flash_cmd(spi, CMD_S25FLXX_RDSR, &status, sizeof(status));
+		if (ret)
+			return -1;
+
+		if ((status & SPANSION_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+
+	if ((status & SPANSION_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int spansion_read_fast(struct spi_flash *flash,
+			     u32 offset, size_t len, void *buf)
+{
+	struct spansion_spi_flash *spsn = to_spansion_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = spsn->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	debug
+		("READ: 0x%x => cmd = { 0x%02x 0x%02x%02x%02x%02x } len = 0x%x\n",
+		 offset, cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], len);
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int spansion_write(struct spi_flash *flash,
+			 u32 offset, size_t len, const void *buf)
+{
+	struct spansion_spi_flash *spsn = to_spansion_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = spsn->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_S25FLXX_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_S25FLXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: SPANSION Page Program failed\n");
+			break;
+		}
+
+		ret = spansion_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: SPANSION page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: SPANSION: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int spansion_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct spansion_spi_flash *spsn = to_spansion_spi_flash(flash);
+	unsigned long sector_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = spsn->params->page_size * spsn->params->pages_per_sector;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	cmd[0] = CMD_S25FLXX_SE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += sector_size) {
+		cmd[1] = (offset + actual) >> 16;
+
+		ret = spi_flash_cmd(flash->spi, CMD_S25FLXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: SPANSION page erase failed\n");
+			break;
+		}
+
+		/* Up to 2 seconds */
+		ret = spansion_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: SPANSION page erase timed out\n");
+			break;
+		}
+	}
+
+	debug("SF: SPANSION: Successfully erased %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+
+struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode)
+{
+	const struct spansion_spi_flash_params *params;
+	struct spansion_spi_flash *spsn;
+	unsigned int i;
+	unsigned short jedec, ext_jedec;
+
+	jedec = idcode[1] << 8 | idcode[2];
+	ext_jedec = idcode[3] << 8 | idcode[4];
+
+	for (i = 0; i < ARRAY_SIZE(spansion_spi_flash_table); i++) {
+		params = &spansion_spi_flash_table[i];
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+		if (params->idcode1 == idcode[2])
+			break;
+#else
+		if (((idcode[1] << 8) | idcode[2]) == params->id)
+			break;
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+	}
+
+	if (i == ARRAY_SIZE(spansion_spi_flash_table)) {
+		debug("SF: Unsupported SPANSION ID %04x %04x\n", jedec, ext_jedec);
+		return NULL;
+	}
+
+	spsn = malloc(sizeof(struct spansion_spi_flash));
+	if (!spsn) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	spsn->params = params;
+	spsn->flash.spi = spi;
+	spsn->flash.name = params->name;
+
+	spsn->flash.write = spansion_write;
+	spsn->flash.erase = spansion_erase;
+	spsn->flash.read = spansion_read_fast;
+
+#ifndef CONFIG_AMLOGIC_SPI_FLASH
+	spsn->flash.size = params->page_size * params->pages_per_sector
+	    * params->nr_sectors;
+#else
+	spsn->flash.size = params->chip_size;
+#endif /*CONFIG_AMLOGIC_SPI_FLASH*/
+
+	return &spsn->flash;
+}
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
new file mode 100644
index 0000000..b61d219
--- /dev/null
+++ b/drivers/mtd/spi/spi_flash.c
@@ -0,0 +1,233 @@
+/*
+ * SPI flash interface
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ * Copyright (C) 2010 Reinhard Meyer, EMK Elektronik
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <spi_flash.h>
+
+#include "spi_flash_internal.h"
+
+int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+
+	if (len == 0)
+		flags |= SPI_XFER_END;
+
+	ret = spi_xfer(spi, 8, &cmd, NULL, flags);
+	if (ret) {
+		debug("SF: Failed to send command %02x: %d\n", cmd, ret);
+		return ret;
+	}
+
+	if (len) {
+		ret = spi_xfer(spi, len * 8, NULL, response, SPI_XFER_END);
+		if (ret)
+			debug("SF: Failed to read response (%zu bytes): %d\n",
+					len, ret);
+	}
+
+	return ret;
+}
+
+int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+
+	if (data_len == 0)
+		flags |= SPI_XFER_END;
+
+	ret = spi_xfer(spi, cmd_len * 8, cmd, NULL, flags);
+	if (ret) {
+		debug("SF: Failed to send read command (%zu bytes): %d\n",
+				cmd_len, ret);
+	} else if (data_len != 0) {
+		ret = spi_xfer(spi, data_len * 8, NULL, data, SPI_XFER_END);
+		if (ret)
+			debug("SF: Failed to read %zu bytes of data: %d\n",
+					data_len, ret);
+	}
+
+	return ret;
+}
+
+int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
+		const void *data, size_t data_len)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+
+	if (data_len == 0)
+		flags |= SPI_XFER_END;
+
+	ret = spi_xfer(spi, cmd_len * 8, cmd, NULL, flags);
+	if (ret) {
+		debug("SF: Failed to send read command (%zu bytes): %d\n",
+				cmd_len, ret);
+	} else if (data_len != 0) {
+		ret = spi_xfer(spi, data_len * 8, data, NULL, SPI_XFER_END);
+		if (ret)
+			debug("SF: Failed to read %zu bytes of data: %d\n",
+					data_len, ret);
+	}
+
+	return ret;
+}
+
+
+int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len)
+{
+	struct spi_slave *spi = flash->spi;
+	int ret;
+
+	spi_claim_bus(spi);
+	ret = spi_flash_cmd_read(spi, cmd, cmd_len, data, data_len);
+	spi_release_bus(spi);
+
+	return ret;
+}
+
+/*
+ * The following table holds all device probe functions
+ *
+ * shift:  number of continuation bytes before the ID
+ * idcode: the expected IDCODE or 0xff for non JEDEC devices
+ * probe:  the function to call
+ *
+ * Non JEDEC devices should be ordered in the table such that
+ * the probe functions with best detection algorithms come first.
+ *
+ * Several matching entries are permitted, they will be tried
+ * in sequence until a probe function returns non NULL.
+ *
+ * IDCODE_CONT_LEN may be redefined if a device needs to declare a
+ * larger "shift" value.  IDCODE_PART_LEN generally shouldn't be
+ * changed.  This is the max number of bytes probe functions may
+ * examine when looking up part-specific identification info.
+ *
+ * Probe functions will be given the idcode buffer starting at their
+ * manu id byte (the "idcode" in the table below).  In other words,
+ * all of the continuation bytes will be skipped (the "shift" below).
+ */
+#define IDCODE_CONT_LEN 0
+#define IDCODE_PART_LEN 5
+static const struct {
+	const u8 shift;
+	const u8 idcode;
+	struct spi_flash *(*probe) (struct spi_slave *spi, u8 *idcode);
+} flashes[] = {
+	/* Keep it sorted by define name */
+#ifdef CONFIG_SPI_FLASH_ATMEL
+	{ 0, 0x1f, spi_flash_probe_atmel, },
+#endif
+#ifdef CONFIG_SPI_FLASH_EON
+	{ 0, 0x1c, spi_flash_probe_eon, },
+#endif
+#ifdef CONFIG_SPI_FLASH_MACRONIX
+	{ 0, 0xc2, spi_flash_probe_macronix, },
+#endif
+#ifdef CONFIG_SPI_FLASH_SPANSION
+	{ 0, 0x01, spi_flash_probe_spansion, },
+#endif
+#ifdef CONFIG_SPI_FLASH_SST
+	{ 0, 0xbf, spi_flash_probe_sst, },
+#endif
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	{ 0, 0x20, spi_flash_probe_stmicro, },
+#endif
+#ifdef CONFIG_SPI_FLASH_WINBOND
+	{ 0, 0xef, spi_flash_probe_winbond, },
+#endif
+#ifdef CONFIG_SPI_FRAM_RAMTRON
+	{ 6, 0xc2, spi_fram_probe_ramtron, },
+# undef IDCODE_CONT_LEN
+# define IDCODE_CONT_LEN 6
+#endif
+	/* Keep it sorted by best detection */
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	{ 0, 0xff, spi_flash_probe_stmicro, },
+#endif
+#ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
+	{ 0, 0xff, spi_fram_probe_ramtron, },
+#endif
+};
+#define IDCODE_LEN (IDCODE_CONT_LEN + IDCODE_PART_LEN)
+
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode)
+{
+	struct spi_slave *spi;
+	struct spi_flash *flash = NULL;
+	int ret, i, shift;
+	u8 idcode[IDCODE_LEN], *idp;
+
+	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
+	if (!spi) {
+		printf("SF: Failed to set up slave\n");
+		return NULL;
+	}
+
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("SF: Failed to claim SPI bus: %d\n", ret);
+		goto err_claim_bus;
+	}
+
+	/* Read the ID codes */
+	ret = spi_flash_cmd(spi, CMD_READ_ID, idcode, sizeof(idcode));
+	if (ret)
+		goto err_read_id;
+
+#ifdef DEBUG
+	printf("SF: Got idcodes\n");
+	print_buffer(0, idcode, 1, sizeof(idcode), 0);
+#endif
+
+	/* count the number of continuation bytes */
+	for (shift = 0, idp = idcode;
+	     shift < IDCODE_CONT_LEN && *idp == 0x7f;
+	     ++shift, ++idp)
+		continue;
+
+	/* search the table for matches in shift and id */
+	for (i = 0; i < ARRAY_SIZE(flashes); ++i)
+		if (flashes[i].shift == shift && flashes[i].idcode == *idp) {
+			/* we have a match, call probe */
+			flash = flashes[i].probe(spi, idp);
+			if (flash)
+				break;
+		}
+
+	if (!flash) {
+		printf("SF: Unsupported manufacturer %02x\n", *idp);
+		goto err_manufacturer_probe;
+	}
+
+	spi_release_bus(spi);
+
+	return flash;
+
+err_manufacturer_probe:
+err_read_id:
+	spi_release_bus(spi);
+err_claim_bus:
+	spi_free_slave(spi);
+	return NULL;
+}
+
+void spi_flash_free(struct spi_flash *flash)
+{
+	spi_free_slave(flash->spi);
+	free(flash);
+}
diff --git a/drivers/mtd/spi/spi_flash_amlogic.c b/drivers/mtd/spi/spi_flash_amlogic.c
new file mode 100644
index 0000000..75cf22b
--- /dev/null
+++ b/drivers/mtd/spi/spi_flash_amlogic.c
@@ -0,0 +1,795 @@
+/*
+ * Amlogic SPI flash interface
+ *
+ * Copyright (C) 2011 Amlogic Corporation
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ *
+ * Dedicated for Amlogic SPI controller use
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/cache.h>
+#include "spi_flash_amlogic.h"
+
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+#include "spi_secure_storage.h"
+#endif
+/*note: To use Amlogic SPI flash controller for SPI flash access
+         two macro CONFIG_CMD_SF & CONFIG_AML_MESON_1/2/3
+         must be set to 1
+         header file locate at:  \board\amlogic\configs\
+
+backup PIN_MAX_1 value before claim bus for SPI controller
+restore the original value after usage
+note: following two functions for one SPI operation
+      void spi_release_bus(struct spi_slave *slave)
+      int spi_claim_bus(struct spi_slave *slave)
+
+static u32 g_u32_PERIPHS_PIN_MUX_1_backup = 0;
+*/
+
+int spi_flash_cmd(struct spi_slave *spi, u32 cmd, void *response, size_t len)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+	u32 var=cmd;
+
+	if (len == 0)
+		flags |= SPI_XFER_END;
+
+	flags|=SPI_XFER_CMD;
+
+	ret = spi_xfer(spi, 4*8, (u8*)&var, NULL, flags);
+
+	if (ret) {
+		debug("SF: Failed to send command %02x: %d\n", cmd, ret);
+		return ret;
+	}
+
+	if (len) {
+		if ((1<<SPI_FLASH_RDID) == cmd) {
+			flags=SPI_XFER_ID;
+		}
+		else{
+			if ((1<<SPI_FLASH_RDSR) == cmd) {
+				flags=SPI_XFER_STATUS;
+			}
+		}
+
+		ret = spi_xfer(spi, len * 8, NULL, response, flags|SPI_XFER_END);
+
+		if (ret) {
+			debug("SF: Failed to read response (%zu bytes): %d\n",
+					len, ret);
+		}
+	}
+	return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////
+//
+// implementation of header file <project>\include\spi.h
+//
+//
+struct aml_spi_slave {
+	struct spi_slave slave;
+	void * adr_base;
+	u32    mode;
+	u32    ctl;
+};
+
+static inline struct aml_spi_slave *to_aml_spi(struct spi_slave *slave){
+	return container_of(slave, struct aml_spi_slave, slave);
+}
+
+__attribute__((weak)) int spi_cs_is_valid(unsigned int bus, unsigned int cs){return 0;}
+
+__attribute__((weak)) void spi_cs_activate(struct spi_slave *slave) {}
+
+__attribute__((weak)) void spi_cs_deactivate(struct spi_slave *slave){}
+
+static void spi_initialize(void){
+	writel(0xea949,P_SPI_FLASH_CTRL); //SPI clock-> system clock / 10
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+			unsigned int max_hz, unsigned int mode)
+{
+	struct aml_spi_slave * amls;
+	amls = ( struct aml_spi_slave *)malloc(sizeof(struct aml_spi_slave));
+	if (!amls)
+		return NULL;
+
+	spi_initialize();
+
+	amls->slave.bus = bus;
+	amls->slave.cs 	= cs;
+
+	amls->adr_base 	=(void*)0xCC000000;
+
+	amls->mode=mode;
+
+	return &amls->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct aml_spi_slave *amls = to_aml_spi(slave);
+	free(amls);
+}
+
+int spi_check_write_protect(void)
+{
+    writel(1<<SPI_FLASH_RDSR, P_SPI_FLASH_CMD);
+
+    while (readl(P_SPI_FLASH_CMD) != 0) ;
+
+    return (readl(P_SPI_FLASH_STATUS)&(0xf<<2)) == (0xf<<2)?1:0;
+}
+
+void spi_enable_write_protect(void)
+{
+    unsigned char statusValue;
+    int ret;
+
+    statusValue = 0xf<<2;//all protect;
+
+	/*write enable*/
+    writel(1<<SPI_FLASH_WREN, P_SPI_FLASH_CMD);
+    while (readl(P_SPI_FLASH_CMD) != 0) {
+		do {
+			writel(1<<SPI_FLASH_RDSR, P_SPI_FLASH_CMD);
+			while (readl(P_SPI_FLASH_CMD) != 0) ;
+			ret = readl(P_SPI_FLASH_STATUS);
+		}while (ret&1);
+    }
+
+    /*write status register*/
+    writel(statusValue,P_SPI_FLASH_STATUS);
+    writel(1<<SPI_FLASH_WRSR, P_SPI_FLASH_CMD);
+    while (readl(P_SPI_FLASH_CMD) != 0) {
+		do {
+			writel(1<<SPI_FLASH_RDSR, P_SPI_FLASH_CMD);
+			while (readl(P_SPI_FLASH_CMD) != 0) ;
+			ret = readl(P_SPI_FLASH_STATUS);
+		}while (ret&1);
+    }
+}
+
+void spi_disable_write_protect(void)
+{
+    unsigned char statusValue;
+    int ret, var;
+
+    statusValue = 0;
+
+    /*write enable*/
+    var = 1 << SPI_FLASH_WREN;
+    writel(var, P_SPI_FLASH_CMD);
+    while (readl(P_SPI_FLASH_CMD) != 0) ;
+    ret=1;
+    while ((ret&1) == 1) {
+        var=1<<SPI_FLASH_RDSR;
+        writel(var, P_SPI_FLASH_CMD);
+        while (readl(P_SPI_FLASH_CMD) != 0) ;
+        ret = readl(P_SPI_FLASH_STATUS)&0xff;
+    }
+
+    /*write status register*/
+    writel(statusValue,P_SPI_FLASH_STATUS);
+    var = 1<<SPI_FLASH_WRSR;
+    writel(var, P_SPI_FLASH_CMD);
+    while (readl(P_SPI_FLASH_CMD) != 0) ;
+
+    ret=1;
+    while ( (ret&1) == 1 ) {
+        var=1<<SPI_FLASH_RDSR;
+        writel(var, P_SPI_FLASH_CMD);
+        while (readl(P_SPI_FLASH_CMD) != 0) ;
+        ret = readl(P_SPI_FLASH_STATUS)&0xff;
+    }
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	debug("%s: bus:%i cs:%i\n", __func__, slave->bus, slave->cs);
+	clrbits_le32(P_PERIPHS_PIN_MUX_4,(1<<20)|(7<<22)|(1<<31));
+	setbits_le32(P_PERIPHS_PIN_MUX_5,((1<<0) | (1<<1) | (1<<2) | (1<<3)));
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	debug("%s: bus:%i cs:%i\n", __func__, slave->bus, slave->cs);
+
+	clrbits_le32(P_PERIPHS_PIN_MUX_5,((1<<0)|(1<<1)|(1<<2)|(1<<3)));
+}
+
+//Only for Amlogic SPI controller
+//note flag for cmd adr status data trans
+//bitlen is byte*8
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+			const void *dout, void *din, unsigned long flags)
+{
+	struct aml_spi_slave *as = to_aml_spi(slave);
+	u32 len;
+	u32 temp_len;
+	u8  temp_data[4];
+	u8  *buf = temp_data;
+	const u8 *txp = (u8 *)dout;
+	u8		 *rxp = (u8 *)din;
+	u32		 value;
+	int i,j;
+	volatile unsigned int * c0;
+
+	if (bitlen == 0)/* Finish any previously submitted transfers */
+		goto out;
+
+	if (bitlen % 8) {/* Errors always terminate an ongoing transfer*/
+		flags |= SPI_XFER_END;
+		goto out;
+	}
+
+	len = bitlen / 8; //convert to BYTE counter
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	//Set Address register of SPI controller
+	if (flags&SPI_XFER_ADR) {
+		writel(*((u32*)txp), P_SPI_FLASH_ADDR);
+		goto out;
+	}
+
+	//Send command to device through SPI FLASH command register
+	if (flags&SPI_XFER_CMD) {
+
+		if (*((u32*)dout) == (1<<SPI_FLASH_RDID)) {
+			/*only for RDID, clear the cache for a fresh load*/
+			writel(0, P_SPI_FLASH_C0);
+		}
+		writel(*((u32*)txp), P_SPI_FLASH_CMD);
+		while (readl(P_SPI_FLASH_CMD) != 0) ;
+		goto out;
+	}
+
+	//Write data to SPI data cache for transfer
+	//Then SPI controller will transfer them to SPI device with WREN(Writer enable) & PP(Page program)
+	if ((txp) && (flags&SPI_XFER_WRITECACHE)) {
+		c0 = P_SPI_FLASH_C0;
+		for ( j=0;j<len;j+=4) {
+			value = *(u32*)(txp+j);
+			writel(value, c0++);
+			//printf("buf%d:0x%x\n", j, value);
+		}
+		goto out;
+	}
+
+	//for input to host
+	//following code will use rxp
+	if (!rxp)
+		goto out;
+
+	//Read status register
+	if (flags&SPI_XFER_STATUS) {	/*FIXME WRSTAUS	*/
+
+		value=readl(P_SPI_FLASH_STATUS)&0xffff;
+		*rxp=value&0xff;
+		*(rxp+1)=(value>>8)&0xff;
+		goto out;
+	}
+
+	//Read vender & chip ID
+	if (flags&SPI_XFER_ID) {		/*FIXME EON*/
+
+		value=readl(P_SPI_FLASH_C0)&0xffffff;
+		*rxp=value&0xff;
+		*(rxp+1)=(value>>8)&0xff;
+		*(rxp+2)=(value>>16)&0xff;
+		goto out;
+	}
+
+	//Load data from cache, SPI controller will auto send read read flash command and store data to address as->adr_base
+	if (flags&SPI_XFER_COPY) {
+		setbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB); /*for AHB data bus request*/
+		memcpy((unsigned char *)(rxp),(unsigned char *)((as->adr_base)+(*(u32*)txp)),bitlen/8);
+		clrbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB); /*release AHB bus*/
+		//printf("Hisun: XFER_COPY -> 0x%08X Bytes from 0x%08X to 0x%08X\n",bitlen/8,((as->adr_base)+(*(u32*)txp)),(rxp));
+		goto out;
+	}
+
+	//Load from SPI controller data cache
+	if (flags&SPI_XFER_READCACHE) {
+		temp_len = len/4;
+		c0 = P_SPI_FLASH_C0;
+		for ( i=0;i<temp_len*4;i+=4) {
+			value = readl(c0++);
+			*(u32 *)(rxp+i) = value;
+			//printf("val[%d]=0x%8x\n", i, value);
+		}
+		if (len%4) {
+			temp_len = len%4;
+			*(u32 *)buf = readl(c0++);
+			for (j=0;j<temp_len;j++) {
+				*(u8 *)(rxp+i+j)=*(buf+j);
+			}
+		}
+		goto out;
+	}
+	//note: from here to label "out:" any code without rxp usage
+	//      but rxp is not NULL will be pass
+	//.....
+
+out:
+	if (flags & SPI_XFER_END) {
+
+		spi_cs_deactivate(slave);
+	}
+
+	setbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB); /*for AHB data bus request*/
+	return 0;
+}
+
+//from trunk\spi_flash_aml.c
+static int spi_flash_addr_write(struct spi_slave *spi,  u32 addr){
+
+	unsigned flags = SPI_XFER_END;
+	u32 nAddress = addr;
+	int ret;
+
+	flags |= SPI_XFER_ADR;
+
+	ret = spi_xfer(spi,4*8,&nAddress,NULL,flags);
+
+	if (ret) {
+		debug("SF: Faild to send addr(4 bytes): %d\n",ret);
+	}
+	return ret;
+}
+
+int spi_flash_erase_amlogic(struct spi_flash *flash,u32 offset, size_t len, u32 sector_size)
+{
+	struct spi_slave * slave=flash->spi;
+	size_t actual;
+	unsigned var;
+	int nReturn = -1;
+
+	if (offset % sector_size || len % sector_size) {
+		printf("SF: Erase offset/length not multiple of sector size!\n");
+		return nReturn;
+	}
+	//close AHB bus before any APB bus operation
+	clrbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB);
+
+#ifdef SPI_WRITE_PROTECT
+	spi_disable_write_protect();
+#endif
+
+	for (actual = 0; actual < len; actual+=sector_size) {
+
+		debug("Erase:%zu\n",actual);
+
+		var=(offset+actual) & 0xffffff;
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+		if (flash->secure_protect) {
+			if ((var >=flash->securestorage_info->start_pos) && (var < flash->securestorage_info->end_pos)) {
+				//printf("addr: 0x%x \n",var);
+				continue;
+			}
+		}
+#endif
+		spi_flash_addr_write(slave,var);
+
+		//Trigger write enable command
+		var=1<<SPI_FLASH_WREN;
+		spi_flash_cmd(slave,var,NULL,0);
+
+		//Trigger sector erase command
+		var=1<<SPI_FLASH_SE;
+		spi_flash_cmd(slave,var,NULL,0);
+
+		//debug for hangup
+		//printf("PIN_MAX_REG0 = 0x%08X\n",READ_CBUS_REG(PERIPHS_PIN_MUX_1));
+
+		nReturn=1;
+		while ( (nReturn&1) == 1 ) {
+			var=1<<SPI_FLASH_RDSR;
+			spi_flash_cmd(slave,var,&nReturn,2);		//2 byte status
+		}
+	}
+
+	//reopen AHB bus after any APB bus operation
+	setbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB);
+
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+	void secure_storage_spi_disable(void);
+	secure_storage_spi_disable();
+#endif
+   return nReturn;
+}
+
+//for CONFIG_SPI_FLASH_SPANSION no SE(0x20) command
+//use Block erase 0xD8 command
+int spi_flash_erase_be_amlogic(struct spi_flash *flash,u32 offset, size_t len, u32 sector_size)
+{
+	struct spi_slave * slave=flash->spi;
+	size_t actual;
+	unsigned var;
+	int nReturn = -1;
+
+	if (offset % sector_size || len % sector_size) {
+		printf("SF: Erase offset/length not multiple of sector size!\n");
+		return nReturn;
+	}
+
+	//close AHB bus before any APB bus operation
+	clrbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB);
+
+#ifdef SPI_WRITE_PROTECT
+	spi_disable_write_protect();
+#endif
+
+	for (actual = 0; actual < len; actual+=sector_size) {
+
+		debug("Erase:%zu\n",actual);
+
+		var=(offset+actual) & 0xffffff;
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+		if (flash->secure_protect) {
+			if ((var >=flash->securestorage_info->start_pos) && (var < flash->securestorage_info->end_pos)) {
+				//printf("addr: 0x%x \n",var);
+				continue;
+			}
+		}
+#endif
+		spi_flash_addr_write(slave,var);
+
+		//Trigger write enable command
+		var=1<<SPI_FLASH_WREN;
+		spi_flash_cmd(slave,var,NULL,0);
+
+		//Trigger sector erase command
+		//for CONFIG_SPI_FLASH_SPANSION no SE(0x20) command
+		//use BE(0xD8) command
+		var=1<<SPI_FLASH_BE;
+
+		spi_flash_cmd(slave,var,NULL,0);
+
+		//debug for hangup
+		//printf("PIN_MAX_REG0 = 0x%08X\n",READ_CBUS_REG(PERIPHS_PIN_MUX_1));
+
+		nReturn=1;
+		while ( (nReturn&1) == 1 ) {
+			var=1<<SPI_FLASH_RDSR;
+			spi_flash_cmd(slave,var,&nReturn,2);		//2 byte status
+		}
+	}
+
+	//reopen AHB bus after any APB bus operation
+	setbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB);
+
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+	void secure_storage_spi_disable(void);
+	secure_storage_spi_disable();
+#endif
+   return nReturn;
+}
+
+int spi_flash_write_amlogic(struct spi_flash *flash,u32 offset, size_t len, const void *buf){
+
+	struct spi_slave *spi = flash->spi;
+	u32 temp_addr   = offset;
+    int temp_length = len;
+	unsigned flags;
+	int nReturn = 0;
+
+	if (!len)
+		return nReturn;
+
+	nReturn = 1;
+
+#ifdef SPI_WRITE_PROTECT
+	spi_disable_write_protect();
+#endif
+
+
+	//clean data cache
+	//dcache_clean_range((u32)buf, len);
+	flush_dcache_all();
+
+	//close AHB bus before any APB bus operation
+	clrbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB);
+
+	while (temp_length>0) {
+
+		flags=(temp_addr & 0xffffff)|( (temp_length>=32?32:temp_length) << SPI_FLASH_BYTES_LEN);
+	#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+		if (flash->secure_protect) {
+			if ((temp_addr >= flash->securestorage_info->start_pos) &&(temp_addr<flash->securestorage_info->end_pos)) {
+				temp_addr   += (temp_length>=32?32:temp_length);
+				buf			+= (temp_length>=32?32:temp_length);
+				temp_length -= (temp_length>=32?32:temp_length);
+				//printf("prohibit write,%s:%d\n",__func__,__LINE__);
+				continue;
+			}
+		}
+	#endif
+
+		spi_flash_addr_write(spi, flags);
+
+		flags=SPI_XFER_WRITECACHE;
+
+		spi_xfer(spi,(temp_length>=32?32:temp_length)*8,buf,NULL,flags);
+
+
+		flags=(1<<SPI_FLASH_WREN);
+		spi_flash_cmd(spi,flags,NULL,0);
+
+		flags=(1<<SPI_FLASH_PP);
+		spi_flash_cmd(spi,flags,NULL,0);
+
+
+		 nReturn=1;
+		while ( (nReturn&1) == 1 ) {
+
+			flags=1<<SPI_FLASH_RDSR;
+			spi_flash_cmd(spi,flags,&nReturn,2);		//2 byte status
+		}
+
+        temp_addr   += (temp_length>=32?32:temp_length);
+		buf			+= (temp_length>=32?32:temp_length);
+		temp_length -= (temp_length>=32?32:temp_length);
+	}
+
+	//reopen AHB bus after any APB bus operation
+	setbits_le32(P_SPI_FLASH_CTRL, 1<<SPI_ENABLE_AHB);
+
+#ifdef SPI_WRITE_PROTECT
+    spi_enable_write_protect();
+#endif
+
+	//cache refresh
+	flush_dcache_all();
+
+	return nReturn;
+}
+
+int spi_flash_read_amlogic(struct spi_flash *flash,u32 offset, size_t len, void *buf){
+
+	struct spi_slave *spi = flash->spi;
+	u32 temp_addr = offset;
+    int temp_length = len;
+	unsigned flags;
+
+	if (!len)
+		return 0;
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+	if (flash->secure_protect) {
+		if (((offset+len)>flash->securestorage_info->start_pos) &&((offset+len) <= flash->securestorage_info->end_pos)) {
+				//printf("prohibit read,%s:%d\n",__func__,__LINE__);
+			return -1;
+		}
+		else if(((offset+len)>flash->securestorage_info->end_pos)
+			&&(offset>=flash->securestorage_info->start_pos)
+			&&(offset<flash->securestorage_info->end_pos)){
+				//printf("prohibit read,%s:%d\n",__func__,__LINE__);
+			return -1;
+		}
+		else if(((offset+len)>flash->securestorage_info->end_pos)
+			&&(offset < flash->securestorage_info->start_pos)
+			&&(len>(flash->securestorage_info->start_pos-offset))){
+				//printf("prohibit read,%s:%d\n",__func__,__LINE__);
+			return -1;
+		}
+	}
+#endif
+	//invalid data cache
+	//dcache_invalid_range((u32)buf,len);
+	flush_dcache_all();
+
+
+    /* 0x400000 ~ 0x7fffff */
+    if (temp_addr + len > 0x400000 && temp_addr < 0x400000) {
+		//Read data from SPI controller from temp_addr to 0x3fffff
+		//From 0x400000 to (temp_addr+len) need to set address and
+		//load from cache with 32Bytes per package
+		flags = SPI_XFER_END|SPI_XFER_COPY;
+		spi_xfer(spi,(0x400000-temp_addr)*8,&temp_addr,buf,flags);
+		buf += (0x400000-temp_addr);
+		temp_length = len - (0x400000-temp_addr);
+		temp_addr = 0x400000;
+    }
+    /* 0x000000 ~ 0x3fffff */
+	else if(temp_addr < 0x400000){
+	   flags=SPI_XFER_END|SPI_XFER_COPY;
+       spi_xfer(spi,temp_length*8,&temp_addr,buf,flags);
+	   return 0;
+    }
+
+	while (temp_length>0) {
+		//(byte counter << 24| 24bit device address) for SPI address register
+		flags=(temp_addr & 0xffffff)|( (temp_length>=32?32:temp_length) << SPI_FLASH_BYTES_LEN);
+		spi_flash_addr_write(spi, flags);
+
+		//trigger SPI flash read command
+		flags=(1<<SPI_FLASH_READ);
+		spi_flash_cmd(spi,flags,NULL,0);
+
+		//load data from SPI controller 32bytes data cache
+		flags=SPI_XFER_READCACHE;
+		spi_xfer(spi,(temp_length>=32?32:temp_length)*8,NULL,buf,flags);
+
+		//adjust address, buffer & length
+        temp_addr   += (temp_length>=32?32:temp_length);
+		buf			+= (temp_length>=32?32:temp_length);
+		temp_length -= (temp_length>=32?32:temp_length);
+	}
+
+	//cache refresh
+	flush_dcache_all();
+	return 0;
+}
+
+void spi_flash_free(struct spi_flash *flash)
+{
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+	extern void spi_securestorage_free(void);
+	spi_securestorage_free();
+#endif
+	spi_free_slave(flash->spi);
+	free(flash);
+}
+
+
+/*
+ * The following table holds all device probe functions
+ *
+ * shift:  number of continuation bytes before the ID
+ * idcode: the expected IDCODE or 0xff for non JEDEC devices
+ * probe:  the function to call
+ *
+ * Non JEDEC devices should be ordered in the table such that
+ * the probe functions with best detection algorithms come first.
+ *
+ * Several matching entries are permitted, they will be tried
+ * in sequence until a probe function returns non NULL.
+ *
+ * IDCODE_CONT_LEN may be redefined if a device needs to declare a
+ * larger "shift" value.  IDCODE_PART_LEN generally shouldn't be
+ * changed.  This is the max number of bytes probe functions may
+ * examine when looking up part-specific identification info.
+ *
+ * Probe functions will be given the idcode buffer starting at their
+ * manu id byte (the "idcode" in the table below).  In other words,
+ * all of the continuation bytes will be skipped (the "shift" below).
+ */
+#define IDCODE_CONT_LEN 0
+#define IDCODE_PART_LEN 5
+static const struct {
+	const u8 shift;
+	const u8 idcode;
+	struct spi_flash *(*probe) (struct spi_slave *spi, u8 *idcode);
+} g_flashes[] = {
+	/* Keep it sorted by define name */
+//#ifdef CONFIG_SPI_FLASH_ATMEL
+//	{ 0, 0x1f, spi_flash_probe_atmel, },
+//#endif
+#ifdef CONFIG_SPI_FLASH_EON
+	{ 0, 0x1c, spi_flash_probe_eon, },
+#endif
+#ifdef CONFIG_SPI_FLASH_MACRONIX
+	{ 0, 0xc2, spi_flash_probe_macronix, },
+#endif
+#ifdef CONFIG_SPI_FLASH_SPANSION
+	{ 0, 0x01, spi_flash_probe_spansion, },
+#endif
+#ifdef CONFIG_SPI_FLASH_SST
+	{ 0, 0xbf, spi_flash_probe_sst, },
+#endif
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	{ 0, 0x20, spi_flash_probe_stmicro, },
+#endif
+#ifdef CONFIG_SPI_FLASH_WINBOND
+	{ 0, 0xef, spi_flash_probe_winbond, },
+#endif
+#ifdef CONFIG_SPI_FLASH_GIGADEVICE
+	{ 0, 0xc8, spi_flash_probe_gigadevice, },
+#endif
+#ifdef CONFIG_SPI_FLASH_PMDEVICE
+	{ 0, 0x7f, spi_flash_probe_pmdevice, },
+#endif
+#ifdef CONFIG_SPI_FLASH_ESMT
+	{ 0, 0x8c, spi_flash_probe_esmt, },
+#endif
+//#ifdef CONFIG_SPI_FRAM_RAMTRON
+//	{ 6, 0xc2, spi_fram_probe_ramtron, },
+//# undef IDCODE_CONT_LEN
+//# define IDCODE_CONT_LEN 6
+//#endif
+	/* Keep it sorted by best detection */
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	{ 0, 0xff, spi_flash_probe_stmicro, },
+#endif
+//#ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
+//	{ 0, 0xff, spi_fram_probe_ramtron, },
+//#endif
+};
+#define IDCODE_LEN (IDCODE_CONT_LEN + IDCODE_PART_LEN)
+
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode)
+{
+	struct spi_slave *spi;
+	struct spi_flash *flash = NULL;
+	int ret, i, shift;
+	u8 idcode[IDCODE_LEN], *idp;
+
+	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
+	if (!spi) {
+		printf("SF: Failed to set up slave\n");
+		return NULL;
+	}
+
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("SF: Failed to claim SPI bus: %d\n", ret);
+		goto err_claim_bus;
+	}
+
+	/* Read the ID codes */
+	memset(idcode,0,sizeof(idcode));
+
+	ret = spi_flash_cmd(spi, 1<<SPI_FLASH_RDID, idcode, sizeof(idcode));
+
+	if (ret)
+		goto err_read_id;
+
+	/* count the number of continuation bytes */
+	for (shift = 0, idp = idcode;
+	     shift < IDCODE_CONT_LEN && *idp == 0x7f;
+	     ++shift, ++idp)
+		continue;
+
+	/* search the table for matches in shift and id */
+	for (i = 0; i < ARRAY_SIZE(g_flashes); ++i)
+		if (g_flashes[i].shift == shift && g_flashes[i].idcode == *idp) {
+			/* we have a match, call probe */
+			flash = g_flashes[i].probe(spi, idp);
+			if (flash)
+				break;
+		}
+
+	if (!flash) {
+		printf("SF: Unsupported manufacturer %02x\n", *idp);
+		goto err_manufacturer_probe;
+	}
+
+#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+	extern int spi_securestorage_probe(void *keypara);
+	if (spi_securestorage_probe(flash)) {
+		printf("spi secure storage probe fail\n");
+	}
+#endif
+#ifdef SPI_WRITE_PROTECT
+        if (spi_check_write_protect())
+             printf("\nSPI NOR Flash have write protect!!!\n");
+        else{
+             printf("\nSPI NOR Flash NO write protect!!!, So I will enable it...\n");
+             spi_enable_write_protect();
+            }
+#endif
+
+	spi_release_bus(spi);
+
+	return flash;
+
+err_manufacturer_probe:
+err_read_id:
+	spi_release_bus(spi);
+err_claim_bus:
+	spi_free_slave(spi);
+	return NULL;
+}
diff --git a/drivers/mtd/spi/spi_flash_amlogic.h b/drivers/mtd/spi/spi_flash_amlogic.h
new file mode 100644
index 0000000..4de9af7
--- /dev/null
+++ b/drivers/mtd/spi/spi_flash_amlogic.h
@@ -0,0 +1,160 @@
+/*
+ * SPI flash internal definitions
+ *
+ * Copyright (C) 2011 Amlogic Corporation
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ *
+ * Dedicated for Amlogic SPI controller use
+ */
+
+
+#ifndef __SPI_FLASH_AMLOGIC_H__
+#define __SPI_FLASH_AMLOGIC_H__
+#include <spi.h>
+#include <spi_flash.h>
+#include <asm/arch/io.h>
+
+#ifdef CONFIG_AMLOGIC_SPI_FLASH
+
+/* SPI transfer flags */
+//copy from @\u-boot-arm\branches\a3_bringup\include\spi.h
+//should place to <inlcude\spi.h>
+//but ....
+#ifndef SPI_XFER_BEGIN
+#define SPI_XFER_BEGIN      0x0001		/* Assert CS before transfer */
+#define SPI_XFER_END        0x0002		/* Deassert CS after transfer */
+#endif
+#define SPI_XFER_ADR        0x0004		/* Set SPI address for read/write */
+#define SPI_XFER_CMD        0x0008		/* Trigger SPI command */
+#define SPI_XFER_STATUS		  0x0010		/* Read SPI status register from device */
+#define SPI_XFER_ID	    	  0x0020		/* Read SPI device ID */
+#define SPI_XFER_COPY		    0x0040		/* Amlogic SPI AHB bus copy */
+#define SPI_XFER_READCACHE	0x0080		/* SPI controller data operation: from cache to host */
+#define SPI_XFER_WRITECACHE	0x0100		/* SPI controller data operation: from host to cache*/
+
+#define P_SPI_FLASH_CMD  	(volatile unsigned int *)0xc1108c80
+#define P_SPI_FLASH_ADDR 	(volatile unsigned int *)0xc1108c84
+#define P_SPI_FLASH_CTRL	(volatile unsigned int *)0xc1108c88
+#define P_SPI_FLASH_STATUS	(volatile unsigned int *)0xc1108c90
+#define P_SPI_USER_REG 		(volatile unsigned int *)0xc1108c9c
+#define P_SPI_FLASH_C0		(volatile unsigned int *)0xc1108cc0
+
+#define P_SPI_START_ADDR 	(volatile unsigned int *)0xCC000000
+
+#define P_PERIPHS_PIN_MUX_4		0xc88344c0
+#define P_PERIPHS_PIN_MUX_5		0xc88344c4
+
+#define SPI_FLASH_CMD                              0x2320
+    #define SPI_FLASH_READ    31
+    #define SPI_FLASH_WREN    30
+    #define SPI_FLASH_WRDI    29
+    #define SPI_FLASH_RDID    28
+    #define SPI_FLASH_RDSR    27
+    #define SPI_FLASH_WRSR    26
+    #define SPI_FLASH_PP      25
+    #define SPI_FLASH_SE      24
+    #define SPI_FLASH_BE      23
+    #define SPI_FLASH_CE      22
+    #define SPI_FLASH_DP      21
+    #define SPI_FLASH_RES     20
+    #define SPI_HPM           19
+    #define SPI_FLASH_USR     18
+    #define SPI_FLASH_USR_ADDR 15
+    #define SPI_FLASH_USR_DUMMY 14
+    #define SPI_FLASH_USR_DIN   13
+    #define SPI_FLASH_USR_DOUT   12
+    #define SPI_FLASH_USR_DUMMY_BLEN   10
+    #define SPI_FLASH_USR_CMD     0
+#define SPI_FLASH_ADDR                             0x2321
+    #define SPI_FLASH_BYTES_LEN 24
+    #define SPI_FLASH_ADDR_START 0
+#define SPI_FLASH_CTRL                             0x2322
+    #define SPI_ENABLE_AHB    17
+    #define SPI_SST_AAI       16
+    #define SPI_RES_RID       15
+    #define SPI_FREAD_DUAL    14
+    #define SPI_READ_READ_EN  13
+    #define SPI_CLK_DIV0      12
+    #define SPI_CLKCNT_N      8
+    #define SPI_CLKCNT_H      4
+    #define SPI_CLKCNT_L      0
+#define SPI_FLASH_CTRL1                            0x2323
+#define SPI_FLASH_STATUS                           0x2324
+#define SPI_FLASH_CTRL2                            0x2325
+#define SPI_FLASH_CLOCK                            0x2326
+#define SPI_FLASH_USER                             0x2327
+#define SPI_FLASH_USER1                            0x2328
+#define SPI_FLASH_USER2                            0x2329
+#define SPI_FLASH_USER3                            0x232a
+#define SPI_FLASH_USER4                            0x232b
+#define SPI_FLASH_SLAVE                            0x232c
+#define SPI_FLASH_SLAVE1                           0x232d
+#define SPI_FLASH_SLAVE2                           0x232e
+#define SPI_FLASH_SLAVE3                           0x232f
+#define SPI_FLASH_C0                               0x2330
+#define SPI_FLASH_C1                               0x2331
+#define SPI_FLASH_C2                               0x2332
+#define SPI_FLASH_C3                               0x2333
+#define SPI_FLASH_C4                               0x2334
+#define SPI_FLASH_C5                               0x2335
+#define SPI_FLASH_C6                               0x2336
+#define SPI_FLASH_C7                               0x2337
+#define SPI_FLASH_B8                               0x2338
+#define SPI_FLASH_B9                               0x2339
+#define SPI_FLASH_B10                              0x233a
+#define SPI_FLASH_B11                              0x233b
+#define SPI_FLASH_B12                              0x233c
+#define SPI_FLASH_B13                              0x233d
+#define SPI_FLASH_B14                              0x233e
+#define SPI_FLASH_B15                              0x233f
+
+
+int spi_flash_cmd_amlogic(struct spi_slave *spi, u32 cmd, void *response, size_t len);
+int spi_flash_read_amlogic(struct spi_flash *flash,u32 offset, size_t len, void *buf);
+int spi_flash_write_amlogic(struct spi_flash *flash,u32 offset, size_t len, const void *buf);
+int spi_flash_erase_amlogic(struct spi_flash *flash,u32 offset, size_t len, u32 sector_size);
+int spi_flash_erase_be_amlogic(struct spi_flash *flash,u32 offset, size_t len, u32 sector_size);
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+			const void *dout, void *din, unsigned long flags);
+
+#endif //CONFIG_AMLOGIC_SPI_FLASH
+
+/* Manufacturer-specific probe functions */
+#ifdef CONFIG_SPI_FLASH_SPANSION
+struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_ATEML
+struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_EON
+struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_MACRONIX
+struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_SST
+struct spi_flash *spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_STMICRO
+struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_WINBOND
+struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_RAMTRON
+struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode);
+#endif
+
+#ifdef CONFIG_SPI_FLASH_GIGADEVICE
+struct spi_flash *spi_flash_probe_gigadevice(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_PMDEVICE
+struct spi_flash *spi_flash_probe_pmdevice(struct spi_slave *spi, u8 *idcode);
+#endif
+#ifdef CONFIG_SPI_FLASH_ESMT
+struct spi_flash *spi_flash_probe_esmt(struct spi_slave *spi, u8 *idcode);
+#endif
+
+#endif //__SPI_FLASH_AMLOGIC_H__
diff --git a/drivers/mtd/spi/spi_flash_internal.h b/drivers/mtd/spi/spi_flash_internal.h
new file mode 100644
index 0000000..68dcffb
--- /dev/null
+++ b/drivers/mtd/spi/spi_flash_internal.h
@@ -0,0 +1,54 @@
+/*
+ * SPI flash internal definitions
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ */
+
+/* Common parameters -- kind of high, but they should only occur when there
+ * is a problem (and well your system already is broken), so err on the side
+ * of caution in case we're dealing with slower SPI buses and/or processors.
+ */
+#define SPI_FLASH_PROG_TIMEOUT		(2 * CONFIG_SYS_HZ)
+#define SPI_FLASH_PAGE_ERASE_TIMEOUT	(5 * CONFIG_SYS_HZ)
+#define SPI_FLASH_SECTOR_ERASE_TIMEOUT	(10 * CONFIG_SYS_HZ)
+
+/* Common commands */
+#define CMD_READ_ID			0x9f
+
+#define CMD_READ_ARRAY_SLOW		0x03
+#define CMD_READ_ARRAY_FAST		0x0b
+#define CMD_READ_ARRAY_LEGACY		0xe8
+
+/* Send a single-byte command to the device and read the response */
+int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
+
+/*
+ * Send a multi-byte command to the device and read the response. Used
+ * for flash array reads, etc.
+ */
+int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len);
+
+/*
+ * Send a multi-byte command to the device followed by (optional)
+ * data. Used for programming the flash array, etc.
+ */
+int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
+		const void *data, size_t data_len);
+
+/*
+ * Same as spi_flash_cmd_read() except it also claims/releases the SPI
+ * bus. Used as common part of the ->read() operation.
+ */
+int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
+		size_t cmd_len, void *data, size_t data_len);
+
+/* Manufacturer-specific probe functions */
+struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode);
diff --git a/drivers/mtd/spi/spi_secure_storage.c b/drivers/mtd/spi/spi_secure_storage.c
new file mode 100644
index 0000000..e98f7fe
--- /dev/null
+++ b/drivers/mtd/spi/spi_secure_storage.c
@@ -0,0 +1,528 @@
+
+#include <linux/types.h>
+#include "spi_secure_storage.h"
+#ifdef SPI_SECURE_STORAGE_UBOOT
+#include <spi.h>
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include <ubi_uboot.h>
+#endif
+
+#ifdef SPI_SECURE_STORAGE_KERNEL
+
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include "spi_nor_flash.h"
+#endif
+
+//static struct spi_flash *spi_securestorage_flash=NULL;
+static void *spi_securestorage_flash=NULL;
+
+static u32 emmckey_calculate_checksum(u8 *buf,u32 lenth)
+{
+	u32 checksum = 0;
+	u32 cnt;
+	for (cnt=0;cnt<lenth;cnt++) {
+		checksum += buf[cnt];
+	}
+	return checksum;
+}
+
+static int spi_securestorage_read(void *keypara,u8 *buf,u32 len)
+{
+	u64 addr,size;
+	u32 checksum;
+	int ret;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)keypara;
+	struct aml_spisecurestorage_info_t *securestorage_info = flash->securestorage_info;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	int retlen;
+	struct spi_nor *flash = (struct spi_nor*)keypara;
+	struct aml_spisecurestorage_info_t *securestorage_info = flash->securestorage_info;
+#endif
+	struct aml_spi_securestorage_t *securedata;
+
+	if (!securestorage_info->secure_init) {
+		printk("secure_init:%d fail,%s:%d\n",securestorage_info->secure_init,__func__,__LINE__);
+		return -1;
+	}
+	securedata = kzalloc(sizeof(*securedata), GFP_KERNEL);
+	if (securedata == NULL) {
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	memset(securedata,0,sizeof(*securedata));
+
+	addr = securestorage_info->valid_node->offset;
+	size = securestorage_info->valid_node->size;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	flash->secure_protect = 0;
+	ret = spi_flash_read(flash, (u32)addr,(size_t)size, securedata);
+	flash->secure_protect = 1;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	flash->secure_protect = 0;
+	ret = flash->mtd.read(&flash->mtd,addr,size,&retlen,(u_char*)securedata);
+	flash->secure_protect = 1;
+#endif
+	if (ret) {
+		printk("%s:%d,spi read secure storage addr:0x%llx,size:0x%llx fail\n",__func__,__LINE__,addr,size);
+	}
+	else{
+		checksum = emmckey_calculate_checksum(securedata->data,SPI_SECURESTORAGE_AREA_VALID_SIZE);
+		if ((!memcmp(securedata->magic, SPI_SECURESTORAGE_MAGIC, 9))
+			&&(emmckey_calculate_checksum(securedata->magic,SPI_SECURESTORAGE_MAGIC_SIZE) == securedata->magic_checksum)
+			&&(checksum == securedata->checksum)){
+				memcpy(buf,securedata->data,len);
+		}
+		else{
+			ret = -1;
+			//printk("checksum:%x, securedata->checksum:%x \n",checksum,securedata->checksum);
+			//printk("save:%s, orign:%s ",securedata->magic,SPI_SECURESTORAGE_MAGIC);
+			//printk("head checksum:%x, securedata->magic_checksum:%x \n",emmckey_calculate_checksum(securedata->magic,SPI_SECURESTORAGE_MAGIC_SIZE) ,securedata->magic_checksum);
+		}
+	}
+
+	kfree(securedata);
+	return ret;
+}
+static int spi_securestorage_write(void *keypara,u8 *buf,u32 len)
+{
+	u64 addr,size;
+	int ret=-1;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)keypara;
+	struct aml_spisecurestorage_info_t *securestorage_info = flash->securestorage_info;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	int retlen;
+	struct spi_nor *flash = (struct spi_nor*)keypara;
+	struct aml_spisecurestorage_info_t *securestorage_info = flash->securestorage_info;
+	struct erase_info instr;
+#endif
+	struct aml_spifree_node_t *free_node,*free_tmp_node;
+	//struct aml_spivalid_node_t *valid_node;
+	struct aml_spi_securestorage_t *securedata;
+
+	if (!securestorage_info->secure_init) {
+		printk("secure_init:%d fail,%s:%d\n",securestorage_info->secure_init,__func__,__LINE__);
+		return -1;
+	}
+	securedata = kzalloc(sizeof(*securedata), GFP_KERNEL);
+	if (securedata == NULL) {
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	memset(securedata,0,sizeof(*securedata));
+
+	if (securestorage_info->secure_valid) {
+		free_tmp_node = kzalloc(sizeof(*free_tmp_node), GFP_KERNEL);
+		if (free_tmp_node == NULL) {
+			printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+			return -ENOMEM;
+		}
+		memset(free_tmp_node,0,sizeof(*free_tmp_node));
+		free_tmp_node->offset = securestorage_info->valid_node->offset;
+		free_tmp_node->size = securestorage_info->valid_node->size;
+
+		free_node = securestorage_info->free_node;
+
+		securestorage_info->valid_node->offset = free_node->offset;
+		securestorage_info->valid_node->size = free_node->size;
+		securestorage_info->valid_node->timestamp += 1;
+
+		securestorage_info->free_node = free_node->next;
+		kfree(free_node);
+		if (securestorage_info->free_node == NULL) {
+			securestorage_info->free_node = free_tmp_node;
+		}
+		else{
+			free_node = securestorage_info->free_node;
+			while (free_node->next != NULL) {
+				free_node = free_node->next;
+			}
+			free_node->next = free_tmp_node;
+		}
+	}
+	else{
+		free_node = securestorage_info->free_node;
+		securestorage_info->valid_node->offset = free_node->offset;
+		securestorage_info->valid_node->size = free_node->size;
+		securestorage_info->valid_node->timestamp += 1;
+		securestorage_info->free_node = free_node->next;
+		kfree(free_node);
+	}
+	memcpy(securedata->magic,SPI_SECURESTORAGE_MAGIC,sizeof(SPI_SECURESTORAGE_MAGIC));
+	securedata->magic_checksum = emmckey_calculate_checksum(securedata->magic,SPI_SECURESTORAGE_MAGIC_SIZE);
+	securedata->timestamp = securestorage_info->valid_node->timestamp;
+	securedata->version = SPI_SECURESTORAGE_VER;
+	memcpy(securedata->data,buf,len);
+	securedata->checksum = emmckey_calculate_checksum(securedata->data,SPI_SECURESTORAGE_AREA_VALID_SIZE);
+
+	addr = securestorage_info->valid_node->offset;
+	size = securestorage_info->valid_node->size;
+
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	flash->secure_protect = 0;
+	if (!spi_flash_erase(flash,(u32)addr,(size_t)size)) {
+		flash->secure_protect = 0;
+		ret = spi_flash_write(flash,(u32)addr,(size_t)size,securedata);
+		//static inline int spi_flash_write(struct spi_flash *flash, u32 offset,size_t len, const void *buf)
+		if (ret) {
+			printk("%s:%d,spi flash write addr:0x%llx,size:0x%llx fail\n",__func__,__LINE__,addr,size);
+		}
+	}
+	else{
+		printk("%s:%d,spi flash erase addr:0x%llx,size:0x%llx fail\n",__func__,__LINE__,addr,size);
+	}
+	flash->secure_protect = 1;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	flash->secure_protect = 0;
+	memset(&instr,0,sizeof(struct erase_info));
+	instr.mtd = &flash->mtd;
+	instr.addr = addr;
+	instr.len = size;
+	if (!flash->mtd.erase(&flash->mtd,&instr)) {
+		ret = flash->mtd.write(&flash->mtd,addr,size,&retlen,(u_char*)securedata);
+		if (ret) {
+			printk("%s:%d,spi flash write addr:0x%llx,size:0x%llx fail\n",__func__,__LINE__,addr,size);
+		}
+	}
+	else{
+		printk("%s:%d,spi flash erase addr:0x%llx,size:0x%llx fail\n",__func__,__LINE__,addr,size);
+	}
+	flash->secure_protect = 1;
+#endif
+	securestorage_info->secure_valid = 1;
+	kfree(securedata);
+	return ret;
+}
+
+static int spi_securestorage_init(void *keypara)
+{
+	int cnt,securestorage_part,error=0;
+	u64 addr,size;
+	int ret=0;
+	u32 checksum;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)keypara;
+	struct aml_spisecurestorage_info_t *securestorage_info = flash->securestorage_info;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	int retlen;
+	struct spi_nor *flash = (struct spi_nor*)keypara;
+	struct aml_spisecurestorage_info_t *securestorage_info = flash->securestorage_info;
+#endif
+
+	struct aml_spifree_node_t *free_node,*free_tmp_node,*free_prev_node;
+
+	struct aml_spi_securestorage_t *securedata;
+	securestorage_part = SPI_SECURESTORAGE_AREA_COUNT;
+
+	securedata = kzalloc(sizeof(*securedata), GFP_KERNEL);
+	if (securedata == NULL) {
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	securestorage_info->valid_node = kzalloc(sizeof(struct aml_spivalid_node_t), GFP_KERNEL);
+	if (securestorage_info->valid_node == NULL) {
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		kfree(securedata);
+		return -ENOMEM;
+	}
+	memset(securestorage_info->valid_node,0,sizeof(struct aml_spivalid_node_t));
+	cnt = 0;
+	do {
+		size = SPI_SECURESTORAGE_AREA_SIZE;
+		addr = securestorage_info->start_pos + cnt*size;
+		flash->secure_protect = 0;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+		ret = spi_flash_read(flash, (u32)addr,(size_t)size, securedata);
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+		ret = flash->mtd.read(&flash->mtd,(loff_t)addr,(size_t)size,(size_t*)&retlen,(u_char*)securedata);
+#endif
+		flash->secure_protect = 1;
+		if (ret) {
+			printk("%s:%d,spi read secure storage addr:0x%llx,size:0x%llx fail\n",__func__,__LINE__,addr,size);
+			error++;
+			cnt++;
+			if (cnt >= securestorage_part) {
+				break;
+			}
+			continue;
+		}
+
+		checksum = emmckey_calculate_checksum(securedata->data,SPI_SECURESTORAGE_AREA_VALID_SIZE);
+		if ((!memcmp(securedata->magic, SPI_SECURESTORAGE_MAGIC, 9))
+			&&(emmckey_calculate_checksum(securedata->magic,SPI_SECURESTORAGE_MAGIC_SIZE) == securedata->magic_checksum)
+			&&(checksum == securedata->checksum)){
+				securestorage_info->secure_valid = 1;
+				if (securestorage_info->valid_node->offset > 0) {
+					free_node = kzalloc(sizeof(*free_node), GFP_KERNEL);
+					if (free_node == NULL) {
+						printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+						ret = -ENOMEM;
+						goto exit;
+					}
+					memset(free_node,0,sizeof(*free_node));
+					free_node->dirty_flag = 1;
+					if (securedata->timestamp > securestorage_info->valid_node->timestamp) {
+						free_node->offset = securestorage_info->valid_node->offset;
+						free_node->size = securestorage_info->valid_node->size;
+
+						securestorage_info->valid_node->offset = addr;
+						securestorage_info->valid_node->size = size;
+						securestorage_info->valid_node->timestamp = securedata->timestamp;
+					}
+					else{
+						free_node->offset = addr;
+						free_node->size = size;
+					}
+					if (securestorage_info->free_node == NULL) {
+						securestorage_info->free_node = free_node;
+					}
+					else{
+						free_tmp_node = securestorage_info->free_node;
+						while (free_tmp_node->next != NULL) {
+							free_tmp_node = free_tmp_node->next;
+						}
+						free_tmp_node->next = free_node;
+					}
+				}
+				else{
+					securestorage_info->valid_node->offset = addr;
+					securestorage_info->valid_node->size = size;
+					securestorage_info->valid_node->timestamp = securedata->timestamp;
+				}
+		}
+		else {
+			free_node = kzalloc(sizeof(*free_node), GFP_KERNEL);
+			if (free_node == NULL) {
+				printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+				ret = -ENOMEM;
+				goto exit;
+			}
+			memset(free_node,0,sizeof(*free_node));
+			free_node->offset = addr;
+			free_node->size = size;
+			if (securestorage_info->free_node == NULL) {
+				securestorage_info->free_node = free_node;
+			}
+			else{
+				free_tmp_node = securestorage_info->free_node;
+				free_prev_node = free_tmp_node;
+				while (free_tmp_node != NULL) {
+					if (free_tmp_node->dirty_flag == 1) {
+						break;
+					}
+					free_prev_node = free_tmp_node;
+					free_tmp_node = free_tmp_node->next;
+				}
+				if (free_prev_node == free_tmp_node) {
+					free_node->next = free_tmp_node;
+					securestorage_info->free_node = free_node;
+				}
+				else{
+					free_prev_node->next = free_node;
+					free_node->next = free_tmp_node;
+				}
+			}
+		}
+		securestorage_info->secure_init = 1;
+		cnt++;
+	}while(cnt<securestorage_part);
+	ret = 0;
+	if (error >= securestorage_part) {
+		ret = -1;
+		error = securestorage_part;
+	}
+	printk("spi secure storage part count %d ok\n",(securestorage_part-error));
+	if (securestorage_info->secure_valid == 1) {
+		printk("spi secure storage valid addr:%llx,size:0x%llx\n",securestorage_info->valid_node->offset,securestorage_info->valid_node->size);
+	}
+exit:
+	kfree(securedata);
+	return ret;
+}
+
+static int spi_securestorage_check(void *keypara)
+{
+	int err = 0;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)keypara;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	struct spi_nor *flash = (struct spi_nor*)keypara;
+#endif
+	struct aml_spisecurestorage_info_t *securestorage_info;
+	//struct aml_spi_securestorage_t *securedata;
+	u8 *data_buf;
+	securestorage_info = flash->securestorage_info;
+
+	err = spi_securestorage_init(keypara);
+	if (err) {
+		printk("%s:%d,spi secure storeage init fail\n",__func__,__LINE__);
+		return err;
+	}
+
+	if (securestorage_info->secure_valid) {
+	}
+	else{
+		data_buf = kzalloc(SPI_SECURESTORAGE_AREA_VALID_SIZE, GFP_KERNEL);
+		memset(data_buf,0,SPI_SECURESTORAGE_AREA_VALID_SIZE);
+		err = spi_securestorage_write(keypara,data_buf,SPI_SECURESTORAGE_AREA_VALID_SIZE);
+		if (err) {
+			printk("spi secure storage write init value fail,%s:%d\n",__func__,__LINE__);
+		}
+		kfree(data_buf);
+		return err;
+	}
+	return 0;
+}
+
+void spi_securestorage_free(void)
+{
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)spi_securestorage_flash;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	struct spi_nor *flash = (struct spi_nor*)spi_securestorage_flash;
+#endif
+	if (spi_securestorage_flash) {
+#ifdef SPI_SECURE_STORAGE_UBOOT
+		if (flash->securestorage_info) {
+			kfree(flash->securestorage_info);
+			flash->securestorage_info = NULL;
+		}
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+		if (flash->securestorage_info) {
+			kfree(flash->securestorage_info);
+			flash->securestorage_info = NULL;
+		}
+#endif
+	}
+	spi_securestorage_flash = NULL;
+}
+
+int spi_securestorage_probe(void *keypara)
+{
+	int err = 0;
+	u64 addr,size;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)keypara;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	//struct mtd_info *mtd = (struct mtd_info*)keypara;
+	struct spi_nor *flash = (struct spi_nor*)keypara;
+#endif
+	struct aml_spisecurestorage_info_t *securestorage_info;
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	if (flash->size < SPI_MIN_ROOM_SIZE) {
+		printk("spi can't setup secure storage,flash size:0x%x is smaller than 0x%x\n",flash->size,SPI_MIN_ROOM_SIZE);
+		return -1;
+	}
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	if (flash->mtd.size < SPI_MIN_ROOM_SIZE) {
+		printk("spi can't setup secure storage,flash size:0x%llx is smaller than 0x%x\n",flash->mtd.size,SPI_MIN_ROOM_SIZE);
+		return -1;
+	}
+#endif
+	securestorage_info = kzalloc(sizeof(*securestorage_info), GFP_KERNEL);
+	if (securestorage_info == NULL) {
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	memset(securestorage_info,0,sizeof(*securestorage_info));
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	flash->securestorage_info = securestorage_info;
+	flash->secure_protect = 1;
+	addr = SPI_SECURESTORAGE_OFFSET;
+	size = SPI_SECURESTORAGE_AREA_SIZE * SPI_SECURESTORAGE_AREA_COUNT;
+#endif
+#ifdef SPI_SECURE_STORAGE_KERNEL
+	flash->securestorage_info = securestorage_info;
+	flash->secure_protect = 1;
+	addr = SPI_SECURESTORAGE_OFFSET;
+	size = SPI_SECURESTORAGE_AREA_SIZE * SPI_SECURESTORAGE_AREA_COUNT;
+#endif
+	securestorage_info->start_pos = addr;
+	securestorage_info->end_pos = addr + size;//valid room: [start_pos:end_pos)
+
+	err = spi_securestorage_check(keypara);
+	if (!err) {
+		spi_securestorage_flash = keypara;
+		printk("spi secure storage start position:0x%llx,end position:%llx ok\n",addr,(addr+size));
+	}
+	else{
+		printk("spi secure storage fail,%s:%d\n",__func__,__LINE__);
+	}
+	return err;
+}
+void secure_storage_spi_enable(void)
+{
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)spi_securestorage_flash;
+#endif
+	if (spi_securestorage_flash == NULL) {
+		return ;
+	}
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	flash->secure_protect = 0;
+#endif
+}
+
+void secure_storage_spi_disable(void)
+{
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	struct spi_flash *flash = (struct spi_flash*)spi_securestorage_flash;
+#endif
+	if (spi_securestorage_flash == NULL) {
+		return ;
+	}
+#ifdef SPI_SECURE_STORAGE_UBOOT
+	flash->secure_protect = 1;
+#endif
+}
+
+int secure_storage_spi_write(char *buf,unsigned int len)
+{
+	int err;
+	if (len > SPI_SECURESTORAGE_AREA_VALID_SIZE) {
+		printk("spi secure storage write fail,len 0x%x is bigger than 0x%x,%s:%d\n",len,SPI_SECURESTORAGE_AREA_VALID_SIZE,__func__,__LINE__);
+		return -1;
+	}
+	if (spi_securestorage_flash == NULL) {
+		printk("spi secure storage not init,please init spi,%s:%d\n",__func__,__LINE__);
+		return -1;
+	}
+	err = spi_securestorage_write(spi_securestorage_flash,(u8 *)buf, len);
+	return err;
+}
+
+int secure_storage_spi_read(char *buf,unsigned int len)
+{
+	u32 size;
+	int err;
+	if (spi_securestorage_flash == NULL) {
+		printk("spi secure storage not init,please init spi,%s:%d\n",__func__,__LINE__);
+		return -1;
+	}
+	if (len>SPI_SECURESTORAGE_AREA_VALID_SIZE) {
+		size = SPI_SECURESTORAGE_AREA_VALID_SIZE;
+	}
+	else{
+		size = len;
+	}
+	err = spi_securestorage_read(spi_securestorage_flash,(u8 *)buf, size);
+	return err;
+}
+
+
diff --git a/drivers/mtd/spi/spi_secure_storage.h b/drivers/mtd/spi/spi_secure_storage.h
new file mode 100644
index 0000000..65b0c37
--- /dev/null
+++ b/drivers/mtd/spi/spi_secure_storage.h
@@ -0,0 +1,64 @@
+#ifndef __SPI_SECURE_STORAGE_H__
+#define __SPI_SECURE_STORAGE_H__
+
+//#include <linux/types.h>
+#define SPI_SECURE_STORAGE_UBOOT
+//#define SPI_SECURE_STORAGE_KERNEL
+
+#define SPI_MIN_ROOM_SIZE 0x200000
+
+//#ifdef CONFIG_SPI_NOR_SECURE_STORAGE
+struct aml_spivalid_node_t{
+	u64 offset;
+	u64 size;
+	int timestamp;
+	struct aml_spivalid_node_t *next;
+};
+struct aml_spifree_node_t{
+	u64 offset;
+	u64 size;
+	int dirty_flag;
+	struct aml_spifree_node_t *next;
+};
+
+#define SPI_SECURESTORAGE_VER		1
+#define SPI_SECURESTORAGE_MAGIC		"spi_sskey"
+
+#define SPI_SECURESTORAGE_SIZE		(128*1024)
+
+#define SPI_SECURESTORAGE_AREA_SIZE	(256*1024)
+#define SPI_SECURESTORAGE_AREA_COUNT 2
+#define SPI_SECURESTORAGE_OFFSET	(0x100000+64*1024)
+
+#define SPI_SECURESTORAGE_MAGIC_SIZE	16
+#define SPI_SECURESTORAGE_AREA_HEAD_SIZE	(SPI_SECURESTORAGE_MAGIC_SIZE+4*6)
+#define SPI_SECURESTORAGE_AREA_VALID_SIZE	(SPI_SECURESTORAGE_AREA_SIZE-SPI_SECURESTORAGE_AREA_HEAD_SIZE)
+
+struct aml_spi_securestorage_t{
+	u8 magic[SPI_SECURESTORAGE_MAGIC_SIZE];
+	u32 magic_checksum;
+	u32 version;
+	u32 tag;
+	u32 checksum; //data checksum
+	u32 timestamp;
+	u32 reserve;
+	u8 data[SPI_SECURESTORAGE_AREA_VALID_SIZE];
+};
+
+
+struct aml_spisecurestorage_info_t{
+	struct aml_spivalid_node_t *valid_node;
+	struct aml_spifree_node_t *free_node;
+	u64 start_pos;
+	u64 end_pos;
+	u8 secure_valid;
+	u8 secure_init;
+};
+
+//#else
+//#endif
+
+
+#endif
+
+
diff --git a/drivers/mtd/spi/sst.c b/drivers/mtd/spi/sst.c
new file mode 100644
index 0000000..bf7b681
--- /dev/null
+++ b/drivers/mtd/spi/sst.c
@@ -0,0 +1,412 @@
+/*
+ * Driver for SST serial flashes
+ *
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ * Copyright 2008, Network Appliance Inc.
+ * Jason McMullan <mcmullan@netapp.com>
+ * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
+ * Copyright (c) 2008-2009 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#ifdef CONFIG_AMLOGIC_SPI_FLASH
+
+#include "spi_flash_amlogic.h"
+
+#else //else CONFIG_AMLOGIC_SPI_FLASH
+
+#include "spi_flash_internal.h"
+
+#define CMD_SST_WREN		0x06	/* Write Enable */
+#define CMD_SST_WRDI		0x04	/* Write Disable */
+#define CMD_SST_RDSR		0x05	/* Read Status Register */
+#define CMD_SST_WRSR		0x01	/* Write Status Register */
+#define CMD_SST_READ		0x03	/* Read Data Bytes */
+#define CMD_SST_FAST_READ	0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_SST_BP		0x02	/* Byte Program */
+#define CMD_SST_AAI_WP		0xAD	/* Auto Address Increment Word Program */
+#define CMD_SST_SE		0x20	/* Sector Erase */
+
+#define SST_SR_WIP		(1 << 0)	/* Write-in-Progress */
+#define SST_SR_WEL		(1 << 1)	/* Write enable */
+#define SST_SR_BP0		(1 << 2)	/* Block Protection 0 */
+#define SST_SR_BP1		(1 << 3)	/* Block Protection 1 */
+#define SST_SR_BP2		(1 << 4)	/* Block Protection 2 */
+#define SST_SR_AAI		(1 << 6)	/* Addressing mode */
+#define SST_SR_BPL		(1 << 7)	/* BP bits lock */
+
+#endif //else end for CONFIG_AMLOGIC_SPI_FLASH
+
+struct sst_spi_flash_params {
+	u8 idcode1;
+	u16 nr_sectors;
+	const char *name;
+};
+
+struct sst_spi_flash {
+	struct spi_flash flash;
+	const struct sst_spi_flash_params *params;
+};
+
+static inline struct sst_spi_flash *to_sst_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct sst_spi_flash, flash);
+}
+
+#define SST_SECTOR_SIZE (4 * 1024)
+static const struct sst_spi_flash_params sst_spi_flash_table[] = {
+	{
+		.idcode1 = 0x8d,
+		.nr_sectors = 128,
+		.name = "SST25VF040B",
+	},{
+		.idcode1 = 0x8e,
+		.nr_sectors = 256,
+		.name = "SST25VF080B",
+	},{
+		.idcode1 = 0x41,
+		.nr_sectors = 512,
+		.name = "SST25VF016B",
+	},{
+		.idcode1 = 0x4a,
+		.nr_sectors = 1024,
+		.name = "SST25VF032B",
+	},{
+		.idcode1 = 0x01,
+		.nr_sectors = 16,
+		.name = "SST25WF512",
+	},{
+		.idcode1 = 0x02,
+		.nr_sectors = 32,
+		.name = "SST25WF010",
+	},{
+		.idcode1 = 0x03,
+		.nr_sectors = 64,
+		.name = "SST25WF020",
+	},{
+		.idcode1 = 0x04,
+		.nr_sectors = 128,
+		.name = "SST25WF040",
+	},
+};
+
+
+#ifdef CONFIG_AMLOGIC_SPI_FLASH
+//new solution for Amlogic SPI controller
+//
+//
+static int sst_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	return 0;
+}
+
+static int sst_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	return 0;
+}
+int sst_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	return 0;
+}
+
+#else //else for CONFIG_AMLOGIC_SPI_FLASH, keep former for rollback verify
+
+static int
+sst_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 byte = CMD_SST_RDSR;
+
+	ret = spi_xfer(spi, sizeof(byte) * 8, &byte, NULL, SPI_XFER_BEGIN);
+	if (ret) {
+		debug("SF: Failed to send command %02x: %d\n", byte, ret);
+		return ret;
+	}
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_xfer(spi, sizeof(byte) * 8, NULL, &byte, 0);
+		if (ret)
+			break;
+
+		if ((byte & SST_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if (!ret && (byte & SST_SR_WIP) != 0)
+		ret = -1;
+
+	if (ret)
+		debug("SF: sst wait for ready timed out\n");
+	return ret;
+}
+
+static int
+sst_enable_writing(struct spi_flash *flash)
+{
+	int ret = spi_flash_cmd(flash->spi, CMD_SST_WREN, NULL, 0);
+	if (ret)
+		debug("SF: Enabling Write failed\n");
+	return ret;
+}
+
+static int
+sst_disable_writing(struct spi_flash *flash)
+{
+	int ret = spi_flash_cmd(flash->spi, CMD_SST_WRDI, NULL, 0);
+	if (ret)
+		debug("SF: Disabling Write failed\n");
+	return ret;
+}
+
+static int
+sst_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	u8 cmd[5] = {
+		CMD_READ_ARRAY_FAST,
+		offset >> 16,
+		offset >> 8,
+		offset,
+		0x00,
+	};
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int
+sst_byte_write(struct spi_flash *flash, u32 offset, const void *buf)
+{
+	int ret;
+	u8 cmd[4] = {
+		CMD_SST_BP,
+		offset >> 16,
+		offset >> 8,
+		offset,
+	};
+
+	debug("BP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
+		spi_w8r8(flash->spi, CMD_SST_RDSR), buf, cmd[0], offset);
+
+	ret = sst_enable_writing(flash);
+	if (ret)
+		return ret;
+
+	ret = spi_flash_cmd_write(flash->spi, cmd, sizeof(cmd), buf, 1);
+	if (ret)
+		return ret;
+
+	return sst_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+}
+
+static int
+sst_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	size_t actual, cmd_len;
+	int ret;
+	u8 cmd[4];
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	/* If the data is not word aligned, write out leading single byte */
+	actual = offset % 2;
+	if (actual) {
+		ret = sst_byte_write(flash, offset, buf);
+		if (ret)
+			goto done;
+	}
+	offset += actual;
+
+	ret = sst_enable_writing(flash);
+	if (ret)
+		goto done;
+
+	cmd_len = 4;
+	cmd[0] = CMD_SST_AAI_WP;
+	cmd[1] = offset >> 16;
+	cmd[2] = offset >> 8;
+	cmd[3] = offset;
+
+	for (; actual < len - 1; actual += 2) {
+		debug("WP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
+		     spi_w8r8(flash->spi, CMD_SST_RDSR), buf + actual, cmd[0],
+		     offset);
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len,
+		                          buf + actual, 2);
+		if (ret) {
+			debug("SF: sst word program failed\n");
+			break;
+		}
+
+		ret = sst_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret)
+			break;
+
+		cmd_len = 1;
+		offset += 2;
+	}
+
+	if (!ret)
+		ret = sst_disable_writing(flash);
+
+	/* If there is a single trailing byte, write it out */
+	if (!ret && actual != len)
+		ret = sst_byte_write(flash, offset, buf + actual);
+
+ done:
+	debug("SF: sst: program %s %zu bytes @ 0x%zx\n",
+	      ret ? "failure" : "success", len, offset - actual);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int
+sst_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	unsigned long sector_size;
+	u32 start, end;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * Probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = SST_SECTOR_SIZE;
+
+	if (offset % sector_size) {
+		debug("SF: Erase offset not multiple of sector size\n");
+		return -1;
+	}
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	cmd[0] = CMD_SST_SE;
+	cmd[3] = 0;
+	start = offset;
+	end = start + len;
+
+	ret = 0;
+	while (offset < end) {
+		cmd[1] = offset >> 16;
+		cmd[2] = offset >> 8;
+		offset += sector_size;
+
+		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
+		      cmd[2], cmd[3], offset);
+
+		ret = sst_enable_writing(flash);
+		if (ret)
+			break;
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, sizeof(cmd), NULL, 0);
+		if (ret) {
+			debug("SF: sst page erase failed\n");
+			break;
+		}
+
+		ret = sst_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret)
+			break;
+	}
+
+	debug("SF: sst: Successfully erased %lu bytes @ 0x%x\n",
+	      len * sector_size, start);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+static int
+sst_unlock(struct spi_flash *flash)
+{
+	int ret;
+	u8 cmd, status;
+
+	ret = sst_enable_writing(flash);
+	if (ret)
+		return ret;
+
+	cmd = CMD_SST_WRSR;
+	status = 0;
+	ret = spi_flash_cmd_write(flash->spi, &cmd, 1, &status, 1);
+	if (ret)
+		debug("SF: Unable to set status byte\n");
+
+	debug("SF: sst: status = %x\n", spi_w8r8(flash->spi, CMD_SST_RDSR));
+
+	return ret;
+}
+
+#endif // else end for CONFIG_AMLOGIC_SPI_FLASH
+
+struct spi_flash *
+spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode)
+{
+	const struct sst_spi_flash_params *params;
+	struct sst_spi_flash *stm;
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(sst_spi_flash_table); ++i) {
+		params = &sst_spi_flash_table[i];
+		if (params->idcode1 == idcode[2])
+			break;
+	}
+
+	if (i == ARRAY_SIZE(sst_spi_flash_table)) {
+		debug("SF: Unsupported SST ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	stm = malloc(sizeof(*stm));
+	if (!stm) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	stm->params = params;
+	stm->flash.spi = spi;
+	stm->flash.name = params->name;
+
+	stm->flash.write = sst_write;
+	stm->flash.erase = sst_erase;
+	stm->flash.read = sst_read_fast;
+	stm->flash.size = SST_SECTOR_SIZE * params->nr_sectors;
+
+	printf("SF: Detected %s with page size %u, total ",
+	       params->name, SST_SECTOR_SIZE);
+	print_size(stm->flash.size, "\n");
+
+	/* Flash powers up read-only, so clear BP# bits */
+	#ifdef CONFIG_AMLOGIC_SPI_FLASH
+	printf("Please implement sst SPI unlock function!");
+	while (1) {
+	}
+	#else
+	sst_unlock(&stm->flash);
+	#endif
+
+	return &stm->flash;
+}
diff --git a/drivers/mtd/spi/stmicro.c b/drivers/mtd/spi/stmicro.c
new file mode 100644
index 0000000..92e793b
--- /dev/null
+++ b/drivers/mtd/spi/stmicro.c
@@ -0,0 +1,511 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * Copyright 2008, Network Appliance Inc.
+ * Jason McMullan <mcmullan@netapp.com>
+ *
+ * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+#if !defined(CONFIG_AMLOGIC_SPI_FLASH)
+//For PxP emulator SPI M25P32 support
+#include <spi_flash.h>
+
+#include "spi_flash_internal.h"
+
+/* M25Pxx-specific commands */
+#define CMD_M25PXX_WREN		0x06	/* Write Enable */
+#define CMD_M25PXX_WRDI		0x04	/* Write Disable */
+#define CMD_M25PXX_RDSR		0x05	/* Read Status Register */
+#define CMD_M25PXX_WRSR		0x01	/* Write Status Register */
+#define CMD_M25PXX_READ		0x03	/* Read Data Bytes */
+#define CMD_M25PXX_FAST_READ	0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_M25PXX_PP		0x02	/* Page Program */
+#define CMD_M25PXX_SE		0xd8	/* Sector Erase */
+#define CMD_M25PXX_BE		0xc7	/* Bulk Erase */
+#define CMD_M25PXX_DP		0xb9	/* Deep Power-down */
+#define CMD_M25PXX_RES		0xab	/* Release from DP, and Read Signature */
+
+#define STM_ID_M25P10		0x11
+#define STM_ID_M25P16		0x15
+#define STM_ID_M25P20		0x12
+#define STM_ID_M25P32		0x16
+#define STM_ID_M25P40		0x13
+#define STM_ID_M25P64		0x17
+#define STM_ID_M25P80		0x14
+#define STM_ID_M25P128		0x18
+
+#define STMICRO_SR_WIP		(1 << 0)	/* Write-in-Progress */
+
+struct stmicro_spi_flash_params {
+	u8 idcode1;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 nr_sectors;
+	const char *name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct stmicro_spi_flash {
+	struct spi_flash flash;
+	const struct stmicro_spi_flash_params *params;
+};
+
+static inline struct stmicro_spi_flash *to_stmicro_spi_flash(struct spi_flash
+							     *flash)
+{
+	return container_of(flash, struct stmicro_spi_flash, flash);
+}
+
+static const struct stmicro_spi_flash_params stmicro_spi_flash_table[] = {
+	{
+		.idcode1 = STM_ID_M25P10,
+		.page_size = 256,
+		.pages_per_sector = 128,
+		.nr_sectors = 4,
+		.name = "M25P10",
+	},
+	{
+		.idcode1 = STM_ID_M25P16,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 32,
+		.name = "M25P16",
+	},
+	{
+		.idcode1 = STM_ID_M25P20,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 4,
+		.name = "M25P20",
+	},
+	{
+		.idcode1 = STM_ID_M25P32,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 64,
+		.name = "M25P32",
+	},
+	{
+		.idcode1 = STM_ID_M25P40,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 8,
+		.name = "M25P40",
+	},
+	{
+		.idcode1 = STM_ID_M25P64,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 128,
+		.name = "M25P64",
+	},
+	{
+		.idcode1 = STM_ID_M25P80,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 16,
+		.name = "M25P80",
+	},
+	{
+		.idcode1 = STM_ID_M25P128,
+		.page_size = 256,
+		.pages_per_sector = 1024,
+		.nr_sectors = 64,
+		.name = "M25P128",
+	},
+};
+
+static int stmicro_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 cmd = CMD_M25PXX_RDSR;
+	u8 status;
+
+	ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
+	if (ret) {
+		debug("SF: Failed to send command %02x: %d\n", cmd, ret);
+		return ret;
+	}
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_xfer(spi, 8, NULL, &status, 0);
+		if (ret)
+			return -1;
+
+		if ((status & STMICRO_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if ((status & STMICRO_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int stmicro_read_fast(struct spi_flash *flash,
+			     u32 offset, size_t len, void *buf)
+{
+	struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = stm->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int stmicro_write(struct spi_flash *flash,
+			 u32 offset, size_t len, const void *buf)
+{
+	struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = stm->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_M25PXX_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_M25PXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: STMicro Page Program failed\n");
+			break;
+		}
+
+		ret = stmicro_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: STMicro page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: STMicro: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int stmicro_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
+	unsigned long sector_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = stm->params->page_size * stm->params->pages_per_sector;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	len /= sector_size;
+	cmd[0] = CMD_M25PXX_SE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual++) {
+		cmd[1] = offset >> 16;
+		offset += sector_size;
+
+		ret = spi_flash_cmd(flash->spi, CMD_M25PXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: STMicro page erase failed\n");
+			break;
+		}
+
+		ret = stmicro_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: STMicro page erase timed out\n");
+			break;
+		}
+	}
+
+	debug("SF: STMicro: Successfully erased %u bytes @ 0x%x\n",
+	      len * sector_size, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
+{
+	const struct stmicro_spi_flash_params *params;
+	struct stmicro_spi_flash *stm;
+	unsigned int i;
+
+	if (idcode[0] == 0xff) {
+		i = spi_flash_cmd(spi, CMD_M25PXX_RES,
+				  idcode, 4);
+		if (i)
+			return NULL;
+		if ((idcode[3] & 0xf0) == 0x10) {
+			idcode[0] = 0x20;
+			idcode[1] = 0x20;
+			idcode[2] = idcode[3] + 1;
+		} else
+			return NULL;
+	}
+
+	printf("\nAmloigc log : STMicro 1\n");
+
+	for (i = 0; i < ARRAY_SIZE(stmicro_spi_flash_table); i++) {
+		params = &stmicro_spi_flash_table[i];
+		if (params->idcode1 == idcode[2]) {
+			break;
+		}
+	}
+
+	printf("\nAmloigc log : STMicro 2\n");
+
+	if (i == ARRAY_SIZE(stmicro_spi_flash_table)) {
+		debug("SF: Unsupported STMicro ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	printf("\nAmloigc log : STMicro 3\n");
+
+	stm = malloc(sizeof(struct stmicro_spi_flash));
+	if (!stm) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	printf("\nAmloigc log : STMicro 4\n");
+
+	stm->params = params;
+	stm->flash.spi = spi;
+	stm->flash.name = params->name;
+
+	stm->flash.write = stmicro_write;
+	stm->flash.erase = stmicro_erase;
+	stm->flash.read = stmicro_read_fast;
+	stm->flash.size = params->page_size * params->pages_per_sector
+	    * params->nr_sectors;
+
+	printf("SF: Detected %s with page size %u, total ",
+	       params->name, params->page_size);
+	print_size(stm->flash.size, "\n");
+
+	return &stm->flash;
+}
+#else
+
+#include "spi_flash_amlogic.h"
+
+struct stmicro_spi_flash_params{
+    u16 idcode;
+    u16 page_size;
+    u16 pages_per_sector;
+    u16 sectors_per_block;
+    u16 nr_blocks;
+    const char *name;
+};
+
+struct stmicro_spi_flash
+{
+    struct spi_flash flash;
+    const struct stmicro_spi_flash_params *params;
+};
+
+static inline struct stmicro_spi_flash *to_stmicro_spi_flash(struct spi_flash *flash)
+{
+    return container_of(flash, struct stmicro_spi_flash, flash);
+}
+
+static const struct stmicro_spi_flash_params stmicro_spi_flash_table[] =
+{
+    {
+	.idcode            = 0x2016,
+	.page_size         = 256,
+	.pages_per_sector  = 256,
+	.sectors_per_block = 64,
+	.nr_blocks         = 1,
+	.name = "M25P32",
+    },
+    {
+	.idcode            = 0x2018,
+	.page_size         = 256,
+	.pages_per_sector  = 1024,
+	.sectors_per_block = 64,
+	.nr_blocks         = 1,
+	.name = "M25P128",
+    },
+};
+
+static int stmicro_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int ret;
+    spi_claim_bus(flash->spi);
+
+    ret = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+    return  ret;
+}
+
+static int stmicro_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+    int ret;
+    spi_claim_bus(flash->spi);
+
+    ret = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+    return ret;
+}
+
+int stmicro_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+    struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
+    u32 sector_size;
+    int ret;
+
+    sector_size = stm->params->page_size * stm->params->pages_per_sector;
+
+    spi_claim_bus(flash->spi);
+
+    ret = spi_flash_erase_amlogic(flash, offset, len, sector_size);
+
+    spi_release_bus(flash->spi);
+
+    return ret;
+}
+
+struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 *idcode)
+{
+	const struct stmicro_spi_flash_params *params;
+	struct stmicro_spi_flash *mcx;
+	unsigned int i;
+	u16 id = idcode[2] | idcode[1] << 8;
+
+	for (i = 0; i < ARRAY_SIZE(stmicro_spi_flash_table); i++) {
+		params = &stmicro_spi_flash_table[i];
+		if (params->idcode == id)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(stmicro_spi_flash_table)) {
+		debug("SF: Unsupported Macronix ID %04x\n", id);
+		return NULL;
+	}
+
+	mcx = malloc(sizeof(*mcx));
+	if (!mcx) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	mcx->params = params;
+	mcx->flash.spi = spi;
+	mcx->flash.name = params->name;
+
+	mcx->flash.write = stmicro_write;
+	mcx->flash.erase = stmicro_erase;
+	mcx->flash.read = stmicro_read_fast;
+	mcx->flash.size = params->page_size * params->pages_per_sector
+	    * params->sectors_per_block * params->nr_blocks;
+
+	printf("SF: Detected %s with page size %u, total ",
+	       params->name, params->page_size);
+	print_size(mcx->flash.size, "\n");
+
+	return &mcx->flash;
+}
+
+#endif
diff --git a/drivers/mtd/spi/winbond.c b/drivers/mtd/spi/winbond.c
new file mode 100644
index 0000000..25d3cc4
--- /dev/null
+++ b/drivers/mtd/spi/winbond.c
@@ -0,0 +1,446 @@
+/*
+ * Copyright 2008, Network Appliance Inc.
+ * Author: Jason McMullan <mcmullan <at> netapp.com>
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#ifdef CONFIG_AMLOGIC_SPI_FLASH
+
+#include "spi_flash_amlogic.h"
+
+#else //else CONFIG_AMLOGIC_SPI_FLASH
+
+#include "spi_flash_internal.h"
+
+/* M25Pxx-specific commands */
+#define CMD_W25_WREN		0x06	/* Write Enable */
+#define CMD_W25_WRDI		0x04	/* Write Disable */
+#define CMD_W25_RDSR		0x05	/* Read Status Register */
+#define CMD_W25_WRSR		0x01	/* Write Status Register */
+#define CMD_W25_READ		0x03	/* Read Data Bytes */
+#define CMD_W25_FAST_READ	0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_W25_PP		0x02	/* Page Program */
+#define CMD_W25_SE		0x20	/* Sector (4K) Erase */
+#define CMD_W25_BE		0xd8	/* Block (64K) Erase */
+#define CMD_W25_CE		0xc7	/* Chip Erase */
+#define CMD_W25_DP		0xb9	/* Deep Power-down */
+#define CMD_W25_RES		0xab	/* Release from DP, and Read Signature */
+
+#define WINBOND_SR_WIP		(1 << 0)	/* Write-in-Progress */
+
+#endif //else end for CONFIG_AMLOGIC_SPI_FLASH
+
+struct winbond_spi_flash_params {
+	uint16_t	id;
+	/* Log2 of page size in power-of-two mode */
+	uint8_t		l2_page_size;
+	uint16_t	pages_per_sector;
+	uint16_t	sectors_per_block;
+	uint16_t	nr_blocks;
+	const char	*name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct winbond_spi_flash {
+	struct spi_flash flash;
+	const struct winbond_spi_flash_params *params;
+};
+
+static inline struct winbond_spi_flash *
+to_winbond_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct winbond_spi_flash, flash);
+}
+
+static const struct winbond_spi_flash_params winbond_spi_flash_table[] = {
+	{
+		.id 				= 0x3011,
+		.l2_page_size		= 8,
+		.pages_per_sector	= 16,
+		.sectors_per_block	= 16,
+		.nr_blocks			= 2,
+		.name				= "W25X10",
+	},
+
+	{
+		.id 				= 0x3012,
+		.l2_page_size		= 8,
+		.pages_per_sector	= 16,
+		.sectors_per_block	= 16,
+		.nr_blocks			= 4,
+		.name				= "W25X20",
+	},
+	{
+		.id 				= 0x3013,
+		.l2_page_size		= 8,
+		.pages_per_sector	= 16,
+		.sectors_per_block	= 16,
+		.nr_blocks			= 8,
+		.name				= "W25X40",
+	},
+
+	{
+		.id                 = 0x3015,
+		.l2_page_size       = 8,
+		.pages_per_sector   = 16,
+		.sectors_per_block  = 16,
+		.nr_blocks          = 32,
+		.name               = "W25X16",
+	},
+	{
+		.id                 = 0x3016,
+		.l2_page_size       = 8,
+		.pages_per_sector   = 16,
+		.sectors_per_block  = 16,
+		.nr_blocks          = 64,
+		.name               = "W25X32",
+	},
+	{
+		.id                 = 0x3017,
+		.l2_page_size       = 8,
+		.pages_per_sector   = 16,
+		.sectors_per_block  = 16,
+		.nr_blocks          = 128,
+		.name               = "W25X64",
+	},
+	{
+		.id                 = 0x4015,
+		.l2_page_size       = 8,
+		.pages_per_sector   = 16,
+		.sectors_per_block  = 16,
+		.nr_blocks          = 32,
+		.name               = "W25Q16",
+	},
+	{
+		.id                 = 0x4016,
+		.l2_page_size       = 8,
+		.pages_per_sector   = 16,
+		.sectors_per_block  = 16,
+		.nr_blocks          = 64,
+		.name               = "W25Q32",
+	},
+	{
+		.id                 = 0x4017,
+		.l2_page_size       = 8,
+		.pages_per_sector   = 16,
+		.sectors_per_block  = 16,
+		.nr_blocks          = 128,
+		.name               = "W25Q64",
+	},
+	{
+		.id                 = 0x4018,
+		.l2_page_size       = 8,
+		.pages_per_sector   = 16,
+		.sectors_per_block  = 16,
+		.nr_blocks          = 256,
+		.name               = "W25Q128",
+	},
+};
+
+#ifdef CONFIG_AMLOGIC_SPI_FLASH
+//new solution for Amlogic SPI controller
+//
+//
+static int winbond_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+{
+	int nReturn = 0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_write_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+static int winbond_read_fast(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int nReturn =0;
+
+	spi_claim_bus(flash->spi);
+
+    nReturn = spi_flash_read_amlogic(flash, offset, len,buf);
+
+    spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+int winbond_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct winbond_spi_flash *stm = to_winbond_spi_flash(flash);
+	u32 sector_size;
+	int nReturn;
+
+	sector_size = (1<< stm->params->l2_page_size) * stm->params->pages_per_sector;
+
+	spi_claim_bus(flash->spi);
+
+	nReturn = spi_flash_erase_amlogic(flash, offset, len, sector_size);
+
+	spi_release_bus(flash->spi);
+
+	return nReturn;
+}
+
+#else //else for CONFIG_AMLOGIC_SPI_FLASH, keep former for rollback verify
+
+static int winbond_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+	u8 cmd[4] = { CMD_W25_RDSR, 0xff, 0xff, 0xff };
+
+	ret = spi_xfer(spi, 32, &cmd[0], NULL, SPI_XFER_BEGIN);
+	if (ret) {
+		debug("SF: Failed to send command %02x: %d\n", cmd, ret);
+		return ret;
+	}
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_xfer(spi, 8, NULL, &status, 0);
+		if (ret) {
+			debug("SF: Failed to get status for cmd %02x: %d\n", cmd, ret);
+			return -1;
+		}
+
+		if ((status & WINBOND_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if ((status & WINBOND_SR_WIP) == 0)
+		return 0;
+
+	debug("SF: Timed out on command %02x: %d\n", cmd, ret);
+	/* Timed out */
+	return -1;
+}
+
+/*
+ * Assemble the address part of a command for Winbond devices in
+ * non-power-of-two page size mode.
+ */
+static void winbond_build_address(struct winbond_spi_flash *stm, u8 *cmd, u32 offset)
+{
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	unsigned int page_shift;
+
+	/*
+	 * The "extra" space per page is the power-of-two page size
+	 * divided by 32.
+	 */
+	page_shift = stm->params->l2_page_size;
+	page_size = (1 << page_shift);
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	cmd[0] = page_addr >> (16 - page_shift);
+	cmd[1] = page_addr << (page_shift - 8) | (byte_addr >> 8);
+	cmd[2] = byte_addr;
+}
+
+static int winbond_read_fast(struct spi_flash *flash,
+		u32 offset, size_t len, void *buf)
+{
+	struct winbond_spi_flash *stm = to_winbond_spi_flash(flash);
+	u8 cmd[5];
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	winbond_build_address(stm, cmd + 1, offset);
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int winbond_write(struct spi_flash *flash,
+		u32 offset, size_t len, const void *buf)
+{
+	struct winbond_spi_flash *stm = to_winbond_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	unsigned int page_shift;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_shift = stm->params->l2_page_size;
+	page_size = (1 << page_shift);
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_W25_PP;
+		cmd[1] = page_addr >> (16 - page_shift);
+		cmd[2] = page_addr << (page_shift - 8) | (byte_addr >> 8);
+		cmd[3] = byte_addr;
+		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+			buf + actual,
+			cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_W25_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			goto out;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+				buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: Winbond Page Program failed\n");
+			goto out;
+		}
+
+		ret = winbond_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: Winbond page programming timed out\n");
+			goto out;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: Winbond: Successfully programmed %u bytes @ 0x%x\n",
+			len, offset);
+	ret = 0;
+
+out:
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int winbond_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct winbond_spi_flash *stm = to_winbond_spi_flash(flash);
+	unsigned long sector_size;
+	unsigned int page_shift;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	page_shift = stm->params->l2_page_size;
+	sector_size = (1 << page_shift) * stm->params->pages_per_sector;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	len /= sector_size;
+	cmd[0] = CMD_W25_SE;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	for (actual = 0; actual < len; actual++) {
+		winbond_build_address(stm, &cmd[1], offset + actual * sector_size);
+		printf("Erase: %02x %02x %02x %02x\n",
+				cmd[0], cmd[1], cmd[2], cmd[3]);
+
+		ret = spi_flash_cmd(flash->spi, CMD_W25_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			goto out;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Winbond sector erase failed\n");
+			goto out;
+		}
+
+		ret = winbond_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: Winbond sector erase timed out\n");
+			goto out;
+		}
+	}
+
+	debug("SF: Winbond: Successfully erased %u bytes @ 0x%x\n",
+			len * sector_size, offset);
+	ret = 0;
+
+out:
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+#endif // else end for CONFIG_AMLOGIC_SPI_FLASH
+
+struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode)
+{
+	const struct winbond_spi_flash_params *params;
+	unsigned page_size;
+	struct winbond_spi_flash *stm;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(winbond_spi_flash_table); i++) {
+		params = &winbond_spi_flash_table[i];
+		if (params->id == ((idcode[1] << 8) | idcode[2]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(winbond_spi_flash_table)) {
+		debug("SF: Unsupported Winbond ID %02x%02x\n",
+				idcode[1], idcode[2]);
+		return NULL;
+	}
+
+	stm = malloc(sizeof(struct winbond_spi_flash));
+	if (!stm) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	stm->params = params;
+	stm->flash.spi = spi;
+	stm->flash.name = params->name;
+
+	/* Assuming power-of-two page size initially. */
+	page_size = 1 << params->l2_page_size;
+
+	stm->flash.write = winbond_write;
+	stm->flash.erase = winbond_erase;
+	stm->flash.read = winbond_read_fast;
+	stm->flash.size = page_size * params->pages_per_sector
+				* params->sectors_per_block
+				* params->nr_blocks;
+
+	printf("SF: Detected %s with page size %u, total ",
+	       params->name, page_size);
+	print_size(stm->flash.size, "\n");
+
+	return &stm->flash;
+}
+
diff --git a/drivers/nand/Kconfig b/drivers/nand/Kconfig
new file mode 100644
index 0000000..0fe6798
--- /dev/null
+++ b/drivers/nand/Kconfig
@@ -0,0 +1,8 @@
+config AML_NAND
+	bool "AML Nand Support"
+	help
+	  Enable support for the Amlogic NAND controller.
+
+config SECURE_NAND
+	bool "secure nand"
+	depends on AML_NAND
diff --git a/drivers/nand/Makefile b/drivers/nand/Makefile
new file mode 100644
index 0000000..8261688
--- /dev/null
+++ b/drivers/nand/Makefile
@@ -0,0 +1,14 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+
+#obj-$(CONFIG_AML_NAND) := aml_nand.o
+obj-$(CONFIG_AML_NAND) += dev/
+#obj-$(CONFIG_AML_NAND) += logic/
+obj-$(CONFIG_AML_NAND) += logiclib/
+obj-$(CONFIG_AML_NAND) += phy/
+
diff --git a/drivers/nand/dev/Makefile b/drivers/nand/dev/Makefile
new file mode 100644
index 0000000..d6c55b2
--- /dev/null
+++ b/drivers/nand/dev/Makefile
@@ -0,0 +1,14 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+EXTRA_CFLAGS = -Idrivers/nand/include/
+
+obj-$(CONFIG_AML_NAND) += aml_nand_dev.o
+
+aml_nand_dev-y := amlnf_config.o amlnf_ctrl.o amlnf_dev.o cmd_amlnf.o amlnf_env.o amlnf_dtb.o amlnf_key.o cmd_amlnf_test.o
+#cmd_amlnf_test.o
+
diff --git a/drivers/nand/dev/amlnf_config.c b/drivers/nand/dev/amlnf_config.c
new file mode 100644
index 0000000..c793cdc
--- /dev/null
+++ b/drivers/nand/dev/amlnf_config.c
@@ -0,0 +1,203 @@
+
+#include "../include/amlnf_dev.h"
+#include "../include/phynand.h"
+#include "storage.h"
+/***********************************************************************
+ * Nand Config
+ **********************************************************************/
+
+struct amlnf_partition *amlnand_config = NULL;
+#if (AML_CFG_INSIDE_PARTTBL)
+/* fixme, port from common/partition_table.c & storage.c */
+static struct partitions * part_table = NULL;
+#define SZ_1M                           0x00100000
+
+struct partitions partition_table[] = {
+		{
+			.name = "logo",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "recovery",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "dtb",
+			.size = 8*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "tee",
+			.size = 8*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "crypt",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "misc",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+#ifdef CONFIG_INSTABOOT
+		{
+			.name = "instaboot",
+			.size = 1024*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+#endif
+		{
+			.name = "boot",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "system",
+			.size = 1024*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "cache",
+			.size = 512*SZ_1M,
+			.mask_flags = STORE_CACHE,
+		},
+		{
+			.name = "data",
+			.size = NAND_PART_SIZE_FULL,
+			.mask_flags = STORE_DATA,
+		},
+};
+#else
+extern struct partitions * part_table;
+#define SZ_1M                           0x00100000
+struct partitions def_partition_table[] = {
+		{
+			.name = "logo",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "recovery",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "dtb",
+			.size = 8*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "tee",
+			.size = 8*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "crypt",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "misc",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+#ifdef CONFIG_INSTABOOT
+		{
+			.name = "instaboot",
+			.size = 1024*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+#endif
+		{
+			.name = "boot",
+			.size = 32*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "system",
+			.size = 1024*SZ_1M,
+			.mask_flags = STORE_CODE,
+		},
+		{
+			.name = "cache",
+			.size = 512*SZ_1M,
+			.mask_flags = STORE_CACHE,
+		},
+		{
+			.name = "data",
+			.size = NAND_PART_SIZE_FULL,
+			.mask_flags = STORE_DATA,
+		},
+};
+#endif /* AML_CFG_INSIDE_PARTTBL */
+
+#if (AML_CFG_DTB_RSV_EN)
+extern int amlnf_dtb_init_partitions(struct amlnand_chip *aml_chip);
+extern int amlnf_detect_dtb_partitions(struct amlnand_chip *aml_chip);
+#endif
+
+int amlnand_get_partition_table(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	u32	config_size;
+	int i;
+
+	/* fixme, debug code for pxp.... */
+#if (AML_CFG_INSIDE_PARTTBL)
+	part_table = partition_table;
+#endif
+	aml_nand_msg("outside dtb: %p", part_table);
+	if (part_table == NULL) {
+		aml_nand_msg("using dtb on nand");
+		/* fixme, not initialized by outside then using dtb of our self. */
+	#if (AML_CFG_DTB_RSV_EN)
+		ret = amlnf_dtb_init_partitions(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("amlnf dtb init failed");
+			return -NAND_FAILED;
+			/* do not use default partition_table anyway!*/
+			/*ret = -NAND_FAILED;*/
+		}
+	#else
+		return -NAND_FAILED;
+	#endif
+	}
+	else{
+		amlnf_detect_dtb_partitions(aml_chip);
+	}
+
+	if (ret) {
+		part_table = def_partition_table;
+		aml_nand_msg("%s() %p, using default one to bootup", __func__, part_table);
+		ret = 0;
+	}
+	config_size = MAX_NAND_PART_NUM * sizeof(struct amlnf_partition);
+	amlnand_config = aml_nand_malloc(config_size);
+	if (!amlnand_config) {
+		aml_nand_dbg("amlnand_config: malloc failed!");
+		ret = -NAND_MALLOC_FAILURE;
+	}
+
+	/* show_partition_table(); */
+	//memcpy(amlnand_config, part_table, config_size);
+	/* do not use memcpy avoid further change */
+	for (i = 0; i < MAX_PART_NUM; i++) {
+		memcpy(amlnand_config[i].name, part_table[i].name, MAX_PART_NAME_LEN);
+		amlnand_config[i].size = part_table[i].size;
+		amlnand_config[i].offset = part_table[i].offset;
+		amlnand_config[i].mask_flags = part_table[i].mask_flags;
+
+		if (part_table[i].size == NAND_PART_SIZE_FULL)
+			break;
+	}
+
+	return ret;
+}
+
+
+
+
diff --git a/drivers/nand/dev/amlnf_ctrl.c b/drivers/nand/dev/amlnf_ctrl.c
new file mode 100644
index 0000000..182c621
--- /dev/null
+++ b/drivers/nand/dev/amlnf_ctrl.c
@@ -0,0 +1,744 @@
+
+/*
+ * Aml
+ *
+ * (C) 2012 8
+ */
+#include "../include/phynand.h"
+#include <asm/arch/secure_apb.h>
+
+extern int aml_ubootenv_init(struct amlnand_chip *aml_chip);
+#if (AML_CFG_DTB_RSV_EN)
+extern int amlnf_dtb_init(struct amlnand_chip *aml_chip);
+#endif
+extern int amlnand_save_info_by_name(struct amlnand_chip *aml_chip,unsigned char * info,unsigned char * buf, u8 * name,unsigned size);
+extern int aml_nand_update_key(struct amlnand_chip * aml_chip, char *key_ptr);
+extern int aml_nand_update_ubootenv(struct amlnand_chip * aml_chip, char *env_ptr);
+
+#ifdef AML_NAND_UBOOT
+struct list_head nf_dev_list;
+struct list_head nlogic_dev_list;
+#endif /* AML_NAND_UBOOT */
+
+struct bch_desc bch_list_m8[MAX_ECC_MODE_NUM] = {
+	[0] = ECC_INFORMATION("NAND_RAW_MODE",
+		NAND_ECC_SOFT_MODE,
+		0,
+		0,
+		0,
+		0),
+	[1] = ECC_INFORMATION("NAND_BCH8_MODE",
+		NAND_ECC_BCH8_MODE,
+		NAND_ECC_UNIT_SIZE,
+		NAND_BCH8_ECC_SIZE,
+		2,
+		1),
+	[2] = ECC_INFORMATION("NAND_BCH8_1K_MODE" ,
+		NAND_ECC_BCH8_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH8_1K_ECC_SIZE,
+		2,
+		2),
+	[3] = ECC_INFORMATION("NAND_BCH24_1K_MODE" ,
+		NAND_ECC_BCH24_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH24_1K_ECC_SIZE,
+		2,
+		3),
+	[4] = ECC_INFORMATION("NAND_BCH30_1K_MODE" ,
+		NAND_ECC_BCH30_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH30_1K_ECC_SIZE,
+		2,
+		4),
+	[5] = ECC_INFORMATION("NAND_BCH40_1K_MODE" ,
+		NAND_ECC_BCH40_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH40_1K_ECC_SIZE,
+		2,
+		5),
+	[6] = ECC_INFORMATION("NAND_BCH50_1K_MODE" ,
+		NAND_ECC_BCH50_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH50_1K_ECC_SIZE,
+		2,
+		6),
+	[7] = ECC_INFORMATION("NAND_BCH60_1K_MODE" ,
+		NAND_ECC_BCH60_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH60_1K_ECC_SIZE,
+		2,
+		7),
+	[8] = ECC_INFORMATION("NAND_SHORT_MODE" ,
+		NAND_ECC_SHORT_MODE,
+		NAND_ECC_UNIT_SHORT,
+		NAND_BCH60_1K_ECC_SIZE,
+		2,
+		8),
+};
+
+struct bch_desc bch_list[MAX_ECC_MODE_NUM] = {
+	[0] = ECC_INFORMATION("NAND_RAW_MODE",
+		NAND_ECC_SOFT_MODE,
+		0,
+		0,
+		0,
+		0),
+	[1] = ECC_INFORMATION("NAND_BCH8_MODE",
+		NAND_ECC_BCH8_MODE,
+		NAND_ECC_UNIT_SIZE,
+		NAND_BCH8_ECC_SIZE,
+		2,
+		1),
+	[2] = ECC_INFORMATION("NAND_BCH8_1K_MODE" ,
+		NAND_ECC_BCH8_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH8_1K_ECC_SIZE,
+		2,
+		2),
+	[3] = ECC_INFORMATION("NAND_BCH16_1K_MODE" ,
+		NAND_ECC_BCH16_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH16_1K_ECC_SIZE,
+		2,
+		3),
+	[4] = ECC_INFORMATION("NAND_BCH24_1K_MODE" ,
+		NAND_ECC_BCH24_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH24_1K_ECC_SIZE,
+		2,
+		4),
+	[5] = ECC_INFORMATION("NAND_BCH30_1K_MODE" ,
+		NAND_ECC_BCH30_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH30_1K_ECC_SIZE,
+		2,
+		5),
+	[6] = ECC_INFORMATION("NAND_BCH40_1K_MODE" ,
+		NAND_ECC_BCH40_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH40_1K_ECC_SIZE,
+		2,
+		6),
+	[7] = ECC_INFORMATION("NAND_BCH60_1K_MODE" ,
+		NAND_ECC_BCH60_1K_MODE,
+		NAND_ECC_UNIT_1KSIZE,
+		NAND_BCH60_1K_ECC_SIZE,
+		2,
+		7),
+	[8] = ECC_INFORMATION("NAND_SHORT_MODE" ,
+		NAND_ECC_SHORT_MODE,
+		NAND_ECC_UNIT_SHORT,
+		NAND_BCH60_1K_ECC_SIZE,
+		2,
+		8),
+};
+
+
+#ifndef AML_NAND_UBOOT
+static dma_addr_t nfdata_dma_addr;
+static dma_addr_t nfinfo_dma_addr;
+spinlock_t amlnf_lock;
+wait_queue_head_t amlnf_wq;
+#endif
+
+struct list_head nphy_dev_list;
+struct list_head nf_dev_list;
+
+void *aml_nand_malloc(u32 size)
+{
+	return kmalloc(size, GFP_KERNEL);
+}
+
+void aml_nand_free(void *ptr)
+{
+	kfree(ptr);
+}
+
+#ifndef AML_NAND_UBOOT
+void *amlnf_dma_malloc(uint32 size, unsigned char flag)
+{
+	if (flag == 0) //data
+		return dma_alloc_coherent(NULL, size, &nfdata_dma_addr, GFP_KERNEL);
+	if (flag == 1) //usr
+		return dma_alloc_coherent(NULL, size, &nfinfo_dma_addr, GFP_KERNEL);
+}
+
+void amlnf_dma_free(const void *ptr, u32 size, u8 flag)
+{
+	if (flag == 0) /* data */
+		dma_free_coherent(NULL, size, (void *)ptr, nfdata_dma_addr);
+	if (flag == 1) /* usr */
+		dma_free_coherent(NULL, size, (void *)ptr, nfinfo_dma_addr);
+}
+#endif
+
+/*
+ * under os.
+ */
+#ifndef AML_NAND_UBOOT
+int amlphy_prepare(u32 flag)
+{
+	spin_lock_init(&amlnf_lock);
+	init_waitqueue_head(&amlnf_wq);
+
+	return 0;
+}
+
+int phydev_suspend(struct amlnand_phydev *phydev)
+{
+    struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+#ifdef AML_NAND_RB_IRQ
+	u32 flags;
+#endif
+
+	if (!strncmp((char *)phydev->name,
+			NAND_BOOT_NAME,
+			strlen((const char *)NAND_BOOT_NAME)))
+		return 0;
+	aml_nand_dbg("phydev_suspend: entered!");
+#ifdef AML_NAND_RB_IRQ
+	spin_lock_irqsave(&amlnf_lock, flags);
+#else
+	spin_lock(&amlnf_lock);
+#endif
+	set_chip_state(aml_chip, CHIP_PM_SUSPENDED);
+#ifdef AML_NAND_RB_IRQ
+	spin_unlock_irqrestore(&amlnf_lock, flags);
+#else
+	spin_unlock(&amlnf_lock);
+#endif
+	return 0;
+
+}
+
+void phydev_resume(struct amlnand_phydev *phydev)
+{
+	amlchip_resume(phydev);
+	return;
+}
+
+int nand_idleflag = 0;
+#define	NAND_CTRL_NONE_RB	(1<<1)
+void nand_get_chip(void *chip)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)chip;
+	struct hw_controller *controller = &(aml_chip->controller);
+	int retry = 0, ret;
+
+	while (1) {
+		/* mutex_lock(&spi_nand_mutex); */
+		nand_idleflag = 1;
+		if ((controller->option & NAND_CTRL_NONE_RB) == 0)
+			ret = pinctrl_select_state(aml_chip->nand_pinctrl ,
+				aml_chip->nand_rbstate);
+		else
+			ret = pinctrl_select_state(aml_chip->nand_pinctrl ,
+				aml_chip->nand_norbstate);
+		if (ret < 0)
+			aml_nand_msg("%s:%d %s can't get pinctrl",
+				__func__,
+				__LINE__,
+				dev_name(&aml_chip->device));
+		else
+			break;
+
+		if (retry++ > 10)
+			aml_nand_msg("get pin fail over 10 times retry=%d",
+				retry);
+	}
+	return;
+}
+
+void nand_release_chip(void *chip)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)chip;
+	struct hw_controller *controller = &(aml_chip->controller);
+	int ret;
+
+	if (nand_idleflag) {
+		/* enter standby state. */
+		controller->enter_standby(controller);
+		ret = pinctrl_select_state(aml_chip->nand_pinctrl,
+			aml_chip->nand_idlestate);
+		if (ret < 0)
+			aml_nand_msg("select idle state error");
+		nand_idleflag = 0;
+		/* mutex_unlock(&spi_nand_mutex); */
+	}
+}
+
+/**
+ * amlnand_get_device - [GENERIC] Get chip for selected access
+ *
+ * Get the device and lock it for exclusive access
+ */
+int amlnand_get_device(struct amlnand_chip *aml_chip,
+	enum chip_state_t new_state)
+{
+#ifdef AML_NAND_RB_IRQ
+	u32 flags;
+#endif
+	DECLARE_WAITQUEUE(wait, current);
+retry:
+#ifdef AML_NAND_RB_IRQ
+	spin_lock_irqsave(&amlnf_lock, flags);
+#else
+	spin_lock(&amlnf_lock);
+#endif
+	if (get_chip_state(aml_chip) == CHIP_READY) {
+		set_chip_state(aml_chip, new_state);
+#ifdef AML_NAND_RB_IRQ
+		spin_unlock_irqrestore(&amlnf_lock, flags);
+#else
+		spin_unlock(&amlnf_lock);
+#endif
+		/* set nand pinmux here */
+		nand_get_chip(aml_chip);
+		return 0;
+	}
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&amlnf_wq, &wait);
+#ifdef AML_NAND_IRQ_MODE
+	spin_unlock_irqrestore(&amlnf_lock, flags);
+#else
+	spin_unlock(&amlnf_lock);
+#endif
+	schedule();
+	remove_wait_queue(&amlnf_wq, &wait);
+
+	goto retry;
+}
+
+/**
+ * nand_release_device - [GENERIC] release chip
+ * @aml_chip:	nand chip structure
+ *
+ * Deselect, release chip lock and wake up anyone waiting on the device
+ */
+void amlnand_release_device(struct amlnand_chip *aml_chip)
+{
+#ifdef AML_NAND_RB_IRQ
+	u32 flags;
+#endif
+	/* Release the controller and the chip */
+#ifdef AML_NAND_RB_IRQ
+	spin_lock_irqsave(&amlnf_lock, flags);
+#else
+	spin_lock(&amlnf_lock);
+#endif
+	set_chip_state(aml_chip, CHIP_READY);
+	wake_up(&amlnf_wq);
+#ifdef AML_NAND_RB_IRQ
+	spin_unlock_irqrestore(&amlnf_lock, flags);
+#else
+	spin_unlock(&amlnf_lock);
+#endif
+	/* clear nand pinmux here */
+	nand_release_chip(aml_chip);
+}
+
+#else /* AML_NAND_UBOOT, uboot ways below */
+
+void nand_get_chip(void *chip)
+{
+	/* fixme, */
+
+	/* pull up enable */
+	aml_nand_dbg("PAD_PULL_UP_EN_REG2 0x%x, PAD_PULL_UP_REG2 0x%x, PERIPHS_PIN_MUX_4 0x%x", P_PAD_PULL_UP_EN_REG2, P_PAD_PULL_UP_REG2, P_PERIPHS_PIN_MUX_4);
+
+	AMLNF_SET_REG_MASK(P_PAD_PULL_UP_EN_REG2, 0x87ff);
+	/* pull direction, dqs pull down */
+	AMLNF_SET_REG_MASK(P_PAD_PULL_UP_REG2, 0x8700);
+	/* switch pinmux */
+	//AMLNF_SET_REG_MASK(P_PERIPHS_PIN_MUX_4, ((0x1<<30) | (0x3fff<<20)));
+	AMLNF_SET_REG_MASK(P_PERIPHS_PIN_MUX_4, ((0x1<<30) | (0x3ff<<20)));
+	AMLNF_CLEAR_REG_MASK(P_PERIPHS_PIN_MUX_0, (0x1 << 19));
+	AMLNF_CLEAR_REG_MASK(P_PERIPHS_PIN_MUX_4, (0x3 << 18));
+	AMLNF_CLEAR_REG_MASK(P_PERIPHS_PIN_MUX_5, (0xF));
+	aml_nand_dbg("PAD_PULL_UP_EN_REG2 0x%x, PAD_PULL_UP_REG2 0x%x, PERIPHS_PIN_MUX_4 0x%x", AMLNF_READ_REG(P_PAD_PULL_UP_EN_REG2), AMLNF_READ_REG(P_PAD_PULL_UP_REG2), AMLNF_READ_REG(P_PERIPHS_PIN_MUX_4));
+	return ;
+}
+
+void nand_release_chip(void *chip)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)chip;
+	struct hw_controller * controller;
+	controller = &aml_chip->controller;
+	NFC_SEND_CMD_STANDBY(controller, 5);
+	/* do not release cs0 & cs1 */
+	//fixme, dbg code here.
+	//AMLNF_CLEAR_REG_MASK(P_PERIPHS_PIN_MUX_2, ((0x33f<<20) | (0x1<< 30)));
+	return;
+}
+
+int amlnand_get_device(struct amlnand_chip *aml_chip, enum chip_state_t new_state)
+{
+	nand_get_chip(aml_chip);
+	set_chip_state(aml_chip, new_state);
+	return 0;
+}
+
+ void amlnand_release_device(struct amlnand_chip *aml_chip)
+{
+	 set_chip_state(aml_chip, CHIP_READY);
+	//clear nand pinmux here
+	nand_release_chip(aml_chip);
+}
+#endif
+
+
+void pinmux_select_chip(unsigned ce_enable, unsigned rb_enable, unsigned flag)
+{
+#ifdef AML_NAND_UBOOT
+	if (!((ce_enable >> 10) & 1))
+		AMLNF_SET_REG_MASK(P_PERIPHS_PIN_MUX_4, (1 << 26));
+	if (!((ce_enable >> 10) & 2))
+		AMLNF_SET_REG_MASK(P_PERIPHS_PIN_MUX_4, (1 << 27));
+	if (!((ce_enable >> 10) & 4))
+		AMLNF_SET_REG_MASK(P_PERIPHS_PIN_MUX_4, (1 << 28));
+	if (!((ce_enable >> 10) & 8))
+		AMLNF_SET_REG_MASK(P_PERIPHS_PIN_MUX_4, (1 << 29));
+
+#endif /*  */
+
+}
+
+void set_nand_core_clk(struct hw_controller *controller, int clk_freq)
+{
+	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GX) {
+		/* basic test code for gxb using 24Mhz, fixme. */
+		//amlnf_write_reg32(controller->nand_clk_reg, 0x81000201); //24Mhz/1
+		if (clk_freq == 200) {
+			/* 1000Mhz/5 = 200Mhz */
+			amlnf_write_reg32(controller->nand_clk_reg, 0x81000245);
+		}
+		else if (clk_freq == 250) {
+			/* 1000Mhz/4 = 250Mhz */
+			amlnf_write_reg32(controller->nand_clk_reg, 0x81000244);
+		} else {
+			/* 1000Mhz/5 = 200Mhz */
+			amlnf_write_reg32(controller->nand_clk_reg, 0x81000245);
+			printk("%s() %d, using default clock setting!\n", __func__, __LINE__);
+		}
+		//printk("clk_reg 0x%x\n", AMLNF_READ_REG(controller->nand_clk_reg));
+		return;
+	} else {
+		printk("cpu type can not support!\n");
+	}
+	return;
+}
+
+void get_sys_clk_rate(struct hw_controller *controller, int *rate)
+{
+	u32 cpu_type;
+#ifndef AML_NAND_UBOOT
+	struct clk *sys_clk;
+#endif
+
+	cpu_type = get_cpu_type();
+	if (cpu_type >= MESON_CPU_MAJOR_ID_M8) {
+		/* 200-250Mhz */
+		set_nand_core_clk(controller, *rate);
+	}
+	return;
+}
+
+/*
+	set nand info into page0_buf
+ */
+void nand_boot_info_prepare(struct amlnand_phydev *phydev,
+	u8 *page0_buf)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct nand_flash *flash = &(aml_chip->flash);
+	/* struct phydev_ops *devops = &(phydev->ops); */
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct en_slc_info *slc_info = NULL;
+	int i, nand_read_info;
+	u32 en_slc, configure_data;
+
+	nand_page0_t * p_nand_page0 = NULL;
+	ext_info_t * p_ext_info = NULL;
+	nand_setup_t * p_nand_setup = NULL;
+
+	slc_info = &(controller->slc_info);
+
+	p_nand_page0 = (nand_page0_t *) page0_buf;
+	p_nand_setup = &p_nand_page0->nand_setup;
+	p_ext_info = &p_nand_page0->ext_info;
+
+
+	configure_data = NFC_CMD_N2M(controller->ran_mode,
+			controller->bch_mode, 0, (controller->ecc_unit >> 3),
+			controller->ecc_steps);
+	/* hynix 2x and lower... */
+	if ((flash->new_type < 10) && (flash->new_type))
+		en_slc = 1;
+	else if (flash->new_type == SANDISK_19NM)
+		en_slc = 2;
+	else
+		en_slc = 0;
+
+	//memset(page0_buf, 0x0, flash->pagesize);
+	memset(p_nand_page0, 0x0, sizeof(nand_page0_t));
+	p_nand_setup->cfg.d32 = (configure_data|(1<<23) | (1<<22) | (2<<20) | (1<<19));
+	printk("cfg.d32 0x%x\n", p_nand_setup->cfg.d32);
+	/* need finish here for romboot retry */
+	p_nand_setup->id = 0;
+	p_nand_setup->max = 0;
+
+	memset(p_nand_page0->page_list,
+		0,
+		NAND_PAGELIST_CNT);
+	if (en_slc) {
+		p_nand_setup->cfg.b.page_list = 1;
+		if (en_slc == 1) {
+			memcpy(p_nand_page0->page_list,
+				(u8 *)(&slc_info->pagelist[1]),
+				NAND_PAGELIST_CNT);
+		} else if (en_slc == 2) {
+			p_nand_setup->cfg.b.a2 = 1;
+			for (i = 1; i < NAND_PAGELIST_CNT; i++)
+				p_nand_page0->page_list[i-1] = i<<1;
+		}
+	}
+
+	/* chip_num occupy the lowest 2 bit */
+	nand_read_info = controller->chip_num;
+
+	p_ext_info->read_info = nand_read_info;
+	p_ext_info->new_type = aml_chip->flash.new_type;
+	p_ext_info->page_per_blk = flash->blocksize / flash->pagesize;
+	p_ext_info->ce_mask = aml_chip->ce_bit_mask;
+	p_ext_info->xlc = 2;
+
+	printk("new_type = 0x%x\n", p_ext_info->new_type);
+	printk("page_per_blk = 0x%x\n", p_ext_info->page_per_blk);
+}
+
+void uboot_set_ran_mode(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct hw_controller *controller = &(aml_chip->controller);
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)
+		controller->ran_mode = 1;
+	else
+		controller->ran_mode = 0;
+}
+
+int aml_sys_info_init(struct amlnand_chip *aml_chip)
+{
+#if (AML_CFG_KEY_RSV_EN)
+	struct nand_arg_info *nand_key = &aml_chip->nand_key;
+#endif
+#ifdef CONFIG_SECURE_NAND
+	struct nand_arg_info *nand_secure = &aml_chip->nand_secure;
+#endif
+#if (AML_CFG_DTB_RSV_EN)
+	struct nand_arg_info *amlnf_dtb = &aml_chip->amlnf_dtb;
+#endif
+	struct nand_arg_info *uboot_env =  &aml_chip->uboot_env;
+	u8 *buf = NULL;
+	u32 buf_size = 0;
+	int ret = 0;
+
+	NAND_LINE
+	if (CONFIG_SECURE_SIZE > CONFIG_KEYSIZE)
+		buf_size = CONFIG_SECURE_SIZE;
+	else
+		buf_size = CONFIG_KEYSIZE;
+	NAND_LINE
+	buf = aml_nand_malloc(buf_size);
+	if (!buf)
+		aml_nand_msg("aml_sys_info_init : malloc failed");
+
+	memset(buf, 0x0, buf_size);
+	NAND_LINE
+#if (AML_CFG_KEY_RSV_EN)
+	if (nand_key->arg_valid == 0) {
+		NAND_LINE
+		ret = aml_key_init(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand key init failed");
+			goto exit_error;
+		}
+	}
+#endif
+
+#ifdef CONFIG_SECURE_NAND
+	if (nand_secure->arg_valid == 0) {
+		NAND_LINE
+		ret = aml_secure_init(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand secure init failed");
+			goto exit_error;
+		}
+	}
+#endif
+#if (AML_CFG_DTB_RSV_EN)
+	if (amlnf_dtb->arg_valid == 0) {
+		NAND_LINE
+		ret = amlnf_dtb_init(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("amlnf dtb init failed");
+			/* fixme, should go on! */
+			//goto exit_error;
+		}
+	}
+#endif
+	NAND_LINE
+	printk("boot_device_flag %d\n", boot_device_flag);
+	if ((uboot_env->arg_valid == 0) && (boot_device_flag == 1)) {
+		NAND_LINE
+		ret = aml_ubootenv_init(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand uboot env init failed");
+			goto exit_error;
+		}
+	}
+
+#if (AML_CFG_KEY_RSV_EN)
+	if (nand_key->arg_valid == 0) {
+		NAND_LINE
+		ret = amlnand_save_info_by_name(aml_chip,
+			(u8 *)(&(aml_chip->nand_key)),
+			buf,
+			(u8 *)KEY_INFO_HEAD_MAGIC,
+			CONFIG_KEYSIZE);
+		NAND_LINE
+		if (ret < 0) {
+			aml_nand_msg("nand save default key failed");
+			goto exit_error;
+		}
+	}
+#endif
+
+#ifdef CONFIG_SECURE_NAND
+	/*save a empty value! */
+	if (nand_secure->arg_valid == 0) {
+		NAND_LINE
+		ret = amlnand_save_info_by_name(aml_chip,
+			(u8 *)&(aml_chip->nand_secure),
+			buf,
+			(u8 *)SECURE_INFO_HEAD_MAGIC,
+			CONFIG_SECURE_SIZE);
+		if (ret < 0) {
+			aml_nand_msg("nand save default secure_ptr failed");
+			goto exit_error;
+		}
+	}
+#endif
+#if (AML_CFG_DTB_RSV_EN)
+	/* fixme, no need to save a empty dtb. */
+#endif
+	NAND_LINE
+exit_error:
+	kfree(buf);
+	buf = NULL;
+	return ret;
+}
+
+int aml_sys_info_error_handle(struct amlnand_chip *aml_chip)
+{
+
+#if (AML_CFG_KEY_RSV_EN)
+	 if ((aml_chip->nand_key.arg_valid == 1) &&
+		(aml_chip->nand_key.update_flag)) {
+		aml_nand_update_key(aml_chip, NULL);
+		aml_chip->nand_key.update_flag = 0;
+		aml_nand_msg("NAND UPDATE CKECK  : ");
+		aml_nand_msg("arg %s:arg_valid=%d,blk_addr=%d,page_addr=%d",
+			"nandkey",
+			aml_chip->nand_key.arg_valid,
+			aml_chip->nand_key.valid_blk_addr,
+			aml_chip->nand_key.valid_page_addr);
+	}
+#endif
+
+#ifdef CONFIG_SECURE_NAND
+	if ((aml_chip->nand_secure.arg_valid == 1)
+		&& (aml_chip->nand_secure.update_flag)) {
+		aml_nand_update_secure(aml_chip, NULL);
+		aml_chip->nand_secure.update_flag = 0;
+		aml_nand_msg("NAND UPDATE CKECK  : ");
+		aml_nand_msg("arg%s:arg_valid=%d,blk_addr=%d,page_addr=%d",
+			"nandsecure",
+			aml_chip->nand_secure.arg_valid,
+			aml_chip->nand_secure.valid_blk_addr,
+			aml_chip->nand_secure.valid_page_addr);
+	}
+#endif
+
+#if (AML_CFG_DTB_RSV_EN)
+	if ((aml_chip->amlnf_dtb.arg_valid == 1)
+		&& (aml_chip->amlnf_dtb.update_flag)) {
+		aml_nand_update_dtb(aml_chip, NULL);
+		aml_chip->amlnf_dtb.update_flag = 0;
+		aml_nand_msg("NAND UPDATE CKECK  : ");
+		aml_nand_msg("arg%s:arg_valid=%d,blk_addr=%d,page_addr=%d",
+			"dtb",
+			aml_chip->amlnf_dtb.arg_valid,
+			aml_chip->amlnf_dtb.valid_blk_addr,
+			aml_chip->amlnf_dtb.valid_page_addr);
+	}
+#endif
+	if ((aml_chip->uboot_env.arg_valid == 1)
+		&& (aml_chip->uboot_env.update_flag)) {
+		aml_nand_update_ubootenv(aml_chip, NULL);
+		aml_chip->uboot_env.update_flag = 0;
+		aml_nand_msg("NAND UPDATE CKECK  : ");
+		aml_nand_msg("arg%s:arg_valid=%d,blk_addr=%d,page_addr=%d",
+			"ubootenv",
+			aml_chip->uboot_env.arg_valid,
+			aml_chip->uboot_env.valid_blk_addr,
+			aml_chip->uboot_env.valid_page_addr);
+	}
+	return 0;
+}
+
+#ifdef AML_NAND_UBOOT
+/*fixme, */
+extern int info_disprotect;
+
+void amlnf_disprotect(char * name)
+{
+	//struct amlnand_chip *aml_chip = aml_nand_chip;
+
+/* #ifdef CONFIG_SECURITYKEY */
+	if (strcmp((const char *)name, "key") == 0) {
+		aml_nand_msg("disprotect key");
+		info_disprotect |= DISPROTECT_KEY;
+		aml_nand_chip->protect |= DISPROTECT_KEY;
+	}
+/*#endif */
+
+#ifdef CONFIG_SECURE_NAND
+	if (strcmp((const char *)name, "secure") == 0) {
+		aml_nand_msg("disprotect secure");
+		info_disprotect |= DISPROTECT_SECURE;
+		aml_nand_chip->protect |= DISPROTECT_SECURE;
+	}
+#endif
+
+	if (strcmp((const char *)name, "fbbt") == 0) {
+		aml_nand_msg("disprotect fbbt");
+		info_disprotect |= DISPROTECT_FBBT;
+		aml_nand_chip->protect |= DISPROTECT_FBBT;
+	}
+	if (strcmp((const char *)name, "hynix") == 0) {
+		aml_nand_msg("disprotect hynix");
+		info_disprotect |= DISPROTECT_HYNIX;
+		aml_nand_chip->protect |= DISPROTECT_HYNIX;
+	}
+	if (strcmp((const char *)name, "dbg") == 0) {
+		aml_nand_msg("disprotect dbg");
+		info_disprotect |= DISPROTECT_DBG;
+		aml_nand_chip->protect |= DISPROTECT_DBG;
+	}
+	aml_nand_msg("disprotect 0x%08x", info_disprotect);
+	return ;
+}
+
+#endif
diff --git a/drivers/nand/dev/amlnf_dev.c b/drivers/nand/dev/amlnf_dev.c
new file mode 100644
index 0000000..3859eaf
--- /dev/null
+++ b/drivers/nand/dev/amlnf_dev.c
@@ -0,0 +1,932 @@
+/*
+ * Aml nftl dev
+ *
+ * (C) 2012 8
+ */
+
+#include "../include/amlnf_dev.h"
+#include "partition_table.h"
+int boot_device_flag = 0;
+struct aml_nand_device *aml_nand_dev = NULL;
+
+
+
+int is_phydev_off_adjust(void)
+{
+	int ret = 0;
+	#ifdef NAND_ADJUST_PART_TABLE
+		ret = 1;
+	#endif
+	return  ret ;
+}
+
+int get_adjust_block_num(void)
+{
+	int ret = 0;
+	#ifdef NAND_ADJUST_PART_TABLE
+		ret = ADJUST_BLOCK_NUM;
+	#endif
+	return	ret ;
+}
+
+int amlnf_get_logicdev(struct amlnf_logicdev_t *amlnf_logicdev)
+{
+#ifndef AML_NAND_UBOOT
+		mutex_lock(&amlnf_logicdev->lock);
+#endif
+	return 0;
+}
+
+int amlnf_free_logicdev(struct amlnf_logicdev_t *amlnf_logicdev)
+{
+#ifndef AML_NAND_UBOOT
+	mutex_unlock(&amlnf_logicdev->lock);
+#endif
+	return 0;
+}
+
+
+/*****************************************************************************
+*Name         :
+*Description  :
+*Parameter    :
+*Return       :
+*Note         :
+*****************************************************************************/
+
+#ifndef AML_NAND_UBOOT
+
+static struct class_attribute phydev_class_attrs[] = {
+	__ATTR(info, S_IRUGO | S_IWUSR, show_nand_info, NULL),
+	__ATTR(verify, S_IRUGO | S_IWUSR, NULL, verify_nand_page),
+	__ATTR(dump, S_IRUGO | S_IWUSR, NULL, dump_nand_page),
+	__ATTR(bbt_table, S_IRUGO | S_IWUSR, NULL, show_bbt_table),
+	__ATTR(test_sync_flag, S_IRUGO | S_IWUSR, NULL, change_test_sync_flag),
+	__ATTR(page_read, S_IRUGO | S_IWUSR, NULL, nand_page_read),
+	__ATTR(page_write, S_IRUGO | S_IWUSR, NULL, nand_page_write),
+	__ATTR(version, S_IRUGO | S_IWUSR, show_amlnf_version_info, NULL),
+	__ATTR_NULL
+};
+
+#if 0
+static struct class_attribute logicdev_class_attrs[] = {
+	__ATTR(part, S_IRUGO , show_part_struct, NULL),
+	__ATTR(list, S_IRUGO , show_list, NULL),
+	__ATTR(gcall, S_IRUGO , do_gc_all, NULL),
+	__ATTR(gcone, S_IRUGO , do_gc_one, NULL),
+	__ATTR(test, S_IRUGO | S_IWUSR , NULL, do_test),
+	__ATTR_NULL
+};
+
+static struct class_attribute nfdev_class_attrs[] = {
+	__ATTR(debug, S_IRUGO , nfdev_debug, NULL),
+	__ATTR_NULL
+};
+#endif
+
+
+#if 0
+static struct class phydev_class = {
+	.name = "amlphydev",
+	.owner = THIS_MODULE,
+	.suspend = phydev_cls_suspend,
+	.resume = phydev_cls_resume,
+};
+#endif
+
+int amlnf_pdev_register(struct amlnand_phydev *phydev)
+{
+	int ret = 0;
+	/* phydev->dev.class = &phydev_class; */
+	dev_set_name(&phydev->dev, phydev->name, 0);
+	dev_set_drvdata(&phydev->dev, phydev);
+	ret = device_register(&phydev->dev);
+	if (ret != 0) {
+		aml_nand_msg("device register failed for %s", phydev->name);
+		aml_nand_free(phydev);
+		goto exit_error0;
+	}
+
+	phydev->cls.name =
+		aml_nand_malloc(strlen((const char *)phydev->name)+8);
+	snprintf((char *)phydev->cls.name,
+		(MAX_DEVICE_NAME_LEN+8),
+		 "%s%s",
+		 "phy_",
+		 (char *)(phydev->name));
+	phydev->cls.class_attrs = phydev_class_attrs;
+	ret = class_register(&phydev->cls);
+	if (ret) {
+		aml_nand_msg("class register nand_class fail for %s",
+			phydev->name);
+		goto exit_error1;
+	}
+	return 0;
+exit_error1:
+	aml_nand_free(phydev->cls.name);
+exit_error0:
+	return ret;
+}
+
+
+static int amlnf_blk_open(struct block_device *bdev, fmode_t mode)
+{
+	return 0;
+}
+
+static void amlnf_blk_release(struct gendisk *disk, fmode_t mode)
+{
+	return;
+}
+
+
+static int amlnf_blk_getgeo(struct block_device *bdev, struct hd_geometry *geo)
+{
+	return 0;
+}
+
+static int amlnf_blk_ioctl(struct block_device *bdev, fmode_t mode,
+			      u32 cmd, u32 arg)
+{
+	return 0;
+}
+
+
+static const struct block_device_operations amlnf_blk_ops = {
+	.owner		= THIS_MODULE,
+	.open		= amlnf_blk_open,
+	.release	= amlnf_blk_release,
+	.ioctl		= amlnf_blk_ioctl,
+	.getgeo		= amlnf_blk_getgeo,
+};
+
+#define blk_queue_plugged(q)    test_bit(18, &(q)->queue_flags)
+
+
+/*****************************************************************************
+*Name         :
+*Description  :
+*Parameter    :
+*Return       :
+*Note         : for kernel; for boot is in logic\aml_nftl_init.c
+*****************************************************************************/
+int amlnf_logic_init(u32 flag)
+{
+	struct amlnand_phydev *phydev = NULL;
+	int ret = 0;
+
+	aml_nand_msg("amlnand_add_nftl:");
+	/* amlnand_show_dev_partition(aml_chip); */
+	list_for_each_entry(phydev, &nphy_dev_list, list) {
+		if (phydev == NULL)
+			break;
+		if (strncmp((char *)phydev->name,
+			NAND_BOOT_NAME,
+			strlen((const char *)NAND_BOOT_NAME))) {
+			ret = add_ntd_partitions(phydev);
+			if (ret < 0) {
+				aml_nand_msg("nand add nftl failed");
+				goto exit_error;
+			}
+		}
+		if (!strncmp((char *)phydev->name,
+			NAND_BOOT_NAME,
+			strlen((const char *)NAND_BOOT_NAME))) {
+			ret = boot_device_register(phydev);
+			if (ret < 0) {
+				aml_nand_msg("boot device registe failed");
+				goto exit_error;
+			}
+		}
+	}
+exit_error:
+	return ret;
+}
+
+static ssize_t nand_version_get(struct class *class,
+	struct class_attribute *attr,
+	char *buf)
+{
+	sprintf(buf, "%d", DRV_PHY_VERSION);
+	return 0;
+}
+
+static void show_partition_table(struct partitions *table)
+{
+	int i = 0;
+	struct partitions *par_table = NULL;
+
+	aml_nand_msg("show partition table:");
+
+	for (i = 0; i < MAX_PART_NUM; i++) {
+		par_table = &table[i];
+		if (par_table->size == -1) {
+			aml_nand_msg("part: %d, name: %10s, size: %-4s",
+				i,
+				par_table->name,
+				"end");
+			break;
+		} else
+			aml_nand_msg("part: %d, name : %10s, size : %-4llx",
+				i,
+				par_table->name,
+				par_table->size);
+	}
+	return;
+}
+
+static ssize_t nand_part_table_get(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	struct amlnand_phydev *phydev = NULL;
+	struct amlnand_chip *aml_chip = NULL;
+	struct nand_config *config = NULL;
+	struct dev_para *dev_paramt = NULL;
+	struct partitions *part_table = NULL;
+	int i = 0, j = 0, k = 0, m = 0, tmp_num = 0;
+
+	list_for_each_entry(phydev, &nphy_dev_list, list) {
+		if ((phydev != NULL)
+			&& (!strncmp((char *)phydev->name,
+				NAND_CODE_NAME,
+				strlen((const char *)NAND_CODE_NAME))))
+			break;
+	}
+
+	aml_chip = (struct amlnand_chip *)phydev->priv;
+	config =  aml_chip->config_ptr;
+
+	part_table = aml_nand_malloc(MAX_PART_NUM*sizeof(struct partitions));
+	if (!part_table) {
+		aml_nand_msg("nand_part_table_get : malloc failed");
+		return 0;
+	}
+	memset(part_table, 0x0, MAX_PART_NUM*sizeof(struct partitions));
+
+	if (boot_device_flag == 1) {
+		i += 1;
+		tmp_num = i;
+	}
+
+	for (; i < PHY_DEV_NUM+1; i++) {
+		dev_paramt = &config->dev_para[i];
+		if ((!strncmp((char *)dev_paramt->name,
+				NAND_CODE_NAME,
+				strlen((const char *)NAND_CODE_NAME)))) {
+			for (j = 0; j < dev_paramt->nr_partitions; j++) {
+				memcpy(&(part_table[j].name),
+					dev_paramt->partitions[j].name,
+					MAX_NAND_PART_NAME_LEN);
+				part_table[j].size =
+					dev_paramt->partitions[j].size;
+				part_table[j].offset =
+					dev_paramt->partitions[j].offset;
+				part_table[j].mask_flags =
+					dev_paramt->partitions[j].mask_flags;
+				/*
+				aml_nand_msg("CODE: partiton name %s, size %llx,
+				offset %llx maskflag %d",
+				part_table[j].name,
+				part_table[j].size,
+				part_table[j].offset,
+				part_table[j].mask_flags);
+				*/
+			}
+			break;
+		}
+	}
+
+	i = tmp_num;
+	for (; i < PHY_DEV_NUM+1; i++) {
+		dev_paramt = &config->dev_para[i];
+		/*
+		aml_nand_msg("cache : dev_paramt name %s ",dev_paramt->name);
+		*/
+		if ((!strncmp((char *)dev_paramt->name,
+			NAND_CACHE_NAME,
+			strlen((const char *)NAND_CACHE_NAME)))) {
+			k = j++;
+			for (j = 0; j < dev_paramt->nr_partitions; k++, j++) {
+				memcpy(&(part_table[k].name),
+					dev_paramt->partitions[j].name,
+					MAX_NAND_PART_NAME_LEN);
+				part_table[k].size =
+					dev_paramt->partitions[j].size;
+				part_table[k].offset =
+					dev_paramt->partitions[j].offset;
+				part_table[k].mask_flags =
+					dev_paramt->partitions[j].mask_flags;
+				/*
+				aml_nand_msg("CODE: partiton name %s,size %llx,
+				offset %llx maskflag %d",
+				part_table[k].name,
+				part_table[k].size,
+				part_table[k].offset,
+				part_table[k].mask_flags);
+				*/
+			}
+			break;
+		}
+	}
+
+	i = tmp_num;
+	for (; i < PHY_DEV_NUM+1; i++) {
+		dev_paramt = &config->dev_para[i];
+		/*
+		aml_nand_msg("dev_paramt name %s ",dev_paramt->name);
+		*/
+		if ((!strncmp((char *)dev_paramt->name,
+			NAND_DATA_NAME,
+			strlen((const char *)NAND_DATA_NAME)))) {
+			m = k++;
+			for (j = 0; j < dev_paramt->nr_partitions; j++) {
+				memcpy(&(part_table[m].name),
+					dev_paramt->partitions[j].name,
+					MAX_NAND_PART_NAME_LEN);
+				part_table[m].size =
+					dev_paramt->partitions[j].size;
+				part_table[m].offset =
+					dev_paramt->partitions[j].offset;
+				part_table[m].mask_flags =
+					dev_paramt->partitions[j].mask_flags;
+				/*
+				aml_nand_msg("CODE:partiton name %s,size %llx,
+				offset %llx maskflag %d",
+				part_table[m].name,
+				part_table[m].size,
+				part_table[m].offset,
+				part_table[m].mask_flags);
+				*/
+			}
+			break;
+		}
+	}
+
+	show_partition_table(part_table);
+	memcpy(buf, part_table, MAX_PART_NUM*sizeof(struct partitions));
+
+	kfree(part_table);
+	part_table = NULL;
+
+	return 0;
+}
+
+static ssize_t store_device_flag_get(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	sprintf(buf, "%d", boot_device_flag);
+	return 0;
+}
+
+static struct class_attribute aml_version =
+	__ATTR(version, S_IRUGO, nand_version_get, NULL);
+static struct class_attribute aml_part_table =
+	__ATTR(part_table, S_IRUGO, nand_part_table_get, NULL);
+static struct class_attribute aml_store_device =
+	__ATTR(store_device, S_IRUGO, store_device_flag_get, NULL);
+#endif /* AML_NAND_UBOOT */
+/*****************************************************************************
+*Name         :
+*Description  :
+*Parameter    :
+*Return       :
+*Note         :
+*****************************************************************************/
+int amlnf_dev_init(u32 flag)
+{
+#ifndef AML_NAND_UBOOT
+	struct amlnand_phydev *phydev = NULL;
+	/* struct amlnf_dev* nf_dev = NULL; */
+	struct class *aml_store_class = NULL;
+	int ret = 0;
+
+	list_for_each_entry(phydev, &nphy_dev_list, list) {
+		if ((phydev != NULL)
+			&& (strncmp((char *)phydev->name,
+				NAND_BOOT_NAME,
+				strlen((const char *)NAND_BOOT_NAME)))) {
+			ret = amlnf_pdev_register(phydev);
+			if (ret < 0) {
+				aml_nand_msg("nand add nftl failed");
+				goto exit_error0;
+			}
+		}
+	}
+
+aml_store_class = class_create(THIS_MODULE, "aml_store");
+	if (IS_ERR(aml_store_class)) {
+		aml_nand_msg("amlnf_dev_init : class cread failed");
+		ret =  -1;
+		goto exit_error0;
+	}
+
+	ret = class_create_file(aml_store_class, &aml_version);
+	if (ret) {
+		aml_nand_msg("amlnf_dev_init :  cannot create sysfs file : ");
+		goto out_class1;
+	}
+	ret = class_create_file(aml_store_class, &aml_part_table);
+	if (ret) {
+		aml_nand_msg("amlnf_dev_init : cannot create sysfs file : ");
+		goto out_class2;
+	}
+	ret = class_create_file(aml_store_class, &aml_store_device);
+	if (ret) {
+		aml_nand_msg("amlnf_dev_init : cannot create sysfs file : ");
+		goto out_class3;
+	}
+
+#endif
+
+	return 0;
+#ifndef AML_NAND_UBOOT
+out_class3:
+	class_remove_file(aml_store_class, &aml_part_table);
+out_class2:
+	class_remove_file(aml_store_class, &aml_version);
+out_class1:
+	class_destroy(aml_store_class);
+exit_error0:
+	return ret;
+#endif
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_nand_dt_match[] = {
+	{	.compatible = "amlogic,aml_nand",
+	},
+	{},
+};
+
+/*
+static inline struct
+aml_nand_device *aml_get_driver_data(struct platform_device *pdev)
+{
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+		match = of_match_node(amlogic_nand_dt_match, pdev->dev.of_node);
+		return (struct aml_nand_device *)match->data;
+	}
+	return NULL;
+}
+
+static int get_nand_platform(struct aml_nand_device *aml_nand_dev,
+		struct platform_device *pdev)
+{
+	int ret;
+	int plat_num = 0;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (pdev->dev.of_node) {
+		of_node_get(np);
+		ret = of_property_read_u32(np, "plat-num", &plat_num);
+		if (ret) {
+			aml_nand_msg("%s:%d,please config plat-num item\n",
+				__func__,
+				__LINE__);
+			return -1;
+		}
+	}
+	aml_nand_dbg("plat_num %d ", plat_num);
+
+	return 0;
+}
+*/
+#endif	/* CONFIG_OF */
+/***
+*boot_device_flag = 0 ; indicate spi+nand boot
+*boot_device_flag = 1;  indicate nand  boot
+***/
+#if 1
+int poc_cfg_prase(void)
+{
+	int boot_flag;
+	u32 cpu_type, poc_value;
+
+	poc_value =
+		amlnf_read_reg32(aml_nand_dev->platform_data->poc_reg);
+
+	cpu_type = get_cpu_type();
+	if (cpu_type == MESON_CPU_MAJOR_ID_GX) {
+		poc_value = (poc_value >> 6) & 0x03;
+	} else if (cpu_type >= MESON_CPU_MAJOR_ID_M8)
+		poc_value = ((((poc_value >> 0x09) & 0x01) << 2) |
+			((poc_value >> 6) & 0x03));
+	else
+		poc_value = (poc_value & 0x07);
+
+	if (cpu_type == MESON_CPU_MAJOR_ID_GX) {
+		if (poc_value & 0x2)
+			boot_flag = SPI_BOOT_FLAG;
+		else
+			boot_flag = NAND_BOOT_FLAG; //fixme, ...
+
+	} else if (cpu_type > MESON_CPU_MAJOR_ID_M8) {
+		if (poc_value == 0x05)
+			boot_flag = SPI_BOOT_FLAG;
+		if ((poc_value == 0x03) || (poc_value == 0x01))
+			boot_flag = EMMC_BOOT_FLAG;
+	} else {
+		if ((poc_value == 0x05) || (poc_value == 0x04))
+			boot_flag = SPI_BOOT_FLAG;
+		if (poc_value == 0x03)
+			boot_flag = EMMC_BOOT_FLAG;
+	}
+
+	if ((poc_value == 0x07) || (poc_value == 0x06))
+		boot_flag = NAND_BOOT_FLAG;
+	if (poc_value == 0x00)
+		boot_flag = EMMC_BOOT_FLAG;
+
+	return boot_flag;
+}
+
+
+int check_storage_device(void)
+{
+	int value = -1, poc_cfg = -1;
+
+	poc_cfg = poc_cfg_prase();
+	value = boot_device_flag;
+
+	if ((value == 0)
+		|| (value == SPI_NAND_FLAG)
+		|| (value == NAND_BOOT_FLAG)) {
+		if ((value == 0) || (value == -1)) {
+			if (poc_cfg == NAND_BOOT_FLAG)
+				boot_device_flag = 1;
+			else if (poc_cfg == EMMC_BOOT_FLAG)
+				boot_device_flag = -1;
+			else if (poc_cfg == SPI_BOOT_FLAG)
+				boot_device_flag = 0;
+			else if (poc_cfg == CARD_BOOT_FLAG)
+				boot_device_flag = 1;
+		} else if (value == SPI_NAND_FLAG)
+			boot_device_flag = 0;
+		else
+			boot_device_flag = 1;
+	} else
+		boot_device_flag = -1;
+
+	boot_device_flag = 1; //fixme, debug code....
+
+	aml_nand_msg("boot_device_flag : %d", boot_device_flag);
+	if ((boot_device_flag == 0) || (boot_device_flag == 1))
+		return 0;
+	else {
+		boot_device_flag = value;
+		return -NAND_FAILED;
+	}
+}
+EXPORT_SYMBOL(check_storage_device);
+#endif
+
+#ifndef AML_NAND_UBOOT
+static int  __init get_storage_device(char *str)
+{
+	int value = -1;
+
+	if (kstrtoul(str, 16, (u32 *)&value))
+		return -EINVAL;
+	/*value = strtoul(str, NULL, 16);*/
+	aml_nand_msg("get storage device: storage %s", str);
+	aml_nand_msg("value=%d", value);
+	boot_device_flag = value;
+	return 0;
+}
+
+early_param("storage", get_storage_device);
+
+static int amlnf_get_resource(struct platform_device *pdev)
+{
+	struct resource *res_mem, *res_irq;
+	int size;
+
+	/*
+	getting Nand Platform Data that are set in dts files by of_xxx functions
+	*/
+#ifdef CONFIG_OF
+/*
+	pdev->dev.platform_data = aml_get_driver_data(pdev);
+	aml_nand_msg("===========================================");
+	aml_nand_msg("%s:%d,nand device tree ok,dev-name:%s\n",
+		__func__,
+		__LINE__,
+		dev_name(&pdev->dev));
+*/
+#endif
+/*
+	ret = get_nand_platform(pdev->dev.platform_data, pdev);
+*/
+	/*aml_nand_dev = pdev->dev.platform_data;*/
+	aml_nand_dev = kzalloc(sizeof(struct aml_nand_device), GFP_KERNEL);
+	if (!aml_nand_dev) {
+		aml_nand_msg("aml_nand_dev not exist\n");
+		return -ENODEV;
+	}
+
+	aml_nand_dev->platform_data =
+		kzalloc(sizeof(struct amlnf_platform_data), GFP_KERNEL);
+	if (!aml_nand_dev->platform_data) {
+		aml_nand_msg("malloc platform data fail\n");
+		return -ENOMEM;
+	}
+
+	/*mapping PORT CONFIG register address*/
+	aml_nand_dev->platform_data->poc_reg =
+		devm_ioremap_nocache(&pdev->dev, POC_CONFIG_REG, sizeof(int));
+	if (aml_nand_dev->platform_data->poc_reg == NULL) {
+		dev_err(&pdev->dev, "ioremap External Port Config IO fail\n");
+		return -ENOMEM;
+	}
+	aml_nand_msg("poc_reg = 0x%0x\n",
+		(u32)aml_nand_dev->platform_data->poc_reg);
+
+	/*getting nand platform device IORESOURCE_MEM*/
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem) {
+		dev_err(&pdev->dev, "cannot obtain I/O memory region");
+		return -ENODEV;
+	}
+
+	size = resource_size(res_mem);
+	aml_nand_msg("%s : %0x  %0x\n", __func__, res_mem->start , size);
+
+	/*mapping Nand Flash Controller register address*/
+	/*request mem erea*/
+	if (!devm_request_mem_region(&pdev->dev,
+		res_mem->start,
+		size,
+		dev_name(&pdev->dev))) {
+		dev_err(&pdev->dev, "Memory region busy\n");
+		return -EBUSY;
+	}
+
+	/*mapping IO, nocache*/
+	aml_nand_dev->platform_data->nf_reg_base =
+		devm_ioremap_nocache(&pdev->dev,
+		res_mem->start,
+		size);
+	if (aml_nand_dev->platform_data->nf_reg_base == NULL) {
+		dev_err(&pdev->dev, "ioremap Nand Flash IO fail\n");
+		return -ENOMEM;
+	}
+
+	/*mapping external Clock register address of Nand Flash Controller*/
+	aml_nand_dev->platform_data->ext_clk_reg =
+		devm_ioremap_nocache(&pdev->dev,
+		NAND_CLK_CNTL,
+		sizeof(int));
+	if (aml_nand_dev->platform_data->ext_clk_reg == NULL) {
+		dev_err(&pdev->dev, "ioremap External Nand Clock IO fail\n");
+		return -ENOMEM;
+	}
+
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res_irq) {
+		dev_err(&pdev->dev, "irq res get fail\n");
+		return -ENODEV;
+	}
+
+	aml_nand_dev->platform_data->irq = res_irq->start;
+
+	return 0;
+}
+
+#else /* AML_NAND_UBOOT */
+
+/*fixme, yyh*/
+static int amlnf_get_resource(struct platform_device *pdev)
+{
+	/*TODO: */
+	aml_nand_dev = kzalloc(sizeof(struct aml_nand_device), GFP_KERNEL);
+	if (!aml_nand_dev) {
+		aml_nand_msg("aml_nand_dev not exist\n");
+		return -ENODEV;
+	}
+
+	aml_nand_dev->platform_data =
+		kzalloc(sizeof(struct amlnf_platform_data), GFP_KERNEL);
+	if (!aml_nand_dev->platform_data) {
+		aml_nand_msg("malloc platform data fail\n");
+		return -ENOMEM;
+	}
+	aml_nand_dbg("nand io resources:\n");
+	aml_nand_dev->platform_data->poc_reg = (volatile uint32_t *)POC_CONFIG_REG;
+	aml_nand_dbg("poc_reg = %p\n",
+		aml_nand_dev->platform_data->poc_reg);
+
+	aml_nand_dev->platform_data->nf_reg_base = (volatile uint32_t *)NAND_BASE_APB;
+	aml_nand_dbg("nf_reg_base = %p\n",
+		aml_nand_dev->platform_data->nf_reg_base);
+
+	aml_nand_dev->platform_data->ext_clk_reg = (volatile uint32_t *)NAND_CLK_CNTL;
+	aml_nand_dbg("ext_clk_reg = %p\n",
+		aml_nand_dev->platform_data->ext_clk_reg);
+	return 0;
+}
+#endif /* AML_NAND_UBOOT */
+
+#ifdef AML_NAND_UBOOT
+extern struct list_head nlogic_dev_list;
+#endif /* AML_NAND_UBOOT */
+
+static int _amlnf_init(struct platform_device *pdev, u32 flag)
+{
+	int ret = 0;
+	INIT_LIST_HEAD (&nphy_dev_list);
+	INIT_LIST_HEAD (&nlogic_dev_list);
+	INIT_LIST_HEAD (&nf_dev_list);
+
+	PHY_NAND_LINE
+	/*Nand physic init*/
+	/*Amlogic Nand Flash Controller init and Nand chip init ......*/
+	/*Scan or Build table,fbbt ,bbt, key and so on*/
+	/*Creating physical partition, offset and size*/
+	ret = amlnf_phy_init(flag, pdev);
+	if (ret) {
+		aml_nand_msg("nandphy_init failed and ret=0x%x", ret);
+		if (ret == -NAND_FAILED) {
+			ret = -1; // controller failed
+		}else if(ret == -NAND_SHIPPED_BADBLOCK_FAILED){
+			ret = NAND_SHIPPED_BADBLOCK_FAILED;
+		}else{
+			ret = 1;
+		}
+		goto exit_error0;
+	}
+
+	PHY_NAND_LINE
+	//only read id, quit myself.
+	if (flag == NAND_SCAN_ID_INIT)
+		goto exit_error0;
+	PHY_NAND_LINE
+	/*Nand logic init*/
+	ret = amlnf_logic_init(flag);
+	if (ret < 0) {
+		aml_nand_msg("amlnf_add_nftl failed and ret=0x%x", ret);
+		goto exit_error0;
+	}
+	PHY_NAND_LINE
+	ret = amlnf_dev_init(flag);
+	if (ret < 0) {
+		aml_nand_msg("amlnf_add_nftl failed and ret=0x%x", ret);
+		goto exit_error0;
+	}
+	PHY_NAND_LINE
+exit_error0:
+	return ret; /* fixme, */
+}
+#ifndef AML_NAND_UBOOT
+static int amlnf_driver_probe(struct platform_device *pdev)
+#else
+int amlnf_init(u32 flag)
+#endif /* AML_NAND_UBOOT */
+{
+	int ret = 0;
+#ifndef AML_NAND_UBOOT
+	u32 flag = 0;
+#else
+	struct platform_device plat_dev;
+	struct platform_device *pdev = &plat_dev;
+#endif /* AML_NAND_UBOOT */
+
+	PHY_NAND_LINE
+	ret = amlnf_get_resource(pdev);
+	if (ret < 0) {
+		aml_nand_msg("get resource fail!");
+		return 0;
+	}
+	PHY_NAND_LINE
+	/*judge if it is nand boot device*/
+	ret = check_storage_device();
+	if (ret < 0) {
+		aml_nand_msg("do not init nand");
+		return 0;
+	}
+	PHY_NAND_LINE
+	/*Initializing Nand Flash*/
+	ret = _amlnf_init(pdev, flag);
+	PHY_NAND_LINE
+	return ret;
+}
+
+#ifdef AML_NAND_UBOOT
+int amlnf_exit(unsigned flag)
+#else
+static int amlnf_exit(struct platform_device *pdev)
+#endif
+{
+	extern void amlnf_phy_exit(void);
+	extern void amlnf_logic_exit(void);
+	amlnf_phy_exit();
+	amlnf_logic_exit();
+	aml_nand_msg("amlnf_exit : ok");
+
+	return 0;
+}
+
+
+#ifndef AML_NAND_UBOOT
+static int amlnf_driver_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void amlnf_driver_shutdown(struct platform_device *pdev)
+{
+	struct amlnand_phydev *phy_dev = NULL;
+	struct amlnand_chip *aml_chip = NULL;
+
+	if (check_storage_device() < 0) {
+		aml_nand_msg("without nand");
+		return;
+	}
+
+	list_for_each_entry(phy_dev, &nphy_dev_list, list) {
+		if (phy_dev) {
+			aml_chip = (struct amlnand_chip *)phy_dev->priv;
+			amlnand_get_device(aml_chip, CHIP_SHUTDOWN);
+			phy_dev->option |= NAND_SHUT_DOWN;
+			amlnand_release_device(aml_chip);
+		}
+	}
+	return;
+}
+
+/* driver device registration */
+static struct platform_driver amlnf_driver = {
+	.probe = amlnf_driver_probe,
+	.remove = amlnf_driver_remove,
+	.shutdown = amlnf_driver_shutdown,
+	.driver = {
+		.name = DRV_AMLNFDEV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_nand_dt_match,
+	},
+};
+
+static int __init amlnf_module_init(void)
+{
+	return platform_driver_register(&amlnf_driver);
+}
+
+static void __exit amlnf_module_exit(void)
+{
+	platform_driver_unregister(&amlnf_driver);
+}
+
+module_init(amlnf_module_init);
+module_exit(amlnf_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("AML NAND TEAM");
+MODULE_DESCRIPTION("aml nand flash driver");
+#endif /* AML_NAND_UBOOT */
+
+#ifdef AML_NAND_UBOOT
+struct amlnand_phydev *aml_phy_get_dev(char * name)
+{
+	struct amlnand_phydev * phy_dev = NULL;
+
+	list_for_each_entry(phy_dev, &nphy_dev_list, list){
+		if (!strncmp((char*)phy_dev->name, name, MAX_DEVICE_NAME_LEN)) {
+				aml_nand_dbg("nand get phy dev %s ",name);
+				return phy_dev;
+		}
+	}
+	aml_nand_msg("nand get phy dev %s       failed",name);
+	return NULL;
+}
+
+
+struct amlnf_dev* aml_nftl_get_dev(char * name)
+{
+	struct amlnf_dev * nf_dev = NULL;
+
+	list_for_each_entry(nf_dev, &nf_dev_list, list){
+		if (!strncmp((char*)nf_dev->name, name, strlen(nf_dev->name))) {
+				aml_nand_dbg("nand get nftl dev %s ",name);
+				return nf_dev;
+		}
+	}
+	aml_nand_msg("nand get nftl dev %s  failed",name);
+	return NULL;
+}
+
+void show_ldev_list(void)
+{
+	struct amlnf_dev * nf_dev = NULL;
+	int i = 0;
+	list_for_each_entry(nf_dev, &nf_dev_list, list) {
+		printf("%d: %s: %llx\n", i++, (char*)nf_dev->name, nf_dev->size_sector);
+	}
+}
+
+
+int amlnf_logicdev_mis_init(struct amlnf_logicdev_t *amlnf_logicdev)
+{
+	return 0;
+}
+
+#endif
diff --git a/drivers/nand/dev/amlnf_dtb.c b/drivers/nand/dev/amlnf_dtb.c
new file mode 100644
index 0000000..ac5a8eb
--- /dev/null
+++ b/drivers/nand/dev/amlnf_dtb.c
@@ -0,0 +1,521 @@
+
+
+#include "../include/phynand.h"
+#ifndef AML_NAND_UBOOT
+#include<linux/cdev.h>
+#include <linux/device.h>
+
+#define DTB_NAME	"amlnf_dtb"
+static dev_t amlnf_dtb_no;
+struct cdev amlnf_dtb;
+struct device *dtb_dev = NULL;
+struct class *amlnf_dtb_class = NULL;
+#endif  /* AML_NAND_UBOOT */
+int dtb_erase_blk = -1;
+extern int get_partition_from_dts(unsigned char * buffer);
+
+struct amlnand_chip *aml_chip_dtb = NULL;
+
+
+int amlnf_dtb_save(u8 *buf, int len)
+{
+	u8 *dtb_buf = NULL;
+	int ret = 0;
+
+	aml_nand_msg("%s: ####", __func__);
+	if (aml_chip_dtb == NULL) {
+		aml_nand_msg("%s: amlnf not init yet!", __func__);
+		return -EFAULT;
+	}
+
+	if (len > CONFIG_DTB_SIZE) {
+		aml_nand_msg("%s: length too much", __func__);
+		return -EFAULT;
+	}
+	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	if (dtb_buf == NULL) {
+		aml_nand_msg("%s: malloc failed", __func__);
+		ret = -1;
+		goto exit_err;
+	}
+	memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+	memcpy(dtb_buf, buf, len);
+
+	ret = amlnand_save_info_by_name(aml_chip_dtb,
+		(u8 *)&(aml_chip_dtb->amlnf_dtb),
+		dtb_buf,
+		(u8 *)DTD_INFO_HEAD_MAGIC,
+		CONFIG_DTB_SIZE);
+	if (ret) {
+		aml_nand_msg("%s: nand dtd save failed", __func__);
+		ret = -EFAULT;
+		goto exit_err;
+	}
+exit_err:
+	if (dtb_buf) {
+		/* kfree(dtb_buf); */
+		kfree(dtb_buf);
+		dtb_buf = NULL;
+	}
+	return ret;
+}
+
+int amlnf_dtb_erase(void)
+{
+	int ret = 0;
+	if (aml_chip_dtb == NULL) {
+		aml_nand_msg("%s amlnf not ready yet!", __func__);
+		return -1;
+	}
+	ret = amlnand_erase_info_by_name(aml_chip_dtb,
+		(u8 *)&(aml_chip_dtb->amlnf_dtb),
+		(u8 *)DTD_INFO_HEAD_MAGIC);
+	if (ret) {
+		aml_nand_msg("dtb error,%s", __func__);
+		ret = -EFAULT;
+	}
+	return ret;
+}
+
+int amlnf_dtb_read(u8 *buf, int len)
+{
+	u8 *dtb_buf = NULL;
+	int ret = 0;
+
+	aml_nand_msg("%s: ####", __func__);
+
+	if (len > CONFIG_DTB_SIZE) {
+		aml_nand_msg("%s dtd length too much", __func__);
+		return -EFAULT;
+	}
+	if (aml_chip_dtb == NULL) {
+		memset(buf, 0x0, len);
+		aml_nand_msg("%s amlnf not ready yet!", __func__);
+		return 0;
+	}
+
+	if (aml_chip_dtb->amlnf_dtb.arg_valid == 0) {
+		memset(buf, 0x0, len);
+		aml_nand_msg("%s arg_valid = 0 invalid", __func__);
+		return 0;
+	}
+
+	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	if (dtb_buf == NULL) {
+		aml_nand_msg("%s: malloc failed", __func__);
+		ret = -1;
+		goto exit_err;
+	}
+	memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+
+	ret = amlnand_read_info_by_name(aml_chip_dtb,
+		(u8 *)&(aml_chip_dtb->amlnf_dtb),
+		(u8 *)dtb_buf,
+		(u8 *)DTD_INFO_HEAD_MAGIC,
+		CONFIG_DTB_SIZE);
+	if (ret) {
+		aml_nand_msg("dtb error,%s", __func__);
+		ret = -EFAULT;
+		goto exit_err;
+	}
+
+	memcpy(buf, dtb_buf, len);
+exit_err:
+	if (dtb_buf) {
+		/* kfree(dtb_buf); */
+		kfree(dtb_buf);
+		dtb_buf = NULL;
+	}
+	return ret;
+}
+
+/* under kernel */
+#ifndef AML_NAND_UBOOT
+ssize_t dtb_show(struct class *class, struct class_attribute *attr,
+		char *buf)
+{
+	aml_nand_dbg("dtb_show : #####");
+	/* fixme, read back and show in log! */
+	return 0;
+}
+
+ssize_t dtb_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	int ret = 0;
+	u8 *dtb_ptr = NULL;
+	aml_nand_dbg("dtb_store : #####");
+
+	dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+	if (dtb_ptr == NULL) {
+		aml_nand_msg("%s: malloc buf failed ", __func__);
+		return -ENOMEM;
+	}
+	/* fixme, why read back then write? */
+	ret = amlnf_dtb_read(dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		aml_nand_msg("%s: read failed", __func__);
+		kfree(dtb_ptr);
+		return -EFAULT;
+	}
+
+	ret = amlnf_dtb_save(dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		aml_nand_msg("%s: save failed", __func__);
+		kfree(dtb_ptr);
+		return -EFAULT;
+	}
+
+	aml_nand_dbg("dtb_store : OK #####");
+	return count;
+}
+
+static CLASS_ATTR(amlnf_dtb, S_IWUSR | S_IRUGO, dtb_show, dtb_store);
+
+int dtb_open(struct inode *node, struct file *file)
+{
+	return 0;
+}
+
+ssize_t dtb_read(struct file *file,
+		char __user *buf,
+		size_t count,
+		loff_t *ppos)
+{
+	u8 *dtb_ptr = NULL;
+	struct nand_flash *flash = &aml_chip_dtb->flash;
+	ssize_t read_size = 0;
+	int ret = 0;
+
+	if (*ppos == CONFIG_DTB_SIZE)
+		return 0;
+
+	if (*ppos >= CONFIG_DTB_SIZE) {
+		aml_nand_msg("%s:data access out of space!", __func__);
+		return -EFAULT;
+	}
+
+	/* dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL); */
+	dtb_ptr = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	if (dtb_ptr == NULL) {
+		aml_nand_msg("%s: malloc buf failed ", __func__);
+		return -ENOMEM;
+	}
+
+	amlnand_get_device(aml_chip_dtb, CHIP_READING);
+	ret = amlnf_dtb_read((u8 *)dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		aml_nand_msg("%s: read failed:%d", __func__, ret);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	if ((*ppos + count) > CONFIG_DTB_SIZE)
+		read_size = CONFIG_DTB_SIZE - *ppos;
+	else
+		read_size = count;
+
+	ret = copy_to_user(buf, (dtb_ptr + *ppos), read_size);
+	*ppos += read_size;
+exit:
+	amlnand_release_device(aml_chip_dtb);
+	/* kfree(dtb_ptr); */
+	vfree(dtb_ptr);
+	return read_size;
+}
+
+ssize_t dtb_write(struct file *file,
+		const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	u8 *dtb_ptr = NULL;
+	ssize_t write_size = 0;
+	struct nand_flash *flash = &aml_chip_dtb->flash;
+	int ret = 0;
+
+	if (*ppos == CONFIG_DTB_SIZE)
+		return 0;
+
+	if (*ppos >= CONFIG_DTB_SIZE) {
+		aml_nand_msg("%s: data access out of space!", __func__);
+		return -EFAULT;
+	}
+
+	/* dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL); */
+	dtb_ptr = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	if (dtb_ptr == NULL) {
+		aml_nand_msg("%s: malloc buf failed ", __func__);
+		return -ENOMEM;
+	}
+	amlnand_get_device(aml_chip_dtb, CHIP_WRITING);
+
+	ret = amlnf_dtb_read((u8 *)dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		aml_nand_msg("%s: read failed", __func__);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	if ((*ppos + count) > CONFIG_DTB_SIZE)
+		write_size = CONFIG_DTB_SIZE - *ppos;
+	else
+		write_size = count;
+
+	ret = copy_from_user((dtb_ptr + *ppos), buf, write_size);
+
+	ret = amlnf_dtb_save(dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		aml_nand_msg("%s: read failed", __func__);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	*ppos += write_size;
+exit:
+	amlnand_release_device(aml_chip_dtb);
+	/* kfree(dtb_ptr); */
+	vfree(dtb_ptr);
+	return write_size;
+}
+
+long dtb_ioctl(struct file *file, u32 cmd, u32 args)
+{
+	return 0;
+}
+
+static const struct file_operations dtb_ops = {
+	.open = dtb_open,
+	.read = dtb_read,
+	.write = dtb_write,
+	.unlocked_ioctl = dtb_ioctl,
+};
+#endif /* AML_NAND_UBOOT */
+
+int amlnf_dtb_init(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	u8 *dtb_buf = NULL;
+	aml_chip_dtb = aml_chip;
+
+	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	if (dtb_buf == NULL) {
+		aml_nand_msg("nand malloc for dtb_buf failed");
+		ret = -1;
+		goto exit_err;
+	}
+	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	aml_nand_msg("nand dtb: probe.");
+	ret = amlnand_info_init(aml_chip,
+		(u8 *)&(aml_chip->amlnf_dtb),
+		dtb_buf,
+		(u8 *)DTD_INFO_HEAD_MAGIC,
+		CONFIG_DTB_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("%s failed", __func__);
+		ret = -1;
+		goto exit_err;
+	}
+
+	/*if(aml_chip->amlnf_dtb.arg_valid == 0){
+		memset(dtb_buf,0x0,CONFIG_DTB_SIZE);
+		ret = amlnf_dtb_save(dtb_buf,CONFIG_DTB_SIZE);
+		if (ret) {
+			aml_nand_msg("amlnf_dtb_save: save env failed");
+		}
+	}*/
+#ifndef AML_NAND_UBOOT
+	aml_nand_dbg("%s: register dtb cdev", __func__);
+	ret = alloc_chrdev_region(&amlnf_dtb_no, 0, 1, DTB_NAME);
+	if (ret < 0) {
+		aml_nand_msg("%s alloc dtb dev_t number failed", __func__);
+		ret = -1;
+		goto exit_err;
+	}
+
+	cdev_init(&amlnf_dtb, &dtb_ops);
+	amlnf_dtb.owner = THIS_MODULE;
+	ret = cdev_add(&amlnf_dtb, amlnf_dtb_no, 1);
+	if (ret) {
+		aml_nand_msg("%s amlnf dtd dev add failed", __func__);
+		ret = -1;
+		goto exit_err1;
+	}
+
+	amlnf_dtb_class = class_create(THIS_MODULE, DTB_NAME);
+	if (IS_ERR(amlnf_dtb_class)) {
+		aml_nand_msg("%s: amlnf dtd class add failed", __func__);
+		ret = -1;
+		goto exit_err2;
+	}
+
+	ret = class_create_file(amlnf_dtb_class, &class_attr_env);
+	if (ret) {
+		aml_nand_msg("%s dev add failed", __func__);
+		ret = -1;
+		goto exit_err2;
+	}
+
+	dtb_dev = device_create(amlnf_dtb_class,
+		NULL,
+		amlnf_dtb_no,
+		NULL,
+		DTB_NAME);
+	if (IS_ERR(dtb_dev)) {
+		aml_nand_msg("%s: device_create failed", __func__);
+		ret = -1;
+		goto exit_err3;
+	}
+
+	aml_nand_dbg("%s: register dtd cdev OK", __func__);
+
+	kfree(dtb_buf);
+	dtb_buf = NULL;
+
+	return ret;
+
+exit_err3:
+	class_remove_file(amlnf_dtb_class, &class_attr_env);
+	class_destroy(amlnf_dtb_class);
+exit_err2:
+	cdev_del(&amlnf_dtb);
+exit_err1:
+	unregister_chrdev_region(amlnf_dtb_no, 1);
+
+#endif /* AML_NAND_UBOOT */
+exit_err:
+	if (dtb_buf) {
+		kfree(dtb_buf);
+		dtb_buf = NULL;
+	}
+	return ret;
+}
+
+int amlnf_dtb_init_partitions(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	u8 *dtb_buf = NULL;
+	aml_chip_dtb = aml_chip;
+
+	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	if (dtb_buf == NULL) {
+		aml_nand_msg("nand malloc for dtb_buf failed");
+		ret = -1;
+		goto exit_err;
+	}
+	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	aml_nand_msg("%s: probe. ", __func__);
+	ret = amlnand_info_init(aml_chip,
+		(u8 *)&(aml_chip->amlnf_dtb),
+		dtb_buf,
+		(u8 *)DTD_INFO_HEAD_MAGIC,
+		CONFIG_DTB_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("%s failed", __func__);
+		ret = -1;
+		goto exit_err;
+	}
+
+	/*parse partitions table */
+	ret = get_partition_from_dts(dtb_buf);
+	if (ret) {
+		aml_nand_msg("%s  get_partition_from_dts failed", __func__);
+	}
+exit_err:
+	if (dtb_buf) {
+		kfree(dtb_buf);
+		dtb_buf = NULL;
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ Prototype    : amlnf_detect_dtb_partitions
+ Description  : if 'dtb, write the bad block, we can't erase this block.
+				So we have to find the 'dtb' address in flash and flag it.
+ Input        : struct amlnand_chip *aml_chip
+ Output       : NULL
+ Return Value :	ret
+ Called By    : amlnand_get_partition_table
+
+  History        :
+  1.Date         : 2015/10/15
+	Author       : Fly Mo
+	Modification : Created function
+
+*****************************************************************************/
+int amlnf_detect_dtb_partitions(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	u8 *dtb_buf = NULL;
+	aml_chip_dtb = aml_chip;
+	struct nand_arg_info test_amlnf_dtb;
+	memset(&test_amlnf_dtb, 0, sizeof(test_amlnf_dtb));
+	dtb_erase_blk = -1;
+	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	if (dtb_buf == NULL) {
+		aml_nand_msg("nand malloc for dtb_buf failed");
+		ret = -1;
+		goto exit_err;
+	}
+	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	test_amlnf_dtb.arg_type = aml_chip->amlnf_dtb.arg_type;
+	ret = amlnand_info_init(aml_chip,
+		(u8 *)&(test_amlnf_dtb),
+		dtb_buf,
+		(u8 *)DTD_INFO_HEAD_MAGIC,
+		CONFIG_DTB_SIZE);
+	if (test_amlnf_dtb.arg_valid == 1) {
+		dtb_erase_blk = test_amlnf_dtb.valid_blk_addr;
+	}
+	aml_nand_msg("%s:dtb_erase_blk:%d", __func__,dtb_erase_blk);
+exit_err:
+	if (dtb_buf) {
+		kfree(dtb_buf);
+		dtb_buf = NULL;
+	}
+	return ret;
+}
+
+/* for blank positions... */
+int aml_nand_update_dtb(struct amlnand_chip *aml_chip, char *dtb_ptr)
+{
+	int ret = 0;
+	char malloc_flag = 0;
+	char *dtb_buf = NULL;
+
+	if (dtb_buf == NULL) {
+		dtb_buf = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+		malloc_flag = 1;
+		if (dtb_buf == NULL)
+			return -ENOMEM;
+		memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+		ret = amlnand_read_info_by_name(aml_chip,
+			(u8 *)&(aml_chip->amlnf_dtb),
+			(u8 *)dtb_buf,
+			(u8 *)DTD_INFO_HEAD_MAGIC,
+			CONFIG_DTB_SIZE);
+		if (ret) {
+			aml_nand_msg("read dtb error,%s\n", __func__);
+			ret = -EFAULT;
+			goto exit;
+		}
+	} else
+		dtb_buf = dtb_ptr;
+
+	ret = amlnand_save_info_by_name(aml_chip,
+		(u8 *)&(aml_chip->amlnf_dtb),
+		(u8 *)dtb_buf,
+		(u8 *)DTD_INFO_HEAD_MAGIC,
+		CONFIG_DTB_SIZE);
+	if (ret < 0)
+		aml_nand_msg("%s: update failed", __func__);
+exit:
+	if (malloc_flag && (dtb_buf)) {
+		kfree(dtb_buf);
+		dtb_buf = NULL;
+	}
+	return 0;
+}
+
+
diff --git a/drivers/nand/dev/amlnf_env.c b/drivers/nand/dev/amlnf_env.c
new file mode 100644
index 0000000..f3c2e58
--- /dev/null
+++ b/drivers/nand/dev/amlnf_env.c
@@ -0,0 +1,417 @@
+
+#include "../include/phynand.h"
+#ifndef AML_NAND_UBOOT
+#include<linux/cdev.h>
+#include <linux/device.h>
+
+#define CONFIG_ENV_SIZE  \
+	((get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) ? (64*1024U) : (0x8000U))
+
+
+#define ENV_NAME	"nand_env"
+static dev_t uboot_env_no;
+struct cdev uboot_env;
+struct device *uboot_dev = NULL;
+struct class *uboot_env_class = NULL;
+#endif  /* AML_NAND_UBOOT */
+
+struct amlnand_chip *aml_chip_env = NULL;
+
+
+int amlnf_env_save(u8 *buf, int len)
+{
+	u8 *env_buf = NULL;
+	//struct nand_flash *flash = &aml_chip_env->flash;
+	int ret = 0;
+
+	aml_nand_msg("uboot env amlnf_env_save : ####");
+	if (aml_chip_env == NULL) {
+		aml_nand_msg("uboot env not init yet!,%s", __func__);
+		return -EFAULT;
+	}
+
+	if (len > CONFIG_ENV_SIZE) {
+		aml_nand_msg("uboot env data len too much,%s", __func__);
+		return -EFAULT;
+	}
+	env_buf = aml_nand_malloc(CONFIG_ENV_SIZE);
+	if (env_buf == NULL) {
+		aml_nand_msg("nand malloc for uboot env failed");
+		ret = -1;
+		goto exit_err;
+	}
+	memset(env_buf, 0, CONFIG_ENV_SIZE);
+	memcpy(env_buf, buf, len);
+
+	ret = amlnand_save_info_by_name(aml_chip_env,
+		(u8 *)&(aml_chip_env->uboot_env),
+		env_buf,
+		(u8 *)ENV_INFO_HEAD_MAGIC,
+		CONFIG_ENV_SIZE);
+	if (ret) {
+		aml_nand_msg("nand uboot env error,%s", __func__);
+		ret = -EFAULT;
+		goto exit_err;
+	}
+exit_err:
+	if (env_buf) {
+		/* kfree(env_buf); */
+		kfree(env_buf);
+		env_buf = NULL;
+	}
+	return ret;
+}
+
+
+int amlnf_env_read(u8 *buf, int len)
+{
+	u8 *env_buf = NULL;
+	int ret = 0;
+	//struct nand_flash *flash = &aml_chip_env->flash;
+
+	aml_nand_msg("uboot env amlnf_env_read : ####");
+
+	if (len > CONFIG_ENV_SIZE) {
+		aml_nand_msg("uboot env data len too much,%s", __func__);
+		return -EFAULT;
+	}
+	if (aml_chip_env == NULL) {
+		memset(buf, 0x0, len);
+		aml_nand_msg("uboot env arg_valid = 0 invalid,%s", __func__);
+		return 0;
+	}
+
+	if (aml_chip_env->uboot_env.arg_valid == 0) {
+		memset(buf, 0x0, len);
+		aml_nand_msg("uboot env arg_valid = 0 invalid,%s", __func__);
+		return 0;
+	}
+
+	env_buf = aml_nand_malloc(CONFIG_ENV_SIZE);
+	if (env_buf == NULL) {
+		aml_nand_msg("nand malloc for uboot env failed");
+		ret = -1;
+		goto exit_err;
+	}
+	memset(env_buf, 0, CONFIG_ENV_SIZE);
+
+	ret = amlnand_read_info_by_name(aml_chip_env,
+		(u8 *)&(aml_chip_env->uboot_env),
+		(u8 *)env_buf,
+		(u8 *)ENV_INFO_HEAD_MAGIC,
+		CONFIG_ENV_SIZE);
+	if (ret) {
+		aml_nand_msg("nand uboot env error,%s", __func__);
+		ret = -EFAULT;
+		goto exit_err;
+	}
+
+	memcpy(buf, env_buf, len);
+exit_err:
+	if (env_buf) {
+		/* kfree(env_buf); */
+		kfree(env_buf);
+		env_buf = NULL;
+	}
+	return ret;
+}
+#ifndef AML_NAND_UBOOT
+ssize_t env_show(struct class *class, struct class_attribute *attr,
+		char *buf)
+{
+	aml_nand_dbg("env_show : #####");
+
+	return 0;
+}
+
+ssize_t env_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	int ret = 0;
+	u8 *env_ptr = NULL;
+	aml_nand_dbg("env_store : #####");
+
+	env_ptr = kzalloc(CONFIG_ENV_SIZE, GFP_KERNEL);
+	if (env_ptr == NULL) {
+		aml_nand_msg("nand_env_read: nand env malloc buf failed ");
+		return -ENOMEM;
+	}
+
+	ret = amlnf_env_read(env_ptr, CONFIG_ENV_SIZE);
+	if (ret) {
+		aml_nand_msg("nand_env_read: nand env read failed");
+		kfree(env_ptr);
+		return -EFAULT;
+	}
+
+	ret = amlnf_env_save(env_ptr, CONFIG_ENV_SIZE);
+	if (ret) {
+		aml_nand_msg("nand_env_read: nand env read failed");
+		kfree(env_ptr);
+		return -EFAULT;
+	}
+
+	aml_nand_dbg("env_store : OK #####");
+	return count;
+}
+
+static CLASS_ATTR(env, S_IWUSR | S_IRUGO, env_show, env_store);
+
+int uboot_env_open(struct inode *node, struct file *file)
+{
+	return 0;
+}
+
+ssize_t uboot_env_read(struct file *file,
+		char __user *buf,
+		size_t count,
+		loff_t *ppos)
+{
+	u8 *env_ptr = NULL;
+	struct nand_flash *flash = &aml_chip_env->flash;
+	ssize_t read_size = 0;
+	int ret = 0;
+
+	if (*ppos == CONFIG_ENV_SIZE)
+		return 0;
+
+	if (*ppos >= CONFIG_ENV_SIZE) {
+		aml_nand_msg("nand env: data access out of space!");
+		return -EFAULT;
+	}
+
+	/* env_ptr = kzalloc(CONFIG_ENV_SIZE, GFP_KERNEL); */
+	env_ptr = vmalloc(CONFIG_ENV_SIZE + flash->pagesize);
+	if (env_ptr == NULL) {
+		aml_nand_msg("nand_env_read: nand env malloc buf failed ");
+		return -ENOMEM;
+	}
+
+	amlnand_get_device(aml_chip_env, CHIP_READING);
+	ret = amlnf_env_read((u8 *)env_ptr, CONFIG_ENV_SIZE);
+	if (ret) {
+		aml_nand_msg("nand_env_read: nand env read failed:%d", ret);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	if ((*ppos + count) > CONFIG_ENV_SIZE)
+		read_size = CONFIG_ENV_SIZE - *ppos;
+	else
+		read_size = count;
+
+	ret = copy_to_user(buf, (env_ptr + *ppos), read_size);
+	*ppos += read_size;
+exit:
+	amlnand_release_device(aml_chip_env);
+	/* kfree(env_ptr); */
+	vfree(env_ptr);
+	return read_size;
+}
+
+ssize_t uboot_env_write(struct file *file,
+		const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	u8 *env_ptr = NULL;
+	ssize_t write_size = 0;
+	struct nand_flash *flash = &aml_chip_env->flash;
+	int ret = 0;
+
+	if (*ppos == CONFIG_ENV_SIZE)
+		return 0;
+
+	if (*ppos >= CONFIG_ENV_SIZE) {
+		aml_nand_msg("nand env: data access out of space!");
+		return -EFAULT;
+	}
+
+	/* env_ptr = kzalloc(CONFIG_ENV_SIZE, GFP_KERNEL); */
+	env_ptr = vmalloc(CONFIG_ENV_SIZE + flash->pagesize);
+	if (env_ptr == NULL) {
+		aml_nand_msg("nand_env_read: nand env malloc buf failed ");
+		return -ENOMEM;
+	}
+	amlnand_get_device(aml_chip_env, CHIP_WRITING);
+
+	ret = amlnf_env_read((u8 *)env_ptr, CONFIG_ENV_SIZE);
+	if (ret) {
+		aml_nand_msg("nand_env_read: nand env read failed");
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	if ((*ppos + count) > CONFIG_ENV_SIZE)
+		write_size = CONFIG_ENV_SIZE - *ppos;
+	else
+		write_size = count;
+
+	ret = copy_from_user((env_ptr + *ppos), buf, write_size);
+
+	ret = amlnf_env_save(env_ptr, CONFIG_ENV_SIZE);
+	if (ret) {
+		aml_nand_msg("nand_env_read: nand env read failed");
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	*ppos += write_size;
+exit:
+	amlnand_release_device(aml_chip_env);
+	/* kfree(env_ptr); */
+	vfree(env_ptr);
+	return write_size;
+}
+
+long uboot_env_ioctl(struct file *file, u32 cmd, u32 args)
+{
+	return 0;
+}
+
+static const struct file_operations uboot_env_ops = {
+	.open = uboot_env_open,
+	.read = uboot_env_read,
+	.write = uboot_env_write,
+	.unlocked_ioctl = uboot_env_ioctl,
+};
+#endif /* AML_NAND_UBOOT */
+int aml_ubootenv_init(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	u8 *env_buf = NULL;
+	aml_chip_env = aml_chip;
+
+	env_buf = aml_nand_malloc(CONFIG_ENV_SIZE);
+	if (env_buf == NULL) {
+		aml_nand_msg("nand malloc for secure_ptr failed");
+		ret = -1;
+		goto exit_err;
+	}
+	memset(env_buf, 0x0, CONFIG_ENV_SIZE);
+
+	ret = amlnand_info_init(aml_chip,
+		(u8 *)&(aml_chip->uboot_env),
+		env_buf,
+		(u8 *)ENV_INFO_HEAD_MAGIC,
+		CONFIG_ENV_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("%s failed\n", __func__);
+		ret = -1;
+		goto exit_err;
+	}
+
+	/*if(aml_chip->uboot_env.arg_valid == 0){
+		memset(env_buf,0x0,CONFIG_ENV_SIZE);
+		ret = amlnf_env_save(env_buf,CONFIG_ENV_SIZE);
+		if (ret) {
+			aml_nand_msg("amlnf_env_save: save env failed");
+		}
+	}*/
+#ifndef AML_NAND_UBOOT
+	aml_nand_dbg("%s: register env chardev", __func__);
+	ret = alloc_chrdev_region(&uboot_env_no, 0, 1, ENV_NAME);
+	if (ret < 0) {
+		aml_nand_msg("alloc uboot env dev_t no failed");
+		ret = -1;
+		goto exit_err;
+	}
+
+	cdev_init(&uboot_env, &uboot_env_ops);
+	uboot_env.owner = THIS_MODULE;
+	ret = cdev_add(&uboot_env, uboot_env_no, 1);
+	if (ret) {
+		aml_nand_msg("uboot env dev add failed");
+		ret = -1;
+		goto exit_err1;
+	}
+
+	uboot_env_class = class_create(THIS_MODULE, ENV_NAME);
+	if (IS_ERR(uboot_env_class)) {
+		aml_nand_msg("uboot env dev add failed");
+		ret = -1;
+		goto exit_err2;
+	}
+
+	ret = class_create_file(uboot_env_class, &class_attr_env);
+	if (ret) {
+		aml_nand_msg("uboot env dev add failed");
+		ret = -1;
+		goto exit_err2;
+	}
+
+	uboot_dev = device_create(uboot_env_class,
+		NULL,
+		uboot_env_no,
+		NULL,
+		ENV_NAME);
+	if (IS_ERR(uboot_dev)) {
+		aml_nand_msg("uboot env dev add failed");
+		ret = -1;
+		goto exit_err3;
+	}
+
+	aml_nand_dbg("%s: register env chardev OK", __func__);
+
+	kfree(env_buf);
+	env_buf = NULL;
+
+	return ret;
+
+exit_err3:
+	class_remove_file(uboot_env_class, &class_attr_env);
+	class_destroy(uboot_env_class);
+exit_err2:
+	cdev_del(&uboot_env);
+exit_err1:
+	unregister_chrdev_region(uboot_env_no, 1);
+
+#endif /* AML_NAND_UBOOT */
+exit_err:
+	if (env_buf) {
+		kfree(env_buf);
+		env_buf = NULL;
+	}
+	return ret;
+}
+/* update env if only it is still readable! */
+int aml_nand_update_ubootenv(struct amlnand_chip *aml_chip, char *env_ptr)
+{
+	int ret = 0;
+	char malloc_flag = 0;
+	char *env_buf = NULL;
+
+	if (env_buf == NULL) {
+		env_buf = kzalloc(CONFIG_ENV_SIZE, GFP_KERNEL);
+		malloc_flag = 1;
+		if (env_buf == NULL)
+			return -ENOMEM;
+		memset(env_buf, 0, CONFIG_ENV_SIZE);
+		ret = amlnand_read_info_by_name(aml_chip,
+			(u8 *)&(aml_chip->uboot_env),
+			(u8 *)env_buf,
+			(u8 *)ENV_INFO_HEAD_MAGIC,
+			CONFIG_ENV_SIZE);
+		if (ret) {
+			aml_nand_msg("read ubootenv error,%s\n", __func__);
+			ret = -EFAULT;
+			goto exit;
+		}
+	} else
+		env_buf = env_ptr;
+
+	ret = amlnand_save_info_by_name(aml_chip,
+		(u8 *)&(aml_chip->uboot_env),
+		(u8 *)env_buf,
+		(u8 *)ENV_INFO_HEAD_MAGIC,
+		CONFIG_ENV_SIZE);
+	if (ret < 0)
+		aml_nand_msg("aml_nand_update_secure : update secure failed");
+exit:
+	if (malloc_flag && (env_buf)) {
+		kfree(env_buf);
+		env_buf = NULL;
+	}
+	return 0;
+}
+
+
diff --git a/drivers/nand/dev/amlnf_key.c b/drivers/nand/dev/amlnf_key.c
new file mode 100644
index 0000000..67b8f3e
--- /dev/null
+++ b/drivers/nand/dev/amlnf_key.c
@@ -0,0 +1,183 @@
+#include "../include/phynand.h"
+
+
+static struct amlnand_chip *aml_chip_key = NULL;
+
+/*
+ * This funcion reads the u-boot keys.
+ */
+int amlnf_key_read(u8 * buf, int len)
+{
+	struct amlnand_chip * aml_chip = aml_chip_key;
+	struct nand_menson_key *key_ptr = NULL;
+	int error = 0;
+
+	if (aml_chip == NULL) {
+		printk("%s(): amlnf key not ready yet!", __func__);
+		return -EFAULT;
+	}
+
+	if (len > CONFIG_KEYSIZE) {
+		printk("%s key data len too much\n",__func__);
+		return -EFAULT;
+	}
+	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+	if (key_ptr == NULL)
+		return -ENOMEM;
+	memset(key_ptr, 0, CONFIG_KEYSIZE);
+
+	error = amlnand_read_info_by_name(aml_chip,
+		(u8 *)&(aml_chip->nand_key),
+		(u8 *)key_ptr,
+		(u8*)KEY_INFO_HEAD_MAGIC,
+		CONFIG_KEYSIZE);
+	if (error) {
+		printk("%s: read key error\n",__func__);
+		error = -EFAULT;
+		goto exit;
+	}
+	memcpy(buf, key_ptr->data, len);
+
+exit:
+	kfree(key_ptr);
+	return 0;
+}
+
+/*
+ * This funcion write the keys.
+ */
+int amlnf_key_write(u8 *buf, int len)
+{
+	struct amlnand_chip * aml_chip = aml_chip_key;
+	struct nand_menson_key *key_ptr = NULL;
+	int error = 0;
+
+	if (aml_chip == NULL) {
+		printk("%s(): amlnf key not ready yet!", __func__);
+		return -EFAULT;
+	}
+
+	if (len > CONFIG_KEYSIZE) {
+		printk("key data len too much,%s\n",__func__);
+		return -EFAULT;
+	}
+	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+	if (key_ptr == NULL)
+		return -ENOMEM;
+	memset(key_ptr,0,CONFIG_KEYSIZE);
+	memcpy(key_ptr->data + 0, buf, len);
+
+	error = amlnand_save_info_by_name(aml_chip,
+		(u8 *)&(aml_chip->nand_key),
+		(u8 *)key_ptr,
+		(u8 *)KEY_INFO_HEAD_MAGIC,
+		CONFIG_KEYSIZE);
+	if (error) {
+		printk("save key error,%s\n",__func__);
+		error = -EFAULT;
+		goto exit;
+	}
+exit:
+	kfree(key_ptr);
+	return error;
+}
+
+int amlnf_key_erase(void)
+{
+	int ret = 0;
+	if (aml_chip_key == NULL) {
+		printk("%s amlnf not ready yet!\n", __func__);
+		return -1;
+	}
+	ret = amlnand_erase_info_by_name(aml_chip_key,
+		(u8 *)&(aml_chip_key->nand_key),
+		(u8 *)KEY_INFO_HEAD_MAGIC);
+	if (ret) {
+		printk("%s erase key error\n", __func__);
+		ret = -EFAULT;
+	}
+	return ret;
+}
+
+
+int aml_key_init(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	struct nand_menson_key *key_ptr = NULL;
+
+	/* avoid null */
+	aml_chip_key = aml_chip;
+
+	key_ptr = aml_nand_malloc(CONFIG_KEYSIZE);
+	if (key_ptr == NULL) {
+		printk("nand malloc for key_ptr failed");
+		ret = -1;
+		goto exit_error0;
+	}
+	memset(key_ptr, 0x0, CONFIG_KEYSIZE);
+	printk("%s probe.\n", __func__);
+
+	ret = amlnand_info_init(aml_chip,
+		(u8 *)&(aml_chip->nand_key),
+		(u8 *)key_ptr,(u8 *)KEY_INFO_HEAD_MAGIC,
+		CONFIG_KEYSIZE);
+	if (ret < 0) {
+		printk("invalid nand key\n");
+	}
+exit_error0:
+	if (key_ptr) {
+		aml_nand_free(key_ptr);
+		key_ptr =NULL;
+	}
+	return ret;
+}
+
+
+int aml_nand_update_key(struct amlnand_chip * aml_chip, char *key_ptr)
+{
+	int ret = 0;
+	int malloc_flag = 0;
+	char *key_buf = NULL;
+
+	if (key_buf == NULL) {
+
+		key_buf = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+		malloc_flag = 1;
+		if (key_buf == NULL)
+			return -ENOMEM;
+		memset(key_buf,0,CONFIG_KEYSIZE);
+		ret = amlnand_read_info_by_name(aml_chip,
+			(u8 *)&(aml_chip->nand_key),
+			(u8 *)key_buf,
+			(u8 *)KEY_INFO_HEAD_MAGIC,
+			CONFIG_KEYSIZE);
+		if (ret) {
+			printk("%s: read key error\n", __func__);
+			ret = -EFAULT;
+			goto exit;
+		}
+	} else {
+		key_buf = key_ptr;
+	}
+
+	printk("amlnf_key : type %d, valid %d, flag %d, blk %d, page %d\n",
+		aml_chip->nand_key.arg_type,aml_chip->nand_key.arg_valid,
+		aml_chip->nand_key.update_flag,aml_chip->nand_key.valid_blk_addr,
+		aml_chip->nand_key.valid_page_addr);
+
+	ret = amlnand_save_info_by_name( aml_chip,
+		(u8 *)&(aml_chip->nand_key),
+		(u8 *)key_buf,
+		(u8 *)KEY_INFO_HEAD_MAGIC,
+		CONFIG_KEYSIZE);
+	if (ret < 0) {
+		printk("%s : save key info failed\n", __func__);
+	}
+
+exit:
+	if (malloc_flag &&(key_buf)) {
+		kfree(key_buf);
+		key_buf = NULL;
+	}
+	return 0;
+}
diff --git a/drivers/nand/dev/cmd_amlnf.c b/drivers/nand/dev/cmd_amlnf.c
new file mode 100644
index 0000000..f1e5b5e
--- /dev/null
+++ b/drivers/nand/dev/cmd_amlnf.c
@@ -0,0 +1,1107 @@
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : driver_uboot.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**			amlnand_init,  mainly init nand phy driver.
+**
+**
+*****************************************************************/
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include "../include/amlnf_dev.h"
+
+#ifdef AML_NAND_UBOOT
+extern void amlnf_disprotect(char * name);
+extern struct amlnand_phydev *aml_phy_get_dev(char * name);
+extern struct amlnf_dev* aml_nftl_get_dev(char * name);
+extern void amlnf_get_chip_size(u64 *size);
+extern void show_phydev_list(void);
+extern void show_ldev_list(void);
+#endif
+extern void amlnf_dump_chipinfo(void);
+extern int roomboot_nand_read(struct amlnand_phydev *phydev);
+extern int roomboot_nand_write(struct amlnand_phydev *phydev);
+extern int nand_read_ops(struct amlnand_phydev *phydev);
+extern int nand_write_ops(struct amlnand_phydev *phydev);
+extern int nand_erase(struct amlnand_phydev *phydev);
+extern void amlnand_dump_page(struct amlnand_phydev *phydev);
+extern int  amlnf_erase_ops(uint64_t off, uint64_t erase_len,unsigned char scrub_flag);
+extern int  amlnf_markbad_reserved_ops(uint32_t start_blk);
+
+#if (AML_CFG_DTB_RSV_EN)
+extern int amlnf_dtb_save(u8 *buf, int len);
+extern int amlnf_dtb_read(u8 *buf, int len);
+extern int amlnf_dtb_erase(void);
+#endif
+
+#if (AML_CFG_KEY_RSV_EN)
+extern int amlnf_key_write(u8 *buf, int len);
+extern int amlnf_key_read(u8 * buf, int len);
+extern int amlnf_key_erase(void);
+#endif
+
+extern int amlnf_init(unsigned char flag);
+extern int amlnf_exit(void);
+//static int plane_mode;
+struct amlnf_dev * nftl_device = NULL;
+struct amlnand_phydev *phy_device=NULL;
+static int nand_protect = 1;
+
+static inline int isstring(char *p)
+{
+	char *endptr = p;
+	while (*endptr != '\0') {
+		if (!(((*endptr >= '0') && (*endptr <= '9'))
+			|| ((*endptr >= 'a') && (*endptr <= 'f'))
+			|| ((*endptr >= 'A') && (*endptr <= 'F'))
+			|| (*endptr == 'x') || (*endptr == 'X')))
+			return 1;
+		endptr++;
+	}
+
+	return 0;
+}
+
+#ifdef AML_NAND_UBOOT
+/*
+ * repack.
+ **/
+unsigned long strtoul(const char *cp, char **endp,
+				unsigned int base)
+{
+	return simple_strtoul(cp, endp, base);
+}
+#endif /* AML_NAND_UBOOT */
+static inline int str2long(char *p, ulong *num)
+{
+	char *endptr;
+	*num = strtoul(p, &endptr, 16);
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static inline int str2longlong(char *p, u64 *num)
+{
+	char *endptr;
+#ifndef AML_NAND_UBOOT
+	*num = strtoull(p, &endptr, 16);
+#else
+	*num = simple_strtoul(p, &endptr, 16);
+#endif
+	if (*endptr != '\0') {
+		switch (*endptr) {
+		case 'g':
+		case 'G':
+			*num <<= 10;
+		case 'm':
+		case 'M':
+			*num <<= 10;
+		case 'k':
+		case 'K':
+			*num <<= 10;
+			endptr++;
+			break;
+		}
+	}
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static int arg_off_size(int argc, char *argv[],
+	u64 chipsize,
+	u64 *off,
+	u64 *size)
+{
+	if (argc >= 1) {
+		if (!(str2longlong(argv[0], (u64 *)off))) {
+			aml_nand_dbg("'%s' is not a number", argv[0]);
+			return -1;
+		}
+	} else
+		*off = 0;
+
+	if (argc >= 2) {
+		if (!(str2longlong(argv[1], (u64 *)size))) {
+			aml_nand_dbg("'%s' is not a number", argv[1]);
+			return -1;
+		}
+	} else
+		*size = chipsize - *off;
+
+	if (*size == chipsize)
+		aml_nand_dbg("whole chip/dev");
+	else
+		aml_nand_dbg("offset 0x%llx, size 0x%llx", *off, *size);
+
+	return 0;
+}
+
+#define AML_NFTL_ALIGN_SIZE	    512
+#define AML_NFTL_ALIGN_SHIFT	9
+u8 local_buf[AML_NFTL_ALIGN_SIZE];
+
+int amlnand_read(struct amlnf_dev *nftl_dev,
+		u8 *buf,
+		u64 offset,	/* in bytes */
+		u64 size)	/* in bytes */
+{
+	u32 ret = 0;
+	u64 head_sector;
+	u64 head_start_bytes;
+	u64 head_bytes_num;
+
+	u64 mid_sector;
+	u64 mid_len;
+
+	u64 tail_sector;
+	u64 tail_bytes_num;
+
+	mid_len = offset >> AML_NFTL_ALIGN_SHIFT;	/* in sector */
+	head_start_bytes = offset - (mid_len << AML_NFTL_ALIGN_SHIFT);
+	head_bytes_num = AML_NFTL_ALIGN_SIZE - head_start_bytes;
+	head_sector = offset >> AML_NFTL_ALIGN_SHIFT;
+	CMD_LINE
+	if (head_bytes_num >= size) {
+		CMD_LINE
+		ret |= nftl_dev->read_sector(nftl_dev,
+			head_sector,
+			1,
+			local_buf);
+		memcpy(buf, local_buf+head_start_bytes, size);
+		return ret;
+	}
+	CMD_LINE
+	ret |= nftl_dev->read_sector(nftl_dev, head_sector, 1, local_buf);
+	memcpy(buf, local_buf+head_start_bytes, head_bytes_num);
+	CMD_LINE
+	buf += head_bytes_num;
+	offset += head_bytes_num;
+	size -= head_bytes_num;
+
+	if (size > AML_NFTL_ALIGN_SIZE) {
+		mid_len = size >> AML_NFTL_ALIGN_SHIFT;
+		mid_sector = offset >> AML_NFTL_ALIGN_SHIFT;
+		CMD_LINE
+		ret |= nftl_dev->read_sector(nftl_dev,
+			mid_sector,
+			mid_len,
+			buf);
+		buf += mid_len << AML_NFTL_ALIGN_SHIFT;
+		offset += mid_len << AML_NFTL_ALIGN_SHIFT;
+		size = size - (mid_len << AML_NFTL_ALIGN_SHIFT);
+	}
+
+	if (size == 0)
+		return ret;
+	CMD_LINE
+	tail_sector = offset >> AML_NFTL_ALIGN_SHIFT;
+	tail_bytes_num = size;
+	ret |= nftl_dev->read_sector(nftl_dev, tail_sector, 1, local_buf);
+	memcpy(buf, local_buf, tail_bytes_num);
+	CMD_LINE
+	return ret;
+}
+
+int amlnand_write(struct amlnf_dev *nftl_dev,
+	u8 *buf,
+	u64 offset,
+	u64 size)
+{
+	u32 ret = 0;
+	u64 head_sector;
+	u64 head_start_bytes;
+	u64 head_bytes_num;
+
+	u64 mid_sector;
+	u64 mid_len;
+
+	u64 tail_sector;
+	u64 tail_bytes_num;
+
+	CMD_LINE
+	mid_len = offset >> AML_NFTL_ALIGN_SHIFT;
+	head_start_bytes = offset - (mid_len << AML_NFTL_ALIGN_SHIFT);
+	head_bytes_num = AML_NFTL_ALIGN_SIZE - head_start_bytes;
+	head_sector = offset >> AML_NFTL_ALIGN_SHIFT;
+	CMD_LINE
+	if (head_bytes_num >= size) {
+		ret |= nftl_dev->read_sector(nftl_dev,
+			head_sector,
+			1,
+			local_buf);
+		memcpy(local_buf+head_start_bytes, buf, size);
+		ret |= nftl_dev->write_sector(nftl_dev,
+			head_sector,
+			1,
+			local_buf);
+		goto flush;
+	}
+	CMD_LINE
+	ret |= nftl_dev->read_sector(nftl_dev, head_sector, 1, local_buf);
+	memcpy(local_buf+head_start_bytes, buf, head_bytes_num);
+	ret |= nftl_dev->write_sector(nftl_dev, head_sector, 1, local_buf);
+
+
+	buf += head_bytes_num;
+	offset += head_bytes_num;
+	size -= head_bytes_num;
+
+	if (size > AML_NFTL_ALIGN_SIZE) {
+		CMD_LINE
+		mid_len = size >> AML_NFTL_ALIGN_SHIFT;
+		mid_sector = offset >> AML_NFTL_ALIGN_SHIFT;
+		ret |= nftl_dev->write_sector(nftl_dev,
+			mid_sector,
+			mid_len,
+			buf);
+		buf += mid_len << AML_NFTL_ALIGN_SHIFT;
+		offset += mid_len << AML_NFTL_ALIGN_SHIFT;
+		size = size - (mid_len << AML_NFTL_ALIGN_SHIFT);
+	}
+
+	if (size == 0)
+		goto flush;
+	CMD_LINE
+	tail_sector = offset >> AML_NFTL_ALIGN_SHIFT;
+	tail_bytes_num = size;
+	ret |= nftl_dev->read_sector(nftl_dev, tail_sector, 1, local_buf);
+	memcpy(local_buf, buf, tail_bytes_num);
+	ret |= nftl_dev->write_sector(nftl_dev, tail_sector, 1, local_buf);
+
+flush:
+	CMD_LINE
+	ret = nftl_dev->flush((struct amlnf_dev *)nftl_dev);
+	if (ret < 0) {
+		aml_nand_msg("nftl flush cache failed");
+		ret = -1;
+	}
+	CMD_LINE
+	return ret;
+}
+
+extern void dbg_phyop(void);
+
+static int do_amlnfphy(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct amlnand_phydev *phydev = NULL;
+	struct phydev_ops  *devops = NULL;
+	struct amlnf_dev *nftl_dev;
+
+	unsigned long addr;
+	u64 chipsize, erase_addr, erase_len, erase_off, off, size;
+	u8 devread, nfread_flag;
+	int  start_secor, length,  ret = 0;
+	char *cmd, *protect_name;
+	char *dev_name = NULL;
+	unsigned long markbad_reserved_addr = 0;
+
+	/* at least two arguments please */
+	if (argc < 1)
+		goto usage;
+
+	cmd = argv[1];
+
+	/* for dbg entry! */
+	if (strcmp(cmd, "dbg") == 0) {
+		dbg_phyop();
+		return 0;
+	}
+	/* show boot flag!*/
+	if (strcmp(cmd, "boot") == 0) {
+		aml_nand_msg("device_boot_flag 0x%x", device_boot_flag);
+		if (device_boot_flag == NAND_BOOT_FLAG) {
+			aml_nand_msg("boot from nand!");
+		} else {
+			aml_nand_msg("bootflag not ready yet!");
+		}
+		return 0;
+	}
+
+	if (strcmp(cmd, "device") == 0) {
+	   //printk("argc %d\n", argc);
+		if (argc == 2) {
+			show_phydev_list();
+			return 0;
+		}
+		phydev = aml_phy_get_dev(dev_name);
+		if (!phydev) {
+		   aml_nand_msg("phydev be NULL, can't get it!");
+		   return -1;
+		}
+		return 0;
+	}
+
+	if (strcmp(cmd, "env") == 0) {
+		aml_nand_dbg("env relocate");		env_relocate();
+		return 0;
+	}
+
+	if (strcmp(cmd, "disprotect") == 0) {
+		protect_name = argv[2];
+		/* fixme, using amlnf_chip*/
+		amlnf_disprotect(protect_name);
+		return 0;
+	}
+
+	if (strcmp(cmd, "exit") == 0) {
+		amlnf_exit();
+		return 0;
+	}
+
+	if (strcmp(cmd, "init") == 0) {
+		putc('\n');
+		int init_flag = (ulong)strtoul(argv[2], NULL, 16);
+		/* flag = 0, indicate normal boot; */
+		/* flag = 1, indicate update, with data; */
+		/* flag = 2, indicate need erase */
+		ret = amlnf_init(init_flag);
+		if (ret) {
+			aml_nand_msg("nand_init failed ret:%x", ret);
+			return ret;
+		}
+
+		phydev = aml_phy_get_dev(NAND_CODE_NAME);
+		if (!phydev) {
+			aml_nand_msg("phydev be NULL");
+			goto usage;
+		}
+		return 0;
+	}
+	//ldevice
+	if (strcmp(cmd, "ldevice") == 0) {
+	   //printk("argc %d\n", argc);
+	   if (argc == 2) {
+		   show_ldev_list();
+		   return 0;
+	   }
+	   //fixme,
+	   goto usage;
+	   return 0;
+	}
+
+	if ((strcmp(cmd, "read_byte") == 0)
+		|| (strcmp(cmd, "write_byte") == 0)
+		|| (strcmp(cmd, "lwrite") == 0)
+		||(strcmp(cmd, "lread") == 0)) {
+
+		if (argc < 6)
+			goto usage;
+
+		dev_name = argv[2];
+		nftl_dev = NULL;
+		nftl_dev = aml_nftl_get_dev(dev_name);
+		if (!nftl_dev) {
+			aml_nand_msg("nftl_dev be NULL");
+			return -1;
+		}
+		aml_nand_dbg("nftl_dev->name =%s", nftl_dev->name);
+
+		addr = (ulong)strtoul(argv[3], NULL, 16);
+
+		nfread_flag = 0;
+		if ((strncmp(cmd, "read_byte", 9) == 0)
+			||(strncmp(cmd, "lread", 5) == 0) )
+			nfread_flag = 1;
+
+		aml_nand_dbg("\nNAND %s: addr:%llx ",
+				nfread_flag ? "read_byte" : "write_byte",
+				addr);
+
+		if (arg_off_size(argc - 4, (char **)(argv + 4), 0x0, &off, &size) != 0) {
+			goto usage;
+		}
+
+		if (nfread_flag)
+			ret = amlnand_read(nftl_dev, (u8 *)addr, off, size);
+		else
+			ret = amlnand_write(nftl_dev, (u8 *)addr, off, size);
+
+		aml_nand_dbg(" 0x%llx bytes %s : %s",
+				size,
+				nfread_flag ? "read_byte" : "write_byte",
+				ret ? "ERROR" : "OK");
+	    return ret;
+	}
+
+	if ((strcmp(cmd, "read") == 0) || (strcmp(cmd, "write") == 0)) {
+		if (argc < 6)
+			goto usage;
+
+		dev_name = argv[2];
+		nftl_dev = NULL;
+		nftl_dev = aml_nftl_get_dev(dev_name);
+		if (!nftl_dev) {
+			aml_nand_msg("nftl_dev be NULL");
+			return -1;
+		}
+		aml_nand_dbg("nftl_dev->nand_dev->writesize =%x",
+				nftl_dev->nand_dev->writesize);
+		aml_nand_dbg("nftl_dev->nand_dev->erasesize =%x",
+				nftl_dev->nand_dev->erasesize);
+		aml_nand_dbg("nftl_dev->name =%s", nftl_dev->name);
+
+		addr = (ulong)strtoul(argv[3], NULL, 16);
+
+		nfread_flag = strncmp(cmd, "read", 4) == 0;
+		/* 1 = read, 0 = write */
+		aml_nand_msg("NAND %s: addr:%lx",
+			nfread_flag ? "read" : "write",
+			addr);
+
+		if (arg_off_size(argc - 4, (char **)(argv + 4), 0x0, &off, &size) != 0)
+			goto usage;
+
+		if (off % 512) {
+			start_secor = ((int) (off / 512) + 1);
+			aml_nand_dbg("secor+1");
+		} else
+			start_secor = (int) (off / 512);
+
+		if (size % 512) {
+			length = ((int)((size / 512))+1);
+			aml_nand_dbg("length+1");
+		} else
+			length = (int)((size / 512));
+
+		aml_nand_dbg("start_secor =%d", start_secor);
+		aml_nand_dbg("length_sector =%d", length);
+
+		if (nfread_flag) {
+			ret = nftl_dev->read_sector(nftl_dev,
+				start_secor,
+				length,
+				(u8 *)addr);
+			if (ret < 0) {
+				aml_nand_dbg("read %d sector  failed", length);
+				return -1;
+			}
+		} else {
+			ret = nftl_dev->write_sector(nftl_dev,
+				start_secor,
+				length,
+				(u8 *)addr);
+			if (ret < 0) {
+				aml_nand_dbg("write %d sector  failed", length);
+				return -1;
+			}
+			ret = nftl_dev->flush(nftl_dev);
+			if (ret < 0) {
+				aml_nand_dbg("nftl flush cache failed");
+				return -1;
+			}
+		}
+
+		aml_nand_msg(" %d sector %s : %s",
+			length,
+			nfread_flag ? "read" : "write",
+			ret ? "ERROR" : "OK");
+		return ret;
+	}
+
+	if (strcmp(cmd, "chipinfo") == 0) {
+		putc('\n');
+		amlnf_dump_chipinfo();
+		return 0;
+	}
+
+	if (strcmp(cmd, "size") == 0) {
+		if (argc < 4)
+			goto usage;
+
+		dev_name = argv[2];
+		nftl_dev = NULL;
+		nftl_dev = aml_nftl_get_dev(dev_name);
+		if (!nftl_dev) {
+			aml_nand_msg("nftl_dev be NULL");
+			return -1;
+		}
+		aml_nand_dbg("nftl_dev->nand_dev->writesize =%x",
+				nftl_dev->nand_dev->writesize);
+		aml_nand_dbg("nftl_dev->nand_dev->erasesize =%x",
+				nftl_dev->nand_dev->erasesize);
+		aml_nand_dbg("nftl_dev->name =%s", nftl_dev->name);
+
+		addr = (ulong)strtoul(argv[3], NULL, 16);
+		*(u64 *)addr = nftl_dev->size_sector;
+		aml_nand_dbg("nftl_dev->size_sector =%llx",
+			nftl_dev->size_sector);
+		aml_nand_dbg("*addr = %llx", (*(u64 *)addr));
+
+		return 0;
+	}
+
+	if (strncmp(cmd, "rom_protect", 9) == 0) {
+		if (argc < 2)
+			goto usage;
+
+		if (strncmp(argv[2], "on", 2) == 0)
+			nand_protect = 1;
+		else if (strncmp(argv[2], "off", 3) == 0)
+			nand_protect = 0;
+		else
+			goto usage;
+
+		return	0;
+	}
+
+	if ((strcmp(cmd, "rom_write") == 0)
+		|| (strcmp(cmd, "rom_read") == 0)) {
+		nfread_flag = 0;
+		if (strncmp(cmd, "rom_read", 8) == 0)
+				nfread_flag = 1;
+
+		if (argc < 4)
+			goto usage;
+
+		addr = (ulong)strtoul(argv[2], NULL, 16);
+		aml_nand_msg("AMLNAND %s: ",
+			nfread_flag ? "rom_read" : "rom_write");
+
+		struct amlnand_phydev *tmp_phydev = phydev;
+		struct phydev_ops  *tmp_devops = devops;
+
+		phydev = aml_phy_get_dev(NAND_BOOT_NAME);
+		if (!phydev) {
+			aml_nand_msg("phydev be NULL");
+			return -1;
+		}
+		devops = &(phydev->ops);
+		aml_nand_dbg("phydev->name =%s", phydev->name);
+		amldev_dumpinfo(phydev);
+
+		if (arg_off_size(argc - 3,
+			(char **)(argv + 3),
+			phydev->size,
+			&off,
+			&size) != 0)
+			return -1;
+
+		memset(devops, 0x0, sizeof(struct phydev_ops));
+
+		devops->addr = off;
+		devops->len = size;
+		devops->mode = NAND_HW_ECC;
+		devops->datbuf = (u8 *)addr;
+
+		if (nfread_flag) {
+			ret = roomboot_nand_read(phydev);
+			if (ret < 0)
+				aml_nand_msg("nand read uboot failed");
+		} else {
+			ret = roomboot_nand_write(phydev);
+			if (ret < 0)
+				aml_nand_msg("nand write uboot failed");
+		}
+
+		aml_nand_msg("%llu bytes %s : %s",
+				size,
+				nfread_flag ? "rom_read" : "rom_write",
+				ret ? "ERROR" : "OK");
+
+		phydev = tmp_phydev;
+		devops = tmp_devops;
+
+		return ret;
+	}
+#if (AML_CFG_DTB_RSV_EN)
+	if ((strcmp(cmd, "dtb_write") == 0)
+		|| (strcmp(cmd, "dtb_read") == 0)) {
+		nfread_flag = 0;
+		if (strncmp(cmd, "dtb_read", 8) == 0)
+				nfread_flag = 1;
+
+		if (argc < 3)
+			goto usage;
+
+		addr = (ulong)strtoul(argv[2], NULL, 16);
+		size = (ulong)strtoul(argv[3], NULL, 16);
+		aml_nand_msg("cmd %s: ",
+			nfread_flag ? "dtb_read" : "dtb_write");
+
+		//memset(devops, 0x0, sizeof(struct phydev_ops));
+
+		if (nfread_flag) {
+			ret = amlnf_dtb_read((u8 *)addr, (int)size);
+			if (ret < 0)
+				aml_nand_msg("nand read dtd failed");
+		} else {
+			ret = amlnf_dtb_save((u8 *)addr, (int)size);
+			if (ret < 0)
+				aml_nand_msg("nand write dtd failed");
+		}
+
+		aml_nand_msg("%llu bytes %s : %s",
+				size,
+				nfread_flag ? "dtd_read" : "dtd_write",
+				ret ? "ERROR" : "OK");
+		return ret;
+	}
+
+	if (strcmp(cmd, "dtb_erase") == 0) {
+		ret = amlnf_dtb_erase();
+		aml_nand_msg("dtb erase %s", ret ? "Fail" : "Okay");
+		return ret;
+	}
+#endif
+	/* need full environments */
+#if (AML_CFG_KEY_RSV_EN)
+	if ((strcmp(cmd, "key_write") == 0)
+		|| (strcmp(cmd, "key_read") == 0)) {
+		nfread_flag = 0;
+		if (strncmp(cmd, "key_read", 8) == 0)
+				nfread_flag = 1;
+
+		if (argc < 3)
+			goto usage;
+
+		addr = (ulong)strtoul(argv[2], NULL, 16);
+		size = (ulong)strtoul(argv[3], NULL, 16);
+		aml_nand_msg("cmd %s: ",
+			nfread_flag ? "key_read" : "key_write");
+
+		//memset(devops, 0x0, sizeof(struct phydev_ops));
+
+		if (nfread_flag) {
+			ret = amlnf_key_read((u8 *)addr, (int)size);
+			if (ret < 0)
+				aml_nand_msg("nand read key failed");
+		} else {
+			ret = amlnf_key_write((u8 *)addr, (int)size);
+			if (ret < 0)
+				aml_nand_msg("nand write key failed");
+		}
+
+		aml_nand_msg("%llu bytes %s : %s",
+				size,
+				nfread_flag ? "key_read" : "key_write",
+				ret ? "ERROR" : "OK");
+		return ret;
+	}
+
+	if (strcmp(cmd, "key_erase") == 0) {
+		ret = amlnf_key_erase();
+		aml_nand_msg("key erase %s", ret ? "Fail" : "Okay");
+		return ret;
+	}
+#endif
+	/* avoid fail... */
+	amlnf_get_chip_size(&chipsize);
+
+	if ((strcmp(cmd, "devread") == 0) || (strcmp(cmd, "devwrite") == 0)) {
+
+		if (argc < 6)
+			goto usage;
+
+		dev_name = argv[2];
+		if (strcmp(dev_name, "boot") == 0)
+			dev_name = NAND_BOOT_NAME;
+		else if (strcmp(dev_name, "code") == 0)
+			dev_name = NAND_CODE_NAME;
+		else if (strcmp(dev_name, "cache") == 0)
+			dev_name = NAND_CACHE_NAME;
+		else if (strcmp(dev_name, "data") == 0)
+			dev_name = NAND_DATA_NAME;
+		else {
+			aml_nand_msg("input wrong name!! %s", dev_name);
+			goto usage;
+		}
+		addr = (ulong)strtoul(argv[3], NULL, 16);
+		aml_nand_dbg("addr = %llx", addr);
+
+		devread = strncmp(cmd, "devread", 7) == 0;
+		/* 1 = devread, 0 = devwrite */
+		aml_nand_msg("NAND %s: addr:%lx",
+			devread ? "devread" : "devwrite",
+			addr);
+
+		if (arg_off_size(argc - 4,
+			(char **)(argv + 4),
+			chipsize,
+			&off,
+			&size) != 0)
+			goto usage;
+
+		phydev = aml_phy_get_dev(dev_name);
+		if (!phydev) {
+			aml_nand_msg("phydev be NULL");
+			return -1;
+		}
+		devops = &(phydev->ops);
+
+		memset(devops, 0x0, sizeof(struct phydev_ops));
+		devops->addr = off;
+		devops->len = size;
+		devops->mode = NAND_HW_ECC;
+		devops->datbuf = (u8 *)addr;
+
+		if (devread) {
+			ret = nand_read_ops(phydev);
+			if (ret < 0)
+				aml_nand_dbg("nand read failed");
+		} else {
+			ret = nand_write_ops(phydev);
+			if (ret < 0)
+				aml_nand_dbg("nand write failed");
+		}
+
+		aml_nand_msg("%llu bytes %s : %s",
+			size,
+			devread ? "devread" : "devwrite",
+			ret ? "ERROR" : "OK");
+		return 0;
+	}
+
+	if ((strcmp(cmd, "deverase") == 0)) {
+		if (argc < 4)
+			goto usage;
+
+		int percent = 0;
+		int percent_complete = -1;
+		int without_check = 0;
+
+		dev_name = argv[2];
+		if (strcmp(dev_name, "boot") == 0) {
+			dev_name = NAND_BOOT_NAME;
+			/* do not check bad block in uboot area! */
+			without_check = 1;
+		}
+		else if (strcmp(dev_name, "code") == 0)
+			dev_name = NAND_CODE_NAME;
+		else if (strcmp(dev_name, "cache") == 0)
+			dev_name = NAND_CACHE_NAME;
+		else if (strcmp(dev_name, "data") == 0)
+			dev_name = NAND_DATA_NAME;
+		else {
+			aml_nand_msg("input wrong name!! %s", dev_name);
+			goto usage;
+		}
+		phydev = aml_phy_get_dev(dev_name);
+		if (!phydev) {
+			aml_nand_msg("phydev be NULL");
+			return -1;
+		}
+
+		devops = &(phydev->ops);
+		if (!strcmp(argv[3], "whole")) {
+			off = 0;
+			size = phydev->size;
+			erase_addr = erase_off = off;
+			erase_len = size;
+			printf("whole dev.\n");
+		} else {
+			if ((strcmp(cmd, "deverase") == 0) && (argc < 3))
+				goto usage;
+			if ((arg_off_size(argc - 3,
+					(char **)(argv + 3),
+					phydev->size,
+					&off,
+					&size) != 0))
+				goto usage;
+			aml_nand_dbg("off:0x%llx size:%llx.\n", off, size);
+			erase_addr = erase_off = off;
+			erase_len = size;
+		}
+
+		aml_nand_dbg("erase_len = %llx", erase_len);
+		aml_nand_dbg("erase_off = %llx", erase_off);
+
+		if (erase_len < phydev->erasesize) {
+			aml_nand_msg("size 0x%016llx smaller than one blk 0x%08x",
+				erase_len,
+				phydev->erasesize);
+			aml_nand_msg("Erasing 0x%08x instead",
+				phydev->erasesize);
+			erase_len = phydev->erasesize;
+		}
+
+		for (;
+		erase_addr < erase_off + erase_len;
+		erase_addr +=  phydev->erasesize) {
+			memset(devops, 0x0, sizeof(struct phydev_ops));
+			devops->addr = erase_addr;
+			devops->len = phydev->erasesize;
+			devops->mode = NAND_HW_ECC;
+			if (!without_check) {
+				ret = phydev->block_isbad(phydev);
+				if (ret > 0) {
+					aml_nand_msg("\rSkipping bad block at 0x%08llx",
+						erase_addr);
+					continue;
+				} else if (ret < 0) {
+					aml_nand_msg("get blk failed:ret=%d addr=%llx",
+						ret,
+						erase_addr);
+					return -1;
+				}
+			}
+			ret = nand_erase(phydev);
+			if (ret < 0) {
+				aml_nand_msg("\nAMLNAND Erase fail:%d %llx\n",
+					ret,
+					erase_addr);
+				ret = phydev->block_markbad(phydev);
+				if (ret < 0)
+					aml_nand_msg("bad blk mark fail:%llx\n",
+					erase_addr);
+				continue;
+			}
+
+			percent = (erase_addr * 100) / (erase_off + erase_len);
+			if ((percent != percent_complete)
+				&& ((percent % 10) == 0)) {
+				percent_complete = percent;
+				aml_nand_msg("erasing %d %%-%d %% complete",
+					percent,
+					percent+10);
+			}
+		}
+		aml_nand_msg("NAND %s %s\n", "ERASE",
+			(ret < 0) ? "ERROR" : "OK");
+		return 0;
+	}
+	if (strcmp(cmd, "dump") == 0) {
+		dev_name = argv[2];
+		if (strcmp(dev_name, "boot") == 0)
+			dev_name = NAND_BOOT_NAME;
+		else if (strcmp(dev_name, "cache") == 0)
+			dev_name = NAND_CACHE_NAME;
+		else if (strcmp(dev_name, "code") == 0)
+			dev_name = NAND_CODE_NAME;
+		else if (strcmp(dev_name, "data") == 0)
+			dev_name = NAND_DATA_NAME;
+		else {
+			aml_nand_msg("input wrong name!! %s", dev_name);
+			goto usage;
+		}
+		addr = (ulong)strtoul(argv[3], NULL, 16);
+		aml_nand_dbg("addr = %llx", addr);
+
+		if (arg_off_size(argc - 4,
+			(char **)(argv + 4),
+			chipsize,
+			&off,
+			&size) != 0)
+			goto usage;
+
+		phydev = aml_phy_get_dev(dev_name);
+		if (!phydev) {
+			aml_nand_msg("phydev be NULL");
+			return -1;
+		}
+
+		devops = &(phydev->ops);
+		memset(devops, 0x0, sizeof(struct phydev_ops));
+		devops->addr = off;
+		devops->len = phydev->writesize;
+		devops->oobbuf = NULL;
+		devops->datbuf = (u8 *)addr;
+		devops->mode = NAND_SOFT_ECC;
+
+		amlnand_dump_page(phydev);
+		return 0;
+	}
+
+	if ((strcmp(cmd, "scrub") == 0) || (strcmp(cmd, "erase") == 0)) {
+		int scrub_flag = !strncmp(cmd, "scrub", 5);
+		if (argc < 2)
+			goto usage;
+
+		if (scrub_flag) {
+			puts("Warning:"
+				"devscrub option will erase all factory set "\
+				"bad blocks !\n"\
+				"         "\
+				"There is no reliable way to recover them.\n"\
+				"         "\
+				"Use this command only for testing purposes "\
+				"if you\n"\
+				"         "\
+				"are sure of what you are doing !\n"
+				"\nReally scrub this NAND flash ? < y/N >"\
+				"\n");
+			scrub_flag = 0;
+			if (nand_protect) {
+				if (getc() == 'y') {
+					puts("y");
+					if (getc() == '\r')
+						scrub_flag = 1;
+					else {
+						puts("scrub aborted\n");
+						return -1;
+					}
+				} else {
+					puts("scrub aborted\n");
+					return -1;
+				}
+			} else
+			    scrub_flag = 1;
+		}
+
+		if (!strcmp(argv[2], "whole")) {
+			off = 0;
+			/* ((u64)flash->chipsize << 20); */
+			size = chipsize;
+			erase_addr = erase_off = off;
+			erase_len = size;
+			printf("whole dev.\n");
+		} else {
+			if ((arg_off_size(argc - 2,
+				(char **)(argv + 2),
+				chipsize,
+				&off,
+				&size) != 0))
+				goto usage;
+			erase_addr = erase_off = off;
+			erase_len = size;
+		}
+
+		erase_addr = erase_off = off;
+		erase_len = size;
+		ret = amlnf_erase_ops(off, erase_len, scrub_flag);
+		if (ret < 0)
+			aml_nand_msg("nand erase failed");
+		return ret;
+	}
+    if (strcmp(cmd, "markbad") == 0) {
+
+		if (argc < 4) {
+			goto usage;
+		}
+
+		dev_name = argv[2];
+		if (strcmp(dev_name, "boot") == 0) {
+			dev_name = NAND_BOOT_NAME;
+		}
+		else if(strcmp(dev_name, "code") == 0){
+			dev_name = NAND_CODE_NAME;
+		}else if(strcmp(dev_name, "cache") == 0){
+			dev_name = NAND_CACHE_NAME;
+		}else if(strcmp(dev_name, "data") == 0){
+			dev_name = NAND_DATA_NAME;
+		}else{
+			aml_nand_msg("input wrong name!! %s",dev_name);
+			goto usage;
+		}
+		phydev = aml_phy_get_dev(dev_name);
+		if (!phydev) {
+			aml_nand_msg("phydev be NULL");
+			return -1;
+		}
+
+		devops = &(phydev->ops);
+
+		if ((arg_off_size(argc - 3, (char **)(argv + 3), phydev->size, &off, &size) != 0)) {
+			goto usage;
+		}
+		aml_nand_dbg("off:0x%llx size:%llx.\n", off, size);
+		erase_addr =erase_off= off;
+		erase_len = size;
+
+
+		aml_nand_dbg("erase_len = %llx",erase_len);
+		aml_nand_dbg("erase_off = %llx",erase_off);
+
+		if (erase_len < phydev->erasesize) {
+			printf("Warning: markbad size 0x%08x smaller than one "	\
+				   "block 0x%08x\n",(unsigned int)erase_len, phydev->erasesize);
+			printf("		 markbad 0x%08x instead\n", phydev->erasesize);
+			erase_len = phydev->erasesize;
+		}
+
+        for (; erase_addr <erase_off + erase_len; erase_addr +=  phydev->erasesize) {
+            memset(devops, 0x0, sizeof(struct phydev_ops));
+            devops->addr = erase_addr;
+            devops->len = phydev->erasesize;
+            devops->mode = NAND_HW_ECC;
+
+             ret = phydev->block_isbad(phydev);
+            if (ret > 0) {
+                printf("\rSkipping bad block at 0x%08llx\n", erase_addr);
+                continue;
+
+            } else if (ret < 0) {
+                printf("\n:AMLNAND get bad block failed: ret=%d at addr=%llx\n",ret, erase_addr);
+                return -1;
+            }
+
+            ret = phydev->block_markbad(phydev);
+            if (ret < 0)
+                printf("AMLNAND bad block mark failed: %llx\n", erase_addr);
+
+        }
+		printf("NAND %s %s\n", "MARKBAD", (ret <0) ? "ERROR" : "OK");
+		return 0;
+	}
+    if (strcmp(cmd, "markbad_reserved") == 0) {
+
+		if (argc < 3) {
+			goto usage;
+		}
+
+		if (!(str2long(argv[2], (unsigned long*)&markbad_reserved_addr))) {
+			aml_nand_dbg("'%s' is not a number", argv[2]);
+			goto usage;
+		}
+		printf("mark_reserved block:%d\n", (int)markbad_reserved_addr);
+		ret = amlnf_markbad_reserved_ops(markbad_reserved_addr);
+
+		printf("NAND %s %s\n", "MARKBAD", (ret <0) ? "ERROR" : "OK");
+		return 0;
+	}
+usage:
+	printf("may be invalid argus, check again.\n");
+	cmd_usage(cmdtp);
+	return 1;
+}
+
+#ifdef CONFIG_SYS_LONGHELP
+static char amlnand_help_text[] =
+	"init - init amlnand_phy here\n"
+	"chipinfo - show aml chip information\n"
+	"device[dev] - show or set current device\n"
+	"partition* [part] - show or set current partition\n"
+	"plane[dev] - show or set current plane mode\n"
+	"read - addr off|partition size\n"
+	"write - addr off|partition size\n"
+	"    read/write 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"erase[clean|whole][off size] - erase 'size' bytes from\n"
+	"    offset 'off' (entire device if not specified)\n"
+	"dump  addr off\n"
+	"    show the raw data to addr at offset off\n"
+	"read_byte - addr off|partition size\n"
+	"write_byte - addr off|partition size\n"
+	"    read_byte/write_byte 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"devread  - addr off|partition size\n"
+	"devwrite - addr off|partition size\n"
+	"    read/write 'size' bytes starting at offset 'off' in device[dev]\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"deverase[whole][off size] - erase 'size' bytes from\n"
+	"    offset 'off' (entire device if not specified) in device[dev]\n"
+	"markbad addr - mark block bad at addr\n"
+	"mark_reserved reserved_blk_NO -mark reserved_blk_NO bad \n"
+	"ldevice[dev] - show/get nftl(logic) device by name\n"
+	"rom_read/write addr off cnt - read/write uboot.\n"
+	"boot - show boot flag"
+#if (AML_CFG_DTB_RSV_EN)
+	"dtb_read/write addr cnt - read/write dtd.\n"
+	"dtb_erase - erase dtb!\n"
+#endif
+#if (AML_CFG_KEY_RSV_EN)
+	"key_read/write addr cnt - read/write dtd.\n"
+	"key_erase - erase keys!\n"
+#endif
+	"";
+#endif
+
+U_BOOT_CMD(
+	amlnf, CONFIG_SYS_MAXARGS, 0, do_amlnfphy,
+	"aml nand sub-system",
+	amlnand_help_text
+);
+
+
diff --git a/drivers/nand/dev/cmd_amlnf_test.c b/drivers/nand/dev/cmd_amlnf_test.c
new file mode 100644
index 0000000..e1ea3f4
--- /dev/null
+++ b/drivers/nand/dev/cmd_amlnf_test.c
@@ -0,0 +1,798 @@
+
+#include "../include/phynand.h"
+
+extern int amlnand_init(unsigned char flag);
+extern void amlchip_dumpinfo(struct amlnand_chip *aml_chip);
+extern void amldev_dumpinfo(struct amlnand_phydev *phydev);
+//static int plane_mode = 0;
+//struct aml_nftl_dev * nftl_device;
+
+/* just like memset function but the paraments' type is  little different */
+void *memset_nand_test(void *s, u32 c, size_t count)
+{
+	u32 *sl = (u32 *) s;
+	u32 cl = 0;
+	//char *s8;
+	int i;
+
+	/* do it one word at a time (32 bits or 64 bits) while possible */
+	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
+
+		for (i = 0; i < sizeof(*sl); i++) {
+			cl <<= 8;
+			cl |= c & 0xff;
+			c =c >>8;
+		}
+		while (count >= sizeof(*sl)) {
+			*sl++ = cl;
+			count -= sizeof(*sl);
+		}
+	}
+	/* fill 8 bits at a time */
+	/*s8 = (char *)sl;            //this can write one byte
+	while (count--)
+		*s8++ = c;*/
+
+	return s;
+}
+static int nand_erase_ops_test(struct amlnand_phydev *phydev, uint64_t off, uint64_t len)
+{
+	//struct amlnand_chip *aml_chip = phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	//struct hw_controller *controller = &(aml_chip->controller);
+	//struct chip_operation *operation = &(aml_chip->operation);
+	//struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+
+	uint64_t erase_addr, erase_len, erase_off;
+	int ret = 0;
+
+	erase_addr = erase_off = off;
+	erase_len = len ;
+
+	if ((erase_off+erase_len) > phydev->size ) {
+		aml_nand_msg("nand write size is out of space");
+		ret= -NAND_ERASE_FAILED;
+		goto exit_error;
+	}
+
+	for (; erase_addr < erase_off + erase_len; erase_addr +=  phydev->erasesize) {
+
+		memset(devops, 0x0, sizeof(struct phydev_ops));
+		devops->addr = erase_addr;
+		devops->len = phydev->erasesize;
+		devops->mode = NAND_HW_ECC;
+
+		 ret = phydev->block_isbad(phydev);
+		if (ret > 0) {
+			aml_nand_msg("Skipping bad block at 0x%08llx", erase_addr);
+			continue;
+
+		} else if (ret < 0) {
+			aml_nand_msg("nand get bad block failed: ret=%d at addr=%llx",ret, erase_addr);
+			ret =  -NAND_ERASE_FAILED;
+		}
+		extern int nand_erase(struct amlnand_phydev *phydev);
+		ret = nand_erase(phydev);
+		if (ret < 0) {
+			aml_nand_msg("nand Erase failure: %d %llx", ret, erase_addr);
+			ret =  -NAND_ERASE_FAILED;
+		}
+	}
+
+
+exit_error:
+
+	return ret;
+}
+
+static int nand_read_ops_test(struct amlnand_phydev *phydev,uint64_t off , uint64_t len , unsigned char * dat_buf)
+{
+	//struct amlnand_chip *aml_chip =phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	uint64_t offset , write_len;
+	unsigned char * buffer = NULL;
+	int ret = 0;
+
+	offset = off;
+	write_len = len;
+	buffer = aml_nand_malloc(2 * phydev->writesize);
+	if (!buffer) {
+		aml_nand_msg("nand read test malloc failed");
+		ret = -NAND_READ_FAILED;
+		goto exit_error;
+	}
+
+	if (!dat_buf) {
+		aml_nand_msg("nand read no buf");
+		return -NAND_READ_FAILED;
+	}
+
+	if ((offset & (phydev->writesize - 1)) != 0 ||(write_len & (phydev->writesize - 1)) != 0) {
+		aml_nand_msg ("Attempt to read non page aligned data");
+		return -NAND_READ_FAILED;
+	}
+
+	if ((offset + write_len) > phydev->size) {
+		aml_nand_msg("Attemp to read out side the dev area");
+		return -NAND_READ_FAILED;
+	}
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = buffer;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+	aml_nand_dbg("phydev->writesize= %x",phydev->writesize);
+	do {
+		if ((devops->addr % phydev->erasesize) == 0 ) {
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				aml_nand_msg("Skipping bad block at %llx", devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				aml_nand_msg("AMLNAND get bad block failed: ret=%d at addr=%llx",ret, devops->addr);
+				return -1;
+			}
+		}
+		memset(buffer,0x0,(2 * phydev->writesize));
+		ret = phydev->read(phydev);
+		if ((ret)) {
+			aml_nand_msg("nand read failed at %llx",devops->addr);
+		}
+		if (memcmp(buffer,dat_buf,phydev->writesize)) {
+			aml_nand_msg("nand read test verify failed");
+			break;
+		}
+		devops->addr +=  phydev->writesize;
+
+	}while(devops->addr < (offset + write_len));
+
+
+exit_error:
+
+	if (buffer) {
+		aml_nand_free(buffer);
+	}
+
+	return ret;
+}
+#if 0
+static int nand_read_oob_ops_test(struct amlnand_phydev *phydev,uint64_t off , uint64_t len , unsigned char * dat_buf)
+{
+	//struct amlnand_chip *aml_chip =phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	uint64_t offset , write_len;
+	unsigned char * buffer = NULL;
+	int ret = 0;
+
+	offset = off;
+	write_len = len;
+	buffer = aml_nand_malloc(2 * phydev->writesize);
+	if (!buffer) {
+		aml_nand_msg("nand read oob test malloc failed");
+		ret = -NAND_READ_FAILED;
+		goto exit_error;
+	}
+
+	if (!dat_buf) {
+		aml_nand_msg("nand read oob no buf");
+		return -NAND_READ_FAILED;
+	}
+
+	if ((offset & (phydev->writesize - 1)) != 0 ||(write_len & (phydev->writesize - 1)) != 0) {
+		aml_nand_msg ("Attempt to read non page aligned data");
+		return -NAND_READ_FAILED;
+	}
+
+	if ((offset + write_len) > phydev->size) {
+		aml_nand_msg("Attemp to read out side the dev area");
+		return -NAND_READ_FAILED;
+	}
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = NULL;
+	devops->oobbuf = buffer;
+	devops->mode = NAND_HW_ECC;
+	aml_nand_dbg("phydev->writesize= %x",phydev->writesize);
+	do {
+		if ((devops->addr % phydev->erasesize) == 0 ) {
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				aml_nand_msg("Skipping bad block at %llx", devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				aml_nand_msg("AMLNAND get bad block failed: ret=%d at addr=%llx",ret, devops->addr);
+				return -1;
+			}
+		}
+		memset(buffer,0x0,(2 * phydev->writesize));
+		ret = phydev->read_oob(phydev);
+		if ((ret)) {
+			aml_nand_msg("nand read oob failed at %llx",devops->addr);
+		}
+		if (memcmp(buffer,dat_buf,phydev->writesize)) {
+			aml_nand_msg("nand read oob test verify failed");
+			break;
+		}
+		devops->addr +=  phydev->writesize;
+
+	}while(devops->addr < (offset + write_len));
+
+
+exit_error:
+
+	if (buffer) {
+		aml_nand_free(buffer);
+	}
+
+	return ret;
+}
+#endif
+
+static int nand_write_ops_test(struct amlnand_phydev *phydev , uint64_t off, uint64_t len, unsigned char * dat_buf, int flag)
+{
+	//struct amlnand_chip *aml_chip = phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	unsigned char * verify_buf =NULL;
+	unsigned char * buffer = NULL;
+	uint64_t offset , write_len;
+	int ret = 0;
+
+	offset = off;
+	write_len = len;
+	buffer = dat_buf;
+	flag = 1; /* fixme, verify flag! */
+	if (!buffer) {
+		aml_nand_msg("nand write no buf");
+		return -NAND_WRITE_FAILED;
+	}
+
+	if ((offset & (phydev->writesize - 1)) != 0 ||(write_len & (phydev->writesize - 1)) != 0) {
+		aml_nand_msg ("Attempt to write non page aligned data");
+		return -NAND_WRITE_FAILED;
+	}
+
+	if ((offset + write_len) > phydev->size) {
+		aml_nand_msg("Attemp to write out side the dev area : %llx, %llx",(offset + write_len),phydev->size);
+		return -NAND_WRITE_FAILED;
+	}
+
+	if (flag == 1) {
+		verify_buf = aml_nand_malloc(2*phydev->writesize);
+		if (!verify_buf) {
+			aml_nand_msg("Attemp to write out side the dev area");
+			ret =  -NAND_WRITE_FAILED;
+			goto exit_error;
+		}
+	}
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = buffer;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+	aml_nand_dbg("phydev->writesize= %x",phydev->writesize);
+	do {
+		if ((devops->addr % phydev->erasesize) == 0 ) {
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				aml_nand_msg("Skipping bad block at %llx", devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				aml_nand_msg("AMLNAND get bad block failed: ret=%d at addr=%llx",ret, devops->addr);
+				return -1;
+			}
+		}
+		ret = phydev->write(phydev);
+		if (ret < 0) {
+			aml_nand_msg("nand write failed at %llx",devops->addr);
+			ret = -NAND_WRITE_FAILED;
+			goto exit_error;
+		}
+
+		if (flag == 1) { // verify data
+			memset(verify_buf, 0x0, (2*phydev->writesize));
+			devops->datbuf = verify_buf;
+			ret = phydev->read(phydev);
+			if (ret) {
+				aml_nand_msg("nand test read data failed at  %llx",devops->addr);
+				ret = -NAND_WRITE_FAILED;
+				goto exit_error;
+			}
+			if (memcmp(verify_buf, buffer, phydev->writesize)) {
+				aml_nand_msg("nand test verify data failed at  %llx",devops->addr);
+				ret = -NAND_WRITE_FAILED;
+				goto exit_error;
+			}
+			devops->datbuf = buffer;
+		}
+
+		devops->addr +=  phydev->writesize;
+
+		if ((((phydev->offset + devops->addr) % phydev->erasesize) == 0))
+			aml_nand_msg("aml nand write devops->addr %llx OK",devops->addr);
+
+	}while(devops->addr < (offset + write_len));
+
+
+exit_error:
+
+	if (flag == 1) {
+		if (verify_buf) {
+			aml_nand_free(verify_buf);
+		}
+	}
+	return ret;
+}
+//nand_test  4 write and read  every block test
+static int amlnand_test4(void)
+{
+    struct amlnand_phydev *phydev = NULL;
+    //struct amlnand_chip *aml_chip;
+    //struct phydev_ops  *devops;
+
+    int ret =0, j = 0, verify_lag  =0;
+    unsigned char * data_buf = NULL;
+    uint64_t offset = 0 , write_len = 0,read_len=0;
+    uint64_t erase_len, erase_off;
+
+    list_for_each_entry(phydev,&nphy_dev_list,list){
+        data_buf = aml_nand_malloc( phydev->writesize);
+        if (!data_buf) {
+            aml_nand_msg("malloc failed");
+            goto exit_0;
+        }
+    memset(data_buf, 0xa5, phydev->writesize);
+    if (strncmp(phydev->name,NAND_BOOT_NAME,strlen((const char*)NAND_BOOT_NAME))) {
+        aml_nand_msg("nand test 4 : phydev->name %s",phydev->name);
+        //aml_chip = (struct amlnand_chip *)phydev->priv;
+        //devops = &phydev->ops;
+//erase
+        erase_off = 0;
+        erase_len = phydev->size ;
+        ret = nand_erase_ops_test(phydev, erase_off, erase_len);
+        if (ret < 0) {
+            aml_nand_msg("nand test 4 : erase failed ");
+            ret= -NAND_ERASE_FAILED;
+            goto exit_0;
+        }
+        aml_nand_msg("nand test 4 : erase %d times OK ",j);
+//write
+        offset = 0;
+        write_len =  phydev->size;
+        verify_lag = 0;  // 1 indicate verify data when write
+        ret = nand_write_ops_test(phydev, offset, write_len,data_buf,verify_lag);
+        if (ret < 0 ) {
+            aml_nand_msg("nand test 4 : write failed ");
+            ret= -NAND_WRITE_FAILED;
+            goto exit_0;
+        }
+        aml_nand_msg("nand test 4 : write %d times OK ",j);
+//read disturb
+        offset = 0;
+        read_len =  phydev->size;
+        ret = nand_read_ops_test(phydev, offset, read_len,data_buf);
+        if (ret < 0 ) {
+            aml_nand_msg("nand test 4 : read failed ");
+            ret= -NAND_READ_FAILED;
+            goto exit_0;
+        }
+        aml_nand_msg("nand test 4 : read %d times OK ",j);
+    }
+    if (data_buf)
+       {
+        kfree(data_buf);
+        data_buf = NULL;
+       }
+    }
+
+exit_0:
+    if (data_buf) {
+        kfree(data_buf);
+        data_buf = NULL;
+    }
+
+    return ret;
+
+}
+
+static int amlnand_test3(void)
+{
+    struct amlnand_phydev *phydev = NULL;
+    //struct amlnand_chip *aml_chip;
+    //struct phydev_ops  *devops;
+
+    int ret =0, verify_lag  =0;
+    unsigned char * data_buf = NULL;
+    uint64_t offset = 0 , write_len = 0,read_len=0, i = 0;
+    uint64_t erase_len, erase_off;
+
+    list_for_each_entry(phydev,&nphy_dev_list,list){
+        data_buf = aml_nand_malloc( phydev->writesize);
+        if (!data_buf) {
+            aml_nand_msg("malloc failed");
+            goto exit_0;
+        }
+    memset(data_buf, 0xa5, phydev->writesize);
+    if (strncmp(phydev->name,NAND_BOOT_NAME,strlen((const char*)NAND_BOOT_NAME))) {
+        aml_nand_msg("nand test 3 : phydev->name %s",phydev->name);
+        //aml_chip = (struct amlnand_chip *)phydev->priv;
+        //devops = &phydev->ops;
+        aml_nand_msg("nand test 3 : phydev->size=%llx ",phydev->size);
+//erase
+        erase_off = 0;
+        erase_len = phydev->size ;
+        ret = nand_erase_ops_test(phydev, erase_off, erase_len);
+        if (ret < 0) {
+            aml_nand_msg("nand test 3 : erase failed ");
+            ret= -NAND_ERASE_FAILED;
+            goto exit_0;
+        }
+        aml_nand_msg("nand test 3 : erase OK ");
+        for (i=0;i<(phydev->size>>phydev->erasesize_shift)-1;i++) {
+    //write
+            offset = i<<phydev->erasesize_shift;
+            write_len =  (i&0xff)*phydev->writesize;
+            verify_lag = 1;  // 1 indicate verify data when write
+            aml_nand_msg("nand test 3 : poffset=%llx ",offset);
+            ret = nand_write_ops_test(phydev, offset, write_len,data_buf,verify_lag);
+            if (ret < 0 ) {
+                aml_nand_msg("nand test 3 : write failed ");
+                ret= -NAND_WRITE_FAILED;
+                goto exit_0;
+            }
+            aml_nand_msg("nand test 3 : write OK ");
+    //read disturb
+            offset = i<<phydev->erasesize_shift;
+            read_len =  (i&0xff)*phydev->writesize;
+            ret = nand_read_ops_test(phydev, offset, read_len,data_buf);
+            if (ret < 0 ) {
+                aml_nand_msg("nand test 3 : read failed ");
+                ret= -NAND_READ_FAILED;
+                goto exit_0;
+            }
+            aml_nand_msg("nand test 3 : read OK ");
+        }
+    }
+    if (data_buf)
+       {
+        kfree(data_buf);
+        data_buf = NULL;
+       }
+    }
+
+exit_0:
+    if (data_buf) {
+        kfree(data_buf);
+        data_buf = NULL;
+    }
+
+    return ret;
+
+}
+
+//nand_test  2 Endurance test
+static int amlnand_test2(void)
+{
+    struct amlnand_phydev *phydev = NULL;
+    //struct amlnand_chip *aml_chip;
+    //struct phydev_ops  *devops;
+
+    int ret =0, j = 0, verify_lag  =0;
+    unsigned char * data_buf = NULL;
+    uint64_t offset = 0 , write_len = 0,read_len=0;
+    uint64_t erase_len, erase_off;
+    //int read_times  = 1000;
+
+    list_for_each_entry(phydev,&nphy_dev_list,list){
+        data_buf = aml_nand_malloc( phydev->writesize);
+        if (!data_buf) {
+            aml_nand_msg("malloc failed");
+            goto exit_0;
+        }
+        for (j=1;j<3000;j++)
+        {
+            memset(data_buf, 0xa5, phydev->writesize);
+        if (strncmp(phydev->name,NAND_BOOT_NAME,strlen((const char*)NAND_BOOT_NAME))) {
+            aml_nand_msg("nand test 2 : phydev->name %s",phydev->name);
+            //aml_chip = (struct amlnand_chip *)phydev->priv;
+            //devops = &phydev->ops;
+//erase
+            erase_off = 0;
+            erase_len = phydev->size ;
+            ret = nand_erase_ops_test(phydev, erase_off, erase_len);
+            if (ret < 0) {
+                aml_nand_msg("nand test 2 : erase failed ");
+                ret= -NAND_ERASE_FAILED;
+                goto exit_0;
+            }
+            aml_nand_msg("nand test 2 : erase %d times OK ",j);
+//write
+            offset = 0;
+            write_len =  phydev->size;
+            verify_lag = 0;  // 1 indicate verify data when write
+            ret = nand_write_ops_test(phydev, offset, write_len,data_buf,verify_lag);
+            if (ret < 0 ) {
+                aml_nand_msg("nand test 2 : write failed ");
+                ret= -NAND_WRITE_FAILED;
+                goto exit_0;
+            }
+            aml_nand_msg("nand test 2 : write %d times OK ",j);
+//read disturb
+            offset = 0;
+            read_len =  phydev->size;
+            ret = nand_read_ops_test(phydev, offset, read_len,data_buf);
+            if (ret < 0 ) {
+                aml_nand_msg("nand test 2 : read failed ");
+                ret= -NAND_READ_FAILED;
+                goto exit_0;
+            }
+            aml_nand_msg("nand test 2 : read %d times OK ",j);
+        }
+     }
+    if (data_buf)
+       {
+        kfree(data_buf);
+        data_buf = NULL;
+       }
+    }
+
+exit_0:
+    if (data_buf) {
+        kfree(data_buf);
+        data_buf = NULL;
+    }
+
+    return ret;
+
+
+}
+//nand_test  1 Read Distub test
+static int amlnand_test1(void)
+{
+	struct amlnand_phydev *phydev = NULL;
+	//struct amlnand_chip *aml_chip;
+	//struct phydev_ops  *devops;
+
+	int ret =0, i = 0, verify_lag  =0;
+	unsigned char * data_buf = NULL;
+	uint64_t offset = 0 , write_len = 0,read_len=0;
+	uint64_t erase_len, erase_off;
+	int read_times  = 10000;
+
+	list_for_each_entry(phydev,&nphy_dev_list,list){
+		data_buf = aml_nand_malloc( phydev->writesize);
+		if (!data_buf) {
+			aml_nand_msg("malloc failed");
+			goto exit_0;
+		}
+		memset(data_buf, 0xa5, phydev->writesize);
+
+		if (strncmp(phydev->name,NAND_BOOT_NAME,strlen((const char*)NAND_BOOT_NAME))) {
+			aml_nand_msg("nand test 1 : phydev->name %s",phydev->name);
+			// aml_chip = (struct amlnand_chip *)phydev->priv;
+			// devops = &phydev->ops;
+//erase
+			erase_off = 0;
+			erase_len = phydev->size ;
+			ret = nand_erase_ops_test(phydev, erase_off, erase_len);
+			if (ret < 0) {
+				aml_nand_msg("nand test 1 : erase failed ");
+				ret= -NAND_ERASE_FAILED;
+				goto exit_0;
+			}
+            aml_nand_msg("nand test 1 : erase OK");
+//write
+			offset = 0;
+			write_len =  phydev->size;
+			verify_lag = 0;  // 1 indicate verify data when write
+			ret = nand_write_ops_test(phydev, offset, write_len,data_buf,verify_lag);
+			if (ret < 0 ) {
+				aml_nand_msg("nand test 1 : write failed ");
+				ret= -NAND_WRITE_FAILED;
+				goto exit_0;
+			}
+            aml_nand_msg("nand test 1 : write OK");
+//read disturb
+			for (i = 0; i < read_times; i++) {
+				offset = 0;
+				read_len =	4*phydev->erasesize;
+				ret = nand_read_ops_test(phydev, offset, read_len,data_buf);
+				if (ret < 0 ) {
+					aml_nand_msg("nand test 1 : read failed ");
+					ret= -NAND_WRITE_FAILED;
+					goto exit_0;
+				}
+                aml_nand_msg("nand test 1 : read %d times OK",i);
+			}
+
+//erase
+			erase_off = 0;
+			erase_len = phydev->size ;
+			ret = nand_erase_ops_test(phydev, erase_off, erase_len);
+			if (ret < 0) {
+				aml_nand_msg("nand test 1 : erase failed ");
+				ret= -NAND_ERASE_FAILED;
+				goto exit_0;
+			}
+
+		}
+
+		if (data_buf) {
+			kfree(data_buf);
+			data_buf = NULL;
+		}
+
+	}
+
+exit_0:
+	if (data_buf) {
+		kfree(data_buf);
+		data_buf = NULL;
+	}
+
+	return ret;
+}
+//nand_test  0 E/P/R Cycle Whole chip
+static int amlnand_test0(void)
+{
+	struct amlnand_phydev *phydev = NULL;
+	//struct amlnand_chip *aml_chip;
+	//struct phydev_ops  *devops;
+
+	int ret =0, verify_lag  =0;
+	unsigned char * data_buf = NULL;
+	uint64_t offset = 0 , write_len = 0,read_len=0;
+	uint64_t erase_len, erase_off;
+
+	list_for_each_entry(phydev,&nphy_dev_list,list){
+
+		data_buf = aml_nand_malloc(phydev->writesize);
+		if (!data_buf) {
+			aml_nand_msg("malloc failed");
+			ret = -1;
+			goto exit_0;
+		}
+		memset(data_buf, 0xa5, phydev->writesize);
+
+		if (strncmp(phydev->name,NAND_BOOT_NAME,strlen((const char*)NAND_BOOT_NAME))) {
+			aml_nand_msg("nand test 0 : phydev->name %s",phydev->name);
+			// aml_chip = (struct amlnand_chip *)phydev->priv;
+			// devops = &phydev->ops;
+//erase
+			aml_nand_msg("nand test 0 : erase");
+			erase_off = 0;
+			erase_len = phydev->size ;
+			ret = nand_erase_ops_test(phydev, erase_off, erase_len);
+			if (ret < 0) {
+				aml_nand_msg("nand test 0 : erase failed ");
+				ret= -NAND_ERASE_FAILED;
+				goto exit_0;
+			}
+//write
+			aml_nand_msg("nand test 0 : write");
+			offset = 0;
+			write_len =  phydev->size;
+			verify_lag = 0;  // 1 indicate verify data when write
+			ret = nand_write_ops_test(phydev, offset, write_len,data_buf,verify_lag);
+			if (ret < 0 ) {
+				aml_nand_msg("nand test 0 : write failed ");
+				ret= -NAND_WRITE_FAILED;
+				goto exit_0;
+			}
+//read
+			aml_nand_msg("nand test 0 : read");
+			offset = 0;
+			read_len =  phydev->size;
+			ret = nand_read_ops_test(phydev, offset, read_len,data_buf);
+			if (ret < 0 ) {
+				aml_nand_msg("nand test 0 : read failed ");
+				ret= -NAND_WRITE_FAILED;
+				goto exit_0;
+			}
+//erase
+			erase_off = 0;
+			erase_len = phydev->size ;
+			ret = nand_erase_ops_test(phydev, erase_off, erase_len);
+			if (ret < 0) {
+				aml_nand_msg("nand test 0 : erase failed ");
+				ret= -NAND_ERASE_FAILED;
+				goto exit_0;
+			}
+
+		}
+
+		if (data_buf) {
+			kfree(data_buf);
+			data_buf = NULL;
+		}
+	}
+
+exit_0:
+	if (data_buf) {
+		kfree(data_buf);
+		data_buf = NULL;
+	}
+
+	return ret;
+}
+
+
+int do_amlnand_test(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	//ulong addr;
+	//ulong data_write;
+	//loff_t off, size;
+	char *cmd;
+
+	if (argc < 2) {
+		printf("argc less than 2 :\n");
+		goto usage;
+	}
+
+	cmd = argv[1];
+
+	if (strncmp(cmd, "0", 1) == 0) {
+		ret = amlnand_test0();
+		if (ret < 0) {
+			aml_nand_msg("amlnand_test0: E/P/R Cycle failed");
+		}else
+			aml_nand_msg("amlnand_test0: E/P/R Cycle OK");
+		return 0;
+	}else if (strncmp(cmd, "1", 1) == 0){
+		ret = amlnand_test1();
+		if (ret < 0) {
+			aml_nand_msg("amlnand_test1: Read Distub test failed");
+		}else
+			aml_nand_msg("amlnand_test1: Read Distub test OK");
+		return 0;
+	}else if (strncmp(cmd, "2", 1) == 0){
+		ret = amlnand_test2();
+		if (ret < 0) {
+			aml_nand_msg("amlnand_test2: Endurance test failed");
+		}else
+			aml_nand_msg("amlnand_test2: Endurance test OK");
+		return 0;
+	}else if (strncmp(cmd, "3", 1) == 0){
+		ret = amlnand_test3();
+		if (ret < 0) {
+			aml_nand_msg("amlnand_test3: write and read random pages of every block test failed");
+		}else
+			aml_nand_msg("amlnand_test3: write and read random pages of every block test OK");
+
+		return 0;
+	}else if (strncmp(cmd, "4", 1) == 0){
+		ret = amlnand_test4();
+		if (ret < 0) {
+			aml_nand_msg("amlnand_test4: READ all page  every block test failed");
+		}else
+			aml_nand_msg("amlnand_test4: READ all page  every block test OK");
+
+		return 0;
+	}else{
+			goto usage;
+	}
+
+usage:
+	cmd_usage(cmdtp);
+	return 1;
+
+}
+
+U_BOOT_CMD(amlnf_test, CONFIG_SYS_MAXARGS, 1, do_amlnand_test,
+	"AMLPHYNAND sub-system",
+	"amlnf_test  0 E/P/R Cycle Whole chip \n"
+	"amlnf_test  1 Read Distub test,read block 0~3 10k times \n"
+	"amlnf_test  2 Endurance test, E/W/R 10 block 3000 times  \n"
+	"amlnf_test  3 write and read random pages of every block test \n"
+	"amlnf_test  4 READ all page every block   \n"
+	"amlnf_test  5 ...... \n"
+	"amlnf_test  8 exit sync \n"
+);
+
+
diff --git a/drivers/nand/dev/nandkey.c b/drivers/nand/dev/nandkey.c
new file mode 100644
index 0000000..d853ae4
--- /dev/null
+++ b/drivers/nand/dev/nandkey.c
@@ -0,0 +1,192 @@
+#include "../include/phynand.h"
+#ifndef AML_NAND_UBOOT
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <linux/crc32.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/amlogic/securitykey.h>
+#endif
+
+extern int amlnand_read_info_by_name(struct amlnand_chip *aml_chip,u8 * info,u8 * buf, u8 * name,unsigned size);
+extern int amlnand_save_info_by_name(struct amlnand_chip *aml_chip,u8 * info,u8 * buf, u8 * name,unsigned size);
+extern int amlnand_info_init(struct amlnand_chip *aml_chip, u8 * info,u8 * buf, u8 *name,unsigned size);
+
+//#define KEYSIZE (CONFIG_KEYSIZE - (sizeof(uint32_t)))
+
+static struct amlnand_chip *aml_chip_key = NULL;
+
+ int aml_nand_update_key(struct amlnand_chip * aml_chip, char *key_ptr)
+{
+	int ret = 0;
+	int malloc_flag = 0;
+	char *key_buf = NULL;
+
+	if (key_buf == NULL) {
+
+		key_buf = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+		malloc_flag = 1;
+		if (key_buf == NULL)
+			return -ENOMEM;
+		memset(key_buf,0,CONFIG_KEYSIZE);
+		ret = amlnand_read_info_by_name(aml_chip, (u8 *)&(aml_chip->nand_key),(u8 *)key_buf,(u8 *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+		if (ret) {
+			aml_nand_msg("read key error,%s\n",__func__);
+			ret = -EFAULT;
+			goto exit;
+		}
+	}else{
+		key_buf = key_ptr;
+	}
+
+	aml_nand_msg("aml_chip->nand_key : arg_type%d valid %d,update_flag %d,valid_blk_addr %d,valid_page_addr %d",aml_chip->nand_key.arg_type,aml_chip->nand_key.arg_valid,\
+		aml_chip->nand_key.update_flag,aml_chip->nand_key.valid_blk_addr,aml_chip->nand_key.valid_page_addr);
+
+	ret = amlnand_save_info_by_name( aml_chip,(u8 *)&(aml_chip->nand_key),(u8 *)key_buf, (u8 *)KEY_INFO_HEAD_MAGIC,CONFIG_KEYSIZE);
+	if (ret < 0) {
+		aml_nand_msg("aml_nand_update_key : save key info failed");
+	}
+
+exit:
+	if (malloc_flag &&(key_buf)) {
+		kfree(key_buf);
+		key_buf = NULL;
+	}
+	return 0;
+}
+
+/*
+ * This funcion reads the u-boot keyionment variables.
+ * The f_pos points directly to the key location.
+ */
+static int nand_key_read(struct aml_keybox_provider_s * provider, u8 * buf, int len, int flags)
+{
+	struct amlnand_chip * aml_chip = provider->priv;
+	struct nand_menson_key *key_ptr = NULL;
+	//int error = 0,i=0;
+	int error = 0;
+	if (len > CONFIG_KEYSIZE)
+	{
+		printk("key data len too much,%s\n",__func__);
+		return -EFAULT;
+	}
+	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+	if (key_ptr == NULL)
+		return -ENOMEM;
+	memset(key_ptr, 0, CONFIG_KEYSIZE);
+
+	error = amlnand_read_info_by_name(aml_chip, (u8 *)&(aml_chip->nand_key), (u8 *)key_ptr, (u8*)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+	//error = aml_nand_read_key(aml_chip, (u_char *)key_ptr);
+	if (error)
+	{
+		printk("read key error,%s\n",__func__);
+		error = -EFAULT;
+		goto exit;
+	}
+	memcpy(buf, key_ptr->data, len);
+
+exit:
+	kfree(key_ptr);
+	return 0;
+}
+
+static int nand_key_write(struct aml_keybox_provider_s * provider, u8 *buf,int len)
+{
+	struct amlnand_chip * aml_chip = provider->priv;
+	struct nand_menson_key *key_ptr = NULL;
+	//int error = 0,i=0;
+	int error = 0;
+
+	if (len > CONFIG_KEYSIZE)
+	{
+		printk("key data len too much,%s\n",__func__);
+		return -EFAULT;
+	}
+	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+	if (key_ptr == NULL)
+		return -ENOMEM;
+	memset(key_ptr,0,CONFIG_KEYSIZE);
+	memcpy(key_ptr->data + 0, buf, len);
+
+	error = amlnand_save_info_by_name(aml_chip, (u8 *)&(aml_chip->nand_key),(u8 *)key_ptr,(u8 *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+	if (error)
+	{
+		printk("save key error,%s\n",__func__);
+		error = -EFAULT;
+		goto exit;
+	}
+exit:
+	kfree(key_ptr);
+	return error;
+}
+
+static struct aml_keybox_provider_s nand_provider={
+	.name="nand_key",
+	.read=nand_key_read,
+	.write=nand_key_write,
+};
+
+int aml_key_init(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	struct nand_menson_key *key_ptr = NULL;
+	struct aml_keybox_provider_s * provider;
+
+	key_ptr = aml_nand_malloc(CONFIG_KEYSIZE);
+	if (key_ptr == NULL) {
+		aml_nand_msg("nand malloc for key_ptr failed");
+		ret = -1;
+		goto exit_error0;
+	}
+	memset(key_ptr,0x0,CONFIG_KEYSIZE);
+	aml_nand_msg("nand key: nand_key_probe. ");
+
+	ret = amlnand_info_init(aml_chip, (u8 *)&(aml_chip->nand_key),(u8 *)key_ptr,(u8 *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+	if (ret < 0) {
+		aml_nand_msg("invalid nand key\n");
+	}
+
+	aml_chip_key = aml_chip;
+	nand_provider.priv=aml_chip_key;
+
+	provider = aml_keybox_provider_get(nand_provider.name);
+	if (provider) {
+		return ret;
+	}
+
+	ret = aml_keybox_provider_register(&nand_provider);
+	if (ret) {
+		BUG();
+	}
+
+exit_error0:
+	if (key_ptr) {
+		aml_nand_free(key_ptr);
+		key_ptr =NULL;
+	}
+	return ret;
+}
+#ifdef AML_NAND_UBOOT
+int nandkey_provider_register(void)
+{
+	int ret = 0;
+#if 0
+	ret = aml_keybox_provider_register(&nand_provider);
+	if (ret) {
+		BUG();
+	}
+#endif
+	return ret;
+}
+#endif
+
diff --git a/drivers/nand/dev/secure_storage.c b/drivers/nand/dev/secure_storage.c
new file mode 100644
index 0000000..7c48599
--- /dev/null
+++ b/drivers/nand/dev/secure_storage.c
@@ -0,0 +1,176 @@
+
+#include "../include/phynand.h"
+
+
+//#define SECURE_SIZE  (CONFIG_SECURE_SIZE - (sizeof(uint32_t)))
+struct amlnand_chip *aml_chip_secure = NULL;
+
+
+int aml_nand_update_secure(struct amlnand_chip * aml_chip, char *secure_ptr)
+{
+	int ret = 0;
+	char malloc_flag = 0;
+	unsigned char *secure_buf = NULL;
+
+	if (secure_buf == NULL) {
+
+		secure_buf = kzalloc(CONFIG_SECURE_SIZE, GFP_KERNEL);
+		if (secure_buf == NULL)
+			return -ENOMEM;
+		memset(secure_buf,0,CONFIG_SECURE_SIZE);
+		ret = amlnand_read_info_by_name(aml_chip, (unsigned char *)(&aml_chip->nand_secure),secure_buf,(unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+		if (ret)
+		{
+			aml_nand_msg("read key error,%s\n",__func__);
+			ret = -EFAULT;
+			goto exit;
+		}
+	}else{
+		secure_buf = (unsigned char *)secure_ptr;
+	}
+
+	ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)(&aml_chip->nand_secure), secure_buf, (unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("aml_nand_update_secure : update secure failed");
+	}
+
+exit:
+	if (malloc_flag && (secure_buf)) {
+		kfree(secure_buf);
+		secure_buf = NULL;
+	}
+	return 0;
+}
+
+ int32_t nand_secure_read(struct amlnand_chip * aml_chip, char *buf,int len)
+{
+	//struct amlnand_chip * aml_chip = provider->priv;
+	//secure_t *secure_ptr = NULL;
+	unsigned char *secure_ptr = NULL;
+	int error = 0;
+	if (len > CONFIG_SECURE_SIZE)
+	{
+		aml_nand_msg("key data len too much,%s\n",__func__);
+		return -EFAULT;
+	}
+	secure_ptr = kzalloc(CONFIG_SECURE_SIZE, GFP_KERNEL);
+	if (secure_ptr == NULL)
+		return -ENOMEM;
+	memset(secure_ptr,0,CONFIG_SECURE_SIZE);
+
+	error = amlnand_read_info_by_name(aml_chip, (unsigned char *)(&aml_chip->nand_secure),secure_ptr,(unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+	if (error)
+	{
+		aml_nand_msg("read key error,%s\n",__func__);
+		error = -EFAULT;
+		goto exit;
+	}
+	//memcpy(buf, secure_ptr->data, len);
+	memcpy(buf, secure_ptr, len);
+exit:
+	kfree(secure_ptr);
+	return error;
+}
+
+int32_t nand_secure_write(struct amlnand_chip * aml_chip, char *buf,int len)
+{
+	//secure_t *secure_ptr = NULL;
+	unsigned char *secure_ptr = NULL;
+	int error = 0;
+
+	if (len > CONFIG_SECURE_SIZE)
+	{
+		aml_nand_msg("key data len too much,%s\n",__func__);
+		return -EFAULT;
+	}
+	secure_ptr = kzalloc(CONFIG_SECURE_SIZE, GFP_KERNEL);
+	if (secure_ptr == NULL)
+		return -ENOMEM;
+	memset(secure_ptr,0,CONFIG_SECURE_SIZE);
+	//memcpy(secure_ptr->data + 0, buf, len);
+	memcpy(secure_ptr, buf, len);
+
+	error = amlnand_save_info_by_name(aml_chip, (unsigned char *)(&aml_chip->nand_secure),secure_ptr,(unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+	if (error)
+	{
+		printk("save key error,%s\n",__func__);
+		error = -EFAULT;
+		goto exit;
+	}
+exit:
+	kfree(secure_ptr);
+	return error;
+}
+
+
+int aml_secure_init(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	unsigned char *secure_ptr = NULL;
+
+	secure_ptr = aml_nand_malloc(CONFIG_SECURE_SIZE);
+	if (secure_ptr == NULL) {
+		aml_nand_msg("nand malloc for secure_ptr failed");
+		ret = -1;
+		goto exit_error0;
+	}
+	memset(secure_ptr,0x0,CONFIG_SECURE_SIZE);
+	aml_nand_msg("nand secure: nand_secure_probe. ");
+
+	ret = amlnand_info_init(aml_chip, (unsigned char *)(&aml_chip->nand_secure),secure_ptr,(unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("invalid nand secure_ptr\n");
+		ret = -1;
+		goto exit_error0;
+	}
+
+#if 0
+	aml_nand_msg("nand secure debug :: save secure again !!!!");
+	ret = amlnand_save_info_by_name( aml_chip,&(aml_chip->nand_secure),secure_ptr, SECURE_INFO_HEAD_MAGIC,CONFIG_SECURE_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("nand save default secure_ptr failed aigain!!");
+	}
+
+#endif
+
+	aml_chip_secure = aml_chip;
+
+exit_error0:
+	if (secure_ptr) {
+		aml_nand_free(secure_ptr);
+		secure_ptr =NULL;
+	}
+	return ret;
+}
+
+
+#ifdef CONFIG_SECURE_NAND
+int secure_storage_nand_read(char *buf,unsigned int len)
+{
+	 struct amlnand_chip *aml_chip = aml_chip_secure;
+	int ret = 0;
+
+	ret = nand_secure_read(aml_chip,buf,len);
+	if (ret < 0) {
+		aml_nand_msg("secure storage nand read failed\n");
+	}
+
+	return ret;
+}
+
+int secure_storage_nand_write(char *buf,unsigned int len)
+{
+	 struct amlnand_chip *aml_chip = aml_chip_secure;
+	int ret = 0;
+
+	ret = nand_secure_write(aml_chip,buf,len);
+	if (ret < 0) {
+		aml_nand_msg("secure storage nand write failed\n");
+	}
+
+	return ret;
+}
+#endif
+
+
+
diff --git a/drivers/nand/include/aml_nftl_cfg.h b/drivers/nand/include/aml_nftl_cfg.h
new file mode 100644
index 0000000..7cdc5f7
--- /dev/null
+++ b/drivers/nand/include/aml_nftl_cfg.h
@@ -0,0 +1,38 @@
+#ifndef __AML_NFTL_CFG_H__
+#define __AML_NFTL_CFG_H__
+#include "../logic/aml_nftl_type.h"
+#include "../include/amlnf_cfg.h"
+
+/* #define  PRINT printk */
+
+#define NFTL_DONT_CACHE_DATA		0
+#define SUPPORT_GC_READ_RECLAIM		0
+#define SUPPORT_WEAR_LEVELING		0
+#define NFTL_ERASE			0
+
+#ifdef NAND_ADJUST_PART_TABLE
+#define PART_RESERVED_BLOCK_RATIO	10
+#else
+#define PART_RESERVED_BLOCK_RATIO	8
+#endif
+
+#define MIN_FREE_BLOCK_NUM		6
+#define GC_THRESHOLD_FREE_BLOCK_NUM	4
+
+#define MIN_FREE_BLOCK			5
+
+#define GC_THRESHOLD_RATIO_NUMERATOR	2
+#define GC_THRESHOLD_RATIO_DENOMINATOR	3
+
+#define MAX_CACHE_WRITE_NUM		4
+#define NFTL_CACHE_FLUSH_SYNC		1
+
+
+extern void aml_nftl_set_part_test(void *_part, u32 test);
+extern void *aml_nftl_get_part_priv(void *_part);
+extern void aml_nftl_add_part_total_write(void *_part);
+extern void aml_nftl_add_part_total_read(void *_part);
+extern u16 aml_nftl_get_part_write_cache_nums(void *_part);
+
+#endif /* __AML_NFTL_CFG_H__ */
+
diff --git a/drivers/nand/include/amlnf_cfg.h b/drivers/nand/include/amlnf_cfg.h
new file mode 100644
index 0000000..2e4b7c2
--- /dev/null
+++ b/drivers/nand/include/amlnf_cfg.h
@@ -0,0 +1,42 @@
+#ifndef __AML_NF_CFG_H__
+#define __AML_NF_CFG_H__
+
+/*************stage***************/
+#define	AML_NAND_UBOOT	//For uboot
+#define EXPORT_SYMBOL(...)
+/**************PHY****************/
+#define	AML_SLC_NAND_SUPPORT
+#define	AML_MLC_NAND_SUPPORT
+
+
+#define	AML_NAND_DBG				(0)
+#define	AML_CFG_INSIDE_PARTTBL		(0)
+#define AML_CFG_2PLANE_READ_EN		(1)
+/* support nand with readretry&e-slc */
+#define	AML_CFG_NEW_NAND_SUPPORT	(1)
+/* new oob mode */
+#define AML_CFG_NEWOOB_EN			(1)
+/* store dtd in rsv area! */
+#define AML_CFG_DTB_RSV_EN			(1)
+/* store key in rsv area */
+#define AML_CFG_KEY_RSV_EN			(1)
+
+#define NAND_ADJUST_PART_TABLE
+
+#ifdef NAND_ADJUST_PART_TABLE
+#define	ADJUST_BLOCK_NUM	4
+#else
+#define	ADJUST_BLOCK_NUM	0
+#endif
+
+/*do not use rb irq under uboot*/
+/* #define AML_NAND_RB_IRQ */
+
+/*
+#define AML_NAND_DMA_POLLING
+*/
+
+extern  int is_phydev_off_adjust(void);
+extern  int get_adjust_block_num(void);
+
+#endif //__AML_NF_CFG_H__
diff --git a/drivers/nand/include/amlnf_ctrl.h b/drivers/nand/include/amlnf_ctrl.h
new file mode 100644
index 0000000..fa245b4
--- /dev/null
+++ b/drivers/nand/include/amlnf_ctrl.h
@@ -0,0 +1,73 @@
+#ifndef AMLNAND_PHYDEV_H_INCLUDED
+#define AMLNAND_PHYDEV_H_INCLUDED
+
+#include "amlnf_dev.h"
+
+/***nand CE/RB pinmux setting***/
+#define	AML_NAND_CE0	0xe
+#define	AML_NAND_CE1	0xd
+#define	AML_NAND_CE2	0xb
+#define	AML_NAND_CE3	0x7
+
+#define	CE_PAD_DEFAULT	\
+	((AML_NAND_CE0) | \
+	(AML_NAND_CE1 << 4) | \
+	(AML_NAND_CE2 << 8) | \
+	(AML_NAND_CE3 << 12))
+
+/*
+#define RB_PAD_DEFAULT	((AML_NAND_CE0) | (AML_NAND_CE1 << 4))
+*/
+
+#define	RB_PAD_DEFAULT	(AML_NAND_CE0)
+#define	MAX_CHIP_NUM	4
+
+#define	PER_INFO_BYTE	8
+
+/***nand device option***/
+#define	DEV_SLC_MODE		(1<<0)
+#define	DEV_SERIAL_CHIP_MODE	(0<<1)
+#define	DEV_MULTI_CHIP_MODE	(1<<1)
+
+#define	DEV_MULTI_PLANE_MODE	(1<<2)
+#define	DEV_SINGLE_PLANE_MODE	(0<<2)
+
+#define	DEV_ECC_SOFT_MODE	(1<<3)
+#define	DEV_ECC_HW_MODE		(0<<3)
+
+#define	NAND_SHUT_DOWN		(1 << 16)
+
+#define	NAND_CODE_OPTION	(DEV_MULTI_PLANE_MODE | DEV_MULTI_CHIP_MODE)
+#define	NAND_DATA_OPTION	(DEV_MULTI_PLANE_MODE | DEV_MULTI_CHIP_MODE)
+
+/*
+ * Status for nand chip
+ */
+enum chip_state_t {
+	CHIP_READY,
+	CHIP_STATUS,
+	CHIP_ERASING,
+	CHIP_ERASE_SUSPENDING,
+	CHIP_ERASE_SUSPENDED,
+	CHIP_WRITING,
+	CHIP_WRITE_SUSPENDING,
+	CHIP_WRITE_SUSPENDED,
+	CHIP_PM_SUSPENDED,
+	CHIP_SYNCING,
+	CHIP_UNLOADING,
+	CHIP_LOCKING,
+	CHIP_UNLOCKING,
+	CHIP_POINT,
+	CHIP_SHUTDOWN,
+	CHIP_READING,
+	CHIP_RESETING,
+	CHIP_PREPARING_ERASE,
+	CHIP_VERIFYING_ERASE,
+	CHIP_UNKNOWN
+};
+
+
+extern int nandphy_init(u32 flag);
+extern int amlphy_prepare(u32 flag);
+
+#endif
diff --git a/drivers/nand/include/amlnf_dev.h b/drivers/nand/include/amlnf_dev.h
new file mode 100644
index 0000000..2553330
--- /dev/null
+++ b/drivers/nand/include/amlnf_dev.h
@@ -0,0 +1,570 @@
+#ifndef __AML_NFTL_BLOCK_H
+#define __AML_NFTL_BLOCK_H
+
+#include "amlnf_type.h"
+#include "hw_ctrl.h"
+#include "amlnf_ctrl.h"
+#include "amlnf_cfg.h"
+#include "partition_table.h"
+
+#ifndef AML_NAND_UBOOT
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#endif /*AML_NAND_UBOOT*/
+
+
+#define aml_nftl_dbg	aml_nand_dbg
+
+#define aml_nftl_malloc	aml_nand_malloc
+#define aml_nftl_free	aml_nand_free
+
+//#define NAND_LINE	 	do {aml_nand_msg("%s() l-%d", __FUNCTION__, __LINE__);} while(0);
+#define NAND_LINE		do {;} while(0);
+//#define BOOT_LINE	do {aml_nand_msg("%s() l-%d", __FUNCTION__, __LINE__);} while(0);
+#define BOOT_LINE		do {;} while(0);
+//#define PHY_NAND_LINE	do {aml_nand_msg("%s() l-%d", __FUNCTION__, __LINE__);} while(0);
+#define PHY_NAND_LINE	do {;} while(0);
+//#define ENV_NAND_LINE	do {aml_nand_msg("%s() l-%d", __FUNCTION__, __LINE__);} while(0);
+#define ENV_NAND_LINE   do {;} while(0);
+//#define CMD_LINE		do {aml_nand_msg("%s() l-%d", __FUNCTION__, __LINE__);} while(0);
+#define CMD_LINE		do {;} while(0);
+//#define PHYDEV_LINE		do {aml_nand_msg("%s() l-%d", __FUNCTION__, __LINE__);} while(0);
+#define PHYDEV_LINE		do {;} while(0);
+
+
+#define DISPROTECT_DBG			1<<4
+#if (AML_CFG_INSIDE_PARTTBL)
+/*
+ * fixme, moved from <partition_table.h>
+ */
+#define DISPROTECT_KEY    		1
+#define DISPROTECT_SECURE		1<<1
+#define DISPROTECT_FBBT			1<<2
+#define DISPROTECT_HYNIX		1<<3
+
+/*
+ * fixme, moved from <storage.h>
+ */
+#define	STORE_CODE	(1<<0)
+#define STORE_CACHE	(1<<1)
+#define STORE_DATA	(1<<2)
+#endif //0
+/*
+ * cpu version
+ **/
+
+#define	MAX_DEVICE_NUM		4
+#define	MAX_DEVICE_NAME_LEN	16
+
+
+#define AMLNF_DEV_MAJOR		250
+#define TIMESTAMP_LENGTH	15
+#define MAX_TIMESTAMP_NUM	((1<<(TIMESTAMP_LENGTH-1))-1)
+#define AML_NFTL_BOUNCE_SIZE	0x40000
+
+#define NFTL_MAX_SCHEDULE_TIMEOUT	1000
+#define NFTL_FLUSH_DATA_TIME		1
+#define NFTL_CACHE_FORCE_WRITE_LEN	16
+
+
+#define	FACTORY_BAD_BLOCK_ERROR		2
+#define	BYTES_PER_SECTOR		512
+#define	SHIFT_PER_SECTOR		9
+#define	BYTES_OF_USER_PER_PAGE		16
+#define	MIN_BYTES_OF_USER_PER_PAGE	16
+
+#define	AMLNF_DEV_RO_MODE	(1<<0)
+
+#define RET_YES		1
+#define RET_NO		0
+
+#define  PRINT aml_nftl_dbg
+
+#define	NAND_BLOCK_GOOD		0
+#define	NAND_BLOCK_USED_BAD	1
+#define	NAND_BLOCK_FACTORY_BAD	2
+
+
+#define	MAX_NAND_PART_NUM	16
+#define	MAX_NAND_PART_NAME_LEN	16
+
+#define	NAND_PART_SIZE_FULL	-1
+
+#define	NAND_BLOCK_GOOD		0
+#define	NAND_BLOCK_USED_BAD	1
+#define	NAND_BLOCK_FACTORY_BAD	2
+
+/***nand device name***/
+#define	NAND_BOOT_NAME		"nfboot"
+#define	NAND_CACHE_NAME		"nfcache"
+#define	NAND_CODE_NAME		"nfcode"
+#define	NAND_DATA_NAME		"nfdata"
+#define	NAND_RESERVED_NAME	"nfrevd"
+
+#define	PHY_DEV_NUM	3
+
+
+/***boot device flag***/
+#define SPI_BOOT_FLAG		0
+#define NAND_BOOT_FLAG		1
+#define EMMC_BOOT_FLAG		2
+#define CARD_BOOT_FLAG		3
+#define SPI_NAND_FLAG		4
+#define SPI_EMMC_FLAG		5
+
+
+/***nand BOOT flags***/
+#define NAND_BOOT_NORMAL					0
+#define NAND_BOOT_UPGRATE					1
+#define NAND_BOOT_ERASE_PROTECT_CACHE       2
+#define NAND_BOOT_ERASE_ALL   				3
+#define NAND_BOOT_SCRUB_ALL					4
+#define NAND_SCAN_ID_INIT					5
+
+/****nand debug flag info******/
+#define NAND_WRITE_VERIFY	1
+
+#define DRV_AMLNFDEV_NAME	"amlnfdev"
+#define DRV_AMLNFDEV_AUTHOR	"AMLOGIC SZ NAND TEAM"
+#define DRV_AMLNFDEV_DESC	"Amlogic Nand Flash driver"
+
+/*
+ * dummy structure for uboot. fixme,
+ */
+#ifdef AML_NAND_UBOOT
+struct platform_device {
+
+};
+#endif //
+
+struct amlnf_partition {
+	/* identifier string */
+	char name[MAX_NAND_PART_NAME_LEN];
+	/* partition size */
+	u64 size;
+	/* offset within the master space */
+	u64 offset;
+	/* master flags to mask out for this partition */
+	u32 mask_flags;
+	void *priv;
+};
+
+enum amlnf_error_t {
+	NAND_SUCCESS = 0,
+	NAND_CMD_FAILURE = 1,
+	NAND_BUSY_FAILURE = 2,
+	NAND_ID_FAILURE = 3,
+	NAND_DMA_FAILURE = 4,
+	NAND_ECC_FAILURE = 5,
+	NAND_BITFLIP_FAILURE = 6,
+	NAND_MALLOC_FAILURE = 7,
+	NAND_ARGUMENT_FAILURE = 8,
+	NAND_STATUS_FAILURE = 9,
+	NAND_WP_FAILURE = 10,
+	NAND_SELECT_CHIP_FAILURE = 12,
+	NAND_ERASE_FAILED = 13,
+	NAND_WRITE_FAILED = 14,
+	NAND_FAILED = 15,
+	NAND_READ_FAILED = 16,
+	NAND_BAD_BLCOK_FAILURE = 17,
+	NAND_SHIPPED_BAD_FAILURE = 18,
+	NAND_CONFIGS_FAILED	= 19,
+	NAND_SHIPPED_BADBLOCK_FAILED = 20,
+};
+
+struct _nftl_cfg {
+	u16 nftl_use_cache;
+	u16 nftl_support_gc_read_reclaim;
+	u16 nftl_support_wear_leveling;
+	u16 nftl_need_erase;
+	u16 nftl_part_reserved_block_ratio;
+	u16 nftl_part_adjust_block_num;
+	u16 nftl_min_free_block_num;
+	u16 nftl_gc_threshold_free_block_num;
+	u16 nftl_min_free_block;
+	u16 nftl_gc_threshold_ratio_numerator;
+	u16 nftl_gc_threshold_ratio_denominator;
+	u16 nftl_max_cache_write_num;
+};
+
+/*
+ * Constants for ECC_MODES
+ */
+enum oob_modes_t {
+	NAND_HW_ECC,
+	NAND_SOFT_ECC,
+};
+
+/**
+ * struct phydev_ops - oob operation operands
+ * @mode:	operation mode, for ecc none or hw mode
+ * @len:	number of data bytes to write/read
+ * @retlen:	number of data bytes written/read
+ * @ooblen:	number of oob bytes to write/read
+ * @oobretlen:	number of oob bytes written/read
+ * @datbuf:	data buffer - if NULL only oob data are read/written
+ * @oobbuf:	oob data buffer- if NULL only data are read/written
+ *
+ * Note, it is not allowed to read/write more than one OOB area
+ * at one go when oob operation.
+ * That is, the interface assumes that the OOB write requests
+ * program/read within only one page's
+ * OOB area.
+ */
+struct phydev_ops {
+	enum oob_modes_t mode;
+	u64 addr;
+	/* one operation less than 2GB data len */
+	u64 len;
+	u32 retlen;
+	u32 ooblen;
+	u8 *datbuf;
+	u8 *oobbuf;
+};
+
+/* #include "../phy/phynand.h" */
+/*
+ * API for NFTL driver.
+ * Provide nand basic information and common operation function.
+ * Must meet all the requirement of NFTL driver,
+ * and also consider the fulture extensions
+ */
+
+/**
+ * struct amlnand_phydev - nand phy device
+ * @name:
+ * @type: used for fulture, differ from SLC, MLC and TLC
+ * @retlen:	number of data bytes written/read
+ * @ooblen:	number of oob bytes to write/read
+ * @oobretlen:	number of oob bytes written/read
+ * @datbuf:	data buffer - if NULL only oob data are read/written
+ * @oobbuf:	oob data buffer- if NULL only data are read/written
+ *
+ * Note, it is not allowed to read/write more than one OOB area
+ * at one go when oob operation.
+ * That is, the interface assumes that the OOB write requests
+ * program/read within only one page's
+ * OOB area.
+ */
+struct amlnand_phydev {
+	const char name[MAX_DEVICE_NAME_LEN];
+
+	/*****nand flash chip type, maybe SLC/MLC/TLC ******/
+	u8 type;
+
+	u8 ecc_failed;
+	u8 bit_flip;
+
+	/*** used for Read-Only, or other feature ***/
+	u32 flags;
+
+	/*** used for other feature setting***/
+	u32 option;
+
+	/*** struct for whole nand chip***/
+	/* struct amlnand_chip *aml_chip; */
+	void *priv;
+
+	struct list_head list;
+
+#ifndef AML_NAND_UBOOT
+	struct device dev;
+	struct class cls;
+
+	struct cdev uboot_cdev;
+#endif /* AML_NAND_UBOOT */
+
+	/*** offset value of the whole nand device***/
+	u64 offset;
+
+	/*** Total size of the cunrrent nand device***/
+	u64 size;
+
+	u8 chipnr;
+
+	/*** "Major" erase size for the device. ***/
+	u32 erasesize;
+
+	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
+	 * though individual bits can be cleared), in case of NAND flash it is
+	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
+	 * it is of ECC block size, etc. It is illegal to have writesize = 0.
+	 * Any driver registering a struct mtd_info must ensure a writesize of
+	 * 1 or larger.
+	 */
+	u32 writesize;
+
+	/**** Available OOB bytes per page ***/
+	u32 oobavail;
+
+	/*
+	 * If erasesize is a power of 2 then the shift is stored in
+	 * erasesize_shift otherwise erasesize_shift is zero. Ditto writesize.
+	 */
+	u32 erasesize_shift;
+	u32 writesize_shift;
+
+	/*** Masks based on writesize_shift ***/
+	u32 writesize_mask;
+
+	/***partitions info***/
+	u8 nr_partitions;
+	struct amlnf_partition *partitions;
+
+	struct phydev_ops ops;
+	/*
+	 * Erase is an asynchronous operation.  Device drivers are supposed
+	 * to call instr->callback() whenever the operation completes, even
+	 * if it completes with a failure.
+	 * Callers are supposed to pass a callback function and wait for it
+	 * to be called before writing to the block.
+	 */
+	int (*erase)(struct amlnand_phydev *phydev);
+
+	/***basic data operation and included oob data****/
+	int (*read)(struct amlnand_phydev *phydev);
+	int (*write)(struct amlnand_phydev *phydev);
+
+	/* In blackbox flight recorder like scenarios we want to make successful
+	 * writes in interrupt context. panic_write() is only intended to be
+	 * called when its known the kernel is about to panic and we need the
+	 * write to succeed. Since the kernel is not going to be running for
+	 * much longer, this function can break locks and delay to ensure the
+	 * write succeeds (but not sleep).
+	 */
+	int (*panic_write)(struct amlnand_phydev *phydev);
+
+	int (*read_oob)(struct amlnand_phydev *phydev);
+
+	/********not support yet**********/
+	int (*write_oob)(struct amlnand_phydev *phydev);
+
+	/*
+	 * support read data for sect_uint(512bytes in genreal),
+	 * not just writesize unit, to improve read data speed.
+	 * Not spport yet.
+	 */
+	int (*read_sect)(struct amlnand_phydev *phydev);
+
+	/*
+	Sync to nand device, used for TLC nand to finish the current write ops
+	*/
+	void (*sync)(struct amlnand_phydev *phydev);
+
+	/* Chip-supported device locking */
+	int (*lock)(struct amlnand_phydev *phydev);
+	int (*unlock)(struct amlnand_phydev *phydev);
+	int (*is_locked)(struct amlnand_phydev *phydev);
+
+#ifndef AML_NAND_UBOOT
+	/* Power Management functions */
+	int (*suspend)(struct amlnand_phydev *phydev);
+	void (*resume)(struct amlnand_phydev *phydev);
+#endif /* AML_NAND_UBOOT */
+
+	/* Bad block management functions, maybe managed by NFTL layer*/
+	int (*block_isbad)(struct amlnand_phydev *phydev);
+	int (*block_markbad)(struct amlnand_phydev *phydev);
+
+	int (*block_modifybbt)(struct amlnand_phydev *phydev, int value);
+	int (*update_bbt)(struct amlnand_phydev *phydev);
+	int (*phydev_test_block)(struct amlnand_phydev *phydev);
+	/* default mode before reboot */
+	/* struct notifier_block reboot_notifier; */
+};
+
+struct amlnf_logicdev_t {
+
+#ifndef AML_NAND_UBOOT
+	struct mutex lock;
+	struct timespec ts_write_start;
+	spinlock_t thread_lock;
+	struct notifier_block nb;
+	struct task_struct *thread;
+	struct class cls;
+#endif /* AML_NAND_UBOOT */
+
+	/* struct aml_nftl_part_t* aml_nftl_part; */
+	void *priv;
+
+	struct amlnand_phydev *nand_dev;
+	/* amlnf_dev list, since several dev can share one logicdev. */
+	/* struct list_head nfdev_list; */
+	struct list_head list;
+	/* fixme, u32 may not enough! */
+	int (*read_data)(struct amlnf_logicdev_t *amlnf_logicdev,
+		u32 start_sector,
+		u32 len,
+		u8 *buf);
+	int (*write_data)(struct amlnf_logicdev_t *amlnf_logicdev,
+		u32 start_sector,
+		u32 len,
+		u8 *buf);
+	int (*flush)(struct amlnf_logicdev_t *amlnf_logicdev);
+	int (*shutdown)(struct amlnf_logicdev_t *amlnf_logicdev);
+
+	struct _nftl_cfg nftl_cfg;
+};
+
+struct amlnf_dev {
+	/* identifier string */
+	char name[MAX_NAND_PART_NAME_LEN];
+	struct amlnf_logicdev_t *logicdev;
+	struct amlnand_phydev *nand_dev;
+	u64 size_sector;
+	u64 offset_sector;
+	u32 mask_flags;
+
+#ifndef AML_NAND_UBOOT
+	struct kref ref;
+	struct request *req;
+	struct request_queue *queue;
+	spinlock_t queue_lock;
+	struct mutex mutex_lock_req;
+	struct mutex mutex_lock;
+	struct scatterlist *bounce_sg;
+	u32 bounce_sg_len;
+	bool bg_stop;
+	struct task_struct *thread;
+	struct gendisk *disk;
+	struct attribute_group *disk_attributes;
+	struct class cls;
+#endif /* AML_NAND_UBOOT */
+
+	struct list_head list;
+	/* fixme, u32 may not enough! */
+	u32(*read_sector)(struct amlnf_dev *dev,
+		u32 start_sector,
+		u32 len,
+		u8 *buf);
+	u32(*write_sector)(struct amlnf_dev *dev,
+		u32 start_sector,
+		u32 len,
+		u8 *buf);
+	u32(*flush)(struct amlnf_dev *dev);
+};
+
+extern struct list_head nphy_dev_list;
+extern struct list_head nf_dev_list;
+
+struct amlnf_platform_data {
+	volatile uint32_t *poc_reg;
+	volatile uint32_t *nf_reg_base;
+	volatile uint32_t *ext_clk_reg;
+	u32 irq;
+};
+
+struct aml_nand_device {
+	struct amlnf_platform_data	*platform_data;
+	int nandboot;
+};
+
+
+extern struct list_head nphy_dev_list;
+//extern struct partitions *part_table;
+extern struct aml_nand_device *aml_nand_dev;
+extern int boot_device_flag;
+#ifndef AML_NAND_UBOOT
+#define amlnf_notifier_to_blk(l) container_of(l, struct amlnf_logicdev_t, nb)
+extern void nand_get_chip(void *aml_chip);
+extern void nand_release_chip(void *aml_chip);
+extern int check_storage_device(void);
+
+
+
+extern ssize_t verify_nand_page(struct class *class,
+	struct class_attribute *attr,
+	const char *buf,
+	size_t count);
+extern ssize_t dump_nand_page(struct class *class,
+	struct class_attribute *attr,
+	const char *buf,
+	size_t count);
+extern ssize_t show_nand_info(struct class *class,
+	struct class_attribute *attr,
+	char *buf);
+extern ssize_t show_bbt_table(struct class *class,
+	struct class_attribute *attr,
+	const char *buf,
+	size_t count);
+extern ssize_t change_test_sync_flag(struct class *class,
+	struct class_attribute *attr,
+	const char *buf,
+	size_t count);
+extern ssize_t show_amlnf_version_info(struct class *class,
+	struct class_attribute *attr,
+	char *buf);
+extern ssize_t nand_page_read(struct class *class,
+	struct class_attribute *attr,
+	const char *buf,
+	size_t count);
+extern ssize_t nand_page_write(struct class *class,
+	struct class_attribute *attr,
+	const char *buf,
+	size_t count);
+extern ssize_t show_nand_info(struct class *class, struct class_attribute *attr, char *buf);
+extern ssize_t show_bbt_table(struct class *class, struct class_attribute *attr, char *buf);
+/*  */
+extern u16 aml_nftl_get_part_write_cache_nums(void *_part);
+extern int logicdev_bg_handle(void *priv);
+/*  */
+extern ssize_t show_part_struct(struct class *class,
+	struct class_attribute *attr,
+	char *buf);
+extern ssize_t show_list(struct class *class,
+	struct class_attribute *attr,
+	const char *buf);
+extern ssize_t discard_page(struct class *class,
+	struct class_attribute *attr,
+	const char *buf);
+extern ssize_t do_gc_all(struct class *class,
+	struct class_attribute *attr,
+	const char *buf);
+extern ssize_t do_gc_one(struct class *class,
+	struct class_attribute *attr,
+	const char *buf);
+extern ssize_t do_test(struct class *class,
+	struct class_attribute *attr,
+	const char *buf,
+	size_t count);
+
+extern int amlnf_pdev_register(struct amlnand_phydev *phydev);
+extern int amlnf_ldev_register(void);
+extern void amlchip_resume(struct amlnand_phydev *phydev);
+extern int phydev_suspend(struct amlnand_phydev *phydev);
+extern void phydev_resume(struct amlnand_phydev *phydev);
+extern int amlphy_prepare(u32 flag);
+
+extern int add_ntd_partitions(struct amlnand_phydev *master);
+extern int  boot_device_register(struct amlnand_phydev *phydev);
+#endif  /* AML_NAND_UBOOT */
+extern void *aml_nand_malloc(u32 size);
+extern void aml_nand_free(void *ptr);
+
+#ifndef AML_NAND_UBOOT
+extern void *amlnf_dma_malloc(u32 size, u8 flag);
+extern void amlnf_dma_free(const void *ptr, u32 size, u8 flag);
+#endif /* AML_NAND_UBOOT */
+
+extern int amlnf_get_logicdev(struct amlnf_logicdev_t *amlnf_logicdev);
+extern int amlnf_free_logicdev(struct amlnf_logicdev_t *amlnf_logicdev);
+extern int amlnf_logicdev_mis_init(struct amlnf_logicdev_t *amlnf_logicdev);
+
+
+extern void pinmux_select_chip(u32 ce_enable,
+	u32 rb_enable,
+	u32 flag);
+
+extern int amlnf_phy_init(u8 flag, struct platform_device *pdev);
+
+extern int amlnf_logic_init(u32 flag);
+extern int amlnf_dev_init(u32 flag);
+
+extern int is_phydev_off_adjust(void);
+extern int get_adjust_block_num(void);
+
+extern void amldev_dumpinfo(struct amlnand_phydev *phydev);
+
+#endif
diff --git a/drivers/nand/include/amlnf_type.h b/drivers/nand/include/amlnf_type.h
new file mode 100644
index 0000000..3670dbd
--- /dev/null
+++ b/drivers/nand/include/amlnf_type.h
@@ -0,0 +1,98 @@
+#ifndef __AML_NF_TYPE_H__
+#define __AML_NF_TYPE_H__
+
+#include "amlnf_cfg.h"
+
+#ifdef AML_NAND_UBOOT
+#include <common.h>
+#include <environment.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <linux/err.h>
+#include <asm/cache.h>
+//#include <asm/arch/pinmux.h>
+//#include <asm/arch/reboot.h>
+//#include <asm/arch/clock.h>
+#include <linux/list.h>
+//#include <asm/sizes.h>
+//#include <amlogic/securitykey.h>
+
+#else	/* AML_NAND_UBOOT */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include<linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+/*
+#include <linux/earlysuspend.h>
+#include <mach/pinmux.h>
+*/
+#include <linux/err.h>
+/*#include <linux/io.h>*/
+#include <linux/bitops.h>
+#include <linux/crc32.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/reboot.h>
+#include <asm/div64.h>
+/*#include <mach/clock.h>*/
+#include <linux/list.h>
+#include <linux/sizes.h>
+/*#include <mach/am_regs.h>*/
+#include <linux/kthread.h>
+#include <linux/kmod.h>
+#include <linux/blkdev.h>
+#include <linux/blkpg.h>
+#include <linux/freezer.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mutex.h>
+#ifdef AML_NAND_RB_IRQ
+/*#include <mach/irqs.h>*/
+#include <linux/interrupt.h>
+#endif /*AML_NAND_RB_IRQ*/
+
+#ifdef AML_NAND_DMA_POLLING
+#ifdef CONFIG_HIGH_RES_TIMERS
+#include <linux/ktime.h>
+#include <linux/hrtimer.h>
+#endif /* CONFIG_HIGH_RES_TIMERS */
+#endif /* AML_NAND_DMA_POLLING */
+#endif /* AML_NAND_UBOOT */
+
+#if (AML_NAND_DBG)
+
+#define aml_nand_dbg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+				  __func__, __LINE__, ##__VA_ARGS__)
+
+#define aml_nand_msg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+				  __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define aml_nand_dbg(fmt, ...)
+#define aml_nand_msg(fmt, ...) printk( fmt "\n",  ##__VA_ARGS__)
+#endif
+
+
+typedef unsigned char			uchar;
+typedef unsigned short			uint16;
+typedef unsigned int			uint32;
+typedef unsigned long			uint64;
+typedef int						sint32;
+typedef long					sint64;
+typedef short					sint16;
+
+#endif //__AML_NF_TYPE_H__
diff --git a/drivers/nand/include/hw_ctrl.h b/drivers/nand/include/hw_ctrl.h
new file mode 100644
index 0000000..b4be238
--- /dev/null
+++ b/drivers/nand/include/hw_ctrl.h
@@ -0,0 +1,509 @@
+
+#ifndef __HW_CTRL_H__
+#define __HW_CTRL_H__
+
+#include "amlnf_dev.h"
+
+#ifndef AML_NAND_UBOOT
+#include <linux/types.h>
+#endif /* AML_NAND_UBOOT */
+
+#define	NF_REG_INDEX		0
+#define	EXTCLK_REG_INDEX	1
+#define	EXTPORT_REG_INDEX	2
+
+#define RETURN_PAGE_ALL_0XFF	0x01
+#define RETURN_PAGE_NEED_READRETRY	0x02
+
+#ifdef AML_NAND_UBOOT
+#define MESON_CPU_MAJOR_ID_M8 0x19
+#define MESON_CPU_MAJOR_ID_GX 0x21	//dbg code for gx pxp.
+#endif /* AML_NAND_UBOOT */
+
+
+#ifdef AML_NAND_UBOOT
+static inline int get_cpu_type(void)
+{
+	return MESON_CPU_MAJOR_ID_GX;
+}
+#endif /* AML_NAND_UBOOT */
+/*
+#define	NAND_CYCLE_DELAY_M8	84
+*/
+/*
+#define	NAND_CYCLE_DELAY	90
+*/
+#define	NAND_CYCLE_DELAY ((get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)?(84) : (90))
+
+/* Nand Flash Controller CLK register address */
+/*
+#define NAND_CLK_CNTL		0xc110425c
+*/
+/* Amlogic Nand Flash Controller register address */
+/* #define P_NAND_BASE_APB	0xd0048600 */
+/* #define P_NAND_BASE_CBUS	0xc1108600 */
+/* #define RESOURCE_SIZE	0x40 */
+
+#ifdef AML_NAND_UBOOT
+/* m8baby, debug on m201... just for porting*/
+#if  0
+#define NAND_BASE_APB 	(u32 *)0xd0048600
+#define IO_CBUS_PHY_BASE	(0xc1100000)
+#define NAND_CLK_CNTL		(u32 *)(IO_CBUS_PHY_BASE + 0x425C)
+#define	POC_CONFIG_REG		(u32 *)(IO_CBUS_PHY_BASE + 0x7D54)
+#endif /* 0 */
+
+/* gx, for pxp and ic. */
+//#define SD_EMMC_BASE_C	(volatile uint32_t *)(0xd0074000)
+#define SD_EMMC_BASE_C	(0xd0074000)
+#define P_NAND_BASE 	(SD_EMMC_BASE_C | (1<<11))
+#define NAND_BASE_APB	(P_NAND_BASE)
+#define NAND_CLK_CNTL	(SD_EMMC_BASE_C)	//fixme, need update the clock calculation.
+#define	POC_CONFIG_REG	(volatile uint32_t *)(0xc1107d54) //fixme, need check definition.
+#endif /* AML_NAND_UBOOT */
+
+
+/* NAND Write Command And Read Status Register */
+#define P_NAND_CMD			(0x00)
+/* NAND Configuration Register */
+#define P_NAND_CFG			(0x04)
+/* NAND Data Address Register */
+#define P_NAND_DADR			(0x08)
+/* NAND Information Address Register */
+#define P_NAND_IADR			(0x0c)
+/* NAND Read Data Buffer Register */
+#define P_NAND_BUF			(0x10)
+/* NAND Information Register */
+#define P_NAND_INFO			(0x14)
+/* NAND DDR interface Register */
+#define P_NAND_DC			(0x18)
+/* NAND DDR Address Register */
+#define P_NAND_ADR			(0x1c)
+/* NAND DDR Low 32 bits Data Register */
+#define P_NAND_DL			(0x20)
+/* NAND DDR High 32 bits Data Register */
+#define P_NAND_DH			(0x24)
+/* NAND Command Queus Address Register */
+#define P_NAND_CADR			(0x28)
+/* NAND Status Address Register */
+#define P_NAND_SADR			(0x2c)
+/* NAND CS2: SDRAM/NAND pin sharing Register */
+#define P_NAND_PINS			(0x30)
+/* NAND Version number Register */
+#define P_NAND_VER			(0x38)
+
+
+/*...other way to access cfg...*/
+typedef union _nand_cfg {
+    /** raw register data */
+    u32 d;
+    /** register bits */
+    struct {
+        u32 bus_cyc:5;	//0
+        u32 bus_tim:5;	//5
+        u32 sync:2;	//10
+        u32 cmd_start:1;	//12
+        u32 cmd_auto:1;	//13
+        u32 apb_mode:1;	//14
+        u32 spare_only:1;	//15
+        u32 sync_adj:1;	//16
+        u32 secure_des:1;	//17
+        u32 reserved18:2;	//18
+        u32 sts_irq_en:1;	//20
+        u32 cmd_irq_en:1;	//21
+        u32 reserved22:4;	//25
+        u32 oob_on:1;		//26
+        u32 oob_mode:1;	//27
+        u32 dc_ugt:1;		//28
+        u32 nand_wpn:1;	//29
+        u32 dma_power:1;	//30
+        u32 bus_power:1;	//31
+    } b;
+} nand_cfg_t;
+
+typedef struct _nand_reg {
+	volatile u32 cmd;
+	volatile u32 cfg;
+} nand_reg_t;
+
+extern nand_reg_t *p_nand_reg;
+
+static inline u32 amlnf_read_reg32(volatile uint32_t *_reg)
+{
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_rmb();
+#endif /* AML_NAND_UBOOT */
+	return __raw_readl(_reg);
+};
+
+static inline void amlnf_write_reg32(volatile uint32_t *_reg,
+	const u32 _value)
+{
+	__raw_writel(_value, _reg);
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_mb();
+#endif /* AML_NAND_UBOOT */
+};
+
+static inline void amlnf_set_reg32_bits(volatile uint32_t *_reg,
+	const u32 _value,
+	const u32 _start,
+	const u32 _len)
+{
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_rmb();
+#endif /* AML_NAND_UBOOT */
+	__raw_writel(((__raw_readl(_reg) & ~(((1L << (_len))-1) << (_start)))
+		| ((u32)((_value)&((1L<<(_len))-1)) << (_start))), _reg);
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_wmb();
+#endif /* AML_NAND_UBOOT */
+}
+
+static inline void amlnf_clrset_reg32_bits(volatile uint32_t *_reg,
+	const u32 clr,
+	const u32 set)
+{
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_rmb();
+#endif /* AML_NAND_UBOOT */
+	__raw_writel((__raw_readl(_reg) & ~(clr)) | (set), _reg);
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_wmb();
+#endif /* AML_NAND_UBOOT */
+}
+
+static inline u32 amlnf_get_reg32_bits(volatile uint32_t *_reg,
+	const u32 _start,
+	const u32 _len)
+{
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_rmb();
+#endif /* AML_NAND_UBOOT */
+	return (__raw_readl(_reg) >> (_start)) & ((1L << (_len)) - 1);
+}
+
+static inline void amlnf_set_reg32_mask(volatile uint32_t *_reg,
+	const u32 _mask)
+{
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_rmb();
+#endif /* AML_NAND_UBOOT */
+	__raw_writel((__raw_readl(_reg) | (_mask)), _reg);
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_wmb();
+#endif /* AML_NAND_UBOOT */
+}
+
+static inline void amlnf_clr_reg32_mask(volatile uint32_t *_reg,
+	const u32 _mask)
+{
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_rmb();
+#endif /* AML_NAND_UBOOT */
+	__raw_writel((__raw_readl(_reg) & (~(_mask))), _reg);
+	/*---*/
+#ifndef AML_NAND_UBOOT
+	smp_wmb();
+#endif /* AML_NAND_UBOOT */
+}
+
+/*
+#define nfc_readl(host, reg) \
+	__raw_readl((host)->reg_base + P_##reg)
+#define nfc_writel(host, reg, value) \
+	__raw_writel((value), (host)->reg_base + P_##reg)
+#define nfc_readw(host, reg) \
+	__raw_readw((host)->reg_base + P_##reg)
+#define nfc_writew(host, reg, value) \
+	__raw_writew((value), (host)->reg_base + P_##reg)
+ #define nfc_readb(host, reg) \
+	__raw_readb((host)->reg_base + P_##reg)
+#define nfc_writeb(host, reg, value) \
+	__raw_writeb((value), (host)->reg_base + P_##reg)
+
+#define nfc_set_bits(host, reg) \
+	{\
+		u32 value;\
+		value = __raw_readl((host)->reg_base + P_##reg);\
+		value &= ~((( 1L << (_len) )-1) << (_start)); \
+		value |= ((u32)((_value)&((1L<<(_len))-1)) << (_start));\
+		__raw_writel(value, (host)->reg_base + P_##reg);\
+	}
+*/
+
+//#define	AMLNF_WRITE_REG(reg, val) (amlnf_write_reg32((volatile uint32_t *)(reg), (val)))
+#define	AMLNF_WRITE_REG(reg, val) (amlnf_write_reg32(reg, (val)))
+//#define AMLNF_READ_REG(reg) (amlnf_read_reg32((volatile uint32_t *)(reg)))
+#define AMLNF_READ_REG(reg) (amlnf_read_reg32(reg))
+/*
+#define AMLNF_WRITE_REG_BITS(reg, val, start, len) \
+	(amlnf_set_reg32_bits((volatile uint32_t *)(reg), (val), start, len))
+*/
+#define AMLNF_WRITE_REG_BITS(reg, val, start, len) \
+	(amlnf_set_reg32_bits(reg, val, start, len))
+/*
+#define AMLNF_READ_REG_BITS(bus,reg, start, len) \
+	(amlnf_get_reg32_bits(reg,start,len))
+*/
+/*
+#define AMLNF_CLEAR_REG_MASK(reg, mask)	(amlnf_clr_reg32_mask((volatile uint32_t *)(reg), (mask)))
+#define AMLNF_SET_REG_MASK(reg, mask)	(amlnf_set_reg32_mask((volatile uint32_t *)(reg), (mask)))
+*/
+#define AMLNF_CLEAR_REG_MASK(reg, mask)	(amlnf_clr_reg32_mask(reg, mask))
+#define AMLNF_SET_REG_MASK(reg, mask)	(amlnf_set_reg32_mask(reg, mask))
+
+/*
+#define NFC_SET_TIMING(host, mode, cycles, adjust) \
+	AMLNF_WRITE_REG_BITS((host)->reg_base + P_NAND_CFG, \
+	((cycles)|((adjust&0xf)<<10)|((mode&7)<<5)), 0, 14)
+#define NFC_SET_CMD_START(host) \
+	AMLNF_SET_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<12)
+
+#define NFC_SET_CMD_AUTO(host) \
+	AMLNF_SET_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<13)
+
+#define NFC_SET_STS_IRQ(host, en) \
+	AMLNF_WRITE_REG_BITS((host)->reg_base + P_NAND_CFG, en, 20, 1)
+
+#define NFC_SET_CMD_IRQ(host, en) \
+	AMLNF_WRITE_REG_BITS((host)->reg_base + P_NAND_CFG, en, 21, 1)
+*/
+#define NFC_SET_TIMING_ASYC(host, bus_tim, bus_cyc) \
+	AMLNF_WRITE_REG_BITS((host)->reg_base + P_NAND_CFG, \
+	((bus_cyc&31)|((bus_tim&31)<<5)|(0<<10)), \
+	0, \
+	12)
+/*
+#define NFC_SET_TIMING_SYNC(host, bus_tim, bus_cyc, sync_mode) \
+	AMLNF_WRITE_REG_BITS((host)->reg_base + P_NAND_CFG, \
+	(bus_cyc&31)|((bus_tim&31)<<5)|((sync_mode&2)<<10), \
+	0, \
+	12)
+#define NFC_SET_TIMING_SYNC_ADJUST()
+#define NFC_SET_DMA_MODE(host, is_apb, spare_only) \
+	AMLNF_WRITE_REG_BITS((host)->reg_base + P_NAND_CFG, \
+	((spare_only<<1)|(is_apb)), \
+	14, \
+	2)
+*/
+#define NFC_SET_OOB_MODE(host, mode) \
+	AMLNF_SET_REG_MASK((host)->reg_base + P_NAND_CFG, mode);
+#define NFC_CLR_OOB_MODE(host, mode) \
+	AMLNF_CLEAR_REG_MASK((host)->reg_base + P_NAND_CFG, mode);
+/*
+#define NFC_ENABLE_STS_IRQ(host) \
+	AMLNF_SET_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<20)
+#define NFC_DISABLE_STS_IRQ(host) \
+	AMLNF_CLEAR_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<20)
+*/
+#define NFC_ENABLE_IO_IRQ(host)	\
+	AMLNF_SET_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<21)
+#define NFC_DISABLE_IO_IRQ(host) \
+	AMLNF_CLEAR_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<21)
+
+#define NFC_ENABLE_ENCRYPT(host)	\
+	AMLNF_SET_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<17)
+#define NFC_DISABLE_ENCRYPT(host) \
+	AMLNF_CLEAR_REG_MASK((host)->reg_base + P_NAND_CFG, 1<<17)
+
+
+/**
+    ADDR operations
+*/
+#define NFC_SET_DADDR(host, a) \
+	(AMLNF_WRITE_REG((host)->reg_base + P_NAND_DADR, (u32)a))
+#define NFC_SET_IADDR(host, a) \
+	(AMLNF_WRITE_REG((host)->reg_base + P_NAND_IADR, (u32)a))
+#define NFC_SET_SADDR(host, a) \
+	(AMLNF_WRITE_REG((host)->reg_base + P_NAND_SADR, (u32)a))
+
+#define NFC_INFO_GET(host) \
+	(AMLNF_READ_REG((host)->reg_base + P_NAND_CMD))
+
+#define NFC_GET_BUF(host) \
+	AMLNF_READ_REG((host)->reg_base + P_NAND_BUF)
+#define NFC_SET_CFG(host, val) \
+	(AMLNF_WRITE_REG((host)->reg_base + P_NAND_CFG, (u32)val))
+
+/*
+   Common Nand Read Flow
+*/
+#define CE0		(0xe<<10)
+#define CE1		(0xd<<10)
+#define CE2		(0xb<<10)
+#define CE3		(0x7<<10)
+#define CE_NOT_SEL	(0xf<<10)
+#define IO4		((0xe<<10)|(1<<18))
+#define IO5		((0xd<<10)|(1<<18))
+#define IO6		((0xb<<10)|(1<<18))
+#define CLE		(0x5<<14)
+#define ALE		(0x6<<14)
+#define DWR		(0x4<<14)
+#define DRD		(0x8<<14)
+#define IDLE		(0xc<<14)
+#define RB		(1<<20)
+#define STANDBY		(0xf<<10)
+
+#define M2N		((0<<17) | (2<<20) | (1<<19))
+#define N2M		((1<<17) | (2<<20) | (1<<19))
+
+#define M2N_NORAN	0x00200000
+#define N2M_NORAN	0x00220000
+
+#define STS		((3<<17) | (2<<20))
+#define ADL		((0<<16) | (3<<20))
+#define ADH		((1<<16) | (3<<20))
+#define AIL		((2<<16) | (3<<20))
+#define AIH		((3<<16) | (3<<20))
+#define ASL		((4<<16) | (3<<20))
+#define ASH		((5<<16) | (3<<20))
+#define SEED		((8<<16) | (3<<20))
+
+#define SEED_OFFSET	0xc2
+
+/**
+    Nand Flash Controller (M1)
+    Global Macros
+*/
+/**
+   Config Group
+*/
+
+/**
+    CMD relative Macros
+    Shortage word . NFCC
+*/
+#define NFC_CMD_IDLE(ce, time)	((ce)|IDLE|(time&0x3ff))
+#define NFC_CMD_CLE(ce, cmd)	((ce)|CLE | (cmd & 0x0ff))
+#define NFC_CMD_ALE(ce, addr)	((ce)|ALE | (addr&0x0ff))
+#define NFC_CMD_STANDBY(time)	(STANDBY | (time&0x3ff))
+#define NFC_CMD_ADL(addr)	(ADL | (addr&0xffff))
+#define NFC_CMD_ADH(addr)	(ADH|((addr>>16)&0xffff))
+#define NFC_CMD_AIL(addr)	(AIL | (addr&0xffff))
+#define NFC_CMD_AIH(addr)	(AIH|((addr>>16)&0xffff))
+#define NFC_CMD_DWR(ce, data)	(ce|DWR | (data&0xff))
+#define NFC_CMD_DRD(ce, size)	(ce|DRD|size)
+#define NFC_CMD_RB(ce, time)	((ce)|RB | (time&0x1f))
+#define NFC_CMD_RB_INT(ce, time) \
+	((ce)|RB|(((ce>>10)^0xf)<<14)|(time&0x1f))
+#define NFC_CMD_RBIO(time, io)		(RB|io|(time&0x1f))
+#define NFC_CMD_RBIO_IRQ(time)		(RB|IO6|(1<<16)|(time&0x1f))
+#define NFC_CMD_RBIO_INT(io, time)	(RB|(((io>>10)^0x7)<<14)|(time&0x1f))
+#define NFC_CMD_SEED(seed)	(SEED|(SEED_OFFSET + (seed&0x7fff)))
+#define NFC_CMD_STS(tim)	(STS|(tim&3))
+#define NFC_CMD_M2N(ran, ecc, sho, pgsz, pag) \
+	((ran?M2N:M2N_NORAN)|(ecc<<14)|(sho<<13)|((pgsz&0x7f)<<6)|(pag&0x3f))
+#define NFC_CMD_N2M(ran, ecc, sho, pgsz, pag)\
+	((ran?N2M:N2M_NORAN)|(ecc<<14)|(sho<<13)|((pgsz&0x7f)<<6)|(pag&0x3f))
+
+/**
+Alias for CMD
+#define NFC_CMD_D_ADR(addr)	NFC_CMD_ADL(addr), NFC_CMD_ADH(addr)
+#define NFC_CMD_I_ADR(addr)	NFC_CMD_ADI(addr), NFC_CMD_ADI(addr)
+*/
+
+#define NAND_ECC_NONE		(0x0)
+#define NAND_ECC_BCH8		(0x1)
+#define NAND_ECC_BCH8_1K	(0x2)
+#define NAND_ECC_BCH16_1K	(0x3)
+#define NAND_ECC_BCH24_1K	(0x4)
+#define NAND_ECC_BCH24_1K_M8	(0x3)
+#define NAND_ECC_BCH30_1K	(0x5)
+#define NAND_ECC_BCH30_1K_M8	(0x4)
+#define NAND_ECC_BCH40_1K	(0x6)
+#define NAND_ECC_BCH40_1K_M8	(0x5)
+#define NAND_ECC_BCH50_1K_M8	(0x6)
+#define NAND_ECC_BCH60_1K	(0x7)
+#define NAND_ECC_BCH_SHORT	(0x8)
+
+/**
+Register Operation and Controller Status
+*/
+#define NFC_SEND_CMD(host, cmd) \
+	(AMLNF_WRITE_REG((host)->reg_base + P_NAND_CMD, cmd))
+#define NFC_READ_INFO(host) \
+	(AMLNF_READ_REG((host)->reg_base + P_NAND_CMD))
+
+/**
+    Send command directly
+*/
+#define NFC_SEND_CMD_IDLE(host, time) \
+	{\
+		while (NFC_CMDFIFO_SIZE(host) > 0)\
+			; \
+		NFC_SEND_CMD(host, NFC_CMD_IDLE((host)->chip_selected, time)); \
+	}
+#define NFC_SEND_CMD_CLE(host, ce, cmd) \
+	NFC_SEND_CMD(host, NFC_CMD_CLE(ce, cmd))
+#define NFC_SEND_CMD_ALE(host, ce, addr) \
+	NFC_SEND_CMD(host, NFC_CMD_ALE(ce, addr))
+#define NFC_SEND_CMD_STANDBY(host, time) \
+	NFC_SEND_CMD(host, NFC_CMD_STANDBY(time))
+#define NFC_SEND_CMD_ADL(host, addr) \
+	NFC_SEND_CMD(host, NFC_CMD_ADL(addr))
+#define NFC_SEND_CMD_ADH(host, addr) \
+	NFC_SEND_CMD(host, NFC_CMD_ADH(addr))
+#define NFC_SEND_CMD_AIL(host, addr) \
+	NFC_SEND_CMD(host, NFC_CMD_AIL(addr))
+#define NFC_SEND_CMD_AIH(host, addr) \
+	NFC_SEND_CMD(host, NFC_CMD_AIH(addr))
+#define NFC_SEND_CMD_DWR(host, ce, data) \
+	NFC_SEND_CMD(host, NFC_CMD_DWR(ce, data))
+#define NFC_SEND_CMD_DRD(host, ce, size) \
+	NFC_SEND_CMD(host, NFC_CMD_DRD(ce, size))
+#define NFC_SEND_CMD_RB(host, ce, time)	\
+	NFC_SEND_CMD(host, NFC_CMD_RB(ce, time))
+#define NFC_SEND_CMD_SEED(host, seed) \
+	NFC_SEND_CMD(host, NFC_CMD_SEED(seed))
+#define NFC_SEND_CMD_M2N(host, ran, ecc, sho, pgsz, pag) \
+	NFC_SEND_CMD(host, NFC_CMD_M2N(ran, ecc, sho, pgsz, pag))
+#define NFC_SEND_CMD_N2M(host, ran, ecc, sho, pgsz, pag) \
+	NFC_SEND_CMD(host, NFC_CMD_N2M(ran, ecc, sho, pgsz, pag))
+
+#define NFC_SEND_CMD_M2N_RAW(host, ran, len) \
+	NFC_SEND_CMD(host, (ran?M2N:M2N_NORAN)|(len&0x3fff))
+#define NFC_SEND_CMD_N2M_RAW(host, ran, len) \
+	NFC_SEND_CMD(host, (ran?N2M:N2M_NORAN)|(len&0x3fff))
+
+#define NFC_SEND_CMD_STS(host, time, irq) \
+	NFC_SEND_CMD(host, NFC_CMD_STS(time | irq))
+
+#define NFC_SEND_CMD_RB_IRQ(host, time) \
+	NFC_SEND_CMD(host, NFC_CMD_RBIO_IRQ(time))
+
+/**
+    Cmd Info Macros
+*/
+#define NFC_CMDFIFO_SIZE(host)		((NFC_INFO_GET(host)>>22)&0x1f)
+#define NFC_CHECEK_RB_TIMEOUT(host)	((NFC_INFO_GET(host)>>27)&0x1)
+#define NFC_FIFO_CUR_CMD(host)		((NFC_INFO_GET(host)>>22)&0x3FFFFF)
+#define NFC_GET_RB_STATUS(host, ce) \
+	(((NFC_INFO_GET(host)>>28)&(~(ce>>10)))&0xf)
+
+
+#define NAND_INFO_DONE(a)	(((a)>>31)&1)
+#define NAND_ECC_ENABLE(a)	(((a)>>30)&1)
+#define NAND_ECC_CNT(a)		(((a)>>24)&0x3f)
+#define NAND_ZERO_CNT(a)	(((a)>>16)&0x3f)
+#define NAND_INFO_DATA_2INFO(a)	((a)&0xffff)
+#define NAND_INFO_DATA_1INFO(a)	((a)&0xff)
+
+#define POR_CONFIG	READ_CBUS_REG(ASSIST_POR_CONFIG)
+
+#define POC_NAND_CFG	(1<<2)
+#define POC_NAND_NO_RB	(1<<0)
+#define POC_NAND_ASYNC	(1<<7)
+
+#endif /* __HW_CTRL_H__ */
+
diff --git a/drivers/nand/include/phynand.h b/drivers/nand/include/phynand.h
new file mode 100644
index 0000000..f953d5d
--- /dev/null
+++ b/drivers/nand/include/phynand.h
@@ -0,0 +1,914 @@
+#ifndef PHYNAND_H_INCLUDED
+#define PHYNAND_H_INCLUDED
+
+#include "../include/amlnf_dev.h"
+
+#ifndef AML_NAND_UBOOT
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/io.h>
+#endif /*AML_NAND_UBOOT*/
+/* #define CONFIG_OF */
+
+#define NAND_COMPATIBLE_REGION	1
+#define NAND_RESERVED_REGION	1
+#define NAND_ADDNEW_REGION	1
+#define NAND_BUG_FIX_REGION	6
+
+#define DRV_PHY_VERSION	 ((NAND_COMPATIBLE_REGION << 24) + \
+			(NAND_RESERVED_REGION << 16) + \
+			(NAND_ADDNEW_REGION << 8) + \
+			(NAND_BUG_FIX_REGION))
+
+#define NAND_MFR_USER          0x100
+#define NAND_MFR_EFUSE         0x101
+
+/* #define abs(value) (((value) < 0) ? ((value)*-1) : (value)) */
+
+/* -------must same with nand.h------ */
+/*
+ ** Max page list cnt for usrdef mode
+*/
+#define NAND_PAGELIST_CNT		16
+typedef struct nand_setup {
+    union {
+        uint32_t d32;
+        struct {
+            unsigned cmd:22;
+            unsigned large_page:1; // 22
+            unsigned no_rb:1;      // 23 from efuse
+            unsigned a2:1;         // 24
+            unsigned reserved25:1; // 25
+            unsigned page_list:1;  // 26
+            unsigned sync_mode:2;  // 27 from efuse
+            unsigned size:2;       // 29 from efuse
+            unsigned active:1;     // 31
+        } b;
+    } cfg;
+    uint16_t id;
+    uint16_t max; // id:0x100 user, max:0 disable.
+} nand_setup_t;
+
+typedef struct _nand_cmd{
+    unsigned char type;
+    unsigned char val;
+} nand_cmd_t;
+
+typedef struct _ext_info{
+	uint32_t read_info;		//nand_read_info;
+	uint32_t new_type;		//new_nand_type;
+	uint32_t page_per_blk;	//pages_in_block;
+	uint32_t xlc;			//slc=1, mlc=2, tlc=3.
+	uint32_t ce_mask;
+	uint32_t rsv[4];
+	/* add new below, */
+} ext_info_t;
+
+typedef struct _nand_page0 {
+	nand_setup_t nand_setup;		//8
+	unsigned char page_list[NAND_PAGELIST_CNT]; 	//16
+	nand_cmd_t retry_usr[32];		//64 (32 cmd max I/F)
+	ext_info_t ext_info;			//64
+} nand_page0_t;	//384 bytes max.
+/* --------------------------------------------------- */
+union nand_core_clk_t {
+	/* raw register data */
+	u32 d32;
+	/*register bits */
+	struct {
+		u32 clk_div:7;
+		u32 reserved0:1;
+		u32 clk_en:1;
+		u32 clk_sel:3;
+		u32 not_used:20;
+	} b;
+};
+
+
+/***************ERROR CODING*******************/
+#define NAND_CHIP_ID_ERR            1
+#define NAND_SHIP_BAD_BLOCK_ERR     2
+#define NAND_CHIP_REVB_HY_ERR       3
+
+/*
+ * NAND Flash Manufacturer ID Codes
+ */
+#define NAND_MFR_TOSHIBA	0x98
+#define NAND_MFR_SAMSUNG	0xec
+#define NAND_MFR_FUJITSU	0x04
+#define NAND_MFR_NATIONAL	0x8f
+#define NAND_MFR_RENESAS	0x07
+#define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX		0xad
+#define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
+#define NAND_MFR_INTEL		0x89
+#define NAND_MFR_SANDISK	0x45
+
+
+/***nand runing status***/
+#define NAND_STATUS_NORMAL	0
+#define NAND_STATUS_UNUSUAL	1
+
+
+#define NAND_STATUS_MAX_TRY	6
+#define	NAND_STATUS_FAILED	0xe1
+#define	NAND_STATUS_RIGHT	0xe0
+
+#define	BYTES_OF_USER_PER_PAGE	16
+
+#define ADJUST_PART_SIZE	10
+#define ADJUST_SIZE_NFTL	8
+
+#define	SHIPPED_BBT_HEAD_MAGIC	"fbbt"
+#define	BBT_HEAD_MAGIC			"nbbt"
+#define	CONFIG_HEAD_MAGIC		"ncnf"
+#define	HYNIX_DEV_HEAD_MAGIC	"nhix"
+#define	KEY_INFO_HEAD_MAGIC		"nkey"
+#define	SECURE_INFO_HEAD_MAGIC	"nsec"
+#define	ENV_INFO_HEAD_MAGIC		"nenv"
+#define	DTD_INFO_HEAD_MAGIC		"ndtb"
+
+#define	FBBT_COPY_NUM	1
+
+/* 512K */
+#define CONFIG_KEYSIZE		(256*1024)
+#define KEYSIZE	(CONFIG_KEYSIZE - (sizeof(u32)))
+/* 128k */
+#define CONFIG_SECURE_SIZE	(0x10000*2)
+/*fixme, arguing...*/
+#define SECURE_SIZE (CONFIG_SECURE_SIZE - (sizeof(u32)))
+
+/* 256KBytes. */
+#define CONFIG_DTB_SIZE  (256*1024U)
+#define DTB_SIZE (CONFIG_DTB_SIZE - (sizeof(u32)))
+
+#define FULL_BLK	0
+#define FULL_PAGE	1
+
+#define	MAX_BAD_BLK_NUM			    2048
+#define	MAX_SHIPPED_BAD_BLK_NUM		512
+#define	MAX_BLK_NUM			        8192
+#define	RESERVED_BLOCK_CNT		    48
+
+/* nand parameter for read retry, or fulture */
+#define	NANS_PARA_BLOCK_CNT		1
+
+/* for shipped bbt block, short mode, full block, never update */
+/* common bbt table, rarely update */
+#define	BBT_BLOCK_CNT			2
+/* shipped bbt table, just only one copy first detect */
+#define	SHIPPED_BBT_BLOCK_CNT		1
+/* config block, short mode, full block, if update, erase whole block */
+#define	CONFIG_BLOCK_CNT	1
+#define	KEY_BLOCK_CNT		4
+
+/***uboot code***/
+#define	BOOT_COPY_NUM		4
+#define	BOOT_PAGES_PER_COPY	256
+
+#define	MAX_CYCLE_NUM		20
+
+/***nand chip options***/
+#define	NAND_CTRL_FORCE_WP		(1<<0)
+
+/***nand controller options***/
+#define	NAND_CTRL_NONE_RB		(1<<1)
+#define	NAND_CTRL_INTERLEAVING_MODE	(1<<2)
+#define	NAND_MULTI_PLANE_MODE		(1<<3)
+
+
+/***nand controller ECC options***/
+#define	MAX_ECC_MODE_NUM		16
+#define	NAND_ECC_TYPE_MASK		(0xf<<4)
+
+#define	NAND_ECC_SOFT_MODE		(0x0<<4)
+#define	NAND_ECC_SHORT_MODE		(0x1<<4)
+#define	NAND_ECC_BCH9_MODE		(0x2<<4)
+#define	NAND_ECC_BCH8_MODE		(0x3<<4)
+#define	NAND_ECC_BCH12_MODE		(0x4<<4)
+#define	NAND_ECC_BCH16_MODE		(0x5<<4)
+#define	NAND_ECC_BCH8_1K_MODE		(0x6<<4)
+#define	NAND_ECC_BCH16_1K_MODE		(0x7<<4)
+#define	NAND_ECC_BCH24_1K_MODE		(0x8<<4)
+#define	NAND_ECC_BCH30_1K_MODE		(0x9<<4)
+#define	NAND_ECC_BCH40_1K_MODE		(0xa<<4)
+#define	NAND_ECC_BCH50_1K_MODE		(0xb<<4)
+#define	NAND_ECC_BCH60_1K_MODE		(0xc<<4)
+
+
+	/***FOR NAND CHIP TYPES ***/
+#define	NAND_CHIP_TYPE_MASK		(0x3<<9)
+
+#define	NAND_CHIP_TYPE_MLC		(0x0<<9)
+#define	NAND_CHIP_TYPE_SLC		(0x1<<9)
+#define	NAND_CHIP_TYPE_TLC		(0x2<<9)
+
+#define	NAND_CHIP_AYSNC_MODE		(0x0<<12)
+#define	NAND_CHIP_TOGGLE_MODE		(0x1<<12)
+#define	NAND_CHIP_SLC_MODE		(0x1<<13)
+
+
+	/***FOR TIMMING MODE ***/
+
+#define	NAND_TIMING_MODE0		(0x0)
+#define	NAND_TIMING_MODE1		(0x1)
+#define	NAND_TIMING_MODE2		(0x2)
+#define	NAND_TIMING_MODE3		(0x3)
+#define	NAND_TIMING_MODE4		(0x4)
+#define	NAND_TIMING_MODE5		(0x5)
+
+
+#define	NAND_DEFAULT_OPTIONS	(NAND_CTRL_NONE_RB | NAND_ECC_SHORT_MODE)
+
+#define	DEFAULT_T_REA		20
+#define	DEFAULT_T_RHOH		25
+
+/***FOR ECC ***/
+#define	NAND_ECC_UNIT_SIZE		512
+#define	NAND_ECC_UNIT_1KSIZE		1024
+#define	NAND_ECC_UNIT_SHORT		384
+
+#define	NAND_BCH9_ECC_SIZE		15
+#define	NAND_BCH8_ECC_SIZE		14
+#define	NAND_BCH12_ECC_SIZE		20
+#define	NAND_BCH16_ECC_SIZE		26
+#define	NAND_BCH8_1K_ECC_SIZE		14
+#define	NAND_BCH16_1K_ECC_SIZE		28
+#define	NAND_BCH24_1K_ECC_SIZE		42
+#define	NAND_BCH30_1K_ECC_SIZE		54
+#define	NAND_BCH40_1K_ECC_SIZE		70
+#define	NAND_BCH50_1K_ECC_SIZE		88
+#define	NAND_BCH60_1K_ECC_SIZE		106
+
+/* 1uS , about 8mS */
+#define	AML_NAND_READ_BUSY_TIMEOUT	0x2000
+/* 1uS, about 20mS */
+#define	AML_NAND_WRITE_BUSY_TIMEOUT	0x5000
+/* 1uS, about 40mS */
+#define	AML_NAND_ERASE_BUSY_TIMEOUT	0xa000
+
+
+#define	AML_DMA_BUSY_TIMEOUT	0x100000
+
+#define	MAX_ID_LEN		8
+
+#define	NAND_TYPE_MLC		0
+#define	NAND_TYPE_SLC		1
+#define	NAND_TYPE_TLC		2
+
+#define	NAND_TWB_TIME_CYCLE	10
+#define	NAND_TWHR_TIME_CYCLE	20
+#define	NAND_TADL_TIME_CYCLE	20
+#define	NAND_TCCS_TIME_CYCLE	20
+#define	NAND_TRHW_TIME_CYCLE	20
+
+
+#ifdef AML_NAND_RB_IRQ
+#define NAND_CHIP_UNDEFINE	200
+#endif
+
+#ifdef AML_NAND_RB_IRQ
+#define DMA_TIME_CNT_220US	220000
+#define DMA_TIME_CNT_20US	20000
+#endif
+
+/*
+#define	NAND_TWHR2_TIME_CYCLE	20
+*/
+
+/*
+ * Constants for hardware specific CLE/ALE/NCE function
+ *
+ * These are bits which can be or'ed to set/clear multiple
+ * bits in one go.
+ */
+/* Select the chip by setting nCE to low */
+#define	NAND_NCE	0x01
+/* Select the command latch by setting CLE to high */
+#define	NAND_CLE	0x02
+/* Select the address latch by setting ALE to high */
+#define	NAND_ALE	0x04
+
+
+#define	NAND_CTRL_CLE	(NAND_NCE | NAND_CLE)
+#define	NAND_CTRL_ALE	(NAND_NCE | NAND_ALE)
+
+/*
+ * Standard NAND flash commands
+ */
+#define	NAND_CMD_READ0		0x00
+#define	NAND_CMD_READ1		0x01
+#define	NAND_CMD_RNDOUT		0x05
+#define	NAND_CMD_PAGEPROG	0x10
+#define	NAND_CMD_READOOB	0x50
+#define	NAND_CMD_ERASE1		0x60
+#define	NAND_CMD_STATUS		0x70
+#define	NAND_CMD_STATUS_MULTI	0x71
+#define	NAND_CMD_SEQIN		0x80
+#define	NAND_CMD_RNDIN		0x85
+#define	NAND_CMD_READID		0x90
+#define	NAND_CMD_ERASE2		0xd0
+#define	NAND_CMD_PARAM		0xec
+#define	NAND_CMD_RESET		0xff
+
+#define	NAND_CMD_ID_ADDR_NORMAL	0x00
+#define	NAND_CMD_ID_ADDR_ONFI	0x20
+
+
+#define	NAND_CMD_NONE	-1
+
+
+#define	NAND_CMD_LOCK		0x2a
+#define	NAND_CMD_UNLOCK1	0x23
+#define	NAND_CMD_UNLOCK2	0x24
+
+/*
+  *Extended common NAND CMD
+  *
+*/
+#define	NAND_CMD_PLANE2_READ_START	0x06
+#define	NAND_CMD_TWOPLANE_PREVIOS_READ	0x60
+#define	NAND_CMD_TWOPLANE_READ1		0x5a
+#define	NAND_CMD_TWOPLANE_READ2		0xa5
+#define	NAND_CMD_TWOPLANE_WRITE2_MICRO	0x80
+#define	NAND_CMD_TWOPLANE_WRITE2	0x81
+#define	NAND_CMD_DUMMY_PROGRAM		0x11
+#define	NAND_CMD_ERASE1_END		0xd1
+#define	NAND_CMD_MULTI_CHIP_STATUS	0x78
+#define	NAND_CMD_SET_FEATURES		0xEF
+#define	NAND_CMD_GET_FEATURES		0xEE
+#define	NAND_CMD_READSTART		0x30
+#define	NAND_CMD_RNDOUTSTART		0xE0
+#define	NAND_CMD_CACHEDPROG		0x15
+
+#define	ONFI_TIMING_ADDR		0x01
+#define	NAND_STATUS_READY_MULTI		0x20
+
+/* Status bits */
+#define	NAND_STATUS_FAIL	0x01
+#define	NAND_STATUS_FAIL_N1	0x02
+#define	NAND_STATUS_TRUE_READY	0x20
+#define	NAND_STATUS_READY	0x40
+#define	NAND_STATUS_WP		0x80
+
+#if (AML_CFG_NEW_NAND_SUPPORT)
+#define	RETRY_NAND_MAGIC	"refv"
+#define	RETRY_NAND_BLK_NUM	2
+#define	RETRY_NAND_COPY_NUM	4
+
+#define	READ_RETRY_REG_NUM	8
+#define	READ_RETRY_CNT      40
+
+#define	EN_SLC_REG_NUM		8
+
+#define	READ_RETRY_ZERO		((char)-1)
+
+#define	NAND_CMD_HYNIX_GET_VALUE		0x37
+#define	NAND_CMD_HYNIX_SET_VALUE_START		0x36
+#define	NAND_CMD_HYNIX_SET_VALUE_END		0x16
+
+#define	NAND_CMD_TOSHIBA_PRE_CON1		0x5c
+#define	NAND_CMD_TOSHIBA_PRE_CON2		0xc5
+#define	NAND_CMD_TOSHIBA_SET_VALUE		0x55
+#define	NAND_CMD_TOSHIBA_BEF_COMMAND1		0x26
+#define	NAND_CMD_TOSHIBA_BEF_COMMAND2		0x5d
+#define NAND_CMD_SAMSUNG_SET_VALUE		0XA1
+#define NAND_CMD_MICRON_SET_VALUE		0XEF
+#define	NAND_CMD_SANDISK_INIT_ONE		0x3B
+#define	NAND_CMD_SANDISK_INIT_TWO		0xB9
+
+#define	NAND_CMD_SANDISK_LOAD_VALUE_ONE		0x53
+#define	NAND_CMD_SANDISK_LOAD_VALUE_TWO		0x54
+
+#define	NAND_CMD_SANDISK_DYNAMIC_ENABLE		0xB6
+#define	NAND_CMD_SANDISK_DYNAMIC_DISABLE	0xD6
+#define	NAND_CMD_SANDISK_SLC			0xA2
+#define NAND_CMD_SANDISK_SET_VALUE		0XEF
+#define	NAND_CMD_SANDISK_DSP_OFF	0x25
+#define	NAND_CMD_SANDISK_DSP_ON		0x26
+#define	NAND_CMD_SANDISK_RETRY_STA	0x5D
+#define	NAND_CMD_SANDISK_TEST_MODE1	0x5c
+#define	NAND_CMD_SANDISK_TEST_MODE2	0xc5
+#define	NAND_CMD_SANDISK_TEST_MODE_ACCESS 0x55
+/* for hynix 20nm OTP */
+#define	HYNIX_OTP_COPY		8
+#define	HYNIX_OTP_LEN		528
+
+/* for Hynix */
+#define	HYNIX_26NM_4GB		1
+#define	HYNIX_26NM_8GB		2
+#define	HYNIX_20NM_4GB		3
+#define	HYNIX_20NM_8GB		4
+#define	HYNIX_1YNM			6
+/* for Toshiba */
+#define	TOSHIBA_2XNM		20
+/* TC58NVG6D2GTA00 */
+#define	TOSHIBA_A19NM		21
+#define	TOSHIBA_15NM		22
+
+/* for SAMSUNG */
+#define	SUMSUNG_2XNM		30
+
+/* for SANDISK */
+#define	SANDISK_19NM		40
+#define	SANDISK_24NM		41
+#define	SANDISK_A19NM		42
+#define	SANDISK_A19NM_4G	53
+
+/* for Intel */
+#define	INTEL_20NM	60
+/* for Micron */
+#define	MICRON_20NM	50
+
+struct hw_controller;
+struct read_retry_info {
+	u8 flag;
+	u8 default_flag;
+	u8 info_save_blk;
+
+	u8 reg_cnt_lp;
+	u8 reg_cnt_up;
+	u8 reg_cnt_tp;
+
+	u8 retry_cnt_lp;
+	u8 retry_cnt_up;
+	u8 retry_cnt_tp;
+    u8 retry_stage;
+
+	u8 cur_cnt_lp[MAX_CHIP_NUM];
+	u8 cur_cnt_up[MAX_CHIP_NUM];
+	u8 cur_cnt_tp[MAX_CHIP_NUM];
+
+	u8 reg_addr_lp[READ_RETRY_REG_NUM];
+	u8 reg_addr_up[READ_RETRY_REG_NUM];
+	u8 reg_addr_tp[READ_RETRY_REG_NUM];
+
+	u8 reg_def_val[MAX_CHIP_NUM][READ_RETRY_REG_NUM];
+
+	u8 reg_offs_val_lp[MAX_CHIP_NUM][READ_RETRY_CNT][READ_RETRY_REG_NUM];
+	u8 reg_offs_val_up[MAX_CHIP_NUM][READ_RETRY_CNT][READ_RETRY_REG_NUM];
+	u8 reg_offs_val_tp[MAX_CHIP_NUM][READ_RETRY_CNT][READ_RETRY_REG_NUM];
+
+	int (*init)(struct hw_controller *controller);
+	int (*handle)(struct hw_controller *controller, u8 chipnr);
+	int (*exit)(struct hw_controller *controller, u8 chipnr);
+};
+
+struct en_slc_info {
+	u8 flag;
+	u8 *pagelist;
+	u8 reg_cnt;
+	u8 reg_addr[EN_SLC_REG_NUM];
+	u8 reg_def_val[MAX_CHIP_NUM][EN_SLC_REG_NUM];
+	char reg_offs_val[EN_SLC_REG_NUM];
+	int (*init)(struct hw_controller *controller);
+	int (*enter)(struct hw_controller *controller);
+	int (*exit)(struct hw_controller *controller);
+};
+
+#endif
+
+#define ECC_INFORMATION(name_a, bch_a, size_a, parity_a, user_a, index_a) \
+	{\
+		.name = name_a,\
+		.mode = bch_a,\
+		.unit_size = size_a,\
+		.bytes = parity_a,\
+		.usr_mode = user_a,\
+		.bch_index = index_a\
+	}
+
+struct bch_desc {
+	char *name;
+	u32 mode;
+	u32 unit_size;
+	u32 bytes;
+	u32 usr_mode;
+	u32 bch_index;
+};
+
+
+/*** HW controller configuration ***/
+struct hw_controller {
+	u32 chip_selected;
+	u32 rb_received;
+	u32 ce_enable[MAX_CHIP_NUM];
+	u32 rb_enable[MAX_CHIP_NUM];
+
+	u8 chip_num;
+	u8 flash_type;
+	u8 mfr_type;
+	u32 onfi_mode;
+
+	 /* zero means no short */
+	u16 short_pgsz;
+
+	u8 max_bch;
+
+	u16 ecc_unit;
+	u16 ecc_bytes;
+	u16 ecc_steps;
+
+	u16 oobtail;
+
+	u8 bch_mode;
+	u8 user_mode;
+	u8 ran_mode;
+	u8 oobavail;
+	u8 oob_mod;
+	int oob_fill_data;
+	int oob_fill_boot;
+	u8 ecc_cnt_limit;
+	u8 ecc_cnt_cur;
+	u8 ecc_max;
+
+	u16 page_shift;
+	u16 block_shift;
+
+	u32 internal_page_nums;
+	u32 zero_cnt;
+
+	u32 page_addr;
+
+	u32 option;
+
+	u8 *data_buf;
+	u32 *user_buf;
+
+	u8 *page_buf;
+	u8 *oob_buf;
+
+#if (AML_CFG_NEW_NAND_SUPPORT)
+	struct en_slc_info slc_info;
+	struct read_retry_info retry_info;
+#endif
+
+	dma_addr_t data_dma_addr;
+	dma_addr_t info_dma_addr;
+
+	void __iomem *reg_base;
+	void __iomem *nand_clk_reg;
+	u32 irq;
+
+	struct bch_desc *bch_desc;
+
+#ifdef AML_NAND_DMA_POLLING
+	struct hrtimer timer;
+#endif
+
+#if 0/* #ifndef AML_NAND_UBOOT */
+	struct hw_ctrl hw_ctrl;
+#endif
+	struct amlnand_chip *aml_chip;
+
+	/*** hw controller operation function ***/
+	int (*init)(struct hw_controller *controller);
+	int (*adjust_timing)(struct hw_controller *controller);
+	int (*select_chip)(struct hw_controller *controller,
+		u8 chipnr);
+	int (*ecc_confirm)(struct hw_controller *controller);
+	u8 (*readbyte)(struct hw_controller *controller);
+	void (*writebyte)(struct hw_controller *controller,
+		u8 data);
+	void (*cmd_ctrl)(struct hw_controller *controller,
+		u32 cmd,
+		u32 ctrl);
+	int (*quene_rb)(struct hw_controller *controller, u8 chipnr);
+#ifdef AML_NAND_RB_IRQ
+	int (*quene_rb_irq)(struct hw_controller *controller,
+		u8 chipnr);
+#endif
+	int (*dma_read)(struct hw_controller *controller,
+		u32 len,
+		u8 bch_mode);
+	int (*dma_write)(struct hw_controller *controller,
+		u8 *buf,
+		u32 len,
+		u8 bch_mode);
+	int (*hwecc_correct)(struct hw_controller *controller,
+		u32 size,
+		u8 *oob_buf);
+
+	void (*get_usr_byte)(struct hw_controller *controller,
+		u8 *oob_buf,
+		u8 byte_num);
+	void (*set_usr_byte)(struct hw_controller *controller,
+		u8 *oob_buf,
+		u8 byte_num);
+	void (*enter_standby)(struct hw_controller *controller);
+
+};
+
+/*** nand chip operation function ***/
+struct chip_operation {
+	int (*check_wp)(struct amlnand_chip *aml_chip);
+
+	int (*get_onfi_para)(struct amlnand_chip *aml_chip,
+		u8 *buf,
+		int addr);
+	int (*set_onfi_para)(struct amlnand_chip *aml_chip,
+		u8 *buf,
+		int addr);
+
+	int (*reset)(struct amlnand_chip *aml_chip, u8 chip_nr);
+	int (*read_id)(struct amlnand_chip *aml_chip,
+		u8 chip_nr,
+		u8 id_addr,
+		u8 *buf);
+
+	/*
+	 * Erase is an asynchronous operation.  Device drivers are supposed
+	 * to call instr->callback() whenever the operation completes, even
+	 * if it completes with a failure.
+	 * Callers are supposed to pass a callback function and wait for it
+	 * to be called before writing to the block.
+	*/
+	int (*erase_block)(struct amlnand_chip *aml_chip);
+	int (*test_block_chip_op)(struct amlnand_chip *aml_chip);
+	int (*test_block_reserved)(struct amlnand_chip *aml_chip, int tst_blk);
+	/***basic data operation and included oob data****/
+	int (*read_page)(struct amlnand_chip *aml_chip);
+	int (*write_page)(struct amlnand_chip *aml_chip);
+
+	int (*block_isbad)(struct amlnand_chip *aml_chip);
+	int (*block_markbad)(struct amlnand_chip *aml_chip);
+
+	int (*blk_modify_bbt_chip_op)(struct amlnand_chip *aml_chip, int value);
+	int (*update_bbt_chip_op)(struct amlnand_chip *aml_chip);
+};
+
+/*** basic nand flash information  ***/
+struct nand_flash {
+	char *name;
+	u8 id[MAX_ID_LEN];
+
+	u32 pagesize;
+	u32 chipsize;
+	u32 blocksize;
+	u32 oobsize;
+
+	u8 internal_chipnr;
+	u8 T_REA;
+	u8 T_RHOH;
+	u8 onfi_mode;
+	u8 new_type;
+
+	u32 option;
+};
+
+/*
+*operation type as below: oob_mode data_buf oob_buf readlen
+*1) read data hw ecc mode 0 available NULL 0
+*2) read oob hw ecc mode 0 NULL available available
+*3) read data and oob hw ecc mode 0 available available available
+*4) read data/oob none ecc mode 1 available NULL available
+*
+* option chipnr page_addr
+*mulit-chip 0
+*serial-chip available
+*multi-plane
+*sigle-plane
+*/
+struct chip_ops_para {
+	u32 page_addr;
+	u8 chipnr;
+	u8 *data_buf;
+	u8 *oob_buf;
+	enum oob_modes_t oob_mode;
+	u8 bit_flip;
+	u8 ecc_err;
+	/*
+	only for read oob mode, for chip operation,
+	read data should be one entire page, but oob mode not.
+	*/
+	u8 ooblen;
+	u32 option;
+};
+
+
+/**
+ * struct platform_nand_chip - chip level device structure
+ * @nr_chips:		max. number of chips to scan for
+ * @chip_offset:	chip number offset
+ * @nr_partitions:	number of partitions pointed to by partitions (or zero)
+ * @partitions:		mtd partition list
+ * @options:		Option flags, e.g. 16bit buswidth
+ * @priv:		hardware controller specific settings
+ */
+struct dev_para {
+	const char name[MAX_DEVICE_NAME_LEN];
+
+	u64 offset;
+	u64 size;
+	struct amlnf_partition partitions[MAX_NAND_PART_NUM];
+	u8 nr_partitions;
+
+	u32 option;
+};
+#if (AML_CFG_INSIDE_PARTTBL)
+#define MAX_PART_NUM	16
+#define PART_NAME_LEN 16
+struct partitions {
+	/* identifier string */
+	char name[PART_NAME_LEN];
+	/* partition size, byte unit */
+	u64 size;
+	/* offset within the master space, byte unit */
+	u64 offset;
+	/* master flags to mask out for this partition */
+	u32 mask_flags;
+	/* for memcpy  align */
+	//void *priv;
+};
+#endif /* AML_CFG_INSIDE_PARTTBL */
+
+struct nand_config {
+	u32 crc;
+	struct dev_para dev_para[MAX_DEVICE_NUM];
+	u32 driver_version;
+	u8 dev_num;
+	u16 fbbt_blk_addr;
+};
+
+struct nand_bbt {
+	u16 nand_bbt[MAX_CHIP_NUM][MAX_BAD_BLK_NUM];
+};
+
+struct shipped_bbt {
+	u32 crc;
+    u32 chipnum;
+	u16 shipped_bbt[MAX_CHIP_NUM][MAX_BAD_BLK_NUM];
+};
+
+struct nand_menson_key {
+	u32 crc;
+	u8 data[KEYSIZE];
+};
+
+/* typedef struct nand_menson_key meson_key; */	/* fixme, */
+
+struct secure_t {
+	/* CRC32 over data bytes */
+	u32 crc;
+	/* Environment data */
+	u8 data[SECURE_SIZE];
+};
+
+struct nand_arg_oobinfo {
+	char name[4];
+	u16 timestamp;
+};
+
+struct nand_arg_info {
+	u8 arg_type;
+	u16 valid_blk_addr;
+	u16 valid_page_addr;
+	u16 free_blk_addr;
+	u8 arg_valid;
+	u16 timestamp;
+	/*
+	flag indicate that: if read ecc error of any page of this block,
+	should move data to another block
+	*/
+	u8 update_flag;
+};
+
+struct block_status {
+	u32 crc;
+	u16 blk_status[MAX_CHIP_NUM][MAX_BLK_NUM];
+};
+
+/**whole nand chip information  include hw controller and flash information **/
+struct amlnand_chip {
+	struct block_status *block_status;
+
+	enum chip_state_t state;
+	u8 nand_status;
+	u8 init_flag;
+	u8 key_protect;
+	u8 secure_protect;
+	u8 fbbt_protect;
+	u8 ce_bit_mask;
+	struct hw_controller controller;
+
+	/* current operation parameter, should clear before used. */
+	struct chip_ops_para ops_para;
+
+	struct chip_operation operation;
+	struct nand_flash flash;
+
+	struct nand_arg_info config_msg;
+	struct nand_config *config_ptr;
+
+	struct nand_arg_info nand_bbtinfo;
+	struct nand_arg_info shipped_bbtinfo;
+	struct shipped_bbt *shipped_bbt_ptr;
+
+	struct nand_arg_info nand_key;
+	struct nand_arg_info nand_secure;
+	struct nand_arg_info uboot_env;
+#if (AML_CFG_DTB_RSV_EN)
+	struct nand_arg_info amlnf_dtb;
+#endif
+#ifndef AML_NAND_UBOOT
+	struct pinctrl *nand_pinctrl;
+	struct pinctrl_state *nand_pinstate;
+	struct pinctrl_state *nand_rbstate;
+	struct pinctrl_state *nand_norbstate;
+	struct pinctrl_state *nand_idlestate;
+	struct device			device;
+#endif /* AML_NAND_UBOOT */
+	u8 reserved_blk[RESERVED_BLOCK_CNT];
+	u32 max_ecc_per_page;
+	u8 *user_page_buf;
+	u8 *user_oob_buf;
+	u8 protect;
+	u8 debug_flag;
+	u8 g_retry_cnt;
+#ifndef AML_NAND_UBOOT
+	void __iomem *reg_base;
+	void __iomem *nand_clk_reg;
+#endif /*  */
+	u8 shipped_retry_flag; /* do factory bad block detect less than 2 times*/
+};
+
+extern struct nand_flash flash_ids_slc[];
+extern struct nand_flash flash_ids_mlc[];
+extern struct bch_desc bch_list[MAX_ECC_MODE_NUM];
+extern struct bch_desc bch_list_m8[MAX_ECC_MODE_NUM];
+extern struct amlnand_chip *aml_chip_secure;
+extern struct amlnand_chip *aml_nand_chip;
+
+extern enum chip_state_t get_chip_state(struct amlnand_chip *aml_chip);
+extern void set_chip_state(struct amlnand_chip *aml_chip,
+	enum chip_state_t state);
+extern int amlnand_get_device(struct amlnand_chip *aml_chip,
+	enum chip_state_t new_state);
+extern void amlnand_release_device(struct amlnand_chip *aml_chip);
+extern int amlnand_hwcontroller_init(struct amlnand_chip *aml_chip);
+extern int amlnand_init_operation(struct amlnand_chip *aml_chip);
+extern int amlnand_get_dev_configs(struct amlnand_chip *aml_chip);
+extern u32 amlnand_chip_init(struct amlnand_chip *aml_chip);
+extern int amlnand_phydev_init(struct amlnand_chip *aml_chip);
+extern int amlnand_update_bbt(struct amlnand_chip *aml_chip);
+extern int amlnand_set_readretry_slc_para(struct amlnand_chip *aml_chip);
+extern int aml_nand_scan_hynix_info(struct amlnand_chip *aml_chip);
+extern int nand_reset(struct amlnand_chip *aml_chip, u8 chipnr);
+extern void pinmux_select_chip(u32 ce_enable,
+	u32 rb_enable,
+	u32 flag);
+
+extern int32_t nand_secure_read(struct amlnand_chip *aml_chip,
+	char *buf,
+	int len);
+extern int32_t nand_secure_write(struct amlnand_chip *aml_chip,
+	char *buf,
+	int len);
+extern int aml_sys_info_init(struct amlnand_chip *aml_chip);
+extern void nand_boot_info_prepare(struct amlnand_phydev *phydev,
+	u8 *page0_buf);
+extern void uboot_set_ran_mode(struct amlnand_phydev *phydev);
+extern void get_sys_clk_rate(struct hw_controller *controller, int *rate);
+extern int aml_ubootenv_init(struct amlnand_chip *aml_chip);
+
+
+extern void nand_get_chip(void *aml_chip);
+extern void nand_release_chip(void *aml_chip);
+extern int aml_key_init(struct amlnand_chip *aml_chip);
+extern int aml_secure_init(struct amlnand_chip *aml_chip);
+extern int amlnand_info_init(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *buf,
+	u8 *name,
+	u32 size);
+extern int amlnand_check_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *name,
+	u32 size);
+extern int amlnand_save_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *buf,
+	u8 *name,
+	u32 size);
+extern int amlnand_read_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *buf,
+	u8 *name,
+	u32 size);
+extern int amlnand_erase_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *name);
+extern int aml_sys_info_error_handle(struct amlnand_chip *aml_chip);
+extern int aml_nand_update_key(struct amlnand_chip *aml_chip, char *key_ptr);
+extern int aml_nand_update_secure(struct amlnand_chip *aml_chip,
+	char *secure_ptr);
+extern int aml_nand_update_ubootenv(struct amlnand_chip *aml_chip,
+	char *env_ptr);
+
+extern int aml_nand_update_dtb(struct amlnand_chip *aml_chip,
+	char *dtb_ptr);
+
+extern void amlchip_dumpinfo(struct amlnand_chip *aml_chip);
+
+#endif /* NAND_H_INCLUDED */
diff --git a/drivers/nand/logiclib/Makefile b/drivers/nand/logiclib/Makefile
new file mode 100644
index 0000000..9aa5c7d
--- /dev/null
+++ b/drivers/nand/logiclib/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(CONFIG_AML_NAND) += aml_nand_logic-150918.o
diff --git a/drivers/nand/logiclib/aml_nand_logic-150522.o_shipped b/drivers/nand/logiclib/aml_nand_logic-150522.o_shipped
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/nand/logiclib/aml_nand_logic-150611.o_shipped b/drivers/nand/logiclib/aml_nand_logic-150611.o_shipped
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/nand/logiclib/aml_nand_logic-150918.o_shipped b/drivers/nand/logiclib/aml_nand_logic-150918.o_shipped
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/nand/phy/Makefile b/drivers/nand/phy/Makefile
new file mode 100644
index 0000000..e46f338
--- /dev/null
+++ b/drivers/nand/phy/Makefile
@@ -0,0 +1,14 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+
+EXTRA_CFLAGS = -Idrivers/nand/include/
+
+obj-$(CONFIG_AML_NAND) += aml_nand_phy.o
+
+aml_nand_phy-y := amlnand_init.o chip.o chip_operation.o hw_controller.o id_table.o phydev.o chipenv.o new_nand.o boot_operation.o cmd_utils.o
+
diff --git a/drivers/nand/phy/amlnand_init.c b/drivers/nand/phy/amlnand_init.c
new file mode 100644
index 0000000..1331790
--- /dev/null
+++ b/drivers/nand/phy/amlnand_init.c
@@ -0,0 +1,389 @@
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : driver_uboot.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**			amlnand_init,  mainly init nand phy driver.
+**
+**
+*****************************************************************/
+
+#include "../include/phynand.h"
+
+struct amlnand_chip *aml_nand_chip = NULL;
+extern int boot_dev_init(struct amlnand_chip *aml_chip);
+
+static void show_nand_driver_version(void)
+{
+	aml_nand_msg("Nand PHY Ver:%d.%02d.%03d.%04d (c) 2013 Amlogic Inc.",
+		(DRV_PHY_VERSION >> 24)&0xff,
+		(DRV_PHY_VERSION >> 16)&0xff,
+		(DRV_PHY_VERSION >> 8)&0xff,
+		(DRV_PHY_VERSION)&0xff);
+}
+static int amlnf_phy_resource(struct amlnand_chip *aml_chip, struct platform_device *pdev)
+{
+	int ret = 0;
+	if (aml_chip == NULL) {
+		aml_nand_msg("%s() %d: invalid param!", __FUNCTION__, __LINE__);
+		ret = -1;
+		goto _out;
+	}
+
+#ifndef AML_NAND_UBOOT
+	aml_chip->device = pdev->dev;
+
+	aml_nand_msg("%s() %d: amlnf init flag %d",
+		__FUNCTION__, __LINE__, aml_chip->init_flag);
+
+#ifdef CONFIG_OF
+	aml_chip->nand_pinctrl = devm_pinctrl_get(&aml_chip->device);
+	if (IS_ERR(aml_chip->nand_pinctrl)) {
+		aml_nand_msg("get pinctrl error");
+		return PTR_ERR(aml_chip->nand_pinctrl);
+	}
+	aml_chip->nand_rbstate = pinctrl_lookup_state(aml_chip->nand_pinctrl,
+		"nand_rb_mod");
+	if (IS_ERR(aml_chip->nand_rbstate)) {
+		devm_pinctrl_put(aml_chip->nand_pinctrl);
+		return PTR_ERR(aml_chip->nand_rbstate);
+	}
+	aml_chip->nand_norbstate = pinctrl_lookup_state(aml_chip->nand_pinctrl,
+		"nand_norb_mod");
+	if (IS_ERR(aml_chip->nand_norbstate)) {
+		devm_pinctrl_put(aml_chip->nand_pinctrl);
+		return PTR_ERR(aml_chip->nand_norbstate);
+	}
+	aml_chip->nand_idlestate = pinctrl_lookup_state(aml_chip->nand_pinctrl,
+		"nand_cs_pins_only");
+	if (IS_ERR(aml_chip->nand_idlestate)) {
+		devm_pinctrl_put(aml_chip->nand_pinctrl);
+		return PTR_ERR(aml_chip->nand_idlestate);
+	}
+#endif /* CONFIG_OF */
+#endif	/* AML_NAND_UBOOT */
+_out:
+	return ret;
+}
+
+extern int  dbg_amlnf_erase_ops(u64 off, u64 erase_len, unsigned char scrub_flag);
+extern void amlnf_get_chip_size(u64 *size);
+void dbg_erase_whole_chip(struct amlnand_chip *aml_chip)
+{
+	struct nand_flash *flash = &aml_chip->flash;
+	u64 chipsize;
+
+	PHY_NAND_LINE
+	//amlnf_get_chip_size(&chipsize);
+	chipsize = flash->blocksize * 4;	//erase 1st 60 blocks.
+	PHY_NAND_LINE
+
+	dbg_amlnf_erase_ops(0, chipsize, 1);
+
+
+}
+
+//-------------------------------------------------------------------------------------------------------------------
+extern void _dump_mem(u32 * buf, u32 len);
+#define DBG_OOB_LEN		(8)
+static void dbg_buffer_free(struct amlnand_chip *aml_chip)
+{
+	if (aml_chip->user_oob_buf != NULL)
+		kfree(aml_chip->user_oob_buf);
+
+	if (aml_chip->user_page_buf != NULL)
+		kfree(aml_chip->user_page_buf);
+	return;
+}
+
+static void dbg_buffer_alloc(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	u32 ret = 0, buf_size;
+
+	buf_size = flash->oobsize * controller->chip_num;
+	if (flash->option & NAND_MULTI_PLANE_MODE)
+		buf_size <<= 1;
+
+	aml_chip->user_oob_buf = aml_nand_malloc(buf_size);
+	if (aml_chip->user_oob_buf == NULL) {
+		aml_nand_msg("malloc failed for user_oob_buf ");
+		ret = -NAND_MALLOC_FAILURE;
+		goto _out;
+	}
+	memset(aml_chip->user_oob_buf, 0x0, buf_size);
+	buf_size = (flash->pagesize + flash->oobsize) * controller->chip_num;
+	if (flash->option & NAND_MULTI_PLANE_MODE)
+		buf_size <<= 1;
+
+	aml_chip->user_page_buf = aml_nand_malloc(buf_size);
+	if (aml_chip->user_page_buf == NULL) {
+		aml_nand_msg("malloc failed for user_page_buf ");
+		ret = -NAND_MALLOC_FAILURE;
+		goto _out;
+	}
+	memset(aml_chip->user_page_buf, 0x0, buf_size);
+	return;
+	if (ret) {
+		aml_nand_msg("%s() ret %d", __func__, ret);
+	}
+
+_out:
+	dbg_buffer_free(aml_chip);
+	return;
+}
+
+void dbg_calcaddress(u8 chip, u32 blk, u32 page, struct amlnand_chip *aml_chip)
+{
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	u8 phys_erase_shift, phys_page_shift;
+	u32 pages_per_blk;
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+
+	ops_para->chipnr = chip;
+	ops_para->page_addr = blk * pages_per_blk + page;
+	ops_para->ooblen = DBG_OOB_LEN;
+
+	printk("%s(%d, %d, %d) - %x\n", __func__, chip, blk, page, ops_para->page_addr);
+}
+
+void dbg_ereaeblk(u8 chip, u32 blk, struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	int ret;
+
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	dbg_calcaddress(chip, blk, 0, aml_chip);
+
+	ops_para->data_buf = aml_chip->user_page_buf;
+	ops_para->oob_buf = aml_chip->user_oob_buf;
+
+	controller->select_chip(controller, ops_para->chipnr);
+	nand_get_chip(aml_chip);
+	ret = operation->erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("%s() %d: nand erased failed", __func__, __LINE__);
+	}
+	nand_release_chip(aml_chip);
+
+}
+
+void dbg_readpage(u8 chip, u32 blk, u32 page, struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	int ret;
+
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	memset(ops_para->data_buf, 0x0, flash->pagesize);
+	memset(ops_para->oob_buf, 0x0, DBG_OOB_LEN);
+	dbg_calcaddress(chip, blk, page, aml_chip);
+
+	ops_para->data_buf = aml_chip->user_page_buf;
+	ops_para->oob_buf = aml_chip->user_oob_buf;
+
+	controller->select_chip(controller, ops_para->chipnr);
+	nand_get_chip(aml_chip);
+	ret = operation->read_page(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("%s() %d: nand read failed", __func__, __LINE__);
+	}
+	nand_release_chip(aml_chip);
+	_dump_mem((u32 *)ops_para->oob_buf, DBG_OOB_LEN);
+	_dump_mem((u32 *)ops_para->data_buf, 512);
+
+}
+
+void dbg_writepage(u8 chip, u32 blk, u32 page, struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	int ret;
+
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	dbg_calcaddress(chip, blk, page, aml_chip);
+
+	ops_para->data_buf = aml_chip->user_page_buf;
+	ops_para->oob_buf = aml_chip->user_oob_buf;
+
+	memset(ops_para->data_buf, 0xAA, flash->pagesize);
+	memset(ops_para->oob_buf, 0x55, DBG_OOB_LEN);
+
+	controller->select_chip(controller, ops_para->chipnr);
+	nand_get_chip(aml_chip);
+	ret = operation->write_page(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("%s() %d: nand write failed", __func__, __LINE__);
+	}
+	nand_release_chip(aml_chip);
+
+}
+
+void dbg_phyop( void )
+{
+	/* u64 blksize; */
+	struct amlnand_chip *aml_chip = aml_nand_chip;
+	/* struct hw_controller *controller = &aml_chip->controller; */
+	/* struct nand_flash *flash = &aml_chip->flash; */
+
+	PHY_NAND_LINE
+	dbg_buffer_alloc(aml_chip);
+	PHY_NAND_LINE
+#if 0
+	blksize = (u64) flash->blocksize;
+	PHY_NAND_LINE
+	printk("erase\n");
+	amlnf_erase_ops(0, blksize * 2, 1);
+
+	printk("erase again\n");
+	dbg_ereaeblk(0, 0, aml_chip);
+#endif
+	PHY_NAND_LINE	//write page here
+	//printk("read after erase!\n");
+	dbg_readpage(0, 80, 0, aml_chip);
+	dbg_readpage(0, 81, 0, aml_chip);
+	PHY_NAND_LINE	//read page here.
+#if 0
+	printk("write!\n");
+	dbg_writepage(0, 0, 0, aml_chip);
+	printk("read!\n");
+	dbg_readpage(0, 0, 0, aml_chip);
+	PHY_NAND_LINE
+#endif //0
+	dbg_buffer_free(aml_chip);
+}
+
+int amlnf_phy_init(u8 flag, struct platform_device *pdev)
+{
+	struct amlnand_chip *aml_chip = NULL;
+	int ret = 0;
+
+	/*show nand phy version here.*/
+	show_nand_driver_version();
+
+	aml_chip = aml_nand_malloc(sizeof(struct amlnand_chip));
+	if (aml_chip == NULL) {
+		aml_nand_msg("malloc failed for aml_chip:%x",
+			(uint32_t)sizeof(struct amlnand_chip));
+		ret = -NAND_MALLOC_FAILURE;
+		goto exit_error1;
+	}
+	memset(aml_chip , 0, sizeof(struct amlnand_chip));
+	memset(aml_chip->reserved_blk, 0xff, RESERVED_BLOCK_CNT);
+	aml_chip->init_flag = flag;
+	aml_chip->nand_status = NAND_STATUS_NORMAL;
+	aml_nand_chip = aml_chip;
+	PHY_NAND_LINE
+	ret = amlnf_phy_resource(aml_chip, pdev);
+	if (ret)
+		goto exit_error1;
+
+	PHY_NAND_LINE
+	/* Step 1: init hw controller */
+	ret = amlnand_hwcontroller_init(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("aml_hw_controller_init failed");
+		ret = -NAND_FAILED;
+		goto exit_error1;
+	}
+	PHY_NAND_LINE
+	/* Step 2: init aml_chip operation */
+	ret = amlnand_init_operation(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("chip detect failed and ret:%x", ret);
+		ret = -NAND_FAILED;
+		goto exit_error1;
+	}
+	PHY_NAND_LINE
+	/* Step 3: get nand id and get hw flash information */
+	ret = amlnand_chip_init(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("chip detect failed and ret:%x", ret);
+		device_boot_flag = EMMC_BOOT_FLAG;
+		ret = -NAND_FAILED;
+		goto exit_error1;
+	}
+	PHY_NAND_LINE
+	/* update device_boot_flag for outsides */
+	device_boot_flag = NAND_BOOT_FLAG;
+	PHY_NAND_LINE
+	if (aml_chip->init_flag == NAND_SCAN_ID_INIT)
+		goto exit_error1;
+	PHY_NAND_LINE
+
+	//fixme, debug code
+	//dbg_phyop(aml_chip);
+	//dbg_erase_whole_chip(aml_chip);
+
+	/* step 3.5 init boot phydev 1st, then we can operate uboot no matter what happens further.*/
+	boot_dev_init(aml_chip);
+	if (aml_chip->init_flag == 6) {	//NAND_PHY_INIT
+			PHY_NAND_LINE
+			goto exit_error0;
+	}
+
+	//Step 4: get device configs
+	ret = amlnand_get_dev_configs(aml_chip);
+	if (ret < 0) {
+		if ((ret == -NAND_CONFIGS_FAILED) || (ret == -NAND_SHIPPED_BADBLOCK_FAILED)) {
+			aml_nand_msg("get device configs failed and ret:%x", ret);
+			goto exit_error0;
+		}else{
+			aml_nand_msg("get device configs failed and ret:%x", ret);
+			ret = -NAND_READ_FAILED;
+			goto exit_error0;
+		}
+	}
+	PHY_NAND_LINE
+	if (aml_chip->init_flag >= NAND_BOOT_ERASE_PROTECT_CACHE) {
+		struct hw_controller *controller = &aml_chip->controller;
+#ifndef AML_NAND_UBOOT
+		struct nand_flash *flash = &aml_chip->flash;
+
+		amlnf_dma_free(controller->data_buf, (flash->pagesize + flash->oobsize), 0);
+		amlnf_dma_free(controller->user_buf, (flash->pagesize /controller->ecc_bytes)*sizeof(int), 1);
+#else /* AML_NAND_UBOOT */
+		aml_nand_free(controller->data_buf);
+		aml_nand_free(controller->user_buf);
+#endif /* AML_NAND_UBOOT */
+		aml_nand_free(controller->page_buf);
+		aml_nand_free(controller->oob_buf);
+
+		//nand_buf_free(aml_chip);
+		/*exit with error code in porpoises, while we are erasing.*/
+		ret = -1;
+		goto exit_error1;
+	}else{
+		//Step 5: register nand device, and config device information
+		PHY_NAND_LINE
+		ret = amlnand_phydev_init(aml_chip);
+		PHY_NAND_LINE
+		if (ret < 0) {
+			aml_nand_msg("register nand device failed and ret:%x", ret);
+			ret = -NAND_READ_FAILED;
+			goto exit_error0;
+		}
+	}
+	return ret;
+
+exit_error1:
+	aml_nand_free(aml_chip);
+exit_error0:
+
+	return ret;
+}
+
diff --git a/drivers/nand/phy/boot_operation.c b/drivers/nand/phy/boot_operation.c
new file mode 100644
index 0000000..be4fc49
--- /dev/null
+++ b/drivers/nand/phy/boot_operation.c
@@ -0,0 +1,839 @@
+
+
+#include "../include/phynand.h"
+
+
+extern void uboot_set_ran_mode(struct amlnand_phydev *phydev);
+extern void nand_boot_info_prepare(struct amlnand_phydev *phydev, unsigned char * page0_buf);
+
+static int read_uboot(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+
+	u32 configure_data, pages_per_blk, configure_data_w;
+	u32 pages_per_blk_w, page_size, tmp_size;
+	u8 tmp_bch_mode, tmp_user_mode, tmp_ecc_limit, tmp_ecc_max;
+	u16 tmp_ecc_unit, tmp_ecc_bytes, tmp_ecc_steps;
+	u64 addr, readlen = 0, len = 0;
+	int ret = 0;
+	u32 tmp_value;
+
+	if ((devops->addr + devops->len) >  phydev->size) {
+		aml_nand_msg("read uboot:out of space");
+		aml_nand_msg("addr:%llx len:%llx offset:%llx size:%llx",
+			devops->addr,
+			devops->len,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	if ((devops->len == 0) && (devops->ooblen == 0)) {
+		aml_nand_msg("len equal zero here");
+		return NAND_SUCCESS;
+	}
+
+	tmp_ecc_unit = controller->ecc_unit;
+	tmp_ecc_bytes = controller->ecc_bytes;
+	tmp_bch_mode = controller->bch_mode;
+	tmp_user_mode	= controller->user_mode;
+	tmp_ecc_limit = controller->ecc_cnt_limit;
+	tmp_ecc_max = controller->ecc_max;
+	tmp_ecc_steps = controller->ecc_steps;
+
+	if (controller->bch_mode == NAND_ECC_BCH_SHORT)
+		page_size = (flash->pagesize / 512) * NAND_ECC_UNIT_SHORT;
+
+	tmp_size = phydev->writesize;
+	/* phydev->writesize = page_size; */
+
+	/* amlnand_get_device(aml_chip, CHIP_READING); */
+
+	//clear ops_para here
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+
+	if (devops->len == 0) {
+		len = phydev->writesize;
+		ops_para->ooblen = devops->ooblen;
+	} else {
+		len = devops->len;
+		ops_para->ooblen = devops->ooblen;
+	}
+
+	addr = phydev->offset + devops->addr;
+	ops_para->data_buf = devops->datbuf;
+	ops_para->option = phydev->option;
+	ops_para->oob_buf = devops->oobbuf;
+
+	if (devops->mode == NAND_SOFT_ECC)
+		ops_para->option |= DEV_ECC_SOFT_MODE;
+
+	if ((flash->new_type) &&
+		((flash->new_type < 10) || (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+
+	pages_per_blk = flash->blocksize / flash->pagesize;
+	configure_data = NFC_CMD_N2M(controller->ran_mode,
+		controller->bch_mode,
+		0,
+		(controller->ecc_unit >> 3),
+		controller->ecc_steps);
+	while (1) {
+		if ((((u32)addr / flash->pagesize) %
+			BOOT_PAGES_PER_COPY) == 0) {
+				uboot_set_ran_mode(phydev);
+				page_size = (flash->pagesize / 512) *
+					NAND_ECC_UNIT_SHORT;
+				phydev->writesize = page_size;
+#if 1
+				controller->ecc_unit = NAND_ECC_UNIT_SHORT;
+				controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
+				controller->bch_mode = NAND_ECC_BCH_SHORT;
+				controller->user_mode = 2;
+				controller->ecc_cnt_limit = 55;
+				controller->ecc_max = 60;
+				controller->ecc_steps =
+					(flash->pagesize+flash->oobsize)/512;
+#endif
+		} else
+			controller->ran_mode = 1;
+
+		/* controller->chip_num; */
+		ops_para->page_addr = ((u32)addr / flash->pagesize);
+		if ((ops_para->option & DEV_SLC_MODE)) {
+			tmp_value = ops_para->page_addr;
+			tmp_value &= (~(pages_per_blk - 1));
+			if ((flash->new_type > 0) && (flash->new_type < 10))
+				ops_para->page_addr = tmp_value |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+			if (flash->new_type == SANDISK_19NM)
+				ops_para->page_addr = tmp_value |
+				((ops_para->page_addr % pages_per_blk) << 1);
+		}
+
+		ret = operation->read_page(aml_chip);
+		if ((ops_para->ecc_err) || (ret < 0)) {
+			aml_nand_msg("fail page_addr:%d", ops_para->page_addr);
+			break;
+		}
+
+		/* check info page */
+		if ((!strncmp((char *)phydev->name,
+				NAND_BOOT_NAME,
+				strlen((const char *)NAND_BOOT_NAME)))
+				&& (((((u32)addr / flash->pagesize))%
+				BOOT_PAGES_PER_COPY) == 0)) {
+			controller->ran_mode = 1;
+			memcpy((u8 *)(&configure_data_w),
+				ops_para->data_buf,
+				sizeof(int));
+			memcpy((u8 *)(&pages_per_blk_w),
+				ops_para->data_buf+4,
+				sizeof(int));
+
+			aml_nand_msg("configure_data:%x, pages_per_blk:%x",
+				configure_data,
+				pages_per_blk);
+			/*
+			if ((pages_per_blk_w != pages_per_blk)
+				|| (configure_data_w != configure_data)){
+				aml_nand_msg("boot check data failed,
+				and configure_data_w:0x%x,
+				pages_per_blk_w:0x%x",
+				configure_data_w,
+				pages_per_blk_w);
+			}*/
+			addr += flash->pagesize;
+#if 1
+			controller->ecc_unit = tmp_ecc_unit;
+			controller->ecc_bytes = tmp_ecc_bytes;
+			controller->bch_mode = tmp_bch_mode;
+			controller->user_mode = tmp_user_mode;
+			controller->ecc_cnt_limit = tmp_ecc_limit;
+			controller->ecc_max = tmp_ecc_max;
+			controller->ecc_steps = tmp_ecc_steps;
+			phydev->writesize = tmp_size;
+#endif
+			continue;
+		}
+
+		addr += flash->pagesize;
+		ops_para->data_buf += phydev->writesize;
+		readlen += phydev->writesize;
+
+		if (readlen >= len)
+			break;
+	}
+
+	devops->retlen = readlen;
+	/* amlnand_release_device(aml_chip); */
+	if (!ret) {
+		if (ops_para->ecc_err)
+			ret = NAND_ECC_FAILURE;
+		/*else if(ops_para->bit_flip){
+			ret = NAND_BITFLIP_FAILURE;
+		}*/
+	}
+
+	controller->ran_mode = 1;
+	controller->ecc_unit = tmp_ecc_unit;
+	controller->ecc_bytes = tmp_ecc_bytes;
+	controller->bch_mode = tmp_bch_mode;
+	controller->user_mode = tmp_user_mode;
+	controller->ecc_cnt_limit = tmp_ecc_limit;
+	controller->ecc_max = tmp_ecc_max;
+	controller->ecc_steps = tmp_ecc_steps;
+	phydev->writesize = tmp_size;
+
+	return ret;
+}
+
+int roomboot_nand_read(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	u64 offset , write_len;
+	u8 *buffer;
+	int ret = 0;
+	int oob_set = 0;
+
+	offset = devops->addr;
+	write_len = devops->len;
+	buffer = devops->datbuf;
+
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = write_len;
+	devops->datbuf = buffer;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+
+	if (controller->oob_mod) {
+		oob_set = controller->oob_mod;
+		NFC_CLR_OOB_MODE(controller, 3<<26);
+		controller->oob_mod = 0;
+	}
+
+	amlnand_get_device(aml_chip, CHIP_READING);
+
+	ret = read_uboot(phydev);
+	if (ret < 0)
+		aml_nand_dbg("nand read failed at %llx", devops->addr);
+
+	amlnand_release_device(aml_chip);
+	if (oob_set) {
+		controller->oob_mod = oob_set;
+		NFC_SET_OOB_MODE(controller, 3<<26);
+	}
+	return ret;
+}
+void _dump_mem_u8(uint8_t * buf, uint32_t len)
+{
+	uint32_t i;
+	if (buf == NULL)
+		return;
+	printk("%s, %p, %d", __func__, buf, len);
+	for (i = 0; i < len/sizeof(uint8_t); i++) {
+
+		if ( i % 16 == 0)
+			printk("\n0x%p: ", buf+i);
+		printk("%02x ", buf[i]);
+	}
+	printk("\n");
+	return;
+}
+static int write_uboot(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	u8 *fill_buf = NULL;
+	u8 *oob_buf = NULL, *page0_buf = NULL;
+	u8 tmp_bch_mode, tmp_user_mode, tmp_ecc_limit, tmp_ecc_max;
+	u8 tmp_rand;
+	u32 configure_data, pages_per_blk;
+	u32 oobsize, page_size, tmp_size, priv_lsb, ops_tem;
+	u16 tmp_ecc_unit, tmp_ecc_bytes, tmp_ecc_steps;
+	u64 addr, writelen = 0, len = 0;
+	int  i, ret = 0;
+	u8 *lazy_buf = devops->datbuf;
+	/* u8  *tmp_buf; */
+	char write_boot_status[BOOT_COPY_NUM] = {0}, err = 0;
+	u32 tmp_value;
+
+	BOOT_LINE
+	if ((devops->addr + devops->len) >  phydev->size) {
+		aml_nand_msg("writeboot:out of space and addr:");
+		aml_nand_msg("%llx len:%llx offset:%llx size:%llx",
+			devops->addr,
+			devops->len,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	if ((devops->len == 0) && (devops->ooblen == 0)) {
+		aml_nand_msg("len equal zero here");
+		return NAND_SUCCESS;
+	}
+
+	if (devops->addr != 0) {
+		aml_nand_msg("addr do not equal zero here for uboot write");
+		return NAND_SUCCESS;
+	}
+
+	tmp_ecc_unit = controller->ecc_unit;
+	tmp_ecc_bytes = controller->ecc_bytes;
+	tmp_bch_mode = controller->bch_mode;
+	tmp_user_mode	= controller->user_mode;
+	tmp_ecc_limit = controller->ecc_cnt_limit;
+	tmp_ecc_max = controller->ecc_max;
+	tmp_ecc_steps = controller->ecc_steps;
+	tmp_rand = controller->ran_mode;
+
+	if (controller->bch_mode == NAND_ECC_BCH_SHORT)
+		page_size = (flash->pagesize / 512) * NAND_ECC_UNIT_SHORT;
+
+	oobsize = controller->ecc_steps*controller->user_mode;
+	BOOT_LINE
+	tmp_size = phydev->writesize;
+	/* phydev->writesize = page_size; */
+
+	amlnand_get_device(aml_chip, CHIP_WRITING);
+
+	oob_buf = aml_nand_malloc(oobsize);
+	if (oob_buf == NULL) {
+		aml_nand_msg("malloc failed and oobavail:%d", phydev->oobavail);
+		ret = -NAND_MALLOC_FAILURE;
+		goto error_exit;
+	}
+	memset(oob_buf, 0x0, oobsize);
+	page0_buf = aml_nand_malloc(flash->pagesize);
+	if (page0_buf == NULL) {
+		aml_nand_msg("malloc failed and oobavail:%d", flash->pagesize);
+		ret = -NAND_MALLOC_FAILURE;
+		goto error_exit;
+	}
+	memset(page0_buf, 0x0, flash->pagesize);
+	len = devops->len;
+	for (i = 0; i < oobsize; i += 2) {
+		oob_buf[i] = 0x55;
+		oob_buf[i+1] = 0xaa;
+	}
+	fill_buf = aml_nand_malloc(flash->pagesize);
+	if (fill_buf == NULL) {
+		aml_nand_msg("malloc failed and oobavail:%d", flash->pagesize);
+		ret = -NAND_MALLOC_FAILURE;
+		goto error_exit;
+	}
+	memset(fill_buf, 0xff, flash->pagesize);
+	BOOT_LINE
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	ops_para->option = phydev->option;
+	ops_para->data_buf = devops->datbuf;
+	ops_para->oob_buf = oob_buf;
+	BOOT_LINE
+	if ((flash->new_type)
+		&& ((flash->new_type < 10)
+		|| (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+
+	configure_data = NFC_CMD_N2M(controller->ran_mode,
+		controller->bch_mode,
+		0,
+		(controller->ecc_unit >> 3),
+		controller->ecc_steps);
+
+	/*
+	configure_data = NFC_CMD_N2M(controller->ran_mode,
+		NAND_ECC_BCH60_1K,
+		1,
+		(controller->ecc_unit >> 3),
+		controller->ecc_steps);
+	*/
+	pages_per_blk = flash->blocksize / flash->pagesize;
+	aml_nand_msg("configure_data:%x, pages_per_blk:%x",
+		configure_data,
+		pages_per_blk);
+
+	nand_boot_info_prepare(phydev, page0_buf);
+	//_dump_mem_u8((uint8_t *)page0_buf, 384);
+	BOOT_LINE
+	for (i = 0; i < BOOT_COPY_NUM; i++) {
+
+		BOOT_LINE
+		writelen = 0;
+		addr = 0;
+		addr += flash->pagesize*(BOOT_PAGES_PER_COPY*i);
+		ops_para->data_buf = lazy_buf;
+		devops->datbuf = lazy_buf;
+		while (1) {
+			if (((((u32)addr / flash->pagesize)) %
+				BOOT_PAGES_PER_COPY) == 0) {
+				uboot_set_ran_mode(phydev);
+				ops_para->data_buf = page0_buf;
+
+				page_size =
+				(flash->pagesize / 512) * NAND_ECC_UNIT_SHORT;
+				phydev->writesize = page_size;
+#if 1
+				controller->ecc_unit = NAND_ECC_UNIT_SHORT;
+				controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
+				controller->bch_mode = NAND_ECC_BCH_SHORT;
+				controller->user_mode = 2;
+				controller->ecc_cnt_limit = 55;
+				controller->ecc_max = 60;
+				controller->ecc_steps =
+					(flash->pagesize+flash->oobsize)/512;
+#endif
+			}
+			ops_para->page_addr = ((u32)addr / flash->pagesize);
+			ops_tem = ops_para->page_addr;
+			if ((ops_para->option & DEV_SLC_MODE)) {
+				tmp_value = ops_para->page_addr;
+				tmp_value &= (~(pages_per_blk - 1));
+				if ((flash->new_type > 0)
+					&& (flash->new_type < 10))
+					ops_para->page_addr = tmp_value |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+				if (flash->new_type == SANDISK_19NM)
+					ops_para->page_addr = tmp_value |
+				((ops_para->page_addr % pages_per_blk) << 1);
+			}
+#if 1
+			if (flash->new_type == HYNIX_1YNM) {
+				if ((ops_tem % 256) > 1) {
+					tmp_value = ops_tem;
+					tmp_value &= (~(pages_per_blk - 1));
+					priv_lsb = tmp_value |
+					(slc_info->pagelist[(ops_tem % 256)-1]);
+					ops_tem = ops_para->page_addr;
+					while (ops_tem > (priv_lsb+1)) {
+						ops_para->data_buf = fill_buf;
+						controller->bch_mode =
+							NAND_ECC_NONE;
+						controller->ran_mode = 0;
+						ops_para->page_addr =
+							priv_lsb+1;
+						operation->write_page(aml_chip);
+						priv_lsb++;
+					}
+					ops_para->page_addr = ops_tem;
+					ops_para->data_buf = devops->datbuf;
+					controller->ecc_unit = tmp_ecc_unit;
+					controller->ecc_bytes = tmp_ecc_bytes;
+					controller->bch_mode = tmp_bch_mode;
+					controller->user_mode = tmp_user_mode;
+					controller->ecc_cnt_limit =
+						tmp_ecc_limit;
+					controller->ecc_max = tmp_ecc_max;
+					controller->ecc_steps = tmp_ecc_steps;
+					phydev->writesize = tmp_size;
+					controller->ran_mode = tmp_rand;
+				}
+			}
+#endif
+			if (((((u32)addr / flash->pagesize)) %
+				BOOT_PAGES_PER_COPY) != 0)
+				ops_para->data_buf = devops->datbuf;
+			ret = operation->write_page(aml_chip);
+			//printk("copy %d, page 0x%08x\n", i, ops_para->page_addr);
+			//printk("P_NAND_CFG 0x%x", AMLNF_READ_REG(P_NAND_BASE + P_NAND_CFG));
+			if (ret < 0) {
+				write_boot_status[i] = 1;
+				aml_nand_msg("fail page_addr:%d",
+					ops_para->page_addr);
+				break;
+			}
+
+			if ((((u32)addr / flash->pagesize) %
+				BOOT_PAGES_PER_COPY) == 0) {
+				controller->ran_mode = 1;
+				addr += flash->pagesize;
+				ops_para->data_buf = devops->datbuf;
+#if 1
+				controller->ecc_unit = tmp_ecc_unit;
+				controller->ecc_bytes = tmp_ecc_bytes;
+				controller->bch_mode = tmp_bch_mode;
+				controller->user_mode = tmp_user_mode;
+				controller->ecc_cnt_limit = tmp_ecc_limit;
+				controller->ecc_max = tmp_ecc_max;
+				controller->ecc_steps = tmp_ecc_steps;
+				phydev->writesize = tmp_size;
+#endif
+				continue;
+			}
+
+			addr += flash->pagesize;
+			devops->datbuf += phydev->writesize;
+			writelen += phydev->writesize;
+
+			if ((writelen >= devops->len)
+				&& (writelen < phydev->erasesize))
+				devops->datbuf = fill_buf;
+
+			if ((writelen >= (len-flash->pagesize))
+				|| ((ops_para->option & DEV_SLC_MODE)
+				&& ((u32)addr%(flash->blocksize>>1) == 0))
+				|| (((ops_para->option & DEV_SLC_MODE) == 0)
+				&& ((u32)addr%flash->blocksize == 0)))
+				break;
+		}
+	}
+	BOOT_LINE
+	for (i = 0; i < BOOT_COPY_NUM; i++)
+		err += write_boot_status[i];
+
+	if (err < 2)
+		ret = 0;
+	else
+	    ret = 1;
+	devops->retlen = writelen;
+
+error_exit:
+	amlnand_release_device(aml_chip);
+	controller->ran_mode = 1;
+	controller->ecc_unit = tmp_ecc_unit;
+	controller->ecc_bytes = tmp_ecc_bytes;
+	controller->bch_mode = tmp_bch_mode;
+	controller->user_mode = tmp_user_mode;
+	controller->ecc_cnt_limit = tmp_ecc_limit;
+	controller->ecc_max = tmp_ecc_max;
+	controller->ecc_steps = tmp_ecc_steps;
+	phydev->writesize = tmp_size;
+	kfree(fill_buf);
+	fill_buf = NULL;
+
+	kfree(page0_buf);
+	page0_buf = NULL;
+	kfree(oob_buf);
+	oob_buf = NULL;
+	return ret;
+}
+
+int roomboot_nand_write(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+
+	u64 offset , write_len, addr;
+	u8 *buffer;
+	int pages_per_blk = 0, ret = 0;
+	int oob_set = 0;
+	u32 tmp_value;
+
+	offset = devops->addr;
+	write_len = devops->len;
+	buffer = devops->datbuf;
+
+	if (offset != 0) {
+		aml_nand_msg("Wrong addr begin");
+		return -1;
+	}
+	if (write_len <  phydev->erasesize)
+		write_len =  phydev->erasesize;
+	if ((flash->new_type)
+		&& ((flash->new_type < 10)
+			|| (flash->new_type == SANDISK_19NM)))
+		write_len =  phydev->erasesize >> 1;
+
+	write_len = ((((u32)write_len + phydev->writesize)-1)/
+		phydev->writesize)*phydev->writesize;
+
+	if ((offset & (phydev->writesize - 1)) != 0
+		|| (write_len & (phydev->writesize - 1)) != 0) {
+		aml_nand_msg("Attempt to write non page aligned data\n");
+		return -NAND_WRITE_FAILED;
+	}
+	BOOT_LINE
+	if ((offset + write_len) > (phydev->size / BOOT_COPY_NUM)) {
+		aml_nand_msg("Attemp to write out side the dev area");
+		return -NAND_WRITE_FAILED;
+	}
+
+	if (controller->oob_mod) {
+		oob_set = controller->oob_mod;
+		NFC_CLR_OOB_MODE(controller, 3<<26);
+		controller->oob_mod = 0;
+	}
+	pages_per_blk = flash->blocksize / flash->pagesize;
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	ops_para->chipnr = 0;
+	ops_para->option = phydev->option;
+	if ((flash->new_type) && (flash->new_type == SANDISK_19NM))
+		ops_para->option |= DEV_SLC_MODE;
+
+	do {
+		ops_para->page_addr = ((u32)addr / flash->pagesize);
+		controller->select_chip(controller, ops_para->chipnr);
+		//fixme, we may should skip the
+	#if 0
+		ret = operation->block_isbad(aml_chip);
+	#else
+		ret = 0; //do not check bad block....
+	#endif
+		if (ret ==  NAND_BLOCK_FACTORY_BAD) {
+			aml_nand_msg("blk is shipped bad block at page %d",
+				ops_para->page_addr);
+			addr += phydev->erasesize;
+			continue;
+		}
+		BOOT_LINE
+
+		if ((flash->new_type == SANDISK_19NM)
+			&& (ops_para->option & DEV_SLC_MODE)) {
+			tmp_value = ops_para->page_addr;
+			tmp_value &= (~(pages_per_blk - 1));
+			ops_para->page_addr = tmp_value |
+				((ops_para->page_addr % pages_per_blk) << 1);
+		}
+
+		nand_get_chip(aml_chip);
+		BOOT_LINE
+		ret = operation->erase_block(aml_chip);
+		BOOT_LINE
+		nand_release_chip(aml_chip);
+		if (ret < 0)
+			aml_nand_msg("nand erase fail at addr page %d",
+				ops_para->page_addr);
+			/* break; */
+		addr += phydev->erasesize;
+	} while (addr < (1024 * flash->pagesize));
+	BOOT_LINE
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = write_len;
+	devops->datbuf = buffer;	//!!
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+
+	aml_nand_dbg("devops->addr =%llx", devops->addr);
+	aml_nand_dbg("devops->len =%llx", devops->len);
+	BOOT_LINE
+	ret = write_uboot(phydev);
+	BOOT_LINE
+	if (ret < 0) {
+		aml_nand_dbg("nand write failed at %llx", devops->addr);
+		goto exit_error0;
+	}
+	if (oob_set) {
+		controller->oob_mod = oob_set;
+		NFC_SET_OOB_MODE(controller, 3<<26);
+	}
+	return ret;
+exit_error0:
+	return ret;
+}
+
+#ifndef AML_NAND_UBOOT
+static int uboot_open(struct inode * inode, struct file * filp)
+{
+	aml_nand_dbg("uboot_open");
+	return 0;
+}
+/*
+ * This funcion reads the u-boot envionment variables.
+ * The f_pos points directly to the env location.
+ */
+static ssize_t uboot_read(struct file *file,
+	char __user *buf,
+	size_t count,
+	loff_t *ppos)
+{
+	struct amlnand_phydev *phydev = uboot_phydev;
+	struct amlnand_chip *aml_chip = phydev->priv;
+	/* struct nand_flash *flash = &(aml_chip->flash); */
+	struct phydev_ops *devops = &(phydev->ops);
+	/* struct hw_controller *controller = &(aml_chip->controller); */
+	/* struct chip_operation *operation = &(aml_chip->operation); */
+	/* struct chip_ops_para *ops_para = &(aml_chip->ops_para); */
+
+	u8 *data_buf;
+	int  ret;
+	size_t align_count = 0;
+	/* data_buf = aml_nand_malloc(UBOOT_WRITE_SIZE); */
+	align_count =
+		((((u32)count + phydev->writesize)-1)/phydev->writesize)
+		*phydev->writesize;
+	data_buf = aml_nand_malloc(align_count);
+	if (!data_buf) {
+		aml_nand_dbg("malloc buf for rom_write failed");
+		goto err_exit0;
+	}
+	/* memset(data_buf,0x0,UBOOT_WRITE_SIZE); */
+	/* ret=copy_from_user(data_buf, buf, UBOOT_WRITE_SIZE); */
+	memset(data_buf, 0x0, align_count);
+
+
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = 0x0;
+	/* devops->len = UBOOT_WRITE_SIZE; */
+	devops->len = align_count;
+	devops->mode = NAND_HW_ECC;
+	devops->datbuf = data_buf;
+	amlnand_get_device(aml_chip, CHIP_WRITING);
+
+	ret = roomboot_nand_read(phydev);
+	if (ret < 0) {
+		aml_nand_dbg("uboot_write failed");
+		count = 0;
+	}
+	amlnand_release_device(aml_chip);
+	ret = copy_to_user(buf, data_buf, count);
+err_exit0:
+
+	aml_nand_free(data_buf);
+	data_buf = NULL;
+
+	return count;
+}
+
+static ssize_t uboot_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	struct amlnand_phydev *phydev = uboot_phydev;
+	struct amlnand_chip *aml_chip = phydev->priv;
+	/* struct nand_flash *flash = &(aml_chip->flash); */
+	struct phydev_ops *devops = &(phydev->ops);
+	/* struct hw_controller *controller = &(aml_chip->controller); */
+	/* struct chip_operation *operation = &(aml_chip->operation); */
+	/* struct chip_ops_para *ops_para = &(aml_chip->ops_para); */
+
+	u8 *data_buf;
+	int  ret;
+	size_t align_count = 0;
+	/* data_buf = aml_nand_malloc(UBOOT_WRITE_SIZE); */
+	align_count =
+		((((u32)count + phydev->writesize)-1)/phydev->writesize)
+		*phydev->writesize;
+	data_buf = aml_nand_malloc(align_count);
+	if (!data_buf) {
+		aml_nand_dbg("malloc buf for rom_write failed");
+		goto err_exit0;
+	}
+	/* memset(data_buf,0x0,UBOOT_WRITE_SIZE); */
+	/* ret=copy_from_user(data_buf, buf, UBOOT_WRITE_SIZE); */
+	memset(data_buf, 0x0, align_count);
+	ret = copy_from_user(data_buf, buf, count);
+
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = 0x0;
+	/* devops->len = UBOOT_WRITE_SIZE; */
+	devops->len = align_count;
+	devops->mode = NAND_HW_ECC;
+	devops->datbuf = data_buf;
+	amlnand_get_device(aml_chip, CHIP_WRITING);
+
+	ret = roomboot_nand_write(phydev);
+	if (ret < 0) {
+		aml_nand_dbg("uboot_write failed");
+		count = 0;
+	}
+	amlnand_release_device(aml_chip);
+
+err_exit0:
+
+	if (data_buf) {
+		aml_nand_free(data_buf);
+		data_buf = NULL;
+	}
+
+	return count;
+}
+
+static int uboot_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int uboot_suspend(struct device *dev, pm_message_t state)
+{
+		return 0;
+}
+
+static int uboot_resume(struct device *dev)
+{
+	return 0;
+}
+
+
+static struct class uboot_class = {
+
+	.name = "bootloader",
+	.owner = THIS_MODULE,
+	.suspend = uboot_suspend,
+	.resume = uboot_resume,
+};
+
+static const struct file_operations uboot_fops = {
+	.owner = THIS_MODULE,
+	.open = uboot_open,
+	.read = uboot_read,
+	.write = uboot_write,
+	.release = uboot_close,
+};
+
+int boot_device_register(struct amlnand_phydev *phydev)
+{
+	int ret = 0;
+
+	if (!strncmp((char *)phydev->name,
+		NAND_BOOT_NAME,
+		strlen((const char *)NAND_BOOT_NAME))) {
+
+		aml_nand_dbg("boot device register");
+
+		uboot_phydev = phydev;
+		ret = alloc_chrdev_region(&uboot_devno, 0, 1, "bootloader");
+		if (ret < 0) {
+			aml_nand_dbg("uboot_phydev:failed to allocate chrdev.");
+			goto exit_error0;
+		}
+		cdev_init(&uboot_phydev->uboot_cdev, &uboot_fops);
+		uboot_phydev->uboot_cdev.owner = THIS_MODULE;
+		ret = cdev_add(&uboot_phydev->uboot_cdev, uboot_devno, 1);
+		if (ret) {
+			aml_nand_dbg("uboot_phydev: failed to add device.");
+			goto exit_error0;
+		}
+
+		ret = class_register(&uboot_class);
+		if (ret < 0) {
+			aml_nand_dbg("class_register(&uboot_class) failed!\n");
+			goto exit_error0;
+		}
+
+		devp = device_create(&uboot_class,
+				NULL,
+				uboot_devno,
+				NULL,
+				"bootloader");
+		if (IS_ERR(devp)) {
+			aml_nand_dbg("uboot_phydev:fail to create node\n");
+			ret = PTR_ERR(devp);
+			goto exit_error0;
+		}
+	}
+	return NAND_SUCCESS;
+exit_error0:
+	return ret;
+}
+#endif /* AML_NAND_UBOOT */
diff --git a/drivers/nand/phy/chip.c b/drivers/nand/phy/chip.c
new file mode 100644
index 0000000..88e520a
--- /dev/null
+++ b/drivers/nand/phy/chip.c
@@ -0,0 +1,699 @@
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : chip.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**		chip init/bbt/config/scan function,  mainly for nand phy driver.
+**
+**
+*****************************************************************/
+#include "../include/phynand.h"
+
+static int get_flash_type(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	u8 dev_id[MAX_ID_LEN] = {0};
+	struct nand_flash *type = NULL;
+	int ret = 0, i, extid;
+
+	ret = operation->read_id(aml_chip,
+		0,
+		NAND_CMD_ID_ADDR_NORMAL,
+		&dev_id[0]);
+	if (ret < 0) {
+		aml_nand_dbg("read id failed and ret:0x%x", ret);
+		goto error_exit;
+	}
+
+	aml_nand_msg("NAND device id: %x %x %x %x %x %x %x %x",
+			dev_id[0],
+			dev_id[1],
+			dev_id[2],
+			dev_id[3],
+			dev_id[4],
+			dev_id[5],
+			dev_id[6],
+			dev_id[7]);
+
+#ifdef AML_SLC_NAND_SUPPORT
+	/* Lookup the slc flash id */
+	for (i = 0; flash_ids_slc[i].name != NULL; i++) {
+		if (dev_id[1] == flash_ids_slc[i].id[1]) {
+			type = &flash_ids_slc[i];
+			break;
+		}
+	}
+#endif
+	if (type) {
+		aml_nand_msg("detect slc nand here");
+		controller->flash_type = NAND_TYPE_SLC;
+	} else {
+#ifdef AML_MLC_NAND_SUPPORT
+		/* Lookup the mlc flash id */
+		for (i = 0; flash_ids_mlc[i].name != NULL; i++) {
+			if (!strncmp((char *)flash_ids_mlc[i].id,
+				(char *)dev_id,
+				strlen((const char *)flash_ids_mlc[i].id))) {
+				type = &flash_ids_mlc[i];
+				break;
+			}
+		}
+#endif
+		if (!type) {
+			aml_nand_msg("no matched id");
+			ret = -NAND_ID_FAILURE;
+			goto error_exit;
+		}
+		controller->flash_type = NAND_TYPE_MLC;
+	}
+
+	memcpy(&(aml_chip->flash), type, sizeof(struct nand_flash));
+	controller->mfr_type = type->id[0];
+
+	aml_nand_dbg("check type->T_REA:%d, type->T_RHOH:%d, flash:%d %d",
+		type->T_REA,
+		type->T_RHOH,
+		aml_chip->flash.T_REA,
+		aml_chip->flash.T_RHOH);
+
+	aml_nand_msg("detect NAND device: %s", type->name);
+
+#ifdef AML_SLC_NAND_SUPPORT
+	type = &aml_chip->flash;
+
+	/* Newer devices have all the information in additional id bytes */
+	if (!type->pagesize) {
+		/* The 3rd id byte holds MLC / multichip data */
+		controller->readbyte(controller);
+		/* The 4th id byte is the important one */
+		extid = controller->readbyte(controller);
+		/* Calc pagesize */
+		type->pagesize = 1024 << (extid & 0x3);
+		extid >>= 2;
+		/* Calc oobsize */
+		type->oobsize = (8 << (extid & 0x01)) * (type->pagesize>>9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		type->blocksize = (64 * 1024) << (extid & 0x03);
+		extid >>= 2;
+		/* Get buswidth information */
+		aml_nand_msg("detect nand buswidth:%s",
+				(extid & 0x02) ? "16bit" : "8bit");
+		if (extid & 0x02) {
+			aml_nand_msg("do not support 16bit buswidth yet");
+			ret = -NAND_ID_FAILURE;
+			goto error_exit;
+		}
+	}
+#endif
+
+#ifdef AML_MLC_NAND_SUPPORT
+	/* read onfi id */
+	ret = operation->read_id(aml_chip,
+		0,
+		NAND_CMD_ID_ADDR_ONFI,
+		&dev_id[0]);
+	if (ret < 0) {
+		aml_nand_msg("read id failed and ret:0x%x", ret);
+		goto error_exit;
+	}
+
+	controller->page_shift =  ffs(aml_chip->flash.pagesize) - 1;
+	controller->block_shift =  ffs(aml_chip->flash.blocksize) - 1;
+	controller->internal_page_nums =
+		((aml_chip->flash.chipsize<<(20 - controller->page_shift)) /
+		aml_chip->flash.internal_chipnr);
+	aml_nand_dbg("internal_page_nums =%d,internal_chipnr=%d",
+			controller->internal_page_nums,
+			aml_chip->flash.internal_chipnr);
+	if (!memcmp((char *)dev_id, "ONFI", 4))
+		controller->onfi_mode = type->onfi_mode;
+#endif
+error_exit:
+	return ret;
+}
+
+
+/*
+  * fill amlnand_chip struct.
+  * including chip partnum detect and multi-chip num detect function.
+  *
+  */
+static int amlnand_chip_scan(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	u8 dev_id[MAX_ID_LEN] = {0};
+	u8 onfi_features[4] = {0};
+	int i, chip_num, ret = 0;
+	NAND_LINE
+	/* should setting nand pinmux first */
+	nand_get_chip(aml_chip);
+	NAND_LINE
+	ret = get_flash_type(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("get_chip_type and ret:%x", ret);
+		goto error_exit0;
+	}
+
+	controller->chip_num = MAX_CHIP_NUM;/* 1; */
+	controller->option |= NAND_CTRL_NONE_RB;
+	chip_num = 1;
+	NAND_LINE
+	/*ce0 is always valid.*/
+	aml_chip->ce_bit_mask |= 0x01;
+
+	/* Check for a chip array */
+	for (i = 1; i < MAX_CHIP_NUM; i++) {
+		memset(&dev_id[0], 0, MAX_ID_LEN);
+		ret = operation->read_id(aml_chip,
+			i,
+			NAND_CMD_ID_ADDR_NORMAL,
+			&dev_id[0]);
+		if (ret < 0) {
+			aml_nand_dbg("read id failed and ret:%d", ret);
+			continue;
+		}
+		/*
+		memcmp((char*)&(aml_chip->flash.id[0]),
+			(char*)&dev_id[0], MAX_ID_LEN)
+		*/
+		aml_nand_dbg("controller->flash_type =%d",
+			controller->flash_type);
+		if (((controller->flash_type == NAND_TYPE_SLC)
+			|| (controller->flash_type == NAND_TYPE_MLC))
+&& (aml_chip->flash.id[1] == dev_id[1])) {
+			controller->ce_enable[chip_num] =
+				(((CE_PAD_DEFAULT >> i*4) & 0xf) << 10);
+			controller->rb_enable[chip_num] =
+				(((RB_PAD_DEFAULT >> i*4) & 0xf) << 10);
+			chip_num++;
+			aml_chip->ce_bit_mask |= (1 << i);
+		}
+	}
+	/* aml_nand_msg("nand chip ce mask %0x", aml_chip->ce_bit_mask); */
+
+	controller->chip_num = chip_num;
+
+	if (controller->chip_num > 1) {
+		if (controller->chip_num == MAX_CHIP_NUM) {
+			aml_chip->flash.option &= ~(NAND_MULTI_PLANE_MODE);
+			aml_nand_msg("detect %d NF chips,disable twoplane mode",
+				controller->chip_num);
+		} else
+			aml_nand_msg("detected %d NAND chips",
+				controller->chip_num);
+	}
+
+	if (controller->onfi_mode) {
+		operation->set_onfi_para(aml_chip,
+			(u8 *)&(controller->onfi_mode),
+			ONFI_TIMING_ADDR);
+		operation->get_onfi_para(aml_chip,
+			onfi_features,
+			ONFI_TIMING_ADDR);
+		if (onfi_features[0] != controller->onfi_mode) {
+			aml_chip->flash.T_REA = DEFAULT_T_REA;
+			aml_chip->flash.T_RHOH = DEFAULT_T_RHOH;
+			aml_nand_msg("onfi timing mode set failed: %x",
+				onfi_features[0]);
+		}
+	}
+
+	ret = NAND_SUCCESS;
+error_exit0:
+	NAND_LINE
+	/* should clear nand pinmux here */
+	nand_release_chip(aml_chip);
+	NAND_LINE
+	return ret;
+}
+
+/*
+  * fill aml_nand_buf_init struct.
+  * malloc tmp buf and dma buf here.
+  *
+*/
+static int nand_buf_init(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &aml_chip->flash;
+	u32 buf_size;
+	int err = 0;
+
+	controller->ecc_unit = NAND_ECC_UNIT_SIZE;
+	//fixme, check controller init operations...
+#ifndef AML_NAND_UBOOT
+		controller->data_buf = dma_alloc_coherent(NULL,
+			(flash->pagesize + flash->oobsize),
+			&controller->data_dma_addr, GFP_KERNEL);
+#else /* AML_NAND_UBOOT */
+		controller->data_buf = aml_nand_malloc(flash->pagesize + flash->oobsize);
+#endif /* AML_NAND_UBOOT */
+	if (!controller->data_buf) {
+		aml_nand_msg("no memory for data buf, and need %x", (flash->pagesize + flash->oobsize));
+		err = -NAND_MALLOC_FAILURE;
+		goto exit_error0;
+	}
+
+
+	buf_size = (flash->pagesize /controller->ecc_unit)*PER_INFO_BYTE;
+	buf_size += 16;
+#ifndef AML_NAND_UBOOT
+		controller->user_buf = dma_alloc_coherent(NULL,
+			buf_size,
+			&(controller->info_dma_addr),
+			GFP_KERNEL);/* amlnf_dma_malloc(buf_size, 1); */
+#else /* AML_NAND_UBOOT */
+		controller->user_buf = aml_nand_malloc(buf_size);
+#endif /* AML_NAND_UBOOT */
+	if (!controller->user_buf) {
+		aml_nand_msg("no memory for usr info buf, and need %x", buf_size);
+		err = -NAND_MALLOC_FAILURE;
+		goto exit_error1;
+	}
+
+	buf_size = (flash->pagesize + flash->oobsize) * controller->chip_num;
+	if (flash->option & NAND_MULTI_PLANE_MODE)
+		buf_size <<= 1;
+
+		controller->page_buf = aml_nand_malloc(buf_size);
+	if (!controller->page_buf) {
+		aml_nand_msg("no memory for data buf, and need %x", buf_size);
+		err = -NAND_MALLOC_FAILURE;
+		goto exit_error2;
+	}
+
+	buf_size = flash->oobsize * controller->chip_num;
+	if (flash->option & NAND_MULTI_PLANE_MODE)
+		buf_size <<= 1;
+
+		controller->oob_buf = aml_nand_malloc(buf_size);
+	if (!controller->oob_buf) {
+		aml_nand_msg("no memory for data buf, and need %x", buf_size);
+		err = -NAND_MALLOC_FAILURE;
+		goto exit_error3;
+	}
+
+	/*
+	if (request_irq(INT_NAND,
+		(irq_handler_t)nand_interrupt_monitor,
+		0,
+		"anl_nand",
+		aml_chip)) {
+		printk("request SDIO irq error!!!\n");
+		return -1;
+	}
+	*/
+	return NAND_SUCCESS;
+exit_error3:
+	aml_nand_free(controller->page_buf);
+exit_error2:
+#ifndef AML_NAND_UBOOT
+	amlnf_dma_free(controller->user_buf,
+		(flash->pagesize / controller->ecc_bytes)*sizeof(int),
+		1);
+#else /* AML_NAND_UBOOT */
+	aml_nand_free(controller->user_buf);
+#endif /* AML_NAND_UBOOT */
+exit_error1:
+#ifndef AML_NAND_UBOOT
+	amlnf_dma_free(controller->data_buf,
+		(flash->pagesize + flash->oobsize),
+		0);
+#else /* AML_NAND_UBOOT */
+		aml_nand_free(controller->data_buf);
+#endif /* AML_NAND_UBOOT */
+
+exit_error0:
+	return err;
+}
+
+/*
+ * fill free malloc buf here.
+ *
+ *
+*/
+static void nand_buf_free(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+#ifndef AML_NAND_UBOOT
+	struct nand_flash *flash = &aml_chip->flash;
+
+	amlnf_dma_free(controller->data_buf,
+		(flash->pagesize + flash->oobsize),
+		0);
+	amlnf_dma_free(controller->user_buf,
+		(flash->pagesize / controller->ecc_bytes)*sizeof(int),
+		1);
+#else /* AML_NAND_UBOOT */
+	  aml_nand_free(controller->data_buf);
+	  aml_nand_free(controller->user_buf);
+#endif /* AML_NAND_UBOOT */
+	controller->data_buf = NULL;
+	controller->user_buf = NULL;
+
+	aml_nand_free(controller->page_buf);
+	aml_nand_free(controller->oob_buf);
+	controller->page_buf = NULL;
+	controller->oob_buf = NULL;
+}
+
+/*
+  * check rb pin here.
+  * if without rb pin, then setting NAND_CTRL_NONE_RB mode
+  *
+*/
+static void aml_chip_rb_mode_confirm(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	u32 por_cfg = 0, rb_mode = 0;
+	void __iomem *poc_reg = NULL;
+
+	poc_reg = (void __iomem *)aml_nand_dev->platform_data->poc_reg;
+
+	if (controller->chip_num > 2) {
+		aml_nand_msg("force NO RB pin and chip_num:%d over 2",
+			controller->chip_num);
+		rb_mode = 1;
+	} else {
+		por_cfg = amlnf_read_reg32(poc_reg);
+
+		aml_nand_msg("detect RB pin here and por_cfg:%x", por_cfg);
+		if (por_cfg&POC_NAND_NO_RB) {
+			aml_nand_msg("detect without RB pin here");
+			rb_mode = 1;
+		} else {
+			aml_nand_msg("detect with RB pin here");
+			controller->option &= ~NAND_CTRL_NONE_RB;
+		}
+	}
+
+#ifdef AML_NAND_RB_IRQ
+	rb_mode = 1;
+	aml_nand_msg("force none rb mode for rb irq");
+#endif
+
+	if (rb_mode) {
+		controller->rb_enable[0] = 0;
+		controller->option |= NAND_CTRL_NONE_RB;
+	}
+}
+
+void amlchip_dumpinfo(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+
+	/* flash info */
+	aml_nand_msg("flash  info");
+	aml_nand_msg("name:%s, id:%2x %2x %2x %2x %2x %2x %2x %2x",
+		flash->name,
+		flash->id[0],
+		flash->id[1],
+		flash->id[2],
+		flash->id[3],
+		flash->id[4],
+		flash->id[5],
+		flash->id[6],
+		flash->id[7]);
+	aml_nand_msg("pgs:%x,blks:%x,oobs:%d,chips:%d,opt:0x%x,T_R:%d,T_RH:%d",
+		flash->pagesize,
+		flash->blocksize,
+		flash->oobsize,
+		flash->chipsize,
+		flash->option,
+		flash->T_REA,
+		flash->T_RHOH);
+	aml_nand_msg("hw controller info\n");
+	aml_nand_msg("chipn:%d,onfi:%d,pg_shift:%d,blk_shift:%d,option:0x%x",
+		controller->chip_num,
+		controller->onfi_mode,
+		controller->page_shift,
+		controller->block_shift,
+		controller->option);
+	aml_nand_msg("ecc_unit:%d, ecc_bytes:%d, ecc_steps:%d, ecc_max:%d",
+		controller->ecc_unit,
+		controller->ecc_bytes,
+		controller->ecc_steps,
+		controller->ecc_max);
+	aml_nand_msg("bch_mode:%d, user_mode:%d, oobavail:%d, oobtail:%d",
+		controller->bch_mode,
+		controller->user_mode,
+		controller->oobavail,
+		controller->oobtail);
+}
+
+int amlchip_opstest(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr, opslen = 0, len = 0;
+	u32 erase_shift, write_shift, writesize, erasesize;
+	int i, ret = 0;
+
+	/* should setting nand pinmux first */
+	nand_get_chip(aml_chip);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+
+	writesize = flash->pagesize;
+	erasesize = flash->blocksize;
+
+	/* ops_para->option = (DEV_ECC_HW_MODE |DEV_SERIAL_CHIP_MODE ); */
+	ops_para->option = (DEV_ECC_HW_MODE |
+		NAND_MULTI_PLANE_MODE |
+		DEV_SERIAL_CHIP_MODE);
+	ops_para->data_buf = controller->page_buf;
+	/* ops_para->oob_buf = controller->oobbuf; */
+
+	if (ops_para->option & DEV_MULTI_PLANE_MODE) {
+		writesize *= 2;
+		erasesize *= 2;
+	}
+
+	if (ops_para->option & DEV_MULTI_CHIP_MODE) {
+		writesize *= controller->chip_num;
+		erasesize *= controller->chip_num;
+	}
+
+	erase_shift  = ffs(erasesize) - 1;
+	write_shift  = ffs(writesize) - 1;
+
+#if 0
+	/* read */
+	/* start addr 0, read whole chip size */
+	opslen = addr = 0;
+	len = ((u64)(flash->chipsize*controller->chip_num))<<20;
+	aml_nand_dbg("TEST step1 read whole chip,len:%llx, total_page:%d",
+		len,
+		len>>write_shift);
+
+	while (1) {
+		memset(ops_para->data_buf, 0, writesize);
+		if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+			ops_para->chipnr =
+				(addr>>erase_shift)%controller->chip_num;
+		}
+
+		ops_para->page_addr =
+			(int)(addr >> write_shift)/controller->chip_num;
+		ret = operation->read_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("fail page_addr:%d", ops_para->page_addr);
+			break;
+		}
+		aml_nand_dbg("page:%d data: %x %x %x %x", ops_para->page_addr,
+			ops_para->data_buf[0],
+			ops_para->data_buf[1],
+			ops_para->data_buf[2],
+			ops_para->data_buf[3]);
+
+		addr += writesize;
+		opslen += writesize;
+		if (opslen >= len)
+			break;
+
+		if (ops_para->ecc_err)
+			aml_nand_msg("ecc failed at page_addr:%d",
+				ops_para->page_addr);
+		else if (ops_para->bit_flip)
+			aml_nand_msg("bit_flip at page_addr:%d",
+				ops_para->page_addr);
+	}
+#endif
+/* BUG(); */
+#if 1
+	/* erase */
+	/* start addr 0, read whole chip size */
+	aml_nand_dbg("TEST step2 erase whole chip");
+	opslen = addr = 0;
+	/* len = ((u64)(flash->chipsize*controller->chip_num))<<20; */
+	len = 1<<erase_shift;
+	aml_nand_dbg("TEST step2 erase whole chip, len:%llx, total_page:%d",
+		len,
+		len>>write_shift);
+	while (1) {
+		if (ops_para->option & DEV_SERIAL_CHIP_MODE)
+			ops_para->chipnr =
+				(addr>>erase_shift)%controller->chip_num;
+
+		ops_para->page_addr =
+			(int)(addr >> write_shift)/controller->chip_num;
+		ret = operation->erase_block(aml_chip);
+		if (ret < 0)
+			aml_nand_msg("fail page_addr:%d", ops_para->page_addr);
+			break;
+
+		addr += erasesize;
+		opslen += erasesize;
+		if (opslen >= len)
+			break;
+	}
+#endif
+	/* BUG(); */
+	/* write */
+	opslen = addr = 0;
+	/* len = ((u64)(flash->chipsize*controller->chip_num))<<20; */
+	aml_nand_dbg("TEST step3 write whole chip, len:%llx, total_page:%d",
+				len, len>>write_shift);
+	for (i = 0; i < writesize; i++)
+		ops_para->data_buf[i] = i;
+
+	while (1) {
+		if (ops_para->option & DEV_SERIAL_CHIP_MODE)
+			ops_para->chipnr =
+				(addr>>erase_shift)%controller->chip_num;
+
+		ops_para->page_addr =
+			(int)(addr >> write_shift)/controller->chip_num;
+		ret = operation->write_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("fail page_addr:%d", ops_para->page_addr);
+			break;
+		}
+
+		addr += writesize;
+		/* ops_para->data_buf += writesize; */
+		opslen += writesize;
+		if (opslen >= len)
+			break;
+	}
+
+	/* read */
+	/* start addr 0, read whole chip size */
+	opslen = addr = 0;
+	/* len = ((u64)(flash->chipsize*controller->chip_num))<<20; */
+	aml_nand_dbg("TEST step4 read whole chip, len:%llx, total_page:%d",
+		len,
+		len>>write_shift);
+	while (1) {
+		memset(ops_para->data_buf, 0, writesize);
+		if (ops_para->option & DEV_SERIAL_CHIP_MODE)
+			ops_para->chipnr =
+				(addr>>erase_shift)%controller->chip_num;
+
+		ops_para->page_addr =
+			(int)(addr >> write_shift)/controller->chip_num;
+		ret = operation->read_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("fail page_addr:%d", ops_para->page_addr);
+			break;
+		}
+		aml_nand_dbg("page:%d data: %x %x %x %x",
+			ops_para->page_addr,
+			ops_para->data_buf[0],
+			ops_para->data_buf[1],
+			ops_para->data_buf[2],
+			ops_para->data_buf[3]);
+		addr += writesize;
+		/* ops_para->data_buf += writesize; */
+		opslen += writesize;
+		if (opslen >= len)
+			break;
+
+		if (ops_para->ecc_err)
+			aml_nand_msg("ecc failed at page_addr:%d",
+				ops_para->page_addr);
+		else if (ops_para->bit_flip)
+			aml_nand_msg("bit_flip at page_addr:%d",
+				ops_para->page_addr);
+	}
+
+	/* should clear nand pinmux here */
+	nand_release_chip(aml_chip);
+	return 0;
+}
+
+/*
+  * fill amlnand_chip struct.
+  * including hw init, chip detect, option setting and operation function.
+  *
+  */
+u32 amlnand_chip_init(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	/* struct chip_operation *operation = &aml_chip->operation; */
+	int ret = 0;
+	NAND_LINE
+	ret = amlnand_chip_scan(aml_chip);
+	if (ret) {
+		aml_nand_msg("get_chip_type and ret:%x", ret);
+		goto error_exit0;
+	}
+	NAND_LINE
+
+#ifdef AML_NAND_UBOOT
+	// /*only check nand circult is ok*/
+	if (aml_chip->init_flag == NAND_SCAN_ID_INIT)
+		goto error_exit0;
+#endif /* AML_NAND_UBOOT */
+
+	/* amlchip_dumpinfo(aml_chip); */
+
+	ret = nand_buf_init(aml_chip);
+	if (ret) {
+		aml_nand_msg("buf init failed and ret:%x", ret);
+		goto error_exit0;
+	}
+	NAND_LINE
+	ret = controller->adjust_timing(controller);
+	if (ret) {
+		aml_nand_msg("adjust_timing failed and ret:%x", ret);
+		goto error_exit1;
+	}
+	NAND_LINE
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_M8)
+		aml_chip_rb_mode_confirm(aml_chip);
+
+	NAND_LINE
+	ret = controller->ecc_confirm(controller);
+	if (ret) {
+		aml_nand_msg("buf init failed and ret:%x", ret);
+		goto error_exit1;
+	}
+	NAND_LINE
+#if (AML_NAND_DBG)
+	amlchip_dumpinfo(aml_chip);
+#endif
+
+/* basic operation test here, read/write/erase */
+#if 0
+	amlchip_opstest(aml_chip);
+#endif
+
+	return NAND_SUCCESS;
+error_exit1:
+	nand_buf_free(aml_chip);
+error_exit0:
+	return ret;
+
+}
+
diff --git a/drivers/nand/phy/chip_operation.c b/drivers/nand/phy/chip_operation.c
new file mode 100644
index 0000000..58a1733
--- /dev/null
+++ b/drivers/nand/phy/chip_operation.c
@@ -0,0 +1,2518 @@
+
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : chip_operation.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**chip operation function,  contains read/write/erase, and bad block function.
+**mainly init nand phy driver.
+**
+*****************************************************************/
+#include "../include/phynand.h"
+
+static int _read_page_single_plane(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u32 page_addr);
+
+static int check_cmdfifo_size(struct hw_controller *controller)
+{
+	int time_out_cnt = 0, retry_cnt = 0;
+
+RETRY:
+	do {
+		if (NFC_CMDFIFO_SIZE(controller) <= 0)
+			break;
+	} while (time_out_cnt++ <= AML_DMA_BUSY_TIMEOUT);
+
+	if (time_out_cnt >= AML_DMA_BUSY_TIMEOUT) {
+		if (retry_cnt++ > 3) {
+			aml_nand_msg("check cmdfifo size timeout!");
+			return -NAND_FAILED;
+		} else {
+			aml_nand_dbg("check cmdfifo size timeout retry_cnt:%d",
+				retry_cnt);
+			udelay(10);
+			goto RETRY;
+		}
+	}
+	return NAND_SUCCESS;
+}
+
+
+/************************************************************
+ * nand_check_wp - [GENERIC] check if the chip is write protected
+ * Check, if the chip is write protected.
+ * First of all, check controller->option, then  read status, check nand status
+ *
+ *************************************************************/
+static int check_wp(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	int i, time_out_cnt = 0;
+
+	/* force WP for readonly add for shutdown protect */
+	if (controller->option & NAND_CTRL_FORCE_WP) {
+		aml_nand_msg("check force WP here");
+		return -NAND_WP_FAILURE;
+	}
+
+	/* Check the WP bit */
+	for (i = 0; i < controller->chip_num; i++) {
+		controller->select_chip(controller, i);
+		/* read status */
+		controller->cmd_ctrl(controller, NAND_CMD_STATUS,
+			NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+		NFC_SEND_CMD_IDLE(controller, 0);
+		NFC_SEND_CMD_IDLE(controller, 0);
+		do {
+			if (NFC_CMDFIFO_SIZE(controller) <= 0)
+				break;
+			udelay(2);
+		} while (time_out_cnt++ <= AML_NAND_READ_BUSY_TIMEOUT);
+
+		if (time_out_cnt >= AML_NAND_READ_BUSY_TIMEOUT) {
+			aml_nand_msg("cmd fifo size failed to clear!");
+			aml_nand_msg("NFC_CMDFIFO_SIZE():%d" ,
+				NFC_CMDFIFO_SIZE(controller));
+			return -NAND_CMD_FAILURE;
+		}
+
+		if (controller->readbyte(controller) & NAND_STATUS_WP)
+			return -NAND_WP_FAILURE;
+	}
+
+	return 0;
+}
+
+static int ecc_read_retry_handle(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u8 *tmp_buf,
+	u8 user_byte_num,
+	u32 page_size,
+	u8 slc_mode,
+	u8 up_page)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	u8 need_retry;
+	u8 *retry_cnt;
+	int retry_op_cnt, retry_cnt_lp, retry_cnt_up, ret;
+
+	retry_op_cnt = retry_cnt_lp = retry_info->retry_cnt_lp;
+	retry_cnt_up = retry_info->retry_cnt_up;
+	retry_cnt = &aml_chip->g_retry_cnt;
+
+	if ((flash->new_type == HYNIX_20NM_8GB)
+		|| (flash->new_type == HYNIX_20NM_4GB)
+		|| (flash->new_type == HYNIX_1YNM))
+		retry_op_cnt = retry_info->retry_cnt_lp *
+			retry_info->retry_cnt_lp;
+
+	/* get usr bytes */
+	controller->get_usr_byte(controller, tmp_buf, user_byte_num);
+	ret = controller->hwecc_correct(controller, page_size, tmp_buf);
+	if (ret ==  NAND_ECC_FAILURE) {
+		/* check rand_mode and 0xff page */
+		if (controller->zero_cnt < controller->ecc_max)
+			return RETURN_PAGE_ALL_0XFF;
+		/* ecc fail */
+		need_retry = 0;
+		if (retry_info->flag && (slc_mode == 0)) {
+			if ((flash->new_type != SANDISK_19NM)
+				&& ((*retry_cnt)++ < retry_op_cnt)) {
+				need_retry = 1;
+			} else if (flash->new_type == SANDISK_19NM) {
+				if (up_page) {
+					if ((*retry_cnt)++ < retry_cnt_up)
+						need_retry = 1;
+				} else if ((*retry_cnt)++ < retry_cnt_lp)
+					need_retry = 1;
+			}
+			if (need_retry) {
+				aml_nand_dbg("read retry");
+				aml_nand_dbg("chip:%d cnt:%d",
+					chipnr,
+					*retry_cnt);
+				ret = retry_info->handle(controller, chipnr);
+				if (ret < 0) {
+					aml_nand_msg("read retry");
+					aml_nand_msg("fail at plane0_page");
+				}
+				/* next round */
+				return RETURN_PAGE_NEED_READRETRY;
+			}
+		}
+		ret = -1;
+	} else {
+	if ((*retry_cnt)) {
+		if (flash->new_type != SANDISK_19NM) {
+			if ((*retry_cnt) > (retry_op_cnt-2)) {
+				aml_nand_dbg("detect bitflip page:%d",
+					page_addr);
+				ops_para->bit_flip++;
+			}
+		} else {
+			if (up_page) {
+				if ((*retry_cnt) > (retry_cnt_up-2)) {
+					aml_nand_dbg("detect bitflip page:%d",
+						page_addr);
+					ops_para->bit_flip++;
+				}
+			} else {
+				if ((*retry_cnt) > (retry_cnt_lp-2)) {
+					aml_nand_dbg("detect bitflip page:%d",
+						page_addr);
+					ops_para->bit_flip++;
+				}
+			}
+		}
+	} else if ((controller->ecc_cnt_cur > controller->ecc_cnt_limit)
+		&& (flash->new_type == 0)) {
+		aml_nand_dbg("detect bitflip page:%d, chip:%d",
+			page_addr,
+			chipnr);
+		ops_para->bit_flip++;
+	}
+	ret = 0;
+	}
+	/*  exit after all retry effort */
+	if ((*retry_cnt) && retry_info->exit) {
+		ret |= retry_info->exit(controller, chipnr);
+		if (ret < 0) {
+			aml_nand_msg("retry exit failed");
+			aml_nand_msg("flash->new_type:%d, cnt:%d",
+				flash->new_type,
+				*retry_cnt);
+		}
+	}
+	/* zero retry... */
+	*retry_cnt = 0;
+	return ret;
+}
+
+#if (AML_CFG_2PLANE_READ_EN)
+static int read_page_two_plane(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u32 plane0_page_addr,
+	u32 plane1_page_addr)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u8 *buf = ops_para->data_buf;
+	u8 *tmp_buf = controller->oob_buf;
+	u32 pages_per_blk_shift;
+	u32 page_size, page_addr, tmp_page;
+	u32 page0_addr, page1_addr;
+	u8 plane0_retry_flag = 0, all_ff_flag = 0;
+	u8 bch_mode, user_byte_num, slc_mode, up_page = 0;
+	int ret = 0;
+	int new_oob = 0;
+	PHY_NAND_LINE
+	page0_addr = plane0_page_addr;
+	page1_addr = plane1_page_addr;
+	page_addr = ops_para->page_addr;
+	pages_per_blk_shift =
+		(controller->block_shift - controller->page_shift);
+
+	if ((controller->oob_mod) && (ops_para->oob_buf)
+		&& (!ops_para->data_buf))
+		new_oob = 1;
+	PHY_NAND_LINE
+	/* for ecc mode */
+	if ((ops_para->option & DEV_ECC_SOFT_MODE)
+		|| (controller->bch_mode == NAND_ECC_NONE)) {
+		bch_mode = NAND_ECC_NONE;
+		page_size = flash->pagesize + flash->oobsize;
+		user_byte_num = flash->oobsize;
+	} else {
+		bch_mode = controller->bch_mode;
+		user_byte_num = controller->ecc_steps * controller->user_mode;
+		page_size = controller->ecc_steps * controller->ecc_unit;
+	}
+
+	if (new_oob)
+		page_size = controller->ecc_unit;
+
+	if (ops_para->option & DEV_SLC_MODE) {
+		/* aml_nand_dbg("enable SLC mode"); */
+		if (flash->new_type == SANDISK_19NM)
+			slc_mode = 1;
+		else if ((flash->new_type > 0) && (flash->new_type < 10))
+			slc_mode = 2;
+		else
+			slc_mode = 0;
+	} else {
+		slc_mode = 0;
+		if (flash->new_type == SANDISK_19NM) {
+			tmp_page = page_addr % (1 << pages_per_blk_shift);
+			if (((tmp_page % 2 == 0)
+				&& (tmp_page != 0))
+				|| (tmp_page == ((1 << pages_per_blk_shift)-1)))
+				up_page = 1;
+			else
+				up_page = 0;
+		}
+	}
+	/* setting global retry_cnt to 0 */
+	aml_chip->g_retry_cnt = 0;
+	PHY_NAND_LINE
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb busy here");
+		goto error_exit0;
+	}
+	PHY_NAND_LINE
+RETRY_PLANE_CMD:
+	if ((controller->mfr_type == NAND_MFR_MICRON)
+		|| (controller->mfr_type == NAND_MFR_INTEL)) {
+		/* plane0 */
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page0_addr, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page0_addr>>8, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page0_addr>>16, NAND_CTRL_ALE);
+		PHY_NAND_LINE
+		controller->cmd_ctrl(controller, 0x32, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+		ret = controller->quene_rb(controller, chipnr);
+		if (ret)
+			aml_nand_msg("send 0x32 cmd Rb  failed\n");
+		PHY_NAND_LINE
+		/* plane1 */
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>8, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>16, NAND_CTRL_ALE);
+		/* read start */
+		controller->cmd_ctrl(controller, 0x30, NAND_CTRL_CLE);
+
+	} else {
+		PHY_NAND_LINE
+		/* plane0 */
+		controller->cmd_ctrl(controller, 0x60, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, page0_addr, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page0_addr>>8, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page0_addr>>16, NAND_CTRL_ALE);
+		/* plane1 */
+		controller->cmd_ctrl(controller, 0x60, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, page1_addr, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>8, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>16, NAND_CTRL_ALE);
+		/* read start */
+		controller->cmd_ctrl(controller, 0x30, NAND_CTRL_CLE);
+
+		/* NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE); */
+	}
+	PHY_NAND_LINE
+	/* wait twb here */
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	if (check_cmdfifo_size(controller)) {
+		aml_nand_msg("check cmdfifo size timeout");
+		BUG();
+	}
+	PHY_NAND_LINE
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb busy here");
+		goto error_exit0;
+	}
+	PHY_NAND_LINE
+	if (controller->option & NAND_CTRL_NONE_RB) {
+		controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	}
+	PHY_NAND_LINE
+	if ((controller->mfr_type == NAND_MFR_MICRON)
+		|| (controller->mfr_type == NAND_MFR_INTEL)) {
+		PHY_NAND_LINE
+		if (plane0_retry_flag == 0) {
+			PHY_NAND_LINE
+			controller->page_addr = page0_addr;
+			ret = controller->dma_read(controller,
+				page_size,
+				bch_mode);
+			if (ret) {
+				aml_nand_msg("quene dma busy here");
+				BUG();
+				goto error_exit0;
+			}
+			PHY_NAND_LINE
+			all_ff_flag = 0;
+			/* for ecc soft mode */
+			if (bch_mode != NAND_ECC_NONE) {
+				PHY_NAND_LINE
+				ret = ecc_read_retry_handle(aml_chip,
+					chipnr,
+					tmp_buf,
+					user_byte_num,
+					page_size,
+					slc_mode,
+					up_page);
+				if (ret == RETURN_PAGE_ALL_0XFF) {
+					PHY_NAND_LINE
+					all_ff_flag = 1;
+				} else if (ret == RETURN_PAGE_NEED_READRETRY) {
+					PHY_NAND_LINE
+					goto RETRY_PLANE_CMD;
+				} else if (ret < 0) {
+					aml_nand_msg("uncorrect ecc here!");
+					aml_nand_msg("at page:%d,pl0 chip:%d",
+						page_addr,
+						chipnr);
+					ops_para->ecc_err++;
+
+				}
+				plane0_retry_flag = 1;
+			}
+			if (ops_para->data_buf) {
+				if (all_ff_flag) {
+					memset(buf, 0xff, page_size);
+				} else {
+					memcpy(buf,
+						controller->data_buf,
+						page_size);
+				}
+				buf += page_size;
+			}
+			if (ops_para->oob_buf) {
+				if (all_ff_flag)
+					memset(tmp_buf, 0xff, user_byte_num);
+
+				tmp_buf += user_byte_num;
+			}
+			all_ff_flag = 0;
+		}
+		if (new_oob)
+			goto new_oob_mod;
+		controller->cmd_ctrl(controller, 0x06, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>8, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>16, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0xe0, NAND_CTRL_CLE);
+		PHY_NAND_LINE
+		NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+		PHY_NAND_LINE
+		controller->page_addr = page1_addr;
+		ret = controller->dma_read(controller, page_size, bch_mode);
+		if (ret) {
+			aml_nand_msg("dma error here");
+			BUG();
+			goto error_exit0;
+		}
+
+		if (bch_mode != NAND_ECC_NONE) {
+			PHY_NAND_LINE
+			ret = ecc_read_retry_handle(aml_chip,
+				chipnr,
+				tmp_buf,
+				user_byte_num,
+				page_size,
+				slc_mode,
+				up_page);
+			if (ret == RETURN_PAGE_ALL_0XFF) {
+				all_ff_flag = 1;
+			} else if (ret == RETURN_PAGE_NEED_READRETRY) {
+				goto RETRY_PLANE_CMD;
+			} else if (ret < 0) {
+				aml_nand_msg("uncorrect ecc here");
+				aml_nand_msg("at page:%d, pl1 chip:%d",
+					page_addr,
+					chipnr);
+				ops_para->ecc_err++;
+
+			}
+			plane0_retry_flag = 0;
+		}
+	} else { /* not micron intel below */
+		if (plane0_retry_flag == 0) {
+			PHY_NAND_LINE
+			controller->cmd_ctrl(controller, 0x00, NAND_CTRL_CLE);
+			controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, page0_addr,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, page0_addr>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, page0_addr>>16,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, 0x05, NAND_CTRL_CLE);
+			controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, 0xe0, NAND_CTRL_CLE);
+
+			NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+			PHY_NAND_LINE
+			controller->page_addr = page0_addr;
+			ret = controller->dma_read(controller,
+				page_size,
+				bch_mode);
+			PHY_NAND_LINE
+			if (ret) {
+				aml_nand_msg("dma error here");
+				BUG();
+				goto error_exit0;
+			}
+
+			if (bch_mode != NAND_ECC_NONE) {
+				ret = ecc_read_retry_handle(aml_chip,
+					chipnr,
+					tmp_buf,
+					user_byte_num,
+					page_size,
+					slc_mode,
+					up_page);
+				if (ret == RETURN_PAGE_ALL_0XFF) {
+					all_ff_flag = 1;
+				} else if (ret == RETURN_PAGE_NEED_READRETRY) {
+					goto RETRY_PLANE_CMD;
+				} else if (ret < 0) {
+					aml_nand_msg("NAND uncorrect ecc here");
+					aml_nand_msg("at page:%d, pl0 chip:%d",
+						page_addr,
+						chipnr);
+					ops_para->ecc_err++;
+
+				}
+				plane0_retry_flag = 1;
+			}
+			if (ops_para->data_buf) {
+				if (all_ff_flag)
+					memset(buf, 0xff, page_size);
+				else
+					memcpy(buf,
+						controller->data_buf,
+						page_size);
+				buf += page_size;
+			}
+			if (ops_para->oob_buf) {
+				if (all_ff_flag)
+					memset(tmp_buf, 0xff, user_byte_num);
+
+				tmp_buf += user_byte_num;
+			}
+			all_ff_flag = 0;
+		}
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>8, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, page1_addr>>16, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0x05, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0xe0, NAND_CTRL_CLE);
+		PHY_NAND_LINE
+		NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+		PHY_NAND_LINE
+		controller->page_addr = page1_addr;
+		ret = controller->dma_read(controller, page_size, bch_mode);
+		if (ret) {
+			aml_nand_msg("dma error here");
+			BUG();
+			goto error_exit0;
+		}
+		PHY_NAND_LINE
+		if (bch_mode != NAND_ECC_NONE) {
+			ret = ecc_read_retry_handle(aml_chip,
+				chipnr,
+				tmp_buf,
+				user_byte_num,
+				page_size,
+				slc_mode,
+				up_page);
+			if (ret == RETURN_PAGE_ALL_0XFF) {
+				all_ff_flag = 1;
+			} else if (ret == RETURN_PAGE_NEED_READRETRY) {
+				goto RETRY_PLANE_CMD;
+			} else if (ret < 0) {
+				aml_nand_msg("NAND uncorrect ecc here");
+				aml_nand_msg("at page:%d, pl1 chip:%d",
+					page_addr,
+					chipnr);
+				ops_para->ecc_err++;
+
+			}
+			plane0_retry_flag = 0;
+		}
+	}
+	if (ops_para->data_buf) {
+		if (all_ff_flag)
+			memset(buf, 0xff, page_size);
+		else
+			memcpy(buf, controller->data_buf, page_size);
+		buf += page_size; /* fixme, why buffer plus here? */
+	}
+
+	if (ops_para->oob_buf) {
+		if (all_ff_flag)
+			memset(tmp_buf, 0xff, user_byte_num);
+		tmp_buf += user_byte_num;
+	}
+	all_ff_flag = 0;
+
+	if (check_cmdfifo_size(controller)) {
+		aml_nand_msg("check cmdfifo size timeout");
+		BUG();
+	}
+	PHY_NAND_LINE
+new_oob_mod:
+	if (ops_para->oob_buf) {
+		memcpy(ops_para->oob_buf,
+			controller->oob_buf,
+			BYTES_OF_USER_PER_PAGE);
+		if (ops_para->ecc_err)
+			memset(ops_para->oob_buf, 0x22, BYTES_OF_USER_PER_PAGE);
+	}
+	PHY_NAND_LINE
+	return NAND_SUCCESS;
+error_exit0:
+	return ret;
+}
+/* AML_CFG_2PLANE_READ_EN */
+#else
+/* using 2 single plane read simulate 2plane */
+extern void _dump_mem_u8(uint8_t * buf, uint32_t len);
+static int read_page_two_plane(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u32 p0_addr,
+	u32 p1_addr)
+{
+	int ret = 0;
+	u32 page_size, user_byte_num, new_oob;
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+
+	/* pointer for restore */
+	u8* oob_buffer = controller->oob_buf;
+	u8* data_buffer = ops_para->data_buf;
+
+	new_oob = 0;
+
+	/* for ecc mode */
+	if ((ops_para->option & DEV_ECC_SOFT_MODE)
+		|| (controller->bch_mode == NAND_ECC_NONE)) {
+		page_size = flash->pagesize + flash->oobsize;
+		user_byte_num = flash->oobsize;
+	} else {
+		user_byte_num = controller->ecc_steps * controller->user_mode;
+		page_size = controller->ecc_steps * controller->ecc_unit;
+	}
+
+	if ((controller->oob_mod) && (ops_para->oob_buf)
+		&& (!ops_para->data_buf))
+		new_oob = 1;
+	//printf("p0, oob %p, data %p\n", controller->oob_buf, ops_para->data_buf);
+
+	ret = _read_page_single_plane(aml_chip, chipnr, p0_addr) ;
+	if (new_oob)
+		goto _out;
+	//_dump_mem_u8(ops_para->data_buf, 128);
+	/* move buffer ahead. */
+	//printf("p0-, oob %p, data %p\n", controller->oob_buf, ops_para->data_buf);
+
+	controller->oob_buf += user_byte_num; /* fixme, maybe not right!*/
+	if (ops_para->data_buf)
+	ops_para->data_buf += page_size;
+	//printf("p1, oob %p, data %p\n", controller->oob_buf, ops_para->data_buf);
+
+	ret |= _read_page_single_plane(aml_chip, chipnr, p1_addr) ;
+	//printf("p1-, oob %p, data %p\n", controller->oob_buf, ops_para->data_buf);
+	//_dump_mem_u8(ops_para->data_buf, 128);
+
+	/* restore buffer location */
+	controller->oob_buf = oob_buffer;
+	ops_para->data_buf = data_buffer;
+	//printf("p1=, oob %p, data %p\n", controller->oob_buf, ops_para->data_buf);
+_out:
+	/* fill oob buffer */
+	if (ops_para->oob_buf) {
+		memcpy(ops_para->oob_buf,
+			controller->oob_buf,
+			BYTES_OF_USER_PER_PAGE);
+		if (ops_para->ecc_err)
+			memset(ops_para->oob_buf, 0x22, BYTES_OF_USER_PER_PAGE);
+	}
+	return ret;
+}
+/* AML_CFG_2PLANE_READ_EN */
+#endif
+
+
+static int _read_page_single_plane(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u32 page_addr)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	u8 *buf = ops_para->data_buf;
+	u8 *tmp_buf = controller->oob_buf;
+	u32 pages_per_blk_shift;
+	u32 page_size, tmp_page;
+	u8 all_ff_flag = 0;
+	u8 bch_mode, user_byte_num, slc_mode, up_page = 0;
+	int ret = 0;
+	int new_oob = 0;
+
+	pages_per_blk_shift =
+		(controller->block_shift - controller->page_shift);
+
+	if (controller->oob_mod && (ops_para->oob_buf)
+		&& (!ops_para->data_buf))
+		new_oob = 1;
+	PHY_NAND_LINE
+	/* for ecc mode */
+	if ((ops_para->option & DEV_ECC_SOFT_MODE)
+		|| (controller->bch_mode == NAND_ECC_NONE)) {
+		bch_mode = NAND_ECC_NONE;
+		page_size = flash->pagesize + flash->oobsize;
+		user_byte_num = flash->oobsize;
+	} else {
+		bch_mode = controller->bch_mode;
+		user_byte_num = controller->ecc_steps * controller->user_mode;
+		page_size = controller->ecc_steps * controller->ecc_unit;
+	}
+
+	if (new_oob)
+		page_size = controller->ecc_unit;
+
+	if (ops_para->option & DEV_SLC_MODE) {
+		/* aml_nand_dbg("enable SLC mode"); */
+		if (flash->new_type == SANDISK_19NM)
+			slc_mode = 1;
+		else if ((flash->new_type > 0) && (flash->new_type < 10))
+			slc_mode = 2;
+		else
+			slc_mode = 0;
+	} else {
+		slc_mode = 0;
+		if (flash->new_type == SANDISK_19NM) {
+			tmp_page = page_addr % (1 << pages_per_blk_shift);
+			if (((tmp_page % 2 == 0)
+				&& (tmp_page != 0))
+				|| (tmp_page == ((1 << pages_per_blk_shift)-1)))
+				up_page = 1;
+			else
+				up_page = 0;
+		}
+	}
+	PHY_NAND_LINE
+	/* setting global retry_cnt to 0 */
+	aml_chip->g_retry_cnt = 0;
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb busy here");
+		goto error_exit0;
+	}
+
+	if (slc_mode == 1) {
+		ret = slc_info->enter(controller);
+		if (ret < 0)
+			aml_nand_msg("slc enter failed here");
+	}
+RETRY_CMD:
+	PHY_NAND_LINE
+	controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+	controller->cmd_ctrl(controller, 0x0, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, 0x0, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, page_addr, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, page_addr>>8, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, page_addr>>16, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, NAND_CMD_READSTART, NAND_CTRL_CLE);
+	/* NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE); */
+
+	/* wait twb here */
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	if (check_cmdfifo_size(controller)) {
+		aml_nand_msg("check cmdfifo size timeout");
+		BUG();
+	}
+	PHY_NAND_LINE
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb busy here");
+		goto error_exit0;
+	}
+	PHY_NAND_LINE
+	if (controller->option & NAND_CTRL_NONE_RB) {
+		controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	}
+	PHY_NAND_LINE
+	/* aml_nand_dbg("page_addr:%d", ops_para->page_addr); */
+	/* transfer random seed. */
+	controller->page_addr = page_addr;
+	ret = controller->dma_read(controller, page_size, bch_mode);
+	if (ret) {
+		aml_nand_msg("dma error here");
+		BUG();
+		goto error_exit0;
+	}
+	PHY_NAND_LINE
+	if (bch_mode != NAND_ECC_NONE) {
+		PHY_NAND_LINE
+		ret = ecc_read_retry_handle(aml_chip,
+			chipnr,
+			tmp_buf,
+			user_byte_num,
+			page_size,
+			slc_mode,
+			up_page);
+		if (ret == RETURN_PAGE_ALL_0XFF) {
+			PHY_NAND_LINE
+			all_ff_flag = 1;
+		} else if (ret == RETURN_PAGE_NEED_READRETRY) {
+			PHY_NAND_LINE
+			goto RETRY_CMD;
+		} else if (ret < 0) {
+			PHY_NAND_LINE
+			aml_nand_msg("uncorrect ecc here at page:%d, chip:%d",
+				page_addr,
+				chipnr);
+			ops_para->ecc_err++;
+
+		}
+	}
+	if (ops_para->data_buf) {
+		if (all_ff_flag)
+			memset(buf, 0xff, page_size);
+		else
+			memcpy(buf, controller->data_buf, page_size);
+		buf += page_size;
+	}
+	PHY_NAND_LINE
+	if (ops_para->oob_buf) {
+		if (all_ff_flag)
+			memset(tmp_buf, 0xff, user_byte_num);
+		tmp_buf += user_byte_num;
+	}
+	all_ff_flag = 0;
+
+	if (check_cmdfifo_size(controller)) {
+		aml_nand_msg("check cmdfifo size timeout");
+		BUG();
+	}
+#if 0 /*move this outsides */
+	if (ops_para->oob_buf) {
+		memcpy(ops_para->oob_buf,
+			controller->oob_buf,
+			BYTES_OF_USER_PER_PAGE);
+		if (ops_para->ecc_err)
+			memset(ops_para->oob_buf, 0x22, BYTES_OF_USER_PER_PAGE);
+	}
+#endif //
+	return NAND_SUCCESS;
+error_exit0:
+	return ret;
+}
+
+
+static int read_page_single_plane(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u32 page_addr)
+{
+	int ret;
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+
+	ret = _read_page_single_plane( aml_chip, chipnr, page_addr);
+
+	if (ops_para->oob_buf) {
+		memcpy(ops_para->oob_buf,
+			controller->oob_buf,
+			BYTES_OF_USER_PER_PAGE);
+		if (ops_para->ecc_err)
+			memset(ops_para->oob_buf, 0x22, BYTES_OF_USER_PER_PAGE);
+	}
+
+	return ret;
+}
+
+
+/************************************************************
+ * read_page, all parameters saved in aml_chip->ops_para,
+ * refer to struct chip_ops_para define.
+ * support read way of hwecc/raw, data/oob only, data+oob
+ * for opteration mode, contains multi-plane/multi-chip
+ *************************************************************/
+static int read_page(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u32 plane0_page_addr, plane1_page_addr, page_addr;
+	u32 plane_page_addr, plane_blk_addr, pages_per_blk_shift;
+	u8 i, chip_num , plane_num;
+	int ret = 0;
+	PHY_NAND_LINE
+	if ((!ops_para->oob_buf) && (!ops_para->data_buf)) {
+		aml_nand_msg("buf & oob_buf should never be NULL");
+		ret = -NAND_ARGUMENT_FAILURE;
+		goto error_exit0;
+	}
+
+	/* for multi-chip mode */
+	if (ops_para->option & DEV_MULTI_CHIP_MODE)
+		chip_num = controller->chip_num;
+	else
+		chip_num = 1;
+
+	plane0_page_addr = plane1_page_addr = 0;
+
+	page_addr = ops_para->page_addr;
+	controller->page_addr = ops_para->page_addr;
+	pages_per_blk_shift =
+		(controller->block_shift - controller->page_shift);
+	if (unlikely(page_addr >= controller->internal_page_nums)) {
+		controller->page_addr -= controller->internal_page_nums;
+		controller->page_addr |= controller->internal_page_nums *
+			aml_chip->flash.internal_chipnr;
+		page_addr = controller->page_addr;
+	}
+	PHY_NAND_LINE
+	/* for multi-plane mode */
+	if (ops_para->option & DEV_MULTI_PLANE_MODE) {
+		plane_num = 2;
+		plane_page_addr = page_addr & ((1 << pages_per_blk_shift)-1);
+		plane_blk_addr = (page_addr >> (pages_per_blk_shift));
+		plane_blk_addr <<= 1;
+		plane0_page_addr = (plane_blk_addr << pages_per_blk_shift) |
+			plane_page_addr;
+		plane_blk_addr += 1;
+		plane1_page_addr = (plane_blk_addr << pages_per_blk_shift) |
+			plane_page_addr;
+	} else
+		plane_num = 1;
+	PHY_NAND_LINE
+	if (chip_num > 1) {
+		for (i = 0; i < chip_num; i++) {
+			if (plane_num == 2) {
+				ret = read_page_two_plane(aml_chip,
+					i,
+					plane0_page_addr,
+					plane1_page_addr);
+			} else
+				ret = read_page_single_plane(aml_chip,
+					i,
+					page_addr);
+		}
+	} else {
+		PHY_NAND_LINE
+		if (plane_num == 2) {
+			PHY_NAND_LINE
+			ret = read_page_two_plane(aml_chip,
+				ops_para->chipnr,
+				plane0_page_addr,
+				plane1_page_addr);
+		} else {
+			PHY_NAND_LINE
+			ret = read_page_single_plane(aml_chip,
+				ops_para->chipnr,
+				page_addr);
+		}
+	}
+error_exit0:
+	return ret;
+}
+
+/************************************************************
+ * write_page, all parameters saved in aml_chip->ops_para.
+ * support read way of hwecc/raw, data/oob only, data+oob
+ * for opteration mode, contains multi-plane/multi-chip
+ *
+ *************************************************************/
+static int write_page(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	u8 *buf = ops_para->data_buf;
+	u8 *oob_buf = ops_para->oob_buf;
+	u32 plane_page_addr, plane_blk_addr, pages_per_blk_shift;
+	u32 plane0_page_addr, plane1_page_addr, column, page_addr;
+	u32 page_size;
+	u8 i, bch_mode, plane_num, chip_num, chipnr, user_byte_num;
+	u8 slc_mode, status, st_cnt;
+	int ret = 0;
+
+	if (!buf) {
+		aml_nand_msg("buf should never be NULL");
+		ret = -NAND_ARGUMENT_FAILURE;
+		goto error_exit0;
+	}
+	if (aml_chip->nand_status  != NAND_STATUS_NORMAL) {
+		aml_nand_msg("nand status unusal: do not write anything!!!!!");
+		return NAND_SUCCESS;
+	}
+
+	user_byte_num = chipnr = 0;
+	plane0_page_addr = plane1_page_addr = 0;
+
+	/* for multi-chip mode */
+	if (ops_para->option & DEV_MULTI_CHIP_MODE)
+		chip_num = controller->chip_num;
+	else
+		chip_num = 1;
+
+	if (ops_para->option & DEV_SLC_MODE) {
+		/* aml_nand_dbg("enable SLC mode"); */
+		if (flash->new_type == SANDISK_19NM)
+			slc_mode = 1;
+		else if ((flash->new_type > 0) && (flash->new_type < 10))
+			slc_mode = 2;
+		else
+			slc_mode = 0;
+	} else
+		slc_mode = 0;
+
+	/* for multi-plane mode */
+	page_addr = ops_para->page_addr;
+	controller->page_addr = ops_para->page_addr;
+	pages_per_blk_shift =
+		(controller->block_shift - controller->page_shift);
+	if (unlikely(controller->page_addr >= controller->internal_page_nums)) {
+		controller->page_addr -= controller->internal_page_nums;
+		controller->page_addr |= controller->internal_page_nums *
+			aml_chip->flash.internal_chipnr;
+	}
+	if (ops_para->option & DEV_MULTI_PLANE_MODE) {
+		plane_num = 2;
+		plane_page_addr = (controller->page_addr &
+			(((1 << pages_per_blk_shift) - 1)));
+		plane_blk_addr = (controller->page_addr >> pages_per_blk_shift);
+		plane_blk_addr <<= 1;
+		plane0_page_addr = (plane_blk_addr << pages_per_blk_shift)
+			| plane_page_addr;
+		plane_blk_addr += 1;
+		plane1_page_addr = (plane_blk_addr << pages_per_blk_shift)
+			| plane_page_addr;
+
+#if 0
+		aml_nand_dbg("ops_para->page_addr =%d", ops_para->page_addr);
+		aml_nand_dbg("controller->page_addr=%d", controller->page_addr);
+		aml_nand_dbg("plane_page_addr =%d", plane_page_addr);
+		aml_nand_dbg("plane_blk_addr =%d", plane_blk_addr);
+		aml_nand_dbg("plane0_page_addr =%d", plane0_page_addr);
+		aml_nand_dbg("plane1_page_addr =%d", plane1_page_addr);
+#endif
+	} else {
+		plane_num = 1;
+	}
+
+	/* for ecc mode */
+	if ((ops_para->option & DEV_ECC_SOFT_MODE)
+		|| (controller->bch_mode == NAND_ECC_NONE)) {
+		bch_mode = NAND_ECC_NONE;
+		page_size = flash->pagesize + flash->oobsize;
+	} else {
+		bch_mode = controller->bch_mode;
+		user_byte_num = controller->ecc_steps*controller->user_mode;
+		page_size = controller->ecc_steps*controller->ecc_unit;
+
+		/*
+		if (controller->bch_mode == NAND_ECC_BCH_SHORT) {
+			page_size =
+				(flash->pagesize / 512) * NAND_ECC_UNIT_SHORT;
+		}*/
+
+		if (!oob_buf) { /* empty oob buffer, set defaut */
+			memset(controller->oob_buf,
+				0xa5,
+				(user_byte_num * (plane_num * chip_num)));
+			controller->oob_buf[0] = 0xff;
+			oob_buf = controller->oob_buf;
+		} else {
+			memcpy(controller->oob_buf,
+				ops_para->oob_buf,
+				(user_byte_num * (plane_num * chip_num)));
+			oob_buf = controller->oob_buf;
+		}
+
+	}
+
+#if 0
+	aml_nand_dbg("page_addr:%d, buf: %x %x %x %x %x %x %x %x",
+			ops_para->page_addr, buf[0],
+			buf[1], buf[2], buf[3], buf[4],
+			buf[5], buf[6], buf[7]);
+	aml_nand_dbg("page_addr:%d, oob_buf: %x %x %x %x %x %x %x %x",
+			ops_para->page_addr, oob_buf[0],
+			oob_buf[1], oob_buf[2], oob_buf[3], oob_buf[4],
+			oob_buf[5], oob_buf[6], oob_buf[7]);
+#endif
+	column = 0;
+
+	for (i = 0; i < chip_num; i++) {
+		chipnr = (chip_num > 1) ? i : ops_para->chipnr;
+		ret = controller->quene_rb(controller, chipnr);
+		if (ret) {
+			aml_nand_msg("quene rb busy here");
+			goto error_exit0;
+		}
+#if 0
+		if (aml_chip->debug_num == 1)
+			aml_nand_dbg("chipnr=%d, chip_num=%d",
+				chipnr,
+				chip_num);
+			aml_nand_dbg("controller->chip_selected =%d",
+			controller->chip_selected);
+#endif
+
+		if (plane_num == 2) {
+			/* plane0 */
+			controller->cmd_ctrl(controller, NAND_CMD_SEQIN,
+				NAND_CTRL_CLE);
+			controller->cmd_ctrl(controller, column,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, column>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane0_page_addr,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane0_page_addr>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane0_page_addr>>16,
+				NAND_CTRL_ALE);
+
+			if (bch_mode != NAND_ECC_NONE)
+				controller->set_usr_byte(controller,
+					oob_buf,
+					user_byte_num);
+
+			controller->page_addr = plane0_page_addr;
+			ret = controller->dma_write(controller,
+				buf,
+				page_size,
+				bch_mode);
+			if (ret) {
+				aml_nand_msg("dma error here");
+				goto error_exit0;
+			}
+#if  0
+			if (aml_chip->debug_num == 1) {
+				aml_nand_dbg("ops_para->page_addr =%d",
+					ops_para->page_addr);
+				aml_nand_dbg("controller->page_addr =%d",
+					controller->page_addr);
+				aml_nand_dbg("plane_page_addr =%d",
+					plane_page_addr);
+				aml_nand_dbg("plane_blk_addr =%d",
+					plane_blk_addr);
+				aml_nand_dbg("plane0_page_addr =%d",
+					plane0_page_addr);
+				aml_nand_dbg("plane1_page_addr =%d",
+					plane1_page_addr);
+
+			}
+#endif
+			controller->cmd_ctrl(controller,
+				NAND_CMD_DUMMY_PROGRAM,
+				NAND_CTRL_CLE);
+
+			NFC_SEND_CMD_IDLE(controller, NAND_TADL_TIME_CYCLE);
+
+			ret = controller->quene_rb(controller, chipnr);
+			if (ret) {
+				aml_nand_msg("quene rb busy here");
+				goto error_exit0;
+			}
+
+			oob_buf += user_byte_num;
+
+			/*
+			oob_buf+=(BYTES_OF_USER_PER_PAGE /(controller->chip_num;
+				plane_num));
+			*/
+			buf += page_size;
+
+			if ((controller->mfr_type == NAND_MFR_HYNIX)
+				|| (controller->mfr_type == NAND_MFR_SAMSUNG))
+				controller->cmd_ctrl(controller,
+					NAND_CMD_TWOPLANE_WRITE2,
+					NAND_CTRL_CLE);
+			else
+				controller->cmd_ctrl(controller,
+					NAND_CMD_TWOPLANE_WRITE2_MICRO,
+					NAND_CTRL_CLE);
+
+			controller->cmd_ctrl(controller, column, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, column>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane1_page_addr,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane1_page_addr>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane1_page_addr>>16,
+				NAND_CTRL_ALE);
+
+			NFC_SEND_CMD_IDLE(controller, NAND_TADL_TIME_CYCLE);
+
+			if (bch_mode != NAND_ECC_NONE)
+				controller->set_usr_byte(controller,
+					oob_buf,
+					user_byte_num);
+
+			controller->page_addr = plane1_page_addr;
+			ret = controller->dma_write(controller,
+					buf,
+					page_size,
+					bch_mode);
+			if (ret) {
+				aml_nand_msg("dma error here");
+				goto error_exit0;
+			}
+		} else {
+			if (slc_mode) {
+				ret = slc_info->enter(controller);
+				if (ret < 0)
+					aml_nand_msg("slc enter failed here");
+			}
+
+			/*
+			NFC_SEND_CMD_IDLE(controller, NAND_TADL_TIME_CYCLE);
+			*/
+			ret = controller->quene_rb(controller, chipnr);
+			if (ret)
+				aml_nand_msg("quene rb busy here");
+
+			controller->cmd_ctrl(controller, NAND_CMD_SEQIN,
+				NAND_CTRL_CLE);
+			controller->cmd_ctrl(controller, column,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, column>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, controller->page_addr,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller,
+				controller->page_addr>>8, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller,
+				controller->page_addr>>16, NAND_CTRL_ALE);
+			/*
+			controller->cmd_ctrl(controller,
+				NAND_CMD_PAGEPROG, NAND_CTRL_CLE);
+			*/
+			NFC_SEND_CMD_IDLE(controller, NAND_TADL_TIME_CYCLE);
+
+			if (bch_mode != NAND_ECC_NONE)
+				controller->set_usr_byte(controller,
+					oob_buf,
+					user_byte_num);
+#if 0
+			if (aml_chip->debug_num == 1) {
+				aml_nand_dbg("chipnr =%d", chipnr);
+				aml_nand_dbg("controller->page_addr =%d",
+					controller->page_addr);
+			}
+#endif
+			ret = controller->dma_write(controller,
+				buf,
+				page_size,
+				bch_mode);
+			if (ret) {
+				aml_nand_msg("dma error here");
+				goto error_exit0;
+			}
+#if  0
+			if (1) {
+				aml_nand_dbg("ops_para->page_addr =%d",
+					ops_para->page_addr);
+				aml_nand_dbg("controller->page_addr =%d",
+					controller->page_addr);
+				aml_nand_dbg("plane_page_addr =%d",
+					plane_page_addr);
+				aml_nand_dbg("plane_blk_addr =%d",
+					plane_blk_addr);
+				int tt;
+				aml_nand_dbg("page_size=%d", page_size);
+				for (tt = 0; tt < 200; tt++)
+					aml_nand_dbg("buf[%d]=%d", tt, buf[tt]);
+			}
+#endif
+		}
+		/* start */
+		controller->cmd_ctrl(controller, NAND_CMD_PAGEPROG,
+			NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+		oob_buf += user_byte_num;
+
+		/*
+		oob_buf +=
+		(BYTES_OF_USER_PER_PAGE /(controller->chip_num * plane_num));
+		*/
+		buf += page_size;
+
+		if (check_cmdfifo_size(controller)) {
+			aml_nand_msg("check cmdfifo size timeout");
+			BUG();
+		}
+	}
+
+	for (i = 0; i < chip_num; i++) {
+		chipnr = (chip_num > 1) ? i : ops_para->chipnr;
+		st_cnt = 0;
+#ifdef AML_NAND_RB_IRQ
+		if (i == 0)
+			ret = controller->quene_rb_irq(controller, chipnr);
+		else
+			ret = controller->quene_rb(controller, chipnr);
+#else
+		ret = controller->quene_rb(controller, chipnr);
+#endif
+		if (ret) {
+			aml_nand_msg("quene rb busy here");
+			goto error_exit0;
+		}
+
+		controller->cmd_ctrl(controller, NAND_CMD_STATUS,
+			NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+WSTATUS_TRY:
+		status = controller->readbyte(controller);
+		if (status == NAND_STATUS_FAILED) {
+			aml_nand_msg("write falied at page:%d, status:0x%x",
+				page_addr,
+				status);
+			ret = -NAND_WRITE_FAILED;
+			goto error_exit0;
+		} else if (status != NAND_STATUS_RIGHT) {
+			aml_nand_msg("status failed page:%d,status:0x%x try:%d",
+				page_addr,
+				status,
+				st_cnt);
+			if (st_cnt++ < NAND_STATUS_MAX_TRY) {
+				NFC_SEND_CMD_IDLE(controller,
+					NAND_TWB_TIME_CYCLE);
+				goto WSTATUS_TRY;
+			}
+			aml_nand_msg("status still failed");
+		}
+
+		/* for hynix nand, reset reg def value */
+		if (slc_mode == 2) {
+			ret = slc_info->exit(controller);
+			if (ret < 0)
+				aml_nand_msg("slc enter failed here");
+		}
+	}
+	return NAND_SUCCESS;
+error_exit0:
+	return ret;
+}
+
+static int set_blcok_status(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u32 addr,
+	int value)
+{
+	/* struct hw_controller *controller = &aml_chip->controller; */
+	/* struct nand_flash *flash = &aml_chip->flash; */
+	u32 blk_addr = addr;
+	u16 *tmp_status = NULL;
+
+	tmp_status = &aml_chip->block_status->blk_status[chipnr][0];
+	tmp_status[blk_addr] = value;
+	aml_nand_msg(" NAND bbt set Bad block at %d\n", blk_addr);
+
+	return 0;
+}
+
+static int get_blcok_status(struct amlnand_chip *aml_chip,
+	u8 chipnr,
+	u32 addr)
+{
+	/* struct hw_controller *controller = &aml_chip->controller; */
+	/* struct nand_flash *flash = &aml_chip->flash; */
+	u32 blk_addr = addr;
+	u16 *tmp_status = NULL;
+
+	tmp_status = &aml_chip->block_status->blk_status[chipnr][0];
+#if 0
+	aml_nand_dbg("!!!!!show the block statusXXX ");
+	int chip = 0, start_block, total_blk = 50;
+	u16 *tmp_arr;
+	for (chip = 0; chip < controller->chip_num; chip++) {
+		tmp_arr = &aml_chip->block_status->blk_status[chip][0];
+			for (start_block = 0;
+				start_block < total_blk;
+				start_block++)
+				aml_nand_msg(" tmp_arr[%d][%d]=%d",
+					chip,
+					start_block,
+					tmp_arr[start_block]);
+	}
+#endif
+
+	if (tmp_status[blk_addr] == NAND_BLOCK_USED_BAD) {
+		aml_nand_dbg(" NAND bbt detect Bad block at chip %d blk %d ",
+			chipnr, blk_addr);
+		return  NAND_BLOCK_USED_BAD;
+	} else if (tmp_status[blk_addr] == NAND_BLOCK_FACTORY_BAD) {
+		/*
+		aml_nand_dbg(" NAND bbt detect factory
+			Bad block at chip %d blk %d",
+			chipnr, blk_addr);
+		*/
+		return  NAND_BLOCK_FACTORY_BAD;
+	} else if (tmp_status[blk_addr] == NAND_BLOCK_GOOD)
+		return  NAND_BLOCK_GOOD;
+	else{
+		aml_nand_msg("blk status is wrong at chip%d blk=%d tmp[%d]=%d",
+			chipnr, blk_addr,
+			blk_addr, tmp_status[blk_addr]);
+		return -1;
+	}
+}
+
+/************************************************************
+ * block_isbad, all parameters saved in aml_chip->ops_para.
+ * for opteration mode, contains multi-plane/multi-chip
+ * supposed chip bbt has been installed
+ *
+ *************************************************************/
+static int block_isbad(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_ops_para *ops_para = &aml_chip->ops_para;
+	struct chip_operation *operation = &aml_chip->operation;
+
+	u32 blk_addr, page_per_blk_shift;
+	u8 chipnr;
+	//u8 chip_num = 1;
+	u8  oob_buf[8];
+	int ret = 0;
+#if 0
+	if (ops_para->option & DEV_MULTI_CHIP_MODE) {
+		chip_num = controller->chip_num;
+		/* aml_nand_dbg(" chip_num =%d ",chip_num); */
+	}
+#endif //0
+	page_per_blk_shift = ffs(flash->blocksize) - ffs(flash->pagesize);
+	blk_addr = ops_para->page_addr >> page_per_blk_shift;
+	chipnr = ops_para->chipnr;
+	if (unlikely(controller->page_addr >= controller->internal_page_nums)) {
+		controller->page_addr -= controller->internal_page_nums;
+		controller->page_addr |= controller->internal_page_nums *
+			aml_chip->flash.internal_chipnr;
+	}
+	/* aml_nand_dbg("ops_para->page_addr = %d",ops_para->page_addr); */
+	/* aml_nand_dbg("chipnr= %d",chipnr); */
+	/* aml_nand_dbg("blk_addr= %d",blk_addr); */
+
+	if (aml_chip->block_status != NULL) {
+		if ((ops_para->option  & DEV_MULTI_PLANE_MODE)
+			&& (!(ops_para->option & DEV_MULTI_CHIP_MODE))) {
+			blk_addr <<= 1;
+			/*
+		aml_nand_dbg(" DEV_MULTI_PLANE_MODE  &&  !DEV_MULTI_CHIP_MODE");
+			*/
+			ret = get_blcok_status(aml_chip, chipnr, blk_addr);
+			if (ret == NAND_BLOCK_GOOD) {
+				/* plane 0 is good , check plane 1 */
+				if ((blk_addr % 2) == 0)
+					ret = get_blcok_status(aml_chip,
+						chipnr,
+						(blk_addr+1));
+				else/* plane 1 is good, check plane 0 */
+					ret = get_blcok_status(aml_chip,
+						chipnr,
+						(blk_addr - 1));
+			}
+		} else if ((!(ops_para->option  & DEV_MULTI_PLANE_MODE))
+			&& ((ops_para->option & DEV_MULTI_CHIP_MODE))) {
+			/*
+		aml_nand_dbg(" !DEV_MULTI_PLANE_MODE  &&  DEV_MULTI_CHIP_MODE");
+			*/
+			for (chipnr = 0;
+				chipnr < controller->chip_num;
+				chipnr++) {
+				ret = get_blcok_status(aml_chip, chipnr,
+					blk_addr);
+				if (ret != NAND_BLOCK_GOOD)
+					break;
+			}
+		} else if ((ops_para->option  & DEV_MULTI_PLANE_MODE)
+			&& (ops_para->option & DEV_MULTI_CHIP_MODE)) {
+			/*
+			aml_nand_dbg("DEV_MULTI_PLANE_MODE &&
+				DEV_MULTI_CHIP_MODE");
+			*/
+			blk_addr <<= 1;
+			ret = get_blcok_status(aml_chip, chipnr, blk_addr);
+			if (ret == 0) {
+				for (chipnr = 0;
+					chipnr < controller->chip_num;
+					chipnr++) {
+					ret = get_blcok_status(aml_chip,
+						chipnr,
+						blk_addr);
+					if (ret != NAND_BLOCK_GOOD)
+						break;
+					if ((blk_addr % 2) == 0) {
+						/*
+						plane 0 is good , check plane 1
+						*/
+						ret = get_blcok_status(aml_chip,
+							chipnr,
+							(blk_addr+1));
+			if (ret != NAND_BLOCK_GOOD)
+				break;
+					} else {
+						/*
+						plane 1 is good, check plane 0
+						*/
+						ret = get_blcok_status(aml_chip,
+							chipnr,
+							(blk_addr - 1));
+			if (ret != NAND_BLOCK_GOOD)
+				break;
+					}
+				}
+			}
+		} else
+			ret = get_blcok_status(aml_chip, chipnr, blk_addr);
+	} else {
+		ops_para->data_buf = controller->page_buf;
+		ops_para->oob_buf = controller->oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		memset(ops_para->data_buf, 0x0, flash->pagesize);
+		memset(ops_para->oob_buf, 0x0, sizeof(oob_buf));
+
+		nand_get_chip(aml_chip);
+
+		ret = operation->read_page(aml_chip);
+
+		nand_release_chip(aml_chip);
+
+		if ((ret < 0) || (ops_para->ecc_err)) {
+			aml_nand_msg("nand read page failed at %d chip %d",
+				ops_para->page_addr, ops_para->chipnr);
+			ret = -NAND_READ_FAILED;
+			goto exit_error0;
+		}
+
+		if (ops_para->oob_buf[0] == 0) {
+			aml_nand_msg("nand detect bad blk at %d chip %d",
+				blk_addr, ops_para->chipnr);
+			ret = -NAND_BAD_BLCOK_FAILURE;
+			goto exit_error0;
+		}
+	}
+	return ret;
+exit_error0:
+	return ret;
+}
+
+/************************************************************
+ * block_isbad, all parameters saved in aml_chip->ops_para.
+ * for opteration mode, contains multi-plane/multi-chip
+ * supposed chip bbt has been installed
+ *
+ *************************************************************/
+static int block_markbad(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_ops_para *ops_para = &aml_chip->ops_para;
+	struct chip_operation *operation = &aml_chip->operation;
+
+	u32 blk_addr, pages_per_blk_shift;
+	u8 chipnr;
+	//u8 chip_num = 1;
+	u16 *tmp_status;
+	int ret;
+#if 0
+	if (ops_para->option & DEV_MULTI_CHIP_MODE)
+		chip_num = controller->chip_num;
+#endif
+	pages_per_blk_shift = ffs(flash->blocksize) - ffs(flash->pagesize);
+	blk_addr = ops_para->page_addr >> pages_per_blk_shift;
+	chipnr = ops_para->chipnr;
+	if (unlikely(controller->page_addr >= controller->internal_page_nums)) {
+		controller->page_addr -= controller->internal_page_nums;
+		controller->page_addr |= controller->internal_page_nums *
+			aml_chip->flash.internal_chipnr;
+	}
+	aml_nand_dbg("blk_addr =%d", blk_addr);
+
+	if ((aml_chip->nand_bbtinfo.arg_valid)
+		&& (aml_chip->block_status != NULL)) {
+		tmp_status = &aml_chip->block_status->blk_status[chipnr][0];
+		if ((tmp_status[blk_addr] == NAND_BLOCK_USED_BAD)
+			|| (tmp_status[blk_addr] == NAND_BLOCK_FACTORY_BAD))
+			return 0;
+		else if (tmp_status[blk_addr] == NAND_BLOCK_GOOD) {
+			if ((ops_para->option  & DEV_MULTI_PLANE_MODE)
+			&& (!(ops_para->option & DEV_MULTI_CHIP_MODE))) {
+				blk_addr <<= 1;
+				if ((blk_addr % 2) == 0) {
+					/* plane 0 is good , set plane 1 */
+					ret = set_blcok_status(aml_chip,
+						chipnr, (blk_addr),
+						NAND_BLOCK_USED_BAD);
+					ret = set_blcok_status(aml_chip,
+						chipnr, (blk_addr+1),
+						NAND_BLOCK_USED_BAD);
+				aml_nand_dbg("set blk bad at chip%d blk=%d",
+						chipnr, blk_addr);
+				aml_nand_dbg("set blk bad at chip %d blk %d",
+						chipnr, (blk_addr+1));
+				} else {/* plane 1 is good, set plane 0 */
+					ret = set_blcok_status(aml_chip, chipnr,
+						(blk_addr),
+						NAND_BLOCK_USED_BAD);
+					ret = set_blcok_status(aml_chip, chipnr,
+						(blk_addr - 1),
+						NAND_BLOCK_USED_BAD);
+				aml_nand_dbg("set blk bad at chip %d blk %d",
+						chipnr, blk_addr);
+				aml_nand_dbg("set blk bad at chip %d blk %d",
+						chipnr, (blk_addr-1));
+				}
+			} else if ((!(ops_para->option & DEV_MULTI_PLANE_MODE))
+				&& ((ops_para->option & DEV_MULTI_CHIP_MODE))) {
+				for (chipnr = 0;
+					chipnr < controller->chip_num;
+					chipnr++) {
+					ret = set_blcok_status(aml_chip,
+						chipnr,
+						blk_addr,
+						NAND_BLOCK_USED_BAD);
+				aml_nand_dbg(" set blk bad at chip %d blk %d",
+						chipnr, blk_addr);
+				}
+			} else if ((ops_para->option  & DEV_MULTI_PLANE_MODE)
+				&& (ops_para->option & DEV_MULTI_CHIP_MODE)) {
+				blk_addr <<= 1;
+				for (chipnr = 0;
+					chipnr < controller->chip_num;
+					chipnr++) {
+					if ((blk_addr % 2) == 0) {
+						/*
+						plane 0 is good , set plane 1
+						*/
+						ret = set_blcok_status(aml_chip,
+							chipnr,
+							(blk_addr+1),
+							NAND_BLOCK_USED_BAD);
+				aml_nand_dbg("set blk bad at chip %d blk %d",
+							chipnr,
+							(blk_addr+1));
+					} else {
+					/* plane 1 is good, set plane 0 */
+						ret = set_blcok_status(aml_chip,
+							chipnr,
+							(blk_addr - 1),
+							NAND_BLOCK_USED_BAD);
+				aml_nand_dbg("set blk bad,chip%d blk %d",
+							chipnr,
+							(blk_addr-1));
+					}
+					/* multi_chip , set every chip_blk */
+					ret = set_blcok_status(aml_chip,
+						chipnr,
+						blk_addr,
+						NAND_BLOCK_USED_BAD);
+				aml_nand_dbg("set blk bad at chip%d blk=%d",
+					chipnr, blk_addr);
+				}
+			} else {
+				ret = set_blcok_status(aml_chip,
+					chipnr,
+					blk_addr,
+					NAND_BLOCK_USED_BAD);
+				aml_nand_dbg(" set blk bad at chip %d blk %d",
+					chipnr,
+					blk_addr);
+			}
+
+			ret = amlnand_update_bbt(aml_chip);
+			if (ret < 0)
+				aml_nand_msg("nand update bbt failed");
+
+		}
+	}
+#if 0
+	/* show the changed block status */
+	aml_nand_dbg("show the changed block status ");
+	for (chipnr = 0; chipnr < controller->chip_num; chipnr++) {
+		tmp_arr = &aml_chip->block_status->blk_status[chipnr][0];
+		for (start_block = 0; start_block < 100; start_block++)
+			aml_nand_msg(" tmp_arr[%d][%d]=%d",
+				chipnr,
+				start_block,
+				tmp_arr[start_block]);
+	}
+#endif
+
+	/*
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	*/
+	/* ops_para->page_addr = blk_addr << pages_per_blk_shift; */
+	/* ops_para->chipnr = blk_addr % controller->chip_num; */
+	controller->select_chip(controller, ops_para->chipnr);
+	ops_para->data_buf = controller->page_buf;
+	ops_para->oob_buf = controller->oob_buf;
+	memset((u8 *)ops_para->data_buf, 0x0, flash->pagesize);
+	memset((u8 *)ops_para->oob_buf, 0x0, flash->oobsize);
+
+	if (aml_chip->state == CHIP_READY)
+		nand_get_chip(aml_chip);
+
+	ret = operation->write_page(aml_chip);
+
+	if (aml_chip->state == CHIP_READY)
+		nand_release_chip(aml_chip);
+
+	if (ret < 0) {
+		aml_nand_msg("%s() %d: nand write failed", __func__, __LINE__);
+		ret = -NAND_WRITE_FAILED;
+	}
+
+	return ret;
+}
+
+
+/************************************************************
+ * erase_block, all parameters saved in aml_chip->ops_para.
+ * for opteration mode, contains multi-plane/multi-chip
+ * supposed chip bbt has been installed
+ *
+ *************************************************************/
+static int erase_block(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	u32 plane_page_addr, plane_blk_addr, pages_per_blk_shift;
+	u32 plane0_page_addr, plane1_page_addr, chipnr;
+	u8 slc_mode, chip_num = 1, plane_num = 1, status, st_cnt;
+	int i, ret = 0;
+
+	/* aml_nand_dbg("page_addr:%d", ops_para->page_addr); */
+	if (aml_chip->nand_status  != NAND_STATUS_NORMAL) {
+		aml_nand_msg("nand status unusal: do not erase anything!!!!!");
+		return NAND_SUCCESS;
+	}
+
+	if (ops_para->option & DEV_MULTI_CHIP_MODE)
+		chip_num = controller->chip_num;
+
+	if (ops_para->option & DEV_SLC_MODE) {
+		aml_nand_dbg("enable SLC mode");
+		if (flash->new_type == SANDISK_19NM)
+			slc_mode = 1;
+		else
+			slc_mode = 0;
+	} else
+	   slc_mode = 0;
+
+	controller->page_addr = ops_para->page_addr;
+
+	pages_per_blk_shift = ffs(flash->blocksize) - ffs(flash->pagesize);
+	if (unlikely(controller->page_addr >= controller->internal_page_nums)) {
+		controller->page_addr -= controller->internal_page_nums;
+		controller->page_addr |= controller->internal_page_nums *
+			aml_chip->flash.internal_chipnr;
+	}
+	plane0_page_addr = plane1_page_addr = 0;
+	if (ops_para->option & DEV_MULTI_PLANE_MODE) {
+		plane_num = 2;
+		plane_page_addr = (controller->page_addr &
+			((1 << pages_per_blk_shift) - 1));
+		plane_blk_addr = (controller->page_addr >> pages_per_blk_shift);
+		plane_blk_addr <<= 1;
+		plane0_page_addr = (plane_blk_addr << pages_per_blk_shift) |
+			plane_page_addr;
+		plane1_page_addr =
+			((plane_blk_addr + 1) << pages_per_blk_shift) |
+			plane_page_addr;
+	}
+
+	for (i = 0; i < chip_num; i++) {
+		chipnr = (chip_num > 1) ? i : ops_para->chipnr;
+		ret = controller->quene_rb(controller, chipnr);
+		if (ret) {
+			aml_nand_msg("quene rb busy,chipnr:%d,page_addr:%d",
+				chipnr,
+				controller->page_addr);
+			goto error_exit0;
+		}
+
+		if (plane_num == 2) {
+			controller->cmd_ctrl(controller, NAND_CMD_ERASE1,
+				NAND_CTRL_CLE);
+			controller->cmd_ctrl(controller, plane0_page_addr,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane0_page_addr>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane0_page_addr>>16,
+				NAND_CTRL_ALE);
+			if ((controller->mfr_type == NAND_MFR_MICRON)
+				|| (controller->mfr_type == NAND_MFR_MICRON)) {
+				controller->cmd_ctrl(controller,
+					NAND_CMD_ERASE1_END,
+					NAND_CTRL_CLE);
+				NFC_SEND_CMD_IDLE(controller,
+					NAND_TWB_TIME_CYCLE);
+				ret = controller->quene_rb(controller, chipnr);
+				if (ret) {
+					aml_nand_msg("rb busy,chip%d,paddr:%d",
+						chipnr,
+						controller->page_addr);
+					goto error_exit0;
+				}
+			}
+
+			controller->cmd_ctrl(controller, NAND_CMD_ERASE1,
+				NAND_CTRL_CLE);
+			controller->cmd_ctrl(controller, plane1_page_addr,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane1_page_addr>>8,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, plane1_page_addr>>16,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller, NAND_CMD_ERASE2,
+				NAND_CTRL_CLE);
+			NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+		} else {
+			if (slc_mode) {
+				ret = slc_info->enter(controller);
+				if (ret < 0)
+					aml_nand_msg("slc enter failed here");
+			}
+			controller->cmd_ctrl(controller, NAND_CMD_ERASE1,
+				NAND_CTRL_CLE);
+			controller->cmd_ctrl(controller, controller->page_addr,
+				NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller,
+				controller->page_addr>>8, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller,
+				controller->page_addr>>16, NAND_CTRL_ALE);
+			controller->cmd_ctrl(controller,
+				NAND_CMD_ERASE2, NAND_CTRL_CLE);
+
+			NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+		}
+
+		if (check_cmdfifo_size(controller)) {
+			aml_nand_msg("check cmdfifo size timeout");
+			BUG();
+		}
+	}
+
+	for (i = 0; i < chip_num; i++) {
+		chipnr = (chip_num > 1) ? i : ops_para->chipnr;
+		st_cnt = 0;
+#ifdef AML_NAND_RB_IRQ
+		if (i == 0)
+			ret = controller->quene_rb_irq(controller, chipnr);
+		else
+			ret = controller->quene_rb(controller, chipnr);
+#else
+		ret = controller->quene_rb(controller, chipnr);
+#endif
+		if (ret) {
+			aml_nand_msg("quene rb busy,chipnr:%d,page_addr:%d",
+				chipnr,
+				controller->page_addr);
+			goto error_exit0;
+		}
+
+		controller->cmd_ctrl(controller,
+			NAND_CMD_STATUS, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+
+ESTATUS_TRY:
+		status = controller->readbyte(controller);
+		if (status == NAND_STATUS_FAILED) {
+			aml_nand_msg("erase falied, chip%d page:%d,status:0x%x",
+				chipnr,
+				controller->page_addr,
+				status);
+			ret = -NAND_WRITE_FAILED;
+			goto error_exit0;
+		} else if (status != NAND_STATUS_RIGHT) {
+			aml_nand_msg("erase status failed");
+			aml_nand_msg("chipnr:%d page:%d,status:0x%x and try:%d",
+				chipnr,
+				controller->page_addr,
+				status,
+				st_cnt);
+			if (st_cnt++ < NAND_STATUS_MAX_TRY) {
+				NFC_SEND_CMD_IDLE(controller,
+					NAND_TWB_TIME_CYCLE);
+				goto ESTATUS_TRY;
+			}
+			aml_nand_msg("erase status still failed ");
+		}
+	}
+	return NAND_SUCCESS;
+error_exit0:
+	return ret;
+}
+/************************************************************
+ * test_block, all parameters saved in aml_chip->ops_para.
+ * for opteration mode, contains multi-plane/multi-chip
+ * supposed chip bbt has been installed
+ * something wrong, don't work well!!! Do not use it.
+ *************************************************************/
+static int test_block_chip_op(struct amlnand_chip *aml_chip)
+{
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct nand_flash *flash = &aml_chip->flash;
+
+	u8 phys_erase_shift, phys_page_shift;
+	u32 pages_per_blk, pages_read, blk_addr = 0;
+	u8  oob_buf[8];
+	int  ret = 0, t = 0;
+	u8 *dat_buf = NULL;
+
+	blk_addr = ops_para->page_addr;
+	dat_buf  = aml_nand_malloc(flash->pagesize);
+	if (!dat_buf) {
+		aml_nand_msg("test_block: malloc failed");
+		ret =  -1;
+		goto exit;
+	}
+	memset(dat_buf, 0xa5, flash->pagesize);
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+	pages_read = pages_per_blk;
+
+	/* erase */
+	aml_nand_msg("erase addr = %d", ops_para->page_addr);
+	ret = erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand blk erase failed");
+		ret =  -1;
+		goto exit;
+	}
+	aml_nand_msg("nand blk %d erase OK", blk_addr);
+
+#if 1
+	/* read */
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	ops_para->page_addr = blk_addr;
+	for (t = 0; t < pages_read; t++) {
+		memset(aml_chip->user_page_buf, 0x0, flash->pagesize);
+		ops_para->page_addr += t;
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		ret = read_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand read %d failed", blk_addr);
+			ret =  -1;
+			goto exit;
+		}
+	}
+	aml_nand_msg("nand blk read OK");
+
+	/* write */
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	ops_para->page_addr = blk_addr;
+	for (t = 0; t < pages_read; t++) {
+		memset(aml_chip->user_page_buf, 0xa5, flash->pagesize);
+		ops_para->page_addr += t;
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		ret = write_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("%s() %d: nand write failed", __func__, __LINE__);
+			ret =  -1;
+			goto exit;
+		}
+	}
+	aml_nand_msg("nand blk %d write OK", blk_addr);
+	/* read */
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	ops_para->page_addr = blk_addr;
+	for (t = 0; t < pages_read; t++) {
+		memset(aml_chip->user_page_buf, 0x0, flash->pagesize);
+		ops_para->page_addr += t;
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		ret = read_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand read failed");
+			ret =  -1;
+			goto exit;
+		}
+	}
+	aml_nand_msg("nand blk %d read OK", blk_addr);
+	/* erase */
+	ops_para->page_addr = blk_addr;
+	ret = erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand blk erase failed");
+		ret =  -1;
+		goto exit;
+	}
+	aml_nand_msg("nand blk %d erase OK", blk_addr);
+#endif
+exit:
+	/* nand_release_chip(aml_chip); */
+	if (dat_buf) {
+		aml_nand_free(dat_buf);
+		dat_buf = NULL;
+	}
+	if (!ret)
+		aml_nand_msg("blk test OK");
+
+	return ret;
+}
+
+/************************************************************
+ * test_block, all parameters saved in aml_chip->ops_para.
+ * for opteration mode, contains multi-plane/multi-chip
+ * supposed chip bbt has been installed
+ *
+ *************************************************************/
+static int test_block_reserved(struct amlnand_chip *aml_chip, int tst_blk)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	/* struct chip_operation *operation = & aml_chip->operation; */
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct en_slc_info *slc_info = &(controller->slc_info);
+
+	u8 phys_erase_shift, phys_page_shift, nand_boot;
+	u32 offset, pages_per_blk, pages_read;
+	u8  oob_buf[8];
+	u16  tmp_blk;
+	int  ret = 0, t = 0;
+	u32 tmp_value;
+
+	u8 *dat_buf = NULL;
+
+	dat_buf  = aml_nand_malloc(flash->pagesize);
+	if (!dat_buf) {
+		aml_nand_msg("test_block: malloc failed");
+		ret =  -1;
+		goto exit;
+	}
+	memset(dat_buf, 0xa5, flash->pagesize);
+
+	nand_boot = 1;
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+
+	tmp_blk = (offset >> phys_erase_shift);
+
+	if ((flash->new_type) && ((flash->new_type < 10)
+		|| (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+
+	if (ops_para->option & DEV_SLC_MODE)
+		pages_read = pages_per_blk >> 1;
+	else
+		pages_read = pages_per_blk;
+
+	nand_get_chip(aml_chip);
+
+	/* erase */
+	tmp_value = tst_blk - tst_blk % controller->chip_num;
+	tmp_value /= controller->chip_num;
+	tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+	ops_para->page_addr = tmp_value * pages_per_blk;
+	ops_para->chipnr = tst_blk % controller->chip_num;
+	controller->select_chip(controller, ops_para->chipnr);
+	ret = erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand blk %d erase failed", tst_blk);
+		ret =  -1;
+		goto exit;
+	}
+	/* write */
+	for (t = 0; t < pages_read; t++) {
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		if ((flash->new_type) && ((flash->new_type < 10)
+			|| (flash->new_type == SANDISK_19NM)))
+			ops_para->option |= DEV_SLC_MODE;
+		tmp_value = tst_blk - tst_blk % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = t + tmp_value * pages_per_blk;
+		ops_para->chipnr = tst_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		if ((ops_para->option & DEV_SLC_MODE)) {
+			tmp_value = ~(pages_per_blk - 1);
+			tmp_value &= ops_para->page_addr;
+			if ((flash->new_type > 0) && (flash->new_type < 10))
+				ops_para->page_addr = tmp_value |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+			if (flash->new_type == SANDISK_19NM)
+				ops_para->page_addr = tmp_value |
+				((ops_para->page_addr % pages_per_blk) << 1);
+		}
+
+		memset(aml_chip->user_page_buf, 0xa5, flash->pagesize);
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		ret = write_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("%s() %d: nand write failed", __func__, __LINE__);
+			ret =  -1;
+			goto exit;
+		}
+	}
+	/* read */
+	for (t = 0; t < pages_read; t++) {
+		memset((u8 *)ops_para, 0x0,
+			sizeof(struct chip_ops_para));
+		if ((flash->new_type) && ((flash->new_type < 10)
+			|| (flash->new_type == SANDISK_19NM)))
+			ops_para->option |= DEV_SLC_MODE;
+		tmp_value = tst_blk - tst_blk % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = (t + tmp_value * pages_per_blk);
+		ops_para->chipnr = tst_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		if ((ops_para->option & DEV_SLC_MODE)) {
+			tmp_value = ~(pages_per_blk - 1);
+			tmp_value &= ops_para->page_addr;
+			if ((flash->new_type > 0) && (flash->new_type < 10))
+				ops_para->page_addr = tmp_value |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+			if (flash->new_type == SANDISK_19NM)
+				ops_para->page_addr = tmp_value |
+				((ops_para->page_addr % pages_per_blk) << 1);
+		}
+
+		memset(aml_chip->user_page_buf, 0x0, flash->pagesize);
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		ret = read_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand read failed");
+			ret =  -1;
+			goto exit;
+		}
+		/*
+		aml_nand_dbg("tst_blk %d aml_chip->user_page_buf: ",tst_blk);
+		*/
+		/* show_data_buf(aml_chip->user_page_buf); */
+		/* aml_nand_dbg("tst_blk %d dat_buf: ",tst_blk); */
+		/* show_data_buf(dat_buf); */
+		if (memcmp(aml_chip->user_page_buf,
+			dat_buf,
+			flash->pagesize)) {
+			ret =  -1;
+			aml_nand_msg("blk  %d,  page %d : test failed",
+				tst_blk,
+				t);
+			goto exit;
+		}
+	}
+	/* erase */
+	tmp_value = tst_blk - tst_blk % controller->chip_num;
+	tmp_value /= controller->chip_num;
+	tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+	ops_para->page_addr = tmp_value * pages_per_blk;
+	ops_para->chipnr = tst_blk % controller->chip_num;
+	controller->select_chip(controller, ops_para->chipnr);
+	ret = erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand blk %d erase failed", tst_blk);
+		ret =  -1;
+		goto exit;
+	}
+
+exit:
+	nand_release_chip(aml_chip);
+
+	if (dat_buf) {
+		aml_nand_free(dat_buf);
+		dat_buf = NULL;
+	}
+	if (!ret)
+		aml_nand_msg("blk %d test OK", tst_blk);
+
+	return ret;
+}
+/************************************************************
+ * all parameters saved in aml_chip->ops_para.
+ * for opteration mode, contains multi-plane/multi-chip
+ * supposed chip bbt has been installed
+ *
+ *************************************************************/
+static int blk_modify_bbt_chip_op(struct amlnand_chip *aml_chip, int value)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_ops_para *ops_para = &aml_chip->ops_para;
+	/* struct chip_operation *operation = & aml_chip->operation; */
+
+	u32 blk_addr, page_per_blk_shift;
+	u8 chipnr;
+	/* u8  oob_buf[8]; */
+	int ret = 0;
+#if 0
+	u8 chip_num = 1;
+	if (ops_para->option & DEV_MULTI_CHIP_MODE)
+		chip_num = controller->chip_num;
+#endif
+	page_per_blk_shift = ffs(flash->blocksize) - ffs(flash->pagesize);
+	blk_addr = ops_para->page_addr >> page_per_blk_shift;
+	chipnr = ops_para->chipnr;
+	if (unlikely(controller->page_addr >= controller->internal_page_nums)) {
+		controller->page_addr -= controller->internal_page_nums;
+		controller->page_addr |= controller->internal_page_nums *
+			aml_chip->flash.internal_chipnr;
+	}
+
+	if ((ops_para->option  & DEV_MULTI_PLANE_MODE)
+		&& (!(ops_para->option & DEV_MULTI_CHIP_MODE))) {
+		blk_addr <<= 1;
+		/*
+		aml_nand_dbg(" DEV_MULTI_PLANE_MODE && !DEV_MULTI_CHIP_MODE");
+		*/
+		ret = set_blcok_status(aml_chip, chipnr, blk_addr, value);
+		if (ret == 0) {
+			if ((blk_addr % 2) == 0)
+				/* plane 0 is good , check plane 1 */
+				ret = set_blcok_status(aml_chip,
+					chipnr,
+					(blk_addr+1),
+					value);
+			else	/* plane 1 is good, check plane 0 */
+				ret = set_blcok_status(aml_chip,
+					chipnr,
+					(blk_addr - 1),
+					value);
+		}
+	} else if ((!(ops_para->option & DEV_MULTI_PLANE_MODE))
+		&& ((ops_para->option & value))) {
+		/*
+		aml_nand_dbg(" !DEV_MULTI_PLANE_MODE  &&  DEV_MULTI_CHIP_MODE");
+		*/
+		for (chipnr = 0; chipnr < controller->chip_num; chipnr++) {
+			ret = set_blcok_status(aml_chip,
+				chipnr,
+				blk_addr,
+				value);
+			if (ret != 0)
+				break;
+		}
+	} else if ((ops_para->option  & DEV_MULTI_PLANE_MODE)
+		&& (ops_para->option & DEV_MULTI_CHIP_MODE)) {
+		/*
+		aml_nand_dbg(" DEV_MULTI_PLANE_MODE && DEV_MULTI_CHIP_MODE");
+		*/
+		blk_addr <<= 1;
+		ret = set_blcok_status(aml_chip, chipnr, blk_addr, value);
+		if (ret == 0) {
+			for (chipnr = 0;
+				chipnr < controller->chip_num;
+				chipnr++) {
+				ret = set_blcok_status(aml_chip,
+					chipnr,
+					blk_addr,
+					value);
+				if (ret != 0)
+					break;
+				if ((blk_addr % 2) == 0) {
+					/* plane 0 is good , check plane 1 */
+					ret = set_blcok_status(aml_chip,
+						chipnr,
+						(blk_addr+1),
+						value);
+					if (ret != 0)
+						break;
+				} else {/* plane 1 is good, check plane 0 */
+					ret = set_blcok_status(aml_chip,
+						chipnr,
+						(blk_addr - 1),
+						value);
+					if (ret != 0)
+						break;
+				}
+			}
+		}
+	} else
+		ret = set_blcok_status(aml_chip, chipnr, blk_addr, value);
+
+	return ret;
+}
+
+
+/************************************************************
+ *  all parameters saved in aml_chip->ops_para.
+ * for opteration mode, contains multi-plane/multi-chip
+ * supposed chip bbt has been installed
+ *
+ *************************************************************/
+static int update_bbt_chip_op(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	/* struct chip_operation *operation = & aml_chip->operation; */
+
+	/* u8 chip_num = 1; */
+	/* u16 * tmp_status; */
+	int ret;
+#if 0
+	if (ops_para->option & DEV_MULTI_CHIP_MODE)
+		chip_num = controller->chip_num;
+#endif
+
+	//blk_addr = ops_para->page_addr >> pages_per_blk_shift;
+	//chipnr = ops_para->chipnr;
+	if (unlikely(controller->page_addr >= controller->internal_page_nums)) {
+		controller->page_addr -=
+			controller->internal_page_nums;
+		controller->page_addr |= controller->internal_page_nums *
+			aml_chip->flash.internal_chipnr;
+	}
+
+	aml_nand_msg("###nand update start!!!!\n");
+
+	ret = amlnand_update_bbt(aml_chip);
+	if (ret < 0)
+		aml_nand_msg("nand update bbt failed");
+
+	return ret;
+}
+
+/************************************************************
+ * get_onfi_features, for onfi feature operation
+ *
+ *************************************************************/
+static int get_onfi_features(struct amlnand_chip *aml_chip,
+	u8 *buf, int addr)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	int i, j;
+
+	for (i = 0; i < controller->chip_num; i++) {
+		controller->select_chip(controller, i);
+		controller->cmd_ctrl(controller, NAND_CMD_GET_FEATURES,
+			NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, addr, NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+		NFC_SEND_CMD_IDLE(controller, 0);
+
+		for (j = 0; j < 4; j++)
+			buf[j] = controller->readbyte(controller);
+	}
+
+	return 0;
+}
+
+/************************************************************
+ * set_onfi_features, for onfi feature operation
+ *
+ *************************************************************/
+static int set_onfi_features(struct amlnand_chip *aml_chip,
+	u8 *buf,
+	int addr)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	int i, j;
+	int time_out_cnt = 0;
+
+	for (i = 0; i < controller->chip_num; i++) {
+		controller->select_chip(controller, i);
+		controller->cmd_ctrl(controller, NAND_CMD_SET_FEATURES,
+			NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, addr, NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, NAND_TADL_TIME_CYCLE);
+		NFC_SEND_CMD_IDLE(controller, 0);
+
+		for (j = 0; j < 4; j++)
+			controller->writebyte(controller, buf[j]);
+
+		/*
+		NFC_SEND_CMD_RB(controller, controller->chip_selected, 20);
+		*/
+		do {
+			if (NFC_CMDFIFO_SIZE(controller) <= 0)
+				break;
+			udelay(2);
+		} while (time_out_cnt++ <= AML_NAND_READ_BUSY_TIMEOUT);
+
+		if (time_out_cnt >= AML_NAND_READ_BUSY_TIMEOUT)
+			return -NAND_BUSY_FAILURE;
+	}
+
+	return NAND_SUCCESS;
+}
+
+/************************************************************
+ * nand_reset, send reset command, and assume nand selected here
+ *
+ *************************************************************/
+int nand_reset(struct amlnand_chip *aml_chip, u8 chipnr)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	int status;
+
+	/* fixme, read back controller status. */
+
+	/* reset */
+	NFC_SEND_CMD_IDLE(controller, 0);
+	controller->cmd_ctrl(controller, NAND_CMD_RESET, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	NFC_SEND_CMD_IDLE(controller, 0);
+
+	/* read status */
+	/* controller->cmd_ctrl(controller, NAND_CMD_STATUS, NAND_CTRL_CLE); */
+	/* NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE); */
+
+	/* NFC_SEND_CMD_IDLE(controller, 0); */
+
+	if (controller->quene_rb(controller, chipnr) < 0) {
+		aml_nand_dbg("quene rb failed here");
+		return -NAND_BUSY_FAILURE;
+	}
+
+	controller->cmd_ctrl(controller, NAND_CMD_STATUS, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+	NFC_SEND_CMD_IDLE(controller, 0);
+	NFC_SEND_CMD_IDLE(controller, 0);
+
+	while (NFC_CMDFIFO_SIZE(controller))
+		;
+
+	status = (int)controller->readbyte(controller);
+	if (status & NAND_STATUS_READY)
+		return NAND_SUCCESS;
+
+	aml_nand_dbg("check status failed and status:0x%x", status);
+
+	return -NAND_BUSY_FAILURE;
+}
+
+/************************************************************
+ * read_id
+ * @id_addr: for 00H and 20H;
+ * @buf: chip id stored into buf;
+ *************************************************************/
+static int read_id(struct amlnand_chip *aml_chip, u8 chipnr,
+	u8 id_addr,
+	u8 *buf)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	int i, ret = 0;
+
+	if (buf == NULL) {
+		aml_nand_msg("buf must not be NULL here");
+		ret = -NAND_ARGUMENT_FAILURE;
+		goto error_exit0;
+	}
+
+	ret = controller->select_chip(controller, chipnr);
+	if (ret < 0) {
+		aml_nand_msg("select chip %d failed", chipnr);
+		goto error_exit0;
+	}
+
+	ret = nand_reset(aml_chip, chipnr);
+	if (ret < 0) {
+		if (chipnr == 0)
+			aml_nand_msg("reset failed");
+		else
+			aml_nand_dbg("reset failed");
+		goto error_exit0;
+	}
+
+	/* send id cmd */
+	controller->cmd_ctrl(controller, NAND_CMD_READID, NAND_CTRL_CLE);
+	controller->cmd_ctrl(controller, id_addr, NAND_CTRL_ALE);
+	NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+	NFC_SEND_CMD_IDLE(controller, 0);
+
+	/* Read manufacturer and device IDs */
+	for (i = 0; i < MAX_ID_LEN; i++)
+		buf[i] = controller->readbyte(controller);
+error_exit0:
+	return ret;
+}
+
+int amlnand_init_operation(struct amlnand_chip *aml_chip)
+{
+	struct chip_operation *operation = &(aml_chip->operation);
+
+	if (!operation->reset)
+		operation->reset = nand_reset;
+	if (!operation->read_id)
+		operation->read_id = read_id;
+	if (!operation->set_onfi_para)
+		operation->set_onfi_para = set_onfi_features;
+	if (!operation->get_onfi_para)
+		operation->get_onfi_para = get_onfi_features;
+
+	if (!operation->check_wp)
+		operation->check_wp = check_wp;
+
+	if (!operation->erase_block)
+		operation->erase_block = erase_block;
+
+	if (!operation->test_block_chip_op)
+		operation->test_block_chip_op = test_block_chip_op;
+
+	if (!operation->test_block_reserved)
+		operation->test_block_reserved = test_block_reserved;
+
+	if (!operation->block_isbad)
+		operation->block_isbad = block_isbad;
+
+	if (!operation->block_markbad)
+		operation->block_markbad = block_markbad;
+
+	if (!operation->read_page)
+		operation->read_page = read_page;
+
+	if (!operation->write_page)
+		operation->write_page = write_page;
+
+	if (!operation->blk_modify_bbt_chip_op)
+		operation->blk_modify_bbt_chip_op = blk_modify_bbt_chip_op;
+
+	if (!operation->update_bbt_chip_op)
+		operation->update_bbt_chip_op = update_bbt_chip_op;
+
+	return NAND_SUCCESS;
+
+}
+
diff --git a/drivers/nand/phy/chipenv.c b/drivers/nand/phy/chipenv.c
new file mode 100644
index 0000000..a7f8782
--- /dev/null
+++ b/drivers/nand/phy/chipenv.c
@@ -0,0 +1,4082 @@
+
+
+#include "../include/phynand.h"
+
+extern  int block_markbad(struct amlnand_chip *aml_chip);
+extern int amlnand_save_info_by_name(struct amlnand_chip *aml_chip,unsigned char * info,unsigned char * buf,unsigned char * name,unsigned size);
+extern int aml_sys_info_error_handle(struct amlnand_chip *aml_chip);
+extern int aml_sys_info_init(struct amlnand_chip *aml_chip);
+extern int aml_nand_update_ubootenv(struct amlnand_chip * aml_chip, char *env_ptr);
+extern int amlnand_get_partition_table(struct amlnand_chip *aml_chip);
+/* fixme, */
+extern int info_disprotect;
+
+#ifndef MAX
+#define MAX(x, y) ((x) > (y) ? (x) : (y))
+#endif /* MAX */
+
+#ifdef AML_NAND_UBOOT
+//extern struct amlnf_partition amlnand_config;
+extern struct amlnf_partition * amlnand_config;
+int get_last_reserve_block(struct amlnand_chip *aml_chip);
+int repair_reserved_bad_block(struct amlnand_chip *aml_chip);
+void show_data_buf(unsigned char *  buf);
+void amlnand_config_buf_free(struct amlnand_chip *aml_chip);
+
+int chipenv_init_erase_protect(struct amlnand_chip *aml_chip, int flag,int block_num)
+{
+	int ret = 0,start_blk = 0;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct hw_controller *controller = &aml_chip->controller;
+	struct read_retry_info *retry_info = &(controller->retry_info);
+
+	int phys_erase_shift = ffs(flash->blocksize) - 1;
+	start_blk =  (1024 * flash->pagesize) >> phys_erase_shift;
+	block_num  -= (controller->chip_num - 1) * start_blk;
+
+	if ((flag > NAND_BOOT_UPGRATE) && (flag <= NAND_BOOT_SCRUB_ALL)) {
+
+		/*liang:make sure fbbt and bbt are ok, don't erase forever!!!*/
+		if ((block_num == aml_chip->shipped_bbtinfo.valid_blk_addr) && (aml_chip->shipped_bbtinfo.valid_blk_addr >= start_blk)) {
+			aml_nand_msg("protect fbbt at blk %d",block_num);
+			ret = -1;
+		}else if((block_num == aml_chip->nand_bbtinfo.valid_blk_addr)&&(aml_chip->nand_bbtinfo.valid_blk_addr >= start_blk)){
+			aml_nand_msg("protect nand_bbt info at blk %d",block_num);
+			ret = -1;
+		}else if(((block_num == retry_info->info_save_blk)&&(retry_info->info_save_blk >= start_blk)&&(flash->new_type)&&(flash->new_type < 10))&&(!(info_disprotect & DISPROTECT_HYNIX))){
+			aml_nand_msg("protect hynix retry info at blk %d", block_num);
+			ret = -1;
+		}else if((block_num == aml_chip->nand_key.valid_blk_addr)&&(aml_chip->nand_key.valid_blk_addr >= start_blk)&&(!(info_disprotect & DISPROTECT_KEY))){
+			aml_nand_msg("protect nand_key info at blk %d",block_num);
+			ret = -1;
+		}else if((block_num == aml_chip->nand_secure.valid_blk_addr)&&(aml_chip->nand_secure.valid_blk_addr >= start_blk)&&(!(info_disprotect & DISPROTECT_SECURE))){
+			aml_nand_msg("protect nand_secure info at blk %d",block_num);
+			ret = -1;
+		}else{
+			ret = 0;
+		}
+	}
+
+	return ret;
+}
+
+#if (AML_CFG_DTB_RSV_EN)
+extern int dtb_erase_blk;
+int bad_block_is_dtb_blk( const int blk_addr)
+{
+	if (dtb_erase_blk == blk_addr && dtb_erase_blk != -1) {
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+/***
+*erase whole nand as scrub
+* start_blk = 0; total_blk;
+***/
+/*
+	todo need to add bbt here !!!!!!
+*/
+static int amlnand_oops_handle(struct amlnand_chip *aml_chip, int flag)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct nand_flash *flash = &(aml_chip->flash);
+
+	uint64_t  erase_len;
+	unsigned erase_shift, write_shift, pages_per_blk;
+	int  start_blk,total_blk, ret = 0;
+	int percent=0, percent_complete = -1;
+	unsigned char *buf = NULL;
+	unsigned int buf_size = MAX(CONFIG_SECURE_SIZE, CONFIG_KEYSIZE);
+	int last_reserve_blk;
+	buf = aml_nand_malloc(buf_size);
+	if (!buf) {
+	  aml_nand_msg("%s() %d: malloc failed", __FUNCTION__, __LINE__);
+	}
+	memset(buf,0x0,buf_size);
+
+	/* fixme, should not exit here, 20150801 */
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+	if (ret < 0) {
+		aml_nand_msg("%s() %d invalid nand key\n", __FUNCTION__, __LINE__);
+		goto exit_error0;
+	}
+
+#ifdef CONFIG_SECURE_NAND
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_secure),buf,(unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("invalid nand secure_ptr\n");
+		goto exit_error0;
+	}
+#endif
+
+	erase_shift = ffs(flash->blocksize) - 1;
+	write_shift =  ffs(flash->pagesize) - 1;
+	erase_len = ((uint64_t)(flash->chipsize*controller->chip_num))<<20;
+
+	start_blk = 0;
+	total_blk = (int)(erase_len >> erase_shift);
+	pages_per_blk = (1 << (erase_shift -write_shift));
+
+	aml_nand_msg("start_blk =%d,total_blk=%d",start_blk, total_blk);
+
+	if (flag == NAND_BOOT_ERASE_PROTECT_CACHE) {
+		start_blk = (1024 * flash->pagesize) >> erase_shift;
+		total_blk = get_last_reserve_block(aml_chip);
+		aml_nand_msg("start_blk =%d,total_blk=%d",start_blk, total_blk);
+	}
+	last_reserve_blk = get_last_reserve_block(aml_chip);
+	for (;start_blk< total_blk; start_blk++) {
+		memset((unsigned char *)ops_para, 0x0, sizeof(struct chip_ops_para));
+		ops_para->page_addr =(((start_blk - start_blk % controller->chip_num) /controller->chip_num)) * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		ret = operation->block_isbad(aml_chip);
+		if (ret ) {
+			aml_nand_msg("bad block skipping!!!!0x%x",start_blk);
+			//fixme, check is dtb, if dtb ,erase it!
+			if (start_blk < last_reserve_blk && bad_block_is_dtb_blk(start_blk)) {
+				aml_nand_msg("bad block dtb is dtb block:0x%x,not skipping",start_blk);
+			}
+			else {
+				continue;
+			}
+		}	//check bbt
+
+
+		ret = chipenv_init_erase_protect(aml_chip,flag,start_blk);
+		if (ret) {
+			aml_nand_msg("chipenv block skipping!!!!!!!0x%x", start_blk);
+			continue;
+		}
+
+		nand_get_chip(aml_chip);
+		ret = operation->erase_block(aml_chip);
+		nand_release_chip(aml_chip);
+		/*need to mark bad block*/
+		if (ret) {
+			aml_nand_msg("erase fail, marking badblock!!!!!!!0x%x", start_blk);
+			ret = operation->block_markbad(aml_chip);
+			if (ret < 0) {
+				/*
+				todo need to add bbt here !!!!!!
+				*/
+			}
+			//continue;
+		}else{
+
+			if (aml_chip->init_flag > 3) {
+#ifdef	SORTING_BAD_BLOCK_D
+				if (flash->new_type == HYNIX_1YNM) {
+					memset((unsigned char *)ops_para, 0x0, sizeof(struct chip_ops_para));
+					ops_para->page_addr =(((start_blk - start_blk % controller->chip_num) /controller->chip_num)) * pages_per_blk;
+					ops_para->chipnr = start_blk % controller->chip_num;
+					if (start_blk > 4) {
+						nand_get_chip(aml_chip);
+						//aml_nand_msg("test block starting!!!!!!!0x%x", ops_para->page_addr);
+						ret = operation->test_block(aml_chip);
+						nand_release_chip(aml_chip);
+						if (ret < 0) {
+							memset((unsigned char *)ops_para, 0x0, sizeof(struct chip_ops_para));
+							ops_para->page_addr =(((start_blk - start_blk % controller->chip_num) /controller->chip_num)) * pages_per_blk;
+							ops_para->chipnr = start_blk % controller->chip_num;
+							aml_nand_msg("test block fail, marking badblock!!!!!!!0x%x", start_blk);
+							ret = operation->block_markbad(aml_chip);
+						}
+					}
+				}
+#endif
+			}
+		}
+		percent = (start_blk * 100) / total_blk;
+
+		if ((percent != percent_complete) && ((percent %10) == 0)) {
+				percent_complete = percent;
+				aml_nand_msg("nand erasing %d %% --%d %% complete",percent,percent+10);
+		}
+	}
+exit_error0:
+	if (buf) {
+		kfree(buf);
+		buf = NULL;
+	}
+	return ret;
+}
+
+int  phrase_driver_version(unsigned int cp, unsigned int cmp)
+{
+	int ret=0;
+
+	if (((cp >> 24)&0xff) != ((cp >> 24)&0xff)) {
+		ret = -1;
+	}
+	if (((cp >> 16)&0xff)!= ((cp >> 16)&0xff)) {
+		ret = -1;
+	}
+	return ret;
+}
+
+
+void reset_amlchip_member(struct amlnand_chip *aml_chip)
+{
+	memset(aml_chip->reserved_blk, 0xff, RESERVED_BLOCK_CNT);
+	memset(&aml_chip->nand_bbtinfo,0x0,sizeof(struct nand_arg_info));
+	memset(&aml_chip->shipped_bbtinfo,0x0,sizeof(struct nand_arg_info));
+	memset(&aml_chip->nand_key,0x0,sizeof(struct nand_arg_info));
+	memset(&aml_chip->nand_secure,0x0,sizeof(struct nand_arg_info));
+	memset(&aml_chip->config_msg,0x0,sizeof(struct nand_arg_info));
+}
+#endif /* AML_NAND_UBOOT */
+
+static u32 aml_info_checksum(u8 *data, int lenth)
+{
+	u32 checksum;
+	u8 *pdata;
+	int i;
+
+	checksum = 0;
+	pdata = (u8 *)data;
+
+	for (i = 0; i < lenth; i++)
+		checksum += pdata[i];
+
+	return checksum;
+}
+
+static int aml_info_check_datasum(void *data, u8 *name)
+{
+	int ret = 0;
+	u32 crc = 0;
+	struct block_status *blk_status = NULL;
+	struct shipped_bbt *bbt = NULL;
+	struct nand_config *config = NULL;
+
+	if (!memcmp(name, BBT_HEAD_MAGIC, 4)) {
+		blk_status = (struct block_status *)data;
+		crc = blk_status->crc;
+		if (aml_info_checksum((u8 *)(blk_status->blk_status),
+			(MAX_CHIP_NUM*MAX_BLK_NUM)) != crc) {
+			aml_nand_msg("%s :nand bbt bad crc error", __func__);
+			ret = -NAND_READ_FAILED;
+		}
+	}
+
+	if (!memcmp(name, SHIPPED_BBT_HEAD_MAGIC, 4)) {
+		bbt = (struct shipped_bbt *)data;
+		crc = bbt->crc;
+		if (aml_info_checksum((u8 *)(bbt->shipped_bbt),
+			(MAX_CHIP_NUM*MAX_BAD_BLK_NUM)) != crc) {
+			aml_nand_msg("%s : nand shipped bbt  bad crc error",
+				__func__);
+			ret = -NAND_READ_FAILED;
+		}
+	}
+
+	if (!memcmp(name, CONFIG_HEAD_MAGIC, 4)) {
+		config = (struct nand_config *)data;
+		crc = config->crc;
+		if (aml_info_checksum((u8 *)(config->dev_para),
+			(MAX_DEVICE_NUM*sizeof(struct dev_para))) != crc) {
+			aml_nand_msg("%s : nand check config crc error",
+				__func__);
+			ret = -NAND_READ_FAILED;
+		}
+	}
+	/* others do not checksum at all. */
+	return ret;
+}
+
+int amlnand_free_block_test(struct amlnand_chip *aml_chip, int start_blk)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct chip_operation *operation = & aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	char block_invalid = 0;
+
+	u8 phys_erase_shift, phys_page_shift, nand_boot;
+	u32 offset, pages_per_blk, pages_read;
+	u8  oob_buf[8];
+	u16  tmp_blk;
+	int  ret = 0, t = 0;
+	u32 tmp_value;
+
+	u8 *dat_buf = NULL;
+
+	dat_buf  = aml_nand_malloc(flash->pagesize);
+	if (!dat_buf) {
+		aml_nand_msg("amlnand_free_block_test : malloc failed");
+		block_invalid = 1;
+		ret =  -1;
+		goto exit;
+	}
+	memset(dat_buf, 0xa5, flash->pagesize);
+
+	nand_boot = 1;
+
+	/*
+	if (boot_device_flag == 0)
+		nand_boot = 0;
+	*/
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+
+	tmp_blk = (offset >> phys_erase_shift);
+
+	if ((flash->new_type) && ((flash->new_type < 10)
+		|| (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+
+	if (ops_para->option & DEV_SLC_MODE)
+		pages_read = pages_per_blk >> 1;
+	else
+		pages_read = pages_per_blk;
+
+#ifdef AML_NAND_UBOOT
+	nand_get_chip(aml_chip);
+#else
+	if (aml_chip->state == CHIP_READY)
+		nand_get_chip(aml_chip);
+#endif
+
+	/* erase */
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	tmp_value = start_blk - start_blk % controller->chip_num;
+	tmp_value /= controller->chip_num;
+	tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+	ops_para->page_addr =  tmp_value * pages_per_blk;
+	ops_para->chipnr = start_blk % controller->chip_num;
+	controller->select_chip(controller, ops_para->chipnr);
+	ret = operation->erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand blk %d check good but erase failed",
+			start_blk);
+		block_invalid = 1;
+		ret =  -1;
+		goto exit;
+	}
+
+	/* write */
+	for (t = 0; t < pages_read; t++) {
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		if ((flash->new_type) && ((flash->new_type < 10)
+			|| (flash->new_type == SANDISK_19NM)))
+			ops_para->option |= DEV_SLC_MODE;
+		tmp_value = start_blk - start_blk % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = (t + tmp_value * pages_per_blk);
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		if ((ops_para->option & DEV_SLC_MODE)) {
+			tmp_value = ~(pages_per_blk - 1);
+			tmp_value &= ops_para->page_addr;
+			if ((flash->new_type > 0) && (flash->new_type < 10))
+				ops_para->page_addr = tmp_value |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+			if (flash->new_type == SANDISK_19NM)
+				ops_para->page_addr = tmp_value |
+				((ops_para->page_addr % pages_per_blk) << 1);
+		}
+
+
+		memset( aml_chip->user_page_buf, 0xa5, flash->pagesize);
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		ret = operation->write_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("%s() %d: nand write failed", __func__, __LINE__);
+			block_invalid = 1;
+			ret =  -1;
+			goto exit;
+		}
+	}
+	/* read */
+	for (t = 0; t < pages_read; t++) {
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		if ((flash->new_type) && ((flash->new_type < 10)
+			|| (flash->new_type == SANDISK_19NM)))
+			ops_para->option |= DEV_SLC_MODE;
+		tmp_value = start_blk - start_blk % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = (t + tmp_value * pages_per_blk);
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		if ((ops_para->option & DEV_SLC_MODE)) {
+			tmp_value = ~(pages_per_blk - 1);
+			tmp_value &= ops_para->page_addr;
+			if ((flash->new_type > 0) && (flash->new_type < 10))
+				ops_para->page_addr = tmp_value |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+			if (flash->new_type == SANDISK_19NM)
+				ops_para->page_addr = tmp_value |
+				((ops_para->page_addr % pages_per_blk) << 1);
+		}
+
+		memset(aml_chip->user_page_buf, 0x0, flash->pagesize);
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		ret = operation->read_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand write failed, %d", block_invalid);
+			block_invalid = 1;
+
+			ret =  -1;
+			goto exit;
+		}
+		aml_nand_dbg("start_blk %d aml_chip->user_page_buf: ",
+			start_blk);
+		/* show_data_buf(aml_chip->user_page_buf); */
+		aml_nand_dbg("start_blk %d dat_buf: ", start_blk);
+		/* show_data_buf(dat_buf); */
+		if (memcmp(aml_chip->user_page_buf,
+			dat_buf,
+			flash->pagesize)) {
+			block_invalid = 1;
+			ret =  -1;
+			aml_nand_msg("free blk  %d,  page %d : test failed",
+				start_blk,
+				t);
+			goto exit;
+		}
+	}
+
+exit:
+
+#ifdef AML_NAND_UBOOT
+	nand_release_chip(aml_chip);
+#else
+	if (aml_chip->state == CHIP_READY)
+		nand_release_chip(aml_chip);
+#endif
+
+	if (dat_buf) {
+		aml_nand_free(dat_buf);
+		dat_buf = NULL;
+	}
+
+	if (!ret)
+		aml_nand_msg("free blk start_blk %d test OK", start_blk);
+
+	return ret;
+}
+
+int get_last_reserve_block(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct nand_flash *flash = &aml_chip->flash;
+
+	u32 offset, start_blk, blk_addr, tmp_blk, pages_per_blk;
+	u8 phys_erase_shift, phys_page_shift;
+	int  ret = 0;
+	u32 tmp_value;
+	static u32 total_blk = 0, scan_flag = 0;
+	if ((total_blk > RESERVED_BLOCK_CNT) && (scan_flag == 1)) {
+		aml_nand_msg("total_blk:%d",total_blk);
+		return total_blk;
+	}
+	if (aml_chip->nand_bbtinfo.arg_valid) {
+		scan_flag = 1;
+	}
+	offset = (1024 * flash->pagesize);
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+	start_blk = (offset >> phys_erase_shift);
+	tmp_blk = total_blk = start_blk;
+
+	blk_addr = 0;
+	/* decide the total block_addr */
+	while (blk_addr < RESERVED_BLOCK_CNT) {
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		tmp_value = total_blk - total_blk % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = tmp_value * pages_per_blk;
+		ops_para->chipnr = total_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		ret = operation->block_isbad(aml_chip);
+		if (ret ==  NAND_BLOCK_FACTORY_BAD) {
+			aml_nand_msg("blk %d is shipped bad block ",
+				total_blk);
+			total_blk++;
+			continue;
+		}
+		total_blk++;
+		blk_addr++;
+	}
+
+	return total_blk;
+}
+
+int repair_reserved_bad_block(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct nand_flash *flash = &aml_chip->flash;
+	u32 offset, start_blk, total_blk, blk_addr, tmp_blk;
+	u32 pages_per_blk, blk_used_bad_cnt = 0;
+	u8 phys_erase_shift, phys_page_shift;
+	int  ret = 0, i = 0, j = 0;
+	u32 bad_blk[128];
+	u8 *dat_buf = NULL;
+	u8 *oob_buf = NULL;
+	u32 tmp_value;
+
+	memset(bad_blk, 0, 128*sizeof(u32));
+	offset = (1024 * flash->pagesize);
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+	start_blk = (offset >> phys_erase_shift);
+	tmp_blk = total_blk = start_blk;
+
+	dat_buf  = aml_nand_malloc(flash->pagesize);
+	if (!dat_buf) {
+		aml_nand_msg("amlnand_free_block_test : malloc failed");
+		ret = -1;
+		return ret;
+	}
+
+	memset(dat_buf, 0, flash->pagesize);
+	oob_buf  = aml_nand_malloc(flash->oobsize);
+	if (!oob_buf) {
+		aml_nand_msg("amlnand_free_block_test : malloc failed");
+		ret = -1;
+		kfree(dat_buf);
+
+		return ret;
+	}
+	memset(oob_buf, 0, flash->oobsize);
+
+	blk_addr = 0;
+	/* decide the total block_addr */
+	while (blk_addr < RESERVED_BLOCK_CNT) {
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		tmp_value = total_blk - total_blk % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = tmp_value * pages_per_blk;
+		ops_para->chipnr = total_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		ret = operation->block_isbad(aml_chip);
+		if (ret ==  NAND_BLOCK_FACTORY_BAD) {
+			aml_nand_msg("blk %d is shipped bad block ",
+				total_blk);
+			total_blk++;
+			continue;
+		}
+		if (ret == NAND_BLOCK_USED_BAD) {
+			if (blk_used_bad_cnt < 128) {
+				bad_blk[blk_used_bad_cnt] = total_blk;
+				blk_used_bad_cnt++;
+			}
+		}
+		total_blk++;
+		blk_addr++;
+	}
+
+	if (blk_used_bad_cnt > 6) {
+		nand_get_chip(aml_chip);
+		aml_nand_msg("repair badblk of reserved,blk_used_bad_cnt=%d\n",
+			blk_used_bad_cnt);
+		for (i = 0; i < blk_used_bad_cnt; i++) {
+			memset((u8 *)ops_para,
+				0x0,
+				sizeof(struct chip_ops_para));
+			tmp_value = bad_blk[i]-bad_blk[i]%controller->chip_num;
+			tmp_value /= controller->chip_num;
+			tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+			ops_para->page_addr = tmp_value * pages_per_blk;
+			ops_para->chipnr = bad_blk[i] % controller->chip_num;
+			controller->select_chip(controller, ops_para->chipnr);
+			ret = operation->blk_modify_bbt_chip_op(aml_chip, 0);
+			/* erase */
+			ret = operation->erase_block(aml_chip);
+			if (ret) {
+				ret = operation->blk_modify_bbt_chip_op(
+					aml_chip,
+					1);
+				aml_nand_msg("test blk %d fail\n", bad_blk[i]);
+				continue;
+			}
+			/* write */
+			ops_para->page_addr = tmp_value * pages_per_blk;
+			ops_para->data_buf = dat_buf;
+			ops_para->oob_buf = oob_buf;
+			for (j = 0; j < pages_per_blk; j++) {
+				ops_para->page_addr += 1;
+				memset(dat_buf, 0, flash->pagesize);
+				memset(oob_buf, 0, flash->oobsize);
+				ret = operation->write_page(aml_chip);
+				if (ret) {
+					ops_para->page_addr =
+						tmp_value * pages_per_blk;
+					ret =
+					operation->blk_modify_bbt_chip_op(
+						aml_chip, 1);
+					aml_nand_msg("test blk %d fail\n",
+						bad_blk[i]);
+					goto write_read_fail;
+				}
+			}
+			/* read */
+			ops_para->page_addr = tmp_value * pages_per_blk;
+			ops_para->data_buf = dat_buf;
+			ops_para->oob_buf = oob_buf;
+			for (j = 0; j < pages_per_blk; j++) {
+				ops_para->page_addr += 1;
+				memset(dat_buf, 0, flash->pagesize);
+				memset(oob_buf, 0, flash->oobsize);
+				ret = operation->read_page(aml_chip);
+				if ((ops_para->ecc_err) || (ret < 0)) {
+					ops_para->page_addr =
+						tmp_value * pages_per_blk;
+					ret =
+					operation->blk_modify_bbt_chip_op(
+						aml_chip, 1);
+					aml_nand_msg("test blk %d fail\n",
+						bad_blk[i]);
+					goto write_read_fail;
+				}
+			}
+			/* erase */
+			ops_para->page_addr = tmp_value * pages_per_blk;
+			ret = operation->erase_block(aml_chip);
+			if (ret) {
+				ret = operation->blk_modify_bbt_chip_op(
+					aml_chip, 1);
+				aml_nand_msg("test blk %d fail\n", bad_blk[i]);
+				continue;
+			}
+			aml_nand_msg("test blk %d OK\n", bad_blk[i]);
+write_read_fail:
+			;
+		}
+		nand_release_chip(aml_chip);
+		amlnand_update_bbt(aml_chip);
+	}
+	kfree(dat_buf);
+
+	kfree(oob_buf);
+
+	return total_blk;
+}
+/*****************************************************************************
+*Name         :amlnand_get_free_block
+*Description :search a good block by skip the shipped bad block
+*Parameter  :
+*Return       :
+*Note          :
+*****************************************************************************/
+int amlnand_get_free_block(struct amlnand_chip *aml_chip, u32 block)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct nand_flash *flash = &aml_chip->flash;
+
+	u32 offset, nand_boot, start_blk, total_blk;
+	u32 blk_addr, tmp_blk, pages_per_blk;
+	u8 phys_erase_shift, phys_page_shift;
+	u8  blk_used_flag = 0;
+	int  ret = 0, i;
+	u32 tmp_value;
+
+	nand_boot = 1;
+
+	/*if(boot_device_flag == 0) {
+		nand_boot = 0;
+	}*/
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+	start_blk = (offset >> phys_erase_shift);
+	tmp_blk = total_blk = start_blk;
+
+	total_blk = get_last_reserve_block(aml_chip);
+	blk_addr = 0;
+
+	while ((blk_addr < 1) && (start_blk < total_blk)) {
+		for (i = 0; i < RESERVED_BLOCK_CNT;  i++) {
+			if (aml_chip->reserved_blk[i] == start_blk) {
+				/*
+				aml_nand_msg("nand blk %d is used", start_blk);
+				*/
+				blk_used_flag = 1;
+				break;
+			} else
+				blk_used_flag = 0;
+		}
+
+		if (blk_used_flag) {
+			start_blk++;
+			continue;
+		}
+
+		if (block == start_blk) {
+			start_blk++;
+			continue;
+		}
+
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		tmp_value = start_blk - start_blk % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = tmp_value * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		ret = operation->block_isbad(aml_chip);
+		if (ret == NAND_BLOCK_FACTORY_BAD) {
+			aml_nand_msg("blk %d is shipped bad block ",
+				start_blk);
+			start_blk++;
+			continue;
+		}
+		if (ret == NAND_BLOCK_USED_BAD) {
+			aml_nand_msg("blk %d is used bad block ",
+				start_blk);
+			start_blk++;
+			continue;
+		}
+		/*
+		ret = amlnand_free_block_test(aml_chip, start_blk);
+		if (ret) {
+			aml_nand_msg("nand get free block  %d invalid",
+				start_blk);
+			start_blk++;
+			continue;
+		}*/
+
+		if (aml_chip->state == CHIP_READY)
+			nand_get_chip(aml_chip);
+		ret = operation->erase_block(aml_chip);
+		if (aml_chip->state == CHIP_READY)
+			nand_release_chip(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand blk %d check good but erase failed",
+				start_blk);
+			ret = operation->block_markbad(aml_chip);
+			start_blk++;
+			continue;
+		} else
+			aml_nand_dbg("nand get free block at %d", start_blk);
+
+		blk_addr++;
+	}
+
+	if (start_blk >= total_blk) {
+		ret = -NAND_BAD_BLCOK_FAILURE;
+		aml_nand_msg("nand can not find free block");
+	}
+
+	return (ret == 0) ? start_blk : ret;
+}
+
+void amlnand_info_error_handle(struct amlnand_chip *aml_chip)
+{
+	struct nand_arg_info *nand_bbt = &aml_chip->nand_bbtinfo;
+	struct nand_arg_info *nand_config = &aml_chip->config_msg;
+	int ret = 0;
+
+	if ((nand_bbt->arg_valid) && (nand_bbt->update_flag)) {
+		/* aml_nand_msg("amlnand_info_error_handle : update bbt"); */
+		ret = amlnand_update_bbt(aml_chip);
+		nand_bbt->update_flag = 0;
+		aml_nand_msg("NAND UPDATE CKECK : arg %s:", "bbt");
+		aml_nand_msg("arg_valid=%d,valid_blk_addr=%d,valid_pg_addr=%d",
+			nand_bbt->arg_valid,
+			nand_bbt->valid_blk_addr,
+			nand_bbt->valid_page_addr);
+		if (ret) {
+			aml_nand_msg("%s: nand update bbt failed", __func__);
+			return;
+		}
+	}
+
+	if ((nand_config->arg_valid) && (nand_config->update_flag)) {
+		/*
+		aml_nand_msg("amlnand_info_error_handle : update nand config");
+		*/
+		aml_chip->config_ptr->crc =
+			aml_info_checksum(
+			(u8 *)(aml_chip->config_ptr->dev_para),
+			(MAX_DEVICE_NUM*sizeof(struct dev_para)));
+		 ret = amlnand_save_info_by_name(aml_chip,
+			(u8 *) &(aml_chip->config_msg),
+			(u8 *)aml_chip->config_ptr,
+			(u8 *)CONFIG_HEAD_MAGIC,
+			sizeof(struct nand_config));
+		nand_config->update_flag = 0;
+		aml_nand_msg("NAND UPDATE CKECK: arg %s:", "config");
+		aml_nand_msg("arg_valid=%d,valid_blk_addr=%d,valid_pg_addr=%d",
+			nand_config->arg_valid,
+			nand_config->valid_blk_addr,
+			nand_config->valid_page_addr);
+		if (ret < 0) {
+			aml_nand_msg("save nand dev_configs failed and ret:%d",
+				ret);
+			return;
+		}
+	}
+
+	return;
+}
+int amlnand_erase_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *name)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct nand_arg_info *arg_info = (struct nand_arg_info *)info;
+
+	u8 phys_erase_shift, phys_page_shift, nand_boot;
+	u32 offset;
+	u32 pages_per_blk;
+	u8 oob_buf[sizeof(struct nand_arg_oobinfo)];
+	u16 start_blk, tmp_blk;
+	int  ret = 0;
+	u32 tmp_value;
+
+	nand_boot = 1;
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+
+	if ((flash->new_type)
+		&& ((flash->new_type < 10)
+		|| (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+
+	start_blk = (offset >> phys_erase_shift);
+	tmp_blk = start_blk;
+
+	if (arg_info->arg_valid == 1) {
+
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		if ((flash->new_type)
+			&& ((flash->new_type < 10)
+			|| (flash->new_type == SANDISK_19NM)))
+			ops_para->option |= DEV_SLC_MODE;
+
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+		memset((u8 *)ops_para->data_buf,
+			0x0, flash->pagesize);
+		memset((u8 *)ops_para->oob_buf,
+			0x0, sizeof(oob_buf));
+		/* calculate address */
+		tmp_value = arg_info->valid_blk_addr;
+		tmp_value = tmp_value-tmp_value % controller->chip_num;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+
+		ops_para->page_addr = tmp_value * pages_per_blk;
+		ops_para->chipnr =
+			arg_info->valid_blk_addr % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+#ifdef AML_NAND_UBOOT
+		nand_get_chip(aml_chip);
+#else
+		if (aml_chip->state == CHIP_READY)
+			nand_get_chip(aml_chip);
+#endif	/* AML_NAND_UBOOT */
+		/* erase block ! */
+		ret = operation->erase_block(aml_chip);
+#ifdef AML_NAND_UBOOT
+		nand_release_chip(aml_chip);
+#else
+		if (aml_chip->state == CHIP_READY)
+			nand_release_chip(aml_chip);
+#endif
+		if (ret < 0) {
+			aml_nand_msg("erase arg %s fail,chip%d page=%d",
+				name,
+				ops_para->chipnr,
+				ops_para->page_addr);
+		}
+		arg_info->arg_valid = 0;
+	}
+
+	return ret;
+}
+
+int amlnand_read_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *buf,
+	u8 *name,
+	u32 size)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	struct nand_arg_info *arg_info = (struct nand_arg_info *)info;
+	struct nand_arg_oobinfo *arg_oob_info;
+
+	u8 phys_erase_shift, phys_page_shift, nand_boot;
+	u32 offset, offset_tmp;
+	u32 pages_per_blk, amount_loaded = 0;
+	u8 oob_buf[sizeof(struct nand_arg_oobinfo)];
+	u16 start_blk, tmp_blk;
+	int  ret = 0, len;
+	u32 tmp_value, tmp_index;
+
+	nand_boot = 1;
+
+	/*if(boot_device_flag == 0){
+		nand_boot = 0;
+	}*/
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	arg_oob_info = (struct nand_arg_oobinfo *)oob_buf;
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+
+	if ((flash->new_type)
+		&& ((flash->new_type < 10)
+		|| (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+#if 0
+	if (ops_para->option & DEV_SLC_MODE)
+		pages_read = pages_per_blk >> 1;
+	else
+		pages_read = pages_per_blk;
+#endif //0
+	start_blk = (offset >> phys_erase_shift);
+	tmp_blk = start_blk;
+	/*total_blk = (offset >> phys_erase_shift) + RESERVED_BLOCK_CNT; */
+
+	if (arg_info->arg_valid == 1) {
+		/* load bbt */
+		offset_tmp = 0;
+		while (amount_loaded < size) {
+			memset((u8 *)ops_para,
+				0x0,
+				sizeof(struct chip_ops_para));
+			if ((flash->new_type)
+				&& ((flash->new_type < 10)
+				|| (flash->new_type == SANDISK_19NM)))
+				ops_para->option |= DEV_SLC_MODE;
+
+			ops_para->data_buf = aml_chip->user_page_buf;
+			ops_para->oob_buf = aml_chip->user_oob_buf;
+			ops_para->ooblen = sizeof(oob_buf);
+			memset((u8 *)ops_para->data_buf,
+				0x0, flash->pagesize);
+			memset((u8 *)ops_para->oob_buf,
+				0x0, sizeof(oob_buf));
+
+			tmp_value = arg_info->valid_blk_addr;
+			tmp_value = tmp_value-tmp_value % controller->chip_num;
+			tmp_value /= controller->chip_num;
+			tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+			ops_para->page_addr = (arg_info->valid_page_addr +
+				tmp_value * pages_per_blk) + offset_tmp;
+
+			if ((ops_para->option & DEV_SLC_MODE)) {
+				tmp_value = ~(pages_per_blk - 1);
+				tmp_value &= ops_para->page_addr;
+				if ((flash->new_type > 0)
+					&& (flash->new_type < 10)) {
+					tmp_index = ops_para->page_addr % 256;
+					ops_para->page_addr = tmp_value |
+						slc_info->pagelist[tmp_index];
+				}
+				if (flash->new_type == SANDISK_19NM)
+					ops_para->page_addr = tmp_value |
+						((ops_para->page_addr %
+						pages_per_blk) << 1);
+			}
+
+			ops_para->chipnr =
+				arg_info->valid_blk_addr % controller->chip_num;
+			controller->select_chip(controller, ops_para->chipnr);
+#ifdef AML_NAND_UBOOT
+			nand_get_chip(aml_chip);
+#else
+			if (aml_chip->state == CHIP_READY)
+				nand_get_chip(aml_chip);
+#endif	/* AML_NAND_UBOOT */
+			ret = operation->read_page(aml_chip);
+#ifdef AML_NAND_UBOOT
+		nand_release_chip(aml_chip);
+#else
+		if (aml_chip->state == CHIP_READY)
+			nand_release_chip(aml_chip);
+#endif
+			if ((ops_para->ecc_err) || (ret < 0)) {
+				aml_nand_msg("read arg %s fail,chip%d page=%d",
+					name,
+					ops_para->chipnr,
+					ops_para->page_addr);
+				goto exit_error0;
+			}
+
+			memcpy((u8 *)arg_oob_info,
+				aml_chip->user_oob_buf,
+				sizeof(oob_buf));
+			if (!memcmp(arg_oob_info->name, name, 4)) {
+				len = min(flash->pagesize, size-amount_loaded);
+				memcpy(((u8 *)(buf)+amount_loaded),
+					(u8 *)aml_chip->user_page_buf,
+					len);
+			}
+			offset_tmp += 1;
+			amount_loaded += flash->pagesize;
+		}
+	}
+
+	return ret;
+exit_error0:
+	return ret;
+}
+
+int amlnand_save_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *buf,
+	u8 *name,
+	u32 size)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	struct nand_arg_info *arg_info = (struct nand_arg_info *)info;
+	struct nand_arg_oobinfo *arg_oob_info;
+	u32 len, offset, offset_tmp, nand_boot, blk_addr = 0;
+	u32 tmp_blk_addr, amount_saved = 0;
+	u32 pages_per_blk, arg_pages, pages_read;
+	u8 phys_erase_shift, phys_page_shift;
+	u8 oob_buf[sizeof(struct nand_arg_oobinfo)];
+	u16 tmp_blk;
+	u32 tmp_addr, temp_option;
+	u8 temp_ran_mode;
+	int full_page_flag = 0, ret = 0, i, test_cnt = 0;
+	int extra_page = 0, write_page_cnt = 0, temp_page_num = 0;
+	u32 tmp_value, index;
+
+	ENV_NAND_LINE
+	nand_boot = 1;
+
+	/*if(boot_device_flag == 0){
+		nand_boot = 0;
+	}	*/
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+	ENV_NAND_LINE
+	/*printk("aml_chip %p\n", aml_chip);*/
+	/*printk("flash %p, block %d, page %d\n", flash, flash->blocksize, flash->pagesize);*/
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+	aml_nand_msg("%s(), %d", __func__, __LINE__);
+	aml_nand_msg("name %s, size:%d", name, size);
+	arg_pages = ((size>>phys_page_shift) + 1);
+	//aml_nand_msg("arg_pages:%d", arg_pages);
+	if ((size%flash->pagesize) == 0)
+		extra_page = 1;
+	else
+		extra_page = 0;
+	//aml_nand_msg("extra_page:%d", extra_page);
+
+	tmp_blk = (offset >> phys_erase_shift);
+
+	if ((flash->new_type) && ((flash->new_type < 10)
+		|| (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+
+	if (ops_para->option & DEV_SLC_MODE)
+		pages_read = pages_per_blk >> 1;
+	else
+		pages_read = pages_per_blk;
+
+write_again:
+	arg_oob_info = (struct nand_arg_oobinfo *) oob_buf;
+	arg_info->timestamp += 1;
+	arg_oob_info->timestamp = arg_info->timestamp;
+
+	memcpy(arg_oob_info->name, name, 4);
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+#if 0
+	aml_nand_dbg(" buf: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",
+		bbt_ptr[0], bbt_ptr[1], bbt_ptr[2], bbt_ptr[3], bbt_ptr[4],
+		bbt_ptr[5], bbt_ptr[6], bbt_ptr[7], bbt_ptr[8], bbt_ptr[9],
+		bbt_ptr[10], bbt_ptr[11], bbt_ptr[12], bbt_ptr[13],
+		bbt_ptr[14], bbt_ptr[15]);
+
+	aml_nand_dbg(" oob_buf: %x %x %x %x %x %x %x %x",
+		oob_buf[0], oob_buf[1], oob_buf[2], oob_buf[3],
+		oob_buf[4], oob_buf[5], oob_buf[6], oob_buf[7]);
+
+	aml_nand_dbg(" bbt_oob_info: %x %x %x %x %x %x %x %x",
+		bbt_oob_info[0], bbt_oob_info[1], bbt_oob_info[2],
+		bbt_oob_info[3], bbt_oob_info[4], bbt_oob_info[5],
+		bbt_oob_info[6], bbt_oob_info[7]);
+#endif
+
+get_free_blk:
+	/* get new block according to arg_type or update_flag */
+	if ((arg_info->arg_valid)
+		&& (!arg_info->update_flag)
+		&& (arg_info->arg_type == FULL_PAGE)) {
+		if ((arg_info->valid_page_addr + 2 * arg_pages) > pages_read) {
+			ret = amlnand_get_free_block(aml_chip, blk_addr);
+			blk_addr = ret;
+			if (ret < 0) {
+				aml_nand_msg("nand get free blcok failed");
+				ret = -NAND_BAD_BLCOK_FAILURE;
+				goto exit_error0;
+			}
+			aml_nand_dbg("nand get free block  at %d", blk_addr);
+			full_page_flag = 1;
+		} else
+			blk_addr = arg_info->valid_blk_addr;
+	} else {
+		ret = amlnand_get_free_block(aml_chip, blk_addr);
+		blk_addr = ret;
+		aml_nand_msg("%s, %d: new blk %d", __func__, __LINE__, blk_addr);
+		if (ret < 0) {
+			aml_nand_msg("nand get free block failed");
+			ret = -NAND_BAD_BLCOK_FAILURE;
+			goto exit_error0;
+		}
+		aml_nand_dbg("nand get free block  at %d", blk_addr);
+	}
+
+	/* show_data_buf(buf); */
+	if (arg_info->arg_type == FULL_BLK) {
+		for (i = 0; i < pages_read;) {
+			if ((pages_read - i) < arg_pages) {
+				if (flash->new_type == HYNIX_1YNM) {
+					/*
+					for slc mode, if not full block write,
+					need write dummy random data to lock
+					data
+					*/
+					/*
+					write dummy page
+					*/
+					memset((u8 *)ops_para,
+						0x0,
+						sizeof(struct chip_ops_para));
+					ops_para->option |= DEV_SLC_MODE;
+
+					tmp_value = blk_addr;
+					tmp_value /= controller->chip_num;
+					tmp_value += tmp_blk -
+						tmp_blk/controller->chip_num;
+					tmp_value *= pages_per_blk;
+					ops_para->page_addr = tmp_value + i;
+					tmp_value = ~(pages_per_blk - 1);
+					tmp_value &= ops_para->page_addr;
+					index = ops_para->page_addr % 256;
+					ops_para->page_addr = tmp_value |
+						(slc_info->pagelist[index]);
+					ops_para->chipnr =
+						blk_addr % controller->chip_num;
+					controller->select_chip(controller,
+						ops_para->chipnr);
+					ops_para->data_buf =
+						aml_chip->user_page_buf;
+					ops_para->oob_buf =
+						aml_chip->user_oob_buf;
+					ops_para->ooblen = sizeof(oob_buf);
+					memset(aml_chip->user_oob_buf, 0x5a,
+						sizeof(oob_buf));
+					memset(aml_chip->user_page_buf, 0x5a,
+						flash->pagesize);
+				#ifdef AML_NAND_UBOOT
+					nand_get_chip(aml_chip);
+				#else
+					nand_get_chip(aml_chip);
+				#endif
+			aml_nand_msg("dummy random data,i=%d pg_addr=%x",
+						i,
+						ops_para->page_addr);
+					ret = operation->write_page(aml_chip);
+				#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_release_chip(aml_chip);
+				#endif
+
+					/* write dummy page paried */
+					tmp_addr = ops_para->page_addr;
+					temp_ran_mode = controller->ran_mode;
+					temp_option = ops_para->option;
+					controller->ran_mode = 0;
+					ops_para->page_addr += 1;
+			aml_nand_msg("dummy random paired data,i=%d pg_addr=%x",
+						i,
+						ops_para->page_addr);
+					ops_para->option |= DEV_ECC_SOFT_MODE;
+					ops_para->option &=
+						DEV_SERIAL_CHIP_MODE;
+					memset(aml_chip->user_page_buf, 0xff,
+						flash->pagesize);
+					memset(aml_chip->user_oob_buf, 0xff,
+						sizeof(oob_buf));
+				#ifdef AML_NAND_UBOOT
+					nand_get_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_get_chip(aml_chip);
+				#endif
+					ret = operation->write_page(aml_chip);
+				#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_release_chip(aml_chip);
+				#endif
+					controller->ran_mode = temp_ran_mode;
+					ops_para->page_addr = tmp_addr;
+					ops_para->option = temp_option;
+				}
+				break;
+			}
+			offset_tmp = 0;
+			amount_saved = 0;
+			while (amount_saved <
+				(size+extra_page*flash->pagesize)) {
+				memset((u8 *)ops_para, 0x0,
+					sizeof(struct chip_ops_para));
+				if ((flash->new_type)
+					&& ((flash->new_type < 10)
+					|| (flash->new_type == SANDISK_19NM)))
+					ops_para->option |= DEV_SLC_MODE;
+
+				tmp_value = blk_addr;
+				tmp_value /= controller->chip_num;
+				tmp_value += tmp_blk -
+					tmp_blk/controller->chip_num;
+				tmp_value *= pages_per_blk;
+				tmp_value += offset_tmp + i;
+				ops_para->page_addr = tmp_value;
+
+				if ((ops_para->option & DEV_SLC_MODE)) {
+					tmp_value = ops_para->page_addr;
+					tmp_value &= (~(pages_per_blk - 1));
+					if ((flash->new_type > 0)
+						&& (flash->new_type < 10)) {
+						index =
+						ops_para->page_addr % 256;
+						ops_para->page_addr =
+						tmp_value |
+						(slc_info->pagelist[index]);
+					}
+					if (flash->new_type == SANDISK_19NM) {
+						index = ops_para->page_addr;
+						index %= pages_per_blk;
+						index <<= 0x01;
+						ops_para->page_addr =
+							tmp_value | index;
+					}
+				}
+
+				ops_para->chipnr =
+					blk_addr % controller->chip_num;
+				controller->select_chip(controller,
+					ops_para->chipnr);
+				ops_para->data_buf = aml_chip->user_page_buf;
+				ops_para->oob_buf = aml_chip->user_oob_buf;
+				ops_para->ooblen = sizeof(oob_buf);
+
+				len = min(flash->pagesize,
+					size +
+					extra_page*flash->pagesize -
+					amount_saved);
+				memset(aml_chip->user_page_buf,
+					0x0,
+					flash->pagesize);
+				memset(aml_chip->user_oob_buf,
+					0x0,
+					sizeof(oob_buf));
+				memcpy((u8 *)aml_chip->user_page_buf,
+					((u8 *)(buf) + amount_saved),
+					len);
+				memcpy(aml_chip->user_oob_buf,
+					(u8 *)arg_oob_info,
+					sizeof(oob_buf));
+#if 0
+			aml_nand_dbg("oob_buf:%x %x %x %x %x %x %x %x",
+				ops_para->oob_buf[0], ops_para->oob_buf[1],
+				ops_para->oob_buf[2], ops_para->oob_buf[3],
+				ops_para->oob_buf[4], ops_para->oob_buf[5],
+				ops_para->oob_buf[6], ops_para->oob_buf[7]);
+#endif
+			#ifdef AML_NAND_UBOOT
+				nand_get_chip(aml_chip);
+			#else
+				if (aml_chip->state == CHIP_READY)
+				nand_get_chip(aml_chip);
+			#endif
+				ret = operation->write_page(aml_chip);
+
+
+			#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+			#else
+					if (aml_chip->state == CHIP_READY)
+						nand_release_chip(aml_chip);
+			#endif
+				if (ret < 0) {
+					aml_nand_msg("%s() %d: nand write failed", __func__, __LINE__);
+					if (test_cnt >= 3) {
+						aml_nand_msg("test 3 times");
+						break;
+					}
+				ret = operation->test_block_reserved(aml_chip,
+					blk_addr);
+					test_cnt++;
+			if (ret) {
+				ret = operation->block_markbad(aml_chip);
+				if (ret < 0)
+					aml_nand_msg("nand mark bad blk=%d",
+						blk_addr);
+			}
+					aml_nand_msg("rewrite!");
+					goto get_free_blk;
+				}
+				/*for slc mode*/
+				if (flash->new_type == HYNIX_1YNM) {
+					temp_page_num = offset_tmp + i;
+				if (temp_page_num >= 1) {
+					ops_para->chipnr =
+						blk_addr % controller->chip_num;
+					controller->select_chip(controller,
+						ops_para->chipnr);
+
+					tmp_addr = ops_para->page_addr;
+					temp_ran_mode = controller->ran_mode;
+					temp_option = ops_para->option;
+					controller->ran_mode = 0;
+					ops_para->page_addr += 1;
+					ops_para->option |= DEV_ECC_SOFT_MODE;
+					ops_para->option &=
+						DEV_SERIAL_CHIP_MODE;
+					memset(aml_chip->user_page_buf, 0xff,
+						flash->pagesize);
+					memset(aml_chip->user_oob_buf, 0xff,
+						sizeof(oob_buf));
+				#ifdef AML_NAND_UBOOT
+					nand_get_chip(aml_chip);
+				#else
+						if (aml_chip->state == CHIP_READY)
+							nand_get_chip(aml_chip);
+				#endif
+			aml_nand_msg("normal blk write,pgnum=%d pgaddr=%x",
+						temp_page_num,
+						ops_para->page_addr);
+						ret =
+						operation->write_page(aml_chip);
+				#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_release_chip(aml_chip);
+				#endif
+					controller->ran_mode = temp_ran_mode;
+					ops_para->page_addr = tmp_addr;
+					ops_para->option = temp_option;
+					/*
+					ops_para->option &= DEV_ECC_HW_MODE;
+					*/
+					/* ops_para->option |=DEV_SLC_MODE; */
+				}
+				}
+
+				offset_tmp += 1;
+				amount_saved += flash->pagesize;
+			}
+			i += arg_pages;
+			if (ret < 0)
+				break;
+		}
+	} else if (arg_info->arg_type == FULL_PAGE) {
+		offset_tmp = 0;
+		amount_saved = 0;
+		while (amount_saved < size+extra_page*flash->pagesize) {
+			memset((u8 *)ops_para, 0x0,
+				sizeof(struct chip_ops_para));
+			if ((flash->new_type)
+				&& ((flash->new_type < 10)
+				|| (flash->new_type == SANDISK_19NM)))
+				ops_para->option |= DEV_SLC_MODE;
+			tmp_value = blk_addr;
+			tmp_value /= controller->chip_num;
+			tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+			tmp_value *= pages_per_blk;
+			ops_para->page_addr = tmp_value + offset_tmp;
+			if (arg_info->arg_valid
+				&& (!full_page_flag)
+				&& (!arg_info->update_flag))
+				ops_para->page_addr +=
+					(arg_info->valid_page_addr + arg_pages);
+
+			/*for slc mode*/
+			if (flash->new_type == HYNIX_1YNM) {
+				if (arg_info->arg_valid
+					&& (!full_page_flag)
+					&& (!arg_info->update_flag))
+					ops_para->page_addr += 1;
+					temp_page_num =
+					ops_para->page_addr % 256;
+			}
+
+			if ((ops_para->option & DEV_SLC_MODE)) {
+				tmp_value = ops_para->page_addr;
+				tmp_value &= (~(pages_per_blk - 1));
+				if ((flash->new_type > 0)
+					&& (flash->new_type < 10)) {
+					index = ops_para->page_addr % 256;
+					ops_para->page_addr = tmp_value |
+						(slc_info->pagelist[index]);
+				}
+				if (flash->new_type == SANDISK_19NM) {
+					index = ops_para->page_addr;
+					index %= pages_per_blk;
+					index <<= 0x01;
+					ops_para->page_addr = tmp_value | index;
+				}
+			}
+
+			ops_para->chipnr = blk_addr % controller->chip_num;
+			controller->select_chip(controller, ops_para->chipnr);
+
+			ops_para->data_buf = aml_chip->user_page_buf;
+			ops_para->oob_buf = aml_chip->user_oob_buf;
+			ops_para->ooblen = sizeof(oob_buf);
+
+			len = min(flash->pagesize,
+			size + extra_page*flash->pagesize - amount_saved);
+			memset(aml_chip->user_page_buf, 0x0, flash->pagesize);
+			memset(aml_chip->user_oob_buf, 0x0, sizeof(oob_buf));
+			memcpy((u8 *)aml_chip->user_page_buf,
+				((u8 *)(buf) + amount_saved), len);
+			memcpy(aml_chip->user_oob_buf,
+				(u8 *)arg_oob_info, sizeof(oob_buf));
+
+		#ifdef AML_NAND_UBOOT
+			nand_get_chip(aml_chip);
+		#else
+			if (aml_chip->state == CHIP_READY)
+				nand_get_chip(aml_chip);
+		#endif
+			ret = operation->write_page(aml_chip);
+            //aml_nand_msg("nand write page:%d,chipnr:%d",ops_para->page_addr,ops_para->chipnr);
+#ifdef AML_NAND_UBOOT
+			nand_release_chip(aml_chip);
+#else
+			if (aml_chip->state == CHIP_READY)
+				nand_release_chip(aml_chip);
+#endif
+			if (ret < 0) {
+				aml_nand_msg("%s() %d: nand write failed", __func__, __LINE__);
+				if (test_cnt >= 3) {
+					aml_nand_msg("test blk 3times");
+					break;
+				}
+				ret = operation->test_block_reserved(aml_chip,
+					blk_addr);
+				test_cnt++;
+				if (ret) {
+					ret =
+					operation->block_markbad(aml_chip);
+					if (ret < 0)
+						aml_nand_msg("mark bad blk %d",
+							blk_addr);
+				}
+				goto get_free_blk;
+			}
+
+			/*for slc mode*/
+			if (flash->new_type == HYNIX_1YNM) {
+				if (temp_page_num >= 1) {
+					ops_para->chipnr =
+						blk_addr % controller->chip_num;
+					controller->select_chip(controller,
+						ops_para->chipnr);
+					tmp_addr = ops_para->page_addr;
+					temp_ran_mode = controller->ran_mode;
+					temp_option = ops_para->option;
+					controller->ran_mode = 0;
+					ops_para->page_addr += 1;
+					ops_para->option |= DEV_ECC_SOFT_MODE;
+					ops_para->option &=
+						DEV_SERIAL_CHIP_MODE;
+					memset(aml_chip->user_page_buf, 0xff,
+						flash->pagesize);
+					memset(aml_chip->user_oob_buf, 0xff,
+						sizeof(oob_buf));
+				#ifndef AML_UBOOT_NAND
+					nand_get_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_get_chip(aml_chip);
+				#endif
+					aml_nand_msg("pgnum=%d pgaddr=%x",
+						temp_page_num,
+						ops_para->page_addr);
+					ret = operation->write_page(aml_chip);
+				#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_release_chip(aml_chip);
+				#endif
+					controller->ran_mode = temp_ran_mode;
+					ops_para->page_addr = tmp_addr;
+					ops_para->option = temp_option;
+					/*
+					ops_para->option &= DEV_ECC_HW_MODE;
+					*/
+					/*
+					ops_para->option |=DEV_SLC_MODE;
+					*/
+				}
+			}
+
+			offset_tmp += 1;
+			amount_saved += flash->pagesize;
+
+			if (flash->new_type == HYNIX_1YNM) {
+				if (amount_saved >= size+
+					extra_page*flash->pagesize) {
+					/*
+					for slc mode, if not full block write,
+					need write dummy random data to lock
+					data
+					*/
+					/*
+					write dummy page
+					*/
+					memset((u8 *)ops_para, 0x0,
+						sizeof(struct chip_ops_para));
+					ops_para->option |= DEV_SLC_MODE;
+
+					tmp_value = blk_addr;
+					tmp_value /= controller->chip_num;
+					tmp_value += tmp_blk -
+						tmp_blk/controller->chip_num;
+					tmp_value *= pages_per_blk;
+					ops_para->page_addr =
+						tmp_value + temp_page_num + 1;
+
+					tmp_value = ops_para->page_addr;
+					tmp_value &= (~(pages_per_blk - 1));
+					index = ops_para->page_addr % 256;
+					ops_para->page_addr = tmp_value |
+						(slc_info->pagelist[index]);
+					ops_para->chipnr =
+						blk_addr % controller->chip_num;
+					controller->select_chip(controller,
+						ops_para->chipnr);
+					ops_para->data_buf =
+						aml_chip->user_page_buf;
+					ops_para->oob_buf =
+						aml_chip->user_oob_buf;
+					ops_para->ooblen = sizeof(oob_buf);
+
+					memset(aml_chip->user_page_buf, 0x5a,
+						flash->pagesize);
+					memset(aml_chip->user_oob_buf, 0x5a,
+						sizeof(oob_buf));
+
+					if (aml_chip->state == CHIP_READY)
+						nand_get_chip(aml_chip);
+
+			aml_nand_msg("dummy random data:pgnum=%d pgaddr=%x",
+						temp_page_num,
+						ops_para->page_addr);
+					ret = operation->write_page(aml_chip);
+				#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_release_chip(aml_chip);
+				#endif
+
+					/* write dummy page paried */
+					tmp_addr = ops_para->page_addr;
+					temp_ran_mode = controller->ran_mode;
+					temp_option = ops_para->option;
+					controller->ran_mode = 0;
+					ops_para->page_addr += 1;
+					ops_para->option |= DEV_ECC_SOFT_MODE;
+					ops_para->option &=
+						DEV_SERIAL_CHIP_MODE;
+					memset(aml_chip->user_page_buf, 0xff,
+						flash->pagesize);
+					memset(aml_chip->user_oob_buf, 0xff,
+						sizeof(oob_buf));
+				#ifdef AML_NAND_UBOOT
+					nand_get_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+						nand_get_chip(aml_chip);
+				#endif
+		aml_nand_msg("dummy random paired data:pgnum=%d pgaddr=%x",
+						temp_page_num,
+						ops_para->page_addr);
+					ret = operation->write_page(aml_chip);
+				#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+				#else
+					if (aml_chip->state == CHIP_READY)
+					nand_release_chip(aml_chip);
+				#endif
+					controller->ran_mode = temp_ran_mode;
+					ops_para->page_addr = tmp_addr;
+					ops_para->option = temp_option;
+
+				}
+			}
+		}
+	}
+
+	if (ret < 0) { /* write failed */
+		aml_nand_msg(" NAND SAVE :arg %s faild at blk:%d",
+			name,
+			blk_addr);
+		ret = -NAND_WRITE_FAILED;
+		goto exit_error0;
+	} else {
+		/* write success and update reserved_blk table */
+		if ((arg_info->arg_valid == 0)
+			|| (arg_info->arg_type == FULL_BLK)
+			|| ((arg_info->arg_type == FULL_PAGE)
+			&& (full_page_flag || arg_info->update_flag))) {
+			for (i = 0; i < RESERVED_BLOCK_CNT; i++) {
+				if (aml_chip->reserved_blk[i] == 0xff) {
+					aml_nand_dbg("update blk %s blk %d",
+						name,
+						blk_addr);
+					aml_chip->reserved_blk[i] = blk_addr;
+					break;
+				}
+			}
+		}
+#if 0
+		for (i = 0; i < RESERVED_BLOCK_CNT; i++)
+			aml_nand_dbg("aml_chip->reserved_blk[%d]=%d ",
+			i,
+			aml_chip->reserved_blk[i]);
+#endif
+		/* write success and update arg_info */
+		tmp_blk_addr = arg_info->valid_blk_addr;
+		arg_info->valid_blk_addr = blk_addr;
+
+		if ((arg_info->arg_type == FULL_PAGE)
+			&& (arg_info->arg_valid)) {
+			if (full_page_flag || arg_info->update_flag)
+				arg_info->valid_page_addr  = 0;
+			else{
+				arg_info->valid_page_addr += arg_pages;
+				if (flash->new_type == HYNIX_1YNM)
+					arg_info->valid_page_addr += 1;
+			}
+		} else if ((arg_info->arg_type == FULL_BLK)
+			&& (arg_info->arg_valid))
+			arg_info->valid_page_addr  = 0;
+
+		aml_nand_dbg("NAND  SAVE :  arg  %s success at blk:%d",
+			name,
+			blk_addr);
+
+		/* erase old info block */
+		if ((arg_info->arg_type == FULL_BLK)
+			|| ((arg_info->arg_type == FULL_PAGE)
+			&& (full_page_flag || arg_info->update_flag))) {
+			if ((arg_info->arg_valid) && (tmp_blk_addr != 0)) {
+				aml_nand_dbg("nand erase old arg %s blk at %d",
+					name,
+					tmp_blk_addr);
+				tmp_value = tmp_blk_addr;
+				tmp_value /= controller->chip_num;
+				tmp_value += tmp_blk -
+					tmp_blk/controller->chip_num;
+				ops_para->page_addr = tmp_value * pages_per_blk;
+				ops_para->chipnr =
+					tmp_blk_addr % controller->chip_num;
+				controller->select_chip(controller,
+					ops_para->chipnr);
+#ifdef AML_NAND_UBOOT
+					nand_get_chip(aml_chip);
+#else
+					if (aml_chip->state == CHIP_READY)
+						nand_get_chip(aml_chip);
+#endif
+					 ret = operation->erase_block(aml_chip);
+#ifdef AML_NAND_UBOOT
+					nand_release_chip(aml_chip);
+#else
+					if (aml_chip->state == CHIP_READY)
+						nand_release_chip(aml_chip);
+#endif
+				if (ret < 0) {
+					aml_nand_msg("blk %d erase failed",
+						tmp_blk_addr);
+					ret =
+					operation->test_block_reserved(aml_chip,
+						tmp_blk_addr);
+				if (ret) {
+					ret =
+					operation->block_markbad(aml_chip);
+				if (ret < 0) {
+					aml_nand_msg("mark failed,blk=%d",
+						tmp_blk_addr);
+					goto exit_error0;
+				}
+			}
+		}
+
+				for (i = 0; i < RESERVED_BLOCK_CNT; i++) {
+					if (aml_chip->reserved_blk[i]
+						== tmp_blk_addr) {
+						aml_chip->reserved_blk[i] =
+							0xff;
+						break;
+					}
+				}
+#if 0
+				for (i = 0; i < RESERVED_BLOCK_CNT; i++)
+					aml_nand_dbg("reserved_blk[%d]=%d ",
+						i,
+						aml_chip->reserved_blk[i]);
+#endif
+			}
+		}
+
+		if (arg_info->arg_type == FULL_PAGE) {
+			if (write_page_cnt == 0) {
+				arg_info->arg_valid = 1;
+				full_page_flag = 0;
+				arg_info->update_flag = 0;
+				write_page_cnt = 1;
+				goto write_again;
+			}
+		}
+		arg_info->arg_valid = 1;   /* SAVE SET VALID */
+		full_page_flag = 0;
+	}
+
+exit_error0:
+	return ret;
+}
+
+
+void show_data_buf(u8 *buf)
+{
+	int i = 0;
+
+	for (i = 0; i < 10; i++)
+		aml_nand_dbg("buf[%d]= %d", i, buf[i]);
+
+	return;
+}
+
+int amlnand_check_info_by_name(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *name,
+	u32 size)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	struct nand_arg_info *arg_info = (struct nand_arg_info *)info;
+	struct nand_arg_oobinfo *arg_oob_info;
+
+	u8 phys_erase_shift, phys_page_shift, nand_boot;
+	u32 i, offset, pages_per_blk, pages_read;
+	u8 oob_buf[sizeof(struct nand_arg_oobinfo)];
+	u16 start_blk, total_blk, tmp_blk;
+	int ret = 0, read_failed_page = 0, read_middle_page_failed = 0;
+	u32 tmp_value, index;
+
+	nand_boot = 1;
+	/*if(boot_device_flag == 0){
+		nand_boot = 0;
+	}	*/
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+	ENV_NAND_LINE
+	arg_oob_info = (struct nand_arg_oobinfo *)oob_buf;
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+
+	if ((flash->new_type)
+		&& ((flash->new_type < 10)
+		|| (flash->new_type == SANDISK_19NM)))
+		ops_para->option |= DEV_SLC_MODE;
+
+	if (ops_para->option & DEV_SLC_MODE)
+		pages_read = pages_per_blk >> 1;
+	else
+		pages_read = pages_per_blk;
+
+	start_blk = (offset >> phys_erase_shift);
+	tmp_blk = start_blk;
+#if 0
+	total_blk = (offset >> phys_erase_shift) + RESERVED_BLOCK_CNT;
+#else
+	total_blk = get_last_reserve_block(aml_chip);
+#endif
+	ENV_NAND_LINE
+#if 1
+	for (; start_blk < total_blk; start_blk++) {
+		read_failed_page = 0;
+		read_middle_page_failed = 0;
+		memset((u8 *)ops_para, 0x0,
+			sizeof(struct chip_ops_para));
+
+		tmp_value = start_blk;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = tmp_value * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+		ret = operation->block_isbad(aml_chip);
+		if (ret) {
+			aml_nand_msg("blk %d is bad ", start_blk);
+			continue;
+		}
+		for (i = 0; i < pages_read;) {
+			memset((u8 *)ops_para, 0x0,
+				sizeof(struct chip_ops_para));
+			if ((flash->new_type)
+				&& ((flash->new_type < 10)
+				|| (flash->new_type == SANDISK_19NM)))
+				ops_para->option |= DEV_SLC_MODE;
+
+			ops_para->page_addr = (i + tmp_value * pages_per_blk);
+			ops_para->chipnr = start_blk % controller->chip_num;
+
+			controller->select_chip(controller, ops_para->chipnr);
+
+			if ((ops_para->option & DEV_SLC_MODE)) {
+				index = ops_para->page_addr;
+				index &= (~(pages_per_blk - 1));
+				if ((flash->new_type > 0)
+					&& (flash->new_type < 10))
+					ops_para->page_addr = index |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+				if (flash->new_type == SANDISK_19NM)
+					ops_para->page_addr = index |
+				((ops_para->page_addr % pages_per_blk) << 1);
+			}
+			ops_para->data_buf = aml_chip->user_page_buf;
+			ops_para->oob_buf = aml_chip->user_oob_buf;
+			ops_para->ooblen = sizeof(oob_buf);
+
+			memset(ops_para->data_buf, 0x0, flash->pagesize);
+			memset(ops_para->oob_buf, 0x0, sizeof(oob_buf));
+			ENV_NAND_LINE
+			nand_get_chip(aml_chip);
+			ENV_NAND_LINE
+			ret = operation->read_page(aml_chip);
+			ENV_NAND_LINE
+			nand_release_chip(aml_chip);
+
+			if ((ops_para->ecc_err) || (ret < 0)) {
+				aml_nand_msg("blk check good but read failed");
+				aml_nand_msg("chip%d page=%d",
+					ops_para->chipnr,
+					ops_para->page_addr);
+				read_failed_page++;
+				i += (size >> phys_page_shift) + 1;
+				if ((read_failed_page > 8)
+					&& (read_middle_page_failed == 0)) {
+					aml_nand_msg("failed_pg=%d",
+						read_failed_page);
+					i = ((size >> phys_page_shift) + 1) *
+			((pages_per_blk/((size >> phys_page_shift) + 1))>>1);
+					read_middle_page_failed = -1;
+				} else if (read_middle_page_failed == -1) {
+					aml_nand_msg("failed_page=%d",
+						read_failed_page);
+					i = ((size >> phys_page_shift) + 1) *
+			((pages_per_blk/((size >> phys_page_shift) + 1)));
+					read_middle_page_failed = -2;
+				}
+				continue;
+			}
+
+			memcpy((u8 *)arg_oob_info,
+				aml_chip->user_oob_buf,
+				sizeof(oob_buf));
+			if ((!memcmp(arg_oob_info->name, name, 4))) {
+				if (arg_info->arg_valid == 1) {
+					if (arg_oob_info->timestamp >
+						arg_info->timestamp) {
+						arg_info->free_blk_addr =
+						arg_info->valid_blk_addr;
+						arg_info->valid_blk_addr =
+							start_blk;
+						arg_info->timestamp =
+							arg_oob_info->timestamp;
+					} else
+						arg_info->free_blk_addr =
+							start_blk;
+					break;
+				} else {
+					arg_info->arg_valid = 1;
+					arg_info->valid_blk_addr = start_blk;
+					arg_info->timestamp =
+						arg_oob_info->timestamp;
+				}
+			}
+			break;
+		}
+
+		if ((arg_info->arg_type == FULL_BLK)
+			&& (arg_info->arg_valid == 1)
+			&& (arg_info->valid_blk_addr != 0))
+			break;
+	}
+#else
+	do {
+		memset((u8 *)ops_para, 0x0,
+			sizeof(struct chip_ops_para));
+		ops_para->page_addr =
+		(((start_blk - start_blk % controller->chip_num) /
+		controller->chip_num) + tmp_blk -
+		tmp_blk/controller->chip_num) * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+		ret = operation->block_isbad(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("blk %d is bad ",
+				start_blk);
+			continue;
+		}
+
+		memset((u8 *)ops_para, 0x0,
+			sizeof(struct chip_ops_para));
+		if ((flash->new_type) && ((flash->new_type < 10)
+			|| (flash->new_type == SANDISK_19NM)))
+			ops_para->option |= DEV_SLC_MODE
+		ops_para->page_addr =
+			(((start_blk - start_blk % controller->chip_num) /
+			controller->chip_num) + tmp_blk -
+			tmp_blk/controller->chip_num) * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		if ((ops_para->option & DEV_SLC_MODE)) {
+			if ((flash->new_type > 0) && (flash->new_type < 10))
+				ops_para->page_addr = (ops_para->page_addr &
+					(~(pages_per_blk - 1))) |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+			if (flash->new_type == SANDISK_19NM)
+				ops_para->page_addr =
+			(ops_para->page_addr & (~(pages_per_blk - 1))) |
+				((ops_para->page_addr % pages_per_blk) << 1);
+		}
+
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		memset(ops_para->data_buf, 0x0, flash->pagesize);
+		memset(ops_para->oob_buf, 0x0, sizeof(oob_buf));
+
+		if (aml_chip->state == CHIP_READY)
+			nand_get_chip(aml_chip);
+
+		ret = operation->read_page(aml_chip);
+
+		if (aml_chip->state == CHIP_READY)
+			nand_release_chip(aml_chip);
+
+		if ((ops_para->ecc_err) || (ret < 0)) {
+			aml_nand_msg("blk check good but read failed");
+			aml_nand_msg("chip%d page=%d",
+				ops_para->chipnr,
+				ops_para->page_addr);
+			continue;
+		}
+
+#if 0
+	aml_nand_dbg(" ops_para->oob_buf : %x %x %x %x %x %x %x %x",
+		ops_para->oob_buf[0], ops_para->oob_buf[1],
+		ops_para->oob_buf[2], ops_para->oob_buf[3],
+		ops_para->oob_buf[4], ops_para->oob_buf[5],
+		ops_para->oob_buf[6], ops_para->oob_buf[7]);
+#endif
+		memcpy((u8 *)arg_oob_info,  aml_chip->user_oob_buf,
+			sizeof(oob_buf));
+		if ((!memcmp(arg_oob_info->name, name, 4))) {
+			if (arg_info->arg_valid == 1) {
+				if (arg_oob_info->timestamp >
+					arg_info->timestamp) {
+					arg_info->free_blk_addr =
+						arg_info->valid_blk_addr;
+					arg_info->valid_blk_addr = start_blk;
+					arg_info->timestamp =
+						arg_oob_info->timestamp;
+				} else
+					arg_info->free_blk_addr = start_blk;
+				break;
+			} else {
+				arg_info->arg_valid = 1;
+				arg_info->valid_blk_addr = start_blk;
+				arg_info->timestamp = arg_oob_info->timestamp;
+			}
+		}
+
+		if ((arg_info->arg_type == FULL_BLK)
+			&& (arg_info->arg_valid == 1)
+			&& (arg_info->valid_blk_addr != 0))
+			break;
+	} while ((++start_blk) < total_blk);
+#endif
+
+	if (arg_info->arg_valid == 1) {
+		if (arg_info->arg_type == FULL_BLK) {
+			for (i = 0; i < pages_read;) {
+				memset((u8 *)ops_para, 0x0,
+					sizeof(struct chip_ops_para));
+				ops_para->data_buf = NULL;
+				ops_para->oob_buf = aml_chip->user_oob_buf;
+				ops_para->ooblen = sizeof(oob_buf);
+				memset((u8 *)ops_para->oob_buf, 0x0,
+					sizeof(oob_buf));
+
+				if ((flash->new_type)
+					&& ((flash->new_type < 10)
+					|| (flash->new_type == SANDISK_19NM)))
+					ops_para->option |= DEV_SLC_MODE;
+
+				tmp_value = arg_info->valid_blk_addr;
+				tmp_value /= controller->chip_num;
+				tmp_value += tmp_blk -
+					tmp_blk/controller->chip_num;
+				tmp_value *= pages_per_blk;
+				ops_para->page_addr = i + tmp_value;
+
+				if ((ops_para->option & DEV_SLC_MODE)) {
+					index = ops_para->page_addr;
+					index &= (~(pages_per_blk - 1));
+					if ((flash->new_type > 0)
+						&& (flash->new_type < 10))
+						ops_para->page_addr = index |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+					if (flash->new_type == SANDISK_19NM)
+						ops_para->page_addr = index |
+				((ops_para->page_addr % pages_per_blk) << 1);
+				}
+
+				ops_para->chipnr =
+				arg_info->valid_blk_addr % controller->chip_num;
+				controller->select_chip(controller,
+					ops_para->chipnr);
+
+				if (aml_chip->state == CHIP_READY)
+					nand_get_chip(aml_chip);
+
+				ret = operation->read_page(aml_chip);
+
+				if (aml_chip->state == CHIP_READY)
+					nand_release_chip(aml_chip);
+
+			if ((ops_para->ecc_err) || (ret < 0)) {
+				aml_nand_msg("read %s failed chip%d page=%d",
+					name,
+					ops_para->chipnr,
+					ops_para->page_addr);
+				i += (size >> phys_page_shift) + 1;
+				arg_info->update_flag = 1;
+				continue;
+			}
+
+				memcpy((u8 *)arg_oob_info,
+					aml_chip->user_oob_buf,
+					sizeof(oob_buf));
+				if (!memcmp(arg_oob_info->name, name, 4)) {
+					arg_info->valid_page_addr = i;
+					arg_info->timestamp =
+						arg_oob_info->timestamp;
+					break;
+				}
+				i += (size >> phys_page_shift) + 1;
+			}
+		} else if (arg_info->arg_type == FULL_PAGE) {
+			for (i = 0; i < pages_read;) {
+				memset((u8 *)ops_para, 0x0,
+					sizeof(struct chip_ops_para));
+				if ((flash->new_type)
+					&& ((flash->new_type < 10)
+					|| (flash->new_type == SANDISK_19NM)))
+					ops_para->option |= DEV_SLC_MODE;
+
+				ops_para->data_buf = aml_chip->user_page_buf;
+				ops_para->oob_buf = aml_chip->user_oob_buf;
+				ops_para->ooblen = sizeof(oob_buf);
+				memset((u8 *)ops_para->data_buf,
+					0x0, flash->pagesize);
+				memset((u8 *)ops_para->oob_buf,
+					0x0, sizeof(oob_buf));
+
+				tmp_value = arg_info->valid_blk_addr;
+				tmp_value /= controller->chip_num;
+				tmp_value += tmp_blk -
+					tmp_blk/controller->chip_num;
+				tmp_value *= pages_per_blk;
+				ops_para->page_addr = i + tmp_value;
+
+				if ((ops_para->option & DEV_SLC_MODE)) {
+					index = ops_para->page_addr;
+					index &= (~(pages_per_blk - 1));
+					if ((flash->new_type > 0)
+						&& (flash->new_type < 10))
+						ops_para->page_addr = index |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+					if (flash->new_type == SANDISK_19NM)
+						ops_para->page_addr = index |
+				((ops_para->page_addr % pages_per_blk) << 1);
+				}
+
+				ops_para->chipnr = arg_info->valid_blk_addr %
+					controller->chip_num;
+				controller->select_chip(controller,
+					ops_para->chipnr);
+
+				if (aml_chip->state == CHIP_READY)
+					nand_get_chip(aml_chip);
+
+				ret = operation->read_page(aml_chip);
+
+				if (aml_chip->state == CHIP_READY)
+					nand_release_chip(aml_chip);
+
+			if ((ops_para->ecc_err) || (ret < 0)) {
+				aml_nand_msg("read %s failed at chip%d page %d",
+					name,
+					ops_para->chipnr,
+					ops_para->page_addr);
+				i += (size >> phys_page_shift) + 1;
+				arg_info->update_flag = 1;
+				continue;
+			}
+
+				memcpy((u8 *)arg_oob_info,
+					aml_chip->user_oob_buf,
+					sizeof(oob_buf));
+				if (!memcmp(arg_oob_info->name, name, 4)) {
+					arg_info->valid_page_addr = i;
+					arg_info->timestamp =
+						arg_oob_info->timestamp;
+				} else
+					break;
+
+				i += (size >> phys_page_shift) + 1;
+				/*for hynix slc mode*/
+				if (flash->new_type == HYNIX_1YNM)
+					i += 1;
+			}
+		}
+
+		for (i = 0; i < RESERVED_BLOCK_CNT; i++) {
+			if (aml_chip->reserved_blk[i] == 0xff) {
+				aml_chip->reserved_blk[i] =
+					arg_info->valid_blk_addr;
+				break;
+			}
+		}
+		aml_nand_dbg("NAND CKECK: %s success at blk:%d page %d",
+			name,
+			arg_info->valid_blk_addr,
+			arg_info->valid_page_addr);
+	}
+	aml_nand_msg("NAND CKECK:arg %s: valid=%d, blk=%d, page=%d",
+		name,
+		arg_info->arg_valid,
+		arg_info->valid_blk_addr,
+		arg_info->valid_page_addr);
+	aml_nand_dbg(" complete ");
+
+	return ret;
+}
+
+
+int amlnand_info_init(struct amlnand_chip *aml_chip,
+	u8 *info,
+	u8 *buf,
+	u8 *name,
+	u32 size)
+{
+	struct nand_arg_info *arg_info = (struct nand_arg_info *)info;
+	int ret = 0;
+
+	aml_nand_dbg("NAME :  %s", name);
+
+	ret = amlnand_check_info_by_name(aml_chip,
+		(u8 *) arg_info ,
+		name,
+		size);
+	if (ret < 0) {
+		aml_nand_msg("nand check info failed");
+		goto exit_error;
+	}
+
+	if (arg_info->arg_valid == 1) {
+		ret = amlnand_read_info_by_name(aml_chip,
+			(u8 *)arg_info,
+			buf,
+			name,
+			size);
+		if (ret < 0) {
+			aml_nand_msg("nand check info success but read failed");
+			goto exit_error;
+		}
+		ret = aml_info_check_datasum(buf, name);
+		if (ret < 0) {
+			aml_nand_msg("amlnand_info_init:check read %s failed",
+				name);
+			/* ret = 0; */
+			goto exit_error;
+		}
+	} else
+		aml_nand_msg("found NO arg : %s info", name);
+
+exit_error:
+	return ret;
+}
+
+
+/*****************************************************************************
+*Name         :amlnand_update_bbt
+*Description :update bbt by block status
+*Parameter  :
+*Return       :
+*Note          :
+*****************************************************************************/
+int amlnand_update_bbt(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+
+	aml_nand_dbg("amlnand_update_bbt  :here!!");
+
+
+#if 0
+	/* show the bbt */
+	aml_nand_dbg("show the bbt");
+	for (chipnr = 0; chipnr < controller->chip_num; chipnr++) {
+		tmp_arr = &aml_chip->bbt_ptr->nand_bbt[chipnr][0];
+		for (start_block = 0; start_block < 200; start_block++)
+			aml_nand_msg(" tmp_arr[%d][%d]=%d",
+				chipnr,
+				start_block,
+				tmp_arr[start_block]);
+	}
+#endif
+
+	aml_chip->block_status->crc =
+		aml_info_checksum((u8 *)aml_chip->block_status->blk_status,
+			(MAX_CHIP_NUM*MAX_BLK_NUM));
+	ret = amlnand_save_info_by_name(aml_chip,
+		(u8 *)&(aml_chip->nand_bbtinfo),
+		(u8 *)aml_chip->block_status,
+		(unsigned char *)BBT_HEAD_MAGIC,
+		sizeof(struct block_status));
+	if (ret < 0) {
+		aml_nand_msg("nand update bbt failed");
+		goto exit_error0;
+	}
+
+	return ret;
+exit_error0:
+	return ret;
+}
+
+
+/*****************************************************************************
+*Name         :amlnand_init_block_status
+*Description :init the block_status table by bbt;
+*Parameter  :
+*Return       :
+*Note          :
+*****************************************************************************/
+int amlnand_init_block_status(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	/* struct chip_operation *operation = &aml_chip->operation; */
+	struct nand_flash *flash = &aml_chip->flash;
+	/* struct shipped_bbt * shipped_bbt_ptr = aml_chip->shipped_bbt_ptr; */
+	u32 total_blk, chipnr;
+	u16 *tmp_bbt, *tmp_status;
+	u8 phys_erase_shift;
+	u64 tmp_size;
+	int ret = 0, i, j;
+
+	aml_nand_dbg("amlnand_init_block_status : start");
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+
+	tmp_size = flash->chipsize;
+	total_blk = (int) ((tmp_size<<20) >> phys_erase_shift);
+
+#if 0
+	aml_nand_dbg("show the bbt");
+	for (chipnr = 0; chipnr < controller->chip_num; chipnr++) {
+		tmp_arr = &aml_chip->bbt_ptr->nand_bbt[chipnr][0];
+		for (start_block = 0; start_block < 200; start_block++)
+			aml_nand_msg(" tmp_arr[%d][%d]=%d",
+				chipnr,
+				start_block,
+				tmp_arr[start_block]);
+	}
+#endif
+
+	for (chipnr = 0; chipnr < controller->chip_num;  chipnr++) {
+		tmp_bbt = &aml_chip->shipped_bbt_ptr->shipped_bbt[chipnr][0];
+		tmp_status = &aml_chip->block_status->blk_status[chipnr][0];
+		for (i = 0; i < total_blk; i++) {
+			tmp_status[i] = NAND_BLOCK_GOOD;
+			for (j = 0; j < MAX_BAD_BLK_NUM; j++) {
+				if ((tmp_bbt[j] & 0x7fff) == i) {
+					if ((tmp_bbt[j] & 0x8000)) {
+						tmp_status[i] =
+							NAND_BLOCK_FACTORY_BAD;
+						aml_nand_dbg("s[%d][%d]=%d",
+							chipnr,
+							i,
+							tmp_status[i]);
+					} else {
+				if (i == 0)
+					tmp_status[i] = NAND_BLOCK_GOOD;
+				else{
+					tmp_status[i] = NAND_BLOCK_USED_BAD;
+					aml_nand_dbg("s[%d][%d]=%d",
+						chipnr,
+						i,
+						tmp_status[i]);
+				}
+					}
+					break;
+				}
+			}
+		}
+	}
+
+#if 0
+	aml_nand_dbg("show the block status ");
+	u16 *tmp_arr;
+	int start_block;
+	for (chipnr = 0; chipnr < controller->chip_num; chipnr++) {
+		tmp_arr = &aml_chip->block_status->blk_status[chipnr][0];
+		for (start_block = 0; start_block < 50; start_block++)
+			aml_nand_msg(" tmp_arr[%d][%d]=%d",
+				chipnr,
+				start_block,
+				tmp_arr[start_block]);
+	}
+#endif
+
+	return ret;
+}
+
+#ifdef AML_NAND_UBOOT
+static int confirm_dev_para(struct dev_para*dev_para_cmp,struct amlnf_partition *config_init,int dev_flag)
+{
+	int ret =0, j=0,partiton_num=0;
+	struct amlnf_partition *partition = NULL;
+	struct amlnf_partition * partition_ptr =NULL;
+
+	for (j = 0; j < MAX_NAND_PART_NUM; j++) {
+		partition = &(config_init[j]);
+		partition_ptr =& (dev_para_cmp->partitions[partiton_num]);
+		if (partition->mask_flags == dev_flag) {
+			if (memcmp(partition_ptr->name, partition->name, strlen(partition->name))) {
+				aml_nand_msg("nand partition table changed: partition->name: from %s  to %s",partition_ptr->name,partition->name);
+				ret = -1;
+				break;
+			}
+			if (partition->size != partition_ptr->size) {
+				aml_nand_msg("nand partition table changed:  %s partition->size: from %llx	to %llx",partition->name,partition_ptr->size,partition->size);
+				ret = -1;
+				break;
+			}
+			if (partition_ptr->mask_flags != dev_flag) {
+				aml_nand_msg("nand partition table %s : mask_flag changed from %d to %d",partition->name,partition_ptr->mask_flags,partition->mask_flags);
+				ret = -1;
+				break;
+			}
+			partiton_num ++;
+		}else if(partition == NULL){
+			break;
+		}
+	}
+
+	if (dev_para_cmp->nr_partitions != partiton_num) {
+		aml_nand_msg("nand dev %s : nr_partitions num changed from %d to %d",dev_para_cmp->name,dev_para_cmp->nr_partitions,partiton_num);
+		ret = -1;
+	}
+
+	return ret ;
+}
+
+static void init_dev_para(struct dev_para*dev_para_ptr,struct amlnf_partition *config_init, int dev_flag)
+{
+	int j=0,partiton_num=0;
+	struct amlnf_partition *partition = NULL;
+	struct amlnf_partition * partition_ptr =NULL;
+
+	for (j = 0; j < MAX_NAND_PART_NUM; j++) {
+		//printf("%s, j = %d\n", __func__, j);
+		partition = &(config_init[j]);
+		partition_ptr =& (dev_para_ptr->partitions[partiton_num]);
+		if (partition->mask_flags == dev_flag) {
+			memcpy(partition_ptr->name, partition->name, strlen( partition->name));
+			partition_ptr->size = partition->size;
+			partition_ptr->mask_flags = partition->mask_flags;
+			partiton_num ++;
+			aml_nand_dbg("init_dev_para : partition->name %s ", partition->name);
+			aml_nand_dbg("init_dev_para : partition->size %llx", partition->size);
+			aml_nand_dbg("init_dev_para : partition->mask_flags %d", partition->mask_flags);
+		}else if(partition == NULL){
+			break;
+		}
+	}
+	dev_para_ptr->nr_partitions = partiton_num;
+	aml_nand_msg("partition-> partiton_num %d",partiton_num);
+
+	return;
+}
+static void amlnand_get_dev_num(struct amlnand_chip *aml_chip,struct amlnf_partition *config_init)
+{
+	//struct dev_para *dev_para = NULL;
+	struct dev_para*dev_para_ptr =NULL;
+	//struct amlnf_partition *partition = NULL;
+	//struct amlnf_partition * partition_ptr =NULL;
+	//int j, i,k,tmp_num=0,partiton_num=0,dev_num=0,ret=0;
+	int i,tmp_num=0;
+	int device_num =PHY_DEV_NUM;
+
+	if (boot_device_flag == 1) {
+		memcpy((void *)(aml_chip->config_ptr->dev_para[tmp_num].name), NAND_BOOT_NAME, strlen(NAND_BOOT_NAME));
+		aml_chip->config_ptr->dev_para[tmp_num].nr_partitions = 0;
+		aml_chip->config_ptr->dev_para[tmp_num].option = 0;
+		tmp_num++;
+		device_num = PHY_DEV_NUM + 1;
+	}
+	aml_chip->config_ptr->dev_num = device_num;
+
+	for (i=0;tmp_num < device_num;tmp_num++,i++) {
+		dev_para_ptr = &(aml_chip->config_ptr->dev_para[tmp_num]);
+		if (i == 0) {
+			//printf("cache!\n");
+			memcpy((void *)(dev_para_ptr->name), NAND_CACHE_NAME, strlen(NAND_CACHE_NAME));
+			init_dev_para(dev_para_ptr,config_init,STORE_CACHE);
+			dev_para_ptr->option = NAND_DATA_OPTION;
+		}else if(i==1) {
+			//printf("code!\n");
+			memcpy((void *)(dev_para_ptr->name), NAND_CODE_NAME, strlen(NAND_CODE_NAME));
+			init_dev_para(dev_para_ptr,config_init,STORE_CODE);
+			dev_para_ptr->option = NAND_CODE_OPTION;
+		}else if(i==2) {
+			//printf("data!\n");
+			memcpy((void *)(dev_para_ptr->name), NAND_DATA_NAME, strlen(NAND_DATA_NAME));
+			init_dev_para(dev_para_ptr,config_init,STORE_DATA);
+			dev_para_ptr->option = NAND_DATA_OPTION;
+		}else {
+			aml_nand_msg("%s: something wrong %d!!", __func__, __LINE__);
+			break;
+		}
+	}
+
+	return ;
+}
+
+int amlnand_configs_confirm(struct amlnand_chip *aml_chip)
+{
+	//nand_arg_info * config_msg = &aml_chip->config_msg;
+#ifdef AML_NAND_UBOOT
+	struct amlnf_partition * configs_init =  (struct amlnf_partition *) amlnand_config;
+#endif
+	struct nand_config * config_ptr = aml_chip->config_ptr;
+
+	struct dev_para *dev_para_cmp = NULL;
+	unsigned char  confirm_flag=0;
+	int i, tmp_num=0,ret = 0;
+	int device_num =PHY_DEV_NUM;
+	ENV_NAND_LINE
+	ret = phrase_driver_version(config_ptr->driver_version,DRV_PHY_VERSION);
+	if (ret) {
+		aml_nand_msg("nand driver version confirm failed :  driver_version in nand  %d.%02d.%03d.%04d ",(config_ptr->driver_version >> 24)&0xff,
+		(config_ptr->driver_version >> 16)&0xff,(config_ptr->driver_version >> 8)&0xff,(config_ptr->driver_version)&0xff);
+		confirm_flag = 1;
+	}
+	ENV_NAND_LINE
+
+	if (boot_device_flag == 1) {
+		tmp_num++;
+		device_num = PHY_DEV_NUM + 1;
+	}
+	ENV_NAND_LINE
+	//check device num
+	if (device_num != config_ptr->dev_num) {
+		//aml_nand_msg("nand device num changed from %d to %d %s", config_ptr->dev_num,device_num);
+		aml_nand_msg("nand device num changed from %d to %d", config_ptr->dev_num,device_num);
+		confirm_flag = 1;
+	}
+	ENV_NAND_LINE
+	for (i=0;tmp_num < device_num;tmp_num++,i++) {
+		ENV_NAND_LINE
+		dev_para_cmp = &(aml_chip->config_ptr->dev_para[tmp_num]);
+		if (i == 0) {
+			ret = confirm_dev_para(dev_para_cmp,configs_init,STORE_CACHE);
+			if (ret) {
+				confirm_flag = 1;
+				break;
+			}
+		}else if(i==1) {
+			ret = confirm_dev_para(dev_para_cmp,configs_init,STORE_CODE);
+			if (ret) {
+				confirm_flag = 1;
+				break;
+			}
+		}else if(i==2) {
+			ret = confirm_dev_para(dev_para_cmp,configs_init,STORE_DATA);
+			if (ret) {
+				confirm_flag = 1;
+				break;
+			}
+		}else {
+			aml_nand_msg("%s: something wrong %d!!", __func__, __LINE__);
+			confirm_flag = 1;
+			break;
+		}
+	}
+	ENV_NAND_LINE
+	if (confirm_flag == 0) {
+		aml_nand_dbg("nand configs confirm all right");
+		aml_chip->shipped_bbtinfo.valid_blk_addr = config_ptr->fbbt_blk_addr;
+		for (i=0; i<RESERVED_BLOCK_CNT; i++) {
+			if (aml_chip->reserved_blk[i] == 0xff) {
+				aml_chip->reserved_blk[i] = aml_chip->config_ptr->fbbt_blk_addr;
+				break;
+			}
+		}
+		aml_nand_dbg("nand  shipped bbt at blk:%d, nand  config at blk:%d", \
+			aml_chip->shipped_bbtinfo.valid_blk_addr, aml_chip->config_msg.valid_blk_addr);
+	}
+	else{
+		aml_nand_msg("nand configs confirm failed");
+		reset_amlchip_member(aml_chip);
+		ret = -1;
+	}
+	ENV_NAND_LINE
+	return ret;
+
+//exit_error0:
+	//return ret;
+}
+#endif /* AML_NAND_UBOOT */
+
+
+int aml_nand_save_hynix_info(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+
+	u8 phys_erase_shift, phys_page_shift;
+	u16  blk_addr = 0,  tmp_blk,  nand_boot;
+	u32 i, j, offset,  pages_per_blk, pages_read;
+	u8 oob_buf[8];
+	int ret = 0;
+	u32 tmp_addr;
+	int test_cnt = 0;
+	u8 tmp_rand;
+	u32 tmp_value;
+
+#ifdef DEBUG_HYINX_DEF
+	int save_cnt = 20;
+	if (retry_info->retry_cnt_lp > 20)
+		save_cnt = retry_info->retry_cnt_lp;
+#endif
+	if ((flash->new_type == 0) || (flash->new_type > 10))
+		return NAND_SUCCESS;
+
+	aml_nand_dbg("aml_nand_save_hynix_info : here!! ");
+
+	nand_boot = 1;
+
+	/*if(boot_device_flag == 0){
+		nand_boot = 0;
+	}*/
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+	tmp_blk = (offset >> phys_erase_shift);
+
+	if ((flash->new_type) && (flash->new_type < 10))
+		ops_para->option |= DEV_SLC_MODE;
+
+	if (ops_para->option & DEV_SLC_MODE)
+		pages_read = pages_per_blk >> 1;
+	else
+		pages_read = pages_per_blk;
+
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	memcpy(oob_buf, HYNIX_DEV_HEAD_MAGIC, strlen(HYNIX_DEV_HEAD_MAGIC));
+
+get_free_blk:
+	ret = amlnand_get_free_block(aml_chip, blk_addr);
+	blk_addr = ret;
+	if (ret < 0) {
+		aml_nand_msg("nand get free block failed");
+		ret = -NAND_BAD_BLCOK_FAILURE;
+		goto exit_error0;
+	}
+	aml_nand_dbg("nand get free block for hynix readretry info at %d",
+		blk_addr);
+
+	for (i = 0; i < pages_read; i++) {
+		memset((u8 *)ops_para, 0x0,
+			sizeof(struct chip_ops_para));
+		if ((flash->new_type) && (flash->new_type < 10))
+			ops_para->option |= DEV_SLC_MODE;
+		tmp_value = blk_addr;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = i + (tmp_value * pages_per_blk);
+		ops_para->chipnr = blk_addr % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		if ((ops_para->option & DEV_SLC_MODE)
+			&& ((flash->new_type > 0)
+			&& (flash->new_type < 10))) {
+			tmp_value = ops_para->page_addr;
+			tmp_value &= (~(pages_per_blk - 1));
+			ops_para->page_addr = tmp_value |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+		}
+
+		ops_para->data_buf = aml_chip->user_page_buf;
+		ops_para->oob_buf = aml_chip->user_oob_buf;
+		ops_para->ooblen = sizeof(oob_buf);
+
+		if (flash->new_type == HYNIX_1YNM) {
+			if ((i > 1) && ((i%2) == 0)) {
+				tmp_addr =	ops_para->page_addr;
+				tmp_rand = controller->ran_mode;
+				ops_para->page_addr -= 1;
+				controller->ran_mode = 0;
+				ops_para->option |= DEV_ECC_SOFT_MODE;
+				ops_para->option &= DEV_SERIAL_CHIP_MODE;
+				memset(aml_chip->user_page_buf, 0xff,
+					flash->pagesize);
+				#ifdef AML_NAND_UBOOT
+
+				nand_get_chip(aml_chip);
+				#else
+				if (aml_chip->state == CHIP_READY)
+					nand_get_chip(aml_chip);
+				#endif
+				ret = operation->write_page(aml_chip);
+				#ifdef AML_NAND_UBOOT
+				nand_release_chip(aml_chip);
+				#else
+				if (aml_chip->state == CHIP_READY)
+					nand_release_chip(aml_chip);
+				#endif
+				ops_para->page_addr = tmp_addr;
+				controller->ran_mode = tmp_rand;
+				ops_para->option &= DEV_ECC_HW_MODE;
+				ops_para->option |=DEV_SLC_MODE;
+			}
+		}
+		memset(aml_chip->user_page_buf, 0x0, flash->pagesize);
+		memset(aml_chip->user_oob_buf, 0x0, sizeof(oob_buf));
+		memcpy((u8 *)aml_chip->user_page_buf,
+			&retry_info->reg_def_val[0][0],
+			MAX_CHIP_NUM*READ_RETRY_REG_NUM);
+		memcpy(aml_chip->user_oob_buf, (u8 *)oob_buf, 4);
+
+#ifdef DEBUG_HYINX_DEF
+		for (k = 0; k < controller->chip_num; k++)
+			for (j = 0; j < save_cnt; j++)
+				memcpy((u8 *)(aml_chip->user_page_buf +
+					MAX_CHIP_NUM*READ_RETRY_REG_NUM +
+					j*READ_RETRY_REG_NUM+k*READ_RETRY_CNT),
+					&retry_info->reg_offs_val_lp[k][j][0],
+					READ_RETRY_REG_NUM);
+#else
+		memcpy((u8 *)(aml_chip->user_page_buf +
+			MAX_CHIP_NUM*READ_RETRY_REG_NUM),
+			&retry_info->reg_offs_val_lp[0][0][0],
+			MAX_CHIP_NUM*READ_RETRY_CNT*READ_RETRY_REG_NUM);
+#endif
+#ifdef AML_NAND_UBOOT
+		nand_get_chip(aml_chip);
+#else
+		if (aml_chip->state == CHIP_READY)
+			nand_get_chip(aml_chip);
+#endif
+		ret = operation->write_page(aml_chip);
+#ifdef AML_NAND_UBOOT
+		nand_release_chip(aml_chip);
+#else
+	if (aml_chip->state == CHIP_READY)
+		nand_release_chip(aml_chip);
+#endif
+		if (ret < 0) {
+			aml_nand_msg("%s:nand write failed", __func__);
+			if (test_cnt >= 3) {
+				aml_nand_msg("test blk 3times,");
+				break;
+			}
+			ret = operation->test_block_reserved(aml_chip,
+				blk_addr);
+			test_cnt++;
+			if (ret) {
+				ret = operation->block_markbad(aml_chip);
+				if (ret < 0)
+					aml_nand_dbg("mark badblk failed %d",
+						blk_addr);
+			}
+			goto get_free_blk;
+		}
+	}
+
+	if (ret < 0) {
+		aml_nand_msg("hynix nand save readretry info failed");
+		goto exit_error0;
+	} else {
+		for (j = 0; j < RESERVED_BLOCK_CNT; j++) {
+			if (aml_chip->reserved_blk[j] == 0xff) {
+				aml_chip->reserved_blk[j] = blk_addr;
+				break;
+			}
+		}
+		retry_info->info_save_blk = blk_addr;
+		aml_nand_dbg("save hynix readretry info success at blk %d",
+			blk_addr);
+	}
+
+exit_error0:
+	return ret;
+}
+
+int aml_nand_scan_hynix_info(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct chip_operation *operation = &aml_chip->operation;
+	struct chip_ops_para  *ops_para = &aml_chip->ops_para;
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+
+	u8 phys_erase_shift, phys_page_shift;
+	u16 start_blk, tmp_blk, total_blk, nand_boot;
+	u32 i, j, k, n, offset,  pages_per_blk, pages_read;
+	u8 oob_buf[8];
+	int nand_type, ret = 0;
+	u32 tmp_value, index;
+
+#ifdef DEBUG_HYINX_DEF
+	int save_cnt = 20;
+	if (retry_info->retry_cnt_lp > 20)
+		save_cnt = retry_info->retry_cnt_lp;
+#endif
+	if ((flash->new_type == 0) || (flash->new_type > 10))
+		return NAND_SUCCESS;
+
+	nand_boot = 1;
+
+	/*if(boot_device_flag == 0){
+		nand_boot = 0;
+	}*/
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	memset((u8 *)ops_para, 0x0, sizeof(struct chip_ops_para));
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	if ((flash->new_type) && (flash->new_type < 10))
+		ops_para->option |= DEV_SLC_MODE;
+	pages_per_blk = (1 << (phys_erase_shift - phys_page_shift));
+
+	if (ops_para->option & DEV_SLC_MODE)
+		pages_read = pages_per_blk >> 1;
+	else
+		pages_read = pages_per_blk;
+
+	retry_info->default_flag = 0;
+	retry_info->flag = 0;
+
+	start_blk = (int)(offset >> phys_erase_shift);
+	tmp_blk = start_blk;
+	total_blk = (offset >> phys_erase_shift)+RESERVED_BLOCK_CNT;
+
+	do {
+		memset((u8 *)ops_para, 0x0,
+			sizeof(struct chip_ops_para));
+		tmp_value = start_blk;
+		tmp_value /= controller->chip_num;
+		tmp_value += tmp_blk - tmp_blk/controller->chip_num;
+		ops_para->page_addr = tmp_value * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+
+		nand_type = flash->new_type;
+		flash->new_type = 0;
+		ret = operation->block_isbad(aml_chip);
+		flash->new_type = nand_type;
+		if (ret == NAND_BLOCK_FACTORY_BAD) {
+			aml_nand_msg("blk %d is bad ", start_blk);
+			continue;
+		}
+
+		for (i = 0; i < pages_read; i++) {
+			memset((u8 *)ops_para, 0x0,
+				sizeof(struct chip_ops_para));
+
+			if ((flash->new_type) && (flash->new_type < 10))
+				ops_para->option |= DEV_SLC_MODE;
+
+			ops_para->data_buf = aml_chip->user_page_buf;
+			ops_para->oob_buf = aml_chip->user_oob_buf;
+			ops_para->ooblen = sizeof(oob_buf);
+
+			ops_para->page_addr = (i + tmp_value * pages_per_blk);
+			if ((ops_para->option & DEV_SLC_MODE)
+				&& ((flash->new_type > 0)
+				&& (flash->new_type < 10))) {
+				index = ops_para->page_addr;
+				index &= (~(pages_per_blk - 1));
+				ops_para->page_addr = index |
+				(slc_info->pagelist[ops_para->page_addr % 256]);
+			}
+			ops_para->chipnr = start_blk % controller->chip_num;
+			controller->select_chip(controller, ops_para->chipnr);
+
+			memset((u8 *)ops_para->data_buf, 0x0,
+				flash->pagesize);
+			memset((u8 *)ops_para->oob_buf, 0x0,
+				sizeof(oob_buf));
+
+			nand_type = flash->new_type;
+			flash->new_type = 0;
+#ifdef AML_NAND_UBOOT
+			nand_get_chip(aml_chip);
+#else
+			if (aml_chip->state == CHIP_READY)
+				nand_get_chip(aml_chip);
+#endif
+			ret = operation->read_page(aml_chip);
+#ifdef AML_NAND_UBOOT
+			nand_release_chip(aml_chip);
+#else
+			if (aml_chip->state == CHIP_READY)
+			nand_release_chip(aml_chip);
+#endif
+			flash->new_type = nand_type;
+			if ((ops_para->ecc_err) || (ret < 0)) {
+				aml_nand_msg("blk check good but read failed ");
+				aml_nand_msg("chip %d page %d",
+					ops_para->chipnr,
+					ops_para->page_addr);
+				continue;
+			}
+
+			memcpy(oob_buf, aml_chip->user_oob_buf,
+				sizeof(oob_buf));
+			if (!memcmp(oob_buf,
+				HYNIX_DEV_HEAD_MAGIC,
+				strlen(HYNIX_DEV_HEAD_MAGIC))) {
+				memcpy(&retry_info->reg_def_val[0][0],
+					(u8 *)aml_chip->user_page_buf,
+					MAX_CHIP_NUM*READ_RETRY_REG_NUM);
+				aml_nand_msg("get def value at blk:%d,page:%d",
+					start_blk,
+					ops_para->page_addr);
+
+		for (k = 0; k < controller->chip_num; k++)
+			for (j = 0; j < retry_info->reg_cnt_lp;
+				j++)
+				aml_nand_dbg("REG(0x%x):val:0x%x,for chip%d",
+				retry_info->reg_addr_lp[j],
+			retry_info->reg_def_val[k][j], k);
+
+	if ((flash->new_type == HYNIX_20NM_8GB)
+		|| (flash->new_type == HYNIX_20NM_4GB)
+		|| (flash->new_type == HYNIX_1YNM)) {
+#ifdef DEBUG_HYINX_DEF
+		for (n = 0; n < controller->chip_num; n++)
+			for (j = 0; j < save_cnt; j++)
+				memcpy(&retry_info->reg_offs_val_lp[n][j][0],
+					(u8 *)(aml_chip->user_page_buf +
+					MAX_CHIP_NUM*READ_RETRY_REG_NUM +
+					j*READ_RETRY_REG_NUM+n*save_cnt),
+					READ_RETRY_REG_NUM);
+#else
+		memcpy(&retry_info->reg_offs_val_lp[0][0][0],
+			(u8 *)(aml_chip->user_page_buf +
+			MAX_CHIP_NUM*READ_RETRY_REG_NUM),
+			MAX_CHIP_NUM*READ_RETRY_CNT*READ_RETRY_REG_NUM);
+#endif
+				}
+for (n = 0; n < controller->chip_num; n++)
+	for (j = 0; j < retry_info->retry_cnt_lp; j++)
+		for (k = 0; k < retry_info->reg_cnt_lp; k++)
+			aml_nand_dbg("Retry%dst,REG(0x%x):val:0x%2x,for chip%d",
+				k,
+				retry_info->reg_addr_lp[k],
+			retry_info->reg_offs_val_lp[n][j][k],
+			n);
+
+				retry_info->default_flag = 1;
+				retry_info->flag = 1;
+				break;
+			} else {
+				aml_nand_dbg("read OK but magic is not hynix");
+				break;
+			}
+		}
+
+		if (retry_info->default_flag && flash->new_type)
+			break;
+	} while ((++start_blk) < total_blk);
+
+	if (retry_info->default_flag && flash->new_type) {
+		retry_info->info_save_blk = start_blk;
+		for (i = 0; i < RESERVED_BLOCK_CNT; i++) {
+			if (aml_chip->reserved_blk[i] == 0xff) {
+				aml_chip->reserved_blk[i] = start_blk;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+#ifdef AML_NAND_UBOOT
+
+/*****************************************************************************
+ *Name		:shipped_badblock_detect
+ *Description :Detect factory badblock once using the nand flash first time
+ *Parameter  :
+ *Return	      :
+ *Note	      :
+ *****************************************************************************/
+  static int shipped_badblock_detect(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct shipped_bbt * shipped_bbt_ptr = aml_chip->shipped_bbt_ptr;
+	unsigned short * tmp_arr;
+
+	int pages_per_blk, start_block, total_block, nand_boot, start_blk;
+	int  chipnr, offset, offset_tmp, read_cnt, page_addr, col0_data = 0, col_data_sandisk[6],  col0_oob = 0xff;
+	unsigned char phys_erase_shift, phys_page_shift;
+	int i, ret = 0, factory_badblock_cnt;
+	uint64_t  tmp_blk;
+	aml_nand_dbg("here!! ");
+
+	nand_boot = 1;
+	if (boot_device_flag == 0) {
+		nand_boot = 0;
+	}
+
+	if (nand_boot)
+		offset_tmp = (1024 * flash->pagesize);
+	else {
+		offset_tmp = 0;
+	}
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+	phys_page_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (phys_erase_shift -phys_page_shift));
+
+	start_blk = offset_tmp >> phys_erase_shift;
+	tmp_blk = flash->chipsize;
+	total_block = (int) ((tmp_blk<<20) >> phys_erase_shift);
+
+	aml_nand_dbg("phys_erase_shift=%d ",phys_erase_shift);
+	aml_nand_dbg("flash->chipsize =%d ",flash->chipsize);
+	aml_nand_dbg("flash->blocksize =%d ",flash->blocksize);
+	aml_nand_dbg("start_blk =%d ",start_blk);
+	aml_nand_dbg("total_block =%d ",total_block);
+	aml_nand_dbg("pages_per_blk =%d ",pages_per_blk);
+	//block 0 never bad block, so init table into 0
+	memset((unsigned char *)shipped_bbt_ptr, 0x0, (sizeof(struct shipped_bbt)));
+#ifdef AML_NAND_UBOOT
+		nand_get_chip(aml_chip);
+#else
+		nand_get_chip(aml_chip);
+#endif
+
+	for (chipnr=0; chipnr < controller->chip_num; chipnr++) {
+		aml_nand_dbg("chipnr=%d",chipnr);
+		factory_badblock_cnt = 0;
+		tmp_arr = &aml_chip->shipped_bbt_ptr->shipped_bbt[chipnr][0];
+		controller->select_chip(controller, chipnr);
+		for (start_block=start_blk; start_block < total_block; start_block++) {
+		//for(start_block = 0; start_block < total_block; start_block++){
+			if (((start_block ==  ((aml_chip->nand_key.valid_blk_addr +(controller->chip_num -1)*4)/controller->chip_num)) && (aml_chip->nand_key.arg_valid))
+				||((start_block ==  ((aml_chip->nand_secure.valid_blk_addr +(controller->chip_num -1)*4)/controller->chip_num))&&(aml_chip->nand_secure.arg_valid))){
+				aml_nand_msg("shipped_badblock_detect skip block %d,chipnr %d",start_block,chipnr);
+				continue;
+			}
+			offset = pages_per_blk*start_block;
+			for (read_cnt=0; read_cnt<2; read_cnt++) {
+
+				if ((controller->mfr_type  == NAND_MFR_SANDISK ))
+					page_addr = offset + read_cnt; // page0 page1
+				else
+					page_addr = offset + read_cnt*(pages_per_blk-1); // page_num
+
+				if (unlikely(page_addr >= controller->internal_page_nums)) {
+					page_addr -= controller->internal_page_nums;
+					page_addr |= controller->internal_page_nums *aml_chip->flash.internal_chipnr;
+				}
+				controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+				controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+				controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+				controller->cmd_ctrl(controller, page_addr, NAND_CTRL_ALE);
+				controller->cmd_ctrl(controller, page_addr>>8, NAND_CTRL_ALE);
+				controller->cmd_ctrl(controller, page_addr>>16, NAND_CTRL_ALE);
+				controller->cmd_ctrl(controller, NAND_CMD_READSTART, NAND_CTRL_CLE);
+
+				NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+
+				ret = controller->quene_rb(controller, chipnr);
+				if (ret) {
+					aml_nand_msg("quene rb busy here");
+					ret = -NAND_BUSY_FAILURE;
+					goto error_exit0;
+				}
+
+				 if (controller->option & NAND_CTRL_NONE_RB) {
+					controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+					NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+				}
+
+				if ((controller->mfr_type  == NAND_MFR_SANDISK )) {
+					for (i = 0; i < 6; i++) {
+						col_data_sandisk[i] = controller->readbyte(controller);
+						if (col_data_sandisk[i] == 0x0) {
+							col0_oob = 0x0;
+							break;
+						}
+					}
+				}else	{
+					col0_data = controller->readbyte(controller);
+					//TRHW
+					NFC_SEND_CMD_IDLE(controller, NAND_TRHW_TIME_CYCLE);
+
+					controller->cmd_ctrl(controller, NAND_CMD_RNDOUT, NAND_CTRL_CLE);
+					controller->cmd_ctrl(controller, flash->pagesize, NAND_CTRL_ALE);
+					controller->cmd_ctrl(controller, flash->pagesize>>8, NAND_CTRL_ALE);
+					controller->cmd_ctrl(controller, NAND_CMD_RNDOUTSTART, NAND_CTRL_CLE);
+					//TCCS
+					NFC_SEND_CMD_IDLE(controller, NAND_TCCS_TIME_CYCLE);
+
+					col0_oob = controller->readbyte(controller);
+				}
+
+				if (((controller->mfr_type == NAND_MFR_SAMSUNG ) && ((col0_oob != 0xFF) || (col0_data != 0xFF))) \
+					|| ((controller->mfr_type == NAND_MFR_TOSHIBA ) && ((col0_oob != 0xFF) || (col0_data != 0xFF))) \
+					||((controller->mfr_type  == NAND_MFR_MICRON ) && ((col0_oob == 0x0) ||(col0_oob != 0xFF))) \
+					||((controller->mfr_type  == NAND_MFR_HYNIX ) && (col0_oob != 0xFF)) \
+					||((controller->mfr_type  == NAND_MFR_SANDISK ) && (col0_oob != 0xFF))){
+
+					col0_oob = 0xff;
+					aml_nand_msg("mfr_type:%x detect factory Bad block at read_cnt:%d and block:%d and chip:%d", \
+											controller->mfr_type, read_cnt, start_block, chipnr);
+					tmp_arr[factory_badblock_cnt] = start_block |0x8000;
+					//aml_nand_msg("start_block is bad block = %d, tmp_arr[factory_badblock_cnt] = %d",
+						//start_block, tmp_arr[factory_badblock_cnt]);
+
+					if (start_block < start_blk) {
+						aml_nand_msg("WARNING: UBOOT AREA  BLOCK %d IS BAD BLOCK",start_block);
+					}
+
+					if ((controller->flash_type == NAND_TYPE_MLC) && (flash->option & NAND_MULTI_PLANE_MODE)) {
+						if ((start_block % 2) == 0 ) {		// if  plane 0 is bad block,just set plane 1 to bad
+							start_block+=1;
+							tmp_arr[++factory_badblock_cnt] = start_block |0x8000;
+							//aml_nand_msg(" plane 0 is bad block,just set plane 1 to bad:");
+						}else{					// if plane 1 is bad block, just set plane 0 to bad
+							tmp_arr[++factory_badblock_cnt]= (start_block -1) |0x8000;
+							//aml_nand_msg(" plane 1 is bad block,just set plane 0 to bad:");
+						}
+					}
+
+					//bad block should less than 6% of total blocks
+					if ((factory_badblock_cnt++ >= (total_block/2))) {
+						aml_nand_msg("detect factory bad block over 50%%, hardware problem and factory_badblock_cnt:%d, total_block:%d, chipnr:%d !!!", \
+												factory_badblock_cnt, total_block, chipnr);
+						if (aml_chip->shipped_retry_flag) {
+							ret  = -NAND_STATUS_FAILURE;
+						}else{
+							aml_chip->shipped_retry_flag = 1;
+							reset_amlchip_member(aml_chip);
+							amlnand_config_buf_free(aml_chip);
+							ret= -NAND_SHIPPED_BADBLOCK_FAILED;
+						}
+						goto error_exit0;
+					}
+					break;
+
+				}
+
+			}
+		}
+
+		aml_nand_msg("shipped bad block scan complete: chip %d, factory_badblock_cnt =%d (total_block/10) =%d",chipnr, factory_badblock_cnt,(total_block/10));
+	}
+
+#if 0
+	//display the fbbt
+	for (chipnr= 0; chipnr < controller->chip_num; chipnr++) {
+		tmp_arr = &aml_chip->shipped_bbt_ptr->shipped_bbt[chipnr][0];
+			for (start_block=0; start_block < 200; start_block++) {
+				aml_nand_msg(" tmp_arr[%d][%d]=%d", chipnr, start_block, tmp_arr[start_block]);
+			}
+	}
+#endif
+
+#ifdef AML_NAND_UBOOT
+		nand_release_chip(aml_chip);
+#else
+		nand_release_chip(aml_chip);
+#endif
+
+	return ret;
+
+error_exit0:
+#ifdef AML_NAND_UBOOT
+		nand_release_chip(aml_chip);
+#else
+		nand_release_chip(aml_chip);
+#endif
+	return ret;
+}
+
+#endif
+
+void amlnand_config_buf_free(struct amlnand_chip *aml_chip)
+{
+	if (aml_chip->block_status) {
+		kfree(aml_chip->block_status);
+		aml_chip->block_status = NULL;
+	}
+	if (aml_chip->shipped_bbt_ptr) {
+		kfree(aml_chip->shipped_bbt_ptr);
+		aml_chip->shipped_bbt_ptr = NULL;
+	}
+	if (aml_chip->config_ptr) {
+		kfree(aml_chip->config_ptr);
+		aml_chip->config_ptr = NULL;
+	}
+	if (aml_chip->user_oob_buf) {
+		kfree(aml_chip->user_oob_buf);
+		aml_chip->user_oob_buf = NULL;
+	}
+	if (aml_chip->user_page_buf) {
+		kfree(aml_chip->user_page_buf);
+		aml_chip->user_page_buf = NULL;
+	}
+	if (amlnand_config) {
+		kfree(amlnand_config);
+		amlnand_config = NULL;
+	}
+}
+
+static int amlnand_config_buf_malloc(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	/* struct chip_operation *operation = & aml_chip->operation; */
+	/* struct chip_ops_para  *ops_para = & aml_chip->ops_para; */
+	u32 ret = 0, buf_size;
+
+	buf_size = flash->oobsize * controller->chip_num;
+	if (flash->option & NAND_MULTI_PLANE_MODE)
+		buf_size <<= 1;
+	if (aml_chip->user_oob_buf == NULL) {
+		aml_chip->user_oob_buf = aml_nand_malloc(buf_size);
+		if (aml_chip->user_oob_buf == NULL) {
+			aml_nand_msg("malloc failed for user_oob_buf ");
+			ret = -NAND_MALLOC_FAILURE;
+			goto exit_error0;
+		}
+	}
+	memset(aml_chip->user_oob_buf, 0x0, buf_size);
+	buf_size = (flash->pagesize + flash->oobsize) * controller->chip_num;
+	if (flash->option & NAND_MULTI_PLANE_MODE)
+		buf_size <<= 1;
+
+	if (aml_chip->user_page_buf == NULL) {
+		aml_chip->user_page_buf = aml_nand_malloc(buf_size);
+		if (aml_chip->user_page_buf == NULL) {
+			aml_nand_msg("malloc failed for user_page_buf ");
+			ret = -NAND_MALLOC_FAILURE;
+			goto exit_error0;
+		}
+	}
+	memset(aml_chip->user_page_buf, 0x0, buf_size);
+
+	/* using to record each block status.*/
+	if (aml_chip->block_status == NULL) {
+		aml_chip->block_status =
+		(struct block_status *)aml_nand_malloc(sizeof(struct block_status));
+		if (aml_chip->block_status == NULL) {
+			aml_nand_msg("malloc failed for block_status and size:%x",
+				(u32)sizeof(struct block_status));
+			ret = -NAND_MALLOC_FAILURE;
+			goto exit_error0;
+		}
+	}
+	memset(aml_chip->block_status, 0x0, (sizeof(struct block_status)));
+	if (aml_chip->shipped_bbt_ptr == NULL) {
+		aml_chip->shipped_bbt_ptr = aml_nand_malloc(sizeof(struct shipped_bbt));
+		if (aml_chip->shipped_bbt_ptr == NULL) {
+			aml_nand_msg("malloc failed for shipped_bbt_ptr ");
+			ret = -NAND_MALLOC_FAILURE;
+			goto exit_error0;
+		}
+	}
+	memset(aml_chip->shipped_bbt_ptr, 0x0, (sizeof(struct shipped_bbt)));
+
+	if (aml_chip->config_ptr == NULL) {
+		aml_chip->config_ptr = aml_nand_malloc(sizeof(struct nand_config));
+		if (aml_chip->config_ptr == NULL) {
+			aml_nand_msg("malloc failed for config_ptr ");
+			ret = -NAND_MALLOC_FAILURE;
+			goto exit_error0;
+		}
+	}
+	memset(aml_chip->config_ptr, 0x0, (sizeof(struct nand_config)));
+
+	return ret;
+
+exit_error0:
+	amlnand_config_buf_free(aml_chip);
+	return ret ;
+}
+
+/*
+ * set attribute of each configs.
+ * FULL_BLK: write the whole block once.
+ * FULL_PAGE: write full pages once.
+ */
+void amlnand_set_config_attribute(struct amlnand_chip *aml_chip)
+{
+	aml_chip->nand_bbtinfo.arg_type = FULL_BLK;
+	aml_chip->shipped_bbtinfo.arg_type = FULL_BLK;
+	aml_chip->config_msg.arg_type = FULL_BLK;
+	aml_chip->nand_secure.arg_type = FULL_PAGE;
+	aml_chip->nand_key.arg_type = FULL_PAGE;
+	aml_chip->uboot_env.arg_type = FULL_PAGE;
+#if (AML_CFG_DTB_RSV_EN)
+	aml_chip->amlnf_dtb.arg_type = FULL_PAGE;
+#endif
+	return;
+}
+
+/*
+ bbt is valid.
+ */
+int  bbt_valid_ops(struct amlnand_chip *aml_chip)
+{
+	int  ret = 0;
+	ENV_NAND_LINE
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)(aml_chip->shipped_bbt_ptr),(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+	if (ret < 0) {
+		aml_nand_msg("Waring:Serch fbbt faile:%d",ret);
+		//goto exit_error0;
+	}
+
+	PRINT("%s\n", __func__);
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+	if (ret < 0) {
+		aml_nand_msg("nand scan config failed and ret:%d",ret);
+		goto exit_error0;
+	}
+	ENV_NAND_LINE
+
+	ret = aml_sys_info_init(aml_chip); //key  and stoarge and env
+	if (ret < 0) {
+		aml_nand_msg("nand init sys_info failed and ret:%d", ret);
+		goto exit_error0;
+	}
+
+	ENV_NAND_LINE
+#ifdef AML_NAND_UBOOT
+	if (aml_chip->config_msg.arg_valid == 1) {
+		ENV_NAND_LINE
+		ret = amlnand_configs_confirm(aml_chip);
+		ENV_NAND_LINE
+		if (ret < 0) {
+			if ((aml_chip->init_flag > NAND_BOOT_UPGRATE) && (aml_chip->init_flag < NAND_BOOT_SCRUB_ALL)) {
+				ret =0;
+			} else {
+				aml_nand_msg("nand configs confirm failed");
+				ret = -NAND_CONFIGS_FAILED;
+				goto exit_error0;
+			}
+		}
+	} else {
+		ENV_NAND_LINE
+		// do nothing....
+		aml_nand_msg("%s: do nothing!", __func__);
+//		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)aml_chip->shipped_bbt_ptr,(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+//		if(ret < 0){
+//			aml_nand_msg("nand scan shipped info failed and ret:%d",ret);
+//			goto exit_error0;
+//		}
+//		if(aml_chip->shipped_bbt_ptr->chipnum != controller->chip_num){
+//			aml_nand_msg("nand read chipnum in config %d,controller->chip_num",aml_chip->shipped_bbt_ptr->chipnum,controller->chip_num);
+//			ret = -NAND_SHIPPED_BADBLOCK_FAILED;
+//		}
+	}
+#endif
+	ENV_NAND_LINE
+exit_error0:
+	return ret;
+}
+
+int  shipped_bbt_invalid_ops(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	//struct nand_flash *flash = &aml_chip->flash;
+	//struct chip_operation *operation = & aml_chip->operation;
+	//struct chip_ops_para  *ops_para = & aml_chip->ops_para;
+	// nand_arg_info * nand_key = &aml_chip->nand_key;
+	//nand_arg_info  * nand_secure= &aml_chip->nand_secure;
+	unsigned char *buf = NULL;
+	int  ret = 0;
+#if 0
+	unsigned int buf_size = MAX(CONFIG_SECURE_SIZE,CONFIG_KEYSIZE);
+
+	buf = aml_nand_malloc(buf_size);
+	if (!buf) {
+	  aml_nand_msg("aml_sys_info_init : malloc failed");
+	}
+	memset(buf,0x0,buf_size);
+#endif
+/*
+	clean nand case!!!!!
+*/
+#if 1 //clean nand case
+	/* need erase */
+	if (aml_chip->init_flag > NAND_BOOT_ERASE_PROTECT_CACHE) {
+		/*check factory bad block by reading bad flags.*/
+		ret = shipped_badblock_detect(aml_chip);
+		if (ret < 0 ) {
+		 aml_nand_msg("nand detect factory bbt failed and ret:%d", ret);
+		 goto exit_error0;
+		}
+		/* fill block status according to shipped bad block. */
+		ret = amlnand_init_block_status(aml_chip);
+		if (ret < 0) {
+		 aml_nand_msg("nand init block status failed and ret:%d", ret);
+		 goto exit_error0;
+		}
+
+		aml_chip->nand_bbtinfo.arg_valid =1;//risking?it is need here.
+		/* erasing the whole chip then! */
+		amlnand_oops_handle(aml_chip,aml_chip->init_flag);
+		/* save bbt info.*/
+		aml_chip->nand_bbtinfo.arg_valid =0;
+		aml_chip->block_status->crc = aml_info_checksum((unsigned char *)aml_chip->block_status->blk_status,(MAX_CHIP_NUM*MAX_BLK_NUM));
+		ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)aml_chip->block_status,(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+		if (ret < 0) {
+		 aml_nand_msg("nand save bbt failed and ret:%d", ret);
+		 goto exit_error0;
+		}
+		/* save fbbt info.*/
+		aml_chip->shipped_bbt_ptr->crc = aml_info_checksum((unsigned char *)aml_chip->shipped_bbt_ptr->shipped_bbt,(MAX_CHIP_NUM*MAX_BAD_BLK_NUM));
+		aml_chip->shipped_bbt_ptr->chipnum = controller->chip_num;
+		ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)aml_chip->shipped_bbt_ptr,(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+		if (ret < 0) {
+		 aml_nand_msg("nand save shipped bbt failed and ret:%d",ret);
+		 goto exit_error0;
+		}
+
+	} else {
+	/* normal boot or upgrade, no need to erase the whole chip! */
+	/* init key info here!*/
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+		if (ret < 0) {
+			aml_nand_msg("invalid nand key\n");
+			goto exit_error0;
+		}
+#ifdef CONFIG_SECURE_NAND
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_secure),buf,(unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+		if (ret < 0) {
+			aml_nand_msg("invalid nand secure_ptr\n");
+			goto exit_error0;
+		}
+#endif
+
+		ret = shipped_badblock_detect(aml_chip);
+		if (ret < 0 ) {
+			aml_nand_msg("%s() %d: nand detect factory bbt failed and ret:%d", __FUNCTION__, __LINE__, ret);
+			goto exit_error0;
+		}
+
+		ret = amlnand_init_block_status(aml_chip);
+		if (ret < 0) {
+		 aml_nand_msg("%s() %d: nand init block status failed and ret:%d", __FUNCTION__, __LINE__, ret);
+		 goto exit_error0;
+		}
+
+		ret = aml_sys_info_init(aml_chip); //key  and  stoarge
+		if (ret < 0) {
+			aml_nand_msg("%s() %d: nand init sys_info failed and ret:%d", __FUNCTION__, __LINE__, ret);
+			goto exit_error0;
+		}
+
+		aml_chip->block_status->crc = aml_info_checksum((unsigned char *)aml_chip->block_status->blk_status,(MAX_CHIP_NUM*MAX_BLK_NUM));/*liang:if bbt is valid, never be here! so do this!*/
+		ret = amlnand_save_info_by_name(aml_chip,(unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)aml_chip->block_status,(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+		if (ret < 0) {
+		 aml_nand_msg("nand save bbt failed and ret:%d", ret);
+		 goto exit_error0;
+		}
+
+		aml_chip->shipped_bbt_ptr->crc = aml_info_checksum((unsigned char *)aml_chip->shipped_bbt_ptr->shipped_bbt,(MAX_CHIP_NUM*MAX_BAD_BLK_NUM));
+		aml_chip->shipped_bbt_ptr->chipnum = controller->chip_num;
+		ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)(aml_chip->shipped_bbt_ptr),(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+		if (ret < 0) {
+		 aml_nand_msg("nand save shipped bbt failed and ret:%d",ret);
+		 goto exit_error0;
+		}
+		//save config
+		aml_chip->config_ptr->driver_version = DRV_PHY_VERSION;
+		aml_chip->config_ptr->fbbt_blk_addr = aml_chip->shipped_bbtinfo.valid_blk_addr;
+		amlnand_get_dev_num(aml_chip,(struct amlnf_partition *)amlnand_config);
+
+		aml_chip->config_ptr->crc = aml_info_checksum((unsigned char *)(aml_chip->config_ptr->dev_para),(MAX_DEVICE_NUM*sizeof(struct dev_para)));
+		ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+		if (ret < 0) {
+			aml_nand_msg("save nand dev_configs failed and ret:%d",ret);
+			goto exit_error0;
+		}
+		/*
+		liang: it is not need here. is it ??? when uboot run and will check it,if crc error, will overwrite env.
+		*/
+		if (aml_chip->init_flag > NAND_BOOT_ERASE_PROTECT_CACHE) {
+			aml_chip->uboot_env.update_flag = 1;
+			if ((aml_chip->uboot_env.arg_valid == 1) && (aml_chip->uboot_env.update_flag)) {
+				aml_nand_update_ubootenv(aml_chip,NULL);
+				aml_chip->uboot_env.update_flag = 0;
+				aml_nand_msg("NAND UPDATE CKECK  : arg %s: arg_valid= %d, valid_blk_addr = %d, valid_page_addr = %d",\
+					"ubootenv",aml_chip->uboot_env.arg_valid, aml_chip->uboot_env.valid_blk_addr, aml_chip->uboot_env.valid_page_addr);
+			}
+		}
+	}
+#else
+
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+	if (ret < 0) {
+	aml_nand_msg("invalid nand key\n");
+	goto exit_error0;
+	}
+
+#ifdef CONFIG_SECURE_NAND
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_secure),buf,(unsigned char *)SECURE_INFO_HEAD_MAGIC, CONFIG_SECURE_SIZE);
+	if (ret < 0) {
+		aml_nand_msg("invalid nand secure_ptr\n");
+		goto exit_error0;
+	}
+#endif
+
+
+	if (aml_chip->init_flag > NAND_BOOT_ERASE_PROTECT_CACHE) {
+		amlnand_oops_handle(aml_chip,aml_chip->init_flag);
+	}
+
+	ret = shipped_badblock_detect(aml_chip);
+	if (ret < 0 ) {
+	 aml_nand_msg("nand detect factory bbt failed and ret:%d", ret);
+	 goto exit_error0;
+	}
+
+	ret = amlnand_init_block_status(aml_chip);
+	if (ret < 0) {
+	 aml_nand_msg("nand init block status failed and ret:%d", ret);
+	 goto exit_error0;
+	}
+
+//if((aml_chip->init_flag == NAND_BOOT_ERASE_ALL))
+	// amlnand_oops_handle(aml_chip,aml_chip->init_flag);
+
+	ret = aml_sys_info_init(aml_chip); //key  and  stoarge
+	if (ret < 0) {
+		aml_nand_msg("nand init sys_info failed and ret:%d", ret);
+		goto exit_error0;
+	}
+
+	   aml_chip->block_status->crc = aml_info_checksum((unsigned char *)(aml_chip->block_status->blk_status),(MAX_CHIP_NUM*MAX_BLK_NUM));
+	   ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)(aml_chip->block_status),(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+	   if (ret < 0) {
+		   aml_nand_msg("nand save bbt failed and ret:%d", ret);
+		   goto exit_error0;
+	   }
+
+	   aml_chip->shipped_bbt_ptr->crc = aml_info_checksum((unsigned char *)(aml_chip->shipped_bbt_ptr->shipped_bbt),(MAX_CHIP_NUM*MAX_BAD_BLK_NUM));
+	   aml_chip->shipped_bbt_ptr->chipnum = controller->chip_num;
+	   ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)(aml_chip->shipped_bbt_ptr),(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+	   if (ret < 0) {
+		   aml_nand_msg("nand save shipped bbt failed and ret:%d",ret);
+		   goto exit_error0;
+	   }
+	   //save config
+	   aml_chip->config_ptr->driver_version = DRV_PHY_VERSION;
+	   aml_chip->config_ptr->fbbt_blk_addr = aml_chip->shipped_bbtinfo.valid_blk_addr;
+	   amlnand_get_dev_num(aml_chip,(struct amlnf_partition *)amlnand_config);
+
+	   aml_chip->config_ptr->crc = aml_info_checksum((unsigned char *)(aml_chip->config_ptr->dev_para),(MAX_DEVICE_NUM*sizeof(struct dev_para)));
+	  ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+	   if (ret < 0) {
+		   aml_nand_msg("save nand dev_configs failed and ret:%d",ret);
+		   goto exit_error0;
+	   }
+
+	if (aml_chip->init_flag > NAND_BOOT_ERASE_PROTECT_CACHE) {
+		aml_chip->uboot_env.update_flag = 1;
+		 if ((aml_chip->uboot_env.arg_valid == 1) && (aml_chip->uboot_env.update_flag)) {
+			aml_nand_update_ubootenv(aml_chip,NULL);
+			aml_chip->uboot_env.update_flag = 0;
+			aml_nand_msg("NAND UPDATE CKECK  : arg %s: arg_valid= %d, valid_blk_addr = %d, valid_page_addr = %d",\
+					"ubootenv",aml_chip->uboot_env.arg_valid, aml_chip->uboot_env.valid_blk_addr, aml_chip->uboot_env.valid_page_addr);
+		}
+	}
+#endif
+
+exit_error0:
+	if (buf) {
+		kfree(buf);
+		buf = NULL;
+	}
+	return ret;
+}
+
+int shipped_bbt_valid_ops(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	//struct nand_flash *flash = &aml_chip->flash;
+	//struct chip_operation *operation = & aml_chip->operation;
+	//struct chip_ops_para  *ops_para = & aml_chip->ops_para;
+	// nand_arg_info * nand_key = &aml_chip->nand_key;
+	//nand_arg_info  * nand_secure= &aml_chip->nand_secure;
+	int  ret = 0;
+	ENV_NAND_LINE
+	if (aml_chip->shipped_bbt_ptr->chipnum != controller->chip_num) {
+		aml_nand_msg("nand read chipnum in config %d,controller->chip_num:%d",aml_chip->shipped_bbt_ptr->chipnum,controller->chip_num);
+		ret = -NAND_SHIPPED_BADBLOCK_FAILED ;
+		goto exit_error0;
+	}
+
+	ret = amlnand_init_block_status(aml_chip);
+	if (ret < 0 ) {
+			aml_nand_msg("nand init blcok status failed and ret:%d", ret);
+			goto exit_error0;
+	}
+
+	if (aml_chip->init_flag < NAND_BOOT_ERASE_PROTECT_CACHE) {
+		ENV_NAND_LINE
+		ret = aml_sys_info_init(aml_chip); //key  and  stoarge
+		if (ret < 0) {
+			aml_nand_msg("nand init sys_info failed and ret:%d", ret);
+			goto exit_error0;
+		}
+		ENV_NAND_LINE
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+		if (ret < 0) {
+			aml_nand_msg("nand scan config failed and ret:%d",ret);
+			goto exit_error0;
+		}
+		ENV_NAND_LINE
+		aml_chip->block_status->crc = aml_info_checksum((unsigned char *)aml_chip->block_status->blk_status,(MAX_CHIP_NUM*MAX_BLK_NUM));
+		ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)(aml_chip->block_status),(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+		if (ret < 0) {
+			aml_nand_msg("nand save bbt failed and ret:%d", ret);
+			goto exit_error0;
+		}
+		ENV_NAND_LINE
+		//save config
+		aml_chip->config_ptr->driver_version = DRV_PHY_VERSION;
+		aml_chip->config_ptr->fbbt_blk_addr = aml_chip->shipped_bbtinfo.valid_blk_addr;
+		amlnand_get_dev_num(aml_chip,(struct amlnf_partition *)amlnand_config);
+		ENV_NAND_LINE
+		aml_chip->config_ptr->crc = aml_info_checksum((unsigned char *)(aml_chip->config_ptr->dev_para),(MAX_DEVICE_NUM*sizeof(struct dev_para)));
+		ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+		if (ret < 0) {
+			aml_nand_msg("nand save config failed and ret:%d",ret);
+			goto exit_error0;
+		}
+		ENV_NAND_LINE
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+		if (ret < 0) {
+			aml_nand_msg("nand scan config failed and ret:%d",ret);
+			goto exit_error0;
+		}
+		ENV_NAND_LINE
+		/*liang: check if config is exist,if it is, use old config which is saved in nandflash*/
+		if ((aml_chip->config_msg.arg_valid == 1)) {
+			ENV_NAND_LINE
+			ret = amlnand_configs_confirm(aml_chip);
+			ENV_NAND_LINE
+			if (ret < 0) {
+				if ((aml_chip->init_flag > NAND_BOOT_UPGRATE) && (aml_chip->init_flag < NAND_BOOT_SCRUB_ALL)) {
+					ret =0;
+				}else{
+					aml_nand_msg("nand configs confirm failed");
+					ret = -NAND_CONFIGS_FAILED;
+					goto exit_error0;
+				}
+			}
+		}else{
+			//save config
+			aml_chip->config_ptr->driver_version = DRV_PHY_VERSION;
+			aml_chip->config_ptr->fbbt_blk_addr = aml_chip->shipped_bbtinfo.valid_blk_addr;
+			amlnand_get_dev_num(aml_chip,(struct amlnf_partition *)amlnand_config);
+			ENV_NAND_LINE
+			aml_chip->config_ptr->crc = aml_info_checksum((unsigned char *)aml_chip->config_ptr->dev_para,(MAX_DEVICE_NUM*sizeof(struct dev_para)));
+			ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+			if (ret < 0) {
+				aml_nand_msg("nand save config failed and ret:%d",ret);
+				goto exit_error0;
+			}
+			ENV_NAND_LINE
+		}
+		/* fixme, can not reach here! */
+		if (aml_chip->init_flag > NAND_BOOT_ERASE_PROTECT_CACHE) {
+			aml_chip->uboot_env.update_flag = 1;
+			if ((aml_chip->uboot_env.arg_valid == 1) && (aml_chip->uboot_env.update_flag)) {
+				aml_nand_update_ubootenv(aml_chip,NULL);
+				aml_chip->uboot_env.update_flag = 0;
+				aml_nand_msg("NAND UPDATE CKECK  : arg %s: arg_valid= %d, valid_blk_addr = %d, valid_page_addr = %d",\
+						"ubootenv",aml_chip->uboot_env.arg_valid, aml_chip->uboot_env.valid_blk_addr, aml_chip->uboot_env.valid_page_addr);
+			}
+		}
+	} else {
+		aml_chip->nand_bbtinfo.arg_valid = 1;//risking?it is need here.
+		amlnand_oops_handle(aml_chip,aml_chip->init_flag);
+		aml_chip->nand_bbtinfo.arg_valid = 0;
+		aml_chip->block_status->crc = aml_info_checksum((unsigned char *)aml_chip->block_status->blk_status,(MAX_CHIP_NUM*MAX_BLK_NUM));
+		ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)(aml_chip->block_status),(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+		if (ret < 0) {
+			aml_nand_msg("nand save bbt failed and ret:%d", ret);
+			goto exit_error0;
+		}
+	}
+
+exit_error0:
+	return ret;
+}
+
+/* fixme, */
+#if 0
+static int _get_bbt_fbbt(struct amlnand_chip *aml_chip, int flag)
+{
+	int ret = 0;
+	/* 3.1 get bbt info 1st*/
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)(aml_chip->block_status),(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+	if (ret < 0) {
+		aml_nand_msg("%s() %d: nand scan bbt info failed and ret:%d", __FUNCTION__, __LINE__, ret);
+	}
+	/* 3.2 get fbbt info if bbt info is not exist.*/
+	if (aml_chip->nand_bbtinfo.arg_valid == 0) {
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)aml_chip->shipped_bbt_ptr,(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+		if (ret < 0) {
+			aml_nand_msg("%s() %d: nand scan shipped bbt info failed and ret:%d", __FUNCTION__, __LINE__, ret);
+		}
+		/* 3.3 ship bbt invalid, rebuild it */
+		if (aml_chip->shipped_bbtinfo.arg_valid == 0) {
+		/*todo
+			one, !!!!!!
+			fbbt lost or clean nand.
+			how to check that fbbt is lost or it only a clean nand.
+			if a clean nand, first scan factory bad block and then created a bad block table.
+			else fbbt is lost ,need to do some test-patterns and search bad blocks.
+		*/
+			ret = shipped_bbt_invalid_ops(aml_chip);
+			if (ret < 0) {
+				aml_nand_msg("shipped_bbt_invalid_ops and ret:%d", ret);
+				goto _out;	//fixme, may need free buffer
+			}
+		} else {
+			/* 3.4 ship bbt valid, */
+			ret = shipped_bbt_valid_ops(aml_chip);
+			if (ret < 0) {
+				aml_nand_msg("shipped_bbt_valid_ops and ret:%d", ret);
+				goto _out; //fixme, may need free buffer
+			}
+		}
+	} else { /* bbt is valid */
+		/*liang:
+			for amlnand_oops_handle,it will not erase fbbt if exist.
+		  fixme, may need to check fbbt which may need a refresh.
+		*/
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)(aml_chip->shipped_bbt_ptr),(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+		if (ret < 0) {
+			aml_nand_msg("nand scan shipped info failed and ret:%d",ret);
+		}
+		amlnand_oops_handle(aml_chip,aml_chip->init_flag);
+	}
+
+_out:
+	return ret;
+}
+
+
+static int get_bbt_fbbt(struct amlnand_chip *aml_chip, int flag)
+{
+	int ret = 0;
+
+	switch (flag)
+	{
+		case NAND_BOOT_NORMAL:
+		case NAND_BOOT_UPGRATE:
+
+		break;
+
+		case NAND_BOOT_ERASE_PROTECT_CACHE:
+
+		break;
+		case NAND_BOOT_ERASE_ALL:
+		case NAND_BOOT_SCRUB_ALL:
+		case NAND_SCAN_ID_INIT: //fixme, this flag should already return earlier.
+
+		break;
+
+		default:
+			aml_nand_msg("%s() %d: no such flag(%d) while phy dev init.", __FUNCTION__, __LINE__, flag);
+	}
+
+	return ret;
+}
+#endif
+/*****************************************************************************
+*Name         :amlnand_get_dev_configs
+*Description :search bbt /fbbt /config /key;
+*Parameter  :
+*Return       :
+*Note          :
+*****************************************************************************/
+int amlnand_get_dev_configs(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	//struct chip_operation *operation = & aml_chip->operation;
+	//struct chip_ops_para  *ops_para = & aml_chip->ops_para;
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	//struct dev_para *dev_para = NULL;
+	// nand_arg_info * nand_key = &aml_chip->nand_key;
+	//nand_arg_info  * nand_secure= &aml_chip->nand_secure;
+	int  ret = 0;
+
+	/* 1. setting config attribute.*/
+	ENV_NAND_LINE;
+	amlnand_set_config_attribute(aml_chip);
+
+	ENV_NAND_LINE;
+	ret = amlnand_config_buf_malloc(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand malloc buf failed");
+		goto exit_error0;
+	}
+	ENV_NAND_LINE;
+	/* get retry infos on the otp area.*/
+	if (aml_chip->flash.new_type) {
+		ENV_NAND_LINE;
+		aml_nand_msg("detect new nand here and new_type:%d", aml_chip->flash.new_type);
+		ret = amlnand_set_readretry_slc_para(aml_chip);
+		if (ret<0) {
+			aml_nand_msg("setting new nand para failed and ret:0x%x", ret);
+			goto exit_error0;
+		}
+	}
+
+	ENV_NAND_LINE;
+#ifdef AML_NAND_UBOOT
+	/* 2. get partition table from outsides, maybe sram.*/
+	ret = amlnand_get_partition_table(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("amlnand_get_partition_table failed");
+		goto exit_error0;
+	}
+#endif
+
+	/* 3. with erase flags*/
+	if ((aml_chip->init_flag > NAND_BOOT_ERASE_PROTECT_CACHE)) {
+		ENV_NAND_LINE;
+		/* 3.1 get bbt info 1st*/
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)(aml_chip->block_status),(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+		if (ret < 0) {
+			aml_nand_msg("%s() %d: nand scan bbt info failed and ret:%d", __FUNCTION__, __LINE__, ret);
+			//goto exit_error0;
+		}
+		ENV_NAND_LINE;
+		/* 3.2 get fbbt info if bbt info is not exist.*/
+		if (aml_chip->nand_bbtinfo.arg_valid == 0) {
+			ENV_NAND_LINE;
+			ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)aml_chip->shipped_bbt_ptr,(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+			if (ret < 0) {
+				aml_nand_msg("%s() %d: nand scan shipped bbt info failed and ret:%d", __FUNCTION__, __LINE__, ret);
+				//goto exit_error0;
+			}
+			/* 3.3 ship bbt invalid, rebuild it */
+			if (aml_chip->shipped_bbtinfo.arg_valid == 0) {
+			/*todo
+				one, !!!!!!fbbt lost or clean nand.
+				how to check that fbbt is lost or it only a clean nand.
+				if a clean nand, first scan factory bad block and then created a bad block table.
+				else fbbt is lost ,need to do some test-patterns and search bad blocks.
+			*/
+				ENV_NAND_LINE;
+				ret = shipped_bbt_invalid_ops(aml_chip);
+				if (ret < 0) {
+					aml_nand_msg("shipped_bbt_invalid_ops and ret:%d", ret);
+					goto exit_error0;
+				}
+			} else {
+				/* 3.4 ship bbt valid, */
+				ENV_NAND_LINE;
+				ret = shipped_bbt_valid_ops(aml_chip);
+				if (ret < 0) {
+					aml_nand_msg("shipped_bbt_valid_ops and ret:%d", ret);
+					goto exit_error0;
+				}
+			}
+		} else {
+			/*liang:
+				for amlnand_oops_handle,it will not erase fbbt if exist.
+			  fixme, may need to check fbbt which may need a refresh.
+			*/
+			ENV_NAND_LINE;
+			ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)(aml_chip->shipped_bbt_ptr),(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+			if (ret < 0) {
+				aml_nand_msg("nand scan shipped info failed and ret:%d",ret);
+			}
+			ENV_NAND_LINE;
+			amlnand_oops_handle(aml_chip,aml_chip->init_flag);
+		}
+		ENV_NAND_LINE;
+	}else if(aml_chip->init_flag == NAND_BOOT_ERASE_PROTECT_CACHE) {
+		/* 4. erase protect cache only!*/
+		ENV_NAND_LINE;
+		amlnand_oops_handle(aml_chip, aml_chip->init_flag);
+	} else {
+		/* 5. without erase, normal boot or upgrade */
+		/* 5.1 search bbt 1st.*/
+		ENV_NAND_LINE
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_bbtinfo),(unsigned char *)(aml_chip->block_status),(unsigned char *)BBT_HEAD_MAGIC, sizeof(struct block_status));
+		if (ret < 0) {
+			aml_nand_msg("nand scan bbt info  failed :%d",ret);
+		}
+
+		if (aml_chip->nand_bbtinfo.arg_valid == 0) { // bbt invalid
+#ifdef AML_NAND_UBOOT
+			ENV_NAND_LINE
+			ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->shipped_bbtinfo),(unsigned char *)(aml_chip->shipped_bbt_ptr),(unsigned char *)SHIPPED_BBT_HEAD_MAGIC, sizeof(struct shipped_bbt));
+			if (ret < 0) {
+				aml_nand_msg("nand scan shipped info failed and ret:%d",ret);
+				//goto exit_error0;
+			}
+			ENV_NAND_LINE
+			if (aml_chip->shipped_bbtinfo.arg_valid == 0) {	// ship bbt invalid
+				ret = shipped_bbt_invalid_ops(aml_chip);
+				if (ret < 0) {
+					aml_nand_msg("shipped_bbt_invalid_ops and ret:%d", ret);
+					goto exit_error0;
+				}
+			} else {		// ship bbt valid
+				ENV_NAND_LINE
+				ret = shipped_bbt_valid_ops(aml_chip);
+				if (ret < 0) {
+					aml_nand_msg("shipped_bbt_valid_ops and ret:%d", ret);
+					goto exit_error0;
+				}
+			}
+#else
+			aml_nand_msg("nand scan bbt failed");
+			ret = -NAND_READ_FAILED;
+			goto exit_error0;
+#endif
+		} else {	// bbt valid
+			ENV_NAND_LINE
+			ret = bbt_valid_ops(aml_chip);
+			if (ret < 0) {
+				aml_nand_msg("shipped_bbt_valid_ops and ret:%d", ret);
+				goto exit_error0;
+			}
+		}
+	}
+	/* normal boot or upgrade */
+	ENV_NAND_LINE
+	if ((aml_chip->init_flag < NAND_BOOT_ERASE_PROTECT_CACHE)) {
+#ifdef AML_NAND_UBOOT
+		if (aml_chip->config_msg.arg_valid == 0) { // if no config,just save
+			ENV_NAND_LINE
+			aml_chip->config_ptr->driver_version = DRV_PHY_VERSION;
+			ENV_NAND_LINE
+			aml_chip->config_ptr->fbbt_blk_addr = aml_chip->shipped_bbtinfo.valid_blk_addr;
+			ENV_NAND_LINE
+			/* fixme, debug code. */
+			aml_nand_msg("%s() %d", __func__, __LINE__);
+			amlnand_get_dev_num(aml_chip,(struct amlnf_partition *)amlnand_config);
+			ENV_NAND_LINE
+			aml_chip->config_ptr->crc = aml_info_checksum((unsigned char *)aml_chip->config_ptr->dev_para,(MAX_DEVICE_NUM*sizeof(struct dev_para)));
+			ENV_NAND_LINE
+			ret = amlnand_save_info_by_name(aml_chip, (unsigned char *)&(aml_chip->config_msg),(unsigned char *)(aml_chip->config_ptr),(unsigned char *)CONFIG_HEAD_MAGIC, sizeof(struct nand_config));
+			if (ret < 0) {
+				aml_nand_msg("nand save config failed and ret:%d",ret);
+				goto exit_error0;
+			}
+		}
+		ENV_NAND_LINE
+		if (flash->new_type && (flash->new_type < 10) && (retry_info->default_flag == 0)) {
+			ENV_NAND_LINE
+			ret = aml_nand_save_hynix_info(aml_chip);
+			if (ret < 0) {
+				aml_nand_msg("hynix nand save readretry info failed and ret:%d", ret);
+				goto exit_error0;
+			}
+		}
+
+		if (aml_chip->shipped_bbt_ptr) {
+			kfree(aml_chip->shipped_bbt_ptr);
+			aml_chip->shipped_bbt_ptr = NULL;
+		}
+#endif
+		ENV_NAND_LINE
+		amlnand_info_error_handle(aml_chip);
+
+		/*liang:sure? is it need?*/
+		/* fixme, yyh */
+		repair_reserved_bad_block(aml_chip);
+		/* fixme, do not free buffers....*/
+		return ret ;
+	}
+	/*fixme, should not return here?*/
+	//return ret;
+	ENV_NAND_LINE
+exit_error0:
+/* fixme, debug code*/
+	/* free this for bad block detect! */
+	ENV_NAND_LINE
+	kfree(aml_chip->block_status);
+	aml_chip->block_status = NULL;
+#if 0
+	kfree(aml_chip->shipped_bbt_ptr);
+	aml_chip->shipped_bbt_ptr = NULL;
+
+	kfree(aml_chip->config_ptr);
+	aml_chip->config_ptr = NULL;
+	/* fixme, user_page_buf */
+	kfree(aml_chip->user_oob_buf);
+	aml_chip->user_oob_buf = NULL;
+
+	kfree(aml_chip->user_page_buf);
+	aml_chip->user_page_buf = NULL;
+#endif
+	return ret;
+}
+
diff --git a/drivers/nand/phy/cmd_utils.c b/drivers/nand/phy/cmd_utils.c
new file mode 100644
index 0000000..6c4cf6b
--- /dev/null
+++ b/drivers/nand/phy/cmd_utils.c
@@ -0,0 +1,460 @@
+
+#include "../include/phynand.h"
+
+
+void amlnf_dump_chipinfo(void)
+{
+	struct amlnand_chip *aml_chip = aml_nand_chip;
+
+	amlchip_dumpinfo(aml_chip);
+	return;
+}
+/*in bytes*/
+void amlnf_get_chip_size(u64 *size)
+{
+	struct amlnand_chip *aml_chip = aml_nand_chip;
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	u64 chipsize = 0;
+
+	chipsize = ((u64)(flash->chipsize*controller->chip_num))<<20;
+	*size = chipsize;
+
+	return;
+}
+
+void amlnand_dump_page(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	//struct hw_controller *controller = &(aml_chip->controller);
+	//struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+
+	u64  dump_len = 0;
+	u8 *tmp =  NULL;
+	int ret = 0;
+
+	ret = phydev->read(phydev);
+	if (ret < 0) {
+		aml_nand_msg("amlnand_dump_page : read failed page_addr:%d",
+			ops_para->page_addr);
+	}
+	aml_nand_msg("\n show the raw read BUF: ");
+	tmp = devops->datbuf;
+	dump_len = 512;
+	while (dump_len--) {
+		aml_nand_msg("\t%02x %02x %02x %02x %02x %02x %02x %02x	%02x %02x %02x %02x %02x %02x %02x %02x",
+			tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5],	tmp[6], tmp[7], tmp[8], tmp[9], tmp[10], tmp[11],
+			tmp[12], tmp[13], tmp[14], tmp[15]);
+			tmp += 16;
+	}
+	return;
+}
+
+
+int nand_read_ops(struct amlnand_phydev *phydev)
+{
+	struct phydev_ops *devops = &(phydev->ops);
+
+	u64 offset , read_len;
+	u8 *buffer;
+	int ret = 0;
+
+	offset = devops->addr;
+	read_len = devops->len;
+	buffer = devops->datbuf;
+
+	aml_nand_dbg("offset =%llx", offset);
+	aml_nand_dbg("write_len =%llx", read_len);
+
+	if ((offset & (phydev->writesize - 1)) != 0
+		|| (read_len & (phydev->writesize - 1)) != 0) {
+		printf("Attempt to read non page aligned data\n");
+		return -NAND_READ_FAILED;
+	}
+
+	if ((offset + read_len) > phydev->size) {
+		aml_nand_dbg("Attemp to read out side the dev area");
+		return -NAND_READ_FAILED;
+	}
+
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = buffer;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+	aml_nand_dbg("phydev->writesize= %x", phydev->writesize);
+	do {
+		if ((devops->addr % phydev->erasesize) == 0) {
+			/* aml_nand_dbg("devops->addr = %llx",devops->addr); */
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				printf("\rSkipping bad block at %llx\n",
+					devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				printf("\n:AMLNAND get bad block failed: ret=%d at addr=%llx\n",
+					ret,
+					devops->addr);
+				return -1;
+			}
+		}
+
+		ret = phydev->read(phydev);
+		if (ret < 0)
+			aml_nand_dbg("nand read failed at %llx", devops->addr);
+
+		devops->addr +=  phydev->writesize;
+		devops->datbuf += phydev->writesize;
+	} while (devops->addr < (offset + read_len));
+
+	return ret;
+}
+
+int nand_write_ops(struct amlnand_phydev *phydev)
+{
+	struct phydev_ops *devops = &(phydev->ops);
+
+	u64 offset , write_len;
+	u8 *buffer;
+	int ret = 0;
+
+	offset = devops->addr;
+	write_len = devops->len;
+	buffer = devops->datbuf;
+
+	if ((offset & (phydev->writesize - 1)) != 0
+		|| (write_len & (phydev->writesize - 1)) != 0) {
+		printf("Attempt to write non page aligned data\n");
+		return -NAND_WRITE_FAILED;
+	}
+
+	if ((offset + write_len) > phydev->size) {
+		aml_nand_msg("Attemp to write out side the dev area");
+		return -NAND_WRITE_FAILED;
+	}
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = buffer;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+	aml_nand_msg("phydev->writesize= %x", phydev->writesize);
+	do {
+		if ((devops->addr % phydev->erasesize) == 0) {
+			aml_nand_dbg("devops->addr = %llx",devops->addr);
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				printf("\rSkipping bad block at %llx\n",
+					devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				printf("\n:AMLNAND get bad block failed: ret=%d at addr=%llx\n", ret, devops->addr);
+				return -1;
+			}
+		}
+
+		ret = phydev->write(phydev);
+		if (ret < 0)
+			aml_nand_dbg("nand write failed at %llx", devops->addr);
+
+		devops->addr +=  phydev->writesize;
+		devops->datbuf	 += phydev->writesize;
+	} while (devops->addr < (offset + write_len));
+
+	return ret;
+}
+#if 1
+static int erase_env_protect(struct amlnand_chip *aml_chip, int blk)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	struct nand_arg_info *shipped_bbtinfo = &aml_chip->shipped_bbtinfo;
+	struct nand_arg_info *nand_key = &aml_chip->nand_key;
+	struct nand_arg_info *nand_secure = &aml_chip->nand_secure;
+	unsigned char phys_erase_shift;
+	unsigned short start_blk, nand_boot;
+	unsigned  offset;
+	int ret = 0;
+
+	nand_boot = 1;
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else {
+		offset = 0;
+	}
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+
+	start_blk = (int)(offset >> phys_erase_shift);
+
+	blk  -= (controller->chip_num - 1) * start_blk;
+
+	if (!(info_disprotect & DISPROTECT_FBBT)) {
+		/* do not erase fbbt whenever! */
+		if (((blk == shipped_bbtinfo->valid_blk_addr))
+			&&(shipped_bbtinfo->valid_blk_addr >= start_blk)){
+			aml_nand_msg("protect fbbt at blk %d",blk);
+			ret = -1;
+		}else if(((blk == retry_info->info_save_blk)
+			&&(retry_info->info_save_blk >= start_blk)
+			&&(flash->new_type)
+			&&(flash->new_type < 10))
+			&&(!(info_disprotect & DISPROTECT_HYNIX))){
+			aml_nand_msg("protect hynix retry info at blk %d",blk);
+			ret = -1;
+		}else if((blk == nand_key->valid_blk_addr)
+			&&(nand_key->valid_blk_addr >= start_blk)
+			&&(!(info_disprotect & DISPROTECT_KEY))){
+			aml_nand_msg("protect nand_key info at blk %d",blk);
+			ret = -1;
+		}else if((blk == nand_secure->valid_blk_addr)
+			&&(nand_secure->valid_blk_addr >= start_blk)
+			&&(!(info_disprotect & DISPROTECT_SECURE))){
+			aml_nand_msg("protect nand_secure info at blk %d",blk);
+			ret = -1;
+		}else{
+			ret = 0;
+		}
+	}
+	return ret;
+}
+#else
+static int erase_env_protect(struct amlnand_chip *aml_chip, int blk)
+{
+	struct hw_controller *controller = &aml_chip->controller;
+	struct nand_flash *flash = &aml_chip->flash;
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	struct nand_arg_info *shipped_bbtinfo = &aml_chip->shipped_bbtinfo;
+	struct nand_arg_info *nand_key = &aml_chip->nand_key;
+	struct nand_arg_info *nand_secure = &aml_chip->nand_secure;
+
+	u8 phys_erase_shift;
+	u16 start_blk, nand_boot;
+	u32  offset;
+	int ret = 0;
+
+	nand_boot = 1;
+	/*if(boot_device_flag == 0){
+		nand_boot = 0;
+	}*/
+
+	if (nand_boot)
+		offset = (1024 * flash->pagesize);
+	else
+		offset = 0;
+
+	phys_erase_shift = ffs(flash->blocksize) - 1;
+
+	start_blk = (int)(offset >> phys_erase_shift);
+
+	/* decrease the uboot block; */
+	blk  -= (controller->chip_num - 1) * start_blk;
+
+	if (!aml_chip->fbbt_protect) {
+		if (((blk == shipped_bbtinfo->valid_blk_addr))
+			&& (shipped_bbtinfo->valid_blk_addr >= start_blk)
+			&& (!(aml_chip->protect & 1))) {
+			aml_nand_msg("protect fbbt at blk %d", blk);
+			ret = -1;
+		} else if (((blk == retry_info->info_save_blk)
+			&& (retry_info->info_save_blk >= start_blk)
+			&& (flash->new_type)
+			&& (flash->new_type < 10))) {
+			aml_nand_msg("protect hynix retry info at blk %d", blk);
+			ret = -1;
+		} else if ((blk == nand_key->valid_blk_addr)
+			&& (nand_key->valid_blk_addr >= start_blk)
+			&& (!(aml_chip->protect & (1<<1)))) {
+			aml_nand_msg("protect nand_key info at blk %d", blk);
+			ret = -1;
+		} else if ((blk == nand_secure->valid_blk_addr)
+			&& (nand_secure->valid_blk_addr >= start_blk)
+			&& (!(aml_chip->protect & (1<<2)))) {
+			aml_nand_msg("protect nand_secure info at blk %d", blk);
+			ret = -1;
+		} else
+			ret = 0;
+	}
+
+	return ret;
+}
+#endif
+
+int  amlnf_erase_ops(u64 off, u64 erase_len, u8 scrub_flag)
+{
+	struct amlnand_chip *aml_chip = aml_nand_chip;
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct nand_flash *flash = &(aml_chip->flash);
+	u32 erase_shift, write_shift, pages_per_blk;
+	int  start_blk, total_blk, ret = 0;
+	int percent = 0;
+	int percent_complete = -1;
+	int temp_value;
+
+	erase_shift = ffs(flash->blocksize) - 1;
+	write_shift =  ffs(flash->pagesize) - 1;
+	start_blk = (int)(off >> erase_shift);
+	total_blk = (int)(erase_len >> erase_shift);
+	pages_per_blk = (1 << (erase_shift - write_shift));
+
+	if (!scrub_flag) {
+		if (boot_device_flag == 1) {
+			if (start_blk < ((1024 / pages_per_blk)))
+				start_blk = ((1024 / pages_per_blk));
+		}
+	}
+	aml_nand_dbg("start_blk =%d,total_blk=%d", start_blk, total_blk);
+
+	for (; start_blk < total_blk; start_blk++) {
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		temp_value = start_blk - start_blk % controller->chip_num;
+		temp_value /= controller->chip_num;
+		ops_para->page_addr = temp_value * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		/* printk("%04d, ", start_blk); */
+		controller->select_chip(controller, ops_para->chipnr);
+
+		ret = erase_env_protect(aml_chip, start_blk);
+		if (ret < 0)
+			continue;
+
+		if (!scrub_flag) {
+			ret = operation->block_isbad(aml_chip);
+			if (ret)
+				continue;
+		}
+		nand_get_chip(aml_chip);
+
+		ret = operation->erase_block(aml_chip);
+
+		nand_release_chip(aml_chip);
+
+		if (ret < 0) {
+			ret = operation->block_markbad(aml_chip);
+			continue;
+		}
+		percent = (start_blk * 100) / total_blk;
+
+		if ((percent != percent_complete)
+			&& ((percent % 10) == 0)) {
+				percent_complete = percent;
+				aml_nand_msg("nand erasing %d %% --%d %% complete",
+					percent,
+					percent+10);
+		}
+	}
+	printk("\n");
+	return 0;
+}
+
+int  dbg_amlnf_erase_ops(u64 off, u64 erase_len, u8 scrub_flag)
+{
+	struct amlnand_chip *aml_chip = aml_nand_chip;
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct nand_flash *flash = &(aml_chip->flash);
+	u32 erase_shift, write_shift, pages_per_blk;
+	int  start_blk, total_blk, ret = 0;
+	int percent = 0;
+	int percent_complete = -1;
+	int temp_value;
+
+	erase_shift = ffs(flash->blocksize) - 1;
+	write_shift =  ffs(flash->pagesize) - 1;
+	start_blk = (int)(off >> erase_shift);
+	total_blk = (int)(erase_len >> erase_shift);
+	pages_per_blk = (1 << (erase_shift - write_shift));
+
+	if (!scrub_flag) {
+		if (boot_device_flag == 1) {
+			if (start_blk < ((1024 / pages_per_blk)))
+				start_blk = ((1024 / pages_per_blk));
+		}
+	}
+	aml_nand_dbg("start_blk =%d,total_blk=%d", start_blk, total_blk);
+
+	for (; start_blk < total_blk; start_blk++) {
+		memset((u8 *)ops_para,
+			0x0,
+			sizeof(struct chip_ops_para));
+		temp_value = start_blk - start_blk % controller->chip_num;
+		temp_value /= controller->chip_num;
+		ops_para->page_addr = temp_value * pages_per_blk;
+		ops_para->chipnr = start_blk % controller->chip_num;
+		printk("%04d, ", start_blk);
+		controller->select_chip(controller, ops_para->chipnr);
+#if 0	//fixme, dbg code.....
+		ret = erase_env_protect(aml_chip, start_blk);
+		if (ret < 0)
+			continue;
+
+		if (!scrub_flag) {
+			ret = operation->block_isbad(aml_chip);
+			if (ret)
+				continue;
+		}
+#endif //0
+		nand_get_chip(aml_chip);
+
+		ret = operation->erase_block(aml_chip);
+
+		nand_release_chip(aml_chip);
+
+	#if 0	//dbg code.
+		if (ret < 0) {
+			ret = operation->block_markbad(aml_chip);
+			continue;
+		}
+	#endif //
+		percent = (start_blk * 100) / total_blk;
+
+		if ((percent != percent_complete)
+			&& ((percent % 10) == 0)) {
+				percent_complete = percent;
+				aml_nand_msg("nand erasing %d %% --%d %% complete",
+					percent,
+					percent+10);
+		}
+	}
+	printk("\n");
+	return ret;
+}
+
+int  amlnf_markbad_reserved_ops(uint32_t start_blk)
+{
+	struct amlnand_chip *aml_chip = aml_nand_chip;
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct nand_flash *flash = &(aml_chip->flash);
+	unsigned erase_shift, write_shift, pages_per_blk;
+	int ret = 0;
+
+	erase_shift = ffs(flash->blocksize) - 1;
+	write_shift =  ffs(flash->pagesize) - 1;
+	pages_per_blk = (1 << (erase_shift -write_shift));
+
+	memset((unsigned char *)ops_para, 0x0, sizeof(struct chip_ops_para));
+	ops_para->page_addr =(((start_blk - start_blk % controller->chip_num) /controller->chip_num)) * pages_per_blk;
+	ops_para->chipnr = start_blk % controller->chip_num;
+	controller->select_chip(controller, ops_para->chipnr );
+	nand_get_chip(aml_chip);
+	ret = operation->block_markbad(aml_chip);
+	nand_release_chip(aml_chip);
+	aml_nand_msg("ops_para->page_addr=%d, ret %d\n",ops_para->page_addr, ret);
+	return 0;
+}
+
+
diff --git a/drivers/nand/phy/hw_controller.c b/drivers/nand/phy/hw_controller.c
new file mode 100644
index 0000000..7507109
--- /dev/null
+++ b/drivers/nand/phy/hw_controller.c
@@ -0,0 +1,1010 @@
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : hw_controller.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**		hw controller operation function,  mainly init nand phy driver.
+**
+**
+*****************************************************************/
+#include "../include/phynand.h"
+#include <asm/arch/secure_apb.h>
+static int controller_select_chip(struct hw_controller *controller,
+	u8 chipnr)
+{
+	int i, ret = 0;
+
+	switch (chipnr) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		controller->chip_selected = controller->ce_enable[chipnr];
+		controller->rb_received = controller->rb_enable[chipnr];
+#ifdef AML_NAND_UBOOT
+	for (i=0; i < controller->chip_num; i++) {
+		pinmux_select_chip(controller->ce_enable[i], controller->rb_enable[i], ((controller->option & NAND_CTRL_NONE_RB) == 0));
+	}
+#endif
+
+		NFC_SEND_CMD_IDLE(controller, 0);
+		break;
+	default:
+		BUG();
+		controller->chip_selected = CE_NOT_SEL;
+		ret = -NAND_SELECT_CHIP_FAILURE;
+		aml_nand_msg("failed");
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef AML_NAND_DMA_POLLING
+static struct completion controller_dma_completion;
+
+static enum hrtimer_restart controller_dma_timerfuc(struct hrtimer *timer)
+{
+	struct hw_controller *controller = NULL;
+	u32 fifo_cnt = 0;
+
+	controller = container_of(timer, struct hw_controller, timer);
+	fifo_cnt = NFC_CMDFIFO_SIZE(controller);
+
+	/* */
+	smp_rmb();
+	/* */
+	smp_wmb();
+	if (fifo_cnt == 0)
+		complete(&controller_dma_completion);
+	else
+		hrtimer_start(&controller->timer,
+			ktime_set(0, DMA_TIME_CNT_20US),
+			HRTIMER_MODE_REL);
+
+	return HRTIMER_NORESTART;
+}
+
+static int controller_dma_timer_handle(struct hw_controller *controller)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	int timeout, time_start;
+
+	time_start = (flash->pagesize + flash->oobsize)*50+5000;
+	init_completion(&controller_dma_completion);
+	hrtimer_start(&controller->timer,
+		ktime_set(0, time_start),
+		HRTIMER_MODE_REL);
+
+	/* max 500mS */
+	timeout = wait_for_completion_timeout(&controller_dma_completion, 50);
+	if (timeout == 0) {
+		aml_nand_msg("dma time out");
+		return -NAND_BUSY_FAILURE;
+	}
+	return 0;
+}
+#endif /* AML_NAND_DMA_POLLING */
+
+#ifdef AML_NAND_RB_IRQ
+
+static struct completion controller_rb_completion;
+
+void controller_open_interrupt(struct hw_controller *controller)
+{
+	/* NFC_ENABLE_STS_IRQ(); */
+	NFC_ENABLE_IO_IRQ(controller);
+
+}
+
+void controller_close_interrupt(struct hw_controller *controller)
+{
+	/* NFC_DISABLE_STS_IRQ(); */
+	NFC_DISABLE_IO_IRQ(controller);
+}
+
+static irqreturn_t controller_interrupt_monitor(int irq,
+	void *dev_id,
+	struct pt_regs *regs)
+{
+	struct hw_controller *controller = (struct hw_controller *)dev_id;
+
+	controller_close_interrupt(controller);
+	complete(&controller_rb_completion);
+
+	return IRQ_HANDLED;
+}
+
+static int controller_queue_rb_irq(struct hw_controller *controller,
+	u8 chipnr)
+{
+	int ret = 0, timeout = 0;
+
+	if (chipnr != NAND_CHIP_UNDEFINE)/* skip dma operation */
+		controller->select_chip(controller, chipnr);
+
+	init_completion(&controller_rb_completion);
+	controller_open_interrupt(controller);
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	controller->cmd_ctrl(controller, NAND_CMD_STATUS, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	/* */
+	smp_rmb();
+	/* */
+	smp_wmb();
+
+	NFC_SEND_CMD_RB_IRQ(controller, 18);
+	/* NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE); */
+
+	timeout = wait_for_completion_timeout(&controller_rb_completion, 50);
+	if (timeout == 0) {
+		aml_nand_msg("***nand irq timeout here");
+		ret = -NAND_BUSY_FAILURE;
+	}
+
+	controller_close_interrupt(controller);
+	return ret;
+}
+#endif /* AML_NAND_RB_IRQ */
+
+static int controller_quene_rb(struct hw_controller *controller,
+	u8 chipnr)
+{
+	u32 time_out_limit, time_out_cnt = 0;
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	int ret = 0;
+
+	if (aml_chip->state == CHIP_RESETING)
+		time_out_limit = AML_NAND_ERASE_BUSY_TIMEOUT;
+	else if (aml_chip->state == CHIP_WRITING)
+		time_out_limit = AML_NAND_WRITE_BUSY_TIMEOUT;
+	else
+		time_out_limit = AML_NAND_READ_BUSY_TIMEOUT;
+
+	controller->select_chip(controller, chipnr);
+
+	NFC_SEND_CMD_IDLE(controller, 0);
+	NFC_SEND_CMD_IDLE(controller, 0);
+	while (NFC_CMDFIFO_SIZE(controller) > 0);
+
+#if 0
+	NFC_SEND_CMD_RB(controller, aml_chip->chip_enable, 20);
+	NFC_SEND_CMD_IDLE(controller, 0);
+	NFC_SEND_CMD_IDLE(controller, 0);
+	do {
+		if (NFC_CMDFIFO_SIZE(controller) <= 0)
+			break;
+	} while (time_out_cnt++ <= AML_DMA_BUSY_TIMEOUT);
+#endif
+
+	/* udelay(2); */
+	if (controller->option & NAND_CTRL_NONE_RB) {
+		controller->cmd_ctrl(controller,
+			NAND_CMD_STATUS, NAND_CTRL_CLE);
+		/*
+		aml_nand_dbg("controller->chip_selected =%d",
+			controller->chip_selected);
+		*/
+		//NAND_LINE
+		NFC_SEND_CMD_IDLE(controller, NAND_TWHR_TIME_CYCLE);
+		do {
+			/* udelay(chip->chip_delay); */
+			if ((int)controller->readbyte(controller) &
+				NAND_STATUS_READY)
+				break;
+			udelay(1);
+			//NAND_LINE
+		} while (time_out_cnt++ <= time_out_limit);/* 200ms max */
+	} else {
+		do {
+			if (NFC_GET_RB_STATUS(controller,
+				controller->rb_received))
+				break;
+			udelay(2);
+		} while (time_out_cnt++ <= time_out_limit);
+	}
+
+	if (time_out_cnt >=  time_out_limit) {
+		NAND_LINE
+		ret = -NAND_BUSY_FAILURE;
+	}
+	return ret;
+}
+
+static int controller_hwecc_correct(struct hw_controller *controller,
+	u32 size,
+	u8 *oob_buf)
+{
+	u32 ecc_step_num, cur_ecc, usr_info;
+	u32 info_times_int_len = PER_INFO_BYTE/sizeof(u32);
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	int max_ecc = 0;
+	int user_offset = 0;
+	u32 tmp_value;
+
+	if (controller->oob_mod == 1)
+		user_offset = 4;
+
+	if (size % controller->ecc_unit) {
+		aml_nand_msg("err para size for ecc correct %x,and ecc_unit:%x",
+			size,
+			controller->ecc_unit);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	controller->ecc_cnt_cur = 0;
+	 for (ecc_step_num = 0;
+		ecc_step_num < (size / controller->ecc_unit);
+		ecc_step_num++) {
+		/* check if there have uncorrectable sector */
+		tmp_value = ecc_step_num*info_times_int_len + user_offset;
+		usr_info = (*(u32 *)(&(controller->user_buf[tmp_value])));
+		cur_ecc = NAND_ECC_CNT(usr_info);
+		/*
+		aml_nand_dbg("uncorrected for cur_ecc:%d, usr_buf[%d]:%x",
+			cur_ecc,
+			ecc_step_num,
+			usr_info);
+		*/
+		if (cur_ecc == 0x3f) {
+			controller->zero_cnt = NAND_ZERO_CNT(usr_info);
+			if (max_ecc < controller->zero_cnt)
+				max_ecc =  controller->zero_cnt;
+			/*
+			aml_nand_dbg("uncorrected for ecc_step_num:%d,
+				zero_cnt:%d",
+				ecc_step_num,
+				controller->zero_cnt);
+			*/
+			return NAND_ECC_FAILURE;
+		} else {
+			controller->ecc_cnt_cur =
+				(controller->ecc_cnt_cur > cur_ecc) ?
+				controller->ecc_cnt_cur : cur_ecc;
+			if (max_ecc < controller->ecc_cnt_cur)
+				max_ecc =  controller->ecc_cnt_cur;
+		}
+	}
+	aml_chip->max_ecc_per_page = max_ecc;
+	return 0;
+}
+
+void _dump_mem(u32 * buf, u32 len)
+{
+	u32 i;
+	printk("%s, %p, %d", __func__, buf, len);
+	for (i = 0; i < len/sizeof(u32); i++) {
+
+		if ( i % 4 == 0)
+			printk("\n0x%p: ", buf+i);
+		printk("%08x ", buf[i]);
+	}
+	printk("\n");
+	return;
+}
+
+/* default enable ran mode */
+static int controller_dma_read(struct hw_controller *controller,
+	u32 len,
+	u8 bch_mode)
+{
+	int count, dma_unit_size, info_times_int_len, time_out_cnt, dma_cnt;
+	u32 *info_buf = 0;
+	u32 tmp_value;
+	u32 cmp;
+	u64 data64, user64;
+	/* volatile int cmp=0; */
+	/* int ret = 0; */
+	//printk("%s() %d: 0x%p\n", __func__, __LINE__, controller->data_buf);
+	dma_unit_size = 0;
+	info_times_int_len = PER_INFO_BYTE/sizeof(u32);
+	if (bch_mode == NAND_ECC_NONE) {
+		if (len > 0x3fff)
+			len = 0x3ffe;
+		count = 1;
+	} else if (bch_mode == NAND_ECC_BCH_SHORT) {
+		dma_unit_size = (controller->ecc_unit >> 3);
+		count = len/controller->ecc_unit;
+	} else
+		count = controller->ecc_steps;
+
+	dma_cnt = count;
+	if ((controller->oob_mod == 1) && (bch_mode != NAND_ECC_NONE))
+		count += 16 / PER_INFO_BYTE;
+
+	tmp_value = (count-1)*info_times_int_len;
+	info_buf = (u32 *)&(controller->user_buf[tmp_value]);
+	memset((u8 *)controller->user_buf, 0, count*PER_INFO_BYTE);
+
+	/* */
+#ifndef AML_NAND_UBOOT
+	smp_wmb();
+	wmb();
+
+	//while(NFC_CMDFIFO_SIZE() > 10);
+	NFC_SEND_CMD_ADL(controller, controller->data_dma_addr);
+	NFC_SEND_CMD_ADH(controller, controller->data_dma_addr);
+	NFC_SEND_CMD_AIL(controller, controller->info_dma_addr);
+	NFC_SEND_CMD_AIH(controller, controller->info_dma_addr);
+#else
+
+	flush_dcache_range((uint64_t)controller->user_buf, (uint64_t)(controller->user_buf + count*PER_INFO_BYTE));
+	invalidate_dcache_range((uint64_t)controller->data_buf, (uint64_t)(controller->data_buf + len));
+	//while(NFC_CMDFIFO_SIZE() > 10);
+	data64 = (u64)controller->data_buf;
+	user64 = (u64)controller->user_buf;
+	NFC_SEND_CMD_ADL(controller, (u32)data64);
+	NFC_SEND_CMD_ADH(controller, (u32)data64);
+	NFC_SEND_CMD_AIL(controller, (u32)user64);
+	NFC_SEND_CMD_AIH(controller, (u32)user64);
+#endif
+
+
+	/* setting page_addr used for seed */
+	aml_nand_dbg("r seed %x, bch %d\n", controller->page_addr, bch_mode);
+	NFC_SEND_CMD_SEED(controller, controller->page_addr);
+
+	if (bch_mode == NAND_ECC_NONE)
+		NFC_SEND_CMD_N2M_RAW(controller, controller->ran_mode, len);
+	else
+		NFC_SEND_CMD_N2M(controller, controller->ran_mode,
+		((bch_mode == NAND_ECC_BCH_SHORT)?NAND_ECC_BCH60_1K:bch_mode),
+		((bch_mode == NAND_ECC_BCH_SHORT)?1:0), dma_unit_size, dma_cnt);
+
+#if 0
+	NFC_SEND_CMD_STS(controller, 20, 2);
+#else
+#ifdef AML_NAND_DMA_POLLING
+	ret = controller_dma_timer_handle(controller);
+#if 0   /* irq failed here */
+	ret = controller_queue_rb_irq(controller, NAND_CHIP_UNDEFINE);
+#endif /* 0 */
+
+	if (ret) {
+		time_out_cnt = AML_DMA_BUSY_TIMEOUT;
+		aml_nand_msg("dma timeout here");
+		return -NAND_DMA_FAILURE;
+	}
+#else /* AML_NAND_DMA_POLLING */
+	NFC_SEND_CMD_IDLE(controller, 0);
+	NFC_SEND_CMD_IDLE(controller, 0);
+
+	time_out_cnt = 0;
+
+	do {
+		if (NFC_CMDFIFO_SIZE(controller) <= 0)
+			break;
+	} while (time_out_cnt++ <= AML_DMA_BUSY_TIMEOUT);
+
+	if (time_out_cnt >= AML_DMA_BUSY_TIMEOUT) {
+		aml_nand_msg("dma timeout here");
+		return -NAND_DMA_FAILURE;
+	}
+
+#endif /* AML_NAND_DMA_POLLING */
+#endif /* 0 */
+
+#ifndef AML_NAND_UBOOT
+	do {
+	    smp_rmb();
+	}while(NAND_INFO_DONE(*info_buf) == 0);
+
+	smp_wmb();
+	wmb();
+#else  /*AML_NAND_UBOOT*/
+	do {
+		invalidate_dcache_range((unsigned long)controller->user_buf, ((unsigned long)controller->user_buf + count * PER_INFO_BYTE));
+		info_buf = (u32 *)&(controller->user_buf[(count-1) * info_times_int_len]);
+		cmp = *info_buf;
+	}while((cmp)==0);
+
+#endif /* AML_NAND_UBOOT */
+	/*
+	aml_nand_dbg("len:%d, count:%d, bch_mode:%d\n",
+		len,
+		count,
+		bch_mode);
+	*/
+	return NAND_SUCCESS;
+}
+
+static int controller_dma_write(struct hw_controller *controller,
+	u8 *buf,
+	u32 len,
+	u8 bch_mode)
+{
+	int ret = 0, time_out_cnt = 0, oob_fill_cnt = 0;
+	u32 dma_unit_size = 0, count = 0;
+	u64 data64, user64;
+
+	data64 = (u64)controller->data_buf;
+	user64 = (u64)controller->user_buf;
+
+	if (bch_mode == NAND_ECC_NONE) {
+		if (len > 0x3fff)
+			len = 0x3ffe;
+		count = 1;
+	} else if (bch_mode == NAND_ECC_BCH_SHORT) {
+		dma_unit_size = (controller->ecc_unit >> 3);
+		count = len / controller->ecc_unit;
+	} else
+		count = controller->ecc_steps;
+
+        memcpy(controller->data_buf, buf, len);
+
+#ifndef AML_NAND_UBOOT
+	smp_wmb();
+	wmb();
+
+	NFC_SEND_CMD_ADL(controller, controller->data_dma_addr);
+	NFC_SEND_CMD_ADH(controller, controller->data_dma_addr);
+	NFC_SEND_CMD_AIL(controller, controller->info_dma_addr);
+	NFC_SEND_CMD_AIH(controller, controller->info_dma_addr);
+#else /* AML_NAND_UBOOT */
+	flush_dcache_range((unsigned long)controller->user_buf, ((unsigned long)controller->user_buf + count*PER_INFO_BYTE));
+	flush_dcache_range((unsigned long)controller->data_buf, ((unsigned long)controller->data_buf +len));
+	NFC_SEND_CMD_ADL(controller, (u32)data64);
+	NFC_SEND_CMD_ADH(controller, (u32)data64);
+	NFC_SEND_CMD_AIL(controller, (u32)user64);
+	NFC_SEND_CMD_AIH(controller, (u32)user64);
+#endif /* AML_NAND_UBOOT */
+	/* fixme, dbg code */
+	aml_nand_dbg("w seed %x, bch %d\n", controller->page_addr, bch_mode);
+	NFC_SEND_CMD_SEED(controller, controller->page_addr);
+
+	if (!bch_mode)
+		NFC_SEND_CMD_M2N_RAW(controller, 0, len);
+	else
+		NFC_SEND_CMD_M2N(controller, controller->ran_mode,
+		((bch_mode == NAND_ECC_BCH_SHORT)?NAND_ECC_BCH60_1K:bch_mode),
+		((bch_mode == NAND_ECC_BCH_SHORT)?1:0), dma_unit_size, count);
+
+	if (bch_mode == NAND_ECC_BCH_SHORT)
+		oob_fill_cnt = controller->oob_fill_boot;
+	else if (bch_mode != NAND_ECC_NONE)
+		oob_fill_cnt = controller->oob_fill_data;
+
+	if (((bch_mode != NAND_ECC_NONE)) && (oob_fill_cnt > 0))
+		/*
+		aml_nand_dbg("fill oob controller oob_fill_cnt %d",\
+			oob_fill_cnt);
+		*/
+		NFC_SEND_CMD_M2N_RAW(controller,
+			controller->ran_mode,
+			oob_fill_cnt);
+	else if (bch_mode == NAND_ECC_NONE) {
+		NFC_SEND_CMD_ADL(controller, (u32)data64);
+		NFC_SEND_CMD_ADH(controller, (u32)data64);
+		NFC_SEND_CMD_M2N_RAW(controller, 0, controller->oobavail);
+	}
+
+#ifdef AML_NAND_DMA_POLLING
+	ret = controller_dma_timer_handle(controller);
+#if 0/* irq failed here */
+	ret = controller_queue_rb_irq(controller, NAND_CHIP_UNDEFINE);
+#endif /* 0 */
+	if (ret) {
+		time_out_cnt = AML_DMA_BUSY_TIMEOUT;
+		aml_nand_msg("dma timeout here");
+		return -NAND_DMA_FAILURE;
+	}
+#else /* AML_NAND_DMA_POLLING */
+	NFC_SEND_CMD_IDLE(controller, 0);
+	NFC_SEND_CMD_IDLE(controller, 0);
+
+	time_out_cnt = 0;
+	do {
+		if (NFC_CMDFIFO_SIZE(controller) <= 0)
+			break;
+	} while (time_out_cnt++ <= AML_DMA_BUSY_TIMEOUT);
+
+	if (time_out_cnt >= AML_DMA_BUSY_TIMEOUT) {
+		aml_nand_msg("dma timeout here");
+		return -NAND_DMA_FAILURE;
+	}
+#endif /* AML_NAND_DMA_POLLING */
+	return ret;
+}
+
+/*
+  * aml_nand_hw_init function.
+  * init hwcontroller CFG register setting,
+  *
+*/
+static int controller_hw_init(struct hw_controller *controller)
+{
+	int sys_clk_rate, sys_time, bus_cycle, bus_timing;
+	/* int clk_delay; */
+	int ret = 0;
+	//nand_cfg_t cfg;
+
+	sys_clk_rate = 200;
+	get_sys_clk_rate(controller, &sys_clk_rate);
+
+	sys_time = (10000 / sys_clk_rate);
+
+#if 0
+	/* if( get_cpu_type() >=MESON_CPU_MAJOR_ID_M8) */
+	/* clk_delay = ; */
+	start_cycle = (((NAND_CYCLE_DELAY + T_REA * 10) * 10) / sys_time);
+	start_cycle = (start_cycle + 9) / 10;
+
+	for (bus_cycle = 4; bus_cycle <= MAX_CYCLE_NUM; bus_cycle++) {
+		Tcycle = bus_cycle * sys_time;
+		end_cycle =
+		(((NAND_CYCLE_DELAY + Tcycle/2 + T_RHOH * 10) * 10)/sys_time);
+		end_cycle = end_cycle / 10;
+		if ((((start_cycle >= 3) && (start_cycle <= (bus_cycle + 1)))
+			|| ((end_cycle >= 3) && (end_cycle <= (bus_cycle + 1))))
+			&& (start_cycle <= end_cycle)) {
+			break;
+		}
+	}
+
+	if (bus_cycle > MAX_CYCLE_NUM) {
+		aml_nand_msg("timming failed bus_cycle:%d", bus_cycle);
+		return -NAND_FAILED;
+	}
+
+	bus_timing = (start_cycle + end_cycle) / 2;
+#else
+	bus_cycle  = 6;
+	bus_timing = bus_cycle + 2;
+#endif
+	//NFC_SET_CFG(controller, 0);
+	NFC_SET_TIMING_ASYC(controller, bus_timing, (bus_cycle - 1));
+	NFC_SEND_CMD(controller, 1<<31);
+
+	aml_nand_msg("init bus_cycle=%d, bus_timing=%d, system=%d.%dns",
+		bus_cycle, bus_timing, sys_time/10, sys_time%10);
+	aml_nand_dbg("cfg %x\n", p_nand_reg->cfg);
+
+	return ret;
+}
+
+void controller_enter_standby(struct hw_controller *controller)
+{
+	/* just enter standby status. */
+	NFC_SEND_CMD_STANDBY(controller, 5);/* delay for 5 cycle. */
+}
+
+static int controller_adjust_timing(struct hw_controller *controller)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	int sys_clk_rate, sys_time, bus_cycle, bus_timing;
+	//nand_cfg_t cfg;
+
+	if (!flash->T_REA || (flash->T_REA < 16))
+		flash->T_REA = 16;
+	if (!flash->T_RHOH || (flash->T_RHOH < 15))
+		flash->T_RHOH = 15;
+
+	if (flash->T_REA > 16)
+		sys_clk_rate = 200;
+	else
+		sys_clk_rate = 250;
+
+	get_sys_clk_rate(controller, &sys_clk_rate);
+
+	sys_time = (10000 / sys_clk_rate);
+	/* sys_time = (10000 / (sys_clk_rate / 1000000)); */
+
+#if 0
+	start_cycle = (((NAND_CYCLE_DELAY + flash->T_REA * 10) * 10)/sys_time);
+	start_cycle = (start_cycle + 9) / 10;
+
+	for (bus_cycle = 6; bus_cycle <= MAX_CYCLE_NUM; bus_cycle++) {
+		Tcycle = bus_cycle * sys_time;
+		end_cycle =
+		(((NAND_CYCLE_DELAY+Tcycle/2+flash->T_RHOH*10)*10)/sys_time);
+		end_cycle = end_cycle / 10;
+		if ((((start_cycle >= 3) && (start_cycle <= (bus_cycle + 1)))
+			|| ((end_cycle >= 3) && (end_cycle <= (bus_cycle + 1))))
+			&& (start_cycle <= end_cycle)) {
+			break;
+		}
+	}
+	if (bus_cycle > MAX_CYCLE_NUM) {
+		aml_nand_msg("timming fail,bus_c:%d,sys_t%d,T_REA:%d,T_RHOH:%d",
+			bus_cycle,
+			sys_time,
+			flash->T_REA,
+			flash->T_RHOH);
+		return -NAND_FAILED;
+	}
+
+	bus_timing = (start_cycle + end_cycle) / 2;
+#else /* 0 */
+	bus_cycle  = 6;
+	bus_timing = bus_cycle + 2;
+#endif /* 0 */
+
+	NFC_SET_CFG(controller , 0);
+	NFC_SET_TIMING_ASYC(controller, bus_timing, (bus_cycle - 1));
+
+	/* for encrypt store */
+	if (AMLNF_READ_REG(P_AO_SEC_SD_CFG10) &  (1 << 15))
+		NFC_ENABLE_ENCRYPT(controller);
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)	{
+#if (AML_CFG_NEWOOB_EN) /* !!!we need modify later. */
+		/* fixme, debug code....*/
+		if (flash->pagesize > 4096) {
+			aml_nand_msg("new oob mode");
+			NFC_SET_OOB_MODE(controller, 3<<26);
+			controller->oob_mod = 1;	//new oob mode.
+		} else
+			controller->oob_mod = 0;
+#else
+		controller->oob_mod = 0;
+#endif
+	} else
+		controller->oob_mod = 0;
+
+	NFC_SEND_CMD(controller, 1<<31);
+	aml_nand_msg("bus_c=%d,bus_t=%d,sys=%d.%dns,T_REA=%d,T_RHOH=%d",
+		bus_cycle,
+		bus_timing,
+		sys_time/10,
+		sys_time%10,
+		flash->T_REA,
+		flash->T_RHOH);
+
+	return NAND_SUCCESS;
+}
+
+/*
+  *options confirm here, including ecc mode
+  */
+static int controller_ecc_confirm(struct hw_controller *controller)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct bch_desc *ecc_supports = controller->bch_desc;
+	u32 max_bch_mode = controller->max_bch;
+	u32 options_support = 0, ecc_bytes, i;
+	u8 bch_index;
+	u16 tmp_value;
+
+	if (controller->option & NAND_ECC_SOFT_MODE) {
+		controller->ecc_unit = flash->pagesize + flash->oobsize;
+		controller->bch_mode = NAND_ECC_NONE;
+		aml_nand_msg("soft ecc mode");
+		return NAND_SUCCESS;
+	}
+
+	for (i = (max_bch_mode-1); i > 0; i--) {
+		ecc_bytes =
+		flash->oobsize/(flash->pagesize/ecc_supports[i].unit_size);
+		if (ecc_bytes >= ecc_supports[i].bytes +
+			ecc_supports[i].usr_mode) {
+			options_support = ecc_supports[i].mode;
+			bch_index = ecc_supports[i].bch_index;
+			break;
+		}
+	}
+
+	switch (options_support) {
+	case NAND_ECC_BCH8_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_SIZE;
+		controller->ecc_bytes = NAND_BCH8_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 6;
+		controller->ecc_max = 8;
+		break;
+
+	case NAND_ECC_BCH8_1K_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
+		controller->ecc_bytes = NAND_BCH8_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 6;
+		controller->ecc_max = 8;
+		break;
+
+	case NAND_ECC_BCH16_1K_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
+		controller->ecc_bytes = NAND_BCH16_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 14;
+		controller->ecc_max = 16;
+		break;
+
+	case NAND_ECC_BCH24_1K_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
+		controller->ecc_bytes = NAND_BCH24_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 22;
+		controller->ecc_max = 24;
+		break;
+
+	case NAND_ECC_BCH30_1K_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
+		controller->ecc_bytes = NAND_BCH30_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 26;
+		controller->ecc_max = 30;
+		break;
+
+	case NAND_ECC_BCH40_1K_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
+		controller->ecc_bytes = NAND_BCH40_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 34;
+		controller->ecc_max = 40;
+		break;
+
+	case NAND_ECC_BCH50_1K_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
+		controller->ecc_bytes = NAND_BCH50_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 45;
+		controller->ecc_max = 50;
+		break;
+
+	case NAND_ECC_BCH60_1K_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
+		controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 55;
+		controller->ecc_max = 60;
+		break;
+
+	case NAND_ECC_SHORT_MODE:
+		controller->ecc_unit = NAND_ECC_UNIT_SHORT;
+		controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
+		controller->bch_mode = bch_index;
+		controller->user_mode = 2;
+		controller->ecc_cnt_limit = 55;
+		controller->ecc_max = 60;
+		break;
+
+	default:
+		aml_nand_msg("no match ecc mode here");
+		return -NAND_ARGUMENT_FAILURE;
+		break;
+	}
+
+	tmp_value = controller->ecc_unit + controller->ecc_bytes +
+		controller->user_mode;
+	controller->ecc_steps = (flash->pagesize+flash->oobsize)/tmp_value;
+	controller->oobavail = controller->ecc_steps*controller->user_mode;
+
+	controller->oobtail = flash->pagesize - controller->ecc_steps*tmp_value;
+	controller->oob_fill_data = (flash->oobsize -
+	(controller->ecc_steps*(controller->ecc_bytes+controller->user_mode)));
+	controller->oob_fill_boot = (flash->pagesize+flash->oobsize) - 512;
+	controller->ran_mode = 1;
+	aml_nand_dbg("ecc_unit:%d, ecc_bytes:%d, ecc_steps:%d, ecc_max:%d",
+		controller->ecc_unit,
+		controller->ecc_bytes,
+		controller->ecc_steps,
+		controller->ecc_max);
+	aml_nand_dbg("bch_mode:%d,user_mode:%d, oobavail:%d,oobtail:%d",
+		controller->bch_mode,
+		controller->user_mode,
+		controller->oobavail,
+		controller->oobtail);
+	aml_nand_dbg("oob_fill_data %d,controller->oob_fill_boot %d",
+		controller->oob_fill_data,
+		controller->oob_fill_boot);
+
+	return NAND_SUCCESS;
+}
+
+static void controller_cmd_ctrl(struct hw_controller *controller,
+	u32 cmd,
+	u32 ctrl)
+{
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	if (ctrl & NAND_CLE)
+		cmd = NFC_CMD_CLE(controller->chip_selected, cmd);
+	else
+		cmd = NFC_CMD_ALE(controller->chip_selected, cmd);
+
+	NFC_SEND_CMD(controller, cmd);
+}
+
+static void controller_write_byte(struct hw_controller *controller,
+	u8 data)
+{
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+	NFC_SEND_CMD_DWR(controller, controller->chip_selected, data);
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+
+	NFC_SEND_CMD_IDLE(controller, 0);
+	NFC_SEND_CMD_IDLE(controller, 0);
+
+	while (NFC_CMDFIFO_SIZE(controller) > 0)
+		;
+
+}
+
+static u8 controller_read_byte(struct hw_controller *controller)
+{
+	NFC_SEND_CMD_DRD(controller, controller->chip_selected, 0);
+	NFC_SEND_CMD_IDLE(controller, NAND_TWB_TIME_CYCLE);
+
+	NFC_SEND_CMD_IDLE(controller, 0);
+	NFC_SEND_CMD_IDLE(controller, 0);
+
+	while (NFC_CMDFIFO_SIZE(controller) > 0)
+		;
+
+	return amlnf_read_reg32(controller->reg_base + P_NAND_BUF);
+
+}
+
+static void controller_get_user_byte(struct hw_controller *controller,
+	u8 *oob_buf,
+	u8 byte_num)
+{
+	int read_times = 0;
+	u32 len = PER_INFO_BYTE/sizeof(u32);
+
+	if (controller->oob_mod == 1) {
+		memcpy(oob_buf,
+			(u8 *)controller->user_buf,
+			byte_num);
+		return;
+	}
+	while (byte_num > 0) {
+		*oob_buf++ = (controller->user_buf[read_times*len] & 0xff);
+		byte_num--;
+		if (controller->user_mode == 2) {
+			*oob_buf++ =
+			((controller->user_buf[read_times*len] >> 8) & 0xff);
+			byte_num--;
+		}
+		read_times++;
+	}
+}
+
+static void controller_set_user_byte(struct hw_controller *controller,
+	u8 *oob_buf,
+	u8 byte_num)
+{
+	int write_times = 0;
+	u32 len = PER_INFO_BYTE/sizeof(u32);
+#if 0
+	u8 *usr_info;
+	usr_info = (u8 *)controller->user_buf;
+#endif
+	if (controller->oob_mod == 1) {
+		memcpy((u8 *)controller->user_buf,
+			oob_buf,
+			byte_num);
+		return;
+	}
+	while (byte_num > 0) {
+		controller->user_buf[write_times*len] = *oob_buf++;
+		byte_num--;
+		if (controller->user_mode == 2) {
+			controller->user_buf[write_times*len] |=
+				(*oob_buf++ << 8);
+			byte_num--;
+		}
+		write_times++;
+	}
+}
+nand_reg_t *p_nand_reg;
+/*
+  * fill hw_controller struct.
+  * including hw init, option setting and operation function.
+  *
+  */
+int amlnand_hwcontroller_init(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+
+	int i, tmp_num = 0, ret = 0;
+
+	/*IO base mapping address*/
+	controller->reg_base = (void *)aml_nand_dev->platform_data->nf_reg_base;
+	/*external register mapping address for nand clock cfg*/
+	controller->nand_clk_reg = (void *) aml_nand_dev->platform_data->ext_clk_reg;
+	controller->irq = aml_nand_dev->platform_data->irq;
+
+	p_nand_reg = (nand_reg_t *) controller->reg_base;
+
+	aml_nand_dbg("controller->reg_base %p\n", controller->reg_base);
+	if (!controller->init)
+		controller->init = controller_hw_init;
+	if (!controller->adjust_timing)
+		controller->adjust_timing = controller_adjust_timing;
+	if (!controller->ecc_confirm)
+		controller->ecc_confirm = controller_ecc_confirm;
+	if (!controller->cmd_ctrl)
+		controller->cmd_ctrl = controller_cmd_ctrl;
+	if (!controller->select_chip)
+		controller->select_chip = controller_select_chip;
+	if (!controller->quene_rb)
+		controller->quene_rb = controller_quene_rb;
+#ifdef AML_NAND_RB_IRQ
+	if (!controller->quene_rb_irq)
+		controller->quene_rb_irq = controller_queue_rb_irq;
+#endif
+	if (!controller->dma_read)
+		controller->dma_read = controller_dma_read;
+	if (!controller->dma_write)
+		controller->dma_write = controller_dma_write;
+	if (!controller->hwecc_correct)
+		controller->hwecc_correct = controller_hwecc_correct;
+	if (!controller->readbyte)
+		controller->readbyte = controller_read_byte;
+	if (!controller->writebyte)
+		controller->writebyte = controller_write_byte;
+	if (!controller->get_usr_byte)
+		controller->get_usr_byte = controller_get_user_byte;
+	if (!controller->set_usr_byte)
+		controller->set_usr_byte = controller_set_user_byte;
+	if (!controller->enter_standby)
+		controller->enter_standby = controller_enter_standby;
+
+	for (i = 0; i < MAX_CHIP_NUM; i++) {
+		controller->ce_enable[i] =
+			(((CE_PAD_DEFAULT >> i*4) & 0xf) << 10);
+		controller->rb_enable[i] =
+			(((RB_PAD_DEFAULT >> i*4) & 0xf) << 10);
+	}
+
+	/*setting default value for option.*/
+	controller->option |= NAND_CTRL_NONE_RB;
+	controller->option |= NAND_ECC_BCH60_1K_MODE;
+
+	controller->aml_chip = aml_chip;
+
+#ifdef AML_NAND_RB_IRQ
+	aml_nand_msg("######STS IRQ mode for nand driver");
+	if (request_irq(controller->irq,
+		(irq_handler_t)controller_interrupt_monitor,
+		0,
+		"aml_nand",
+		controller)) {
+		aml_nand_msg("request nand status irq error!!!");
+		return -1;
+	}
+#endif /* AML_NAND_RB_IRQ */
+
+#ifdef AML_NAND_DMA_POLLING
+	aml_nand_msg("######timer mode for nand driver");
+	hrtimer_init(&controller->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	controller->timer.function = controller_dma_timerfuc;
+#endif /* AML_NAND_DMA_POLLING */
+#ifndef AML_NAND_UBOOT
+	amlphy_prepare(0);
+#endif /* AML_NAND_UBOOT */
+
+	ret = controller->init(controller);
+	if (ret)
+		aml_nand_msg("controller hw init failed");
+	/* do not need change unless I/F changed...*/
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)
+		controller->bch_desc = (struct bch_desc *)&bch_list_m8[0];
+	else
+		controller->bch_desc = (struct bch_desc *)&bch_list[0];
+	for (i = 0; i < MAX_ECC_MODE_NUM; i++) {
+		if (controller->bch_desc[i].name == NULL)
+			break;
+		tmp_num++;
+	}
+	controller->max_bch  = tmp_num;
+	/*
+	controller->max_bch = sizeof(bch_list) / sizeof(bch_list[0]);
+	*/
+	return ret;
+}
+
diff --git a/drivers/nand/phy/id_table.c b/drivers/nand/phy/id_table.c
new file mode 100644
index 0000000..f3b899f
--- /dev/null
+++ b/drivers/nand/phy/id_table.c
@@ -0,0 +1,697 @@
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : id_table.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**	all supported nand id table, provide nand flash basic information,
+**	mainly init nand phy driver.
+**
+*****************************************************************/
+#include "../include/phynand.h"
+
+
+#ifdef AML_SLC_NAND_SUPPORT
+struct nand_flash flash_ids_slc[] = {
+	/***for SLC nand***/
+	{"NAND 128MiB 3,3V 8-bit", {0, 0x79}, 512, 128, 0x4000, 0, 0, 0},
+
+	{"NAND 256MiB 3,3V 8-bit", {0, 0x71}, 512, 256, 0x4000, 0, 0, 0},
+	/*512 Megabit */
+	{"NAND 64MiB 3,3V 8-bit", {0, 0xF2}, 0,  64, 0, 0, 0, 0},
+	/* 1 Gigabit */
+	{"NAND 128MiB 3,3V 8-bit", {0, 0xF1}, 0, 128, 0, 0, 0, 0},
+	/* 2 Gigabit */
+	{"NAND 256MiB 3,3V 8-bit", {0, 0xDA}, 0, 256, 0, 0, 0, 0},
+	/* 4 Gigabit */
+	{"NAND 512MiB 3,3V 8-bit", {0, 0xDC}, 0, 512, 0, 0, 0, 0},
+	/* 8 Gigabit */
+	{"NAND 1GiB 3,3V 8-bit", {0, 0xD3}, 0, 1024, 0, 0, 0, 0},
+	{NULL,}
+};
+#endif
+
+#ifdef AML_MLC_NAND_SUPPORT
+struct nand_flash flash_ids_mlc[] = {
+/***for MLC nand***/
+	{"A revision NAND 2GiB H27UAG8T2A",
+		{NAND_MFR_HYNIX, 0xd5, 0x94, 0x25, 0x44, 0x41},
+		4096,
+		2048,
+		0x80000,
+		224,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"A revision NAND 4GiB H27UBG8T2A",
+		{NAND_MFR_HYNIX, 0xd7, 0x94, 0x9a, 0x74, 0x42},
+		8192,
+		4096,
+		0x200000,
+		448,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"B revision NAND 2GiB H27UAG8T2B",
+		{NAND_MFR_HYNIX, 0xd5, 0x94, 0x9a, 0x74, 0x42},
+		8192,
+		2048,
+		0x200000,
+		448,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+#if (AML_CFG_NEW_NAND_SUPPORT)
+	{"B revision 26nm NAND 4GiB H27UBG8T2B",
+		{NAND_MFR_HYNIX, 0xd7, 0x94, 0xda, 0x74, 0xc3},
+		8192,
+		4096,
+		0x200000,
+		640,
+		1,
+		16,
+		15,
+		0,
+		HYNIX_26NM_4GB,
+		NAND_MULTI_PLANE_MODE},
+	{"B revision 26nm NAND 8GiB H27UCG8T2M",
+		{NAND_MFR_HYNIX, 0xde, 0x94, 0xd2, 0x04, 0x43},
+		8192,
+		8192,
+		0x200000,
+		448,
+		1,
+		16,
+		15,
+		0,
+		HYNIX_26NM_8GB,
+		NAND_MULTI_PLANE_MODE},
+	{"C revision 20nm NAND 4GiB H27UBG8T2C",
+		{NAND_MFR_HYNIX, 0xd7, 0x94, 0x91, 0x60, 0x44},
+		8192,
+		4096,
+		0x200000,
+		640,
+		1,
+		16,
+		15,
+		0,
+		HYNIX_20NM_4GB,
+		NAND_MULTI_PLANE_MODE},
+	{"A revision 20nm NAND 8GiB H27UCG8T2A",
+		{NAND_MFR_HYNIX, 0xde, 0x94, 0xda, 0x74, 0xc4},
+		8192,
+		8192,
+		0x200000,
+		640,
+		1,
+		16,
+		15,
+		0,
+		HYNIX_20NM_8GB,
+		NAND_MULTI_PLANE_MODE},
+	{"B revision 20nm NAND 8GiB H27UCG8T2B",
+		{NAND_MFR_HYNIX, 0xde, 0x94, 0xeb, 0x74, 0x44},
+		16384,
+		8192,
+		0x400000,
+		1280,
+		1,
+		16,
+		15,
+		0,
+		HYNIX_20NM_4GB,
+		NAND_MULTI_PLANE_MODE },
+	{"E revision 1Ynm NAND 8GiB H27UCG8T2E",
+		{NAND_MFR_HYNIX, 0xde, 0x14, 0xA7, 0x42, 0x4A},
+		16384,
+		8192,
+		0x400000,
+		1664,
+		1,
+		16,
+		15,
+		0,
+		HYNIX_1YNM,
+		NAND_MULTI_PLANE_MODE },
+#endif
+#if (AML_CFG_NEW_NAND_SUPPORT)
+	{"B revision NAND 8GiB MT29F64G08CBABA",
+		{NAND_MFR_MICRON, 0x64, 0x44, 0x4B, 0xA9},
+		8192,
+		8192,
+		0x200000,
+		744,
+		1,
+		16,
+		15,
+		5,
+		MICRON_20NM,
+		NAND_MULTI_PLANE_MODE},
+	{"D revision NAND 4GiB MT29F32G08CBADA",
+		{NAND_MFR_MICRON, 0x44, 0x44, 0x4B, 0xA9},
+		8192,
+		4096,
+		0x200000,
+		744,
+		1,
+		16,
+		15,
+		5,
+		MICRON_20NM,
+		NAND_MULTI_PLANE_MODE},
+	{"1 Generation NAND 8GiB JS29F64G08ACMF1",
+		{NAND_MFR_INTEL, 0x88, 0x24, 0x4b, 0xA9, 0x84},
+		8192,
+		8192,
+		0x200000,
+		448,
+		1,
+		20,
+		15,
+		0,
+		INTEL_20NM,
+		NAND_MULTI_PLANE_MODE},
+	{"1 Generation NAND 16GiB JS29F64G08CCMF1",
+		{NAND_MFR_INTEL,
+		0x88,
+		0x24,
+		0x4b,
+		0xA9,
+		0x84},
+		8192,
+		16384,
+		0x200000,
+		448,
+		1,
+		20,
+		15,
+		0,
+		INTEL_20NM,
+		NAND_MULTI_PLANE_MODE},
+#endif
+
+	{"A revision NAND 4GiB MT29F32G-A",
+		{NAND_MFR_MICRON, 0xd7, 0x94, 0x3e, 0x84},
+		4096,
+		4096,
+		0x80000,
+		218,
+		1,
+		16,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"A revision NAND 16GiB MT29F128G-A",
+		{NAND_MFR_MICRON, 0xd9, 0xd5, 0x3e, 0x88},
+		4096,
+		16384,
+		0x80000,
+		218,
+		1,
+		16,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"B revision NAND 4GiB MT29F32G-B",
+		{NAND_MFR_MICRON, 0x68, 0x04, 0x46, 0x89},
+		4096,
+		4096,
+		0x100000,
+		224,
+		1,
+		20,
+		15,
+		4,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"B revision NAND 8GiB MT29F64G-B",
+		{NAND_MFR_MICRON, 0x88, 0x05, 0xc6, 0x89},
+		4096,
+		8192,
+		0x100000,
+		224,
+		1,
+		20,
+		15,
+		4,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"C revision NAND 4GiB MT29F32G-C",
+		{NAND_MFR_MICRON, 0x68, 0x04, 0x4a, 0xa9},
+		4096,
+		4096,
+		0x100000,
+		224,
+		1,
+		16,
+		15,
+		5,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"C revision NAND 8GiB MT29F64G-C",
+		{NAND_MFR_MICRON, 0x88, 0x04, 0x4b, 0xa9},
+		8192,
+		8192,
+		0x200000,
+		448,
+		1,
+		16,
+		15,
+		5,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"C revision NAND 32GiB MT29F256G-C",
+		{NAND_MFR_MICRON, 0xa8, 0x05, 0xcb, 0xa9},
+		8192,
+		16384,
+		0x200000,
+		448,
+		2,
+		16,
+		15,
+		5,
+		0,
+		NAND_MULTI_PLANE_MODE},
+
+	{"1 Generation NAND 4GiB JS29F32G08AA-1",
+		{NAND_MFR_INTEL, 0x68, 0x04, 0x46, 0xA9},
+		4096,
+		4096,
+		0x100000,
+		218,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"1 Generation NAND 8GiB JS29F64G08AA-1",
+		{NAND_MFR_INTEL, 0x88, 0x24, 0x4b, 0xA9},
+		8192,
+		8192,
+		0x200000,
+		448,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+
+	{"E serials NAND 2GiB TC58NVG4D2ETA00",
+		{NAND_MFR_TOSHIBA, 0xD5, 0x94, 0x32, 0x76, 0x54},
+		8192,
+		2048,
+		0x100000,
+		376,
+		1,
+		20,
+		25,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"E serials NAND 4GiB TC58NVG5D2ETA00",
+		{NAND_MFR_TOSHIBA, 0xD7, 0x94, 0x32, 0x76, 0x54},
+		8192,
+		4096,
+		0x100000,
+		376,
+		1,
+		20,
+		25,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"F serials NAND 2GiB TC58NVG4D2FTA00",
+		{NAND_MFR_TOSHIBA, 0xD5, 0x94, 0x32, 0x76, 0x55},
+		8192,
+		2076,
+		0x100000,
+		448,
+		1,
+		20,
+		25,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"F serials NAND 4GiB TC58NVG5D2FTA00",
+		{NAND_MFR_TOSHIBA, 0xD7, 0x94, 0x32, 0x76, 0x55},
+		8192,
+		4096,
+		0x100000,
+		448,
+		1,
+		20,
+		25,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"F serials NAND 8GiB TC58NVG6D2FTA00",
+		{NAND_MFR_TOSHIBA, 0xDE, 0x94, 0x32, 0x76, 0x55},
+		8192,
+		8192,
+		0x100000,
+		448,
+		1,
+		20,
+		25,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"F serials NAND 8GiB TH58NVG7D2FTA20",
+		{NAND_MFR_TOSHIBA, 0xDE, 0x95, 0x32, 0x7a, 0x55},
+		8192,
+		8200,
+		0x100000,
+		448,
+		2,
+		20,
+		25,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+#if (AML_CFG_NEW_NAND_SUPPORT)
+	{"F serials NAND 4GiB TC58NVG5D2HTA00",
+		{NAND_MFR_TOSHIBA, 0xD7, 0x94, 0x32, 0x76, 0x56},
+		8192,
+		4096,
+		0x100000,
+		640,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_2XNM,
+		NAND_MULTI_PLANE_MODE},
+	{"F serials NAND 8GiB TC58NVG6D2GTA00",
+		{NAND_MFR_TOSHIBA, 0xDE, 0x94, 0x82, 0x76, 0x56},
+		8192,
+		8192,
+		0x200000,
+		640,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_2XNM,
+		NAND_MULTI_PLANE_MODE},
+	{"F serials NAND 8GiB TC58TEG6DCJTA00",
+		{NAND_MFR_TOSHIBA, 0xDE, 0x84, 0x93, 0x72, 0x57},
+		16384,
+		8192,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_2XNM,
+		0},  /* not surrport two plane mode */
+	{"A serials NAND 4GiB TC58TEG5DCJTA00 ",
+		{NAND_MFR_TOSHIBA, 0xD7, 0x84, 0x93, 0x72, 0x57},
+		16384,
+		4096,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_2XNM,
+		0 },
+	{"B serials NAND 16GiB TC58TEG7DCJTA00 ",
+		{NAND_MFR_TOSHIBA, 0x3a, 0x85, 0x93, 0x76, 0x57},
+		16384,
+		16384,
+		0x400000,
+		1280,
+		2,
+		20,
+		25,
+		0,
+		TOSHIBA_2XNM,
+		0 },
+	{"A serials NAND 4GiB TC58TEG5DCKTA00 ",
+		{NAND_MFR_TOSHIBA, 0xD7, 0x84, 0x93, 0x72, 0x50},
+		16384,
+		4096,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_A19NM,
+		0 },
+	{"A serials NAND 8GiB TC58TEG6DDKTA00 ",
+		{NAND_MFR_TOSHIBA, 0xDE, 0x94, 0x93, 0x76, 0x50},
+		16384,
+		8192,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_A19NM,
+		NAND_MULTI_PLANE_MODE },
+	/* 15nm */
+	{"A serials NAND 8GiB TC58TEG6DDLTA00 ",
+		{NAND_MFR_TOSHIBA, 0xDE, 0x94, 0x93, 0x76, 0x51},
+		16384,
+		8192,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_15NM,
+		NAND_MULTI_PLANE_MODE },
+	{"A serials NAND 16GiB TC58TEG7DDLTA00 ",
+		{NAND_MFR_TOSHIBA, 0x3A, 0x94, 0x93, 0x76, 0x51},
+		16384,
+		16384,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		TOSHIBA_15NM,
+		NAND_MULTI_PLANE_MODE },
+#endif
+#if (AML_CFG_NEW_NAND_SUPPORT)
+	{"A serials NAND 8GiB SDTNQGAMA-008G ",
+		{NAND_MFR_SANDISK, 0xDE, 0x94, 0x93, 0x76, 0x57},
+		16384,
+		8192,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		SANDISK_19NM,
+		NAND_MULTI_PLANE_MODE},
+	{"A serials NAND 4GiB SDTNQGAMA-004G ",
+		{NAND_MFR_SANDISK, 0xD7, 0x84, 0x93, 0x72, 0x57},
+		16384,
+		4096,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		SANDISK_19NM, 0},
+	{"A serials NAND 8GiB SDTNPMAHEM-008G ",
+		{NAND_MFR_SANDISK, 0xDE, 0xA4, 0x82, 0x76, 0x56},
+		8192,
+		8192,
+		0x200000,
+		640,
+		1,
+		20,
+		25,
+		0,
+		SANDISK_24NM, 0},
+	{"A serials NAND 8GiB SDTNRGAMA-008G ",
+		{NAND_MFR_SANDISK, 0xDE, 0x94, 0x93, 0x76, 0x50},
+		16384,
+		8192,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		SANDISK_A19NM,
+		NAND_MULTI_PLANE_MODE},
+	{"A serials NAND 4GiB SDTNRFAMA-004G ",
+		{NAND_MFR_SANDISK, 0xD7, 0x84, 0x93, 0x72, 0x50},
+		16384,
+		4096,
+		0x400000,
+		1280,
+		1,
+		20,
+		25,
+		0,
+		SANDISK_A19NM_4G,
+		0},
+#endif
+
+	{"M Generation NAND 2GiB K9GAG08U0M",
+		{NAND_MFR_SAMSUNG, 0xD5, 0x14, 0xb6, 0x74},
+		4096,
+		2048,
+		0x80000,
+		128,
+		1,
+		20,
+		15,
+		0,
+		0,
+		0},
+	{"5 Generation NAND 2GiB K9GAG08X0D",
+		{NAND_MFR_SAMSUNG, 0xD5, 0x94, 0x29, 0x34, 0x41},
+		4096,
+		2048,
+		0x80000,
+		218,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"6 Generation NAND 2GiB K9GAG08U0E",
+		{NAND_MFR_SAMSUNG, 0xD5, 0x84, 0x72, 0x50, 0x42},
+		8192,
+		2048,
+		0x100000,
+		436,
+		1,
+		25,
+		15,
+		0,
+		0,
+		0},
+	{"7 Generation NAND 2GiB K9GAG08U0F",
+		{NAND_MFR_SAMSUNG, 0xD5, 0x94, 0x76, 0x54, 0x43},
+		8192,
+		2048,
+		0x100000,
+		512,
+		1,
+		25,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"6 Generation NAND 4GiB K9LBG08U0E",
+		{NAND_MFR_SAMSUNG, 0xD7, 0xC5, 0x72, 0x54, 0x42},
+		8192,
+		4096,
+		0x100000,
+		436,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"6 Generation NAND 8GiB K9HCG08U0E",
+		{NAND_MFR_SAMSUNG, 0xDE, 0xC5, 0x72, 0x54, 0x42},
+		8192,
+		8192,
+		0x100000,
+		436,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"2 Generation NAND 4GiB K9GBG08U0A",
+		{NAND_MFR_SAMSUNG, 0xD7, 0x94, 0x7a, 0x54, 0x43},
+		8192,
+		4152,
+		0x100000,
+		640,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+	{"2 Generation NAND 8GiB K9LCG08U0A",
+		{NAND_MFR_SAMSUNG, 0xDE, 0xD5, 0x7a, 0x58, 0x43},
+		8192,
+		8304,
+		0x100000,
+		640,
+		1,
+		20,
+		15,
+		0,
+		0,
+		NAND_MULTI_PLANE_MODE},
+#if (AML_CFG_NEW_NAND_SUPPORT)
+	{"2 Generation NAND 4GiB K9GBG08U0B",
+		{NAND_MFR_SAMSUNG, 0xD7, 0x94, 0x7e, 0x64, 0x44},
+		8192,
+		4096,
+		0x100000,
+		640,
+		1,
+		20,
+		15,
+		0,
+		SUMSUNG_2XNM,
+		NAND_MULTI_PLANE_MODE},
+
+	{"2 Generation NAND 8GiB K9GLCG08U0A",
+		{NAND_MFR_SAMSUNG, 0xDE, 0xA4, 0x7A, 0x68, 0xC4},
+		8192,
+		8192,
+		0x100000,
+		640,
+		1,
+		20,
+		15,
+		0,
+		SUMSUNG_2XNM,
+		NAND_MULTI_PLANE_MODE},
+	{"2 Generation NAND 8GiB K9LCG08U0B",
+		{NAND_MFR_SAMSUNG, 0xDE, 0xD5, 0x7e, 0x68, 0x44},
+		8192,
+		8192,
+		0x100000,
+		640,
+		1,
+		20,
+		15,
+		0,
+		SUMSUNG_2XNM,
+		NAND_MULTI_PLANE_MODE},
+#endif
+	{NULL,}
+};
+#endif
+
diff --git a/drivers/nand/phy/new_nand.c b/drivers/nand/phy/new_nand.c
new file mode 100644
index 0000000..9e6e2c2
--- /dev/null
+++ b/drivers/nand/phy/new_nand.c
@@ -0,0 +1,3236 @@
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : retry_slc.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**		read retry and enchance slc program function information,
+**		mainly init nand phy driver.
+**
+*****************************************************************/
+#include "../include/phynand.h"
+
+static u8 pagelist_hynix256[128] = {
+	0x00, 0x01, 0x02, 0x03, 0x06, 0x07, 0x0A, 0x0B,
+	0x0E, 0x0F, 0x12, 0x13, 0x16, 0x17, 0x1A, 0x1B,
+	0x1E, 0x1F, 0x22, 0x23, 0x26, 0x27, 0x2A, 0x2B,
+	0x2E, 0x2F, 0x32, 0x33, 0x36, 0x37, 0x3A, 0x3B,
+
+	0x3E, 0x3F, 0x42, 0x43, 0x46, 0x47, 0x4A, 0x4B,
+	0x4E, 0x4F, 0x52, 0x53, 0x56, 0x57, 0x5A, 0x5B,
+	0x5E, 0x5F, 0x62, 0x63, 0x66, 0x67, 0x6A, 0x6B,
+	0x6E, 0x6F, 0x72, 0x73, 0x76, 0x77, 0x7A, 0x7B,
+
+	0x7E, 0x7F, 0x82, 0x83, 0x86, 0x87, 0x8A, 0x8B,
+	0x8E, 0x8F, 0x92, 0x93, 0x96, 0x97, 0x9A, 0x9B,
+	0x9E, 0x9F, 0xA2, 0xA3, 0xA6, 0xA7, 0xAA, 0xAB,
+	0xAE, 0xAF, 0xB2, 0xB3, 0xB6, 0xB7, 0xBA, 0xBB,
+
+	0xBE, 0xBF, 0xC2, 0xC3, 0xC6, 0xC7, 0xCA, 0xCB,
+	0xCE, 0xCF, 0xD2, 0xD3, 0xD6, 0xD7, 0xDA, 0xDB,
+	0xDE, 0xDF, 0xE2, 0xE3, 0xE6, 0xE7, 0xEA, 0xEB,
+	0xEE, 0xEF, 0xF2, 0xF3, 0xF6, 0xF7, 0xFA, 0xFB,
+};
+u8 pagelist_1ynm_hynix256[128] = {
+	0x00, 0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d,
+	0x0f, 0x11, 0x13, 0x15, 0x17, 0x19, 0x1b, 0x1d,
+	0x1f, 0x21, 0x23, 0x25, 0x27, 0x29, 0x2b, 0x2d,
+	0x2f, 0x31, 0x33, 0x35, 0x37, 0x39, 0x3b, 0x3d,
+
+	0x3f, 0x41, 0x43, 0x45, 0x47, 0x49, 0x4b, 0x4d,
+	0x4f, 0x51, 0x53, 0x55, 0x57, 0x59, 0x5b, 0x5d,
+	0x5f, 0x61, 0x63, 0x65, 0x67, 0x69, 0x6b, 0x6d,
+	0x6f, 0x71, 0x73, 0x75, 0x77, 0x79, 0x7b, 0x7d,
+	0x7f, 0x81, 0x83, 0x85, 0x87, 0x89, 0x8b, 0x8d,
+	0x8f, 0x91, 0x93, 0x95, 0x97, 0x99, 0x9b, 0x9d,
+	0x9f, 0xa1, 0xA3, 0xA5, 0xA7, 0xA9, 0xAb, 0xAd,
+	0xAf, 0xb1, 0xB3, 0xB5, 0xB7, 0xB9, 0xBb, 0xBd,
+	0xBf, 0xc1, 0xC3, 0xC5, 0xC7, 0xC9, 0xCb, 0xCd,
+	0xCf, 0xd1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDb, 0xDd,
+	0xDf, 0xe1, 0xE3, 0xE5, 0xE7, 0xE9, 0xEb, 0xEd,
+	0xEf, 0xf1, 0xF3, 0xF5, 0xF7, 0xF9, 0xFb, 0xFd,
+};
+
+/*****************************HYNIX******************************************/
+
+static int get_reg_value_hynix(struct hw_controller *controller,
+	u8 *buf,
+	u8 *addr,
+	u8 chipnr,
+	u8 cnt)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	int i, ret = 0;
+
+	if ((flash->new_type == 0) || (flash->new_type > 10))
+		return NAND_SUCCESS;
+
+	aml_nand_dbg("flash->new_type:%d", flash->new_type);
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	controller->cmd_ctrl(controller,
+		NAND_CMD_HYNIX_GET_VALUE,
+		NAND_CTRL_CLE);
+
+	for (i = 0; i < cnt; i++) {
+		controller->cmd_ctrl(controller, addr[i], NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 10);
+		buf[i] = controller->readbyte(controller);
+		NFC_SEND_CMD_IDLE(controller, 10);
+		aml_nand_dbg("REG(0x%x): value:0x%x, for chip[%d]\n",
+			addr[i],
+			buf[i],
+			chipnr);
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+static int dummy_read(struct hw_controller *controller, unsigned char chipnr)
+{
+	//struct amlnand_chip *aml_chip = controller->aml_chip;
+	//struct nand_flash *flash = &(aml_chip->flash);
+	int i, ret = 0;
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+	for (i = 0; i < 5; i++)
+	    controller->cmd_ctrl(controller, 0x0, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, NAND_CMD_READSTART, NAND_CTRL_CLE);
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return 0;
+}
+
+static int set_reg_value_hynix(struct hw_controller *controller,
+	u8 *buf,
+	u8 *addr,
+	u8 chipnr,
+	u8 cnt)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	int i, ret = 0;
+
+	if ((flash->new_type == 0) || (flash->new_type > 10))
+		return NAND_SUCCESS;
+
+	/* aml_nand_dbg("flash->new_type:%d", flash->new_type);*/
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	controller->cmd_ctrl(controller,
+		NAND_CMD_HYNIX_SET_VALUE_START,
+		NAND_CTRL_CLE);
+
+	for (i = 0; i < cnt; i++) {
+		controller->cmd_ctrl(controller, addr[i], NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 15);
+		controller->writebyte(controller, buf[i]);
+		NFC_SEND_CMD_IDLE(controller, 0);
+		/*
+		aml_nand_dbg("REG(0x%x):value:0x%x, for chip[%d]\n",
+		addr[i], buf[i], chipnr);
+		*/
+	}
+
+	controller->cmd_ctrl(controller,
+		NAND_CMD_HYNIX_SET_VALUE_END,
+		NAND_CTRL_CLE);
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return 0;
+}
+
+/* only called while uboot.*/
+#ifdef 	AML_NAND_UBOOT
+#define HYNIX_20NM_DBG	(0)
+static int aml_nand_get_20nm_OTP_value(struct hw_controller *controller,  unsigned char *buf,unsigned char chipnr)
+{
+	int i, j, k, check_flag = 0;
+	unsigned char  *tmp_buf;
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+
+#if (HYNIX_20NM_DBG)
+	int total_reg_cnt, reg_cnt_otp;
+	total_reg_cnt = controller->readbyte(controller);
+	reg_cnt_otp = controller->readbyte(controller);
+	aml_nand_dbg("20 nm flash total_reg_cnt:%d, reg_cnt_otp:%d, chip[%d]", total_reg_cnt, reg_cnt_otp, chipnr);
+#endif
+
+	for (i=0; i<HYNIX_OTP_COPY; i++) {
+		check_flag = 0;
+		memset(buf, 0, HYNIX_OTP_LEN>>1);
+		for (j=0;j<(HYNIX_OTP_LEN>>1);j++) {
+			buf[j] = controller->readbyte(controller);
+			ndelay(100);
+		}
+		for (j=0;j<64;j+=8) {
+			for (k=0;k<7;k++) {
+				if (((buf[k+j] < 0x80) && (buf[k+j+64] < 0x80)) ||
+				   ((buf[k+j] > 0x80) && (buf[k+j+64] > 0x80))  ||
+				   ((unsigned char)(buf[k+j]^buf[k+j+64]) != 0xFF)){
+					aml_nand_dbg("%dst copy at j:%d, k%d, not match %2x %2x\n", \
+						i, j, k, buf[k+j], buf[k+j+64]);
+					check_flag = 1;
+					break;
+				}
+				if (check_flag) {
+					break;
+				}
+			}
+			if (check_flag) {
+				break;
+			}
+		}
+		if (check_flag == 0) {
+			break;
+		}
+	}
+		if (check_flag) {
+		aml_nand_msg(" 20 nm flashdefault vaule abnormal not safe !!!!!, chip[%d]", chipnr);
+		BUG();
+	}
+	else{
+		tmp_buf = buf;
+		aml_nand_dbg("20 nm flashdefault vaule OK at %dst copy", i);
+		memcpy(&retry_info->reg_def_val[chipnr][0], tmp_buf, retry_info->reg_cnt_lp);
+		aml_nand_dbg("20 nm flash default vaule");
+		for (j=0;j<retry_info->reg_cnt_lp;j++)
+			aml_nand_dbg("REG(0x%x):   value:0x%2x, for chip[%d]", retry_info->reg_addr_lp[j],
+			                   retry_info->reg_def_val[chipnr][j], chipnr);
+		tmp_buf += retry_info->reg_cnt_lp;
+		aml_nand_dbg("20 nm flash offset vaule");
+		for (j=0;j<retry_info->retry_cnt_lp;j++) {
+			for (k=0;k<retry_info->reg_cnt_lp;k++) {
+				retry_info->reg_offs_val_lp[chipnr][j][k] = (char)tmp_buf[0];
+				tmp_buf++;
+				aml_nand_dbg("Retry[%d]   REG(0x%x):	value:0x%2x, for chip[%d]", j, retry_info->reg_addr_lp[k],
+				                 retry_info->reg_offs_val_lp[chipnr][j][k], chipnr);
+			}
+			aml_nand_dbg("retry_info->retry_cnt_lp:%d", retry_info->retry_cnt_lp);
+		}
+	}
+	return check_flag;
+}
+
+
+static int _get_valid_otp_bit(unsigned char *sets, int set_cnt, int bit, unsigned char * _bit)
+{
+    int ret = 0;
+    int i, max;
+    int cnt_0 = 0;
+    int cnt_1 = 0;
+
+    *_bit = 1;
+    for (i = 0; i < set_cnt; i++)
+    {
+        if ((sets[i] & (1 << bit)))
+        {
+            cnt_1++;
+        }
+        else
+        {
+            cnt_0++;
+        }
+    }
+    max = cnt_1;
+    if (cnt_0 > cnt_1)
+    {
+        max = cnt_0;
+        *_bit = 0;
+    }
+    if (max <= 4)
+    {
+        ret = -1;
+    }
+
+    return ret;
+}
+//get valid otp table from src, then copy it to the dst.
+static int _get_valid_otp(unsigned char * src,unsigned char * dst)
+{
+    int ret = 0;
+    int set_size = 32;
+    int set_cnt = 8;
+    int bit_cnt = 8;
+    int i, j, k;
+    unsigned char * _set_org;
+    unsigned char * _set_inv;
+    unsigned char _target_org[8];
+    unsigned char _target_inv[8];
+    unsigned char _M, _bit;
+
+    if ((src == NULL) || (dst == NULL))
+    {
+        PRINT("%s() %d: invalid buffer param\n", __FUNCTION__, __LINE__);
+        return -1;
+    }
+
+    _set_org = &src[16]; // org set 0.
+    _set_inv = &src[48]; // inv set 0
+    //all bytes in the set.
+    for (i = 0; i < set_size; i++)
+    {
+        for (j = 0; j < set_cnt; j++)
+        {
+            _target_org[j] = _set_org[j*set_size*2 + i];
+            _target_inv[j] = _set_inv[j*set_size*2 + i];
+        }
+#if	0
+        printk("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+					_target_org[0], _target_org[1], _target_org[2], _target_org[3], _target_org[4], _target_org[5], _target_org[6], _target_org[7]);
+				printk("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+					_target_inv[0], _target_inv[1], _target_inv[2], _target_inv[3], _target_inv[4], _target_inv[5], _target_inv[6], _target_inv[7]);
+#endif
+        _M = 0;
+        for (k = 0; k < bit_cnt; k++)
+        {
+            ret = _get_valid_otp_bit(_target_org, set_cnt, k, &_bit);
+            if (ret)
+            {
+                ret = _get_valid_otp_bit(_target_inv, set_cnt, k, &_bit);
+                if (ret)
+                {
+                    PRINT("%s() %d: get valid bit failed!\n", __FUNCTION__, __LINE__);
+                    return -1;
+                }
+                //_bit = ~_bit;
+                //invers it while the bit is come from invers set.
+                if (_bit == 0)
+                    _bit = 1;
+                else
+                    _bit = 0;
+
+            }
+            _M |= _bit << k;
+        }
+        dst[i] = _M;
+    }
+    return ret;
+}
+
+static int aml_nand_get_1ynm_OTP_value(struct hw_controller *controller,
+	u8 *buf,
+	u8 chipnr)
+{
+	int i, j, k, ret =0;
+	//unsigned char  *tmp_buf;
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	unsigned char  retry_value_sta[32] ={0};
+	memset(buf, 0, 528);
+	for (i=0; i<528; i++) {
+		buf[i] = controller->readbyte(controller);
+		 NFC_SEND_CMD_IDLE(controller, 0);
+		  NFC_SEND_CMD_IDLE(controller, 0);
+	}
+
+//	unsigned char temp_orgin[8],temp_inverse[8];
+//
+//	for(i=0; i<32; i++)	//retry value number
+//	{
+//		for(j=0; j<HYNIX_OTP_COPY; j++){
+//			temp_orgin[j]=buf[16 + j];			//base ops 16
+//			temp_inverse[j]=buf[16 + j + 32];			//base ops 16  inverse offset 32
+//		}
+//		retry_value_sta[i] = get_valid_otp_byte(temp_orgin, temp_inverse);
+//
+//	}
+		ret = _get_valid_otp(buf, retry_value_sta);
+		for (j=0;j<8;j++) {
+			for (k=0;k<4;k++) {
+				if (j == 0)
+					retry_info->reg_def_val[chipnr][k] = retry_value_sta[k];
+				else
+					retry_info->reg_offs_val_lp[chipnr][j-1][k] = retry_value_sta[k + j*4];
+			}
+		}
+		if (ret < 0) {
+			aml_nand_msg("########!!!!!!!get retry table fail\n");
+			return 1;
+		}
+
+
+
+		for (j=0;j<retry_info->reg_cnt_lp;j++)
+			aml_nand_dbg("REG(0x%x):   value:0x%2x, for chip[%d]", retry_info->reg_addr_lp[j],
+			                   retry_info->reg_def_val[chipnr][j], chipnr);
+		for (j=0;j<retry_info->retry_cnt_lp;j++) {
+			for (k=0;k<retry_info->reg_cnt_lp;k++) {
+				aml_nand_dbg("Retry[%d]   REG(0x%x):	value:0x%2x, for chip[%d]", j, retry_info->reg_addr_lp[k],
+				                 retry_info->reg_offs_val_lp[chipnr][j][k], chipnr);
+			}
+			aml_nand_dbg("retry_info->retry_cnt_lp:%d", retry_info->retry_cnt_lp);
+		}
+		return 0;
+}
+static int get_reg_value_formOTP_hynix(struct hw_controller *controller, unsigned char chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct chip_operation *operation = &(aml_chip->operation);
+	//struct read_retry_info *retry_info =  &(controller->retry_info);
+	//int i, j, k, reg_cnt_otp, total_reg_cnt, check_flag = 0;
+	int check_flag = 0;
+	//unsigned char *one_copy_buf, *tmp_buf;
+	unsigned char *one_copy_buf;
+	int ret = 0;
+
+	if ((flash->new_type != HYNIX_20NM_4GB) && (flash->new_type != HYNIX_20NM_8GB)&& (flash->new_type != HYNIX_1YNM))
+		return 0;
+
+	aml_nand_dbg("flash->new_type:%d", flash->new_type);
+
+	one_copy_buf = (unsigned char *)aml_nand_malloc(HYNIX_OTP_LEN);
+	if (one_copy_buf == NULL) {
+		aml_nand_msg("malloc failed and need 0x%x here", HYNIX_OTP_LEN);
+		ret = -NAND_MALLOC_FAILURE;
+		goto error_exit0;
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		ret = -NAND_BUSY_FAILURE;
+		goto error_exit1;
+	}
+
+	ret = operation->reset(aml_chip, chipnr);
+
+	if (ret) {
+		aml_nand_msg("reset chip failed chipnr:%d", chipnr);
+		ret = -NAND_BUSY_FAILURE;
+		goto error_exit1;
+	}
+
+	controller->cmd_ctrl(controller, 0x36, NAND_CTRL_CLE);
+
+	 NFC_SEND_CMD_IDLE(controller, 0);
+	if (flash->new_type == HYNIX_20NM_8GB) {
+		controller->cmd_ctrl(controller, 0xff, NAND_CTRL_ALE);			//send 0xff add
+		 NFC_SEND_CMD_IDLE(controller, 0);
+		controller->writebyte(controller, 0x40);							//write 0x40 into 0xff add
+		 NFC_SEND_CMD_IDLE(controller, 0);
+		controller->cmd_ctrl(controller, 0xcc, NAND_CTRL_ALE);			//send 0xcc add
+		NFC_SEND_CMD_IDLE(controller, 0);
+		controller->writebyte(controller, 0x4d);							//write 0x4d
+	}
+	else if(flash->new_type == HYNIX_20NM_4GB){
+		controller->cmd_ctrl(controller, 0xae, NAND_CTRL_ALE);			//send 0xae add
+		 NFC_SEND_CMD_IDLE(controller, 0);
+		controller->writebyte(controller, 0x00);							//write 0x0 into 0xff add
+		 NFC_SEND_CMD_IDLE(controller, 0);
+		controller->cmd_ctrl(controller, 0xb0, NAND_CTRL_ALE);			//send 0xb0 add
+		NFC_SEND_CMD_IDLE(controller, 0);
+		controller->writebyte(controller, 0x4d);							//write 0x4d
+	}
+	else if(flash->new_type == HYNIX_1YNM){
+		controller->cmd_ctrl(controller, 0x38, NAND_CTRL_ALE);			//send 0xae add
+	 NFC_SEND_CMD_IDLE(controller, 0);
+		controller->writebyte(controller, 0x52);							//write 0x0 into 0xff add
+		 NFC_SEND_CMD_IDLE(controller, 0);
+	}
+	 NFC_SEND_CMD_IDLE(controller, 0);
+	controller->cmd_ctrl(controller, 0x16, NAND_CTRL_CLE);	//send cmd 0x16
+	 NFC_SEND_CMD_IDLE(controller, 0);
+	controller->cmd_ctrl(controller, 0x17, NAND_CTRL_CLE);				//send cmd 0x17
+	 NFC_SEND_CMD_IDLE(controller, 0);
+	controller->cmd_ctrl(controller, 0x04, NAND_CTRL_CLE);				//send cmd 0x04
+	 NFC_SEND_CMD_IDLE(controller, 0);
+	controller->cmd_ctrl(controller, 0x19, NAND_CTRL_CLE);					//send cmd 0x19
+	 NFC_SEND_CMD_IDLE(controller, 0);
+	controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+	controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, 0>>8, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, 0x200, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, 0x200>>8, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, 0x200>>16, NAND_CTRL_ALE);
+	controller->cmd_ctrl(controller, NAND_CMD_READSTART, NAND_CTRL_CLE);
+
+
+
+#if 1
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		ret = -NAND_BUSY_FAILURE;
+		goto error_exit1;
+	}
+
+	if (controller->option & NAND_CTRL_NONE_RB)
+		controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+#else
+	udelay(500);
+#endif
+#if 0
+	total_reg_cnt = controller->readbyte(controller);
+	reg_cnt_otp = controller->readbyte(controller);
+	aml_nand_dbg("20 nm flash total_reg_cnt:%d, reg_cnt_otp:%d, chip[%d]", total_reg_cnt, reg_cnt_otp, chipnr);
+
+	for (i=0; i<HYNIX_OTP_COPY; i++) {
+		check_flag = 0;
+		memset(one_copy_buf, 0, HYNIX_OTP_LEN>>1);
+		for (j=0;j<(HYNIX_OTP_LEN>>1);j++) {
+			one_copy_buf[j] = controller->readbyte(controller);
+			ndelay(100);
+		}
+
+		for (j=0;j<64;j+=8) {
+			for (k=0;k<7;k++) {
+				if (((one_copy_buf[k+j] < 0x80) && (one_copy_buf[k+j+64] < 0x80)) ||
+				   ((one_copy_buf[k+j] > 0x80) && (one_copy_buf[k+j+64] > 0x80))  ||
+				   ((unsigned char)(one_copy_buf[k+j]^one_copy_buf[k+j+64]) != 0xFF)){
+					aml_nand_dbg("%dst copy at j:%d, k%d, not match %2x %2x\n", \
+						i, j, k, one_copy_buf[k+j], one_copy_buf[k+j+64]);
+					check_flag = 1;
+					break;
+				}
+				if (check_flag) {
+					break;
+				}
+			}
+			if (check_flag) {
+				break;
+			}
+		}
+		if (check_flag == 0) {
+			break;
+		}
+	}
+#else
+	if ((flash->new_type == HYNIX_20NM_4GB) || (flash->new_type == HYNIX_20NM_8GB))
+		 check_flag = aml_nand_get_20nm_OTP_value(controller,one_copy_buf,chipnr);
+	else if(flash->new_type == HYNIX_1YNM)
+		 check_flag = aml_nand_get_1ynm_OTP_value(controller,one_copy_buf,chipnr);
+	aml_nand_msg("check_flag %d", check_flag);
+#endif
+
+	ret = operation->reset(aml_chip, chipnr);
+
+	if (ret) {
+		aml_nand_msg("reset chip failed chipnr:%d", chipnr);
+		ret = -NAND_BUSY_FAILURE;
+		goto error_exit1;
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		ret = -NAND_BUSY_FAILURE;
+		goto error_exit1;
+	}
+	if ((flash->new_type == HYNIX_20NM_4GB) || (flash->new_type == HYNIX_20NM_8GB)) {
+		controller->cmd_ctrl(controller, 0x38, NAND_CTRL_CLE);			//end read otp mode
+
+		}
+	else if(flash->new_type == HYNIX_1YNM) {
+		controller->cmd_ctrl(controller, 0x36, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, 0x38, NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 0);
+		controller->writebyte(controller, 0);
+		NFC_SEND_CMD_IDLE(controller, 0);
+		controller->cmd_ctrl(controller, 0x16, NAND_CTRL_CLE);
+
+		/*
+		hynix read otp data cmd sequence for dummy read ,don't care address
+		*/
+		controller->cmd_ctrl(controller, NAND_CMD_READ0, NAND_CTRL_CLE);
+		controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+		controller->cmd_ctrl(controller, NAND_CMD_READSTART, NAND_CTRL_CLE);
+
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		ret = -NAND_BUSY_FAILURE;
+		goto error_exit1;
+	}
+
+	aml_nand_free(one_copy_buf);
+
+	return 0;
+
+error_exit1:
+	aml_nand_free(one_copy_buf);
+
+error_exit0:
+	return ret;
+}
+
+#endif /* AML_NAND_UBOOT */
+
+/* init default offset value here,
+** first time, for 26nm, read directly from nand reg,
+** first time, for 20nm, read from nand otp area
+** normal booting, read from storage nand blocks
+*/
+static int readretry_init_hynix(struct hw_controller *controller)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	//struct chip_operation *operation = &(aml_chip->operation);
+	struct nand_flash *flash = &(aml_chip->flash);
+	//struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	//struct en_slc_info *slc_info =  &(controller->slc_info);
+	int i, ret = 0;
+
+	//read from nand block
+
+	ret = aml_nand_scan_hynix_info(aml_chip);
+	if (ret < 0)
+		aml_nand_msg("there is not hynix info, need read from otp");
+
+#ifdef AML_NAND_UBOOT
+	//read from nand reg or otp
+	if (retry_info->default_flag == 0) {
+
+	nand_get_chip(aml_chip);
+	aml_nand_dbg("hynix nand readretry info scan: no info; and get it from nand reg or otp");
+	for (i=0; i<controller->chip_num; i++) {
+		if ((flash->new_type == HYNIX_26NM_4GB) || (flash->new_type == HYNIX_26NM_8GB)) {
+			ret = get_reg_value_hynix(controller, &retry_info->reg_def_val[i][0],\
+				&retry_info->reg_addr_lp[0], i, retry_info->reg_cnt_lp);
+			if (ret < 0) {
+				aml_nand_msg("get reg value hynix failed");
+				goto error_exit;
+			}
+		}
+		else  if((flash->new_type == HYNIX_20NM_8GB) || (flash->new_type == HYNIX_20NM_4GB)|| (flash->new_type == HYNIX_1YNM)){
+			ret = get_reg_value_formOTP_hynix(controller, i);
+			if (ret < 0) {
+				aml_nand_msg("get reg value hynix failed");
+				goto error_exit;
+			}
+		}
+		udelay(2);
+	}
+
+	nand_release_chip(aml_chip);
+
+	}
+#else /* AML_NAND_UBOOT */
+	if (retry_info->default_flag == 0) {
+		aml_nand_msg("hynix nand scan readretry info failed");
+		ret = -NAND_FAILED;
+	}
+
+#endif /* AML_NAND_UBOOT */
+	retry_info->flag = 1;
+
+error_exit:
+	return ret;
+}
+
+
+/* when ecc fail,set nand retry reg */
+static int readretry_handle_hynix(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	u8 reg_value[READ_RETRY_REG_NUM];
+	int i, cur_cnt;
+	int retry_zone, retry_offset;
+	int retry_cnt_lp;
+
+	retry_cnt_lp = retry_info->retry_cnt_lp;
+
+	if ((flash->new_type == 0) || (flash->new_type > 10))
+		return NAND_SUCCESS;
+
+	if (retry_info->cur_cnt_lp[chipnr] < retry_cnt_lp)
+		cur_cnt = retry_info->cur_cnt_lp[chipnr];
+	else {
+		retry_zone = retry_info->cur_cnt_lp[chipnr] / retry_cnt_lp;
+		retry_offset = retry_info->cur_cnt_lp[chipnr] % retry_cnt_lp;
+		cur_cnt = (retry_zone + retry_offset) % retry_cnt_lp;
+	}
+
+	aml_nand_dbg("flash->new_type:%d, cur_cnt:%d",
+		flash->new_type,
+		cur_cnt);
+
+	memset(&reg_value[0], 0, READ_RETRY_REG_NUM);
+
+	for (i = 0; i < retry_info->reg_cnt_lp; i++) {
+		if ((flash->new_type == HYNIX_26NM_8GB)
+			|| (flash->new_type == HYNIX_26NM_4GB)) {
+			if (retry_info->reg_offs_val_lp[0][cur_cnt][i]
+				== READ_RETRY_ZERO)
+				reg_value[i] = 0;
+			else
+				reg_value[i] =
+				retry_info->reg_def_val[chipnr][i] +
+				retry_info->reg_offs_val_lp[0][cur_cnt][i];
+		} else if ((flash->new_type == HYNIX_20NM_8GB)
+			|| (flash->new_type == HYNIX_20NM_4GB)
+			|| (flash->new_type == HYNIX_1YNM))
+			reg_value[i] =
+				retry_info->reg_offs_val_lp[chipnr][cur_cnt][i];
+	}
+
+	set_reg_value_hynix(controller,
+		&reg_value[0],
+		&retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	udelay(2);
+
+	retry_info->cur_cnt_lp[chipnr]++;
+	return 0;
+}
+
+static int readretry_set_def_val_hynix(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	struct en_slc_info *slc_info =  &(controller->slc_info);
+	int i, ret = 0;
+
+	if ((flash->new_type == 0) || (flash->new_type > 10))
+		return NAND_SUCCESS;
+
+	aml_nand_dbg("hynix reatry exit");
+	memset(&retry_info->cur_cnt_lp[0], 0, MAX_CHIP_NUM);
+
+	i = chipnr;
+	/* for read retry */
+	ret = set_reg_value_hynix(controller,
+		&retry_info->reg_def_val[i][0],
+		&retry_info->reg_addr_lp[0],
+		i,
+		retry_info->reg_cnt_lp);
+	if (ret < 0)
+		aml_nand_msg("set retry_info reg value failed for chip[%d]", i);
+	/* for en-slc */
+	udelay(2);
+
+	if (flash->new_type != HYNIX_1YNM) {
+		ret = set_reg_value_hynix(controller,
+			&slc_info->reg_def_val[i][0],
+			&slc_info->reg_addr[0],
+			i,
+			slc_info->reg_cnt);
+		if (ret < 0)
+			aml_nand_msg("set slc reg value failed for chip[%d]",
+				i);
+	}
+
+	return ret;
+}
+
+static int enslc_init_hynix(struct hw_controller *controller)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct en_slc_info *slc_info =  &(controller->slc_info);
+	int i, ret = 0;
+
+	if ((flash->new_type == 0) || (flash->new_type > HYNIX_20NM_8GB))
+		return NAND_SUCCESS;
+
+	if (flash->new_type == HYNIX_1YNM)
+		return NAND_SUCCESS;
+
+	/* aml_nand_dbg("flash->new_type:%d", flash->new_type); */
+	nand_get_chip(aml_chip);
+	for (i = 0; i < controller->chip_num; i++) {
+		ret = get_reg_value_hynix(controller,
+			&slc_info->reg_def_val[i][0],
+			&slc_info->reg_addr[0],
+			i,
+			slc_info->reg_cnt);
+		if (ret)
+			aml_nand_msg("get slc def reg val failed for chip[%d]",
+				i);
+	}
+	nand_release_chip(aml_chip);
+
+	return ret;
+}
+
+static int enslc_enter_hynix(struct hw_controller *controller)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct en_slc_info *slc_info =  &(controller->slc_info);
+	u8 reg_value_tmp[EN_SLC_REG_NUM];
+	int i, j, ret = 0;
+
+	if ((flash->new_type == 0) || (flash->new_type > HYNIX_20NM_8GB))
+		return NAND_SUCCESS;
+
+	if (flash->new_type == HYNIX_1YNM)
+		return NAND_SUCCESS;
+	/* aml_nand_dbg("flash->new_type:%d", flash->new_type); */
+
+	memset(&reg_value_tmp[0], 0, EN_SLC_REG_NUM);
+
+	for (i = 0; i < controller->chip_num; i++) {
+		for (j = 0; j < slc_info->reg_cnt; j++)
+			reg_value_tmp[j] = slc_info->reg_def_val[i][j]
+				+ slc_info->reg_offs_val[j];
+
+		ret = set_reg_value_hynix(controller,
+			&reg_value_tmp[0],
+			&slc_info->reg_addr[0],
+			i,
+			slc_info->reg_cnt);
+		if (ret < 0)
+			aml_nand_msg("set slc reg value failed for chip[%d]",
+				i);
+
+		udelay(2);
+		memset(&reg_value_tmp[0], 0, EN_SLC_REG_NUM);
+	}
+
+	return ret;
+}
+
+/* working  in Normal program mode */
+static int enslc_exit_hynix(struct hw_controller *controller)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	int i, ret = 0;
+
+	if ((flash->new_type == 0) || (flash->new_type > HYNIX_20NM_8GB))
+		return NAND_SUCCESS;
+
+	if (flash->new_type == HYNIX_1YNM)
+		return NAND_SUCCESS;
+	/* aml_nand_dbg("flash->new_type:%d", flash->new_type); */
+
+	for (i = 0; i < controller->chip_num; i++) {
+		ret = set_reg_value_hynix(controller,
+			&slc_info->reg_def_val[i][0],
+			&slc_info->reg_addr[0],
+			i,
+			slc_info->reg_cnt);
+		if (ret < 0)
+			aml_nand_msg("set slc reg value failed for chip[%d]",
+				i);
+		udelay(2);
+		/* dummy read to disable e-slc mode.*/
+		dummy_read(controller, i);
+	}
+
+	return ret;
+}
+
+
+/* for toshiba */
+/***********************TOSHIBA****************************/
+static int set_reg_value_toshiba(struct hw_controller *controller,
+	u8 *buf,
+	u8 *addr,
+	u8 chipnr,
+	u8 cnt)
+{
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	int i, ret = 0;
+
+	/* aml_nand_dbg("flash->new_type:%d", flash->new_type); */
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	if (retry_info->cur_cnt_lp[chipnr] == 0) {
+		controller->cmd_ctrl(controller,
+			NAND_CMD_TOSHIBA_PRE_CON1, NAND_CTRL_CLE);
+		 NFC_SEND_CMD_IDLE(controller, 2);
+		controller->cmd_ctrl(controller,
+			NAND_CMD_TOSHIBA_PRE_CON2, NAND_CTRL_CLE);
+		 NFC_SEND_CMD_IDLE(controller, 2);
+	}
+
+	for (i = 0; i < cnt; i++) {
+		controller->cmd_ctrl(controller,
+			NAND_CMD_TOSHIBA_SET_VALUE, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, 2);
+		controller->cmd_ctrl(controller, addr[i], NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 2);
+		controller->writebyte(controller, buf[i]);
+		NFC_SEND_CMD_IDLE(controller, 2);
+		aml_nand_dbg("REG(0x%x): value:0x%x, for chip[%d]\n",
+			addr[i], buf[i], chipnr);
+	}
+
+	controller->cmd_ctrl(controller,
+		NAND_CMD_TOSHIBA_BEF_COMMAND1, NAND_CTRL_CLE);
+	 NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller,
+		NAND_CMD_TOSHIBA_BEF_COMMAND2, NAND_CTRL_CLE);
+	 NFC_SEND_CMD_IDLE(controller, 2);
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+
+/* when ecc fail,set nand retry reg */
+static int readretry_handle_toshiba(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	int cur_cnt, ret = 0;
+
+	/*
+	if (flash->new_type != TOSHIBA_2XNM)
+		return NAND_SUCCESS;
+	*/
+	cur_cnt = retry_info->cur_cnt_lp[chipnr];
+	/*
+	aml_nand_dbg("flash->new_type:%d, cur_cnt:%d",flash->new_type,cur_cnt);
+	*/
+	ret = set_reg_value_toshiba(controller,
+		&retry_info->reg_offs_val_lp[0][cur_cnt][0],
+		&retry_info->reg_addr_lp[0],
+		chipnr, retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_toshiba failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	cur_cnt++;
+	retry_info->cur_cnt_lp[chipnr] =
+		(cur_cnt > (retry_info->retry_cnt_lp - 1)) ? 0 : cur_cnt;
+
+	return NAND_SUCCESS;
+}
+
+static int readretry_exit_toshiba(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	struct chip_operation *operation = &(aml_chip->operation);
+	int  ret = 0, i;
+	uint8_t buf[5] = {0};
+
+	/* if(flash->new_type != TOSHIBA_2XNM) */
+	/* return NAND_SUCCESS; */
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	aml_nand_dbg("toshiba reatry exit");
+	memset(&retry_info->cur_cnt_lp[0], 0, MAX_CHIP_NUM);
+	if (flash->new_type != TOSHIBA_A19NM) {
+		for (i = 0; i < retry_info->reg_cnt_lp; i++) {
+			controller->cmd_ctrl(controller,
+				NAND_CMD_TOSHIBA_SET_VALUE, NAND_CTRL_CLE);
+			NFC_SEND_CMD_IDLE(controller, 2);
+			controller->cmd_ctrl(controller,
+				retry_info->reg_addr_lp[i], NAND_CTRL_ALE);
+			NFC_SEND_CMD_IDLE(controller, 2);
+			controller->writebyte(controller, buf[i]);
+			NFC_SEND_CMD_IDLE(controller, 2);
+			aml_nand_dbg("REG(0x%x): value:0x%x, for chip[%d]\n",
+				retry_info->reg_addr_lp[i], buf[i], chipnr);
+		}
+	}
+	ret = operation->reset(aml_chip, chipnr);
+	if (ret < 0) {
+		aml_nand_msg("reset nand failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+
+
+/* for samsung */
+/*************************SUMSUNG***************************/
+static int set_reg_value_samsung(struct hw_controller *controller,
+	u8 *buf,
+	u8 *addr,
+	u8 chipnr,
+	u8 cnt)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	int i, ret = 0;
+
+	if (flash->new_type != SUMSUNG_2XNM)
+		return NAND_SUCCESS;
+
+	aml_nand_dbg("flash->new_type:%d", flash->new_type);
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		controller->cmd_ctrl(controller,
+			NAND_CMD_SAMSUNG_SET_VALUE, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, 2);
+		controller->cmd_ctrl(controller, 0, NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 0);
+		controller->cmd_ctrl(controller, addr[i], NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 0);
+		controller->writebyte(controller, buf[i]);
+		NFC_SEND_CMD_IDLE(controller, 20);
+		aml_nand_dbg("REG(0x%x):value:0x%x, for chip[%d]\n",
+			addr[i],
+			buf[i],
+			chipnr);
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+
+static int readretry_handle_samsung(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	int cur_cnt, ret = 0;
+
+	if (flash->new_type != SUMSUNG_2XNM)
+		return NAND_SUCCESS;
+
+	cur_cnt = retry_info->cur_cnt_lp[chipnr];
+
+	aml_nand_dbg("flash->new_type:%d,cur_cnt:%d", flash->new_type, cur_cnt);
+
+	ret = set_reg_value_samsung(controller,
+		&retry_info->reg_offs_val_lp[0][cur_cnt][0],
+		&retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_samsung failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	cur_cnt++;
+	retry_info->cur_cnt_lp[chipnr] =
+		(cur_cnt > (retry_info->retry_cnt_lp - 1)) ? 0 : cur_cnt;
+
+	return NAND_SUCCESS;
+}
+
+static int readretry_exit_samsung(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	int  ret = 0;
+
+	if (flash->new_type != SUMSUNG_2XNM)
+		return NAND_SUCCESS;
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	aml_nand_dbg("samsung reatry exit");
+	memset(&retry_info->cur_cnt_lp[0], 0, MAX_CHIP_NUM);
+
+	ret = set_reg_value_samsung(controller,
+		&retry_info->reg_offs_val_lp[0][0][0],
+		&retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_samsung failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+
+
+/***********************************MICRON************************************/
+static int set_reg_value_micron(struct hw_controller *controller,
+	u8 *buf,
+	u8 *addr,
+	u8 chipnr,
+	u8 cnt)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+/* struct read_retry_info *retry_info =  &(controller->retry_info); */
+	int i, ret = 0;
+
+
+	if (flash->new_type != MICRON_20NM)
+		return NAND_SUCCESS;
+
+	aml_nand_dbg("flash->new_type:%d", flash->new_type);
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		controller->cmd_ctrl(controller,
+			NAND_CMD_MICRON_SET_VALUE, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, 2);
+		controller->cmd_ctrl(controller, addr[i], NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 10);
+		controller->writebyte(controller, buf[i]);
+		NFC_SEND_CMD_IDLE(controller, 1);
+		controller->writebyte(controller, 0);
+		NFC_SEND_CMD_IDLE(controller, 1);
+		controller->writebyte(controller, 0);
+		NFC_SEND_CMD_IDLE(controller, 1);
+		controller->writebyte(controller, 0);
+		NFC_SEND_CMD_IDLE(controller, 100);
+		aml_nand_dbg("REG(0x%x)  value:0x%x, for chip[%d]\n",
+			addr[i],
+			buf[i],
+			chipnr);
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+
+static int readretry_handle_micron(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	int cur_cnt, ret = 0;
+
+	if (flash->new_type != MICRON_20NM)
+		return NAND_SUCCESS;
+
+	cur_cnt = retry_info->cur_cnt_lp[chipnr];
+
+	aml_nand_dbg("flash->new_type:%d, cur_cnt:%d",
+		flash->new_type,
+		cur_cnt);
+
+	ret = set_reg_value_micron(controller,
+		&retry_info->reg_offs_val_lp[0][cur_cnt][0],
+		&retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_samsung failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	cur_cnt++;
+	retry_info->cur_cnt_lp[chipnr] =
+		(cur_cnt > (retry_info->retry_cnt_lp - 1)) ? 0 : cur_cnt;
+
+	return NAND_SUCCESS;
+
+}
+
+static int  readretry_exit_micron(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	int  ret = 0;
+
+	if (flash->new_type != MICRON_20NM)
+		return NAND_SUCCESS;
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	aml_nand_dbg("micron reatry exit");
+	memset(&retry_info->cur_cnt_lp[0], 0, MAX_CHIP_NUM);
+
+	ret = set_reg_value_micron(controller,
+		&retry_info->reg_def_val[0][0],
+		&retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_samsung failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+/**************************INTEL***************************************/
+static int readretry_handle_intel(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	int cur_cnt, ret = 0;
+	int advance = 1;
+
+	if (flash->new_type != INTEL_20NM)
+		return NAND_SUCCESS;
+
+	cur_cnt = retry_info->cur_cnt_lp[chipnr];
+	aml_nand_dbg("flash->new_type:%d, cur_cnt:%d",
+		flash->new_type,
+		cur_cnt);
+
+	if (cur_cnt == 3)
+		ret = set_reg_value_micron(controller,
+		(uint8_t *)&advance,
+		&retry_info->reg_addr_lp[1],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_intel failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	ret = set_reg_value_micron(controller,
+		&retry_info->reg_offs_val_lp[0][cur_cnt][0],
+		&retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_intel failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	NFC_SEND_CMD_IDLE(controller, 10);
+
+	cur_cnt++;
+	retry_info->cur_cnt_lp[chipnr] =
+		(cur_cnt > (retry_info->retry_cnt_lp - 1)) ? 0 : cur_cnt;
+
+	return NAND_SUCCESS;
+}
+
+static int  readretry_exit_intel(struct hw_controller *controller,
+	u8 chipnr)
+{
+
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	int ret = 0;
+
+	if (flash->new_type != INTEL_20NM)
+		return NAND_SUCCESS;
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	aml_nand_dbg("intel reatry exit");
+	memset(&retry_info->cur_cnt_lp[0], 0, MAX_CHIP_NUM);
+		ret = set_reg_value_micron(controller,
+			&retry_info->reg_def_val[0][0],
+			&retry_info->reg_addr_lp[0],
+			chipnr, retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_intel failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	ret = set_reg_value_micron(controller,
+		&retry_info->reg_def_val[0][0],
+		&retry_info->reg_addr_lp[1],
+		chipnr,
+		retry_info->reg_cnt_lp);
+	if (ret) {
+		aml_nand_msg("set_reg_value_intel failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	return NAND_SUCCESS;
+}
+/* for sandisk */
+/***********************************SANDISK************************************/
+static int  readretry_init_sandisk(struct hw_controller *controller)
+{
+	u8 reg_addr_init[10];
+	int i, j;
+
+	reg_addr_init[0] = 0x04;
+	reg_addr_init[1] = 0x05;
+	reg_addr_init[2] = 0x06;
+	reg_addr_init[3] = 0x07;
+	reg_addr_init[4] = 0x08;
+	reg_addr_init[5] = 0x09;
+	reg_addr_init[6] = 0x0a;
+	reg_addr_init[7] = 0x0b;
+	reg_addr_init[8] = 0x0c;
+
+	/*
+	if (flash->new_type != SANDISK_19NM)
+		return NAND_SUCCESS;
+	*/
+
+	/*
+	aml_nand_dbg("flash->new_type:%d", flash->new_type);
+	*/
+
+	for (i = 0; i < controller->chip_num; i++) {
+		controller->cmd_ctrl(controller,
+			NAND_CMD_SANDISK_INIT_ONE, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, 2);
+		controller->cmd_ctrl(controller,
+			NAND_CMD_SANDISK_INIT_TWO, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, 2);
+		for (j = 0; j < 9; j++) {
+			/* send cmd 0x53 */
+			controller->cmd_ctrl(controller,
+				NAND_CMD_SANDISK_LOAD_VALUE_ONE, NAND_CTRL_CLE);
+			NFC_SEND_CMD_IDLE(controller, 10);
+			/* send 0x04 add */
+			controller->cmd_ctrl(controller,
+				reg_addr_init[j], NAND_CTRL_ALE);
+			NFC_SEND_CMD_IDLE(controller, 10);
+			/* write 0x00 into add */
+			controller->writebyte(controller, 0x0);
+			NFC_SEND_CMD_IDLE(controller, 10);
+		}
+	}
+
+	return NAND_SUCCESS;
+}
+
+static int set_reg_value_sandisk(struct hw_controller *controller,
+	u8 *buf,
+	u8 *addr,
+	u8 chipnr,
+	u8 cnt)
+{
+	int i, ret = 0;
+
+	/*
+	if (flash->new_type != SANDISK_19NM)
+		return NAND_SUCCESS;
+	*/
+	/* aml_nand_dbg("flash->new_type:%d", flash->new_type); */
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	controller->cmd_ctrl(controller,
+		NAND_CMD_SANDISK_INIT_ONE, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller,
+		NAND_CMD_SANDISK_INIT_TWO, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, 2);
+
+	for (i = 0; i < cnt; i++) {
+		controller->cmd_ctrl(controller,
+			NAND_CMD_SANDISK_LOAD_VALUE_ONE, NAND_CTRL_CLE);
+		NFC_SEND_CMD_IDLE(controller, 10);
+	        controller->cmd_ctrl(controller, addr[i], NAND_CTRL_ALE);
+		NFC_SEND_CMD_IDLE(controller, 10);
+		controller->writebyte(controller, buf[i]);
+		NFC_SEND_CMD_IDLE(controller, 10);
+		aml_nand_dbg("REG(0x%x) value:0x%x, for chip[%d]\n",
+			addr[i],
+			buf[i],
+			chipnr);
+	}
+
+	controller->cmd_ctrl(controller,
+		NAND_CMD_SANDISK_DYNAMIC_ENABLE, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, 10);
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+
+static int set_a19_reg_value_sandisk(struct hw_controller *controller,
+	u8 *buf,
+	u8 addr,
+	u8 chipnr,
+	u8 cnt)
+{
+	int i, ret = 0;
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	controller->cmd_ctrl(controller,
+		NAND_CMD_SANDISK_SET_VALUE, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller, addr, NAND_CTRL_ALE);
+	NFC_SEND_CMD_IDLE(controller, 10);
+	for (i = 0; i < cnt; i++) {
+		controller->writebyte(controller, buf[i]);
+		NFC_SEND_CMD_IDLE(controller, 10);
+		aml_nand_dbg("REG(0x%x) value:0x%x, for chip[%d]\n",
+			addr,
+			buf[i],
+			chipnr);
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+int aml_nand_sandisk_A19_set_LMFLGFIX_NEXT(struct hw_controller *controller, unsigned char chipnr)
+{
+    int ret = 0;
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+    //Test Mode Enter
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE1, NAND_CTRL_CLE);
+    NFC_SEND_CMD_IDLE(controller, 2);
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE2, NAND_CTRL_CLE);
+    NFC_SEND_CMD_IDLE(controller, 2);
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE_ACCESS, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE); //addr=0x00
+	NFC_SEND_CMD_IDLE(controller, 2);
+    controller->writebyte(controller, 0x01); //data=0x01
+    NFC_SEND_CMD_IDLE(controller, 10);
+
+    //set LMFLGFIX_NEXT=1
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE_ACCESS, NAND_CTRL_CLE); //0X55
+	NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller, 0x23, NAND_CTRL_ALE); //addr=0x23
+	NFC_SEND_CMD_IDLE(controller, 2);
+    controller->writebyte(controller, 0xC0); //data=0xC0
+    NFC_SEND_CMD_IDLE(controller, 10);
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+    return 0;
+}
+int aml_nand_sandisk_A19_reset_LMFLGFIX_NEXT(struct hw_controller *controller, unsigned char chipnr)
+{
+    int ret = 0;
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+    //Test Mode Enter
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE1, NAND_CTRL_CLE);
+    NFC_SEND_CMD_IDLE(controller, 2);
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE2, NAND_CTRL_CLE);
+    NFC_SEND_CMD_IDLE(controller, 2);
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE_ACCESS, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE); //addr=0x00
+	NFC_SEND_CMD_IDLE(controller, 2);
+    controller->writebyte(controller, 0x01); //data=0x01
+    NFC_SEND_CMD_IDLE(controller, 10);
+    //set LMFLGFIX_NEXT=0
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE_ACCESS, NAND_CTRL_CLE); //0X55
+	NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller, 0x23, NAND_CTRL_ALE); //addr=0x23
+	NFC_SEND_CMD_IDLE(controller, 2);
+    controller->writebyte(controller, 0x40); //data=0x40
+    NFC_SEND_CMD_IDLE(controller, 10);
+    //Test Mode Exit
+    controller->cmd_ctrl(controller, NAND_CMD_SANDISK_TEST_MODE_ACCESS, NAND_CTRL_CLE); //0X55
+	NFC_SEND_CMD_IDLE(controller, 2);
+	controller->cmd_ctrl(controller, 0x00, NAND_CTRL_ALE); //addr=0X00
+	NFC_SEND_CMD_IDLE(controller, 2);
+    controller->writebyte(controller, 0x00); //data=0X00
+    NFC_SEND_CMD_IDLE(controller, 10);
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+    return 0;
+}
+
+static int readretry_handle_a19_sandisk(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	u32 pages_per_blk, tmp_page, pages_per_blk_shift;
+	int cur_cnt;
+	int page_info = 0;
+
+	aml_nand_dbg("flash->new_type:%d, controller->page_addr:%d",
+		flash->new_type,
+		controller->page_addr);
+
+	pages_per_blk = flash->blocksize/flash->pagesize;
+	pages_per_blk_shift = (controller->block_shift-controller->page_shift);
+	tmp_page = controller->page_addr % (1 << pages_per_blk_shift);
+	if (((tmp_page != 0) && (tmp_page % 2) == 0)
+		|| (tmp_page == (pages_per_blk - 1)))
+		page_info =  1;
+	cur_cnt = retry_info->cur_cnt_up[chipnr];
+	set_a19_reg_value_sandisk(controller,
+		&retry_info->reg_offs_val_lp[page_info][cur_cnt][0],
+		retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+    switch (retry_info->retry_stage) {
+        case 0:
+            //DSP OFF, default is DSP OFF, so no need to do
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_RETRY_STA, NAND_CTRL_CLE); //CMD 5D
+            break;
+        case 1:
+            //DSP ON
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_RETRY_STA, NAND_CTRL_CLE); //CMD 5D
+            NFC_SEND_CMD_IDLE(controller, 5);
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_DSP_ON, NAND_CTRL_CLE); //CMD 26
+            break;
+        case 2:
+            //CMD 25 Force Flag Prefix with DSP OFF and LMFLGFIX_NEXT = 0
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_DSP_OFF, NAND_CTRL_CLE); //CMD 25
+            NFC_SEND_CMD_IDLE(controller, 5);
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_RETRY_STA, NAND_CTRL_CLE); //CMD 5D
+            break;
+        case 3:
+            //CMD 25 Force Flag Prefix with DSP ON and LMFLGFIX_NEXT = 1
+            aml_nand_sandisk_A19_set_LMFLGFIX_NEXT(controller,chipnr);
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_DSP_OFF, NAND_CTRL_CLE); //CMD 25
+            NFC_SEND_CMD_IDLE(controller, 5);
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_RETRY_STA, NAND_CTRL_CLE); //CMD 5D
+            NFC_SEND_CMD_IDLE(controller, 5);
+            controller->cmd_ctrl(controller, NAND_CMD_SANDISK_DSP_ON, NAND_CTRL_CLE); //CMD 26
+            break;
+        default:
+            printk("never enter,retry stage:%d\n",retry_info->retry_stage);
+            break;
+    }
+	cur_cnt++;
+    if (cur_cnt > (retry_info->retry_cnt_lp -1)) {
+        retry_info->retry_stage++;
+        retry_info->cur_cnt_up[chipnr] = 0;
+    }
+    else{
+        retry_info->cur_cnt_up[chipnr] = cur_cnt;
+    }
+    aml_nand_dbg("retry_stage:%d, cur_cnt:%d\n",retry_info->retry_stage,cur_cnt);
+	return NAND_SUCCESS;
+
+}
+
+
+static int  readretry_exit_a19_sandisk(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	/* struct nand_flash *flash = &(aml_chip->flash); */
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	struct chip_operation *operation = &(aml_chip->operation);
+	int  ret = 0;
+	uint8_t buf[4] = {0};
+
+	/* if(flash->new_type != SANDISK_19NM) */
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	aml_nand_dbg("sandisk reatry exit");
+    // reset the retry stage
+    retry_info->retry_stage = 0;
+	memset(&retry_info->cur_cnt_lp[0], 0, MAX_CHIP_NUM);
+	memset(&retry_info->cur_cnt_up[0], 0, MAX_CHIP_NUM);
+	set_a19_reg_value_sandisk(controller,
+		buf,
+		retry_info->reg_addr_lp[0],
+		chipnr,
+		retry_info->reg_cnt_lp);
+
+    aml_nand_sandisk_A19_reset_LMFLGFIX_NEXT(controller,chipnr);
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	ret = operation->reset(aml_chip, chipnr);
+	if (ret < 0) {
+		aml_nand_msg("reset nand failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+static int readretry_handle_sandisk(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	u32 pages_per_blk, tmp_page, pages_per_blk_shift;
+	int cur_cnt,  ret = 0;
+
+	aml_nand_dbg("flash->new_type:%d, controller->page_addr:%d",
+		flash->new_type,
+		controller->page_addr);
+
+	pages_per_blk = flash->blocksize/flash->pagesize;
+	pages_per_blk_shift =
+		(controller->block_shift - controller->page_shift);
+
+	tmp_page = controller->page_addr % (1 << pages_per_blk_shift);
+	if (((tmp_page != 0) && (tmp_page % 2) == 0)
+		|| (tmp_page == (pages_per_blk - 1))) {
+		cur_cnt = retry_info->cur_cnt_up[chipnr];
+		aml_nand_dbg("upper page flash->new_type:%d, cur_case:%d",
+			flash->new_type,
+			cur_cnt);
+		ret = set_reg_value_sandisk(controller,
+			&retry_info->reg_offs_val_up[0][cur_cnt][0],
+			&retry_info->reg_addr_up[0],
+			chipnr,
+			retry_info->reg_cnt_up);
+		if (ret) {
+			aml_nand_msg("set_reg_value_sandisk failed chipnr:%d",
+				chipnr);
+			return -NAND_FAILED;
+		}
+		cur_cnt++;
+		retry_info->cur_cnt_up[chipnr] =
+			(cur_cnt > (retry_info->retry_cnt_up - 1)) ? 0 :
+			cur_cnt;
+	} else { /* for lower page */
+		cur_cnt = retry_info->cur_cnt_lp[chipnr];
+		aml_nand_dbg("low page flash->new_type:%d, cur_case:%d",
+			flash->new_type,
+			cur_cnt);
+		ret = set_reg_value_sandisk(controller,
+			&retry_info->reg_offs_val_lp[0][cur_cnt][0],
+			&retry_info->reg_addr_lp[0],
+			chipnr,
+			retry_info->reg_cnt_lp);
+		if (ret) {
+			aml_nand_msg("set_reg_value_sandisk failed chipnr:%d",
+				chipnr);
+			return -NAND_FAILED;
+		}
+
+		cur_cnt++;
+		retry_info->cur_cnt_lp[chipnr] =
+			(cur_cnt > (retry_info->retry_cnt_lp - 1)) ? 0 :
+			cur_cnt;
+	}
+
+	return NAND_SUCCESS;
+}
+
+static int  readretry_exit_sandisk(struct hw_controller *controller,
+	u8 chipnr)
+{
+	struct amlnand_chip *aml_chip = controller->aml_chip;
+	struct read_retry_info *retry_info =  &(controller->retry_info);
+	struct chip_operation *operation = &(aml_chip->operation);
+	int  ret = 0;
+
+	/* if(flash->new_type != SANDISK_19NM) */
+	/* return NAND_SUCCESS; */
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+	aml_nand_dbg("sandisk reatry exit");
+
+	memset(&retry_info->cur_cnt_lp[0], 0, MAX_CHIP_NUM);
+	memset(&retry_info->cur_cnt_up[0], 0, MAX_CHIP_NUM);
+
+	controller->cmd_ctrl(controller,
+		NAND_CMD_SANDISK_DYNAMIC_DISABLE, NAND_CTRL_CLE);
+	NFC_SEND_CMD_IDLE(controller, 2);
+
+	ret = retry_info->init(controller);
+	if (ret) {
+		aml_nand_msg("sandisk reatry exit failed");
+		return -NAND_FAILED;
+	}
+
+	ret = controller->quene_rb(controller, chipnr);
+	if (ret) {
+		aml_nand_msg("quene rb failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	ret = operation->reset(aml_chip, chipnr);
+	if (ret < 0) {
+		aml_nand_msg("reset nand failed chipnr:%d", chipnr);
+		return -NAND_FAILED;
+	}
+
+	return NAND_SUCCESS;
+}
+
+static int enslc_enter_sandisk(struct hw_controller *controller)
+{
+	/* if(flash->new_type != SANDISK_19NM) */
+	/* return NAND_SUCCESS; */
+	/* aml_nand_dbg("flash->new_type:%d", flash->new_type); */
+	controller->cmd_ctrl(controller, NAND_CMD_SANDISK_SLC, NAND_CTRL_CLE);
+
+	return NAND_SUCCESS;
+}
+
+
+/***********************************END************************************/
+
+/*
+  * new nand read retry and enslc configuration.
+  * based on nand type setting para.
+  *
+*/
+int amlnand_set_readretry_slc_para(struct amlnand_chip *aml_chip)
+{
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct read_retry_info *retry_info = &(controller->retry_info);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	int ret = 0;
+
+	if (flash->new_type == 0) {
+		aml_nand_msg("new type equals to zero");
+		return NAND_SUCCESS;
+	}
+
+	switch (flash->new_type) {
+	case HYNIX_26NM_4GB:	/* hynix 26nm 4GB */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 4;
+		retry_info->retry_cnt_lp = 6;
+
+		retry_info->reg_addr_lp[0] = 0xA7; /* not same */
+		retry_info->reg_addr_lp[1] = 0xAD;
+		retry_info->reg_addr_lp[2] = 0xAE;
+		retry_info->reg_addr_lp[3] = 0xAF;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0;
+		retry_info->reg_offs_val_lp[0][0][1] = 0x06;
+		retry_info->reg_offs_val_lp[0][0][2] = 0x0A;
+		retry_info->reg_offs_val_lp[0][0][3] = 0x06;
+
+		retry_info->reg_offs_val_lp[0][1][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][1][1] = -0x03;
+		retry_info->reg_offs_val_lp[0][1][2] = -0x07;
+		retry_info->reg_offs_val_lp[0][1][3] = -0x08;
+
+		retry_info->reg_offs_val_lp[0][2][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][2][1] = -0x06;
+		retry_info->reg_offs_val_lp[0][2][2] = -0x0D;
+		retry_info->reg_offs_val_lp[0][2][3] = -0x0F;
+
+		retry_info->reg_offs_val_lp[0][3][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][3][1] = -0x09; /* not same */
+		retry_info->reg_offs_val_lp[0][3][2] = -0x14;
+		retry_info->reg_offs_val_lp[0][3][3] = -0x17;
+
+		retry_info->reg_offs_val_lp[0][4][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][4][1] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][4][2] = -0x1A;
+		retry_info->reg_offs_val_lp[0][4][3] = -0x1E;
+
+		retry_info->reg_offs_val_lp[0][5][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][5][1] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][5][2] = -0x20;
+		retry_info->reg_offs_val_lp[0][5][3] = -0x25;
+
+		retry_info->init = readretry_init_hynix;
+		retry_info->exit = readretry_set_def_val_hynix;
+		retry_info->handle = readretry_handle_hynix;
+
+		/* slc program */
+		slc_info->flag = 1;
+		slc_info->reg_cnt = 5;
+
+		slc_info->reg_addr[0] = 0xA0; /* not same */
+		slc_info->reg_addr[1] = 0xA1;
+		slc_info->reg_addr[2] = 0xB0;
+		slc_info->reg_addr[3] = 0xB1;
+		slc_info->reg_addr[4] = 0xC9;
+
+		slc_info->reg_offs_val[0] = 0x26; /* not same */
+		slc_info->reg_offs_val[1] = 0x26;
+		slc_info->reg_offs_val[2] = 0x26;
+		slc_info->reg_offs_val[3] = 0x26;
+		slc_info->reg_offs_val[4] = 0x01;
+
+		slc_info->init = enslc_init_hynix;
+		slc_info->enter = enslc_enter_hynix;
+		slc_info->exit = enslc_exit_hynix;
+		slc_info->pagelist = pagelist_hynix256;
+		break;
+
+	case HYNIX_26NM_8GB: /* hynix 26nm 8GB */
+		/* read retry */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 4;
+		retry_info->retry_cnt_lp = 6;
+
+		retry_info->reg_addr_lp[0] = 0xAC;
+		retry_info->reg_addr_lp[1] = 0xAD;
+		retry_info->reg_addr_lp[2] = 0xAE;
+		retry_info->reg_addr_lp[3] = 0xAF;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0;
+		retry_info->reg_offs_val_lp[0][0][1] = 0x06;
+		retry_info->reg_offs_val_lp[0][0][2] = 0x0A;
+		retry_info->reg_offs_val_lp[0][0][3] = 0x06;
+
+		retry_info->reg_offs_val_lp[0][1][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][1][1] = -0x03;
+		retry_info->reg_offs_val_lp[0][1][2] = -0x07;
+		retry_info->reg_offs_val_lp[0][1][3] = -0x08;
+
+		retry_info->reg_offs_val_lp[0][2][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][2][1] = -0x06;
+		retry_info->reg_offs_val_lp[0][2][2] = -0x0D;
+		retry_info->reg_offs_val_lp[0][2][3] = -0x0F;
+
+		retry_info->reg_offs_val_lp[0][3][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][3][1] = -0x0B;
+		retry_info->reg_offs_val_lp[0][3][2] = -0x14;
+		retry_info->reg_offs_val_lp[0][3][3] = -0x17;
+
+		retry_info->reg_offs_val_lp[0][4][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][4][1] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][4][2] = -0x1A;
+		retry_info->reg_offs_val_lp[0][4][3] = -0x1E;
+
+		retry_info->reg_offs_val_lp[0][5][0] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][5][1] = READ_RETRY_ZERO;
+		retry_info->reg_offs_val_lp[0][5][2] = -0x20;
+		retry_info->reg_offs_val_lp[0][5][3] = -0x25;
+
+		retry_info->init = readretry_init_hynix;
+		retry_info->exit = readretry_set_def_val_hynix;
+		retry_info->handle = readretry_handle_hynix;
+
+		/* slc program */
+		slc_info->flag = 1;
+		slc_info->reg_cnt = 5;
+
+		slc_info->reg_addr[0] = 0xA4; /* not same */
+		slc_info->reg_addr[1] = 0xA5;
+		slc_info->reg_addr[2] = 0xB0;
+		slc_info->reg_addr[3] = 0xB1;
+		slc_info->reg_addr[4] = 0xC9;
+
+		slc_info->reg_offs_val[0] = 0x25; /* not same */
+		slc_info->reg_offs_val[1] = 0x25;
+		slc_info->reg_offs_val[2] = 0x25;
+		slc_info->reg_offs_val[3] = 0x25;
+		slc_info->reg_offs_val[4] = 0x01;
+
+		slc_info->init = enslc_init_hynix;
+		slc_info->enter = enslc_enter_hynix;
+		slc_info->exit = enslc_exit_hynix;
+		slc_info->pagelist = pagelist_hynix256;
+
+		break;
+
+	case HYNIX_20NM_4GB: /* hynix 20nm 8GB */
+		/* read retry */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 8;
+		retry_info->retry_cnt_lp = 7;
+
+		retry_info->reg_addr_lp[0] = 0xB0; /* not same */
+		retry_info->reg_addr_lp[1] = 0xB1;
+		retry_info->reg_addr_lp[2] = 0xB2;
+		retry_info->reg_addr_lp[3] = 0xB3;
+		retry_info->reg_addr_lp[4] = 0xB4;
+		retry_info->reg_addr_lp[5] = 0xB5;
+		retry_info->reg_addr_lp[6] = 0xB6;
+		retry_info->reg_addr_lp[7] = 0xB7;
+
+		/* for offset value need read from otp area */
+
+		retry_info->init = readretry_init_hynix;
+		retry_info->exit = readretry_set_def_val_hynix;
+		retry_info->handle = readretry_handle_hynix;
+
+		/* for slc */
+		slc_info->flag = 1;
+		slc_info->reg_cnt = 4;
+
+		slc_info->reg_addr[0] = 0xA0; /* not same */
+		slc_info->reg_addr[1] = 0xA1;
+		slc_info->reg_addr[2] = 0xA7;
+		slc_info->reg_addr[3] = 0xA8;
+
+		slc_info->reg_offs_val[0] = 0x0A; /* not same */
+		slc_info->reg_offs_val[1] = 0x0A;
+		slc_info->reg_offs_val[2] = 0x0A;
+		slc_info->reg_offs_val[3] = 0x0A;
+
+		slc_info->init = enslc_init_hynix;
+		slc_info->enter = enslc_enter_hynix;
+		slc_info->exit = enslc_exit_hynix;
+		slc_info->pagelist = pagelist_hynix256;
+		break;
+
+	case HYNIX_20NM_8GB:	/* hynix 20nm 8GB */
+		/* read retry */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 8;
+		retry_info->retry_cnt_lp = 7;
+
+		retry_info->reg_addr_lp[0] = 0xCC; /* not same */
+		retry_info->reg_addr_lp[1] = 0xBF;
+		retry_info->reg_addr_lp[2] = 0xAA;
+		retry_info->reg_addr_lp[3] = 0xAB;
+		retry_info->reg_addr_lp[4] = 0xCD; /* not same */
+		retry_info->reg_addr_lp[5] = 0xAD;
+		retry_info->reg_addr_lp[6] = 0xAE;
+		retry_info->reg_addr_lp[7] = 0xAF;
+
+		/* for offset value need read from otp area */
+
+		retry_info->init = readretry_init_hynix;
+		retry_info->exit = readretry_set_def_val_hynix;
+		retry_info->handle = readretry_handle_hynix;
+
+		/* for slc */
+		slc_info->flag = 1;
+		slc_info->reg_cnt = 4;
+
+		slc_info->reg_addr[0] = 0xB0; /* not same */
+		slc_info->reg_addr[1] = 0xB1;
+		slc_info->reg_addr[2] = 0xA0;
+		slc_info->reg_addr[3] = 0xA1;
+
+		slc_info->reg_offs_val[0] = 0x0A; /* not same */
+		slc_info->reg_offs_val[1] = 0x0A;
+		slc_info->reg_offs_val[2] = 0x0A;
+		slc_info->reg_offs_val[3] = 0x0A;
+
+		slc_info->init = enslc_init_hynix;
+		slc_info->enter = enslc_enter_hynix;
+		slc_info->exit = enslc_exit_hynix;
+		slc_info->pagelist = pagelist_hynix256;
+		break;
+
+	case HYNIX_1YNM: /* hynix 20nm*/
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 4;
+		retry_info->retry_cnt_lp = 7;
+		retry_info->reg_addr_lp[0] = 0x38; /* not same */
+		retry_info->reg_addr_lp[1] = 0x39;
+		retry_info->reg_addr_lp[2] = 0x3A;
+		retry_info->reg_addr_lp[3] = 0x3B;
+		retry_info->init = readretry_init_hynix;
+		retry_info->exit = readretry_set_def_val_hynix;
+		retry_info->handle = readretry_handle_hynix;
+		slc_info->init = enslc_init_hynix;
+		slc_info->enter = enslc_enter_hynix;
+		slc_info->exit = enslc_exit_hynix;
+		slc_info->pagelist = pagelist_1ynm_hynix256;
+		break;
+	case TOSHIBA_2XNM: /* toshiba 24nm/19nm TOSHIBA_2XNM */
+		/* read retry */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 4;
+		retry_info->retry_cnt_lp = 6;
+
+		retry_info->reg_addr_lp[0] = 0x04;
+		retry_info->reg_addr_lp[1] = 0x05;
+		retry_info->reg_addr_lp[2] = 0x06;
+		retry_info->reg_addr_lp[3] = 0x07;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0;
+		retry_info->reg_offs_val_lp[0][0][1] = 0;
+		retry_info->reg_offs_val_lp[0][0][2] = 0;
+		retry_info->reg_offs_val_lp[0][0][3] = 0;
+
+		retry_info->reg_offs_val_lp[0][1][0] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][1] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][3] = 0x04;
+
+		retry_info->reg_offs_val_lp[0][2][0] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][1] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][2] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[0][3][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][3][1] = 0x78;
+		retry_info->reg_offs_val_lp[0][3][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][3][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[0][4][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][4][1] = 0x74;
+		retry_info->reg_offs_val_lp[0][4][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][4][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[0][5][0] = 0x08;
+		retry_info->reg_offs_val_lp[0][5][1] = 0x08;
+		retry_info->reg_offs_val_lp[0][5][2] = 0x08;
+		retry_info->reg_offs_val_lp[0][5][3] = 0x08;
+
+		retry_info->handle = readretry_handle_toshiba;
+		retry_info->exit = readretry_exit_toshiba;
+		break;
+	case TOSHIBA_A19NM:	/* toshiba 24nm/19nm TOSHIBA_2XNM */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 5;
+		retry_info->retry_cnt_lp = 7;
+		retry_info->reg_addr_lp[0] = 0x04;
+		retry_info->reg_addr_lp[1] = 0x05;
+		retry_info->reg_addr_lp[2] = 0x06;
+		retry_info->reg_addr_lp[3] = 0x07;
+		retry_info->reg_addr_lp[3] = 0x0D;
+		retry_info->reg_offs_val_lp[0][0][0] = 0;
+		retry_info->reg_offs_val_lp[0][0][1] = 0;
+		retry_info->reg_offs_val_lp[0][0][2] = 0;
+		retry_info->reg_offs_val_lp[0][0][3] = 0;
+		retry_info->reg_offs_val_lp[0][0][4] = 0;
+		retry_info->reg_offs_val_lp[0][1][0] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][1] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][3] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][4] = 0x00;
+		retry_info->reg_offs_val_lp[0][2][0] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][1] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][2] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][3] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][4] = 0x00;
+		retry_info->reg_offs_val_lp[0][3][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][3][1] = 0x78;
+		retry_info->reg_offs_val_lp[0][3][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][3][3] = 0x78;
+		retry_info->reg_offs_val_lp[0][3][4] = 0x00;
+		retry_info->reg_offs_val_lp[0][4][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][4][1] = 0x74;
+		retry_info->reg_offs_val_lp[0][4][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][4][3] = 0x74;
+		retry_info->reg_offs_val_lp[0][4][4] = 0x00;
+		retry_info->reg_offs_val_lp[0][5][0] = 0x08;
+		retry_info->reg_offs_val_lp[0][5][1] = 0x08;
+		retry_info->reg_offs_val_lp[0][5][2] = 0x08;
+		retry_info->reg_offs_val_lp[0][5][3] = 0x08;
+		retry_info->reg_offs_val_lp[0][5][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][6][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][6][1] = 0x78;
+		retry_info->reg_offs_val_lp[0][6][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][6][3] = 0x78;
+		retry_info->reg_offs_val_lp[0][6][4] = 0x00;
+		retry_info->handle = readretry_handle_toshiba;
+		retry_info->exit = readretry_exit_toshiba;
+		break;
+	/* toshiba 15nm */
+	case TOSHIBA_15NM:
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 5;
+		retry_info->retry_cnt_lp = 10;
+
+		retry_info->reg_addr_lp[0] = 0x04;
+		retry_info->reg_addr_lp[1] = 0x05;
+		retry_info->reg_addr_lp[2] = 0x06;
+		retry_info->reg_addr_lp[3] = 0x07;
+		retry_info->reg_addr_lp[3] = 0x0D;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0;
+		retry_info->reg_offs_val_lp[0][0][1] = 0;
+		retry_info->reg_offs_val_lp[0][0][2] = 0;
+		retry_info->reg_offs_val_lp[0][0][3] = 0;
+		retry_info->reg_offs_val_lp[0][0][4] = 0;
+
+		retry_info->reg_offs_val_lp[0][1][0] = 0x02;
+		retry_info->reg_offs_val_lp[0][1][1] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][2] = 0x02;
+		retry_info->reg_offs_val_lp[0][1][3] = 0x00;
+		retry_info->reg_offs_val_lp[0][1][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][2][0] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][2][2] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][3] = 0x7c;
+		retry_info->reg_offs_val_lp[0][2][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][3][0] = 0x7a;
+		retry_info->reg_offs_val_lp[0][3][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][3][2] = 0x7a;
+		retry_info->reg_offs_val_lp[0][3][3] = 0x7a;
+		retry_info->reg_offs_val_lp[0][3][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][4][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][4][1] = 0x02;
+		retry_info->reg_offs_val_lp[0][4][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][4][3] = 0x7a;
+		retry_info->reg_offs_val_lp[0][4][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][5][0] = 0x7e;
+		retry_info->reg_offs_val_lp[0][5][1] = 0x04;
+		retry_info->reg_offs_val_lp[0][5][2] = 0x7e;
+		retry_info->reg_offs_val_lp[0][5][3] = 0x7a;
+		retry_info->reg_offs_val_lp[0][5][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][6][0] = 0x76;
+		retry_info->reg_offs_val_lp[0][6][1] = 0x04;
+		retry_info->reg_offs_val_lp[0][6][2] = 0x76;
+		retry_info->reg_offs_val_lp[0][6][3] = 0x78;
+		retry_info->reg_offs_val_lp[0][6][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][7][0] = 0x04;
+		retry_info->reg_offs_val_lp[0][7][1] = 0x04;
+		retry_info->reg_offs_val_lp[0][7][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][7][3] = 0x76;
+		retry_info->reg_offs_val_lp[0][7][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][8][0] = 0x06;
+		retry_info->reg_offs_val_lp[0][8][1] = 0x0a;
+		retry_info->reg_offs_val_lp[0][8][2] = 0x06;
+		retry_info->reg_offs_val_lp[0][8][3] = 0x02;
+		retry_info->reg_offs_val_lp[0][8][4] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][9][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][9][1] = 0x7c;
+		retry_info->reg_offs_val_lp[0][9][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][9][3] = 0x76;
+		retry_info->reg_offs_val_lp[0][9][4] = 0x00;
+
+		retry_info->handle = readretry_handle_toshiba;
+		retry_info->exit = readretry_exit_toshiba;
+		break;
+	case SUMSUNG_2XNM:
+		/* read retry */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 4;
+		retry_info->retry_cnt_lp = 15;
+
+		retry_info->reg_addr_lp[0] = 0xA7;
+		retry_info->reg_addr_lp[1] = 0xA4;
+		retry_info->reg_addr_lp[2] = 0xA5;
+		retry_info->reg_addr_lp[3] = 0xA6;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0;
+		retry_info->reg_offs_val_lp[0][0][1] = 0;
+		retry_info->reg_offs_val_lp[0][0][2] = 0;
+		retry_info->reg_offs_val_lp[0][0][3] = 0;
+
+		retry_info->reg_offs_val_lp[0][1][0] = 0x05;
+		retry_info->reg_offs_val_lp[0][1][1] = 0x0A;
+		retry_info->reg_offs_val_lp[0][1][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][1][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][2][0] = 0x28;
+		retry_info->reg_offs_val_lp[0][2][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][2][2] = 0xEc;
+		retry_info->reg_offs_val_lp[0][2][3] = 0xD8;
+
+		retry_info->reg_offs_val_lp[0][3][0] = 0xED;
+		retry_info->reg_offs_val_lp[0][3][1] = 0xF5;
+		retry_info->reg_offs_val_lp[0][3][2] = 0xED;
+		retry_info->reg_offs_val_lp[0][3][3] = 0xE6;
+
+		retry_info->reg_offs_val_lp[0][4][0] = 0x0A;
+		retry_info->reg_offs_val_lp[0][4][1] = 0x0F;
+		retry_info->reg_offs_val_lp[0][4][2] = 0x05;
+		retry_info->reg_offs_val_lp[0][4][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][5][0] = 0x0F;
+		retry_info->reg_offs_val_lp[0][5][1] = 0x0A;
+		retry_info->reg_offs_val_lp[0][5][2] = 0xFB;
+		retry_info->reg_offs_val_lp[0][5][3] = 0xEC;
+
+		retry_info->reg_offs_val_lp[0][6][0] = 0XE8;
+		retry_info->reg_offs_val_lp[0][6][1] = 0XEF;
+		retry_info->reg_offs_val_lp[0][6][2] = 0XE8;
+		retry_info->reg_offs_val_lp[0][6][3] = 0XDC;
+
+		retry_info->reg_offs_val_lp[0][7][0] = 0xF1;
+		retry_info->reg_offs_val_lp[0][7][1] = 0xFB;
+		retry_info->reg_offs_val_lp[0][7][2] = 0xFE;
+		retry_info->reg_offs_val_lp[0][7][3] = 0xF0;
+
+		retry_info->reg_offs_val_lp[0][8][0] = 0x0A;
+		retry_info->reg_offs_val_lp[0][8][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][8][2] = 0xFB;
+		retry_info->reg_offs_val_lp[0][8][3] = 0xEC;
+
+		retry_info->reg_offs_val_lp[0][9][0] = 0xD0;
+		retry_info->reg_offs_val_lp[0][9][1] = 0xE2;
+		retry_info->reg_offs_val_lp[0][9][2] = 0xD0;
+		retry_info->reg_offs_val_lp[0][9][3] = 0xC2;
+
+		retry_info->reg_offs_val_lp[0][10][0] = 0x14;
+		retry_info->reg_offs_val_lp[0][10][1] = 0x0F;
+		retry_info->reg_offs_val_lp[0][10][2] = 0xFB;
+		retry_info->reg_offs_val_lp[0][10][3] = 0xEC;
+
+		retry_info->reg_offs_val_lp[0][11][0] = 0xE8;
+		retry_info->reg_offs_val_lp[0][11][1] = 0xFB;
+		retry_info->reg_offs_val_lp[0][11][2] = 0xE8;
+		retry_info->reg_offs_val_lp[0][11][3] = 0xDC;
+
+		retry_info->reg_offs_val_lp[0][12][0] = 0X1E;
+		retry_info->reg_offs_val_lp[0][12][1] = 0X14;
+		retry_info->reg_offs_val_lp[0][12][2] = 0XFB;
+		retry_info->reg_offs_val_lp[0][12][3] = 0XEC;
+
+		retry_info->reg_offs_val_lp[0][13][0] = 0xFB;
+		retry_info->reg_offs_val_lp[0][13][1] = 0xFF;
+		retry_info->reg_offs_val_lp[0][13][2] = 0xFB;
+		retry_info->reg_offs_val_lp[0][13][3] = 0xF8;
+
+		retry_info->reg_offs_val_lp[0][14][0] = 0x07;
+		retry_info->reg_offs_val_lp[0][14][1] = 0x0C;
+		retry_info->reg_offs_val_lp[0][14][2] = 0x02;
+		retry_info->reg_offs_val_lp[0][14][3] = 0x00;
+
+		retry_info->handle = readretry_handle_samsung;
+		retry_info->exit = readretry_exit_samsung;
+		break;
+
+	case SANDISK_19NM:
+		/* read retry low page */
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 2;
+		retry_info->retry_cnt_lp = 16;
+
+		retry_info->reg_addr_lp[0] = 0x04;
+		retry_info->reg_addr_lp[1] = 0x07;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0xF0;
+		retry_info->reg_offs_val_lp[0][0][1] = 0xF0;
+
+		retry_info->reg_offs_val_lp[0][1][0] = 0xE0;
+		retry_info->reg_offs_val_lp[0][1][1] = 0xE0;
+
+		retry_info->reg_offs_val_lp[0][2][0] = 0xD0;
+		retry_info->reg_offs_val_lp[0][2][1] = 0xD0;
+
+		retry_info->reg_offs_val_lp[0][3][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][3][1] = 0x10;
+
+		retry_info->reg_offs_val_lp[0][4][0] = 0x20;
+		retry_info->reg_offs_val_lp[0][4][1] = 0x20;
+
+		retry_info->reg_offs_val_lp[0][5][0] = 0x30;
+		retry_info->reg_offs_val_lp[0][5][1] = 0x30;
+
+		retry_info->reg_offs_val_lp[0][6][0] = 0xC0;
+		retry_info->reg_offs_val_lp[0][6][1] = 0xD0;
+
+		retry_info->reg_offs_val_lp[0][7][0] = 0x0;
+		retry_info->reg_offs_val_lp[0][7][1] = 0x10;
+
+		retry_info->reg_offs_val_lp[0][8][0] = 0x0;
+		retry_info->reg_offs_val_lp[0][8][1] = 0x20;
+
+		retry_info->reg_offs_val_lp[0][9][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][9][1] = 0x20;
+
+		retry_info->reg_offs_val_lp[0][10][0] = 0xB0;
+		retry_info->reg_offs_val_lp[0][10][1] = 0xD0;
+
+		retry_info->reg_offs_val_lp[0][11][0] = 0xA0;
+		retry_info->reg_offs_val_lp[0][11][1] = 0xD0;
+
+		retry_info->reg_offs_val_lp[0][12][0] = 0x90;
+		retry_info->reg_offs_val_lp[0][12][1] = 0xD0;
+
+		retry_info->reg_offs_val_lp[0][13][0] = 0xB0;
+		retry_info->reg_offs_val_lp[0][13][1] = 0xC0;
+
+		retry_info->reg_offs_val_lp[0][14][0] = 0xA0;
+		retry_info->reg_offs_val_lp[0][14][1] = 0xC0;
+
+		retry_info->reg_offs_val_lp[0][15][0] = 0x90;
+		retry_info->reg_offs_val_lp[0][15][1] = 0xC0;
+
+		/* read retry up page */
+		retry_info->reg_cnt_up = 2;
+		retry_info->retry_cnt_up = 20;
+
+		retry_info->reg_addr_up[0] = 0x04;
+		retry_info->reg_addr_up[1] = 0x05;
+
+		retry_info->reg_offs_val_up[0][0][0] = 0x0;
+		retry_info->reg_offs_val_up[0][0][1] = 0xF0;
+
+		retry_info->reg_offs_val_up[0][1][0] = 0xF;
+		retry_info->reg_offs_val_up[0][1][1] = 0xE0;
+
+		retry_info->reg_offs_val_up[0][2][0] = 0xF;
+		retry_info->reg_offs_val_up[0][2][1] = 0xD0;
+
+		retry_info->reg_offs_val_up[0][3][0] = 0xE;
+		retry_info->reg_offs_val_up[0][3][1] = 0xE0;
+
+		retry_info->reg_offs_val_up[0][4][0] = 0xE;
+		retry_info->reg_offs_val_up[0][4][1] = 0xD0;
+
+		retry_info->reg_offs_val_up[0][5][0] = 0xD;
+		retry_info->reg_offs_val_up[0][5][1] = 0xF0;
+
+		retry_info->reg_offs_val_up[0][6][0] = 0xD;
+		retry_info->reg_offs_val_up[0][6][1] = 0xE0;
+
+		retry_info->reg_offs_val_up[0][7][0] = 0xD;
+		retry_info->reg_offs_val_up[0][7][1] = 0xD0;
+
+		retry_info->reg_offs_val_up[0][8][0] = 0x1;
+		retry_info->reg_offs_val_up[0][8][1] = 0x10;
+
+		retry_info->reg_offs_val_up[0][9][0] = 0x2;
+		retry_info->reg_offs_val_up[0][9][1] = 0x20;
+
+		retry_info->reg_offs_val_up[0][10][0] = 0x2;
+		retry_info->reg_offs_val_up[0][10][1] = 0x10;
+
+		retry_info->reg_offs_val_up[0][11][0] = 0x3;
+		retry_info->reg_offs_val_up[0][11][1] = 0x20;
+
+		retry_info->reg_offs_val_up[0][12][0] = 0xF;
+		retry_info->reg_offs_val_up[0][12][1] = 0x00;
+
+		retry_info->reg_offs_val_up[0][13][0] = 0xE;
+		retry_info->reg_offs_val_up[0][13][1] = 0xF0;
+
+		retry_info->reg_offs_val_up[0][14][0] = 0xD;
+		retry_info->reg_offs_val_up[0][14][1] = 0xC0;
+
+		retry_info->reg_offs_val_up[0][15][0] = 0xF;
+		retry_info->reg_offs_val_up[0][15][1] = 0xF0;
+
+		retry_info->reg_offs_val_up[0][16][0] = 0x1;
+		retry_info->reg_offs_val_up[0][16][1] = 0x00;
+
+		retry_info->reg_offs_val_up[0][17][0] = 0x20;
+		retry_info->reg_offs_val_up[0][17][1] = 0x00;
+
+		retry_info->reg_offs_val_up[0][18][0] = 0xD;
+		retry_info->reg_offs_val_up[0][18][1] = 0xB0;
+
+		retry_info->reg_offs_val_up[0][19][0] = 0xC;
+		retry_info->reg_offs_val_up[0][19][1] = 0xA0;
+
+		retry_info->init = readretry_init_sandisk;
+		retry_info->handle = readretry_handle_sandisk;
+		retry_info->exit = readretry_exit_sandisk;
+
+		/* slc */
+		slc_info->enter = enslc_enter_sandisk;
+
+		break;
+
+	case SANDISK_A19NM:
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 4;
+		retry_info->retry_cnt_lp = 36;
+		retry_info->retry_stage = 0;
+
+		retry_info->reg_addr_lp[0] = 0x11;
+
+		/* lower page read */
+		retry_info->reg_offs_val_lp[0][0][0] = 0x7c;
+		retry_info->reg_offs_val_lp[0][0][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][0][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][0][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][1][0] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][1][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][1][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][2][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][2][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][2][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][2][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][3][0] = 0x08;
+		retry_info->reg_offs_val_lp[0][3][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][3][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][3][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][4][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][4][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][4][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][4][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][5][0] = 0x7c;
+		retry_info->reg_offs_val_lp[0][5][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][5][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][5][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][6][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][6][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][6][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][6][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][7][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][7][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][7][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][7][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][8][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][8][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][8][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][8][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][9][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][9][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][9][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][9][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][10][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][10][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][10][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][10][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][11][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][11][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][11][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][11][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][12][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][12][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][12][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][12][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][13][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][13][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][13][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][13][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][14][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][14][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][14][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][14][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][15][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][15][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][15][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][15][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][16][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][16][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][16][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][16][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][17][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][17][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][17][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][17][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][18][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][18][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][18][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][18][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][19][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][19][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][19][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][19][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][20][0] = 0x14;
+		retry_info->reg_offs_val_lp[0][20][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][20][2] = 0x08;
+		retry_info->reg_offs_val_lp[0][20][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][21][0] = 0x18;
+		retry_info->reg_offs_val_lp[0][21][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][21][2] = 0x0c;
+		retry_info->reg_offs_val_lp[0][21][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][22][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][22][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][22][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][22][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][23][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][23][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][23][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][23][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][24][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][24][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][24][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][24][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][25][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][25][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][25][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][25][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][26][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][26][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][26][2] = 0x6C;
+		retry_info->reg_offs_val_lp[0][26][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][27][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][27][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][27][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][27][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][28][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][28][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][28][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][28][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][29][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][29][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][29][2] = 0x6c;
+		retry_info->reg_offs_val_lp[0][29][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][30][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][30][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][30][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][30][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][31][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][31][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][31][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][31][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][32][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][32][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][32][2] = 0x6c;
+		retry_info->reg_offs_val_lp[0][32][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][33][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][33][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][33][2] = 0x68;
+		retry_info->reg_offs_val_lp[0][33][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][34][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][34][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][34][2] = 0x6C;
+		retry_info->reg_offs_val_lp[0][34][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][35][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][35][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][35][2] = 0x68;
+		retry_info->reg_offs_val_lp[0][35][3] = 0x00;
+
+		/* upper page read */
+
+		retry_info->reg_offs_val_lp[1][0][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][0][1] = 0x00;
+		retry_info->reg_offs_val_lp[1][0][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][0][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][1][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][1][1] = 0x00;
+		retry_info->reg_offs_val_lp[1][1][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][1][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][2][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][2][1] = 0x00;
+		retry_info->reg_offs_val_lp[1][2][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][2][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][3][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][3][1] = 0x7C;
+		retry_info->reg_offs_val_lp[1][3][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][3][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][4][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][4][1] = 0x7c;
+		retry_info->reg_offs_val_lp[1][4][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][4][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][5][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][5][1] = 0x7c;
+		retry_info->reg_offs_val_lp[1][5][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][5][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][6][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][6][1] = 0x7c;
+		retry_info->reg_offs_val_lp[1][6][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][6][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][7][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][7][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][7][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][7][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][8][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][8][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][8][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][8][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][9][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][9][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][9][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][9][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][10][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][10][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][10][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][10][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][11][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][11][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][11][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][11][3] = 0x6c;
+
+		retry_info->reg_offs_val_lp[1][12][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][12][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][12][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][12][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][13][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][13][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][13][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][13][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][14][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][14][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][14][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][14][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][15][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][15][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][15][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][15][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][16][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][16][1] = 0x08;
+		retry_info->reg_offs_val_lp[1][16][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][16][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][17][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][17][1] = 0x08;
+		retry_info->reg_offs_val_lp[1][17][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][17][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][18][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][18][1] = 0x0C;
+		retry_info->reg_offs_val_lp[1][18][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][18][3] = 0x04;
+
+		retry_info->reg_offs_val_lp[1][19][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][19][1] = 0x0C;
+		retry_info->reg_offs_val_lp[1][19][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][19][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][20][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][20][1] = 0x10;
+		retry_info->reg_offs_val_lp[1][20][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][20][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][21][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][21][1] = 0x14;
+		retry_info->reg_offs_val_lp[1][21][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][21][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][22][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][22][1] = 0x0C;
+		retry_info->reg_offs_val_lp[1][22][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][22][3] = 0x7C;
+
+		retry_info->reg_offs_val_lp[1][23][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][23][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][23][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][23][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][24][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][24][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][24][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][24][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][25][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][25][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][25][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][25][3] = 0x6c;
+
+		retry_info->reg_offs_val_lp[1][26][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][26][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][26][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][26][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][27][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][27][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][27][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][27][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][28][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][28][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][28][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][28][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][29][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][29][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][29][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][29][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][30][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][30][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][30][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][30][3] = 0x6C;
+
+		retry_info->reg_offs_val_lp[1][31][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][31][1] = 0x6C;
+		retry_info->reg_offs_val_lp[1][31][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][31][3] = 0x6C;
+
+		retry_info->reg_offs_val_lp[1][32][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][32][1] = 0x6C;
+		retry_info->reg_offs_val_lp[1][32][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][32][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][33][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][33][1] = 0x6C;
+		retry_info->reg_offs_val_lp[1][33][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][33][3] = 0x64;
+
+		retry_info->reg_offs_val_lp[1][34][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][34][1] = 0x68;
+		retry_info->reg_offs_val_lp[1][34][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][34][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][35][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][35][1] = 0x68;
+		retry_info->reg_offs_val_lp[1][35][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][35][3] = 0x64;
+
+		retry_info->handle = readretry_handle_a19_sandisk;
+		retry_info->exit = readretry_exit_a19_sandisk;
+
+		break;
+	case SANDISK_A19NM_4G:
+		//read retry low page
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 4;
+		retry_info->retry_cnt_lp = 36;
+		retry_info->retry_stage = 0;
+
+		retry_info->reg_addr_lp[0] = 0x11;
+
+	/* lower page read */
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0x7c;
+		retry_info->reg_offs_val_lp[0][0][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][0][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][0][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][1][0] = 0x04;
+		retry_info->reg_offs_val_lp[0][1][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][1][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][1][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][2][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][2][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][2][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][2][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][3][0] = 0x08;
+		retry_info->reg_offs_val_lp[0][3][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][3][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][3][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][4][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][4][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][4][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][4][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][5][0] = 0x7c;
+		retry_info->reg_offs_val_lp[0][5][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][5][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][5][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][6][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][6][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][6][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][6][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][7][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][7][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][7][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][7][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][8][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][8][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][8][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][8][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][9][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][9][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][9][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][9][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][10][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][10][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][10][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][10][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][11][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][11][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][11][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][11][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][12][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][12][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][12][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][12][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][13][0] = 0x00;
+		retry_info->reg_offs_val_lp[0][13][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][13][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][13][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][14][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][14][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][14][2] = 0x7C;
+		retry_info->reg_offs_val_lp[0][14][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][15][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][15][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][15][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][15][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][16][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][16][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][16][2] = 0x00;
+		retry_info->reg_offs_val_lp[0][16][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][17][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][17][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][17][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][17][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][18][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][18][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][18][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][18][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][19][0] = 0x10;
+		retry_info->reg_offs_val_lp[0][19][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][19][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][19][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][20][0] = 0x14;
+		retry_info->reg_offs_val_lp[0][20][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][20][2] = 0x08;
+		retry_info->reg_offs_val_lp[0][20][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][21][0] = 0x18;
+		retry_info->reg_offs_val_lp[0][21][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][21][2] = 0x0c;
+		retry_info->reg_offs_val_lp[0][21][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][22][0] = 0x0C;
+		retry_info->reg_offs_val_lp[0][22][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][22][2] = 0x04;
+		retry_info->reg_offs_val_lp[0][22][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][23][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][23][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][23][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][23][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][24][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][24][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][24][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][24][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][25][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][25][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][25][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][25][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][26][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][26][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][26][2] = 0x6C;
+		retry_info->reg_offs_val_lp[0][26][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][27][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][27][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][27][2] = 0x78;
+		retry_info->reg_offs_val_lp[0][27][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][28][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][28][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][28][2] = 0x74;
+		retry_info->reg_offs_val_lp[0][28][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][29][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][29][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][29][2] = 0x6c;
+		retry_info->reg_offs_val_lp[0][29][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][30][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][30][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][30][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][30][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][31][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][31][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][31][2] = 0x70;
+		retry_info->reg_offs_val_lp[0][31][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][32][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][32][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][32][2] = 0x6c;
+		retry_info->reg_offs_val_lp[0][32][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][33][0] = 0x78;
+		retry_info->reg_offs_val_lp[0][33][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][33][2] = 0x68;
+		retry_info->reg_offs_val_lp[0][33][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][34][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][34][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][34][2] = 0x6C;
+		retry_info->reg_offs_val_lp[0][34][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[0][35][0] = 0x74;
+		retry_info->reg_offs_val_lp[0][35][1] = 0x00;
+		retry_info->reg_offs_val_lp[0][35][2] = 0x68;
+		retry_info->reg_offs_val_lp[0][35][3] = 0x00;
+		/* upper page read */
+
+		retry_info->reg_offs_val_lp[1][0][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][0][1] = 0x00;
+		retry_info->reg_offs_val_lp[1][0][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][0][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][1][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][1][1] = 0x00;
+		retry_info->reg_offs_val_lp[1][1][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][1][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][2][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][2][1] = 0x00;
+		retry_info->reg_offs_val_lp[1][2][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][2][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][3][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][3][1] = 0x7C;
+		retry_info->reg_offs_val_lp[1][3][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][3][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][4][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][4][1] = 0x7c;
+		retry_info->reg_offs_val_lp[1][4][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][4][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][5][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][5][1] = 0x7c;
+		retry_info->reg_offs_val_lp[1][5][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][5][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][6][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][6][1] = 0x7c;
+		retry_info->reg_offs_val_lp[1][6][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][6][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][7][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][7][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][7][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][7][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][8][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][8][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][8][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][8][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][9][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][9][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][9][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][9][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][10][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][10][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][10][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][10][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][11][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][11][1] = 0x78;
+		retry_info->reg_offs_val_lp[1][11][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][11][3] = 0x6c;
+
+		retry_info->reg_offs_val_lp[1][12][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][12][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][12][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][12][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][13][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][13][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][13][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][13][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][14][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][14][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][14][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][14][3] = 0x78;
+
+		retry_info->reg_offs_val_lp[1][15][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][15][1] = 0x04;
+		retry_info->reg_offs_val_lp[1][15][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][15][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][16][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][16][1] = 0x08;
+		retry_info->reg_offs_val_lp[1][16][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][16][3] = 0x7c;
+
+		retry_info->reg_offs_val_lp[1][17][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][17][1] = 0x08;
+		retry_info->reg_offs_val_lp[1][17][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][17][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][18][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][18][1] = 0x0C;
+		retry_info->reg_offs_val_lp[1][18][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][18][3] = 0x04;
+
+		retry_info->reg_offs_val_lp[1][19][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][19][1] = 0x0C;
+		retry_info->reg_offs_val_lp[1][19][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][19][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][20][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][20][1] = 0x10;
+		retry_info->reg_offs_val_lp[1][20][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][20][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][21][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][21][1] = 0x14;
+		retry_info->reg_offs_val_lp[1][21][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][21][3] = 0x00;
+
+		retry_info->reg_offs_val_lp[1][22][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][22][1] = 0x0C;
+		retry_info->reg_offs_val_lp[1][22][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][22][3] = 0x7C;
+
+		retry_info->reg_offs_val_lp[1][23][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][23][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][23][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][23][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][24][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][24][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][24][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][24][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][25][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][25][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][25][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][25][3] = 0x6c;
+
+		retry_info->reg_offs_val_lp[1][26][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][26][1] = 0x74;
+		retry_info->reg_offs_val_lp[1][26][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][26][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][27][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][27][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][27][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][27][3] = 0x74;
+
+		retry_info->reg_offs_val_lp[1][28][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][28][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][28][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][28][3] = 0x70;
+
+		retry_info->reg_offs_val_lp[1][29][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][29][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][29][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][29][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][30][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][30][1] = 0x70;
+		retry_info->reg_offs_val_lp[1][30][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][30][3] = 0x6C;
+
+		retry_info->reg_offs_val_lp[1][31][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][31][1] = 0x6C;
+		retry_info->reg_offs_val_lp[1][31][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][31][3] = 0x6C;
+
+		retry_info->reg_offs_val_lp[1][32][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][32][1] = 0x6C;
+		retry_info->reg_offs_val_lp[1][32][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][32][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][33][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][33][1] = 0x6C;
+		retry_info->reg_offs_val_lp[1][33][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][33][3] = 0x64;
+
+		retry_info->reg_offs_val_lp[1][34][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][34][1] = 0x68;
+		retry_info->reg_offs_val_lp[1][34][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][34][3] = 0x68;
+
+		retry_info->reg_offs_val_lp[1][35][0] = 0x00;
+		retry_info->reg_offs_val_lp[1][35][1] = 0x68;
+		retry_info->reg_offs_val_lp[1][35][2] = 0x00;
+		retry_info->reg_offs_val_lp[1][35][3] = 0x64;
+		retry_info->handle = readretry_handle_a19_sandisk;
+		retry_info->exit = readretry_exit_a19_sandisk;
+
+		/* slc */
+		/* slc_info->enter= enslc_enter_sandisk; */
+
+		break;
+	case MICRON_20NM:
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 1;
+		retry_info->retry_cnt_lp = 7;
+
+		retry_info->reg_addr_lp[0] = 0x89;
+
+		retry_info->reg_def_val[0][0] = 0;
+		retry_info->reg_def_val[0][1] = 0;
+		retry_info->reg_def_val[0][2] = 0;
+		retry_info->reg_def_val[0][3] = 0;
+		retry_info->reg_def_val[0][4] = 0;
+		retry_info->reg_def_val[0][5] = 0;
+		retry_info->reg_def_val[0][6] = 0;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0x1;
+		retry_info->reg_offs_val_lp[0][1][0] = 0x2;
+		retry_info->reg_offs_val_lp[0][2][0] = 0x3;
+		retry_info->reg_offs_val_lp[0][3][0] = 0x4;
+		retry_info->reg_offs_val_lp[0][4][0] = 0x5;
+		retry_info->reg_offs_val_lp[0][5][0] = 0x6;
+		retry_info->reg_offs_val_lp[0][6][0] = 0x7;
+
+		retry_info->handle = readretry_handle_micron;
+		retry_info->exit = readretry_exit_micron;
+		break;
+	case INTEL_20NM:
+		retry_info->flag = 1;
+		retry_info->reg_cnt_lp = 2;
+		retry_info->retry_cnt_lp = 7;
+
+		retry_info->reg_addr_lp[0] = 0x89;
+		retry_info->reg_addr_lp[0] = 0x93;
+
+		retry_info->reg_def_val[0][0] = 0;
+		retry_info->reg_def_val[0][1] = 0;
+		retry_info->reg_def_val[0][2] = 0;
+		retry_info->reg_def_val[0][3] = 0;
+		retry_info->reg_def_val[0][4] = 0;
+		retry_info->reg_def_val[0][5] = 0;
+		retry_info->reg_def_val[0][6] = 0;
+
+		retry_info->reg_offs_val_lp[0][0][0] = 0x1;
+		retry_info->reg_offs_val_lp[0][1][0] = 0x2;
+		retry_info->reg_offs_val_lp[0][2][0] = 0x3;
+		retry_info->reg_offs_val_lp[0][3][0] = 0x0;
+		retry_info->reg_offs_val_lp[0][4][0] = 0x1;
+		retry_info->reg_offs_val_lp[0][5][0] = 0x2;
+		retry_info->reg_offs_val_lp[0][6][0] = 0x3;
+
+		retry_info->handle = readretry_handle_intel;
+		retry_info->exit = readretry_exit_intel;
+		break;
+	default:
+		aml_nand_msg("detect flash->new_type(%d) not support!",
+			flash->new_type);
+		return -NAND_FAILED;
+	}
+
+	if (flash->new_type == SANDISK_19NM) {
+		ret = retry_info->init(controller);
+		if (ret) {
+			aml_nand_msg("sandisk readretry init failed");
+			return -NAND_FAILED;
+		}
+	}
+
+	if ((flash->new_type) && (flash->new_type < 10)) {
+		ret = slc_info->init(controller);
+		if (ret) {
+			aml_nand_msg("hynix nand get slc default value failed");
+			return -NAND_FAILED;
+		}
+		ret =  retry_info->init(controller);
+		if (ret) {
+			aml_nand_msg("hynix nand readretry init failed");
+			return -NAND_FAILED;
+		}
+	}
+
+	return NAND_SUCCESS;
+}
+
diff --git a/drivers/nand/phy/phydev.c b/drivers/nand/phy/phydev.c
new file mode 100644
index 0000000..13faf31
--- /dev/null
+++ b/drivers/nand/phy/phydev.c
@@ -0,0 +1,1792 @@
+/*****************************************************************
+**
+**  Copyright (C) 2012 Amlogic,Inc.  All rights reserved
+**
+**        Filename : phydev.c
+**        Revision : 1.001
+**        Author: Benjamin Zhao
+**        Description:
+**		1) Phydev basic operation based on phydev
+**			contains read/write/erase/block_isbad/block_markbad.
+**		2) Get/release chip function ensure only one entry to nand chip;
+**
+*****************************************************************/
+#include "../include/phynand.h"
+
+#ifdef AML_NAND_UBOOT
+	//extern struct amlnf_partition amlnf_partitions;
+	extern struct amlnf_partition * amlnf_partitions;
+#endif
+
+#define DBG_WRITE_VERIFY	(0)
+
+#if (DBG_WRITE_VERIFY)
+u8 * glb_verify_buffer = NULL;
+#endif
+
+enum chip_state_t get_chip_state(struct amlnand_chip *aml_chip)
+{
+	return aml_chip->state;
+}
+
+void set_chip_state(struct amlnand_chip *aml_chip, enum chip_state_t state)
+{
+	aml_chip->state = state;
+}
+
+static u32 amlnand_slc_addr_trs(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct en_slc_info *slc_info = &(controller->slc_info);
+	int real_page_per_blk, page_per_blk, blk_num, blk_num_in_dev, page_num;
+	/* u64 addr, readlen = 0; */
+	u32 page_addr = 0;
+	u32 real_erase_size, real_erase_shift, w_size_shift, e_size_shift;
+	int total_pages_in_dev;
+
+	real_erase_size = (phydev->erasesize << 1);
+	real_erase_shift = ffs(real_erase_size) - 1;
+	w_size_shift = phydev->writesize_shift;
+	e_size_shift = phydev->erasesize_shift;
+
+	real_page_per_blk = (1 << ((ffs(real_erase_size) - 1) - w_size_shift));
+	page_per_blk = (1 << (e_size_shift - w_size_shift));
+
+	blk_num = phydev->offset >> real_erase_shift;
+	blk_num_in_dev = devops->addr >> e_size_shift;
+	blk_num += blk_num_in_dev;
+
+	total_pages_in_dev = blk_num_in_dev * page_per_blk;
+	page_num = ((devops->addr >> w_size_shift) - total_pages_in_dev);
+
+	if ((flash->new_type > 0) && (flash->new_type < 10))
+		page_addr = blk_num * real_page_per_blk +
+			slc_info->pagelist[page_num];
+	else if (flash->new_type == SANDISK_19NM)
+		page_addr = blk_num * real_page_per_blk + (page_num << 1);
+	else { /* not surpport slc nand */
+		page_addr =
+		(int)((phydev->offset + devops->addr) >> w_size_shift);
+		aml_nand_msg("nand not surpport slc ");
+	}
+
+#if 0
+	aml_nand_dbg(" devops->addr =%llx %d", devops->addr, devops->addr);
+	aml_nand_dbg("real_erase_size =%x", real_erase_size);
+	aml_nand_dbg("real_page_per_blk =%d", real_page_per_blk);
+	aml_nand_dbg("page_per_blk =%d", page_per_blk);
+	aml_nand_dbg("blk_num =%d", blk_num);
+	aml_nand_dbg("blk_num_in_dev =%d", blk_num_in_dev);
+	aml_nand_dbg("page_num =%d", page_num);
+	aml_nand_dbg("page_addr =%d", page_addr);
+#endif
+
+	return page_addr;
+}
+
+/*
+ * fixme, pls use DBG_WRITE_VERIFY instead(20150918) before fix! yyh.
+ */
+static void nand_write_verify(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	/* struct hw_controller *controller = &(aml_chip->controller); */
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	int ret = 0;
+	u8 *verify_buf = NULL;
+
+	verify_buf =  aml_nand_malloc(2 * phydev->writesize);
+	if (!verify_buf) {
+		aml_nand_msg("malloc failed for nand_read_verify");
+		return;
+	}
+
+	ops_para->data_buf = verify_buf;
+	ret = operation->read_page(aml_chip);
+	if ((ops_para->ecc_err) || (ret < 0))
+		aml_nand_msg("nand phy read failed at devops->addr : %llx",
+			devops->addr);
+
+	if (memcmp(verify_buf, devops->datbuf, phydev->writesize))
+		aml_nand_msg("nand write verify failed");
+
+	kfree(verify_buf);
+
+	return;
+}
+
+/*
+*read data case:
+*only data read function, if none ecc mode, buf should be data+oob
+* operation type as below: oob_mode data_buf oob_buf ooblen
+*1) read oob hw ecc mode 0 NULL  available available
+*2) read data and oob hw ecc mode 0 available available	available
+*3) read data and oob sw ecc mode 1 available available	0
+*/
+static int nand_read(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr, readlen = 0, len = 0;
+	int ret = 0;
+
+	if ((devops->addr + devops->len) >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx len:%llx pdev->offset:%llx pdev->size:%llx",
+			devops->addr,
+			devops->len,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	if ((devops->len == 0) && (devops->ooblen == 0)) {
+		aml_nand_msg("len equal zero here");
+		return NAND_SUCCESS;
+	}
+
+	amlnand_get_device(aml_chip, CHIP_READING);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+
+	if (devops->len == 0) {
+		len = phydev->writesize;
+		ops_para->ooblen = devops->ooblen;
+	} else {
+		len = devops->len;
+		ops_para->ooblen = devops->ooblen;
+	}
+
+	addr = phydev->offset + devops->addr;
+	ops_para->data_buf = devops->datbuf;
+	ops_para->option = phydev->option;
+	ops_para->oob_buf = devops->oobbuf;
+
+	/* aml_nand_dbg("len =%llx",len); */
+	if (devops->mode == NAND_SOFT_ECC)
+		ops_para->option |= DEV_ECC_SOFT_MODE;
+
+	while (1) {
+		if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+			ops_para->chipnr =
+				(addr >> phydev->erasesize)
+				% controller->chip_num;
+			controller->select_chip(controller, ops_para->chipnr);
+			aml_nand_dbg("ops_para->chipnr  =%d", ops_para->chipnr);
+			aml_nand_dbg("DEV_SERIAL_CHIP_MODE");
+		}
+
+		if (ops_para->option & DEV_SLC_MODE)
+			ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+		else
+			ops_para->page_addr =
+				(int)(addr >> phydev->writesize_shift);
+
+		//printf("%s() page %x\n", __func__, ops_para->page_addr);
+		ret = operation->read_page(aml_chip);
+		if ((ops_para->ecc_err) || (ret < 0)) {
+			aml_nand_msg("phy read failed at devops->addr: %llx",
+				devops->addr);
+			break;
+		}
+
+		addr += phydev->writesize;
+
+		ops_para->data_buf += phydev->writesize;
+		readlen += phydev->writesize;
+
+		/* aml_nand_dbg("readlen =%llx",readlen); */
+		if (readlen >= len)
+			break;
+	}
+
+	devops->retlen = readlen;
+
+	amlnand_release_device(aml_chip);
+
+	if (!ret) {
+		if (ops_para->ecc_err)
+			ret = NAND_ECC_FAILURE;
+		else if (ops_para->bit_flip)
+			ret = -EUCLEAN; /* 117 */
+	}
+
+	return ret;
+}
+
+#if (DBG_WRITE_VERIFY)
+static int _nand_write(struct amlnand_phydev *phydev)
+#else
+static int nand_write(struct amlnand_phydev *phydev)
+#endif
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr, writelen = 0, len = 0;
+	int ret = 0;
+
+	PHYDEV_LINE
+	if ((devops->addr + devops->len) >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx len:%llx pdev->offset:%llx pdev->size:%llx",
+			devops->addr,
+			devops->len,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	if ((devops->len == 0) && (devops->ooblen == 0)) {
+		aml_nand_msg("len equal zero here");
+		return NAND_SUCCESS;
+	}
+
+#ifndef AML_NAND_UBOOT
+	if (phydev->option & NAND_SHUT_DOWN) {
+		aml_nand_msg("nand is in shut dowm protect mod");
+		return NAND_SUCCESS;
+	}
+#endif
+
+	amlnand_get_device(aml_chip, CHIP_WRITING);
+
+	len = devops->len;
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	ops_para->option = phydev->option;	//multi-plane is set
+	ops_para->data_buf = devops->datbuf;
+	ops_para->oob_buf = devops->oobbuf;
+	ops_para->ooblen = devops->ooblen;
+	if (devops->mode == NAND_SOFT_ECC)
+		ops_para->option |= DEV_ECC_SOFT_MODE;
+
+	while (1) {
+		if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+			ops_para->chipnr =
+				(addr>>phydev->erasesize_shift) %
+				controller->chip_num;
+			controller->select_chip(controller, ops_para->chipnr);
+			aml_nand_dbg("DEV_SERIAL_CHIP_MODE");
+		}
+
+		if (ops_para->option & DEV_SLC_MODE)
+			ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+		else
+			ops_para->page_addr =
+				(int)(addr >> phydev->writesize_shift);
+		//printf("%s() page %x\n", __func__, ops_para->page_addr);
+		ret = operation->write_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("Write fail devops->addr:%llx,addr:%llx",
+				devops->addr,
+				addr);
+			break;
+		}
+
+		addr += phydev->writesize;
+		ops_para->data_buf += phydev->writesize;
+		writelen += phydev->writesize;
+		if (writelen >= len)
+			break;
+	}
+
+	devops->retlen = writelen;
+
+	if (aml_chip->debug_flag & NAND_WRITE_VERIFY)
+		nand_write_verify(phydev);
+
+	amlnand_release_device(aml_chip);
+
+	return ret;
+}
+
+#if (DBG_WRITE_VERIFY)
+static int nand_write(struct amlnand_phydev *phydev)
+{
+	int ret;
+	u8 * tmp;
+	struct phydev_ops *devops = &(phydev->ops);
+
+	ret = _nand_write(phydev);
+	tmp = devops->datbuf;
+	devops->datbuf = glb_verify_buffer;
+	nand_read(phydev);
+
+	devops->datbuf = tmp;
+	printf(".");
+	if (memcmp(tmp, glb_verify_buffer, phydev->writesize)) {
+		aml_nand_msg("nand write verify failed");
+		while (1) ;
+	}
+	return ret;
+}
+#endif
+
+int nand_erase(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr = 0, eraselen = 0;
+	int ret = 0;
+
+	if ((devops->addr + devops->len) >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx len:%llx pdev->offset:%llx pdev->size:%llx",
+			devops->addr,
+			devops->len,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	if (devops->len == 0) {
+		aml_nand_msg("len equal zero here");
+		return NAND_SUCCESS;
+	}
+
+	if (phydev->option & NAND_SHUT_DOWN) {
+		aml_nand_msg("nand is in shut dowm protect mod");
+		return NAND_SUCCESS;
+	}
+
+	amlnand_get_device(aml_chip, CHIP_ERASING);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	ops_para->option = phydev->option;
+
+	while (1) {
+		if (ops_para->option & DEV_SLC_MODE)
+			ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+		else
+			ops_para->page_addr =
+				(int)(addr >> phydev->writesize_shift);
+
+		if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+			ops_para->chipnr =
+				(addr>>phydev->erasesize)%controller->chip_num;
+			controller->select_chip(controller, ops_para->chipnr);
+		}
+
+		ret = operation->erase_block(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand erase fail at addr :%x ",
+				ops_para->page_addr);
+			break;
+		}
+
+		addr += phydev->erasesize;
+		eraselen += phydev->erasesize;
+
+		if (eraselen >= devops->len)
+			break;
+	}
+
+	devops->retlen = eraselen;
+
+	amlnand_release_device(aml_chip);
+
+	return ret;
+}
+
+static int nand_block_isbad(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	/* struct nand_flash *flash = &(aml_chip->flash); */
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr = 0;
+	int ret = 0;
+
+	if (devops->addr >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx phydev->offset:%llx phydev->size:%llx",
+				devops->addr, phydev->offset, phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+#ifndef AML_NAND_UBOOT
+	if (phydev->option & NAND_SHUT_DOWN) {
+		aml_nand_msg("nand is in shut dowm protect mod");
+		return NAND_SUCCESS;
+	}
+#endif
+	amlnand_get_device(aml_chip, CHIP_READING);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	ops_para->option = phydev->option;
+	if (ops_para->option & DEV_SLC_MODE)
+		ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+	else
+		ops_para->page_addr = (int)(addr >> phydev->writesize_shift);
+
+	if ((ops_para->option & DEV_SERIAL_CHIP_MODE))
+		ops_para->chipnr =
+			(addr >> phydev->erasesize_shift)
+			% controller->chip_num;
+
+	ret = operation->block_isbad(aml_chip);
+	if (ret < 0)
+		aml_nand_msg("fail page_addr:ret=%d, %x len:%llx",
+			ret,
+			ops_para->page_addr,
+			devops->len);
+
+	amlnand_release_device(aml_chip);
+
+	return ret;
+}
+
+static int nand_block_markbad(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr = 0;
+	int ret = 0;
+
+	if (devops->addr >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx phydev->offset:%llx phydev->size:%llx",
+			devops->addr,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+#ifndef AML_NAND_UBOOT
+	if (phydev->option & NAND_SHUT_DOWN) {
+		aml_nand_msg("nand is in shut dowm protect mod");
+		return NAND_SUCCESS;
+	}
+#endif
+	amlnand_get_device(aml_chip, CHIP_READING);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	ops_para->option = phydev->option;
+	/* ops_para->page_addr = (int)(addr >> phydev->writesize_shift); */
+	if (ops_para->option & DEV_SLC_MODE)
+		ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+	else
+		ops_para->page_addr = (int)(addr >> phydev->writesize_shift);
+
+	if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+		ops_para->chipnr =
+			(addr>>phydev->erasesize)%controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+	}
+
+	ret = operation->block_markbad(aml_chip);
+	if (ret < 0)
+		aml_nand_msg("nand mark bad failed at page %d",
+			ops_para->page_addr);
+
+	amlnand_release_device(aml_chip);
+
+	return ret;
+}
+static int block_modifybbt(struct amlnand_phydev *phydev, int value)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr = 0;
+	int ret = 0;
+
+	if (devops->addr >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx phydev->offset:%llx phydev->size:%llx",
+			devops->addr,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	amlnand_get_device(aml_chip, CHIP_READING);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	aml_nand_msg("addr = %lld", addr);
+	ops_para->option = phydev->option;
+	/* ops_para->page_addr = (int)(addr >> phydev->writesize_shift); */
+	if (ops_para->option & DEV_SLC_MODE)
+		ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+	else
+		ops_para->page_addr = (int)(addr >> phydev->writesize_shift);
+
+	if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+		ops_para->chipnr =
+			(addr>>phydev->erasesize)%controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+	}
+
+	ret = operation->blk_modify_bbt_chip_op(aml_chip, value);
+	if (ret < 0)
+		aml_nand_msg("nand mark bad failed at page %d",
+			ops_para->page_addr);
+
+	amlnand_release_device(aml_chip);
+
+	return ret;
+}
+
+static int update_bbt(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr = 0;
+	int ret = 0;
+
+	if (devops->addr >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx phydev->offset:%llx phydev->size:%llx",
+			devops->addr,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	amlnand_get_device(aml_chip, CHIP_READING);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	ops_para->option = phydev->option;
+	/* ops_para->page_addr = (int)(addr >> phydev->writesize_shift); */
+	if (ops_para->option & DEV_SLC_MODE)
+		ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+	else
+		ops_para->page_addr = (int)(addr >> phydev->writesize_shift);
+
+	if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+		ops_para->chipnr =
+			(addr>>phydev->erasesize)%controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+	}
+
+	ret = operation->update_bbt_chip_op(aml_chip);
+	if (ret < 0)
+		aml_nand_msg("nand mark bad failed at page %d",
+			ops_para->page_addr);
+
+	amlnand_release_device(aml_chip);
+
+	return ret;
+}
+
+static int nand_test_block(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct phydev_ops *devops = &(phydev->ops);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	u64 addr = 0;
+	int ret = 0;
+	u32 tmp_addr = 0;
+
+	if (devops->addr >  phydev->size) {
+		aml_nand_msg("out of space and addr:");
+		aml_nand_msg("%llx phydev->offset:%llx phydev->size:%llx",
+			devops->addr,
+			phydev->offset,
+			phydev->size);
+		return -NAND_ARGUMENT_FAILURE;
+	}
+
+	if (phydev->option & NAND_SHUT_DOWN) {
+		aml_nand_msg("nand is in shut dowm protect mod");
+		return NAND_SUCCESS;
+	}
+
+	amlnand_get_device(aml_chip, CHIP_READING);
+
+	/* clear ops_para here */
+	memset(ops_para, 0, sizeof(struct chip_ops_para));
+	addr = phydev->offset + devops->addr;
+	aml_nand_msg("addr = %lld", addr);
+	ops_para->option = phydev->option;
+	/* ops_para->page_addr = (int)(addr >> phydev->writesize_shift); */
+	if (ops_para->option & DEV_SLC_MODE)
+		ops_para->page_addr = amlnand_slc_addr_trs(phydev);
+	else
+		ops_para->page_addr = (int)(addr >> phydev->writesize_shift);
+
+	if (ops_para->option & DEV_SERIAL_CHIP_MODE) {
+		ops_para->chipnr =
+			(addr>>phydev->erasesize)%controller->chip_num;
+		controller->select_chip(controller, ops_para->chipnr);
+	}
+
+	tmp_addr = ops_para->page_addr;
+	ops_para->data_buf = devops->datbuf;
+	ret = operation->erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand erase_block failed at page %d",
+			ops_para->page_addr);
+		goto exit;
+	}
+
+	ops_para->page_addr = tmp_addr;
+	do {
+		ret = operation->write_page(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("nand erase_block failed at page %d",
+			ops_para->page_addr);
+			goto exit;
+		}
+		ops_para->page_addr += phydev->writesize;
+	} while (ops_para->page_addr >= devops->len);
+
+	ops_para->page_addr = tmp_addr;
+	do {
+		ret = operation->read_page(aml_chip);
+		if ((ops_para->ecc_err) || (ret < 0)) {
+			aml_nand_msg("phy read failed at devops->addr: %llx",
+				devops->addr);
+			goto exit;
+		}
+		ops_para->page_addr += phydev->writesize;
+	} while (ops_para->page_addr >= devops->len);
+
+	ops_para->page_addr = tmp_addr;
+	ret = operation->erase_block(aml_chip);
+	if (ret < 0) {
+		aml_nand_msg("nand erase_block failed at page %d",
+		ops_para->page_addr);
+		goto exit;
+	}
+	aml_nand_msg("nand test OK ");
+
+exit:
+	amlnand_release_device(aml_chip);
+	return ret;
+
+}
+
+
+
+int phydev_init_erase(struct amlnand_chip *aml_chip)
+{
+	int ret =0, percent=0,percent_complete = -1;
+	//uint64_t addr, off, size, chipsize, erase_addr, erase_len, erase_off;
+	uint64_t erase_addr, erase_len, erase_off;
+	struct amlnand_phydev *phydev = NULL;
+	struct phydev_ops  *devops = NULL;
+	if (aml_chip->init_flag == NAND_BOOT_ERASE_PROTECT_CACHE) {
+
+		list_for_each_entry(phydev,&nphy_dev_list,list){
+
+			if ((!strncmp((char*)phydev->name, NAND_CODE_NAME, strlen((const char*)NAND_CODE_NAME))) \
+				||(!strncmp((char*)phydev->name, NAND_DATA_NAME, strlen((const char*)NAND_DATA_NAME)))){
+					devops =  &phydev->ops;
+					erase_addr =  0;
+					erase_off = erase_addr;
+					erase_len = phydev->size;
+					percent=0;percent_complete = -1;
+
+					for (; erase_addr <erase_off + erase_len; erase_addr +=  phydev->erasesize) {
+
+						memset(devops, 0x0, sizeof(struct phydev_ops));
+						devops->addr = erase_addr;
+						devops->len = phydev->erasesize;
+						devops->mode = NAND_HW_ECC;
+
+						 ret = phydev->block_isbad(phydev);
+						if (ret > 0) {
+							printf("\rSkipping bad block at 0x%08llx\n", erase_addr);
+							continue;
+
+						} else if (ret < 0) {
+							printf("\n:AMLNAND get bad block failed: ret=%d at addr=%llx\n",ret, erase_addr);
+							return -1;
+						}
+
+						ret = nand_erase(phydev);
+						if (ret < 0) {
+							printf("\nAMLNAND Erase failure: %d %llx\n", ret, erase_addr);
+							ret = phydev->block_markbad(phydev);
+							if (ret < 0)
+								printf("AMLNAND bad block mark failed: %llx\n", erase_addr);
+							continue;
+						}
+
+						percent = (erase_addr * 100) / (erase_off + erase_len);
+						if ((percent != percent_complete) && ((percent %10) == 0)) {
+								percent_complete = percent;
+								aml_nand_msg("nand erasing %d %% --%d %% complete",percent,percent+10);
+						}
+					}
+			}
+		}
+	}
+
+	return ret;
+}
+
+void amldev_dumpinfo(struct amlnand_phydev *phydev)
+{
+	/* flash info */
+	aml_nand_msg("device info");
+	aml_nand_msg("name:%s, offset:%llx, size:%llx, option:%x",
+		phydev->name,
+		phydev->offset,
+		phydev->size,
+		phydev->option);
+	aml_nand_msg("esize:%x,wsize:%x,oob:%x,esize_shift:%x,wsize_shift:%d",
+		phydev->erasesize,
+		phydev->writesize,
+		phydev->oobavail,
+		phydev->erasesize_shift,
+		phydev->writesize_shift);
+}
+
+#ifndef AML_NAND_UBOOT
+ssize_t nand_page_read(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct amlnand_phydev *phydev = NULL;
+	struct phydev_ops  *devops = NULL;
+
+	u8 *datbuf, *p;
+	u64 offset , write_len;
+	loff_t off;
+	size_t ret;
+	int i;
+
+	phydev = container_of(class, struct amlnand_phydev, cls);
+	devops = &(phydev->ops);
+
+	ret = sscanf(buf, "%llx", &off);
+
+	datbuf = kmalloc(2*phydev->writesize, GFP_KERNEL);
+	if (!datbuf) {
+		aml_nand_msg("No memory for page buffer");
+		goto exit_erro;
+	}
+	p = datbuf;
+
+	memset(datbuf, 0x0, 2*phydev->writesize);
+	aml_nand_dbg("phydev->name =%s", phydev->name);
+	aml_nand_dbg("read page");
+
+	offset = 0;
+	write_len = phydev->writesize;
+
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = datbuf;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+	do {
+		if ((((u32)devops->addr % phydev->erasesize)) == 0) {
+			aml_nand_dbg("devops->addr = %llx", devops->addr);
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				aml_nand_dbg("\rSkipping bad block at %llx\n",
+					devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				aml_nand_dbg("get bad blk fail:");
+				aml_nand_dbg("ret=%d addr=%llx\n",
+					ret,
+					devops->addr);
+				return -1;
+			}
+		}
+
+		ret = phydev->read(phydev);
+		if (ret < 0)
+			aml_nand_dbg("nand read failed at %llx", devops->addr);
+
+		devops->addr +=  phydev->writesize;
+		datbuf += phydev->writesize;
+	} while (devops->addr < (offset + write_len));
+
+	i = 512;
+	aml_nand_dbg("read page");
+	while (i--) {
+		aml_nand_msg("\t%02x %02x %02x %02x %02x %02x %02x %02x",
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+		aml_nand_msg("\t%02x %02x %02x %02x %02x %02x %02x %02x",
+			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		p += 16;
+	}
+
+	aml_nand_dbg("read page complete");
+
+exit_erro:
+	kfree(datbuf);
+
+	return count;
+}
+
+void amlchip_resume(struct amlnand_phydev *phydev)
+{
+	struct amlnand_chip *aml_chip = (struct amlnand_chip *)phydev->priv;
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	u8 onfi_features[4] = {0};
+	int i = 0, ret = 0;
+
+	if (!strncmp((char *)phydev->name,
+		NAND_CODE_NAME,
+		strlen((const char *)NAND_CODE_NAME))) {
+		nand_get_chip(aml_chip);
+		for (i = 0; i < controller->chip_num; i++) {
+			ret = controller->select_chip(controller, i);
+			if (ret < 0)
+				aml_nand_msg("select chip %d failed", i);
+
+			ret = nand_reset(aml_chip, i);
+			if (ret < 0)
+				aml_nand_dbg("reset failed %d", i);
+		}
+
+		if (controller->onfi_mode) {
+			operation->set_onfi_para(aml_chip,
+				(u8 *)&(controller->onfi_mode),
+				ONFI_TIMING_ADDR);
+			operation->get_onfi_para(aml_chip,
+				onfi_features,
+				ONFI_TIMING_ADDR);
+			if (onfi_features[0] != controller->onfi_mode) {
+				aml_chip->flash.T_REA = DEFAULT_T_REA;
+				aml_chip->flash.T_RHOH = DEFAULT_T_RHOH;
+			}
+		}
+
+		/* if (aml_chip->state == CHIP_PM_SUSPENDED) */
+			amlnand_release_device(aml_chip);
+		aml_nand_dbg("nand resume entered\n");
+	}
+	return;
+}
+
+ssize_t nand_page_write(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct amlnand_phydev *phydev = NULL;
+	struct phydev_ops  *devops = NULL;
+	u_char *datbuf;
+	u64 offset , write_len;
+	loff_t off;
+	size_t ret;
+
+	phydev = container_of(class, struct amlnand_phydev, cls);
+	devops = &(phydev->ops);
+
+	aml_nand_dbg("phydev->name =%s", phydev->name);
+	aml_nand_dbg("write page");
+	ret = sscanf(buf, "%llx", &off);
+	datbuf = kmalloc(2*phydev->writesize, GFP_KERNEL);
+	if (!datbuf) {
+		aml_nand_msg("No memory for page buffer");
+		goto exit_erro;
+	}
+	memset(datbuf, 0xa5, 2*phydev->writesize);
+
+	offset = 0;
+	write_len = phydev->writesize;
+
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = datbuf;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_HW_ECC;
+	do {
+		if ((((u32)devops->addr % phydev->erasesize)) == 0) {
+			aml_nand_dbg("devops->addr = %llx", devops->addr);
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				aml_nand_msg("\rSkipping bad block at %llx\n",
+					devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				aml_nand_msg("get bad blk fail:");
+				aml_nand_msg("ret=%d addr=%llx\n",
+					ret,
+					devops->addr);
+				return -1;
+			}
+		}
+		ret = phydev->write(phydev);
+		if (ret < 0)
+			aml_nand_msg("nand read failed at %llx", devops->addr);
+
+		devops->addr +=  phydev->writesize;
+		datbuf += phydev->writesize;
+	} while (devops->addr < (offset + write_len));
+
+	aml_nand_dbg("write page complete");
+exit_erro:
+	kfree(datbuf);
+	return count;
+}
+
+/****
+*verify_nand_page:
+*read data immediately when write data, then compare;
+*
+*enbale this function:  set the first bit of aml_chip->debug_flag  to 1;
+*****/
+ssize_t verify_nand_page(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct amlnand_phydev *phydev = NULL;
+	struct amlnand_chip *aml_chip = NULL;
+	u8  off;
+	size_t ret;
+
+	phydev = container_of(class, struct amlnand_phydev, cls);
+	aml_chip = (struct amlnand_chip *)phydev->priv;
+
+	ret = sscanf(buf, "%d", (int *)&off);
+	aml_chip->debug_flag = off;
+
+	aml_nand_msg("nand set aml_chip->debug_flag to %d",
+		aml_chip->debug_flag);
+
+	return count;
+}
+
+ssize_t dump_nand_page(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct amlnand_phydev *phydev = NULL;
+	struct phydev_ops  *devops = NULL;
+	u8 *datbuf, *p;
+	u64 offset , write_len;
+	u64 off;
+	size_t ret;
+	int i;
+
+	phydev = container_of(class, struct amlnand_phydev, cls);
+	devops = &(phydev->ops);
+
+	ret = sscanf(buf, "%llx", &off);
+
+	aml_nand_msg("dump page %llx", off);
+	datbuf = kmalloc(2*phydev->writesize, GFP_KERNEL);
+	if (!datbuf) {
+		aml_nand_msg("No memory for page buffer");
+		goto exit_erro;
+	}
+	p = datbuf;
+	memset(datbuf, 0x0, 2*phydev->writesize);
+	aml_nand_msg("phydev->name =%s", phydev->name);
+
+	offset = off;
+	write_len = phydev->writesize;
+	aml_nand_msg("offset %llx", offset);
+
+	memset(devops, 0x0, sizeof(struct phydev_ops));
+	devops->addr = offset;
+	devops->len = phydev->writesize;
+	devops->datbuf = datbuf;
+	devops->oobbuf = NULL;
+	devops->mode = NAND_SOFT_ECC;
+	do {
+		if ((((u32)devops->addr % phydev->erasesize)) == 0) {
+			aml_nand_dbg("devops->addr = %llx", devops->addr);
+			ret =  phydev->block_isbad(phydev);
+			if (ret > 0) {
+				aml_nand_dbg("\rSkipping bad block at %llx\n",
+					devops->addr);
+				devops->addr += phydev->erasesize;
+				continue;
+			} else if (ret < 0) {
+				aml_nand_dbg("get bad blk fail:");
+				aml_nand_dbg("ret=%d addr=%llx\n",
+					ret,
+					devops->addr);
+				return -1;
+			}
+		}
+		ret = phydev->read(phydev);
+		if (ret < 0)
+			aml_nand_dbg("nand read failed at %llx", devops->addr);
+
+		devops->addr +=  phydev->writesize;
+		datbuf += phydev->writesize;
+	} while (devops->addr < (offset + write_len));
+
+	i = 512;
+	aml_nand_dbg("read page");
+	while (i--) {
+		aml_nand_msg("\t%02x %02x %02x %02x %02x %02x %02x %02x",
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+		aml_nand_msg("\t%02x %02x %02x %02x %02x %02x %02x %02x",
+			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		p += 16;
+	}
+
+	aml_nand_dbg("read page complete");
+exit_erro:
+	kfree(datbuf);
+	return count;
+}
+
+ssize_t show_nand_info(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	struct amlnand_phydev *phydev = NULL;
+	aml_nand_dbg("phydev info:");
+
+	phydev = container_of(class, struct amlnand_phydev, cls);
+
+	amldev_dumpinfo(phydev);
+	return 0;
+}
+
+ssize_t show_bbt_table(struct class *class,
+		struct class_attribute *attr,
+		const char *buf,
+		size_t count)
+{
+	struct amlnand_phydev *phydev = NULL;
+	struct amlnand_chip *aml_chip = NULL;
+	struct hw_controller *controller = NULL;
+	u16 *tmp_arr;
+	int start_block, chipnr, total_block;
+	int ret;
+
+	phydev = container_of(class, struct amlnand_phydev, cls);
+	aml_chip = (struct amlnand_chip *)phydev->priv;
+	controller = &(aml_chip->controller);
+
+	aml_nand_msg("show the block status !!!!");
+
+	ret = sscanf(buf, "%d", &total_block);
+	if (ret != 1)
+		return -EINVAL;
+	aml_nand_msg("set total_block %d", total_block);
+
+	for (chipnr = 0; chipnr < controller->chip_num; chipnr++) {
+		tmp_arr = &aml_chip->block_status->blk_status[chipnr][0];
+		for (start_block = total_block;
+			start_block < (total_block + 50);
+			start_block++)
+			aml_nand_msg(" aml_chip->block_status[%d][%d]=%d",
+				chipnr,
+				start_block,
+				tmp_arr[start_block]);
+	}
+	return count;
+}
+
+ssize_t change_test_sync_flag(struct class *class,
+			struct class_attribute *attr,
+			const char *buf,
+			size_t count)
+{
+	int num;
+	int ret;
+
+	ret = sscanf(buf, "%x", &num);
+	if (ret != 1)
+		return -EINVAL;
+	aml_nand_msg("---------------test_flag=%d", num);
+	test_flag = num;
+
+	return count;
+}
+
+ssize_t show_amlnf_version_info(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	aml_nand_dbg("show_nand_version_info v0.01");
+	return 0;
+}
+
+#endif /* AML_NAND_UBOOT */
+
+static void show_phydev_info(void)
+{
+	struct amlnand_phydev *phydev = NULL;
+	//struct amlnf_partition *partition = NULL;
+	//int i = 0;
+	char *config1, *config2;
+
+	list_for_each_entry(phydev, &nphy_dev_list, list) {
+		if (phydev == NULL)
+			break;
+	#if 0
+		for (i = 0; i < phydev->nr_partitions; i++) {
+			partition = &phydev->partitions[i];
+			aml_nand_msg("%s: name=%s,size=%llx",
+				phydev->name,
+				partition->name,
+				partition->size);
+		}
+	#endif
+		if (phydev->option & DEV_MULTI_CHIP_MODE)
+			config1 = "multi_chip";
+		else
+			config1 = "single_chip";
+		if (phydev->option & DEV_MULTI_PLANE_MODE)
+			config2 = "multi_plane";
+		else
+			config2 = "single_plane";
+
+		aml_nand_msg("%-10s: 0x%012llx-0x%012llx :partn=%d:%s %s",
+			phydev->name,
+			phydev->offset,
+			phydev->size,
+			phydev->nr_partitions,
+			config1,
+			config2);
+	}
+}
+
+
+/**********/
+/* check list by name 1st, avoiding reinit */
+int phydev_add_list(struct amlnand_phydev *new)
+{
+	int ret = 0;
+	struct amlnand_phydev *dev;
+	list_for_each_entry(dev, &nphy_dev_list, list) {
+		//if (!(memcmp(new->name, dev->name, sizeof(new->name)))) {
+		if (!strncmp((char *)new->name,
+				(char *) dev->name,
+				strlen((char *)new->name))) {
+			ret = -1;
+			goto _out;
+		}
+	}
+	list_add_tail(&new->list, &nphy_dev_list);
+
+_out:
+	return ret;
+}
+
+void show_phydev_list(void)
+{
+	int i = 0;
+	struct amlnand_phydev *dev;
+	printk("%s\n", __func__);
+	list_for_each_entry(dev, &nphy_dev_list, list) {
+		printk("%d: %s\n", i , dev->name);
+		i++;
+	}
+	return;
+}
+
+static int init_phydev_ops(struct amlnand_phydev *phydev)
+{
+	int ret = 0;
+	phydev->write = nand_write;
+	phydev->read = nand_read;
+	phydev->erase = nand_erase;
+
+	phydev->block_isbad = nand_block_isbad;
+	phydev->block_markbad = nand_block_markbad;
+
+	phydev->block_modifybbt = block_modifybbt;
+	phydev->update_bbt = update_bbt;
+//	phydev->phydev_test_block = nand_test_block;
+
+	return ret;
+}
+
+/*only init dev for u-boot*/
+int boot_dev_init(struct amlnand_chip *aml_chip)
+{
+	int ret = 0;
+	struct amlnand_phydev *phydev = NULL;
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct hw_controller *controller = &(aml_chip->controller);
+
+	PHYDEV_LINE
+	phydev = aml_nand_malloc(sizeof(struct amlnand_phydev));
+	if (phydev == NULL) {
+		aml_nand_msg("malloc failed need %x here",
+			(u32)(sizeof(struct amlnand_phydev)));
+		ret = -NAND_MALLOC_FAILURE;
+		goto _out;
+	}
+	memset(phydev, 0, sizeof(struct amlnand_phydev));
+	phydev->priv = aml_chip;
+	PHYDEV_LINE
+	phydev->writesize = flash->pagesize;
+	phydev->erasesize = flash->blocksize;
+	phydev->oobavail = controller->oobavail;
+
+	PHYDEV_LINE
+	//fixme, phy name...
+	memcpy((char *)phydev->name, NAND_BOOT_NAME, strlen(NAND_BOOT_NAME));
+	PHYDEV_LINE
+	phydev->offset = 0;
+	phydev->size = (BOOT_COPY_NUM*BOOT_PAGES_PER_COPY);
+	phydev->size *= flash->pagesize;
+	/* phydev->size *= chip_num; */
+	PHYDEV_LINE
+	phydev->writesize_shift = ffs(phydev->writesize) - 1;
+	phydev->erasesize_shift = ffs(phydev->erasesize) - 1;
+	phydev->writesize_mask =
+		(phydev->size>>phydev->writesize_shift) - 1;
+	PHYDEV_LINE
+	init_phydev_ops(phydev);
+	PHYDEV_LINE
+	if ((flash->option & NAND_CHIP_SLC_MODE)
+		&& (!(phydev->option & DEV_MULTI_PLANE_MODE))) {
+
+		phydev->option |= DEV_SLC_MODE;
+		phydev->erasesize >>= 1;
+		phydev->erasesize_shift = ffs(phydev->erasesize) - 1;
+		phydev->size >>= 1;
+		aml_nand_msg(" DEV %s enable SLC mode", phydev->name);
+	}
+	PHYDEV_LINE
+	ret = phydev_add_list(phydev);
+	if (ret) {
+		kfree(phydev);
+	}
+
+	show_phydev_list();
+_out:
+
+	return ret;
+}
+
+
+/******
+*nand chip usage
+* all dev size should
+* uboot(nand boot)	reserved	code	data
+*/
+int amlnand_phydev_init(struct amlnand_chip *aml_chip)
+{
+	struct amlnand_phydev *phydev = NULL, *phydev_pre = NULL;
+    struct phydev_ops *devops = &(phydev->ops);
+	struct nand_flash *flash = &(aml_chip->flash);
+	struct hw_controller *controller = &(aml_chip->controller);
+	struct chip_operation *operation = &(aml_chip->operation);
+	struct chip_ops_para *ops_para = &(aml_chip->ops_para);
+	struct nand_config *config = aml_chip->config_ptr;
+	struct dev_para *dev_para = NULL;
+	struct amlnf_partition *partition = NULL;
+	u64  offset = 0, dev_size = 0, chip_size = 0, phydev_pre_size = 0;
+	u64 relative_offset;
+	u32 start_blk, total_blk, tmp_write_shift, tmp_erase_shift;
+	u32 bad_blk_cnt =0;
+	u32 tmp_offset = 0, tmp_blk = 0, pages_per_blk;
+	u8 boot_flag = 0, plane_num = 1, chip_num;
+	int i, j, k, ret = 0;
+	u64 *bad_blk = NULL;
+	u32 tmp_value, adjust_blk = 0, cpu_type;
+	PHYDEV_LINE
+	bad_blk = aml_nand_malloc(128*sizeof(u64));
+	if (bad_blk == NULL) {
+		aml_nand_msg("malloc failed");
+		ret = -NAND_MALLOC_FAILURE;
+		goto exit_error0;
+	}
+	memset(bad_blk, 0, 128*sizeof(u64));
+
+	if (flash->option & NAND_MULTI_PLANE_MODE)
+		plane_num = 2;
+	else
+		plane_num = 1;
+
+	/* #ifndef AML_NAND_UBOOT */
+	/* INIT_LIST_HEAD (&nphy_dev_list); */
+	/* #endif */
+
+	chip_num = controller->chip_num;
+
+	chip_size = (flash->chipsize*chip_num);
+	chip_size = chip_size << 20;
+	if (config->dev_num == 0) {
+		aml_nand_msg("config get unvalid: config->dev_num =%d",
+			config->dev_num);
+		ret = -NAND_FAILED;
+		goto exit_error0;
+	}
+	PHYDEV_LINE
+	for (i = 0; i < config->dev_num; i++) {
+		phydev = aml_nand_malloc(sizeof(struct amlnand_phydev));
+		if (phydev == NULL) {
+			aml_nand_msg("malloc failed need %x here",
+				(u32)(sizeof(struct amlnand_phydev)));
+			ret = -NAND_MALLOC_FAILURE;
+			goto exit_error0;
+		}
+		memset(phydev, 0, sizeof(struct amlnand_phydev));
+		phydev->priv = aml_chip;
+		PHYDEV_LINE
+		dev_para = &(config->dev_para[i]);
+		memcpy(&phydev->name,
+			&dev_para->name,
+			MAX_DEVICE_NAME_LEN*sizeof(char));
+
+		/* set default parameter */
+		phydev->writesize = flash->pagesize;
+		phydev->erasesize = flash->blocksize;
+		phydev->oobavail = controller->oobavail;
+		dev_size = 0;
+
+		tmp_write_shift = ffs(flash->pagesize) - 1;
+		tmp_erase_shift = ffs(flash->blocksize) - 1;
+		pages_per_blk = (1 << (tmp_erase_shift - tmp_write_shift));
+
+		phydev->write = nand_write;
+		phydev->read = nand_read;
+
+		phydev->erase = nand_erase;
+
+		phydev->block_isbad = nand_block_isbad;
+		phydev->block_markbad = nand_block_markbad;
+
+		phydev->block_modifybbt = block_modifybbt;
+		phydev->update_bbt = update_bbt;
+		phydev->phydev_test_block = nand_test_block;
+
+		/* set partitions and caulate dev size */
+		if (dev_para->nr_partitions) {
+			phydev->nr_partitions = dev_para->nr_partitions;
+			phydev->partitions = dev_para->partitions;
+			for (k = 0; k < dev_para->nr_partitions; k++) {
+				partition = &(dev_para->partitions[k]);
+				aml_nand_dbg("partition[%d]-name:%s,size:%llx",
+					k,
+					partition->name,
+					partition->size);
+			}
+			PHYDEV_LINE
+			if (i != (config->dev_num - 1)) {
+				for (j = 0; j < dev_para->nr_partitions; j++) {
+					partition = &(dev_para->partitions[j]);
+					dev_size += partition->size;
+				}
+				if (!is_phydev_off_adjust()) {
+					int adjust_shift =
+						ffs(ADJUST_SIZE_NFTL) - 1;
+					/*
+					aml_nand_msg("not adjust,
+					adjust_shift : %d",
+					adjust_shift);
+					*/
+					dev_size = dev_size
+						+ (dev_size >> adjust_shift);
+				}
+				/*
+				adjust dev_size for nftl
+				dev_size = dev_size \
+			+ ((u64)(dev_size)/(u64)(ADJUST_SIZE_NFTL));
+				*/
+			} else {
+				if ((phydev_pre->option & DEV_SLC_MODE)
+&& (flash->option & NAND_CHIP_SLC_MODE)
+				&& (!(phydev->option & DEV_MULTI_PLANE_MODE)))
+					phydev_pre_size = phydev_pre->size << 1;
+				else
+					phydev_pre_size = phydev_pre->size;
+
+				dev_size = chip_size - phydev_pre->offset
+					- phydev_pre_size;
+			}
+		} else {
+			dev_size = dev_para->size;
+		}
+
+		if ((dev_para->option & DEV_SLC_MODE) &&
+			(flash->option & NAND_CHIP_SLC_MODE) &&
+			(!(dev_para->option & DEV_MULTI_PLANE_MODE))) {
+			dev_size <<= 1;
+			aml_nand_msg("DEV enable SLC mode");
+		}
+
+		if (!strncmp((char *)phydev->name,
+			NAND_BOOT_NAME,
+			strlen((const char *)NAND_BOOT_NAME))) {
+			boot_flag = 1;
+
+			phydev->offset = 0;
+			phydev->size = (BOOT_COPY_NUM * BOOT_PAGES_PER_COPY);
+			//printk("----------%llx\n", phydev->size);
+			phydev->size *= flash->pagesize;
+			//printk("----------%llx\n", phydev->size);
+			/* phydev->size *= chip_num; */
+
+			phydev->writesize_shift = ffs(phydev->writesize) - 1;
+			phydev->erasesize_shift = ffs(phydev->erasesize) - 1;
+			phydev->writesize_mask =
+				(phydev->size>>phydev->writesize_shift) - 1;
+
+			tmp_blk = phydev->size >> phydev->erasesize_shift;
+		} else { /* not boot phydev[nftl] */
+			if ((dev_para->option & DEV_MULTI_CHIP_MODE)
+				&& (chip_num > 1)) {
+				phydev->option |= DEV_MULTI_CHIP_MODE;
+				phydev->writesize *= chip_num;
+				phydev->erasesize *= chip_num;
+				phydev->oobavail *= chip_num;
+			}
+
+			if ((dev_para->option & DEV_MULTI_PLANE_MODE)
+				&& (flash->option & NAND_MULTI_PLANE_MODE)) {
+				phydev->option |= DEV_MULTI_PLANE_MODE;
+				phydev->writesize <<= 1;
+				phydev->erasesize <<= 1;
+				phydev->oobavail <<= 1;
+			}
+		#if (DBG_WRITE_VERIFY)
+			/*debug code */
+			if ( NULL == glb_verify_buffer ) {
+				glb_verify_buffer = aml_nand_malloc(phydev->writesize);
+				if (glb_verify_buffer == NULL) {
+					aml_nand_msg("%s() %d, malloc glb_verify_buffer failed!\n",
+						__func__, __LINE__);
+
+				}
+
+			}
+		#endif
+			phydev->writesize_shift = ffs(phydev->writesize) - 1;
+			phydev->erasesize_shift = ffs(phydev->erasesize) - 1;
+
+			if (((boot_flag == 1) && (i == 1))
+				|| ((boot_flag == 0) && (i == 0))) {
+				offset = start_blk = 0;
+				total_blk = RESERVED_BLOCK_CNT;
+				memset(ops_para, 0,
+					sizeof(struct chip_ops_para));
+				do {
+					tmp_value = offset>>tmp_erase_shift;
+					ops_para->chipnr =
+						((u32)tmp_value) % chip_num;
+					tmp_value += tmp_blk;
+					tmp_value /= chip_num;
+					tmp_value += tmp_blk - tmp_blk/chip_num;
+					tmp_value *= pages_per_blk;
+					ops_para->page_addr = tmp_value;
+					ret = operation->block_isbad(aml_chip);
+					if (ret == NAND_BLOCK_FACTORY_BAD) {
+						offset += flash->blocksize;
+						continue;
+					}
+					start_blk++;
+					offset += flash->blocksize;
+				} while (start_blk < total_blk);
+				tmp_value = (u32)(offset>>tmp_erase_shift) - 1;
+				tmp_value /= chip_num*plane_num;
+				tmp_value += 1;
+				total_blk = tmp_value * chip_num * plane_num;
+				aml_nand_dbg("total_blk =%d", total_blk);
+				aml_nand_dbg(" phydev_pre->size =%llx",
+					phydev_pre->size);
+				if (phydev_pre == NULL)
+					phydev->offset =
+						total_blk * flash->blocksize;
+				else
+					phydev->offset =
+						total_blk * flash->blocksize +
+						phydev_pre->size;
+				aml_nand_dbg("phydev->offset =%llx",
+					phydev->offset);
+			} else {
+				if ((!(phydev->option & DEV_MULTI_PLANE_MODE)
+					&& (flash->option & NAND_CHIP_SLC_MODE)
+					&& (phydev_pre->option & DEV_SLC_MODE)))
+					phydev_pre_size = phydev_pre->size << 1;
+				else
+					phydev_pre_size = phydev_pre->size;
+
+				phydev->offset =
+					phydev_pre->offset + phydev_pre_size;
+			}
+
+			if (i != (config->dev_num - 1)) {
+				start_blk = 0;
+				if (((boot_flag == 1) && (i == 1))
+					|| ((boot_flag == 0) && (i == 0)))
+					offset = phydev->offset;
+				else
+					offset = phydev_pre->offset +
+						phydev_pre->size;
+				tmp_offset = offset;
+
+				aml_nand_dbg("offset = %llx, %llx",
+					offset,
+					tmp_erase_shift);
+				/*
+				if (!is_phydev_off_adjust())
+					total_blk = dev_size >> tmp_erase_shift;
+				else {
+				*/
+				aml_nand_dbg("adjust phy offset: %d",
+					ADJUST_BLOCK_NUM);
+				total_blk =
+					dev_size >> phydev->erasesize_shift;
+
+				cpu_type = get_cpu_type();
+				/* for compatible with history. */
+				if ((cpu_type == MESON_CPU_MAJOR_ID_M8)
+					&& (phydev->erasesize < 0x400000))
+					adjust_blk = 0;
+				else
+					adjust_blk = ADJUST_PART_SIZE - 1;
+
+				tmp_value = total_blk;
+				tmp_value += adjust_blk;
+				tmp_value /= ADJUST_PART_SIZE;
+				tmp_value += total_blk + ADJUST_BLOCK_NUM;
+				total_blk = tmp_value;
+
+				memset(ops_para,
+					0,
+					sizeof(struct chip_ops_para));
+				ops_para->option = phydev->option;
+/*
+if (!is_phydev_off_adjust()) {
+	do {
+		ops_para->page_addr =
+		((((u32)((((u32)(offset >> tmp_erase_shift)))) /
+		chip_num) + tmp_blk - tmp_blk / chip_num) * pages_per_blk);
+		ops_para->chipnr =
+		((u32) (offset >> tmp_erase_shift))%chip_num;
+		ret = operation->block_isbad(aml_chip);
+		if (ret == NAND_BLOCK_FACTORY_BAD) {
+			offset += flash->blocksize;
+			continue;
+		}
+		start_blk++;
+		offset += flash->blocksize;
+	} while (start_blk < total_blk);
+
+	total_blk =
+	((((u32) (offset >> phydev->erasesize_shift)) - 1) / \
+		chip_num*plane_num) + 1) * (chip_num*plane_num);
+	aml_nand_dbg("total_blk =%d", total_blk);
+	phydev->size = ((u64)total_blk*(u64)phydev->erasesize);
+} else {
+*/
+				do {
+					tmp_value =
+						offset>>phydev->writesize_shift;
+					ops_para->page_addr = (u32)(tmp_value);
+					/*
+					ops_para->chipnr =
+			((u32)(offset>>phydev->erasesize_shift))%chip_num;
+					*/
+					ret = operation->block_isbad(aml_chip);
+					if (ret == NAND_BLOCK_FACTORY_BAD) {
+						offset += phydev->erasesize;
+						continue;
+					}
+					start_blk++;
+					offset += phydev->erasesize;
+				} while (start_blk < total_blk);
+
+				tmp_value = offset - tmp_offset;
+				tmp_value =
+				(u32)(tmp_value >> phydev->erasesize_shift);
+				tmp_value -= 1;
+				tmp_value /= chip_num * plane_num;
+				tmp_value += 1;
+				total_blk = tmp_value * chip_num * plane_num;
+				//printk("%s() %d, total_blk 0x%x, erase_size 0x%x\n", __func__, __LINE__, total_blk, phydev->erasesize);
+				phydev->size = ((u64)total_blk *
+					(u64)phydev->erasesize);
+				/*
+				}
+				*/
+			} else
+				phydev->size = dev_size;
+
+			if ((phydev->offset + phydev->size) > chip_size) {
+				aml_nand_msg("nand dev size is out of space");
+				ret = -NAND_FAILED;
+				goto exit_error0;
+			}
+#ifndef AML_NAND_UBOOT
+			phydev->suspend = phydev_suspend;
+			phydev->resume = phydev_resume;
+#endif
+		}
+
+		phydev_pre = phydev;
+
+		if ((dev_para->option & DEV_SLC_MODE)
+&& (flash->option & NAND_CHIP_SLC_MODE)
+&& (!(phydev->option & DEV_MULTI_PLANE_MODE))) {
+			phydev->option |= DEV_SLC_MODE;
+			phydev->erasesize >>= 1;
+			phydev->erasesize_shift = ffs(phydev->erasesize) - 1;
+			phydev->size >>= 1;
+			aml_nand_msg(" DEV %s enable SLC mode", phydev->name);
+		}
+		/* fixme, add new physic device */
+		//list_add_tail(&phydev->list, &nphy_dev_list);
+		phydev_add_list(phydev);
+
+#if (AML_NAND_DBG)
+		amldev_dumpinfo(phydev);
+#endif
+		aml_nand_dbg("####: %s :phydev->offset  = %llx",
+				phydev_pre->name, phydev_pre->offset);
+		aml_nand_dbg("####: %s :phydev->size = %llx",
+				phydev_pre->name, phydev_pre->size);
+		aml_nand_dbg("####: %s :phydev->writesize = %x",
+				phydev_pre->name, phydev_pre->writesize);
+		aml_nand_dbg("####: %s :phydev->erasesize = %x",
+				phydev_pre->name, phydev_pre->erasesize);
+
+	}
+
+	show_phydev_info();
+	PHYDEV_LINE
+#if 1
+	phydev = NULL;
+	list_for_each_entry(phydev, &nphy_dev_list, list) {
+		if (phydev == NULL)
+			break;
+
+		aml_nand_dbg("-----------------------------\n");
+		aml_nand_dbg("name:%s,offset:%llx,size:%llx,option:%x",
+			phydev->name,
+			phydev->offset,
+			phydev->size,
+			phydev->option);
+		aml_nand_dbg("es:%x,ws:%x,oob:%x,eshift:%x,wshift:%d",
+			phydev->erasesize,
+			phydev->writesize,
+			phydev->oobavail,
+			phydev->erasesize_shift,
+			phydev->writesize_shift);
+		aml_nand_dbg(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
+		relative_offset = 0;
+		bad_blk_cnt = 0;
+		devops = &(phydev->ops);
+		memset(bad_blk, 0, 128*sizeof(u64));
+		do {
+			memset(devops, 0x0, sizeof(struct phydev_ops));
+			memset(devops, 0x0, sizeof(struct phydev_ops));
+			devops->addr = relative_offset;
+			devops->len = phydev->erasesize;
+			devops->datbuf = NULL;
+			devops->oobbuf = NULL;
+			devops->mode = NAND_HW_ECC;
+			ret = nand_block_isbad(phydev);
+			if (ret == NAND_BLOCK_USED_BAD) {
+				if (bad_blk_cnt < 128) {
+					bad_blk[bad_blk_cnt] = relative_offset;
+					bad_blk_cnt++;
+				}
+			}
+				relative_offset += phydev->erasesize;
+		} while (relative_offset < phydev->size);
+
+		aml_nand_msg("(%s) bad blks %d", phydev->name, bad_blk_cnt);
+
+		if ((bad_blk_cnt * 32 >
+			(phydev->size >> phydev->erasesize_shift)) ||
+			(bad_blk_cnt > 10)) {
+			aml_nand_dbg("Too many new bad blks,try to repair..\n");
+			/*
+			ret = aml_repair_bbt(phydev,bad_blk,bad_blk_cnt);
+			*/
+		}
+	}
+
+#endif
+#ifdef AML_NAND_UBOOT
+	if (aml_chip->init_flag == NAND_BOOT_ERASE_PROTECT_CACHE) {
+		ret = phydev_init_erase(aml_chip);
+		if (ret < 0) {
+			aml_nand_msg("amlnand_phydev_init : phydev_init_erase failed");
+		}
+	}
+#endif /* AML_NAND_UBOOT */
+	return NAND_SUCCESS;
+
+exit_error0:
+	return ret;
+}
+
+#ifdef AML_NAND_UBOOT
+void amlnf_phy_exit(void)
+{
+
+	struct amlnand_phydev *phydev = NULL;
+	struct amlnand_chip *aml_chip = NULL;
+	//struct list_head *entry;
+	int time= 0;
+	list_for_each_entry(phydev,&nphy_dev_list,list){
+
+		if (phydev) {
+			if (time == 0) {
+				aml_chip = (struct amlnand_chip *)phydev->priv;
+				if (aml_chip) {
+					if (aml_chip->block_status) {
+						kfree(aml_chip->block_status);
+						aml_chip->block_status = NULL;
+					}
+					if (aml_chip->user_page_buf) {
+						kfree(aml_chip->user_page_buf);
+						aml_chip->user_page_buf = NULL;
+					}
+					if (aml_chip->user_oob_buf) {
+						kfree(aml_chip->user_oob_buf);
+						aml_chip->user_oob_buf = NULL;
+					}
+					if (aml_chip->shipped_bbt_ptr) {
+						kfree(aml_chip->shipped_bbt_ptr);
+						aml_chip->shipped_bbt_ptr = NULL;
+					}
+					if (aml_chip->config_ptr) {
+						kfree(aml_chip->config_ptr);
+						aml_chip->config_ptr = NULL;
+					}
+				}
+				time++;
+			}
+		}
+	}
+
+	list_del_init(&nphy_dev_list);
+
+}
+#endif
+
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index fb0cf8c..b64c866 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -66,3 +66,4 @@ obj-$(CONFIG_XILINX_LL_TEMAC) += xilinx_ll_temac.o xilinx_ll_temac_mdio.o \
 		xilinx_ll_temac_fifo.o xilinx_ll_temac_sdma.o
 obj-$(CONFIG_ZYNQ_GEM) += zynq_gem.o
 obj-$(CONFIG_FSL_MC_ENET) += fsl_mc/
+obj-$(CONFIG_AML_ETHERNET) +=aml_ethernet.o
diff --git a/drivers/net/aml_eth_reg.h b/drivers/net/aml_eth_reg.h
new file mode 100644
index 0000000..60ab8a3
--- /dev/null
+++ b/drivers/net/aml_eth_reg.h
@@ -0,0 +1,678 @@
+
+/*
+ * drivers/net/aml_eth_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __AML_ETH_REG_H__
+#define __AML_ETH_REG_H__
+#include <asm/arch/eth_setup.h>
+#define ETH_DMA_0_Bus_Mode                      (ETH_BASE + 0x1000)
+#define ETH_DMA_1_Tr_Poll_Demand                (ETH_BASE + 0x1004)
+#define ETH_DMA_2_Re_Poll_Demand                (ETH_BASE + 0x1008)
+#define ETH_DMA_3_Re_Descriptor_List_Addr       (ETH_BASE + 0x100C)
+#define ETH_DMA_4_Tr_Descriptor_List_Addr       (ETH_BASE + 0x1010)
+#define ETH_DMA_5_Status                        (ETH_BASE + 0x1014)
+#define ETH_DMA_6_Operation_Mode                (ETH_BASE + 0x1018)
+#define ETH_DMA_7_Interrupt_Enable              (ETH_BASE + 0x101C)
+#define ETH_DMA_8_Missed_Frame_and_Overflow     (ETH_BASE + 0x1020)
+#define ETH_DMA_9_Reserved                      (ETH_BASE + 0x1024)
+#define ETH_DMA_10_Reserved                     (ETH_BASE + 0x1028)
+#define ETH_DMA_11_Reserved                     (ETH_BASE + 0x102c)
+#define ETH_DMA_12_Reserved                     (ETH_BASE + 0x1030)
+#define ETH_DMA_13_Reserved                     (ETH_BASE + 0x1034)
+#define ETH_DMA_14_Reserved                     (ETH_BASE + 0x1038)
+#define ETH_DMA_15_Reserved                     (ETH_BASE + 0x103c)
+#define ETH_DMA_16_Reserved                     (ETH_BASE + 0x1040)
+#define ETH_DMA_17_Reserved                     (ETH_BASE + 0x1044)
+#define ETH_DMA_18_Curr_Host_Tr_Descriptor      (ETH_BASE + 0x1048)
+#define ETH_DMA_19_Curr_Host_Re_Descriptor      (ETH_BASE + 0x104C)
+#define ETH_DMA_20_Curr_Host_Tr_Buffer_Addr     (ETH_BASE + 0x1050)
+#define ETH_DMA_21_Curr_Host_Re_Buffer_Addr     (ETH_BASE + 0x1054)
+#define ETH_MAC_0_Configuration                 (ETH_BASE + 0x0000)
+#define ETH_MAC_1_Frame_Filter                  (ETH_BASE + 0x0004)
+#define ETH_MAC_2_Hash_Table_High               (ETH_BASE + 0x0008)
+#define ETH_MAC_3_Hash_Table_Low                (ETH_BASE + 0x000C)
+#define ETH_MAC_4_GMII_Addr                     (ETH_BASE + 0x0010)
+#define ETH_MAC_5_GMII_Data                     (ETH_BASE + 0x0014)
+#define ETH_MAC_6_Flow_Control                  (ETH_BASE + 0x0018)
+#define ETH_MAC_7_VLAN_Tag                      (ETH_BASE + 0x001C)
+#define ETH_MAC_8_Version                       (ETH_BASE + 0x0020)
+#define ETH_MAC_9_Reserved                      (ETH_BASE + 0x0024)
+#define ETH_MAC_Remote_Wake_Up_Frame_Filter     (ETH_BASE + 0x0028)
+#define ETH_MAC_PMT_Control_and_Status          (ETH_BASE + 0x002C)
+#define ETH_MAC_12_Reserved                     (ETH_BASE + 0x0030)
+#define ETH_MAC_13_Reserved                     (ETH_BASE + 0x0034)
+#define ETH_MAC_Interrupt                       (ETH_BASE + 0x0038)
+#define ETH_MAC_Interrupt_Mask                  (ETH_BASE + 0x003C)
+#define ETH_MAC_Addr0_High                      (ETH_BASE + 0x0040)
+#define ETH_MAC_Addr0_Low                       (ETH_BASE + 0x0044)
+#define ETH_MAC_Addr1_High                      (ETH_BASE + 0x0048)
+#define ETH_MAC_Addr1_Low                       (ETH_BASE + 0x004C)
+#define ETH_MAC_Addr2_High                      (ETH_BASE + 0x0050)
+#define ETH_MAC_Addr2_Low                       (ETH_BASE + 0x0054)
+#define ETH_MAC_Addr3_High                      (ETH_BASE + 0x0058)
+#define ETH_MAC_Addr3_Low                       (ETH_BASE + 0x005C)
+#define ETH_MAC_Addr4_High                      (ETH_BASE + 0x0060)
+#define ETH_MAC_Addr4_Low                       (ETH_BASE + 0x0064)
+#define ETH_MAC_Addr5_High                      (ETH_BASE + 0x0068)
+#define ETH_MAC_Addr5_Low                       (ETH_BASE + 0x006C)
+#define ETH_MAC_Addr6_High                      (ETH_BASE + 0x0070)
+#define ETH_MAC_Addr6_Low                       (ETH_BASE + 0x0074)
+#define ETH_MAC_Addr7_High                      (ETH_BASE + 0x0078)
+#define ETH_MAC_Addr7_Low                       (ETH_BASE + 0x007C)
+#define ETH_MAC_Addr8_High                      (ETH_BASE + 0x0080)
+#define ETH_MAC_Addr8_Low                       (ETH_BASE + 0x0084)
+#define ETH_MAC_Addr9_High                      (ETH_BASE + 0x0088)
+#define ETH_MAC_Addr9_Low                       (ETH_BASE + 0x008C)
+#define ETH_MAC_Addr10_High                     (ETH_BASE + 0x0090)
+#define ETH_MAC_Addr10_Low                      (ETH_BASE + 0x0094)
+#define ETH_MAC_Addr11_High                     (ETH_BASE + 0x0098)
+#define ETH_MAC_Addr11_Low                      (ETH_BASE + 0x009C)
+#define ETH_MAC_Addr12_High                     (ETH_BASE + 0x00A0)
+#define ETH_MAC_Addr12_Low                      (ETH_BASE + 0x00A4)
+#define ETH_MAC_Addr13_High                     (ETH_BASE + 0x00A8)
+#define ETH_MAC_Addr13_Low                      (ETH_BASE + 0x00AC)
+#define ETH_MAC_Addr14_High                     (ETH_BASE + 0x00B0)
+#define ETH_MAC_Addr14_Low                      (ETH_BASE + 0x00B4)
+#define ETH_MAC_Addr15_High                     (ETH_BASE + 0x00B8)
+#define ETH_MAC_Addr15_Low                      (ETH_BASE + 0x00BC)
+#define ETH_MAC_48_AN_Control                   (ETH_BASE + 0x00C0)
+#define ETH_MAC_49_AN_Status                    (ETH_BASE + 0x00C4)
+#define ETH_MAC_50_AN_Advertisement             (ETH_BASE + 0x00C8)
+#define ETH_MAC_51_AN_Link_Partner_Ability      (ETH_BASE + 0x00CC)
+#define ETH_MAC_52_AN_Expansion                 (ETH_BASE + 0x00D0)
+#define ETH_MAC_53_TBI_Extended_Status          (ETH_BASE + 0x00D4)
+#define ETH_MAC_54_SGMII_RGMII_Status           (ETH_BASE + 0x00D8)
+#define ETH_MAC_55_Reserved                     (ETH_BASE + 0x00DC)
+#define ETH_MAC_56_Reserved                     (ETH_BASE + 0x00E0)
+#define ETH_MAC_57_Reserved                     (ETH_BASE + 0x00E4)
+#define ETH_MAC_58_Reserved                     (ETH_BASE + 0x00E8)
+#define ETH_MAC_59_Reserved                     (ETH_BASE + 0x00EC)
+#define ETH_MAC_60_Reserved                     (ETH_BASE + 0x00F0)
+#define ETH_MAC_61_Reserved                     (ETH_BASE + 0x00F4)
+#define ETH_MAC_62_Reserved                     (ETH_BASE + 0x00F8)
+#define ETH_MAC_63_Reserved                     (ETH_BASE + 0x00FC)
+#define ETH_MMC_cntrl                           (ETH_BASE + 0x0100)
+#define ETH_MMC_intr_rx                         (ETH_BASE + 0x0104)
+#define ETH_MMC_intr_tx                         (ETH_BASE + 0x0108)
+#define ETH_MMC_intr_mask_rx                    (ETH_BASE + 0x010C)
+#define ETH_MMC_intr_mask_tx                    (ETH_BASE + 0x0110)
+#define ETH_MMC_txoctetcount_gb                 (ETH_BASE + 0x0114)
+#define ETH_MMC_txframecount_gb                 (ETH_BASE + 0x0118)
+#define ETH_MMC_txbroadcastframes_g             (ETH_BASE + 0x011C)
+#define ETH_MMC_txmulticastframes_g             (ETH_BASE + 0x0120)
+#define ETH_MMC_tx64octets_gb                   (ETH_BASE + 0x0124)
+#define ETH_MMC_tx65to127octets_gb              (ETH_BASE + 0x0128)
+#define ETH_MMC_tx128to255octets_gb             (ETH_BASE + 0x012C)
+#define ETH_MMC_tx256to511octets_gb             (ETH_BASE + 0x0130)
+#define ETH_MMC_tx512to1023octets_gb            (ETH_BASE + 0x0134)
+#define ETH_MMC_tx1024tomaxoctets_gb            (ETH_BASE + 0x0138)
+#define ETH_MMC_txunicastframes_gb              (ETH_BASE + 0x013C)
+#define ETH_MMC_txmulticastframes_gb            (ETH_BASE + 0x0140)
+#define ETH_MMC_txbroadcastframes_gb            (ETH_BASE + 0x0144)
+#define ETH_MMC_txunderflowerror                (ETH_BASE + 0x0148)
+#define ETH_MMC_txsinglecol_g                   (ETH_BASE + 0x014C)
+#define ETH_MMC_txmulticol_g                    (ETH_BASE + 0x0150)
+#define ETH_MMC_txdeferred                      (ETH_BASE + 0x0154)
+#define ETH_MMC_txlatecol                       (ETH_BASE + 0x0158)
+#define ETH_MMC_txexesscol                      (ETH_BASE + 0x015C)
+#define ETH_MMC_txcarriererror                  (ETH_BASE + 0x0160)
+#define ETH_MMC_txoctetcount_g                  (ETH_BASE + 0x0164)
+#define ETH_MMC_txframecount_g                  (ETH_BASE + 0x0168)
+#define ETH_MMC_txexcessdef                     (ETH_BASE + 0x016C)
+#define ETH_MMC_txpauseframes                   (ETH_BASE + 0x0170)
+#define ETH_MMC_txvlanframes_g                  (ETH_BASE + 0x0174)
+#define ETH_MMC_94_Reserved                     (ETH_BASE + 0x0178)
+#define ETH_MMC_95_Reserved                     (ETH_BASE + 0x017C)
+#define ETH_MMC_rxframecount_gb                 (ETH_BASE + 0x0180)
+#define ETH_MMC_rxoctetcount_gb                 (ETH_BASE + 0x0184)
+#define ETH_MMC_rxoctetcount_g                  (ETH_BASE + 0x0188)
+#define ETH_MMC_rxbroadcastframes_g             (ETH_BASE + 0x018C)
+#define ETH_MMC_rxmulticastframes_g             (ETH_BASE + 0x0190)
+#define ETH_MMC_rxcrcerror                      (ETH_BASE + 0x0194)
+#define ETH_MMC_rxalignmenterror                (ETH_BASE + 0x0198)
+#define ETH_MMC_rxrunterror                     (ETH_BASE + 0x019C)
+#define ETH_MMC_rxjabbererror                   (ETH_BASE + 0x01A0)
+#define ETH_MMC_rxundersize_g                   (ETH_BASE + 0x01A4)
+#define ETH_MMC_rxoversize_g                    (ETH_BASE + 0x01A8)
+#define ETH_MMC_rx64octets_gb                   (ETH_BASE + 0x01AC)
+#define ETH_MMC_rx65to127octets_gb              (ETH_BASE + 0x01B0)
+#define ETH_MMC_rx128to255octets_gb             (ETH_BASE + 0x01B4)
+#define ETH_MMC_rx256to511octets_gb             (ETH_BASE + 0x01B8)
+#define ETH_MMC_rx512to1023octets_gb            (ETH_BASE + 0x01BC)
+#define ETH_MMC_rx1024tomaxoctets_gb            (ETH_BASE + 0x01C0)
+#define ETH_MMC_rxunicastframes_g               (ETH_BASE + 0x01C4)
+#define ETH_MMC_rxlengtherror                   (ETH_BASE + 0x01C8)
+#define ETH_MMC_rxoutofrangetype                (ETH_BASE + 0x01CC)
+#define ETH_MMC_rxpauseframes                   (ETH_BASE + 0x01D0)
+#define ETH_MMC_rxfifooverflow                  (ETH_BASE + 0x01D4)
+#define ETH_MMC_rxvlanframes_gb                 (ETH_BASE + 0x01D8)
+#define ETH_MMC_rxwatchdogerror                 (ETH_BASE + 0x01DC)
+#define ETH_MMC_120_Reserved                    (ETH_BASE + 0x01E0)
+#define ETH_MMC_121_Reserved                    (ETH_BASE + 0x01E4)
+#define ETH_MMC_122_Reserved                    (ETH_BASE + 0x01E8)
+#define ETH_MMC_123_Reserved                    (ETH_BASE + 0x01EC)
+#define ETH_MMC_124_Reserved                    (ETH_BASE + 0x01F0)
+#define ETH_MMC_125_Reserved                    (ETH_BASE + 0x01F4)
+#define ETH_MMC_126_Reserved                    (ETH_BASE + 0x01F8)
+#define ETH_MMC_127_Reserved                    (ETH_BASE + 0x01FC)
+#define ETH_MMC_ipc_intr_mask_rx                (ETH_BASE + 0x0200)
+#define ETH_MMC_129_Reserved                    (ETH_BASE + 0x0204)
+#define ETH_MMC_ipc_intr_rx                     (ETH_BASE + 0x0208)
+#define ETH_MMC_131_Reserved                    (ETH_BASE + 0x020C)
+#define ETH_MMC_rxipv4_gd_frms                  (ETH_BASE + 0x0210)
+#define ETH_MMC_rxipv4_hdrerr_frms              (ETH_BASE + 0x0214)
+#define ETH_MMC_rxipv4_nopay_frms               (ETH_BASE + 0x0218)
+#define ETH_MMC_rxipv4_frag_frms                (ETH_BASE + 0x021C)
+#define ETH_MMC_rxipv4_udsbl_frms               (ETH_BASE + 0x0220)
+#define ETH_MMC_rxipv6_gd_frms                  (ETH_BASE + 0x0224)
+#define ETH_MMC_rxipv6_hdrerr_frms              (ETH_BASE + 0x0228)
+#define ETH_MMC_rxipv6_nopay_frms               (ETH_BASE + 0x022C)
+#define ETH_MMC_rxudp_gd_frms                   (ETH_BASE + 0x0230)
+#define ETH_MMC_rxudp_err_frms                  (ETH_BASE + 0x0234)
+#define ETH_MMC_rxtcp_gd_frms                   (ETH_BASE + 0x0238)
+#define ETH_MMC_rxtcp_err_frms                  (ETH_BASE + 0x023C)
+#define ETH_MMC_rxicmp_gd_frms                  (ETH_BASE + 0x0240)
+#define ETH_MMC_rxicmp_err_frms                 (ETH_BASE + 0x0244)
+#define ETH_MMC_146_Reserved                    (ETH_BASE + 0x0248)
+#define ETH_MMC_147_Reserved                    (ETH_BASE + 0x024C)
+#define ETH_MMC_rxipv4_gd_octets                (ETH_BASE + 0x0250)
+#define ETH_MMC_rxipv4_hdrerr_octets            (ETH_BASE + 0x0254)
+#define ETH_MMC_rxipv4_nopay_octets             (ETH_BASE + 0x0258)
+#define ETH_MMC_rxipv4_frag_octets              (ETH_BASE + 0x025C)
+#define ETH_MMC_rxipv4_udsbl_octets             (ETH_BASE + 0x0260)
+#define ETH_MMC_rxipv6_gd_octets                (ETH_BASE + 0x0264)
+#define ETH_MMC_rxipv6_hdrerr_octets            (ETH_BASE + 0x0268)
+#define ETH_MMC_rxipv6_nopay_octets             (ETH_BASE + 0x026C)
+#define ETH_MMC_rxudp_gd_octets                 (ETH_BASE + 0x0270)
+#define ETH_MMC_rxudp_err_octets                (ETH_BASE + 0x0274)
+#define ETH_MMC_rxtcp_gd_octets                 (ETH_BASE + 0x0278)
+#define ETH_MMC_rxtcp_err_octets                (ETH_BASE + 0x027C)
+#define ETH_MMC_rxicmp_gd_octets                (ETH_BASE + 0x0280)
+#define ETH_MMC_rxicmp_err_octets               (ETH_BASE + 0x0284)
+
+/*
+ * ****************************************************************************
+ *  A description of the NIKE Enthernet registers bit defination
+ * ****************************************************************************
+ */
+/* ETH_DMA_0_Bus_Mode */
+#define ETH_DMA_0_Bus_Mode_SWR_P                0
+#define ETH_DMA_0_Bus_Mode_DA_P                 1
+#define ETH_DMA_0_Bus_Mode_DSL_P                2
+#define ETH_DMA_0_Bus_Mode_PBL_P                8
+#define ETH_DMA_0_Bus_Mode_PR_P                 14
+#define ETH_DMA_0_Bus_Mode_FB_P                 16
+#define ETH_DMA_0_Bus_Mode_RPBL_P               17
+#define ETH_DMA_0_Bus_Mode_USP_P                23
+#define ETH_DMA_0_Bus_Mode_4xPBL_P              24
+#define ETH_DMA_0_Bus_Mode_AAL_P                25
+
+#define ETH_DMA_0_Bus_Mode_SWR                  (1<<ETH_DMA_0_Bus_Mode_SWR_P)
+#define ETH_DMA_0_Bus_Mode_DA                   (1<<ETH_DMA_0_Bus_Mode_DA_P)
+#define ETH_DMA_0_Bus_Mode_DSL                  (1<<ETH_DMA_0_Bus_Mode_DSL_P)
+#define ETH_DMA_0_Bus_Mode_PBL                  (1<<ETH_DMA_0_Bus_Mode_PBL_P)
+#define ETH_DMA_0_Bus_Mode_PR                   (1<<ETH_DMA_0_Bus_Mode_PR_P)
+#define ETH_DMA_0_Bus_Mode_FB                   (1<<ETH_DMA_0_Bus_Mode_FB_P)
+#define ETH_DMA_0_Bus_Mode_RPBL                 (1<<ETH_DMA_0_Bus_Mode_RPBL_P)
+#define ETH_DMA_0_Bus_Mode_USP                  (1<<ETH_DMA_0_Bus_Mode_USP_P)
+#define ETH_DMA_0_Bus_Mode_4xPBL                (1<<ETH_DMA_0_Bus_Mode_4xPBL_P)
+#define ETH_DMA_0_Bus_Mode_AAL                  (1<<ETH_DMA_0_Bus_Mode_AAL_P)
+
+/* ETH_DMA_1_Tr_Poll_Demand */
+#define ETH_DMA_1_Tr_Poll_Demand_P              0
+
+/* ETH_DMA_2_Re_Poll_Demand */
+#define ETH_DMA_2_Re_Poll_Demand_P              0
+
+/* ETH_DMA_3_Re_Descriptor_List_Addr */
+#define ETH_DMA_3_Re_Descriptor_List_Addr_P     0
+
+/* ETH_DMA_4_Tr_Descriptor_List_Addr */
+#define ETH_DMA_4_Tr_Descriptor_List_Addr_P     0
+
+/* ETH_DMA_5_Status */
+#define ETH_DMA_5_Status_TI_P                   0
+#define ETH_DMA_5_Status_TPS_P                  1
+#define ETH_DMA_5_Status_TU_P                   2
+#define ETH_DMA_5_Status_TJT_P                  3
+#define ETH_DMA_5_Status_OVF_P                  4
+#define ETH_DMA_5_Status_UNF_P                  5
+#define ETH_DMA_5_Status_RI_P                   6
+#define ETH_DMA_5_Status_RU_P                   7
+#define ETH_DMA_5_Status_RPS_P                  8
+#define ETH_DMA_5_Status_RWP_P                  9
+#define ETH_DMA_5_Status_ETI_P                  10
+#define ETH_DMA_5_Status_FBI_P                  13
+#define ETH_DMA_5_Status_ERI_P                  14
+#define ETH_DMA_5_Status_AIS_P                  15
+#define ETH_DMA_5_Status_NIS_P                  16
+#define ETH_DMA_5_Status_RS_P                   17
+#define ETH_DMA_5_Status_TS_P                   20
+#define ETH_DMA_5_Status_EB_P                   23
+#define ETH_DMA_5_Status_GLI_P                  26
+#define ETH_DMA_5_Status_GMI_P                  27
+#define ETH_DMA_5_Status_GPI_P                  28
+
+#define ETH_DMA_5_Status_TI                     (1<<ETH_DMA_5_Status_TI_P)
+#define ETH_DMA_5_Status_TPS                    (1<<ETH_DMA_5_Status_TPS_P)
+#define ETH_DMA_5_Status_TU                     (1<<ETH_DMA_5_Status_TU_P)
+#define ETH_DMA_5_Status_TJT                    (1<<ETH_DMA_5_Status_TJT_P)
+#define ETH_DMA_5_Status_OVF                    (1<<ETH_DMA_5_Status_OVF_P)
+#define ETH_DMA_5_Status_UNF                    (1<<ETH_DMA_5_Status_UNF_P)
+#define ETH_DMA_5_Status_RI                     (1<<ETH_DMA_5_Status_RI_P)
+#define ETH_DMA_5_Status_RU                     (1<<ETH_DMA_5_Status_RU_P)
+#define ETH_DMA_5_Status_RPS                    (1<<ETH_DMA_5_Status_RPS_P)
+#define ETH_DMA_5_Status_RWP                    (1<<ETH_DMA_5_Status_RWP_P)
+#define ETH_DMA_5_Status_ETI                    (1<<ETH_DMA_5_Status_ETI_P)
+#define ETH_DMA_5_Status_FBI                    (1<<ETH_DMA_5_Status_FBI_P)
+#define ETH_DMA_5_Status_ERI                    (1<<ETH_DMA_5_Status_ERI_P)
+#define ETH_DMA_5_Status_AIS                    (1<<ETH_DMA_5_Status_AIS_P)
+#define ETH_DMA_5_Status_NIS                    (1<<ETH_DMA_5_Status_NIS_P)
+#define ETH_DMA_5_Status_RS                     (1<<ETH_DMA_5_Status_RS_P)
+#define ETH_DMA_5_Status_TS_STOP                (0<<ETH_DMA_5_Status_TS_P)
+#define ETH_DMA_5_Status_TS_FETCH               (1<<ETH_DMA_5_Status_TS_P)
+#define ETH_DMA_5_Status_TS_WAIT                (2<<ETH_DMA_5_Status_TS_P)
+#define ETH_DMA_5_Status_TS_READ                (3<<ETH_DMA_5_Status_TS_P)
+#define ETH_DMA_5_Status_TS_SUSP                (6<<ETH_DMA_5_Status_TS_P)
+#define ETH_DMA_5_Status_TS_CLS                 (7<<ETH_DMA_5_Status_TS_P)
+#define ETH_DMA_5_Status_EB_TX                  (1<<ETH_DMA_5_Status_EB_P)
+#define ETH_DMA_5_Status_EB_RD                  (1<<(ETH_DMA_5_Status_EB_P+1))
+#define ETH_DMA_5_Status_EB_DES                 (1<<(ETH_DMA_5_Status_EB_P+2))
+#define ETH_DMA_5_Status_GLI                    (1<<ETH_DMA_5_Status_GLI_P)
+#define ETH_DMA_5_Status_GMI                    (1<<ETH_DMA_5_Status_GMI_P)
+#define ETH_DMA_5_Status_GPI                    (1<<ETH_DMA_5_Status_GPI_P)
+
+/* ETH_DMA_6_Operation_Mode */
+#define ETH_DMA_6_Operation_Mode_SR_P           1
+#define ETH_DMA_6_Operation_Mode_OSF_P          2
+#define ETH_DMA_6_Operation_Mode_RTC_P          3
+#define ETH_DMA_6_Operation_Mode_FUF_P          6
+#define ETH_DMA_6_Operation_Mode_FEF_P          7
+#define ETH_DMA_6_Operation_Mode_EFC_P          8
+#define ETH_DMA_6_Operation_Mode_RFA_P          9
+#define ETH_DMA_6_Operation_Mode_RFD_P          11
+#define ETH_DMA_6_Operation_Mode_ST_P           13
+#define ETH_DMA_6_Operation_Mode_TTC_P          14
+#define ETH_DMA_6_Operation_Mode_FTF_P          20
+#define ETH_DMA_6_Operation_Mode_TSF_P          21
+#define ETH_DMA_6_Operation_Mode_RFD2_P         22
+#define ETH_DMA_6_Operation_Mode_RFA2_P         23
+#define ETH_DMA_6_Operation_Mode_DFF_P          24
+#define ETH_DMA_6_Operation_Mode_RSF_P          25
+#define ETH_DMA_6_Operation_Mode_DT_P           26
+
+#define ETH_DMA_6_Operation_Mode_SR             (1<<ETH_DMA_6_Operation_Mode_SR_P)
+#define ETH_DMA_6_Operation_Mode_OSF            (1<<ETH_DMA_6_Operation_Mode_OSF_P)
+#define ETH_DMA_6_Operation_Mode_RTC_64         (0<<ETH_DMA_6_Operation_Mode_RTC_P)
+#define ETH_DMA_6_Operation_Mode_RTC_32         (1<<ETH_DMA_6_Operation_Mode_RTC_P)
+#define ETH_DMA_6_Operation_Mode_RTC_96         (2<<ETH_DMA_6_Operation_Mode_RTC_P)
+#define ETH_DMA_6_Operation_Mode_RTC_128        (3<<ETH_DMA_6_Operation_Mode_RTC_P)
+#define ETH_DMA_6_Operation_Mode_FUF            (1<<ETH_DMA_6_Operation_Mode_FUF_P)
+#define ETH_DMA_6_Operation_Mode_FEF            (1<<ETH_DMA_6_Operation_Mode_FEF_P)
+#define ETH_DMA_6_Operation_Mode_EFC            (1<<ETH_DMA_6_Operation_Mode_EFC_P)
+#define ETH_DMA_6_Operation_Mode_RFA_1K         (0<<ETH_DMA_6_Operation_Mode_RFA_P)
+#define ETH_DMA_6_Operation_Mode_RFA_2K         (1<<ETH_DMA_6_Operation_Mode_RFA_P)
+#define ETH_DMA_6_Operation_Mode_RFA_3K         (2<<ETH_DMA_6_Operation_Mode_RFA_P)
+#define ETH_DMA_6_Operation_Mode_RFA_4K         (3<<ETH_DMA_6_Operation_Mode_RFA_P)
+#define ETH_DMA_6_Operation_Mode_RFD_1K         (0<<ETH_DMA_6_Operation_Mode_RFD_P)
+#define ETH_DMA_6_Operation_Mode_RFD_2K         (1<<ETH_DMA_6_Operation_Mode_RFD_P)
+#define ETH_DMA_6_Operation_Mode_RFD_3K         (2<<ETH_DMA_6_Operation_Mode_RFD_P)
+#define ETH_DMA_6_Operation_Mode_RFD_4K         (3<<ETH_DMA_6_Operation_Mode_RFD_P)
+#define ETH_DMA_6_Operation_Mode_ST             (1<<ETH_DMA_6_Operation_Mode_ST_P)
+#define ETH_DMA_6_Operation_Mode_TTC_64         (0<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_TTC_128        (1<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_TTC_192        (2<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_TTC_256        (3<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_TTC_40         (4<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_TTC_32         (5<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_TTC_24         (6<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_TTC_16         (7<<ETH_DMA_6_Operation_Mode_TTC_P)
+#define ETH_DMA_6_Operation_Mode_FTF            (1<<ETH_DMA_6_Operation_Mode_FTF_P)
+#define ETH_DMA_6_Operation_Mode_TSF            (1<<ETH_DMA_6_Operation_Mode_TSF_P)
+#define ETH_DMA_6_Operation_Mode_RFD2           (1<<ETH_DMA_6_Operation_Mode_RFD2_P)
+#define ETH_DMA_6_Operation_Mode_RFA2           (1<<ETH_DMA_6_Operation_Mode_RFA2_P)
+#define ETH_DMA_6_Operation_Mode_DFF            (1<<ETH_DMA_6_Operation_Mode_DFF_P)
+#define ETH_DMA_6_Operation_Mode_RSF            (1<<ETH_DMA_6_Operation_Mode_RSF_P)
+#define ETH_DMA_6_Operation_Mode_DT             (1<<ETH_DMA_6_Operation_Mode_DT_P)
+
+/* ETH_DMA_7_Interrupt_Enable */
+#define ETH_DMA_7_Interrupt_Enable_TIE_P        0
+#define ETH_DMA_7_Interrupt_Enable_TSE_P        1
+#define ETH_DMA_7_Interrupt_Enable_TUE_P        2
+#define ETH_DMA_7_Interrupt_Enable_TJE_P        3
+#define ETH_DMA_7_Interrupt_Enable_OVE_P        4
+#define ETH_DMA_7_Interrupt_Enable_UNE_P        5
+#define ETH_DMA_7_Interrupt_Enable_RIE_P        6
+#define ETH_DMA_7_Interrupt_Enable_RUE_P        7
+#define ETH_DMA_7_Interrupt_Enable_RSE_P        8
+#define ETH_DMA_7_Interrupt_Enable_RWE_P        9
+#define ETH_DMA_7_Interrupt_Enable_ETE_P        10
+#define ETH_DMA_7_Interrupt_Enable_FBE_P        13
+#define ETH_DMA_7_Interrupt_Enable_ERE_P        14
+#define ETH_DMA_7_Interrupt_Enable_AIE_P        15
+#define ETH_DMA_7_Interrupt_Enable_NIE_P        16
+
+#define ETH_DMA_7_Interrupt_Enable_TIE          (1<<ETH_DMA_7_Interrupt_Enable_TIE_P)
+#define ETH_DMA_7_Interrupt_Enable_TSE          (1<<ETH_DMA_7_Interrupt_Enable_TSE_P)
+#define ETH_DMA_7_Interrupt_Enable_TUE          (1<<ETH_DMA_7_Interrupt_Enable_TUE_P)
+#define ETH_DMA_7_Interrupt_Enable_TJE          (1<<ETH_DMA_7_Interrupt_Enable_TJE_P)
+#define ETH_DMA_7_Interrupt_Enable_OVE          (1<<ETH_DMA_7_Interrupt_Enable_OVE_P)
+#define ETH_DMA_7_Interrupt_Enable_UNE          (1<<ETH_DMA_7_Interrupt_Enable_UNE_P)
+#define ETH_DMA_7_Interrupt_Enable_RIE          (1<<ETH_DMA_7_Interrupt_Enable_RIE_P)
+#define ETH_DMA_7_Interrupt_Enable_RUE          (1<<ETH_DMA_7_Interrupt_Enable_RUE_P)
+#define ETH_DMA_7_Interrupt_Enable_RSE          (1<<ETH_DMA_7_Interrupt_Enable_RSE_P)
+#define ETH_DMA_7_Interrupt_Enable_RWE          (1<<ETH_DMA_7_Interrupt_Enable_RWE_P)
+#define ETH_DMA_7_Interrupt_Enable_ETE          (1<<ETH_DMA_7_Interrupt_Enable_ETE_P)
+#define ETH_DMA_7_Interrupt_Enable_FBE          (1<<ETH_DMA_7_Interrupt_Enable_FBE_P)
+#define ETH_DMA_7_Interrupt_Enable_ERE          (1<<ETH_DMA_7_Interrupt_Enable_ERE_P)
+#define ETH_DMA_7_Interrupt_Enable_AIE          (1<<ETH_DMA_7_Interrupt_Enable_AIE_P)
+#define ETH_DMA_7_Interrupt_Enable_NIE          (1<<ETH_DMA_7_Interrupt_Enable_NIE_P)
+
+/* ETH_MAC_0_Configuration */
+#define ETH_MAC_0_Configuration_RE_P            2
+#define ETH_MAC_0_Configuration_TE_P            3
+#define ETH_MAC_0_Configuration_DC_P            4
+#define ETH_MAC_0_Configuration_BL_P            5
+#define ETH_MAC_0_Configuration_ACS_P           7
+#define ETH_MAC_0_Configuration_LUD_P           8
+#define ETH_MAC_0_Configuration_DR_P            9
+#define ETH_MAC_0_Configuration_IPC_P           10
+#define ETH_MAC_0_Configuration_DM_P            11
+#define ETH_MAC_0_Configuration_LM_P            12
+#define ETH_MAC_0_Configuration_DO_P            13
+#define ETH_MAC_0_Configuration_FES_P           14
+#define ETH_MAC_0_Configuration_PS_P            15
+#define ETH_MAC_0_Configuration_DCRS_P          16
+#define ETH_MAC_0_Configuration_IFG_P           17
+#define ETH_MAC_0_Configuration_JE_P            20
+#define ETH_MAC_0_Configuration_BE_P            21
+#define ETH_MAC_0_Configuration_JD_P            22
+#define ETH_MAC_0_Configuration_WD_P            23
+#define ETH_MAC_0_Configuration_TC_P            24
+
+#define ETH_MAC_0_Configuration_RE              (1<<ETH_MAC_0_Configuration_RE_P)
+#define ETH_MAC_0_Configuration_TE              (1<<ETH_MAC_0_Configuration_TE_P)
+#define ETH_MAC_0_Configuration_DC              (1<<ETH_MAC_0_Configuration_DC_P)
+#define ETH_MAC_0_Configuration_BL              (1<<ETH_MAC_0_Configuration_BL_P)
+#define ETH_MAC_0_Configuration_ACS             (1<<ETH_MAC_0_Configuration_ACS_P)
+#define ETH_MAC_0_Configuration_LUD             (1<<ETH_MAC_0_Configuration_LUD_P)
+#define ETH_MAC_0_Configuration_DR              (1<<ETH_MAC_0_Configuration_DR_P)
+#define ETH_MAC_0_Configuration_IPC             (1<<ETH_MAC_0_Configuration_IPC_P)
+#define ETH_MAC_0_Configuration_DM              (1<<ETH_MAC_0_Configuration_DM_P)
+#define ETH_MAC_0_Configuration_LM              (1<<ETH_MAC_0_Configuration_LM_P)
+#define ETH_MAC_0_Configuration_DO              (1<<ETH_MAC_0_Configuration_DO_P)
+#define ETH_MAC_0_Configuration_FES_10M         (0<<ETH_MAC_0_Configuration_FES_P)
+#define ETH_MAC_0_Configuration_FES_100M        (1<<ETH_MAC_0_Configuration_FES_P)
+#define ETH_MAC_0_Configuration_PS_GMII         (0<<ETH_MAC_0_Configuration_PS_P)
+#define ETH_MAC_0_Configuration_PS_MII          (1<<ETH_MAC_0_Configuration_PS_P)
+#define ETH_MAC_0_Configuration_DCRS            (1<<ETH_MAC_0_Configuration_DCRS_P)
+#define ETH_MAC_0_Configuration_IFG             (1<<ETH_MAC_0_Configuration_IFG_P)
+#define ETH_MAC_0_Configuration_JE              (1<<ETH_MAC_0_Configuration_JE_P)
+#define ETH_MAC_0_Configuration_BE              (1<<ETH_MAC_0_Configuration_BE_P)
+#define ETH_MAC_0_Configuration_JD              (1<<ETH_MAC_0_Configuration_JD_P)
+#define ETH_MAC_0_Configuration_WD              (1<<ETH_MAC_0_Configuration_WD_P)
+#define ETH_MAC_0_Configuration_TC              (1<<ETH_MAC_0_Configuration_TC_P)
+
+/* ETH_MAC_1_Frame_Filter */
+#define ETH_MAC_1_Frame_Filter_PR_P             0
+#define ETH_MAC_1_Frame_Filter_HUC_P            1
+#define ETH_MAC_1_Frame_Filter_HMC_P            2
+#define ETH_MAC_1_Frame_Filter_DAIF_P           3
+#define ETH_MAC_1_Frame_Filter_PM_P             4
+#define ETH_MAC_1_Frame_Filter_DBF_P            5
+#define ETH_MAC_1_Frame_Filter_PCF_P            6
+#define ETH_MAC_1_Frame_Filter_SAIF_P           8
+#define ETH_MAC_1_Frame_Filter_SAF_P            9
+#define ETH_MAC_1_Frame_Filter_HPF_P            10
+#define ETH_MAC_1_Frame_Filter_RA_P             31
+
+#define ETH_MAC_1_Frame_Filter_PR               (1<<ETH_MAC_1_Frame_Filter_PR_P)
+#define ETH_MAC_1_Frame_Filter_HUC              (1<<ETH_MAC_1_Frame_Filter_HUC_P)
+#define ETH_MAC_1_Frame_Filter_HMC              (1<<ETH_MAC_1_Frame_Filter_HMC_P)
+#define ETH_MAC_1_Frame_Filter_DAIF             (1<<ETH_MAC_1_Frame_Filter_DAIF_P)
+#define ETH_MAC_1_Frame_Filter_PM               (1<<ETH_MAC_1_Frame_Filter_PM_P)
+#define ETH_MAC_1_Frame_Filter_DBF              (1<<ETH_MAC_1_Frame_Filter_DBF_P)
+#define ETH_MAC_1_Frame_Filter_PCF              (1<<ETH_MAC_1_Frame_Filter_PCF_P)
+#define ETH_MAC_1_Frame_Filter_SAIF             (1<<ETH_MAC_1_Frame_Filter_SAIF_P)
+#define ETH_MAC_1_Frame_Filter_SAF              (1<<ETH_MAC_1_Frame_Filter_SAF_P)
+#define ETH_MAC_1_Frame_Filter_HPF              (1<<ETH_MAC_1_Frame_Filter_HPF_P)
+#define ETH_MAC_1_Frame_Filter_RA               (1<<ETH_MAC_1_Frame_Filter_RA_P)
+
+/* ETH_MAC_4_GMII_Addr */
+#define ETH_MAC_4_GMII_Addr_GB_P                0
+#define ETH_MAC_4_GMII_Addr_GW_P                1
+#define ETH_MAC_4_GMII_Addr_CR_P                2
+#define ETH_MAC_4_GMII_Addr_GR_P                6
+#define ETH_MAC_4_GMII_Addr_PA_P                11
+
+#define ETH_MAC_4_GMII_Addr_GB                  (1<<ETH_MAC_4_GMII_Addr_GB_P)
+#define ETH_MAC_4_GMII_Addr_GW                  (1<<ETH_MAC_4_GMII_Addr_GW_P)
+#define ETH_MAC_4_GMII_Addr_CR_60_100           (0<<ETH_MAC_4_GMII_Addr_CR_P)
+#define ETH_MAC_4_GMII_Addr_CR_100_150          (1<<ETH_MAC_4_GMII_Addr_CR_P)
+#define ETH_MAC_4_GMII_Addr_CR_20_35            (2<<ETH_MAC_4_GMII_Addr_CR_P)
+#define ETH_MAC_4_GMII_Addr_CR_35_60            (3<<ETH_MAC_4_GMII_Addr_CR_P)
+#define ETH_MAC_4_GMII_Addr_CR_150_250          (4<<ETH_MAC_4_GMII_Addr_CR_P)
+#define ETH_MAC_4_GMII_Addr_CR_250_300          (5<<ETH_MAC_4_GMII_Addr_CR_P)
+
+
+
+
+
+
+
+
+
+
+struct _tx_desc {
+    unsigned int tdes0;
+    unsigned int tdes1;
+    unsigned int tdes2;
+    unsigned int tdes3;
+    unsigned int reverse[4];//for 32 bytes cahce aligned
+} ;
+
+struct _rx_desc {
+    unsigned int rdes0;
+    unsigned int rdes1;
+    unsigned int rdes2;
+    unsigned int rdes3;
+    unsigned int reverse[4];//for 32 bytes cahce aligned
+} ;
+
+
+struct _gStruct{
+  // struct netif e8218_netif;
+   struct _rx_desc* rx;
+   struct _tx_desc* tx;
+   int current_rx_des;
+   int current_tx_des;
+   int rx_len;  //64desc
+   int tx_len;  //64desc
+   int buffer_len; //64bytes
+   unsigned long tx_buf_addr;//0x00C21000
+   unsigned long rx_buf_addr;//0x00C23000
+   unsigned long rx_addr; //0x00C20100
+   unsigned long tx_addr; //0x00C20000
+   int rx_frame_num;
+   int current_tx_ready;
+   int last_tx_sent;
+   int last_tx_desc_num;
+   int irq_handle;
+   int  linked;
+};
+
+
+/* Mtu */
+
+#define ETH_MTU				1500
+
+#define CTX_BUFFER_NUM		32
+#define CRX_BUFFER_NUM		48
+#define CBUFFER_SIZE		1536
+
+/* Size of RX buffers, min = 0 (pointless) max = 2048 (MAX_RX_BUFFER_LEN)
+ * MAC reference manual recommends a value slightly greater than the
+ * maximum size of the packet expected other wise it will chain
+ * a zero size buffer desc if a packet of exactly RX_BUFFER_LEN comes.
+ * VMAC will chain buffers if a packet bigger than this arrives.
+ */
+#define RX_BUFFER_LEN	(ETH_FRAME_LEN + 4)
+
+#define MAX_RX_BUFFER_LEN	0x800	/* 2^11 = 2048 = 0x800 */
+#define MAX_TX_BUFFER_LEN	0x800	/* 2^11 = 2048 = 0x800 */
+
+
+/* 14 bytes of ethernet header, 8 bytes pad to prevent buffer chaining
+ * of maximum sized ethernet packets (1514 bytes)
+ */
+#define	VMAC_BUFFER_PAD ETH_HLEN + 8
+
+
+
+
+
+
+/*
+ * ********************************************************
+ *	A description of the Enthernet DMA Dtion
+ * ********************************************************
+ */
+/* Receive Descriptor 0 */
+#define RDES0_MCE_P						0
+#define RDES0_CE_P						1
+#define RDES0_DBE_P						2
+#define RDES0_RE_P						3
+#define RDES0_RWT_P						4
+#define RDES0_FT_P						5
+#define RDES0_LC_P						6
+#define RDES0_IPC_P						7
+#define RDES0_LS_P						8
+#define RDES0_FS_P						9
+#define RDES0_VLAN_P					10
+#define RDES0_OE_P						11
+#define RDES0_LE_P						12
+#define RDES0_SAF_P						13
+#define RDES0_DE_P						14
+#define RDES0_ES_P						15
+#define RDES0_FL_P						16
+#define RDES0_AFM_P						30
+#define RDES0_OWN_P						31
+
+#define RDES0_MCE						(1<<RDES0_MCE_P)
+#define RDES0_CE						(1<<RDES0_CE_P)
+#define RDES0_DBE						(1<<RDES0_DBE_P)
+#define RDES0_RE						(1<<RDES0_RE_P)
+#define RDES0_RWT   					(1<<RDES0_RWT_P)
+#define RDES0_FT						(1<<RDES0_FT_P)
+#define RDES0_LC						(1<<RDES0_LC_P)
+#define RDES0_IPC   					(1<<RDES0_IPC_P)
+#define RDES0_LS						(1<<RDES0_LS_P)
+#define RDES0_FS						(1<<RDES0_FS_P)
+#define RDES0_VLAN  					(1<<RDES0_VLAN_P)
+#define RDES0_OE						(1<<RDES0_OE_P)
+#define RDES0_LE						(1<<RDES0_LE_P)
+#define RDES0_SAF   					(1<<RDES0_SAF_P)
+#define RDES0_DE						(1<<RDES0_DE_P)
+#define RDES0_ES						(1<<RDES0_ES_P)
+#define RDES0_FL_MASK					(0x3fff<<RDES0_FL_P)
+#define RDES0_AFM   					(1<<RDES0_AFM_P)
+#define RDES0_OWN   					(1<<RDES0_OWN_P)
+
+/* Receive Descriptor 1 */
+#define RDES1_RBS1_P					0
+#define RDES1_RBS2_P					11
+#define RDES1_RCH_P						24
+#define RDES1_RER_P						25
+#define RDES1_DIC_P						31
+
+#define RDES1_RBS1_MASK					(0x7ff<<RDES1_RBS1_P)
+#define RDES1_RBS2_MASK					(0x7ff<<RDES1_RBS2_P)
+#define RDES1_RCH						(1<<RDES1_RCH_P)
+#define RDES1_RER						(1<<RDES1_RER_P)
+#define RDES1_DIC						(1<<RDES1_DIC_P)
+
+/* Receive Descriptor 2: Buffer 1 Address Pointer */
+/* Receive Descriptor 3: Buffer 2 Address Pointer */
+
+/* Transmit Descriptor 0 */
+#define TDES0_DB_P						0
+#define TDES0_UF_P						1
+#define TDES0_ED_P						2
+#define TDES0_CC_P						3
+#define TDES0_VF_P						7
+#define TDES0_EC_P						8
+#define TDES0_LTC_P						9
+#define TDES0_NC_P						10
+#define TDES0_LOC_P						11
+#define TDES0_PCE_P						12
+#define TDES0_FF_P						13
+#define TDES0_JT_P						14
+#define TDES0_ES_P						15
+#define TDES0_IHE_P						16
+#define TDES0_OWN_P						31
+
+#define TDES0_DB						(1<<TDES0_DB_P)
+#define TDES0_UF						(1<<TDES0_UF_P)
+#define TDES0_ED						(1<<TDES0_ED_P)
+#define TDES0_CC_MASK					(0xf<<TDES0_CC_P)
+#define TDES0_VF						(1<<TDES0_VF_P)
+#define TDES0_EC						(1<<TDES0_EC_P)
+#define TDES0_LTC						(1<<TDES0_LTC_P)
+#define TDES0_NC						(1<<TDES0_NC_P)
+#define TDES0_LOC						(1<<TDES0_LOC_P)
+#define TDES0_PCE						(1<<TDES0_PCE_P)
+#define TDES0_FF						(1<<TDES0_FF_P)
+#define TDES0_JT						(1<<TDES0_JT_P)
+#define TDES0_ES						(1<<TDES0_ES_P)
+#define TDES0_IHE						(1<<TDES0_IHE_P)
+#define TDES0_OWN						(1<<TDES0_OWN_P)
+
+/* Transmit Descriptor 1 */
+#define TDES1_TBS1_P					0
+#define TDES1_TBS2_P					11
+#define TDES1_DP_P						23
+#define TDES1_TCH_P						24
+#define TDES1_TER_P						25
+#define TDES1_DC_P						26
+#define TDES1_CIC_P						27
+#define TDES1_FS_P						29
+#define TDES1_LS_P						30
+#define TDES1_IC_P						31
+
+#define TDES1_TBS1_MASK					(0x7ff<<TDES1_TBS1_P)
+#define TDES1_TBS2_MASK					(0x7ff<<TDES1_TBS2_P)
+#define TDES1_DP						(1<<TDES1_DP_P)
+#define TDES1_TCH						(1<<TDES1_TCH_P)
+#define TDES1_TER						(1<<TDES1_TER_P)
+#define TDES1_DC						(1<<TDES1_DC_P)
+#define TDES1_CIC						(1<<TDES1_CIC_P)
+#define TDES1_FS						(1<<TDES1_FS_P)
+#define TDES1_LS						(1<<TDES1_LS_P)
+#define TDES1_IC						(1<<TDES1_IC_P)
+
+/* Transmit Descriptor 2: Buffer 1 Address Pointer */
+/* Transmit Descriptor 3: Buffer 2 Address Pointer */
+
+#define CACHE_LINE_LENGTH 0x20
+#define CACHE_LINE_MASK   0xffffffe0
+
+
+
+#endif /*__AML_ETH_REG_H__*/
diff --git a/drivers/net/aml_ethernet.c b/drivers/net/aml_ethernet.c
new file mode 100644
index 0000000..36ecff2
--- /dev/null
+++ b/drivers/net/aml_ethernet.c
@@ -0,0 +1,1633 @@
+
+/*
+ * drivers/net/aml_ethernet.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <linux/types.h>
+#include <config.h>
+#include <malloc.h>
+#include <common.h>
+#include <net.h>
+#include <asm/u-boot.h>
+#include <asm/cache.h>
+
+/**
+ * Amlogic mason headers
+ *
+ * arch/arm/include/asm/arch-m*
+ */
+#include <asm/arch/io.h>
+#include "aml_eth_reg.h"
+#include "aml_phy_8700.h"
+#include <asm/arch/secure_apb.h>
+
+
+
+#define	aml_eth_readl(x)			(readl((x)&0xffffffffL)&0xffffffffL)
+#define	aml_eth_writel(val,addr)	(writel(((val)&0xffffffffL),((addr)&0xffffffffL)))
+#define AML_READ_CBUS_REG(reg)
+/**
+ * arch/arm/cpu/aml_meson
+ *
+ */
+
+#define NET_DMA_BUFFER_SIZE	0x20000
+
+static unsigned char g_bi_enetaddr[6] = {0, 0, 0, 0, 0, 0};
+static struct _gStruct*	gS = NULL;
+static struct _rx_desc*	g_rx = NULL;
+static struct _tx_desc*	g_tx = NULL;
+static struct _rx_desc*	g_current_rx = NULL;
+static struct _tx_desc*	g_current_tx = NULL;
+static int g_nInitialized = 0 ;
+static unsigned int g_phy_Identifier = 0;
+static unsigned int   g_speed_enforce=0;
+static unsigned int  g_mdc_clock_range=ETH_MAC_4_GMII_Addr_CR_100_150;
+#define PHY_SMSC_8700			0x7c0c4
+#define PHY_SMSC_8720			0x7c0f1
+#define PHY_ATHEROS_8032		0x004dd023
+#define PHY_ATHEROS_8035		0x004dd072
+#define PHY_IC_IP101ALF         0x02430c54
+#define PHY_MICREL_8091         0x221560
+#define PHY_INTERNAL            0x79898963
+#define PHY_RTL_8211F         0x001cc916
+#define PHY_MICREL_KSZ9031    0x00221620
+#define PHY_MICREL_KSZ9031RNX 0x00221622
+#define MAC_MODE_RMII_CLK_EXTERNAL       0
+#define MAC_MODE_RMII_CLK_INTERNAL       1
+#define MAC_MODE_RGMII                   2
+static int g_mac_mode = MAC_MODE_RGMII;
+
+static int g_debug = 0;
+//#define ET_DEBUG
+/*
+M6TV
+ 23
+M6TVlite
+ 24
+M8
+ 25
+M6TVd
+ 26
+M8baby
+ 27
+G9TV
+ 28
+*/
+static unsigned int get_cpuid(void){
+	return READ_CBUS_REG(0x1f53)&0xff;
+}
+#ifdef INTERNAL_PHY
+#define  SMI_ADDR_TSTCNTL     20
+#define  SMI_ADDR_TSTREAD1    21
+#define  SMI_ADDR_TSTREAD2    22
+#define  SMI_ADDR_TSTWRITE    23
+
+#define  WR_ADDR_A0CFG        0x11
+#define  WR_ADDR_A1CFG        0x12
+#define  WR_ADDR_A2CFG        0x13
+#define  WR_ADDR_A3CFG        0x14
+#define  WR_ADDR_A4CFG        0x15
+#define  WR_ADDR_A5CFG        0x16
+#define  WR_ADDR_A6CFG        0x17
+#define  WR_ADDR_A7CFG        0x18
+#define  WR_ADDR_A8CFG        0x1a
+#define  WR_ADDR_A9CFG        0x1b
+#define  WR_ADDR_A10CFG       0x1c
+#define  WR_ADDR_A11CFG       0x1d
+
+#define  RD_ADDR_A3CFG        (0x14 << 5)
+#define  RD_ADDR_A4CFG        (0x15 << 5)
+#define  RD_ADDR_A5CFG        (0x16 << 5)
+#define  RD_ADDR_A6CFG        (0x17 << 5)
+
+#define  TSTCNTL_RD           ((1 << 15) | (1 << 10))
+#define  TSTCNTL_WR           ((1 << 14) | (1 << 10))
+#endif
+
+/*
+
+*/
+
+static void hardware_reset(void)
+{
+	/* PHY hardware reset */
+	/*
+	if (get_cpuid() == 0x16) {
+		CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO5_O, 1 << 15);
+		udelay(500000);
+		SET_CBUS_REG_MASK(PREG_PAD_GPIO5_O, 1 << 15);
+	}
+	if (get_cpuid() == 0x19) {
+		CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO1_O, 1 << 31);
+		udelay(500000);
+		SET_CBUS_REG_MASK(PREG_PAD_GPIO1_O, 1 << 31);
+	}
+	if (get_cpuid() == 0x1b) { // m8b  It is not known when the chips to change //27
+		CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO3_O, 1 << 23);
+		udelay(500000);
+		SET_CBUS_REG_MASK(PREG_PAD_GPIO3_O, 1 << 23);
+	}*/
+	if (get_cpuid() == 0x1f) { // s905
+		clrbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+		udelay(500000);
+		setbits_le32(PREG_PAD_GPIO3_O, 1 << 14);
+	}
+	printf("ETH PHY hardware reset OK\n");
+
+	return;
+}
+static void phy_reg_wr(int phyad, unsigned int reg, unsigned int val)
+{
+	unsigned long busy = 0, tmp = 0;
+	unsigned int phyaddr;
+	unsigned int phyreg;
+	unsigned long reg4;
+
+	phyaddr = phyad << ETH_MAC_4_GMII_Addr_PA_P;
+	phyreg  = reg << ETH_MAC_4_GMII_Addr_GR_P;
+
+	reg4 = phyaddr | phyreg | g_mdc_clock_range | ETH_MAC_4_GMII_Addr_GW | ETH_MAC_4_GMII_Addr_GB;
+	aml_eth_writel(val, ETH_MAC_5_GMII_Data);
+	aml_eth_writel(reg4, ETH_MAC_4_GMII_Addr);
+	busy = 1;
+	while (busy) {
+		tmp = aml_eth_readl(ETH_MAC_4_GMII_Addr);
+		busy = tmp & 1;
+	}
+}
+
+static unsigned int phy_reg_rd(int phyad, unsigned int reg)
+{
+	unsigned long busy = 0, tmp = 0;
+	unsigned int phyaddr;
+	unsigned int phyreg;
+	unsigned long reg4;
+
+	phyaddr = phyad << ETH_MAC_4_GMII_Addr_PA_P;
+	phyreg  = reg << ETH_MAC_4_GMII_Addr_GR_P;
+	reg4 = phyaddr | phyreg | g_mdc_clock_range | ETH_MAC_4_GMII_Addr_GB;
+	aml_eth_writel(reg4, ETH_MAC_4_GMII_Addr);
+
+	busy = 1;
+	while (busy) {
+		tmp = aml_eth_readl(ETH_MAC_4_GMII_Addr);
+		busy = tmp & 1;
+	}
+
+	tmp = aml_eth_readl(ETH_MAC_5_GMII_Data);
+
+	return tmp;
+}
+#ifdef INTERNAL_PHY
+static void initTSTMODE(int phyad)
+{
+	phy_reg_wr(phyad, SMI_ADDR_TSTCNTL, 0x0400);
+	phy_reg_wr(phyad, SMI_ADDR_TSTCNTL, 0x0000);
+	phy_reg_wr(phyad, SMI_ADDR_TSTCNTL, 0x0400);
+
+}
+
+static void closeTSTMODE(int phyad)
+{
+	phy_reg_wr(phyad, SMI_ADDR_TSTCNTL, 0x0000);
+
+}
+
+
+static void init_internal_phy(int phyad)
+{
+        initTSTMODE(phyad);
+        // write tstcntl addr val
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x1354);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR);//write addr 0
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x38);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A0CFG);//write addr 0x11
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x0c00);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A1CFG);//write addr 0x12
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x3e00);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A2CFG);//write addr 0x13
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0xf902);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A3CFG);//write addr 0x14
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x3412);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A4CFG);//write addr 0x15
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x2636);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A5CFG);//write addr 0x16
+        phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,3);//write val
+        phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A7CFG);//write addr 0x18
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x108);
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A9CFG);//write addr 0x1b
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0xda00);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A11CFG);//write addr 0x1d
+	closeTSTMODE(phyad);
+}
+
+
+void init_internal_phy_10B(int phyad)
+{
+
+	initTSTMODE(phyad);
+	// write tstcntl addr val
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x0000);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR);//write addr 0
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x38);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A0CFG);//write addr 0x11
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x0c00);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A1CFG);//write addr 0x12
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x3e00);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A2CFG);//write addr 0x13
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0xf902);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A3CFG);//write addr 0x14
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x3412);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A4CFG);//write addr 0x15
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x2236);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A5CFG);//write addr 0x16
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,3);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A7CFG);//write addr 0x18
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x108);//write val by chandle (2)
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A9CFG);//write addr 0x1b
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0xda00);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A11CFG);//write addr 0x1d
+	closeTSTMODE(phyad);
+}
+
+void init_internal_phy_100B(int phyad)
+{
+
+	initTSTMODE(phyad);
+	// write tstcntl addr val
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x9354);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|0x00);//write addr 0x00
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x38);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A0CFG);//write addr 0x11
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x0c00);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A1CFG);//write addr 0x12
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x3e00);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A2CFG);//write addr 0x13
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0xf902);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A3CFG);//write addr 0x14
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x3412);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A4CFG);//write addr 0x15
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0xa406);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A5CFG);//write addr 0x16
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x0003);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A7CFG);//write addr 0x18
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0x00a6);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A9CFG);//write addr 0x1b
+	phy_reg_wr(phyad,SMI_ADDR_TSTWRITE,0xda00);//write val
+	phy_reg_wr(phyad,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A11CFG);//write addr 0x1d
+	closeTSTMODE(phyad);
+}
+#endif
+static inline void _dcache_flush_range_for_net(unsigned long startAddr, unsigned long endAddr)
+{
+	flush_dcache_range(startAddr, endAddr);
+}
+
+static inline void _dcache_inv_range_for_net(unsigned long startAddr, unsigned long endAddr)
+{
+
+	invalidate_dcache_range(startAddr, endAddr);
+}
+
+static unsigned int detect_phyad(void)
+{
+	unsigned int testval = 0;
+	int i;
+	static int s_phyad = -1;
+
+	if (s_phyad != -1) {
+		return s_phyad;
+	}
+	for (i = 0; i < 32; i++) {
+		testval = phy_reg_rd(i, PHY_SR);	//read the SR register..
+		if (testval != 0x0000 && testval != 0xffff) {
+			s_phyad = i;
+			return s_phyad;
+		}
+	}
+	return 0xffff;
+}
+
+static void set_mac_mode(void)
+{
+	printf("set_mac_mode(%d)\n", g_mac_mode);
+	if (g_mac_mode == 2) {
+		/* RGMII */
+		aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration)|(ETH_MAC_0_Configuration_PS_GMII | ETH_MAC_0_Configuration_TC | ETH_MAC_0_Configuration_DM
+					| ETH_MAC_0_Configuration_RE | ETH_MAC_0_Configuration_TE), ETH_MAC_0_Configuration);
+	} else {
+		/* RMII */
+		aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration)|(ETH_MAC_0_Configuration_PS_MII | ETH_MAC_0_Configuration_FES_100M | ETH_MAC_0_Configuration_DM
+					| ETH_MAC_0_Configuration_RE | ETH_MAC_0_Configuration_TE), ETH_MAC_0_Configuration);
+	}
+
+	aml_eth_writel((ETH_MAC_1_Frame_Filter_PM | ETH_MAC_1_Frame_Filter_RA), ETH_MAC_1_Frame_Filter);
+}
+
+static void set_mac_addrs(void *ptr)
+{
+	unsigned int mac_filter = 0;
+	unsigned char * p = (unsigned char *)ptr;
+
+	mac_filter = (p[5] << 8) | p[4];
+	aml_eth_writel(mac_filter, ETH_MAC_Addr0_High);
+	mac_filter = (p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0];
+	aml_eth_writel(mac_filter, ETH_MAC_Addr0_Low);
+}
+
+static void netdev_chk(void)
+{
+	unsigned int rint, rint2;
+	static unsigned int old_rint = -1;
+	unsigned int id;
+	int speed, full;
+
+	speed = full = 0;
+	id = detect_phyad();
+	rint2 = 3000;
+	if (g_speed_enforce)
+	{
+		//printf("use enforce net speed\n");
+		rint=phy_reg_rd(id,PHY_SR);
+
+	}else{
+		do {
+			rint = phy_reg_rd(id, PHY_SR);
+			if ((rint & PHY_SR_ANCOMPLETE)) {
+				break;
+			}
+			udelay(1000);
+		} while (rint2-- > 0);
+		if (!(rint & PHY_SR_ANCOMPLETE)) {
+			printf("phy auto link failed\n");
+		}
+	}
+	if (old_rint != rint) {
+		if (g_debug > 1)
+			printf("netdev_chk() g_phy_Identifier: 0x%x\n", g_phy_Identifier);
+		switch (g_phy_Identifier) {
+			case PHY_ATHEROS_8032:
+				rint2 = phy_reg_rd(id, 17);
+				speed = (rint2 & (1 << 14)) >> 14;
+				full = ((rint2) & (1 << 13));
+				gS->linked = rint2 & (1 << 10);
+				break;
+			case PHY_ATHEROS_8035:
+				rint2 = phy_reg_rd(id, 17);
+				speed = (rint2 & (3 << 14)) >> 14;
+				full = ((rint2) & (1 << 13));
+				gS->linked = rint2 & (1 << 10);
+				break;
+			case PHY_RTL_8211F:
+				rint2 = phy_reg_rd(id, 26);
+				speed = (rint2 & (3 << 4)) >> 4;
+				full = ((rint2) & (1 << 3));
+				rint2 = phy_reg_rd(id,1);
+				gS->linked = rint2&(1<<2);
+				break;
+			case PHY_MICREL_KSZ9031:
+			case PHY_MICREL_KSZ9031RNX:
+				rint2 = phy_reg_rd(id, 31);
+				speed = (rint2 & (1 << 4))? 0:((rint2 &(1<<5))? 1:2);
+				full = ((rint2) & (1 << 3));
+				rint2 = phy_reg_rd(id,1);
+				gS->linked = rint2&(1<<2);
+				break;
+			case PHY_IC_IP101ALF:
+				rint2 = phy_reg_rd(id,1);
+				gS->linked = rint2&(1<<2);
+				rint2 = phy_reg_rd(id,0);
+				speed = (rint2 & (0x1<<8))? 1:0;
+				rint2 = phy_reg_rd(id,5);
+				full = (rint2 & (0x1<<7))? 1:0;
+				break;
+			case PHY_MICREL_8091:
+				rint2 = phy_reg_rd(id,1);
+				gS->linked = rint2&(1<<2);
+				rint2 = phy_reg_rd(id,30);
+				speed = (rint2 & (0x1<<1))? 1:0;
+				rint2 = phy_reg_rd(id,5);
+				full = (rint2 & 0x1)? 1:0;
+				break;
+			case PHY_INTERNAL:
+				rint2 = phy_reg_rd(id, 31);
+				speed = (rint2 & (1 << 3)) >> 3;
+				full = ((rint2 >> 4) & 1);
+				gS->linked = rint2 & (1 << 2);
+				break;
+			case PHY_SMSC_8700:
+			case PHY_SMSC_8720:
+			default:
+				rint2 = phy_reg_rd(id, 31);
+				speed = (rint2 & (1 << 3)) >> 3;
+				full = ((rint2 >> 4) & 1);
+				gS->linked = rint2 & (1 << 2);
+				break;
+		}
+		/* phy_auto_negotiation_set */
+		if (full) {
+			printf("duplex\n");
+			aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration) | ETH_MAC_0_Configuration_DM, ETH_MAC_0_Configuration);
+		} else {
+			printf("half duplex\n");
+			aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration) & ~ ETH_MAC_0_Configuration_DM, ETH_MAC_0_Configuration);
+		}
+		if (speed == 0) {
+			printf("10m\n");
+#ifdef INTERNAL_PHY
+			init_internal_phy_10B(id);
+			int val =0x4100b040;
+			aml_eth_writel(val,ETH_PLL_CNTL);
+#endif
+			aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration) & ~ ETH_MAC_0_Configuration_FES_100M, ETH_MAC_0_Configuration);
+			aml_eth_writel(((aml_eth_readl(ETH_MAC_0_Configuration)) | (ETH_MAC_0_Configuration_PS_MII)), ETH_MAC_0_Configuration);	// program mac
+#ifndef NEW_MAC_LOGIC
+			if ( get_cpuid() < 0x1B ) {
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) & ~ETH_PLL_CNTL_DIVEN, ETH_PLL_CNTL);		// Disable the Ethernet clocks
+				// ---------------------------------------------
+				// Test 50Mhz Input Divide by 2
+				// ---------------------------------------------
+				// Select divide by 20
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) & ~ETH_PLL_CNTL_DESEND, ETH_PLL_CNTL);  	// desc endianess "same order"
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) & ~ETH_PLL_CNTL_DATEND, ETH_PLL_CNTL); 	// data endianess "little"
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) & ~ETH_PLL_CNTL_MACSPD, ETH_PLL_CNTL);	// divide by 20
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) | ETH_PLL_CNTL_DIVEN, ETH_PLL_CNTL);		// enable Ethernet clocks
+			}
+#endif
+		} else if (speed == 1) {
+			printf("100m\n");
+#ifdef INTERNAL_PHY
+			init_internal_phy_100B(id);
+			int val = (8<<27)|(7 << 24)|(1<<16)|(1<<15)|(1 << 13)|(1 << 12)|(4 << 4)|(0 << 1);
+			aml_eth_writel(val,ETH_PLL_CNTL);
+#endif
+			aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration) | ETH_MAC_0_Configuration_FES_100M, ETH_MAC_0_Configuration);	// program mac
+			aml_eth_writel(((aml_eth_readl(ETH_MAC_0_Configuration)) | (ETH_MAC_0_Configuration_PS_MII)), ETH_MAC_0_Configuration);	// program mac
+#ifndef NEW_MAC_LOGIC
+
+			if (get_cpuid()< 0x1B) {
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) & ~ETH_PLL_CNTL_DIVEN, ETH_PLL_CNTL);		// Disable the Ethernet clocks
+				// ---------------------------------------------
+				// Test 50Mhz Input Divide by 2
+				// ---------------------------------------------
+				// Select divide by 2
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) & ~ETH_PLL_CNTL_DESEND, ETH_PLL_CNTL);  	// desc endianess "same order"
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) & ~ETH_PLL_CNTL_DATEND, ETH_PLL_CNTL); 	// data endianess "little"
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) | ETH_PLL_CNTL_MACSPD, ETH_PLL_CNTL);	// divide by 2
+				aml_eth_writel(aml_eth_readl(ETH_PLL_CNTL) | ETH_PLL_CNTL_DIVEN, ETH_PLL_CNTL);		// enable Ethernet clocks
+			}
+#endif
+		} else {
+			printf("1000m\n");
+#if defined(NEW_MAC_LOGIC)
+				aml_eth_writel(((aml_eth_readl(ETH_MAC_0_Configuration)) & (~ETH_MAC_0_Configuration_PS_MII)) | (1<<13), ETH_MAC_0_Configuration);	// program mac
+			aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration) & (~ETH_MAC_0_Configuration_FES_100M), ETH_MAC_0_Configuration);	// program mac
+
+#else
+			if (get_cpuid() >= 0x1B) {
+				aml_eth_writel(((aml_eth_readl(ETH_MAC_0_Configuration)) & (~ETH_MAC_0_Configuration_PS_MII)) | (1<<13), ETH_MAC_0_Configuration);	// program mac
+			aml_eth_writel(aml_eth_readl(ETH_MAC_0_Configuration) & (~ETH_MAC_0_Configuration_FES_100M), ETH_MAC_0_Configuration);	// program mac
+
+			}
+#endif
+		}
+
+		/* link_changed */
+#if defined(ET_DEBUG)
+		unsigned int regs = 0, val;
+		for (regs = 0; regs <= 31; regs++) {
+			val = phy_reg_rd(id, regs);
+			printf("reg[%d]=%x\n", regs, (unsigned)val);
+		}
+#endif
+		old_rint = rint;
+	}
+}
+
+static void set_phy_mode(void)
+{
+	unsigned int phyad = -1;
+	unsigned int val;
+
+	phyad = 1;
+	if (phyad > 32 || phyad < 0) {
+		return;
+	}
+
+	if (g_debug > 1)
+		printf("set_phy_mode() g_phy_Identifier: 0x%x\n", g_phy_Identifier);
+	switch (g_phy_Identifier) {
+		case PHY_ATHEROS_8032:
+		case PHY_ATHEROS_8035:
+		case PHY_RTL_8211F:
+			break;
+		case PHY_MICREL_8091:
+				val = phy_reg_rd(phyad, 0x16);
+			phy_reg_wr(phyad, 0x16, (val & ~(0x8020)));
+			break;
+		case PHY_INTERNAL:
+			break;
+		case PHY_SMSC_8700:
+		case PHY_SMSC_8720:
+			val = PHY_SPMD_MIIMODE_RMII | (PHY_MODE_BUS_ALL_AE << PHY_SPMD_MODE_P) | (phyad << PHY_SPMD_PHYAD_P);
+			phy_reg_wr(phyad, PHY_SPMD, val);
+			break;
+		default:
+			break;
+	}
+}
+
+/* Reset and idle the chip, putting all registers into
+ * a reasonable state */
+static int eth_reset(struct _gStruct* emac_config)
+{
+	int i, k, phyad;
+	unsigned int val,ori_ctl_val=0;
+	struct _gStruct* m=emac_config;
+	if (get_cpuid() >= 0x16) {
+		/* make sure PHY power-on */
+		set_phy_mode();
+	}
+#define NET_MAX_RESET_TEST 1000
+	if (g_speed_enforce) ori_ctl_val=phy_reg_rd(1, PHY_CR) ;
+	for (i = 0; i < NET_MAX_RESET_TEST; i++) {
+		/* Software Reset MAC */
+		aml_eth_writel(ETH_DMA_0_Bus_Mode_SWR, ETH_DMA_0_Bus_Mode);
+		for (k = 0; k < NET_MAX_RESET_TEST; k++) {
+			udelay(100);
+
+			if (!(aml_eth_readl(ETH_DMA_0_Bus_Mode)&ETH_DMA_0_Bus_Mode_SWR)) {
+				break;
+			}
+		}
+		if (k >= NET_MAX_RESET_TEST) {
+			printf("Error: Fail to reset mac!(%d)\n", k);
+			return -1;
+		} else {
+			printf("Success: reset mac OK!(%d)\n", k);
+		}
+
+		udelay(100000);
+		hardware_reset();
+		udelay(100000);
+		phyad = detect_phyad();
+		if (phyad > 32 || phyad < 0) {
+			continue;
+		}
+		/* set phy work mode */
+		/*
+		val = PHY_SPMD_MIIMODE_RMII | (PHY_MODE_BUS_ALL_AE << PHY_SPMD_MODE_P) | (phyad << PHY_SPMD_PHYAD_P);
+		phy_reg_wr(phyad, PHY_SPMD, val);
+		*/
+		/* get phy_Identifier */
+		val = phy_reg_rd(phyad, 2);
+		g_phy_Identifier = val << 16;
+		val = phy_reg_rd(phyad, 3);
+		g_phy_Identifier |= val;
+		printf("find net phy id=0x%x, phyad=%d\n", (unsigned int)g_phy_Identifier, phyad);
+
+		if (g_phy_Identifier == PHY_IC_IP101ALF) {
+			//if(get_cpuid() == 0x16)
+			//	WRITE_CBUS_REG(HHI_ETH_CLK_CNTL, 0x120); // phy ip101 need clock phase normal
+#ifndef NEW_MAC_LOGIC
+			//if(get_cpuid() == 0x19)
+			//	WRITE_CBUS_REG(HHI_ETH_CLK_CNTL, 0xf00); // phy ip101 need clock phase normal
+#endif
+		}
+		/* Software Reset PHY */
+		phy_reg_wr(phyad, PHY_CR, PHY_CR_RST);
+		for (k = 0; k < NET_MAX_RESET_TEST; k++) {
+			udelay(1000);
+			val = phy_reg_rd(phyad, PHY_CR);
+			if (!(val & PHY_CR_RST)) {
+				break;
+			}
+		}
+		if (k >= NET_MAX_RESET_TEST) {
+			continue;
+		} else {
+			break;
+		}
+	}
+	if (i >= NET_MAX_RESET_TEST) {
+		printf("Error to detected phy\n");
+		return -1;
+	}
+#ifdef INTERNAL_PHY
+	init_internal_phy(phyad);
+#endif
+	set_phy_mode();
+	val = PHY_CR_AN | PHY_CR_RSTAN;
+	phy_reg_wr(phyad, PHY_CR, val);
+	if (g_speed_enforce == 1)
+	{
+		while (!(phy_reg_rd(1,1)&(1<<2))) {}; //wait line status stable
+		phy_reg_wr(phyad, PHY_CR, ori_ctl_val);
+		while (!(phy_reg_rd(1,1)&(1<<2))) {}; //wait new state stable
+
+	}
+	udelay(10);
+
+	set_mac_mode();
+
+	aml_eth_writel((~0), ETH_DMA_5_Status);							/* clear all status flag */
+	aml_eth_writel(0, ETH_DMA_5_Status);
+	aml_eth_writel(0, ETH_DMA_6_Operation_Mode);					/* stop RX and TX */
+	val = aml_eth_readl(ETH_DMA_8_Missed_Frame_and_Overflow);		/* read to clean */
+
+	aml_eth_writel(0, ETH_DMA_7_Interrupt_Enable);					/* disable all interrupt */
+	aml_eth_writel((8 << ETH_DMA_0_Bus_Mode_PBL_P) | ETH_DMA_0_Bus_Mode_FB, ETH_DMA_0_Bus_Mode);
+
+	printf("final_addr[rx-tx]: %p-%p\n", m->rx, m->tx);
+	aml_eth_writel((long)m->rx, ETH_DMA_3_Re_Descriptor_List_Addr);
+	aml_eth_writel((long)m->tx, ETH_DMA_4_Tr_Descriptor_List_Addr);
+
+	/* config the interrupt */
+	aml_eth_writel(ETH_DMA_7_Interrupt_Enable_TUE | ETH_DMA_7_Interrupt_Enable_TJE
+			| ETH_DMA_7_Interrupt_Enable_OVE | ETH_DMA_7_Interrupt_Enable_UNE | ETH_DMA_7_Interrupt_Enable_RIE
+			| ETH_DMA_7_Interrupt_Enable_RUE | ETH_DMA_7_Interrupt_Enable_RSE | ETH_DMA_7_Interrupt_Enable_FBE
+			| ETH_DMA_7_Interrupt_Enable_AIE | ETH_DMA_7_Interrupt_Enable_NIE, ETH_DMA_7_Interrupt_Enable);
+	aml_eth_writel(0, ETH_MAC_Interrupt_Mask);
+
+	printf("Ethernet reset OK\n");
+	return 0;
+}
+
+static void DMARXStart(void)
+{
+	aml_eth_writel(aml_eth_readl(ETH_DMA_6_Operation_Mode) | ETH_DMA_6_Operation_Mode_SR, ETH_DMA_6_Operation_Mode);
+}
+
+static void DMATXStart(void)
+{
+	aml_eth_writel(aml_eth_readl(ETH_DMA_6_Operation_Mode) | ETH_DMA_6_Operation_Mode_ST, ETH_DMA_6_Operation_Mode);
+}
+
+static void GetDMAStatus(unsigned int* mask, unsigned  int* status)
+{
+	*mask = aml_eth_readl(ETH_DMA_7_Interrupt_Enable);
+	*status = aml_eth_readl(ETH_DMA_5_Status);
+}
+
+static void eth_data_dump(unsigned char *p, int len)
+{
+	int i, j;
+	char s[20];
+
+	for (i = 0; i < len; i += 16) {
+		printf("%p:", p);
+		for (j = 0; j < 16 && j < (len - i); j++) {
+			s[j] = (p[j] > 15 && p[j] < 128) ? p[j] : '.';
+			printf(" %02x", p[j]);
+		}
+		s[j] = 0;
+		printf(" |%s|\n", s);
+		p = p + 16;
+	}
+}
+
+static void eth_tx_dump(unsigned char *p, int len)
+{
+	if ((g_debug == 2) || (g_debug == 4)) {
+		printf("=====>\n");
+		eth_data_dump(p, len);
+	}
+}
+
+static void eth_rx_dump(unsigned char *p, int len)
+{
+	if ((g_debug == 3) || (g_debug == 4)) {
+		printf("<=====\n");
+		eth_data_dump(p, len);
+	}
+}
+
+static void aml_eth_halt(struct eth_device * net_current)
+{
+	return;
+}
+
+static int aml_eth_send(struct eth_device *net_current, void *packet, int length)
+{
+	unsigned int mask;
+	unsigned int status;
+
+	if (!g_nInitialized) {
+		return -1;
+	}
+
+	eth_tx_dump((unsigned char *)packet, length);
+	netdev_chk();
+
+	struct _tx_desc* pTx = g_current_tx;
+	struct _tx_desc* pDma = (struct _tx_desc*)aml_eth_readl(ETH_DMA_18_Curr_Host_Tr_Descriptor);
+
+	if (pDma != NULL) {
+		_dcache_inv_range_for_net((unsigned long)pDma, (unsigned long)(pDma) + sizeof(struct _tx_desc) - 1);
+	}
+	if (pDma != NULL && !(pDma->tdes0 & TDES0_OWN) && pTx != pDma) {
+		//this may not happend,if all the hardware work well...
+		//to fixed a bug of the dma maybe lost setting some tx buf to own by host,..;
+		//start the current_tx at pDMA
+		pTx = pDma;
+	}
+	if (pDma != pTx) {
+		_dcache_inv_range_for_net((unsigned long)pTx, (unsigned long)(pTx + 1) - 1);
+	}
+
+	if (length > ETH_MTU) {
+		goto err;
+	}
+
+	if (length < 14) {
+		printf("pbuf len error, len=%d\n", length);
+		goto err;
+	}
+
+	if (pTx->tdes0 & TDES0_OWN) {
+#if 1
+		volatile unsigned long Cdma, Dstatus, status;
+		Cdma = aml_eth_readl(ETH_DMA_18_Curr_Host_Tr_Descriptor);
+		Dstatus = aml_eth_readl(Cdma);
+		status = aml_eth_readl(ETH_DMA_5_Status);
+		printf("Current DMA=0x%x, Dstatus=0x%x\n", (unsigned int)Cdma, (unsigned int)Dstatus);
+		printf("Current status=0x%x\n", (unsigned int)status);
+		printf("no buffer to send\n");
+#endif
+		goto err;
+	}
+
+	if (!(unsigned char*)(unsigned long)pTx->tdes2) {
+		goto err;
+	}
+	g_current_tx = (struct _tx_desc*)(unsigned long)pTx->tdes3;
+	memcpy((unsigned char*)(unsigned long)pTx->tdes2, (unsigned char*)packet, length);
+	//pTx->tdes1 &= DescEndOfRing;
+	_dcache_flush_range_for_net((unsigned long)pTx->tdes2, (unsigned long)pTx->tdes2 + length - 1);
+	pTx->tdes1 = ((length << TDES1_TBS1_P) & TDES1_TBS1_MASK) | TDES1_FS | TDES1_LS | TDES1_TCH | TDES1_IC;
+	pTx->tdes0 = TDES0_OWN;
+	_dcache_flush_range_for_net((unsigned long)pTx, (unsigned long)(pTx + 1) - 1);
+
+	GetDMAStatus(&mask, &status);
+	if (status & ETH_DMA_5_Status_TS_SUSP) {
+		aml_eth_writel(1, ETH_DMA_1_Tr_Poll_Demand);
+	} else {
+		DMATXStart();
+	}
+
+#ifdef ET_DEBUG
+	printf("Transfer starting...\n");
+	GetDMAStatus(&mask, &status);
+	printf("Current status=%x\n", status);
+#endif
+
+	/* wait for transfer to succeed */
+	//unsigned tmo = get_timer (0) + 5 * CONFIG_SYS_HZ;		//5S time out
+	unsigned tmo = 0;
+	do {
+		udelay(100);
+		GetDMAStatus(&mask, &status);
+		if (tmo++ >= 50000) {
+			printf("\ntransmission error %#x\n", status);
+			break;
+		}
+	} while (!((status & ETH_DMA_5_Status_NIS) && (status & ETH_DMA_5_Status_TI)));
+
+	if (status & ETH_DMA_5_Status_NIS) {
+		if (status & ETH_DMA_5_Status_TI) {
+			aml_eth_writel(ETH_DMA_5_Status_NIS | ETH_DMA_5_Status_TI, ETH_DMA_5_Status);
+		}
+		if (status & ETH_DMA_5_Status_TU) {
+			aml_eth_writel(ETH_DMA_5_Status_NIS | ETH_DMA_5_Status_TU, ETH_DMA_5_Status);
+		}
+	}
+
+#ifdef ET_DEBUG
+	//test
+	GetDMAStatus(&mask, &status);
+	printf("Current status=%x\n", status);
+#endif
+	return 0;
+err:
+	return -1;
+}
+
+/*
+ * each time receive a whole packet
+ */
+static int aml_eth_rx(struct eth_device * net_current)
+{
+	unsigned int mask;
+	unsigned int status;
+	int rxnum = 0;
+	int len = 0;
+	struct _rx_desc* pRx;
+
+	if (!g_nInitialized) {
+		return -1;
+	}
+
+	netdev_chk();
+
+	/* Check packet ready or not */
+	GetDMAStatus(&mask, &status);
+	if (!((status & ETH_DMA_5_Status_NIS) && (status & ETH_DMA_5_Status_RI))) {
+		return 0;
+	}
+	aml_eth_writel(ETH_DMA_5_Status_NIS | ETH_DMA_5_Status_RI, ETH_DMA_5_Status);	//clear the int flag
+
+	if (!g_current_rx) {
+		g_current_rx = gS->rx;
+	}
+	pRx = g_current_rx;
+	_dcache_inv_range_for_net((unsigned long)pRx, (unsigned long)(pRx + 1) - 1);
+	while (!(pRx->rdes0 & RDES0_OWN)) {
+		len = (pRx->rdes0 & RDES0_FL_MASK) >> RDES0_FL_P;
+		if (14 >= len) {
+			printf("err len=%d\n", len);
+			goto NEXT_BUF;
+		}
+		// pbuf_header(pb, -sizeof(short));
+		_dcache_inv_range_for_net((unsigned long)pRx->rdes2, (unsigned long)pRx->rdes2 + len - 1);
+
+		if (!memcpy((unsigned char*)NetRxPackets[0], (unsigned char*)(unsigned long)pRx->rdes2, len)) {
+			printf("memcp error\n");
+			goto NEXT_BUF;
+		}
+NEXT_BUF:
+		pRx->rdes0 = RDES0_OWN;
+		_dcache_flush_range_for_net((unsigned long)pRx, (unsigned long)(pRx + 1) - 1);
+		pRx = (struct _rx_desc*)(unsigned long)g_current_rx->rdes3;
+		_dcache_inv_range_for_net((unsigned long)pRx, (unsigned long)(pRx + 1) - 1);
+		g_current_rx = pRx;
+		rxnum++;
+		NetReceive(NetRxPackets[0], len);
+		eth_rx_dump((unsigned char *)NetRxPackets[0], len);
+	}
+
+	return len;
+}
+
+static int aml_ethernet_init(struct eth_device * net_current, bd_t *bd)
+{
+	unsigned long net_dma_start_addr;
+	unsigned long net_dma_end_addr;
+	unsigned char *net_dma_buffer = NULL;
+	unsigned long tx_start, rx_start;
+	struct _rx_desc * pRDesc;
+	struct _tx_desc * pTDesc;
+	unsigned char * bufptr;
+	int i;
+	if (g_nInitialized) {
+		return 0;
+	}
+	printf("Amlogic Ethernet Init\n");
+
+	/* alloc the dma buffer */
+	net_dma_buffer = malloc(NET_DMA_BUFFER_SIZE);
+	net_dma_start_addr = (unsigned long)net_dma_buffer;
+	net_dma_end_addr   = (unsigned long)(net_dma_buffer + NET_DMA_BUFFER_SIZE);
+
+	/* init the dma descriptor 128k */
+	gS = (struct _gStruct*)malloc(sizeof(struct _gStruct));
+	if (net_dma_start_addr != 0 &&
+			(net_dma_end_addr - net_dma_start_addr) > (CTX_BUFFER_NUM + CRX_BUFFER_NUM)*CBUFFER_SIZE +
+			CRX_BUFFER_NUM * sizeof(struct _rx_desc) + CTX_BUFFER_NUM * sizeof(struct _tx_desc)) {
+
+		g_rx = (struct _rx_desc*)((unsigned long)net_dma_start_addr + (CTX_BUFFER_NUM + CRX_BUFFER_NUM) * CBUFFER_SIZE);
+		g_tx = (struct _tx_desc*)((char *)g_rx + CRX_BUFFER_NUM * sizeof(struct _rx_desc));
+	} else {
+		printf("Error!! Ethernet DMA size is smaller");
+		goto error_out;
+	}
+	gS->rx = g_rx;
+	gS->tx = g_tx;
+	tx_start = net_dma_start_addr;
+	rx_start = net_dma_start_addr + CTX_BUFFER_NUM * CBUFFER_SIZE;
+	gS->rx_buf_addr = rx_start;
+	gS->tx_buf_addr = tx_start;
+
+	/* init mStruct */
+	gS->current_rx_des = 0;
+	gS->current_tx_des = 0;
+	gS->rx_len = CRX_BUFFER_NUM;
+	gS->tx_len = CTX_BUFFER_NUM;
+	gS->buffer_len = CBUFFER_SIZE;
+	gS->rx_frame_num = 0;
+	gS->current_tx_ready = 0;
+	gS->last_tx_sent = 0;
+	gS->last_tx_desc_num = 0;
+	gS->irq_handle = -1;
+	gS->linked = 0;
+
+	if (g_debug > 1) {
+		printf("netdma:[0x%lx-0x%lx]\n", net_dma_start_addr, net_dma_end_addr);
+		printf("tx_buf_num:%d \t rx_buf_num:%d buf_size:%d\n", CTX_BUFFER_NUM, CRX_BUFFER_NUM, CBUFFER_SIZE);
+		printf("[===dma_tx] 0x%lx-0x%lx\n", tx_start, rx_start);
+		printf("[===dma_rx] 0x%lx-0x%lx\n", rx_start,(unsigned long) g_rx);
+	}
+	/* init RX desc */
+	pRDesc = gS->rx;
+	bufptr = (unsigned char *) gS->rx_buf_addr;
+	for (i = 0; i < gS->rx_len - 1; i++) {
+		if (g_debug > 1) {
+			printf("[rx-descriptor%d] %p\n", i, bufptr);
+		}
+		pRDesc->rdes0 = RDES0_OWN;
+		pRDesc->rdes1 = RDES1_RCH | (gS->buffer_len & RDES1_RBS1_MASK);
+		pRDesc->rdes2 = (unsigned long)bufptr;
+		pRDesc->rdes3 = (unsigned long)pRDesc + sizeof(struct _rx_desc);
+		pRDesc->reverse[0] = 0;
+		pRDesc->reverse[1] = 0;
+		pRDesc->reverse[2] = 0;
+		pRDesc->reverse[3] = 0;
+		bufptr += gS->buffer_len;
+		pRDesc = pRDesc + 1;
+
+	}
+	pRDesc->rdes0 = RDES0_OWN;
+	pRDesc->rdes1 = RDES1_RCH | RDES1_RER | (gS->buffer_len & RDES1_RBS1_MASK); //chain buf
+	pRDesc->rdes2 = (unsigned long)bufptr;
+	pRDesc->rdes3 = (unsigned long)gS->rx; 		//circle
+	_dcache_flush_range_for_net(( unsigned long )gS->rx, (unsigned long)gS->rx + sizeof(struct _rx_desc)*gS->rx_len);
+
+	/* init TX desc */
+	pTDesc = (struct _tx_desc *)gS->tx;
+	bufptr = (unsigned char *)gS->tx_buf_addr;
+	for (i = 0; i < gS->tx_len - 1; i++) {
+		if (g_debug > 1) {
+			printf("[tx-descriptor%d] %p\n", i, bufptr);
+		}
+		pTDesc->tdes0 = 0;
+		pTDesc->tdes1 = TDES1_TCH | TDES1_IC;
+		pTDesc->tdes2 = (unsigned long)bufptr;
+		pTDesc->tdes3 = (unsigned long)pTDesc + sizeof(struct _tx_desc);
+		pTDesc->reverse[0] = 0;
+		pTDesc->reverse[1] = 0;
+		pTDesc->reverse[2] = 0;
+		pTDesc->reverse[3] = 0;
+		bufptr += gS->buffer_len;
+		pTDesc = pTDesc + 1;
+	}
+	pTDesc->tdes0 = 0;
+	pTDesc->tdes1 = TDES1_TCH | TDES1_TER | TDES1_IC; 	//chain buf, enable complete interrupt
+	pTDesc->tdes2 = (unsigned long)bufptr;
+	pTDesc->tdes3 = (unsigned long)gS->tx; 		//circle
+	g_current_tx = gS->tx;
+	_dcache_flush_range_for_net((unsigned long)gS->tx, (unsigned long)gS->tx + sizeof(struct _tx_desc)*gS->tx_len);
+
+	/* get mii interface */
+	g_mac_mode = (aml_eth_readl(PREG_ETH_REG0) & 0x1) ? MAC_MODE_RGMII:MAC_MODE_RMII_CLK_EXTERNAL;
+
+	/* mac and phy reset */
+	eth_reset(gS);
+
+#ifndef CONFIG_RANDOM_MAC_ADDR
+	/* set mac addr */
+	eth_getenv_enetaddr("ethaddr", g_bi_enetaddr);
+	set_mac_addrs(g_bi_enetaddr);
+
+	/* get the mac and ip */
+	printf("MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", g_bi_enetaddr[0], g_bi_enetaddr[1],
+			g_bi_enetaddr[2], g_bi_enetaddr[3], g_bi_enetaddr[4], g_bi_enetaddr[5]);
+#endif
+	/* start the dma para, but don't start the receive dma */
+	aml_eth_writel(ETH_DMA_6_Operation_Mode_EFC | ETH_DMA_6_Operation_Mode_TTC_16 | ETH_DMA_6_Operation_Mode_RSF | ETH_DMA_6_Operation_Mode_TSF | ETH_DMA_6_Operation_Mode_DT, ETH_DMA_6_Operation_Mode);
+	// | ETH_DMA_6_Operation_Mode_RTC_32 | ETH_DMA_6_Operation_Mode_FUF
+
+	netdev_chk();
+	DMARXStart();
+
+	g_nInitialized = 1;
+	return 0;
+
+error_out:
+	return -1;
+}
+
+int aml_eth_init(bd_t *bis)
+{
+	struct eth_device *dev;
+	dev = (struct eth_device *)malloc(sizeof(*dev));
+	memset(dev, 0, sizeof(*dev));
+	sprintf(dev->name, "Meson_Ethernet");
+	dev->init	= aml_ethernet_init;
+	dev->halt 	= aml_eth_halt;
+	dev->send	= aml_eth_send;
+	dev->recv	= aml_eth_rx;
+	return eth_register(dev);
+}
+
+static int do_phyreg(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int phyad, reg, value;
+	unsigned char *cmd = NULL;
+	unsigned int i;
+
+	if (argc  < 2) {
+		return cmd_usage(cmdtp);
+	}
+
+	phyad = detect_phyad();
+	if (phyad > 32 || phyad < 0) {
+		return -1;
+	}
+
+	cmd = (unsigned char *)argv[1];
+	switch (*cmd) {
+		case 'd':
+			printf("=== ethernet phy register dump:\n");
+			for (i = 0; i < 32; i++)
+				printf("[reg_%d] 0x%x\n", i, phy_reg_rd(phyad, i));
+			break;
+		case 'r':
+			if (argc != 3) {
+				return cmd_usage(cmdtp);
+			}
+			printf("=== ethernet phy register read:\n");
+			reg = simple_strtoul(argv[2], NULL, 10);
+			printf("[reg_%d] 0x%x\n", reg, phy_reg_rd(phyad, reg));
+
+			break;
+		case 'w':
+			if (argc != 4) {
+				return cmd_usage(cmdtp);
+			}
+			printf("=== ethernet phy register write:\n");
+			reg = simple_strtoul(argv[2], NULL, 10);
+			value = simple_strtoul(argv[3], NULL, 16);
+			phy_reg_wr(phyad, reg, value);
+			printf("[reg_%d] 0x%x\n", reg, phy_reg_rd(phyad, reg));
+			break;
+
+		default:
+			return cmd_usage(cmdtp);
+	}
+
+	return 0;
+}
+
+static int do_macreg(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int reg, value;
+	unsigned char *cmd = NULL;
+	unsigned int i = 0;
+
+	if (argc  < 2) {
+		return cmd_usage(cmdtp);
+	}
+
+	cmd = (unsigned char *)argv[1];
+	switch (*cmd) {
+		case 'd':
+			printf("=== ETH_MAC register dump:\n");
+			//for (i = 0x0000; i <= 0x00FC; i += 0x4)
+			for (i = 0x0000; i <= 0x004C; i += 0x4)
+				printf("[0x%04x] 0x%lx\n", i, (unsigned long)aml_eth_readl(ETH_BASE + i));
+#if 0
+			printf("=== ETH_MMC register dump:\n");
+			for (i = 0x0100; i <= 0x0284; i += 0x4)
+				printf("[0x%04x] 0x%x\n", i, aml_eth_readl(ETH_BASE + i));
+#endif
+			printf("=== ETH_DMA register dump:\n");
+			for (i = 0x1000; i <= 0x1054; i += 0x4)
+				printf("[0x%04x] 0x%x\n", i, (unsigned int)aml_eth_readl(ETH_BASE + i));
+
+			printf("=== ethernet board config register dump:\n");
+			printf("[0x1076] 0x%x\n", READ_CBUS_REG(0x1076));
+			printf("[0x2032] 0x%x\n", READ_CBUS_REG(0x2032));
+			printf("[0x2042] 0x%x\n", READ_CBUS_REG(0x2042));
+			break;
+		case 'r':
+			if (argc != 3) {
+				return cmd_usage(cmdtp);
+			}
+			printf("=== ethernet mac register read:\n");
+			reg = simple_strtoul(argv[2], NULL, 10);
+			printf("[0x%04x] 0x%x\n", i, (unsigned int)aml_eth_readl(ETH_BASE + reg));
+
+			break;
+		case 'w':
+			if (argc != 4) {
+				return cmd_usage(cmdtp);
+			}
+			printf("=== ethernet mac register write:\n");
+			reg = simple_strtoul(argv[2], NULL, 10);
+			value = simple_strtoul(argv[3], NULL, 16);
+			aml_eth_writel(value, ETH_BASE + reg);
+			printf("[0x%04x] 0x%x\n", reg, value);
+			break;
+
+		default:
+			return cmd_usage(cmdtp);
+	}
+
+	return 0;
+}
+
+static int do_cbusreg(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int reg, value;
+	char *cmd = NULL;
+
+
+	if (argc < 3) {
+		return cmd_usage(cmdtp);
+	}
+
+	cmd = argv[1];
+	switch (*cmd) {
+		case 'r':
+			if (argc != 3) {
+				return cmd_usage(cmdtp);
+			}
+			printf("=== cbus register read:\n");
+			reg = simple_strtoul(argv[2], NULL, 16);
+			printf("[0x%04x] 0x%x\n", reg, READ_CBUS_REG(reg));
+
+			break;
+		case 'w':
+			if (argc != 4) {
+				return cmd_usage(cmdtp);
+			}
+			printf("=== cbus register write:\n");
+			reg = simple_strtoul(argv[2], NULL, 16);
+			value = simple_strtoul(argv[3], NULL, 16);
+			WRITE_CBUS_REG(reg, value);
+			printf("[0x%04x] 0x%x\n", reg, READ_CBUS_REG(reg));
+			break;
+
+		default:
+			return cmd_usage(cmdtp);
+	}
+
+	return 0;
+}
+
+//loopback test.
+static int do_autoping(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int phyad = -1;
+	unsigned int value;
+	char buffer[40];
+
+	if (argc < 2) {
+		return cmd_usage(cmdtp);
+	}
+
+	phyad = detect_phyad();
+	if (phyad > 32 || phyad < 0) {
+		return -1;
+	}
+
+	value = phy_reg_rd(phyad, PHY_CR);
+	phy_reg_wr(phyad, PHY_CR, value | (1 << 14)); //phy loopback
+	while (1) {
+		if (had_ctrlc()) {
+			printf("Quit autoping...\n");
+			return 0;
+		}
+		sprintf(buffer, "ping %s ", argv[1]);
+		run_command(buffer, 0);
+	}
+	return 0;
+}
+static int do_mdc_clk(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	if (argc  < 2) {
+		return cmd_usage(cmdtp);
+	}
+
+	g_mdc_clock_range=((simple_strtoul(argv[1], NULL, 16)&0xf)<<2);
+	printf("set value:0x%x\n",g_mdc_clock_range);
+	return 0;
+}
+int do_ethchk(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	netdev_chk();
+	return 0;
+}
+
+
+static int do_ethrst(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	eth_reset(gS);
+
+	return 0;
+}
+
+static int do_ethmode(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned char *cmd = NULL;
+
+	if (argc  < 2) {
+		return cmd_usage(cmdtp);
+	}
+
+	cmd = (unsigned char *)argv[1];
+	switch (*cmd) {
+		case '0':
+			g_mac_mode = 0;
+			printf("set MAC mode: RMII 100/10 Mbps (external clk).\n");
+			break;
+		case '1':
+			g_mac_mode = 1;
+			printf("set MAC mode: RMII 100/10 Mbps (internal clk).\n");
+			break;
+		case '2':
+			g_mac_mode = 2;
+			printf("set MAC mode: RGMII 1000/100/10 Mbps.\n");
+			break;
+
+		default:
+			return cmd_usage(cmdtp);
+	}
+	if (get_cpuid() >= 0x16) {
+		/* config ethernet mode */
+		switch (g_mac_mode) {
+			case MAC_MODE_RMII_CLK_EXTERNAL:
+				if (get_cpuid() == 0x19) {
+					//WRITE_CBUS_REG(HHI_ETH_CLK_CNTL, 0xf00);
+					//WRITE_CBUS_REG(PERIPHS_PIN_MUX_6, 0x0000fde0);
+					//WRITE_CBUS_REG(PREG_ETHERNET_ADDR0, 0x241);
+				}
+				else{
+					//WRITE_CBUS_REG(HHI_ETH_CLK_CNTL, 0x130); //clock phase invert
+					//WRITE_CBUS_REG(PERIPHS_PIN_MUX_6, 0x8007ffe0);
+					//WRITE_CBUS_REG(PREG_ETHERNET_ADDR0, 0x241);
+				}
+				break;
+			case MAC_MODE_RMII_CLK_INTERNAL:
+				//WRITE_CBUS_REG(HHI_ETH_CLK_CNTL, 0x702);
+				//WRITE_CBUS_REG(PERIPHS_PIN_MUX_6, 0x4007ffe0);
+				//WRITE_CBUS_REG(PREG_ETHERNET_ADDR0, 0x241);
+				break;
+			case MAC_MODE_RGMII:
+				//WRITE_CBUS_REG(HHI_ETH_CLK_CNTL, 0x309);
+				//WRITE_CBUS_REG(PERIPHS_PIN_MUX_6, 0x4007ffe0);
+				//WRITE_CBUS_REG(PREG_ETHERNET_ADDR0, 0x211);
+				break;
+			default:
+				break;
+		}
+
+		udelay(1000);
+		//hardware_reset();
+		eth_reset(gS);
+	}
+
+	return 0;
+}
+
+static int do_ethdbg(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned char *cmd = NULL;
+
+	if (argc  < 2) {
+		return cmd_usage(cmdtp);
+	}
+
+	cmd = (unsigned char *)argv[1];
+	switch (*cmd) {
+		case '0':
+			g_debug = 0;
+			break;
+		case '1':
+			g_debug = 1;
+			break;
+		case '2':
+			g_debug = 2;
+			break;
+		case '3':
+			g_debug = 3;
+			break;
+		case '4':
+			g_debug = 4;
+			break;
+
+		default:
+			return cmd_usage(cmdtp);
+	}
+	printf("set ethernet debug: %d\n", g_debug);
+
+	return 0;
+}
+
+#define MSR_CLK_REG0 0x21d7
+#define MSR_CLK_REG2 0x21d9
+
+static unsigned int clk_util_clk_msr(unsigned int clk_mux)
+{
+	unsigned int regval = 0;
+
+	WRITE_CBUS_REG(MSR_CLK_REG0, 0);
+	/* Set the measurement gate to 64uS */
+	CLEAR_CBUS_REG_MASK(MSR_CLK_REG0, 0xffff);
+	/* 64uS is enough for measure the frequence? */
+	SET_CBUS_REG_MASK(MSR_CLK_REG0, (64 - 1));
+	/* Disable continuous measurement */
+	/* Disable interrupts */
+	CLEAR_CBUS_REG_MASK(MSR_CLK_REG0, ((1 << 18) | (1 << 17)));
+	CLEAR_CBUS_REG_MASK(MSR_CLK_REG0, (0x7f << 20));
+	SET_CBUS_REG_MASK(MSR_CLK_REG0, (clk_mux << 20) | /* Select MUX */
+			(1 << 19) |       /* enable the clock */
+			(1 << 16));       /* enable measuring */
+	/* Wait for the measurement to be done */
+	regval = READ_CBUS_REG(MSR_CLK_REG0);
+	do {
+		regval = READ_CBUS_REG(MSR_CLK_REG0);
+	} while (regval & (1 << 31));
+
+	/* Disable measuring */
+	CLEAR_CBUS_REG_MASK(MSR_CLK_REG0, (1 << 16));
+	regval = (READ_CBUS_REG(MSR_CLK_REG2) + 31) & 0x000FFFFF;
+
+	return (regval >> 6);
+}
+
+static int do_clkmsr(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const char* clk_table[] = {
+		[82] = "Cts_ge2d_clk ",
+		[81] = "Cts_vapbclk ",
+		[80] = "Rng_ring_osc_clk[3] ",
+		[79] = "Rng_ring_osc_clk[2] ",
+		[78] = "Rng_ring_osc_clk[1] ",
+		[77] = "Rng_ring_osc_clk[0] ",
+		[76] = "cts_aoclk_int ",
+		[75] = "cts_aoclkx2_int ",
+		[74] = "0 ",
+		[73] = "cts_pwm_C_clk ",
+		[72] = "cts_pwm_D_clk ",
+		[71] = "cts_pwm_E_clk ",
+		[70] = "cts_pwm_F_clk ",
+		[69] = "0 ",
+		[68] = "0 ",
+		[67] = "0 ",
+		[66] = "cts_vid_lock_clk ",
+		[65] = "0 ",
+		[64] = "0 ",
+		[63] = "0 ",
+		[62] = "cts_hevc_clk ",
+		[61] = "gpio_clk_msr ",
+		[60] = "alt_32k_clk ",
+		[59] = "cts_hcodec_clk ",
+		[58] = "0 ",
+		[57] = "0 ",
+		[56] = "0 ",
+		[55] = "vid_pll_div_clk_out ",
+		[54] = "0 ",
+		[53] = "Sd_emmc_clk_A ",
+		[52] = "Sd_emmc_clk_B ",
+		[51] = "Cts_nand_core_clk ",
+		[50] = "Mp3_clk_out ",
+		[49] = "mp2_clk_out ",
+		[48] = "mp1_clk_out ",
+		[47] = "ddr_dpll_pt_clk ",
+		[46] = "cts_vpu_clk ",
+		[45] = "cts_pwm_A_clk ",
+		[44] = "cts_pwm_B_clk ",
+		[43] = "fclk_div5 ",
+		[42] = "mp0_clk_out ",
+		[41] = "eth_rx_clk_or_clk_rmii ",
+		[40] = "cts_pcm_mclk ",
+		[39] = "cts_pcm_sclk ",
+		[38] = "0 ",
+		[37] = "cts_clk_i958 ",
+		[36] = "cts_hdmi_tx_pixel_clk ",
+		[35] = "cts_mali_clk ",
+		[34] = "0 ",
+		[33] = "0 ",
+		[32] = "cts_vdec_clk ",
+		[31] = "MPLL_CLK_TEST_OUT ",
+		[30] = "0 ",
+		[29] = "0 ",
+		[28] = "0 ",
+		[27] = "0 ",
+		[26] = "sc_clk_int ",
+		[25] = "0 ",
+		[24] = "0 ",
+		[23] = "HDMI_CLK_TODIG ",
+		[22] = "eth_phy_ref_clk ",
+		[21] = "i2s_clk_in_src0 ",
+		[20] = "rtc_osc_clk_out ",
+		[19] = "cts_hdmitx_sys_clk ",
+		[18] = "A53_clk_div16 ",
+		[17] = "0 ",
+		[16] = "cts_FEC_CLK_2 ",
+		[15] = "cts_FEC_CLK_1 ",
+		[14] = "cts_FEC_CLK_0 ",
+		[13] = "cts_amclk ",
+		[12] = "Cts_pdm_clk ",
+		[11] = "rgmii_tx_clk_to_phy ",
+		[10] = "cts_vdac_clk ",
+		[9] = "cts_encl_clk " ,
+		[8] = "cts_encp_clk " ,
+		[7] = "clk81 " ,
+		[6] = "cts_enci_clk " ,
+		[5] = "0 " ,
+		[4] = "gp0_pll_clk " ,
+		[3] = "A53_ring_osc_clk " ,
+		[2] = "am_ring_osc_clk_out_ee[2] " ,
+		[1] = "am_ring_osc_clk_out_ee[1] " ,
+		[0] = "am_ring_osc_clk_out_ee[0] " ,
+	};
+	int i;
+	int index = 0xff;
+
+	if (argc ==  2) {
+		index = simple_strtoul(argv[1], NULL, 10);
+	}
+
+	if (index == 0xff) {
+		for (i = 0; i < sizeof(clk_table) / sizeof(char *); i++)
+			printf("[%4d MHz] %s[%d]\n", clk_util_clk_msr(i),
+			       clk_table[i], i);
+		return 0;
+	}
+	printf("[%4d MHz] %s\n", clk_util_clk_msr(index), clk_table[82-index]);
+
+	return 0;
+}
+static int  do_netspeed(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int speed=100;
+	int full=0;
+	int data=0;
+
+	if (argc  < 2) {
+
+		switch (g_phy_Identifier)
+		{
+			case PHY_ATHEROS_8032:
+				break;
+			case PHY_IC_IP101ALF:
+				break;
+			case PHY_SMSC_8700:
+			default:
+				data = phy_reg_rd(1,31);
+				speed = data & (1<<3);
+				full = ((data >>4) & 1);
+				printf("status: %sM %s-duplex\n",(speed?"100":"10"),(full?"full":"half"));
+				break;
+		}
+		return cmd_usage(cmdtp);
+	}
+	speed = simple_strtoul(argv[1], NULL, 10);
+	if ((speed != 0) && (speed != 100) && (speed != 10)) return -1;
+	data= phy_reg_rd(1,0);
+	if (speed == 0) //disable net speed enforce mode,ie.  we enable A/N
+	{
+		g_speed_enforce=0;
+		data |=(1<<12)|(1<<9);
+	}else{
+		g_speed_enforce=1;
+		data &=~(1<<12);
+		if (speed == 100) //100M
+		{
+			data |= (1<<13) ;
+		}else if(speed == 10 ){ //10M
+			data &=~(1<<13);
+		}
+		if (strncmp(argv[2],"fu",2) == 0)
+		{
+			data |= (1<<8);
+		}else{
+			data &=~(1<<8);
+		}
+	}
+	phy_reg_wr(1, 0, data);
+	return 0;
+
+}
+#ifdef CONFIG_M8B
+static int do_eth_cali(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int value;
+	int rise=0;
+	int sel=0;
+	int i;
+	//char *cmd = NULL;
+
+
+	if (argc < 2) {
+		return cmd_usage(cmdtp);
+	}
+	rise = simple_strtoul(argv[1], NULL, 10);
+	sel = simple_strtoul(argv[2], NULL, 10);
+	eth_aml_reg0_t eth_reg0;
+	eth_reg0.d32 = READ_CBUS_REG(0x2050);
+	eth_reg0.b.cali_start = 1;
+	eth_reg0.b.cali_rise = rise;
+	eth_reg0.b.cali_sel = sel;
+	WRITE_CBUS_REG(0x2050, eth_reg0.d32);
+	printf("0x%x\n",  READ_CBUS_REG(0x2050));
+	for (i=0;i<10000;i++) {
+		value = READ_CBUS_REG(0x2051);
+		if ((value>>15)&0x1)
+			printf("value == %x,  cali_len == %d, cali_idx == %d,  cali_sel =%d,  cali_rise = %d\n",value,(value>>5)&0x1f,(value&0x1f),(value>>11)&0x7,(value>>14)&0x1);
+	}
+
+	return 0;
+}
+U_BOOT_CMD(
+		cali, 3, 1, do_eth_cali,
+		"configure clock phare",
+		"             - phare mac clock.\n"
+	  );
+#endif
+
+U_BOOT_CMD(
+		netspd_f, 3, 1, do_netspeed,
+		"enforce eth speed",
+		"0            - disable enforce mode,enable A/N\n"
+		"10  full   - enforce 10M full duplex mode\n"
+		"10  half   - enforce 10M half duplex mode\n"
+		"100 full   - enforce 100M full duplexmode\n"
+		"100 half   - enforce 100M half duplexmode\n"
+	  );
+U_BOOT_CMD(
+		phyreg, 4, 1, do_phyreg,
+		"ethernet phy register read/write/dump",
+		"d            - dump phy registers\n"
+		"       r reg        - read phy register\n"
+		"       w reg val    - write phy register"
+	  );
+
+U_BOOT_CMD(
+		macreg, 4, 1, do_macreg,
+		"ethernet mac register read/write/dump",
+		"d            - dump mac registers\n"
+		"       r reg        - read mac register\n"
+		"       w reg val    - write mac register"
+	  );
+
+U_BOOT_CMD(
+		cbusreg, 4, 1, do_cbusreg,
+		"cbus register read/write",
+		"r reg        - read cbus register\n"
+		"        w reg val    - write cbus register"
+	  );
+U_BOOT_CMD(
+		mdc_clk, 2, 1, do_mdc_clk,
+		"do mdc clock",
+		"mdc  data-- data is ETH_MAC_4_GMII_Addr[2..5]  "
+	  );
+U_BOOT_CMD(
+		autoping, 2, 1, do_autoping,
+		"do auto ping test",
+		"ip"
+	  );
+
+U_BOOT_CMD(
+		ethchk, 1, 1, do_ethchk,
+		"check ethernet status",
+		""
+	  );
+
+U_BOOT_CMD(
+		ethrst, 1, 1, do_ethrst,
+		"reset ethernet phy",
+		"             - reset etherent phy\n"
+	  );
+
+U_BOOT_CMD(
+		ethmode, 2, 1, do_ethmode,
+		"set ethernet mac mode",
+		"0         - set mac mode RMII (external clk).\n"
+		"        1         - set mac mode RMII (internal clk).\n"
+		"        2         - set mac mode RGMII.\n"
+	  );
+
+U_BOOT_CMD(
+		ethdbg, 2, 1, do_ethdbg,
+		"set ethernet debug level",
+		"0         - disable ethernet debug\n"
+		"       1         - ethernet basic info\n"
+		"       2         - ethernet TX debug\n"
+		"       3         - ethernet RX debug\n"
+		"       4         - ethernet TX/RX debug\n"
+	  );
+
+U_BOOT_CMD(
+		clkmsr, 2, 1, do_clkmsr,
+		"measure PLL clock",
+		"             - measure PLL clock.\n"
+	  );
diff --git a/drivers/net/aml_phy_8700.h b/drivers/net/aml_phy_8700.h
new file mode 100644
index 0000000..2e2c766
--- /dev/null
+++ b/drivers/net/aml_phy_8700.h
@@ -0,0 +1,129 @@
+
+/*
+ * drivers/net/aml_phy_8700.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __AML_PHY_LAN8700_H__
+#define __AML_PHY_LAN8700_H__
+
+#include <config.h>
+
+
+/*-------------------------------------------
+ .
+ . A description of the SMSC LAN8700 regn order here
+ .
+ ---------------------------------------------------*/
+#define PHY_CR                  0
+#define PHY_CR_RST              (1<<15)
+#define PHY_CR_LOOPBACK         (1<<14)
+#define PHY_CR_SPEED            (1<<13)
+#define PHY_CR_AN               (1<<12)
+#define PHY_CR_PWRDOWN          (1<<11)
+#define PHY_CR_ISOLATE          (1<<10)
+#define PHY_CR_RSTAN            (1<<9)
+#define PHY_CR_DPLX             (1<<8)
+#define PHY_CR_CT               (1<<7)
+
+#define PHY_SR                  1
+#define PHY_SR_100BT4           (1<<15)
+#define PHY_SR_100BTF           (1<<14)
+#define PHY_SR_100BTH           (1<<13)
+#define PHY_SR_10BTF            (1<<12)
+#define PHY_SR_10BTH            (1<<11)
+#define PHY_SR_ANCOMPLETE       (1<<5)
+#define PHY_SR_REMOTEFAULT      (1<<4)
+#define PHY_SR_ANABILITY        (1<<3)
+#define PHY_SR_LINKSTATUS       (1<<2)
+#define PHY_JABBER              (1<<1)
+#define PHY_EXTCAP              (1)
+
+#define PHY_SPMD					18
+#define PHY_SPMD_PHYAD_P			0
+#define PHY_SPMD_MODE_P			5
+#define PHY_SPMD_MIIMODE_P		14
+#define PHY_SPMD_MIIMODE_MII		(0<<14)
+#define PHY_SPMD_MIIMODE_RMII		(1<<14)
+
+#define PHY_SPCT					31
+#define PHY_SPCT_SCD_P				0
+#define PHY_SPCT_SPD_P				2
+#define PHY_SPCT_E4B5B_P			6
+#define PHY_SPCT_GPO_P				7
+#define PHY_SPCT_ATDW_P				12
+#define PHY_SPCT_SCD				(1<<PHY_SPCT_SCD_P)
+#define PHY_SPCT_SPD_10H			(1<<PHY_SPCT_SPD_P)
+#define PHY_SPCT_SPD_10F			(5<<PHY_SPCT_SPD_P)
+#define PHY_SPCT_SPD_100H			(2<<PHY_SPCT_SPD_P)
+#define PHY_SPCT_SPD_100F			(6<<PHY_SPCT_SPD_P)
+#define PHY_SPCT_E4B5B				(1<<PHY_SPCT_E4B5B_P)
+#define PHY_SPCT_GPO				(1<<PHY_SPCT_GPO_P)
+#define PHY_SPCT_ATDW				(1<<PHY_SPCT_ATDW_P)
+
+
+#define ETH_MAC_0_TC                  (1<<24)
+#define ETH_MAC_0_MIIPORT             (1<<15)
+#define ETH_MAC_0_FES_100M            (1<<14)
+#define ETH_MAC_0_DM                  (1<<11)
+#define ETH_MAC_0_LM                  (1<<12)
+#define ETH_MAC_0_LINK                (1<<8)
+#define ETH_MAC_0_TE                  (1<<3)
+#define ETH_MAC_0_RE                  (1<<2)
+
+//MODE BUS
+#define PHY_MODE_BUS_10HD_AD		0
+#define PHY_MODE_BUS_10FD_AD		1
+#define PHY_MODE_BUS_100HD_AD	2
+#define PHY_MODE_BUS_100FD_AD	3
+#define PHY_MODE_BUS_100HD_AE	4
+#define PHY_MODE_BUS_RP_AE		5
+#define PHY_MODE_BUS_PWDN		6
+#define PHY_MODE_BUS_ALL_AE		7
+
+//Normal Interrupts
+#define NOR_INTR_EN 1<<16
+#define TX_INTR_EN  1<<0
+#define TX_BUF_UN_EN 1<<2
+#define RX_INTR_EN  1<<6
+#define EARLY_RX_INTR_EN 1<<14
+
+//Abnormal Interrupts
+#define ANOR_INTR_EN 1<<15
+#define TX_STOP_EN 1<<1
+#define TX_JABBER_TIMEOUT 1<<3
+#define RX_FIFO_OVER 1<<4
+#define TX_UNDERFLOW 1<<5
+#define RX_BUF_UN 1<<7
+#define RX_STOP_EN 1<<8
+#define RX_WATCH_TIMEOUT 1<<9
+#define EARLY_TX_INTR_EN 1<<10
+#define FATAL_BUS_ERROR 1<<13
+
+#define SEGMENT_FIRST 1<<29
+#define SEGMENT_END 1<<30
+#define SEGMENT_FIRST_END 3<<29
+
+#define FIRST_BUFFER 1600;
+#define MIDDLE_BUFFER 1601;
+#define LAST_BUFFER 1602;
+#define FIRST_LAST_BUFFER 1603;
+
+
+#endif /* __AML_EMAC_LAN8700_H__ */
+
diff --git a/drivers/securestorage/Makefile b/drivers/securestorage/Makefile
new file mode 100644
index 0000000..245853b
--- /dev/null
+++ b/drivers/securestorage/Makefile
@@ -0,0 +1,2 @@
+#
+obj-$(CONFIG_SECURE_STORAGE) += securestorage.o
diff --git a/drivers/securestorage/securestorage.c b/drivers/securestorage/securestorage.c
new file mode 100644
index 0000000..bf6d62f
--- /dev/null
+++ b/drivers/securestorage/securestorage.c
@@ -0,0 +1,278 @@
+#include <common.h>
+#include <linux/types.h>
+#include <asm/arch/secure_apb.h>
+#include <amlogic/secure_storage.h>
+#include <asm/arch/bl31_apis.h>
+
+static uint64_t storage_share_in_base;
+static uint64_t storage_share_out_base;
+static uint64_t storage_share_block_base;
+static uint64_t storage_share_block_size;
+static uint64_t storage_init_status;
+
+static uint64_t bl31_storage_ops(uint64_t function_id)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: "+r" (function_id));
+
+	return function_id;
+}
+
+static uint64_t bl31_storage_write(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t keyattr)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint8_t *data;
+	uint32_t namelen;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	*input++ = keylen;
+	*input++ = keyattr;
+	data = (uint8_t *)input;
+	memcpy(data, keyname, namelen);
+	data += namelen;
+	memcpy(data, keybuf, keylen);
+	return bl31_storage_ops(SECURITY_KEY_WRITE);
+}
+
+static uint64_t bl31_storage_read(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t *readlen)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name, *buf;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	*input++ = keylen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_READ);
+	if (ret == RET_OK) {
+		*readlen = *output;
+		buf = (uint8_t *)(output+1);
+		memcpy(keybuf, buf, *readlen);
+	}
+	return ret;
+}
+
+static uint64_t bl31_storage_query(uint8_t *keyname, uint32_t *retval)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_QUERY);
+	if (ret == RET_OK)
+		*retval = *output;
+	return ret;
+}
+
+static uint64_t bl31_storage_status(uint8_t *keyname, uint32_t *retval)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_STATUS);
+	if (ret == RET_OK)
+		*retval = *output;
+	return ret;
+}
+static uint64_t bl31_storage_tell(uint8_t *keyname, uint32_t *retval)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_TELL);
+	if (ret == RET_OK)
+		*retval = *output;
+	return ret;
+}
+
+static uint64_t bl31_storage_verify(uint8_t *keyname, uint8_t *hashbuf)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_VERIFY);
+
+	if (ret == RET_OK)
+		memcpy(hashbuf, (uint8_t *)output, 32);
+	return ret;
+}
+
+static uint64_t bl31_storage_list(uint8_t *listbuf,
+	uint32_t outlen, uint32_t *readlen)
+{
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint64_t ret;
+
+	ret = bl31_storage_ops(SECURITY_KEY_LIST);
+	if (ret == RET_OK) {
+		if (*output > outlen)
+			*readlen = outlen;
+		else
+			*readlen = *output;
+		memcpy(listbuf, (uint8_t *)(output+1), *readlen);
+	}
+	return ret;
+}
+
+static uint64_t bl31_storage_remove(uint8_t *keyname)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t namelen;
+	uint8_t *name;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	return bl31_storage_ops(SECURITY_KEY_REMOVE);
+}
+
+static inline int32_t smc_to_ns_errno(uint64_t errno)
+{
+	int32_t ret = (int32_t)(errno&0xffffffff);
+	return ret;
+}
+
+void secure_storage_init(void)
+{
+		storage_share_in_base =
+				bl31_storage_ops(GET_SHARE_STORAGE_IN_BASE);
+		storage_share_out_base =
+				bl31_storage_ops(GET_SHARE_STORAGE_OUT_BASE);
+		storage_share_block_base =
+				bl31_storage_ops(GET_SHARE_STORAGE_BLOCK_BASE);
+		storage_share_block_size =
+				bl31_storage_ops(GET_SHARE_STORAGE_BLOCK_SIZE);
+		storage_init_status = 1;
+}
+
+void *secure_storage_getbuffer(uint32_t *size)
+{
+	if (!storage_init_status)
+		secure_storage_init();
+	*size = (uint32_t)storage_share_block_size;
+	return (void *)storage_share_block_base;
+}
+void secure_storage_notifier(void)
+{
+	bl31_storage_ops(SECURITY_KEY_NOTIFY);
+}
+
+int32_t secure_storage_write(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t keyattr)
+{
+	uint32_t ret;
+
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_write(keyname, keybuf, keylen, keyattr);
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_read(uint8_t *keyname, uint8_t *keybuf,
+			uint32_t keylen, uint32_t *readlen)
+{
+	uint64_t ret;
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_read(keyname, keybuf, keylen, readlen);
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_query(uint8_t *keyname, uint32_t *retval)
+{
+	uint64_t ret;
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_query(keyname, retval);
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_status(uint8_t *keyname, uint32_t *retval)
+{
+	uint64_t ret;
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_status(keyname, retval);
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_tell(uint8_t *keyname, uint32_t *retval)
+{
+	uint64_t ret;
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_tell(keyname, retval);
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_verify(uint8_t *keyname, uint8_t *hashbuf)
+{
+	uint64_t ret;
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_verify(keyname, hashbuf);
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_list(uint8_t *listbuf,
+		uint32_t buflen, uint32_t *readlen)
+{
+	uint64_t ret;
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_list(listbuf, buflen, readlen);
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_remove(uint8_t *keyname)
+{
+	uint64_t ret;
+	if (!storage_init_status)
+		secure_storage_init();
+	ret = bl31_storage_remove(keyname);
+
+	return smc_to_ns_errno(ret);
+}
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 4cc00cd..4c1f2bc 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_PL010_SERIAL) += serial_pl01x.o
 obj-$(CONFIG_PL011_SERIAL) += serial_pl01x.o
 obj-$(CONFIG_SYS_NS16550_SERIAL) += serial_ns16550.o
 endif
+obj-$(CONFIG_AML_MESON_SERIAL) += serial_meson.o
 
 obj-$(CONFIG_ALTERA_UART) += altera_uart.o
 obj-$(CONFIG_ALTERA_JTAG_UART) += altera_jtag_uart.o
diff --git a/drivers/serial/serial.c b/drivers/serial/serial.c
index 95c992a..5e2298b 100644
--- a/drivers/serial/serial.c
+++ b/drivers/serial/serial.c
@@ -420,7 +420,8 @@ static struct serial_device *get_current(void)
 int serial_init(void)
 {
 	gd->flags |= GD_FLG_SERIAL_READY;
-	return get_current()->start();
+	return 0;
+	//return get_current()->start();
 }
 
 /**
diff --git a/drivers/serial/serial_amlogic.c b/drivers/serial/serial_amlogic.c
new file mode 100644
index 0000000..981c8aa
--- /dev/null
+++ b/drivers/serial/serial_amlogic.c
@@ -0,0 +1,10 @@
+#include <common.h>
+
+
+
+__weak struct serial_device *default_serial_console(void)
+{
+	return NULL;
+}
+
+
diff --git a/drivers/serial/serial_meson.c b/drivers/serial/serial_meson.c
new file mode 100644
index 0000000..897c0cd
--- /dev/null
+++ b/drivers/serial/serial_meson.c
@@ -0,0 +1,370 @@
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description: Serial driver.
+ *
+ *  Author: Jerry Yu
+ *  Created: 2009-3-12
+ *
+ *******************************************************************/
+
+#include <config.h>
+#include <common.h>
+//#include <asm/arch/io.h>
+//#include <asm/arch/cpu.h>
+#include <asm/io.h>
+#include <asm/arch/uart.h>
+#include <serial.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int serial_set_pin_port(unsigned long port_base);
+static void serial_putc_port (unsigned long port_base,const char c);
+
+//static unsigned port_base_addrs[]={UART_PORT_0,UART_PORT_1};
+#if 0 // due to errror
+static void serial_clr_err (unsigned port_base)
+{
+    /* write to the register */
+
+	if (readl(P_UART_STATUS(port_base))&(UART_STAT_MASK_PRTY_ERR|UART_STAT_MASK_FRAM_ERR))
+		writel((readl(P_UART_CONTROL(port_base)) | UART_CNTL_MASK_CLR_ERR), P_UART_CONTROL(port_base));
+}
+#endif
+
+/*
+ * Sets baudarate
+ */
+static void serial_setbrg_port (unsigned long port_base)
+{
+
+    unsigned long baud_para;
+    int clk81=clk_get_rate(UART_CLK_SRC);
+    if (clk81<0)
+        return;
+
+
+    /* baud rate */
+    baud_para=clk81/(gd->baudrate*4) -1;
+
+    baud_para &= UART_CNTL_MASK_BAUD_RATE;
+
+    /* write to the register */
+    writel((readl(P_UART_CONTROL(port_base)) & ~UART_CNTL_MASK_BAUD_RATE) | baud_para, P_UART_CONTROL(port_base));
+}
+
+/*
+ * Sets stop bits
+ * input[0]: stop_bits (1, 2)
+ */
+static void serial_set_stop_port (unsigned long port_base,int stop_bits)
+{
+    unsigned long uart_config;
+
+    uart_config = readl(P_UART_CONTROL(port_base)) & ~UART_CNTL_MASK_STP_BITS;
+    /* stop bits */
+    switch (stop_bits)
+    {
+        case 2:
+            uart_config |= UART_CNTL_MASK_STP_2BIT;
+            break;
+        case 1:
+        default:
+            uart_config |= UART_CNTL_MASK_STP_1BIT;
+            break;
+    }
+
+    /* write to the register */
+    writel(uart_config, P_UART_CONTROL(port_base));
+}
+
+/*
+ * Sets parity type
+ * input[0]: 1 -- enable parity, 0 -- disable;
+ * input[1]: 1 -- odd parity, 0 -- even parity;
+ */
+static void serial_set_parity_port(unsigned long port_base,int type)
+{
+    unsigned long uart_config;
+
+
+    uart_config = readl(P_UART_CONTROL(port_base)) & ~(UART_CNTL_MASK_PRTY_TYPE | UART_CNTL_MASK_PRTY_EN);
+#if 0   //changed by Elvis --- disable parity
+    uart_config |= UART_CNTL_MASK_PRTY_EN;
+    /* parity bits */
+    if (type&2)
+        uart_config |= UART_CNTL_MASK_PRTY_EN;
+    if (type&1)
+        uart_config |= UART_CNTL_MASK_PRTY_ODD;
+    else
+        uart_config |= UART_CNTL_MASK_PRTY_EVEN;
+ #endif
+    /* write to the register */
+    writel(uart_config, P_UART_CONTROL(port_base));
+
+}
+
+/*
+ * Sets data length
+ * input[0]: Character length [5, 6, 7, 8]
+ */
+static void serial_set_dlen_port (unsigned long port_base,int data_len)
+{
+    unsigned long uart_config;
+
+    uart_config = readl(P_UART_CONTROL(port_base)) & ~UART_CNTL_MASK_CHAR_LEN;
+    /* data bits */
+    switch (data_len)
+    {
+        case 5:
+            uart_config |= UART_CNTL_MASK_CHAR_5BIT;
+            break;
+        case 6:
+            uart_config |= UART_CNTL_MASK_CHAR_6BIT;
+            break;
+        case 7:
+            uart_config |= UART_CNTL_MASK_CHAR_7BIT;
+            break;
+        case 8:
+        default:
+            uart_config |= UART_CNTL_MASK_CHAR_8BIT;
+            break;
+    }
+
+    /* write to the register */
+    writel(uart_config, P_UART_CONTROL(port_base));
+}
+
+
+
+/*
+ * reset the uart state machine
+ */
+static void serial_reset_port(unsigned long port_base) {
+
+	/* write to the register */
+	writel(readl(P_UART_CONTROL(port_base)) | UART_CNTL_MASK_RST_TX | UART_CNTL_MASK_RST_RX | UART_CNTL_MASK_CLR_ERR, P_UART_CONTROL(port_base));
+	writel(readl(P_UART_CONTROL(port_base)) & ~(UART_CNTL_MASK_RST_TX | UART_CNTL_MASK_RST_RX | UART_CNTL_MASK_CLR_ERR), P_UART_CONTROL(port_base));
+}
+
+/*
+ * Intialise the serial port with given baudrate
+ */
+
+static int serial_init_port (unsigned long port_base)
+{
+	int ret;
+
+#ifdef CONFIG_M3
+	while ((readl(P_UART_STATUS(port_base)) & (UART_STAT_MASK_XMIT_BUSY))) ;
+#endif
+
+    writel(0,P_UART_CONTROL(port_base));
+    ret = serial_set_pin_port(port_base);
+    if (ret < 0)
+		return -1;
+
+    serial_setbrg_port(port_base);
+#ifndef CONFIG_SERIAL_STP_BITS
+#define CONFIG_SERIAL_STP_BITS 1
+#endif
+    serial_set_stop_port(port_base,CONFIG_SERIAL_STP_BITS);
+#ifndef CONFIG_SERIAL_PRTY_TYPE
+#define CONFIG_SERIAL_PRTY_TYPE 0
+#endif
+
+    serial_set_parity_port(port_base,CONFIG_SERIAL_PRTY_TYPE);
+#ifndef CONFIG_SERIAL_CHAR_LEN
+#define CONFIG_SERIAL_CHAR_LEN 8
+#endif
+    serial_set_dlen_port(port_base,CONFIG_SERIAL_CHAR_LEN);
+    writel(readl(P_UART_CONTROL(port_base)) | UART_CNTL_MASK_TX_EN | UART_CNTL_MASK_RX_EN, P_UART_CONTROL(port_base));
+    while (!(readl(P_UART_STATUS(port_base)) & UART_STAT_MASK_TFIFO_EMPTY)) ;
+    serial_reset_port(port_base);
+#ifdef CONFIG_M3
+	while ((readl(P_UART_STATUS(port_base)) & (UART_STAT_MASK_XMIT_BUSY))) ;
+#endif
+    serial_putc_port(port_base,'\n');
+    return 0;
+}
+
+/*
+ * Output a single byte to the serial port.
+ */
+static void serial_putc_port (unsigned long port_base,const char c)
+{
+
+    if (c == '\n')
+        serial_putc_port(port_base,'\r');
+
+    /* Wait till dataTx register is not full */
+    while ((readl(P_UART_STATUS(port_base)) & UART_STAT_MASK_TFIFO_FULL));
+ // while(!(readl(P_UART_STATUS(port_base)) & UART_STAT_MASK_TFIFO_EMPTY));
+    writel(c, P_UART_WFIFO(port_base));
+    /* Wait till dataTx register is empty */
+#if !defined (CONFIG_VLSI_EMULATOR)
+    while (!(readl(P_UART_STATUS(port_base)) & UART_STAT_MASK_TFIFO_EMPTY)) ;
+#endif //CONFIG_VLSI_EMULATOR
+
+}
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise 0.
+ */
+static int serial_tstc_port (unsigned long port_base)
+{
+
+	int i;
+
+	i=(readl(P_UART_STATUS(port_base)) & UART_STAT_MASK_RFIFO_CNT);
+	return i;
+
+}
+
+/*
+ * Read a single byte from the serial port.
+ */
+static int serial_getc_port (unsigned long port_base)
+{
+    unsigned char ch;
+
+    /* Wait till character is placed in fifo */
+	while ((readl(P_UART_STATUS(port_base)) & UART_STAT_MASK_RFIFO_CNT) == 0) ;
+	ch = readl(P_UART_RFIFO(port_base)) & 0x00ff;
+    /* Also check for overflow errors */
+    if (readl(P_UART_STATUS(port_base)) & (UART_STAT_MASK_PRTY_ERR | UART_STAT_MASK_FRAM_ERR))
+    {
+		writel(readl(P_UART_CONTROL(port_base)) |UART_CNTL_MASK_CLR_ERR,P_UART_CONTROL(port_base));//clear errors
+        writel(readl(P_UART_CONTROL(port_base)) & (~UART_CNTL_MASK_CLR_ERR),P_UART_CONTROL(port_base));
+
+    }
+
+
+    return ((int)ch);
+
+}
+
+static void serial_puts_port (unsigned long port_base,const char *s)
+{
+    while (*s) {
+        serial_putc_port(port_base,*s++);
+    }
+}
+#if CONFIG_SERIAL_MULTI
+#include <serial.h>
+#define DECLARE_UART_FUNCTIONS(port) \
+    static int  uart_##port##_init (void) {\
+	serial_init_port(port);	return(0);}\
+    static void uart_##port##_setbrg (void) {\
+	serial_setbrg_port(port);}\
+    static int  uart_##port##_getc (void) {\
+	return serial_getc_port(port);}\
+    static int  uart_##port##_tstc (void) {\
+	return serial_tstc_port(port);}\
+    static void uart_##port##_putc (const char c) {\
+	serial_putc_port(port, c);}\
+    static void uart_##port##_puts (const char *s) {\
+	serial_puts_port(port, s);}
+
+#define INIT_UART_STRUCTURE(port,_name,bus) static struct serial_device device_##port={\
+	.name	= _name,\
+	/*bus,*/\
+	.start	= uart_##port##_init,\
+	.stop	= NULL,\
+	.setbrg	= uart_##port##_setbrg,\
+	.getc	= uart_##port##_getc,\
+	.tstc	= uart_##port##_tstc,\
+	.putc	= uart_##port##_putc,\
+	.puts	= uart_##port##_puts, }
+
+DECLARE_UART_FUNCTIONS(UART_PORT_0);
+INIT_UART_STRUCTURE(UART_PORT_0,"uart0","UART0");
+DECLARE_UART_FUNCTIONS(UART_PORT_1);
+INIT_UART_STRUCTURE(UART_PORT_1,"uart1","UART1");
+#ifdef UART_PORT_AO
+DECLARE_UART_FUNCTIONS(UART_PORT_AO);
+INIT_UART_STRUCTURE(UART_PORT_AO,"uart_ao","UART_AO");
+#endif
+struct serial_device * default_serial_console (void)
+{
+#if (UART_PORT_CONS==UART_PORT_0)
+    return &device_UART_PORT_0;
+#elif (UART_PORT_CONS==UART_PORT_1)
+    return &device_UART_PORT_1;
+#else
+#ifdef UART_PORT_AO
+#if (UART_PORT_CONS==UART_PORT_AO)
+   return &device_UART_PORT_AO;
+#else
+	#error "invalid uart port index defined"
+#endif
+#endif
+#endif
+}
+void serial_aml_register(void)
+{
+    serial_register(&device_UART_PORT_0);
+    serial_register(&device_UART_PORT_1);
+#ifdef UART_PORT_AO
+    serial_register(&device_UART_PORT_AO);
+#endif
+}
+#endif
+#if !(defined CONFIG_SERIAL_MULTI)
+int serial_init(void){
+	return serial_init_port(UART_PORT_CONS);
+}
+
+void serial_putc(const char c){
+	serial_putc_port(UART_PORT_CONS,c);
+}
+
+int serial_tstc(void){
+	return serial_tstc_port(UART_PORT_CONS);
+}
+
+int serial_getc(void){
+	return serial_getc_port(UART_PORT_CONS);
+}
+
+void serial_puts(const char * s){
+	serial_puts_port(UART_PORT_CONS,s);
+}
+
+void serial_setbrg(void){
+	serial_setbrg_port(UART_PORT_CONS);
+}
+#ifdef CONFIG_CMD_KGDB
+
+
+#if UART_PORT_CONS==UART_PORT_0
+#define DEBUG_PORT UART_PORT_1
+#else
+#define DEBUG_PORT UART_PORT_0
+#endif
+
+int kgdb_serial_init(void){
+    int ret=serial_init_port(DEBUG_PORT);
+
+	return ret;
+}
+
+int getDebugChar(void){
+	return serial_getc_port(DEBUG_PORT);
+}
+
+void putDebugChar(const char c){
+	serial_putc_port(DEBUG_PORT,c);
+}
+
+void putDebugStr(const char * s){
+	serial_puts_port(DEBUG_PORT,s);
+}
+
+#endif  /* CONFIG_CMD_KGDB */
+
+#endif
+
diff --git a/drivers/storagekey/Makefile b/drivers/storagekey/Makefile
new file mode 100644
index 0000000..df6edd8
--- /dev/null
+++ b/drivers/storagekey/Makefile
@@ -0,0 +1,2 @@
+#
+obj-$(CONFIG_SECURE_STORAGE) += storagekey.o
diff --git a/drivers/storagekey/storagekey.c b/drivers/storagekey/storagekey.c
new file mode 100644
index 0000000..c91f5ef
--- /dev/null
+++ b/drivers/storagekey/storagekey.c
@@ -0,0 +1,260 @@
+/*
+ * drivers/storagekey/storagekey.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+/* extern from bl31 */
+/*
+ * when RET_OK
+ * query: retval=1: key exsit,=0: key not exsit
+ * tell: retvak = key size
+ * status: retval=1: secure, retval=0: non-secure
+
+ */
+
+#include <common.h>
+#include <linux/types.h>
+#include <amlogic/secure_storage.h>
+#include <amlogic/storage_if.h>
+
+/* key buffer status */
+/* bit0, dirty flag*/
+#define KEYBUFFER_CLEAN		(0 << 0)
+#define KEYBUFFER_DIRTY		(1 << 0)
+#define SECUESTORAGE_HEAD_SIZE		(256)
+#define SECUESTORAGE_WHOLE_SIZE		(0x40000)
+
+struct storagekey_info_t {
+	uint8_t * buffer;
+	uint32_t size;
+	uint32_t status;
+};
+
+static struct storagekey_info_t storagekey_info = {
+	.buffer = NULL,
+	/* default size */
+	.size = SECUESTORAGE_WHOLE_SIZE,
+	.status = KEYBUFFER_CLEAN,
+};
+
+/**
+ *1.init
+ * return ok 0, fail 1
+ */
+int32_t amlkey_init(uint8_t *seed, uint32_t len)
+{
+	int32_t ret = 0;
+	uint32_t buffer_size;
+
+	/* do nothing for now*/
+	printf("%s() enter!\n", __func__);
+	if (storagekey_info.buffer != NULL) {
+		printf("%s() %d: already init!\n", __func__, __LINE__);
+		goto _out;
+	}
+
+	/* get buffer from bl31 */
+	storagekey_info.buffer = secure_storage_getbuffer(&buffer_size);
+	if (storagekey_info.buffer == NULL) {
+		printf("%s() %d: can't get buffer from bl31!\n",
+				__func__, __LINE__);
+		ret = -1;
+		goto _out;
+	}
+	if (buffer_size != storagekey_info.size) {
+		printf("%s() %d: warnning! %d/%d\n",
+			__func__, __LINE__, buffer_size, storagekey_info.size);
+		/* using innor size!*/
+		storagekey_info.size = buffer_size;
+	}
+
+	/* full fill key infos from storage. */
+	ret = store_key_read(storagekey_info.buffer,  storagekey_info.size);
+	if (ret) {
+		/* memset head info for bl31 */
+		memset(storagekey_info.buffer, 0, SECUESTORAGE_HEAD_SIZE);
+		ret = 0;
+		goto _out;
+	}
+	secure_storage_notifier();
+_out:
+	return ret;
+}
+
+/**
+ *2. query if the key already programmed
+ * return: exsit 1, non 0
+ */
+int32_t amlkey_isexsit(const uint8_t * name)
+{
+	int32_t ret = 0;
+	uint32_t retval;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+
+	ret = secure_storage_query((uint8_t *)name, &retval);
+	if (ret) {
+		printf("%s() %d: ret %d\n", __func__, __LINE__, ret);
+		retval = 0;
+	}
+
+	return (int32_t)retval;
+}
+
+/**
+ * 3. query if the prgrammed key is secure
+ * return secure 1, non 0;
+ */
+int32_t amlkey_issecure(const uint8_t * name)
+{
+	int32_t ret = 0;
+	uint32_t retval;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+
+	ret = secure_storage_status((uint8_t *)name, &retval);
+	if (ret) {
+		printf("%s() %d: ret %d\n", __func__, __LINE__, ret);
+		retval = 0;
+	}
+
+	return (int32_t)retval;
+}
+
+/**
+ * 4. actual bytes of key value
+ *  return actual size.
+ */
+ssize_t amlkey_size(const uint8_t *name)
+{
+	ssize_t size = 0;
+	int32_t ret = 0;
+	uint32_t retval;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+
+	ret = secure_storage_tell((uint8_t *)name, &retval);
+	if (ret) {
+		printf("%s() %d: ret %d\n", __func__, __LINE__, ret);
+		retval = 0;
+	}
+	size = (ssize_t)retval;
+	return size;
+}
+
+/**
+ *5. read non-secure key in bytes, return bytes readback actully.
+ * return actual size read back.
+ */
+ssize_t amlkey_read(const uint8_t *name, uint8_t *buffer, uint32_t len)
+{
+	int32_t ret = 0;
+	ssize_t retval = 0;
+	uint32_t actul_len;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+	ret = secure_storage_read((uint8_t *)name, buffer, len, &actul_len);
+	if (ret) {
+		printf("%s() %d: return %d\n", __func__, __LINE__, ret);
+		retval = 0;
+		goto _out;
+	}
+	retval = actul_len;
+_out:
+	return retval;
+}
+
+/**
+ * 6.write secure/non-secure key in bytes , return bytes readback actully
+ * return actual size write down.
+ */
+ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t secure)
+{
+	int32_t ret = 0;
+	ssize_t retval = 0;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return retval;
+	}
+	ret = secure_storage_write((uint8_t *)name, buffer, len, secure);
+	if (ret) {
+		printf("%s() %d: return %d\n", __func__, __LINE__, ret);
+		retval = 0;
+		goto _out;
+	} else {
+		retval = (ssize_t)len;
+		/* write down! */
+		if (storagekey_info.buffer != NULL) {
+			ret = store_key_write(storagekey_info.buffer, storagekey_info.size);
+			if (ret) {
+				printf("%s() %d, store_key_write fail\n", __func__, __LINE__);
+				retval = 0;
+			}
+		}
+	}
+_out:
+	return retval;
+}
+/**
+ * 7. get the hash value of programmed secure key | 32bytes length, sha256
+ * return success 0, fail -1
+ */
+int32_t amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash)
+{
+	int32_t ret = 0;
+
+	ret = secure_storage_verify((uint8_t *)name, hash);
+
+	return ret;
+}
+
+/**
+ * 7. del key by name
+ * return success 0, fail -1
+ */
+int32_t amlkey_del(const uint8_t * name)
+{
+	int32_t ret = 0;
+
+	ret = secure_storage_remove((uint8_t *)name);
+	if ((ret == 0) && (storagekey_info.buffer != NULL)) {
+		/* flush back */
+		ret = store_key_write(storagekey_info.buffer, storagekey_info.size);
+		if (ret) {
+			printf("%s() %d, store_key_write fail\n", __func__, __LINE__);
+		}
+	} else {
+		printf("%s() %d, remove key fail\n", __func__, __LINE__);
+	}
+
+	return ret;
+}
+
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 70bb550..59d7be8 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -36,3 +36,6 @@ obj-$(CONFIG_MPC885_FAMILY) += mpc8xx_udc.o
 obj-$(CONFIG_CPU_PXA27X) += pxa27x_udc.o
 endif
 endif
+
+obj-$(CONFIG_AML_TINY_USBTOOL) += aml_tiny_usbtool/aml_tiny_usbtool.o \
+									aml_tiny_usbtool/burn_func.o
\ No newline at end of file
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/aml_tiny_usbtool.c b/drivers/usb/gadget/aml_tiny_usbtool/aml_tiny_usbtool.c
new file mode 100644
index 0000000..ff63a4d
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/aml_tiny_usbtool.c
@@ -0,0 +1,76 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/aml_tiny_usbtool.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include "platform.h"
+#include "usb_pcd.h"
+
+#include "usb_pcd.c"
+#include "platform.c"
+#include "dwc_pcd.c"
+#include "dwc_pcd_irq.c"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int usb_boot(int clk_cfg, int time_out)
+{
+	int cfg = INT_CLOCK;
+
+#if defined(CONFIG_SILENT_CONSOLE)
+	gd->flags &= ~GD_FLG_SILENT;
+#endif
+
+	if (clk_cfg)
+		cfg = EXT_CLOCK;
+	set_usb_phy_config(cfg);
+
+	usb_parameter_init(time_out);
+
+	if (usb_pcd_init())
+		return 0;
+
+	while (1)
+	{
+		//watchdog_clear();		//Elvis Fool
+		if (usb_pcd_irq())
+			break;
+	}
+	return 0;
+}
+
+int do_tiny_usbtool (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int time_out = 0;
+	if (argc > 1)
+	{
+		time_out = simple_strtol(argv[1], NULL, 10);
+	}
+	printf("Enter USB burning.\n");
+	return usb_boot(1, time_out);
+}
+
+
+U_BOOT_CMD(
+	tiny_usbtool,	2,	1,	do_tiny_usbtool,
+	"start tiny USB tool for PC burner",
+	"tiny_usbtool timeout"
+);
+
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/burn_func.c b/drivers/usb/gadget/aml_tiny_usbtool/burn_func.c
new file mode 100644
index 0000000..c4e843f
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/burn_func.c
@@ -0,0 +1,2371 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/burn_func.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include "usb_pcd.h"
+#include <common.h>
+
+#include <nand.h>
+#include <div64.h>
+#include <jffs2/jffs2.h>
+//#include <asm/arch/nand.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/ctype.h>
+#include <command.h>
+#include <watchdog.h>
+#include <malloc.h>
+#include <linux/mtd/mtd.h>
+#include <asm/byteorder.h>
+//#include <amlogic/efuse.h>
+#include <linux/string.h>
+#include <usb.h>
+
+
+//#define HDCP_PRINT
+#define SECUKEY_BYTES          512
+#define AML_KEY_NAMELEN    16
+#define HDCP_KEY_LEN            288
+#define HDCP2LC128_LEN        36
+#define HDCP2KEY_LEN            862
+#define HDCP2_KEY_TOTAL_LEN (HDCP2LC128_LEN+HDCP2KEY_LEN)
+#define HDCP2LC128_NAME     "hdcp2lc128"
+#define HDCP2KEY_NAME         "hdcp2key"
+// pctool version >= 1.6.32,return 3 status when read
+#define PCTOOL_VERSION_1632 (unsigned long)1632
+
+static unsigned long sPctoolVersion = 0;
+
+#ifdef WRITE_TO_EFUSE_ENABLE
+#define WRITE_EFUSE         0
+#define READ_EFUSE           1
+#define EFUSE_VERSION_MESON3        "01:02:03"
+#define EFUSE_VERSION_MESON6        "02"
+#define EFUSE_READ_TEST_ENABLE      1
+#ifdef CONFIG_AML_MESON3
+extern int do_efuse_usb(int argc, char * const argv[], char *buf);
+#elif defined(CONFIG_AML_MESON6)
+extern int cmd_efuse(int argc, char * const argv[], char *buf);
+#endif
+#endif
+
+extern int usb_get_update_result(void);
+
+#if defined(WRITE_TO_NAND_EMMC_ENABLE) || defined(WRITE_TO_NAND_ENABLE)
+static int sInitedSecukey = 0;
+extern int uboot_key_initial(char *device);
+extern ssize_t uboot_get_keylist(char *keyname);
+extern ssize_t uboot_key_read(char *keyname, char *keydata);
+extern ssize_t uboot_key_write(char *keyname, char *keydata);
+int ensure_secukey_init(void);
+int cmd_secukey(int argc, char *argv[], char *buf);
+#endif
+
+
+#if defined(CONFIG_SECURE_STORAGE_BURNED)
+#include <amlogic/secure_storage.h>
+static int sInitedSecurestore = 0;
+extern int securestore_key_init( char *seed,int len);
+extern int securestore_key_query(char *keyname, unsigned int *query_return);
+extern int securestore_key_read(char *keyname,char *keybuf,unsigned int keylen,unsigned int *reallen);
+extern int securestore_key_write(char *keyname, char *keybuf,unsigned int keylen,int keytype);
+extern int securestore_key_uninit(void);
+int ensure_securestore_key_init(char *seed, int seed_len);
+int cmd_securestore(int argc, char *argv[], char *buf);
+#endif
+
+void hdcpDataEncryption(const int len, const char *input, char *out);
+void hdcpDataDecryption(const int len, const char *input, char *out);
+
+extern void _mdelay(unsigned long ms);
+extern void _udelay(unsigned int us);
+
+
+/* hdcp key verify code */
+#define DWORD unsigned int  //4 bytes
+#define BYTE unsigned char   //1 byte
+#define SHA1_MAC_LEN 20
+
+typedef struct {
+        DWORD state[5];
+        DWORD count[2];
+        BYTE buffer[64];
+} SHA1_CTX;
+
+void SHA1Reset(SHA1_CTX *context);
+void SHA1Input(SHA1_CTX *context, BYTE *data, DWORD len);
+void SHA1Result(SHA1_CTX *context, BYTE *digest);//20
+void SHA1Transform_H(DWORD *state, BYTE *buffer); //5  64
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+/* blk0() and blk() perform the initial expand. */
+/* I got the idea of expanding during the round function from SSLeay */
+
+#define blk0(i) (workspace[i] = (rol(block->l[i], 24) & 0xFF00FF00) | \
+        (rol(block->l[i], 8) & 0x00FF00FF))
+#define blk(i) (workspace[i & 15] = rol(block->l[(i + 13) & 15] ^ \
+        block->l[(i + 8) & 15] ^ block->l[(i + 2) & 15] ^ block->l[i & 15], 1))
+
+/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) \
+        z += (((w & (x ^ y)) ^ y) + blk0(i) + 0x5A827999 + rol(v, 5)); \
+        w = rol(w, 30);
+#define R1(v,w,x,y,z,i) \
+        z += (((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5)); \
+        w = rol(w, 30);
+#define R2(v,w,x,y,z,i) \
+        z += ((w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5)); w = rol(w, 30);
+#define R3(v,w,x,y,z,i) \
+        z += ((((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5)); \
+        w = rol(w, 30);
+#define R4(v,w,x,y,z,i) \
+        z += ((w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5)); \
+        w=rol(w, 30);
+
+/*********************************************************************/
+static int parse_line (char *line, char *argv[])
+{
+	int nargs = 0;
+
+#ifdef DEBUG_PARSER
+	printf ("parse_line: \"%s\"\n", line);
+#endif
+	while (nargs < CONFIG_SYS_MAXARGS) {
+
+		/* skip any white space */
+		while ((*line == ' ') || (*line == '\t')) {
+			++line;
+		}
+
+		if (*line == '\0') {	/* end of line, no more args	*/
+			argv[nargs] = NULL;
+#ifdef DEBUG_PARSER
+		printf ("parse_line: nargs=%d\n", nargs);
+#endif
+			return (nargs);
+		}
+
+		argv[nargs++] = line;	/* begin of argument string	*/
+
+		/* find end of string */
+		while (*line && (*line != ' ') && (*line != '\t')) {
+			++line;
+		}
+
+		if (*line == '\0') {	/* end of line, no more args	*/
+			argv[nargs] = NULL;
+#ifdef DEBUG_PARSER
+		printf ("parse_line: nargs=%d\n", nargs);
+#endif
+			return (nargs);
+		}
+
+		*line++ = '\0';		/* terminate current arg	 */
+	}
+
+	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
+
+#ifdef DEBUG_PARSER
+	printf ("parse_line: nargs=%d\n", nargs);
+#endif
+	return (nargs);
+}
+
+/* Hash a single 512-bit block. This is the core of the algorithm. */
+void SHA1Transform_H(DWORD *state, BYTE *buffer)
+{
+        DWORD a, b, c, d, e;
+        typedef union {
+                BYTE c[64];
+                DWORD l[16];
+        } CHAR64LONG16;
+        CHAR64LONG16 *block;
+
+        DWORD workspace[16];
+        block = (CHAR64LONG16 *)workspace;
+        memcpy(block, buffer, 64);
+
+        /* Copy context->state[] to working vars */
+        a = state[0];
+        b = state[1];
+        c = state[2];
+        d = state[3];
+        e = state[4];
+        /* 4 rounds of 20 operations each. Loop unrolled. */
+        R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);_udelay(100);
+        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);_udelay(100);
+        R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);_udelay(100);
+        R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);_udelay(100);
+        R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);_udelay(100);
+        R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);_udelay(100);
+        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);_udelay(100);
+        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);_udelay(100);
+        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);_udelay(100);
+        R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);_udelay(100);
+        R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);_udelay(100);
+        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);_udelay(100);
+        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);_udelay(100);
+        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);_udelay(100);
+        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);_udelay(100);
+        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);_udelay(100);
+        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);_udelay(100);
+        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);_udelay(100);
+        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);_udelay(100);
+        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);_udelay(100);
+        /* Add the working vars back into context.state[] */
+        state[0] += a;
+        state[1] += b;
+        state[2] += c;
+        state[3] += d;
+        state[4] += e;
+        /* Wipe variables */
+        a = b = c = d = e = 0;
+
+        memset(block, 0, 64);
+}
+
+
+/* SHA1Reset - Initialize new context */
+
+void SHA1Reset(SHA1_CTX *context)
+{
+        /* SHA1 initialization constants */
+        context->state[0] = 0x67452301;
+        context->state[1] = 0xEFCDAB89;
+        context->state[2] = 0x98BADCFE;
+        context->state[3] = 0x10325476;
+        context->state[4] = 0xC3D2E1F0;
+        context->count[0] = context->count[1] = 0;
+}
+
+
+/* Run your data through this. */
+
+void SHA1Input(SHA1_CTX* context, BYTE *_data, DWORD len)
+{
+        DWORD i, j;
+        BYTE *data = _data;
+
+        j = (context->count[0] >> 3) & 63;
+        if ((context->count[0] += len << 3) < (len << 3))
+                context->count[1]++;
+        context->count[1] += (len >> 29);
+        if ((j + len) > 63) {
+                memcpy(&context->buffer[j], data, (i = 64-j));
+                SHA1Transform_H(context->state, context->buffer);
+                for ( ; i + 63 < len; i += 64) {
+                        SHA1Transform_H(context->state, &data[i]);
+                }
+                j = 0;
+        }
+        else i = 0;
+        memcpy(&context->buffer[j], &data[i], len - i);
+
+}
+
+
+/* Add padding and return the message digest. */
+
+void SHA1Result(SHA1_CTX *context, BYTE *digest)
+{
+        DWORD i;
+        BYTE finalcount[8];
+
+        for (i = 0; i < 8; i++) {
+                finalcount[i] = (BYTE)
+                        ((context->count[(i >= 4 ? 0 : 1)] >>
+                          ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
+        }
+        SHA1Input(context, (BYTE *) "\200", 1);
+        while ((context->count[0] & 504) != 448) {
+                SHA1Input(context, (BYTE *) "\0", 1);
+        }
+        SHA1Input(context, finalcount, 8);  /* Should cause a SHA1Transform_H()
+                                              */
+        for (i = 0; i < 20; i++) {
+                digest[i] = (BYTE)
+                        ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) &
+                         255);
+        }
+        /* Wipe variables */
+        i = 0;
+        memset(context->buffer, 0, 64);
+        memset(context->state, 0, 20);
+        memset(context->count, 0, 8);
+        memset(finalcount, 0, 8);
+}
+ /**************************************************************************
+ * NOTES:       Test Vectors (from FIPS PUB 180-1) to verify implementation
+ *              1- Input : "abc"
+ *              Output : A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
+ *              2- Input : "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
+ *              Output : 84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
+ *              2- Input : A million repetitions of 'a' - not applied (memory shortage)
+ *              Output : 34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
+ *              More test vectors can be obtained from FIPS web site
+ ***************************************************************************/
+void SHA1_Perform(BYTE *indata, DWORD inlen, BYTE *outdata) //calculate SHA-1 API
+{
+    SHA1_CTX sha;
+    SHA1Reset(&sha);
+    SHA1Input(&sha, indata, inlen);
+    SHA1Result(&sha, outdata);
+}
+
+typedef struct
+{
+    unsigned char ksv[5];
+    unsigned char rsv[3];
+    unsigned char dpk[280];
+    unsigned char sha[20];
+}hdcp_llc_file;
+
+
+#if defined(WRITE_TO_EFUSE_ENABLE)
+static int _cmd_efuse(int argc, char * const argv[], char *buf)
+{
+    int i, action = -1;
+    efuseinfo_item_t info;
+    char *title;
+    char *s;
+    char *end;
+
+    if (!strncmp(argv[1], "read", 4))
+        action = READ_EFUSE;
+    else if(!strncmp(argv[1], "write", 5))
+        action = WRITE_EFUSE;
+    else {
+        printf("%s arg error\n", argv[1]);
+        return -1;
+    }
+
+    //efuse read
+    if (action == READ_EFUSE) {
+        title = argv[2];
+        if (efuse_getinfo(title, &info) < 0)
+            return -1;
+
+        memset(buf, 0, EFUSE_BYTES);
+        efuse_read_usr(buf, info.data_len, (loff_t *)&info.offset);
+        printf("info.data_len=%d\n", info.data_len);
+        printf("%s is:\n", title);
+        for (i=0; i<(info.data_len); i++)
+            printf("%02x:", buf[i]);
+        printf("\n");
+    }
+
+    //efuse write
+    else if(action == WRITE_EFUSE) {
+        if (argc < 4) {
+            printf("arg count error\n");
+            return -1;
+        }
+        title = argv[2];
+        if (efuse_getinfo(title, &info) < 0)
+            return -1;
+        if (!(info.we)) {
+            printf("%s write unsupport now. \n", title);
+            return -1;
+        }
+
+        memset(buf, 0, info.data_len);
+        s = argv[3];
+
+        //for usb burn key to efuse
+        if (!strncmp(title, "usid", strlen("usid")))	        //burn usid data(format:"xxxx...", it's string)
+            memcpy(buf, s, strlen(s));
+        else if(!strncmp(title, "hdcp", strlen("hdcp"))) //burn hdcp data(format:xx xx, it's data)
+            memcpy(buf, s, HDCP_KEY_LEN);
+        else {                          //burn version, mac, mac_bt, mac_wifi, customerid(format:"xx:xx:xx...", it's string)
+            for (i=0; i<info.data_len; i++) {
+                buf[i] = s ? simple_strtoul(s, &end, 16) : 0;
+                if (s)
+                    s = (*end) ? end+1 : end;
+            }
+            if (*s) {
+                printf("error: The wriiten data length is too large.\n");
+                return -1;
+            }
+        }
+
+        if (efuse_write_usr(buf, info.data_len, (loff_t*)&info.offset) < 0) {
+            printf("error: efuse write fail.\n");
+            return -1;
+        }
+        else
+            printf("%s written done.\n", info.title);
+    }
+    else {
+        printf("arg error\n");
+        return -1;
+    }
+
+    return 0;
+}
+static int run_efuse_cmd(int argc, char *argv[], char *buff)
+{
+   int ret = -1;
+
+#ifdef CONFIG_AML_MESON3
+   ret = do_efuse_usb(argc, argv, buff);
+#elif defined(CONFIG_AML_MESON6)
+   //ret = cmd_efuse(argc, argv, buff);
+   ret = _cmd_efuse(argc, argv, buff);
+#endif
+
+   return ret;
+}
+
+#if defined(EFUSE_READ_TEST_ENABLE)
+static int test_efuse_read(int argc, char *argv[], char *cmpBuff)
+{
+   int i = 0, j = 0, ret = -1;
+   int hdcp_flag = 0, hdcp_key_len = 288;
+   char *hdcp = NULL;
+   char efuse_data[SECUKEY_BYTES], reBuff[SECUKEY_BYTES], tmpBuf[SECUKEY_BYTES];
+
+   printf("-----Test efuse read commond:\n");
+   for (i=0; i<argc; i++)
+      printf("argv[%d]=%s\n", i, argv[i]);
+
+   if (!strncmp(argv[0], "efuse", 5) && !strncmp(argv[1], "read", 4) &&
+      (!strncmp(argv[2], "version", 7) ||!strncmp(argv[2], "mac_wifi", 8) ||
+      !strncmp(argv[2], "mac_bt", 6) ||!strncmp(argv[2], "mac", 3) ||
+      !strncmp(argv[2], "usid", 4) ||!strncmp(argv[2], "hdcp", 4))) {
+      goto run;
+   }
+   else {
+      printf("test efuse read commond not mach\n");
+      return -3;
+   }
+
+run:
+   memset(efuse_data, 0, sizeof(efuse_data));
+   memset(reBuff, 0, sizeof(reBuff));
+   memset(tmpBuf, 0, sizeof(tmpBuf));
+
+   ret = run_efuse_cmd(argc, argv, reBuff);
+   if (!ret) {
+      // test efuse read version
+      if (!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "version", strlen("version"))) {
+#ifdef CONFIG_AML_MESON3
+         sprintf(efuse_data, "%02x:%02x:%02x", reBuff[0], reBuff[1], reBuff[2]);
+#elif defined(CONFIG_AML_MESON6)
+         sprintf(efuse_data, "%02x", reBuff[0]);
+#endif
+         if (!strncmp(efuse_data, cmpBuff, strlen(cmpBuff))) {
+            printf("test efuse read version success,read version=%s\n", efuse_data);
+            return 0;
+         }
+         else {
+            printf("test efuse read version success,read version=%s, but not mach %s\n", efuse_data, cmpBuff);
+            return -1;
+         }
+      }
+      // test efuse read mac/mac_bt/mac_wifi
+      else if(!strncmp(argv[1], "read", strlen("read")) && (!strncmp(argv[2], "mac", strlen("mac")) ||
+         !strncmp(argv[2], "mac_bt", strlen("mac_bt")) ||!strncmp(argv[2], "mac_wifi", strlen("mac_wifi")))) {
+         sprintf(efuse_data, "%02x:%02x:%02x:%02x:%02x:%02x", reBuff[0], reBuff[1], reBuff[2], reBuff[3], reBuff[4], reBuff[5]);
+         if (!strncmp(efuse_data, cmpBuff, strlen(cmpBuff))) {
+            printf("test efuse read %s success,read %s=%s\n", argv[2], argv[2], efuse_data);
+            return 0;
+         }
+         else {
+            printf("test efuse read %s success,read %s=%s, but not mach %s\n", argv[2], argv[2], efuse_data, cmpBuff);
+            return -1;
+         }
+      }
+      // test efuse read usid
+      else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "usid", strlen("usid"))) {
+         for (i=0; i<strlen(cmpBuff); i++) {
+            sprintf(tmpBuf, "%c", reBuff[i]);
+            sprintf(&efuse_data[j], "%s", tmpBuf);
+            j += strlen(tmpBuf);
+            memset(tmpBuf, 0, sizeof(tmpBuf));
+         }
+         if (!strncmp(efuse_data, cmpBuff, strlen(cmpBuff))) {
+            printf("test efuse read usid success,read usid=%s\n", efuse_data);
+            return 0;
+         }
+         else {
+            printf("test efuse read usid success,read usid=%s, but not mach %s\n", efuse_data, cmpBuff);
+            return -1;
+         }
+      }
+      // test efuse read hdcp
+      else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "hdcp", strlen("hdcp"))) {
+         hdcp = cmpBuff;
+         for (i=0; i<hdcp_key_len; i++) {
+            if (reBuff[i] != *hdcp ++) {
+               hdcp_flag = 1;
+               break;
+            }
+         }
+         if (!hdcp_flag) {
+            printf("test efuse read hdcp success\n");
+            printf("read hdcp is:\n");
+            for (i=0; i<hdcp_key_len; i++)
+               printf("%02x:", reBuff[i]);
+            printf("\n");
+            return 0;
+         }
+         else {
+            printf("test efuse read hdcp success,but not mach\n");
+            return -1;
+         }
+      }
+   }
+   else {
+      printf("test efuse read %s fail\n", argv[2]);
+      return -2;
+   }
+
+   return ret;
+}
+#endif    /* EFUSE_READ_TEST_ENABLE */
+#endif    /* WRITE_TO_EFUSE_ENABLE  */
+
+
+int burn_board(const char *dev, void *mem_addr, u64 offset, u64 size)
+{
+	char	str[128];
+	printf("burn_board!!!\n");
+	printf("CMD: dev=%s, mem_addr=0x%llx, offset=0x%llx, size=0x%llx\n", dev, (unsigned long long)mem_addr, offset, size);
+	if (!strncmp("nand", (const char *)(unsigned long long)(*dev), 4))
+	{
+		sprintf(str, "nand erase 0x%llx 0x%llx}", offset, size);
+		printf("command:    %s\n", str);
+		run_command(str, 0);
+		sprintf(str, "nand write 0x%llx 0x%llx 0x%llx}", (unsigned long long)mem_addr, offset, size);
+		printf("command:    %s\n", str);
+		run_command(str, 0);
+	}
+	else if(!strncmp("spi", (const char *)(unsigned long long)(*dev), 3))
+	{
+		run_command("sf probe 2", 0);
+		sprintf(str, "sf erase 0x%llx 0x%llx}", offset, size);
+		printf("command:    %s\n", str);
+		run_command(str, 0);
+		sprintf(str, "sf write 0x%llx 0x%llx 0x%llx}", (unsigned long long)mem_addr, offset, size);
+		printf("command:    %s\n", str);
+		run_command(str, 0);
+	}
+	else if(!strncmp("emmc", (const char *)(unsigned long long)(*dev), 4))
+	{
+		sprintf(str, "mmc write 1 0x%llx 0x%llx 0x%llx}", (unsigned long long)mem_addr, offset, size);
+		printf("command:    %s\n", str);
+		run_command(str, 0);
+	}
+	else
+	{
+		printf("Invalid Argument!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int usb_bootm(const void *addr)
+{
+	char cmd[128];
+	memset(cmd, 0, sizeof(cmd));
+	sprintf(cmd, "bootm %llx", (unsigned long long)addr);
+	return run_command(cmd, 0);
+}
+
+u32 checkcum_32(const unsigned char *buf, u32 len)
+{
+	u32 fake_len, chksum = 0;
+	u32 *ptr = (u32 *)buf;
+	int i;
+	printf("buf=0x%08llx, len=0x%x\n", (unsigned long long)buf, len);
+	if (len%4)
+	{
+		fake_len = len - len%4 + 4;
+		memset((void *)(buf+len), 0, (fake_len-len));
+	}
+	else
+	{
+		fake_len = len;
+	}
+	printf("fake_len=0x%x\n", fake_len);
+	for (i=0; i<fake_len; i+=4, ptr++)
+	{
+		chksum += *ptr;
+	}
+	return chksum;
+}
+
+
+int usb_run_command (const char *cmd, char* buff)
+{
+	int ret = -1, flag = 0;
+	u64 addr = 0, length = 0;
+	u32 crc_value, crc_verify = 0;
+	int argc;
+	char *argv[CONFIG_SYS_MAXARGS + 1];	/* NULL terminated	*/
+	printf("\n\n---Tool cmd: %s\n", cmd);
+
+	memset(buff, 0, CMD_BUFF_SIZE);
+	if (strncmp(cmd,"get update result",(sizeof("get update result")-1)) == 0) {
+		ret = usb_get_update_result();
+		if (!ret)
+		{
+			strcpy(buff, "success");
+		}
+		else
+		{
+			strcpy(buff, "fail");
+		}
+		return ret;
+	}
+	else if(strncmp(cmd,"usb_bootm",(sizeof("usb_bootm")-1)) == 0){
+		addr = *((u32*)(&cmd[60]));
+		strcpy(buff, "okay");
+		usb_bootm((const void *)addr);
+		strcpy(buff, "fail");
+		return -1;
+	}
+	else if(strncmp(cmd,"crc",(sizeof("crc")-1)) == 0){
+		if ((argc = parse_line ((char *)cmd, argv)) == 0) {
+			return -1;	/* no command at all */
+		}
+		addr = simple_strtoul (argv[1], NULL, 16);
+		length = simple_strtoul (argv[2], NULL, 10);
+		crc_verify = simple_strtoul (argv[3], NULL, 16);
+		//crc_value = crc32 (0, (const uchar *) addr, length);
+		crc_value = checkcum_32((const unsigned char *)addr, length);
+		printf("crc_value=0x%x\n", crc_value);
+		if (crc_verify == crc_value)
+		{
+			strcpy(buff, "success");
+		}
+		else
+		{
+			strcpy(buff, "failed");
+		}
+	}
+	else if(strncmp(cmd,"cmd_in_mem",(sizeof("cmd_in_mem")-1)) == 0){
+		char *cmd_in_mem = NULL;
+		/* Extract arguments */
+		if ((argc = parse_line ((char *)cmd, argv)) == 0) {
+			return -1;	/* no command at all */
+		}
+		cmd_in_mem = (char *)simple_strtoul(argv[1], NULL, 0);
+		printf("cmd_in_mem: %s\n", cmd_in_mem);
+		if (run_command(cmd_in_mem, flag))
+		{
+			strcpy(buff, "fail");
+			return -1;
+		}
+		else
+		{
+			strcpy(buff, "okay");
+		}
+	}
+/*
+  *    pctool version >= 1.6.32,teturn 3 status in read
+  *    "pctool version:"
+  *
+  *	burn keys to efuse/nand/emmc common command:
+  *	"efuse read version"
+  *	"efuse write version"
+  *	"efuse read mac"
+  *	"efuse write mac xx:xx:xx:xx:xx:xx"
+  *	"efuse read bt_mac"
+  *	"efuse write bt_mac xx:xx:xx:xx:xx:xx"
+  *	"efuse read wifi_mac"
+  *	"efuse write wifi_mac xx:xx:xx:xx:xx:xx"
+  *	"efuse read usid"
+  *	"efuse write usid xxxxx..."
+  *	"read hdcp"
+  *	"write hdcp:"   (hdcp key datas form 0x82000000 address)
+  *	"read hdcp2"
+  *	"write hdcp2:" (hdcp2 key datas form 0x82000000 address)
+  *
+  *	or: burn keys to efuse/nand private command:
+  *	"secukey_efuse/secukey_nand read version"
+  *	"secukey_efuse/secukey_nand write version"
+  *	"secukey_efuse/secukey_nand read mac"
+  *	"secukey_efuse/secukey_nand write mac xx:xx:xx:xx:xx:xx"
+  *	"secukey_efuse/secukey_nand read bt_mac"
+  *	"secukey_efuse/secukey_nand write bt_mac xx:xx:xx:xx:xx:xx"
+  *	"secukey_efuse/secukey_nand read wifi_mac"
+  *	"secukey_efuse/secukey_nand write wifi_mac xx:xx:xx:xx:xx:xx"
+  *	"secukey_efuse/secukey_nand read usid"
+  *	"secukey_efuse/secukey_nand write usid xxxxx..."
+  *	"secukey_efuse/secukey_nand read hdcp"
+  *	"secukey_efuse/secukey_nand write hdcp:" (hdcp key datas form 0x82000000 address)
+  *	"secukey_nand read boardid"
+  *	"secukey_nand write boardid:"    (boardid key datas form 0x82000000 address)
+  *	"secukey_nand read serialno"
+  *	"secukey_nand write serialno:"    (serialno key datas form 0x82000000 address)
+  *	"secukey_nand read MFG_Serialno"
+  *	"secukey_nand write MFG_Serialno:"    (MFG_Serialno key datas form 0x82000000 address)
+  *
+  *    // for key to securestorage
+  *	"efuse write random"   (random datas form 0x82000000 address)
+  *	"efuse read widevinekeybox"
+  *	"efuse write widevinekeybox"     (widevinekeybox datas form 0x82000000 address)
+  *	"efuse read PlayReadykeybox"
+  *	"efuse write PlayReadykeybox"   (PlayReadykeybox datas form 0x82000000 address)
+  *	"efuse read MobiDRMPrivate"
+  *	"efuse write MobiDRMPrivate"     (MobiDRMPrivate datas form 0x82000000 address)
+  *	"efuse read MobiDRMPublic"
+  *	"efuse write MobiDRMPublic"       (MobiDRMPublic datas form 0x82000000 address)
+  *
+  **/
+      else if(!strncmp(cmd, "pctool version:", strlen("pctool version:")) ||!strncmp(cmd, "efuse", strlen("efuse")) ||
+            !strncmp(cmd, "read hdcp2", strlen("read hdcp2")) ||!strncmp(cmd, "write hdcp2:", strlen("write hdcp2:")) ||
+            !strncmp(cmd, "read hdcp", strlen("read hdcp")) ||!strncmp(cmd, "write hdcp:", strlen("write hdcp:")) ||
+            !strncmp(cmd, "secukey_efuse", strlen("secukey_efuse")) ||!strncmp(cmd, "secukey_nand", strlen("secukey_nand"))) {
+            int i = 0, key_device_index = -1, random_len = 0;
+            char widevinekeybox_verify_data_receive[20], widevinekeybox_verify_data_calculate[20];
+            char PlayReadykeybox_verify_data_receive[20], PlayReadykeybox_verify_data_calculate[20];
+            char MobiDRMPrivate_verify_data_receive[20], MobiDRMPrivate_verify_data_calculate[20];
+            char MobiDRMPublic_verify_data_receive[20], MobiDRMPublic_verify_data_calculate[20];
+            char key_data[SECUKEY_BYTES], hdcp_verify_data_receive[20], hdcp_verify_data_calculate[20];
+            char hdcp2lc128[HDCP2LC128_LEN], hdcp2key[HDCP2KEY_LEN], hdcp2TotalData[HDCP2_KEY_TOTAL_LEN];
+            char hdcp2_verify_data_receive[20], hdcp2_verify_data_calculate[20];
+            char *random = NULL;
+
+            enum {
+                RANDOM_MAX_LEN = 32,
+                WIDEVINEKEYBOX_MAX_LEN  = 128,
+                PLAYREADYKEYBOX_MAX_LEN  = 16*1024, // max:16k
+                MOBIDRMPRIVATE_MAX_LEN = 1200,
+                MOBIDRMPUBLIC_MAX_LEN = 300,
+            };
+
+            //added to remover warnning
+
+            if (!strncmp(cmd, "pctool version:", strlen("pctool version:"))) {
+                sPctoolVersion = simple_strtoul((char *)(cmd+strlen("pctool version:")), 0, 10);
+                sprintf(buff, "success:(sPctoolVersion:%d)", (int)sPctoolVersion);
+                printf("%s\n", buff);
+                return 0;
+            }
+
+            /* Extract arguments */
+            if (!strncmp(cmd, "read hdcp2", 10) || !strncmp(cmd, "write hdcp2:", 12)) {
+                char cmd_hdcp2[50] = {0};
+                strncpy(cmd_hdcp2, cmd, strlen(cmd));
+                sprintf((char *)cmd, "%s %s", "flash", cmd_hdcp2);  // add parameter for hdcp2 command
+                printf("Actual cmd:%s\n", cmd);
+            }
+            else if(!strncmp(cmd, "read hdcp", 9) || !strncmp(cmd, "write hdcp:", 11)) {
+                char cmd_hdcp[50] = {0};
+                strncpy(cmd_hdcp, cmd, strlen(cmd));
+                sprintf((char *)cmd, "%s %s", "efuse", cmd_hdcp);  // add parameter for hdcp command
+                printf("Actual cmd:%s\n", cmd);
+            }
+
+            if ((argc = parse_line ((char *)cmd, argv)) == 0) {
+               return -1;	/* no command at all */
+            }
+
+            memset(key_data, 0, sizeof(key_data));
+            memset(hdcp_verify_data_receive, 0, sizeof(hdcp_verify_data_receive));
+            memset(hdcp_verify_data_calculate, 0, sizeof(hdcp_verify_data_calculate));
+            memset(hdcp2lc128, 0, sizeof(hdcp2lc128));
+            memset(hdcp2key, 0, sizeof(hdcp2key));
+            memset(hdcp2TotalData, 0, sizeof(hdcp2TotalData));
+            memset(hdcp2_verify_data_receive, 0, sizeof(hdcp2_verify_data_receive));
+            memset(hdcp2_verify_data_calculate, 0, sizeof(hdcp2_verify_data_calculate));
+            memset(widevinekeybox_verify_data_receive, 0, sizeof(widevinekeybox_verify_data_receive));
+            memset(widevinekeybox_verify_data_calculate, 0, sizeof(widevinekeybox_verify_data_calculate));
+            memset(PlayReadykeybox_verify_data_receive, 0, sizeof(PlayReadykeybox_verify_data_receive));
+            memset(PlayReadykeybox_verify_data_calculate, 0, sizeof(PlayReadykeybox_verify_data_calculate));
+            memset(MobiDRMPrivate_verify_data_receive, 0, sizeof(MobiDRMPrivate_verify_data_receive));
+            memset(MobiDRMPrivate_verify_data_calculate, 0, sizeof(MobiDRMPrivate_verify_data_calculate));
+            memset(MobiDRMPublic_verify_data_receive, 0, sizeof(MobiDRMPublic_verify_data_receive));
+            memset(MobiDRMPublic_verify_data_calculate, 0, sizeof(MobiDRMPublic_verify_data_calculate));
+
+
+#if defined(WRITE_TO_NAND_EMMC_ENABLE) || defined(WRITE_TO_NAND_ENABLE) || defined(WRITE_TO_EFUSE_ENABLE)
+            char* hdcp = NULL;
+#endif
+
+/* Burn key to efuse */
+/* ---Command process */
+#ifdef  WRITE_TO_EFUSE_ENABLE
+            if (strncmp(argv[0], "efuse", strlen("efuse")) && strncmp(argv[0], "secukey_efuse", strlen("secukey_efuse"))) {
+               sprintf(buff, "%s", "failed:(code compiled burn to efuse,but cmd not mach with pc send)");
+               printf("%s\n", buff);
+               return -1;
+            }
+            printf("burn key to efuse. convert command...\n");
+            if (!strncmp(argv[0], "secukey_efuse", strlen("secukey_efuse")))
+               argv[0] = "efuse";
+
+            if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "version", strlen("version"))) {
+               argc ++;
+#ifdef CONFIG_AML_MESON3
+               argv[3] = EFUSE_VERSION_MESON3;
+               printf("CONFIG_AML_MESON3 VERSION(version:%s)\n",argv[3]);
+#elif defined(CONFIG_AML_MESON6)
+               argv[3] = EFUSE_VERSION_MESON6;
+               printf("CONFIG_AML_MESON6 VERSION(version:%s)\n",argv[3]);
+#endif
+            }
+
+            if (!strncmp(argv[2], "bt_mac", strlen("bt_mac")))
+               strncpy(argv[2], "mac_bt", strlen("mac_bt"));
+
+            if (!strncmp(argv[2], "wifi_mac", strlen("wifi_mac")))
+               strncpy(argv[2], "mac_wifi", strlen("mac_wifi"));
+
+            if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "hdcp:", strlen("hdcp:"))) {
+#define HDCP_DATA_ADDR	(volatile unsigned long *)(0x82000000)	//get hdcp data from address:0x82000000
+               hdcp = (char *)HDCP_DATA_ADDR;
+               printf("receive %d hdcp key datas from address:0x82000000:\n", HDCP_KEY_LEN);
+               for (i=0; i<HDCP_KEY_LEN; i++) {                                            //read 288 hdcp datas
+                  key_data[i] = *hdcp++;
+                  printf("%.2x:", key_data[i]);
+               }
+               printf("\nreceive 20 hdcp key verify datas:\n");
+               for (i=0; i<20; i++) {											     //read 20 hdcp verify datas
+                  hdcp_verify_data_receive[i] = *hdcp++;
+                  printf("%.2x:", hdcp_verify_data_receive[i]);
+               }
+               printf("\n");
+
+               printf("start to verify %d hdcp key datas...\n", HDCP_KEY_LEN);
+               SHA1_Perform(key_data, HDCP_KEY_LEN, hdcp_verify_data_calculate);
+               printf("verify & get 20 hdcp verify datas:\n");
+               for (i=0; i<20; i++)
+                    printf("%.2x:", hdcp_verify_data_calculate[i]);
+               printf("\n");
+
+               int ret = memcmp(hdcp_verify_data_receive, hdcp_verify_data_calculate, 20);
+               if (ret == 0) {
+                    printf("hdcp datas verify success\n");
+                    argv[0] = "efuse";
+                    argv[1] = "write";
+                    argv[2] = "hdcp";
+                    argv[3] = key_data;
+                    argc = 4;
+               }
+               else {
+                    sprintf(buff, "%s", "failed:(hdcp datas verify failed)");
+                    printf("%s\n", buff);
+                    return -1;
+               }
+            }
+#endif   /* WRITE_TO_EFUSE_ENABLE */
+
+
+#if defined(WRITE_TO_NAND_EMMC_ENABLE) || defined(WRITE_TO_NAND_ENABLE)
+             char* hdcp2 = NULL;
+#endif
+
+/* Burn key to nand/emmc */
+/* ---Command process */
+#if defined(WRITE_TO_NAND_EMMC_ENABLE) || defined(WRITE_TO_NAND_ENABLE)
+            if (strncmp(argv[0], "efuse", strlen("efuse")) && strncmp(argv[0], "secukey_nand", strlen("secukey_nand")) &&
+                strncmp(argv[0], "flash", strlen("flash"))) {
+               sprintf(buff, "%s", "failed:(code compiled burn to flash,but cmd not mach with pc send)");
+               printf("%s\n", buff);
+               return -1;
+            }
+
+            printf("burn key to flash. convert command...\n");
+            if (!strncmp(argv[0], "efuse", strlen("efuse"))||!strncmp(argv[0], "secukey_nand", strlen("secukey_nand")))
+               argv[0] = "flash";
+
+            if (!strncmp(argv[2], "bt_mac", strlen("bt_mac")))
+               strncpy(argv[2], "mac_bt", strlen("mac_bt"));
+
+            if (!strncmp(argv[2], "wifi_mac", strlen("wifi_mac")))
+               strncpy(argv[2], "mac_wifi", strlen("mac_wifi"));
+
+            if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "hdcp2:", strlen("hdcp2:"))) {
+#define HDCP2_DATA_ADDR	(volatile unsigned long *)(0x82000000)
+               hdcp2 = (char *)HDCP2_DATA_ADDR;
+               printf("receive %d %s datas from address:0x82000000:\n", HDCP2LC128_LEN, HDCP2LC128_NAME);
+               memcpy((char *)hdcp2lc128, (char *)hdcp2, HDCP2LC128_LEN);
+#ifdef HDCP_PRINT
+               for (i=0; i<HDCP2LC128_LEN; i++) {
+                  printf("%.2x:", hdcp2lc128[i]);
+               }
+               printf("\n");
+#else
+               printf("receive %d %s datas ok !!!\n", HDCP2LC128_LEN, HDCP2LC128_NAME);
+#endif
+
+               printf("receive %d %s datas from address:0x82000024:\n", HDCP2KEY_LEN, HDCP2KEY_NAME);
+               memcpy((char *)hdcp2key, (char *)(hdcp2+HDCP2LC128_LEN), HDCP2KEY_LEN);
+#ifdef HDCP_PRINT
+               for (i=0; i<HDCP2KEY_LEN; i++) {
+                  printf("%.2x:", hdcp2key[i]);
+               }
+               printf("\n");
+#else
+               printf("receive %d %s datas ok !!!\n", HDCP2KEY_LEN, HDCP2KEY_NAME);
+#endif
+
+               printf("receive 20 hdcp2(%s & %s) verify datas:\n", HDCP2LC128_NAME, HDCP2KEY_NAME);
+               memcpy((char *)hdcp2_verify_data_receive, (char *)(hdcp2+HDCP2_KEY_TOTAL_LEN), 20);
+               for (i=0; i<20; i++) {
+                  printf("%.2x:", hdcp2_verify_data_receive[i]);
+               }
+
+               printf("\nstart to verify %d hdcp2(%s & %s) datas...\n", HDCP2_KEY_TOTAL_LEN, HDCP2LC128_NAME, HDCP2KEY_NAME);
+               memcpy((char *)hdcp2TotalData, (char *)hdcp2lc128, HDCP2LC128_LEN);
+               memcpy((char *)(hdcp2TotalData+HDCP2LC128_LEN), (char *)hdcp2key, HDCP2KEY_LEN);
+               SHA1_Perform((unsigned char *)hdcp2TotalData, HDCP2_KEY_TOTAL_LEN, (unsigned char *)hdcp2_verify_data_calculate);
+               printf("verify & get 20 hdcp2(%s & %s) verify datas:\n", HDCP2LC128_NAME, HDCP2KEY_NAME);
+               for (i=0; i<20; i++)
+                    printf("%.2x:", hdcp2_verify_data_calculate[i]);
+               printf("\n");
+
+               ret = memcmp(hdcp2_verify_data_receive, hdcp2_verify_data_calculate, 20);
+               if (ret == 0) {
+                    printf("hdcp2(%s & %s) datas verify success\n", HDCP2LC128_NAME, HDCP2KEY_NAME);
+                    argv[0] = "flash";
+                    argv[1] = "write";
+                    argv[2] = "hdcp2";
+                    argv[3] = hdcp2TotalData;
+                    argc = 4;
+               }
+               else {
+                    sprintf(buff, "failed:(hdcp2<%s & %s> datas verify failed)", HDCP2LC128_NAME, HDCP2KEY_NAME);
+                    printf("%s\n", buff);
+                    return -1;
+               }
+            }
+
+           if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "hdcp:", strlen("hdcp:"))) {
+#define HDCP_DATA_ADDR	(volatile unsigned long *)(0x82000000)
+               hdcp = (char *)HDCP_DATA_ADDR;
+               printf("receive %d hdcp key datas from address:0x82000000:\n", HDCP_KEY_LEN);
+               for (i=0; i<HDCP_KEY_LEN; i++) {
+                  key_data[i] = *hdcp++;
+#ifdef HDCP_PRINT
+                  printf("%.2x:", key_data[i]);
+#endif
+               }
+               printf("\nreceive %d hdcp datas ok !!!\n", HDCP_KEY_LEN);
+
+               printf("receive 20 hdcp key verify datas:\n");
+               for (i=0; i<20; i++) {
+                  hdcp_verify_data_receive[i] = *hdcp++;
+                  printf("%.2x:", hdcp_verify_data_receive[i]);
+               }
+               printf("\n");
+
+               printf("start to verify %d hdcp key datas...\n", HDCP_KEY_LEN);
+               SHA1_Perform((unsigned char *)key_data, HDCP_KEY_LEN, (unsigned char *)hdcp_verify_data_calculate);
+               printf("verify & get 20 hdcp verify datas:\n");
+               for (i=0; i<20; i++)
+                    printf("%.2x:", hdcp_verify_data_calculate[i]);
+               printf("\n");
+
+               ret = memcmp(hdcp_verify_data_receive, hdcp_verify_data_calculate, 20);
+               if (ret == 0) {
+                    printf("hdcp datas verify success\n");
+                    argv[0] = "flash";
+                    argv[1] = "write";
+                    argv[2] = "hdcp";
+                    argv[3] = key_data;
+                    argc = 4;
+               }
+               else {
+                    sprintf(buff, "%s", "failed:(hdcp datas verify failed)");
+                    printf("%s\n", buff);
+                    return -1;
+               }
+            }
+
+            if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "boardid:", strlen("boardid:"))) {
+#define BOARDID_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get boardid data from address:0x82000000
+               char length[4] = {0};
+               char* boardid = (char *)BOARDID_DATA_ADDR;
+               for (i=0; i<4; i++) {
+                  length[i] = *boardid++;
+                  //printf("length[%d]=0x%02x\n", i, length[i]);
+               }
+               int boardid_key_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+               printf("boardid_key_len=%d(maximum length limit is %d)\n", boardid_key_len, SECUKEY_BYTES);
+               memcpy(key_data, boardid, boardid_key_len);
+               printf("receive %d boardid key datas from address:0x82000000:\n%s\n", boardid_key_len, key_data);
+               argv[0] = "flash";
+               argv[1] = "write";
+               argv[2] = "boardid";
+               argv[3] = key_data;
+               argc = 4;
+            }
+
+            if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "serialno:", strlen("serialno:"))) {
+#define SERIALNO_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get serialno data from address:0x82000000
+               char length[4] = {0};
+               char* serialno = (char *)SERIALNO_DATA_ADDR;
+               for (i=0; i<4; i++) {
+                  length[i] = *serialno++;
+                  //printf("length[%d]=0x%02x\n", i, length[i]);
+               }
+               int serialno_key_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+               printf("serialno_key_len=%d(maximum length limit is %d)\n", serialno_key_len, SECUKEY_BYTES);
+               memcpy(key_data, serialno, serialno_key_len);
+               printf("receive %d serialno key datas from address:0x82000000:\n%s\n", serialno_key_len, key_data);
+               argv[0] = "flash";
+               argv[1] = "write";
+               argv[2] = "serialno";
+               argv[3] = key_data;
+               argc = 4;
+            }
+
+             if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "MFG_Serialno:", strlen("MFG_Serialno:"))) {
+#define MFG_SERIALNO_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get MFG_Serialno data from address:0x82000000
+               char length[4] = {0};
+               char* MFG_Serialno = (char *)MFG_SERIALNO_DATA_ADDR;
+               for (i=0; i<4; i++) {
+                  length[i] = *MFG_Serialno++;
+                  //printf("length[%d]=0x%02x\n", i, length[i]);
+               }
+               int MFG_Serialno_key_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+               printf("MFG_Serialno_key_len=%d(maximum length limit is %d)\n", MFG_Serialno_key_len, SECUKEY_BYTES);
+               memcpy(key_data, MFG_Serialno, MFG_Serialno_key_len);
+               printf("receive %d MFG_Serialno key datas from address:0x82000000:\n%s\n", MFG_Serialno_key_len, key_data);
+               argv[0] = "flash";
+               argv[1] = "write";
+               argv[2] = "MFG_Serialno";
+               argv[3] = key_data;
+               argc = 4;
+            }
+#endif   /* WRITE_TO_NAND_EMMC_ENABLE || WRITE_TO_NAND_ENABLE */
+
+#ifdef CONFIG_SECURE_STORAGE_BURNED
+            int widevinekeybox_len=0, PlayReadykeybox_len=0, MobiDRMPublic_len=0, MobiDRMPrivate_len=0;
+#endif
+
+/* Burn key to securestorage */
+/* ---Command process */
+#if defined(CONFIG_SECURE_STORAGE_BURNED)
+            if (!strncmp(argv[2], "random", strlen("random")) || !strncmp(argv[2], "widevinekeybox", strlen("widevinekeybox")) ||
+                !strncmp(argv[2], "PlayReadykeybox", strlen("PlayReadykeybox")) || !strncmp(argv[2], "MobiDRMPrivate", strlen("MobiDRMPrivate")) ||
+                !strncmp(argv[2], "MobiDRMPublic", strlen("MobiDRMPublic"))) {
+                argv[0] = "securestorage";
+                printf("burn key to %s. convert command...\n", argv[0]);
+
+                if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "random", strlen("random"))) {
+#define RANDOM_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get random data from address:0x82000000
+                    random = (char *)RANDOM_DATA_ADDR;
+                    char length[4] = {0}, random_data[RANDOM_MAX_LEN] = {0};
+                    for (i=0; i<4; i++) {
+                        length[i] = *random++;
+                        //printf("length[%d]=0x%02x\n", i, length[i]);
+                    }
+                    random_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+                    if (random_len > RANDOM_MAX_LEN || random_len <= 0) {
+                        sprintf(buff, "random_len=%d(maximum length limit is %d)", random_len, RANDOM_MAX_LEN);
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+                    printf("receive %d random datas from address:0x82000000:\n", random_len);
+                    memcpy((char *)random_data, (char *)random, random_len);
+                    for (i=0; i<random_len; i++) {
+                        printf("%02x:", random_data[i]);
+                    }
+                    printf("\n");
+
+                    argv[3] = random_data;
+                    argc = 4;
+                }
+
+                if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "widevinekeybox", strlen("widevinekeybox"))) {
+#define WIDEVINE_KEYBOX_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get widevinekeybox data from address:0x82000000
+                    char* widevinekeybox = (char *)WIDEVINE_KEYBOX_DATA_ADDR;
+                    char length[4] = {0}, widevinekeybox_data[WIDEVINEKEYBOX_MAX_LEN] = {0};
+                    for (i=0; i<4; i++) {
+                        length[i] = *widevinekeybox++;
+                        //printf("length[%d]=0x%02x\n", i, length[i]);
+                    }
+                    int widevinekeybox_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+                    if (widevinekeybox_len > WIDEVINEKEYBOX_MAX_LEN || widevinekeybox_len <= 0) {
+                        sprintf(buff, "widevinekeybox_len=%d(maximum length limit is %d)", widevinekeybox_len, WIDEVINEKEYBOX_MAX_LEN);
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+
+                    printf("receive %d widevinekeybox datas from address:0x82000000:\n", widevinekeybox_len);
+                    memcpy((char *)widevinekeybox_data, (char *)widevinekeybox, widevinekeybox_len);
+#ifdef KEYBOX_PRINT
+                    for (i=0; i<widevinekeybox_len; i++) {
+                        printf("%02x:", widevinekeybox_data[i]);
+                    }
+#else
+                    printf("receive %d widevinekeybox datas ok !!!", widevinekeybox_len);
+#endif
+
+                    printf("\nreceive 20 widevinekeybox verify datas:\n");
+                    memcpy((char *)widevinekeybox_verify_data_receive, (char *)(widevinekeybox+widevinekeybox_len), 20);
+                    for (i=0; i<20; i++) {
+                        printf("%02x:", widevinekeybox_verify_data_receive[i]);
+                    }
+                    printf("\n");
+
+                    printf("start to verify %d widevinekeybox datas...\n", widevinekeybox_len);
+                    SHA1_Perform((unsigned char *)widevinekeybox_data, widevinekeybox_len, (unsigned char *)widevinekeybox_verify_data_calculate);
+                    printf("verify & get 20 widevinekeybox verify datas:\n");
+                    for (i=0; i<20; i++)
+                        printf("%02x:", widevinekeybox_verify_data_calculate[i]);
+                    printf("\n");
+
+                    ret = memcmp(widevinekeybox_verify_data_receive, widevinekeybox_verify_data_calculate, 20);
+                    if (ret == 0) {
+                        printf("widevinekeybox datas verify success\n");
+                        argv[3] = widevinekeybox_data;
+                        argc = 4;
+                    }
+                    else {
+                        sprintf(buff, "%s", "failed:(widevinekeybox datas verify failed)");
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+                }
+
+               if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "PlayReadykeybox", strlen("PlayReadykeybox"))) {
+#define PLAYREADY_KEYBOX_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get PlayReadykeybox data from address:0x82000000
+                    char* PlayReadykeybox = (char *)PLAYREADY_KEYBOX_DATA_ADDR;
+                    char length[4] = {0}, PlayReadykeybox_data[PLAYREADYKEYBOX_MAX_LEN] = {0};
+                    for (i=0; i<4; i++) {
+                        length[i] = *PlayReadykeybox++;
+                        //printf("length[%d]=0x%02x\n", i, length[i]);
+                    }
+                    int PlayReadykeybox_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+                    if (PlayReadykeybox_len > PLAYREADYKEYBOX_MAX_LEN || PlayReadykeybox_len <= 0) {
+                        sprintf(buff, "PlayReadykeybox_len=%d(maximum length limit is %d)", PlayReadykeybox_len, PLAYREADYKEYBOX_MAX_LEN);
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+
+                    printf("receive %d PlayReadykeybox datas from address:0x82000000:\n", PlayReadykeybox_len);
+                    memcpy((char *)PlayReadykeybox_data, (char *)PlayReadykeybox, PlayReadykeybox_len);
+#ifdef KEYBOX_PRINT
+                    for (i=0; i<PlayReadykeybox_len; i++) {
+                        printf("%02x:", PlayReadykeybox_data[i]);
+                    }
+#else
+                    printf("receive %d PlayReadykeybox datas ok !!!", PlayReadykeybox_len);
+#endif
+
+                    printf("\nreceive 20 PlayReadykeybox verify datas:\n");
+                    memcpy((char *)PlayReadykeybox_verify_data_receive, (char *)(PlayReadykeybox+PlayReadykeybox_len), 20);
+                    for (i=0; i<20; i++) {
+                        printf("%02x:", PlayReadykeybox_verify_data_receive[i]);
+                    }
+                    printf("\n");
+
+                    printf("start to verify %d PlayReadykeybox datas...\n", PlayReadykeybox_len);
+                    SHA1_Perform((unsigned char *)PlayReadykeybox_data, PlayReadykeybox_len, (unsigned char *)PlayReadykeybox_verify_data_calculate);
+                    printf("verify & get 20 PlayReadykeybox verify datas:\n");
+                    for (i=0; i<20; i++)
+                        printf("%02x:", PlayReadykeybox_verify_data_calculate[i]);
+                    printf("\n");
+
+                    ret = memcmp(PlayReadykeybox_verify_data_receive, PlayReadykeybox_verify_data_calculate, 20);
+                    if (ret == 0) {
+                        printf("PlayReadykeybox datas verify success\n");
+                        argv[3] = PlayReadykeybox_data;
+                        argc = 4;
+                    }
+                    else {
+                        sprintf(buff, "%s", "failed:(PlayReadykeybox datas verify failed)");
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+                }
+
+               if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "MobiDRMPrivate", strlen("MobiDRMPrivate"))) {
+#define MOBIDRMPRIVATE_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get MobiDRMPrivate data from address:0x82000000
+                    char* MobiDRMPrivate = (char *)MOBIDRMPRIVATE_DATA_ADDR;
+                    char length[4] = {0}, MobiDRMPrivate_data[MOBIDRMPRIVATE_MAX_LEN] = {0};
+                    for (i=0; i<4; i++) {
+                        length[i] = *MobiDRMPrivate++;
+                        //printf("length[%d]=0x%02x\n", i, length[i]);
+                    }
+
+                    MobiDRMPrivate_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+                    if (MobiDRMPrivate_len > MOBIDRMPRIVATE_MAX_LEN || MobiDRMPrivate_len <= 0) {
+                        sprintf(buff, "MobiDRMPrivate_len=%d(maximum length limit is %d)", MobiDRMPrivate_len, MOBIDRMPRIVATE_MAX_LEN);
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+
+                    printf("receive %d MobiDRMPrivate datas from address:0x82000000:\n", MobiDRMPrivate_len);
+                    memcpy((char *)MobiDRMPrivate_data, (char *)MobiDRMPrivate, MobiDRMPrivate_len);
+#ifdef KEYBOX_PRINT
+                    for (i=0; i<MobiDRMPrivate_len; i++) {
+                        printf("%02x:", MobiDRMPrivate_data[i]);
+                    }
+#else
+                    printf("receive %d MobiDRMPrivate datas ok !!!", MobiDRMPrivate_len);
+#endif
+
+                    printf("\nreceive 20 MobiDRMPrivate verify datas:\n");
+                    memcpy((char *)MobiDRMPrivate_verify_data_receive, (char *)(MobiDRMPrivate+MobiDRMPrivate_len), 20);
+                    for (i=0; i<20; i++) {
+                        printf("%02x:", MobiDRMPrivate_verify_data_receive[i]);
+                    }
+                    printf("\n");
+
+                    printf("start to verify %d MobiDRMPrivate datas...\n", MobiDRMPrivate_len);
+                    SHA1_Perform((unsigned char *)MobiDRMPrivate_data, MobiDRMPrivate_len, (unsigned char *)MobiDRMPrivate_verify_data_calculate);
+                    printf("verify & get 20 MobiDRMPrivate verify datas:\n");
+                    for (i=0; i<20; i++)
+                        printf("%02x:", MobiDRMPrivate_verify_data_calculate[i]);
+                    printf("\n");
+
+                    ret = memcmp(MobiDRMPrivate_verify_data_receive, MobiDRMPrivate_verify_data_calculate, 20);
+                    if (ret == 0) {
+                        printf("MobiDRMPrivate datas verify success\n");
+                        argv[3] = MobiDRMPrivate_data;
+                        argc = 4;
+                    }
+                    else {
+                        sprintf(buff, "%s", "failed:(MobiDRMPrivate datas verify failed)");
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+                }
+
+               if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "MobiDRMPublic", strlen("MobiDRMPublic"))) {
+#define MOBIDRMPUBLIC_DATA_ADDR	(volatile unsigned long *)(0x82000000)//get MobiDRMPublic data from address:0x82000000
+                    char* MobiDRMPublic = (char *)MOBIDRMPUBLIC_DATA_ADDR;
+                    char length[4] = {0}, MobiDRMPublic_data[MOBIDRMPUBLIC_MAX_LEN] = {0};
+                    for (i=0; i<4; i++) {
+                        length[i] = *MobiDRMPublic++;
+                        //printf("length[%d]=0x%02x\n", i, length[i]);
+                    }
+                    int MobiDRMPublic_len = (int)((length[3]<<24)|(length[2]<<16)|(length[1]<<8)|(length[0]));
+                    if (MobiDRMPublic_len > MOBIDRMPUBLIC_MAX_LEN || MobiDRMPublic_len <= 0) {
+                        sprintf(buff, "MobiDRMPublic_len=%d(maximum length limit is %d)", MobiDRMPublic_len, MOBIDRMPUBLIC_MAX_LEN);
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+
+                    printf("receive %d MobiDRMPublic datas from address:0x82000000:\n", MobiDRMPublic_len);
+                    memcpy((char *)MobiDRMPublic_data, (char *)MobiDRMPublic, MobiDRMPublic_len);
+#ifdef KEYBOX_PRINT
+                    for (i=0; i<MobiDRMPublic_len; i++) {
+                        printf("%02x:", MobiDRMPublic_data[i]);
+                    }
+#else
+                    printf("receive %d MobiDRMPublic datas ok !!!", MobiDRMPublic_len);
+#endif
+
+                    printf("\nreceive 20 MobiDRMPublic verify datas:\n");
+                    memcpy((char *)MobiDRMPublic_verify_data_receive, (char *)(MobiDRMPublic+MobiDRMPublic_len), 20);
+                    for (i=0; i<20; i++) {
+                        printf("%02x:", MobiDRMPublic_verify_data_receive[i]);
+                    }
+                    printf("\n");
+
+                    printf("start to verify %d MobiDRMPublic datas...\n", MobiDRMPublic_len);
+                    SHA1_Perform((unsigned char *)MobiDRMPublic_data, MobiDRMPublic_len, (unsigned char *)MobiDRMPublic_verify_data_calculate);
+                    printf("verify & get 20 MobiDRMPublic verify datas:\n");
+                    for (i=0; i<20; i++)
+                        printf("%02x:", MobiDRMPublic_verify_data_calculate[i]);
+                    printf("\n");
+
+                    ret = memcmp(MobiDRMPublic_verify_data_receive, MobiDRMPublic_verify_data_calculate, 20);
+                    if (ret == 0) {
+                        printf("MobiDRMPublic datas verify success\n");
+                        argv[3] = MobiDRMPublic_data;
+                        argc = 4;
+                    }
+                    else {
+                        sprintf(buff, "%s", "failed:(MobiDRMPublic datas verify failed)");
+                        printf("%s\n", buff);
+                        return -1;
+                    }
+                }
+            }
+#endif   /* CONFIG_SECURE_STORAGE_BURNED */
+
+            //printf argv[0]--argv[argc-1]
+            if (!strncmp(argv[1], "write", strlen("write")) &&  !strncmp(argv[2], "hdcp2", strlen("hdcp2"))) {
+               for (i=0; i<argc-1; i++) printf("argv[%d]=%s\n", i, argv[i]) ;
+               printf("argv[3]=");
+
+#ifdef HDCP_PRINT
+               hdcp2 = argv[3];
+               for (i=0; i<HDCP2_KEY_TOTAL_LEN; i++) printf("%02x:", *hdcp2 ++) ;
+               printf("\n");
+#else
+               printf("......\n");
+#endif
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) &&  !strncmp(argv[2], "hdcp", strlen("hdcp"))) {
+               for (i=0; i<argc-1; i++) printf("argv[%d]=%s\n", i, argv[i]) ;
+               printf("argv[3]=");
+#ifdef HDCP_PRINT
+               hdcp = argv[3];
+               for (i=0; i<HDCP_KEY_LEN; i++) printf("%02x:", *hdcp ++) ;
+               printf("\n");
+#else
+               printf("......\n");
+#endif
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) &&  !strncmp(argv[2], "random", strlen("random"))) {
+               for (i=0; i<argc-1; i++) printf("argv[%d]=%s\n", i, argv[i]) ;
+               random = argv[3];
+               printf("argv[3]=");
+               for (i=0; i<random_len; i++) printf("%02x:", *random ++) ;
+               printf("\n");
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) &&  !strncmp(argv[2], "widevinekeybox", strlen("widevinekeybox"))) {
+               for (i=0; i<argc-1; i++) printf("argv[%d]=%s\n", i, argv[i]) ;
+               printf("argv[3]=");
+#ifdef KEYBOX_PRINT
+               widevinekeybox = argv[3];
+               for (i=0; i<widevinekeybox_len; i++) printf("%02x:", *widevinekeybox ++) ;
+               printf("\n");
+#else
+               printf("......\n");
+#endif
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) &&  !strncmp(argv[2], "PlayReadykeybox", strlen("PlayReadykeybox"))) {
+               for (i=0; i<argc-1; i++) printf("argv[%d]=%s\n", i, argv[i]) ;
+               printf("argv[3]=");
+#ifdef KEYBOX_PRINT
+               PlayReadykeybox = argv[3];
+               for (i=0; i<PlayReadykeybox_len; i++) printf("%02x:", *PlayReadykeybox ++) ;
+               printf("\n");
+#else
+               printf("......\n");
+#endif
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) &&  !strncmp(argv[2], "MobiDRMPrivate", strlen("MobiDRMPrivate"))) {
+               for (i=0; i<argc-1; i++) printf("argv[%d]=%s\n", i, argv[i]) ;
+               printf("argv[3]=");
+#ifdef KEYBOX_PRINT
+               MobiDRMPrivate = argv[3];
+               for (i=0; i<MobiDRMPrivate_len; i++) printf("%02x:", *MobiDRMPrivate ++) ;
+               printf("\n");
+#else
+               printf("......\n");
+#endif
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) &&  !strncmp(argv[2], "MobiDRMPublic", strlen("MobiDRMPublic"))) {
+               for (i=0; i<argc-1; i++) printf("argv[%d]=%s\n", i, argv[i]) ;
+               printf("argv[3]=");
+#ifdef KEYBOX_PRINT
+               MobiDRMPublic = argv[3];
+               for (i=0; i<MobiDRMPublic_len; i++) printf("%02x:", *MobiDRMPublic ++) ;
+               printf("\n");
+#else
+               printf("......\n");
+#endif
+            }
+            else
+               for (i=0; i<argc; i++)  printf("argv[%d]=%s\n", i,argv[i]) ;
+
+            if (!strncmp(argv[2], "version", strlen("version")) ||!strncmp(argv[2], "mac_wifi", strlen("mac_wifi")) ||!strncmp(argv[2], "mac_bt", strlen("mac_bt")) ||
+                !strncmp(argv[2], "mac", strlen("mac")) ||!strncmp(argv[2], "usid", strlen("usid")) ||!strncmp(argv[2], "hdcp2", strlen("hdcp2")) ||
+                !strncmp(argv[2], "hdcp", strlen("hdcp")) || !strncmp(argv[2], "boardid", strlen("boardid")) ||
+                !strncmp(argv[2], "serialno", strlen("serialno")) || !strncmp(argv[2], "MFG_Serialno", strlen("MFG_Serialno")))
+                key_device_index = 1;   // flash -> efuse or nand or emmc
+            else if(!strncmp(argv[2], "random", strlen("random")) ||!strncmp(argv[2], "widevinekeybox", strlen("widevinekeybox")) ||
+                !strncmp(argv[2], "PlayReadykeybox", strlen("PlayReadykeybox")) ||!strncmp(argv[2], "MobiDRMPrivate", strlen("MobiDRMPrivate")) ||
+                !strncmp(argv[2], "MobiDRMPublic", strlen("MobiDRMPublic")))
+                key_device_index = 2;   // securestorage
+            else
+                key_device_index = -1; // none command
+
+
+
+/* Burn key to efuse */
+/* ---The actual function to read & write operation */
+#ifdef  WRITE_TO_EFUSE_ENABLE
+            /* read/write version */
+            if (!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "version", strlen("version"))) {
+               int flag = 0;
+               ret = run_efuse_cmd(argc, argv, buff);
+#ifdef CONFIG_AML_MESON3
+               if (!ret) {
+                  for (i=0; i<3; i++) {
+                     if (buff[i] != 0x00) {
+                        flag = 1;
+                        break;
+                     }
+                  }
+                  if (flag) {
+                     sprintf(key_data, "%02x:%02x:%02x", buff[0], buff[1], buff[2]);
+                     printf("version=%s\n", key_data);
+                     sprintf(buff, "success:(%s)", key_data);
+                  }
+                  else {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "%s", "okay:(version has been not writen)");
+                     else
+                        sprintf(buff, "%s", "failed:(version has been not writen)");
+                  }
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+#elif defined(CONFIG_AML_MESON6)
+               if (!ret) {
+                  if (buff[0] != 0x00) {
+                     sprintf(key_data, "%02x", buff[0]);
+                     printf("version=%s\n", key_data);
+                     sprintf(buff, "success:(%s)", key_data);
+                  }
+                  else {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "%s", "okay:(version has been not writen)");
+                     else
+                        sprintf(buff, "%s", "failed:(version has been not writen)");
+                  }
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+#endif
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "version", strlen("version"))) {
+               ret = run_efuse_cmd(argc, argv, buff);
+               if (!ret) {
+#ifndef EFUSE_READ_TEST_ENABLE
+                  sprintf(buff, "success:(%s)", argv[3]);
+#else
+                  argv[1] = "read";
+                  argc = 3;
+                  ret = test_efuse_read(argc, argv, argv[3]);
+                  if (!ret)
+                     sprintf(buff, "success:(%s)", argv[3]);
+                  else if(ret == -1) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read data not match write)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+                  else if(ret == -2) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read fail)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+#endif
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write mac/mac_bt/mac_wifi */
+            else if(!strncmp(argv[1], "read", strlen("read")) && (!strncmp(argv[2], "mac", strlen("mac")) ||
+               !strncmp(argv[2], "mac_bt", strlen("mac_bt")) ||!strncmp(argv[2], "mac_wifi", strlen("mac_wifi")))) {
+               ret = run_efuse_cmd(argc, argv, buff);
+               if (!ret) {
+                  for (i=0; i<6; i++) {
+                     if (buff[i] != 0x00) {
+                        flag = 1;
+                        break;
+                     }
+                  }
+                  if (flag) {
+                     sprintf(key_data, "%02x:%02x:%02x:%02x:%02x:%02x", buff[0],buff[1],buff[2],buff[3],buff[4],buff[5]);
+                     printf("%s_key_data=%s\n", argv[2], key_data);
+                     sprintf(buff, "success:(%s)", key_data);
+                  }
+                  else {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "okay:(%s has been not writen)", argv[2]);
+                     else
+                        sprintf(buff, "failed:(%s has been not writen)", argv[2]);
+                  }
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && (!strncmp(argv[2], "mac", strlen("mac")) ||
+               !strncmp(argv[2], "mac_bt", strlen("mac_bt")) ||!strncmp(argv[2], "mac_wifi", strlen("mac_wifi")))) {
+               ret = run_efuse_cmd(argc, argv, buff);
+               if (!ret) {
+#ifndef EFUSE_READ_TEST_ENABLE
+                  sprintf(buff, "success:(%s)", argv[3]);
+#else
+                  argv[1] = "read";
+                  argc = 3;
+                  ret = test_efuse_read(argc, argv, argv[3]);
+                  if (!ret)
+                     sprintf(buff, "success:(%s)", argv[3]);
+                  else if(ret == -1) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read data not match write)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+                  else if(ret == -2) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read fail)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+#endif
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write usid */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "usid", strlen("usid"))) {
+               int usid_flag = 0;
+               ret = run_efuse_cmd(argc, argv, buff);
+               if (!ret) {
+                  for (i=0; i<strlen(buff); i++) {
+                     if (buff[i] != 0x00) {
+                        usid_flag = 1;
+                        break;
+                     }
+                  }
+                  if (usid_flag) {
+                     printf("usid_key_data=%s\n", buff);
+                     memcpy(key_data, buff, strlen(buff));
+                     sprintf(buff, "success:(%s)", key_data);
+                  }
+                  else {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "%s", "okay:(usid has been not writen)");
+                     else
+                        sprintf(buff, "%s", "failed:(usid has been not writen)");
+                  }
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "usid", strlen("usid"))) {
+               ret = run_efuse_cmd(argc, argv, buff);
+               if (!ret) {
+#ifndef EFUSE_READ_TEST_ENABLE
+                  sprintf(buff, "success:(%s)", argv[3]);
+#else
+                  argv[1] = "read";
+                  argc = 3;
+                  ret = test_efuse_read(argc, argv, argv[3]);
+                  if (!ret)
+                     sprintf(buff, "success:(%s)", argv[3]);
+                  else if(ret == -1) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read data not match write)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+                  else if(ret == -2) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read fail)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+#endif
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write hdcp */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "hdcp", strlen("hdcp"))) {
+               int hdcp_flag = 0;
+               ret = run_efuse_cmd(argc, argv, buff);
+               if (!ret) {
+                  for (i=0; i<HDCP_KEY_LEN; i++) {
+                     if (buff[i] != 0x00) {
+                        hdcp_flag = 1;
+                        break;
+                     }
+                  }
+                  if (hdcp_flag) {
+                     printf("hdcp_key_data is:\n");
+                     for (i=0; i<HDCP_KEY_LEN; i++)
+                        printf("%.2x:", buff[i]);
+                     printf("\n");
+                     sprintf(buff, "%s", "success:(hdcp has been writen)");
+                  }
+                  else {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "%s", "okay:(hdcp has been not writen)");
+                     else
+                        sprintf(buff, "%s", "failed:(hdcp has been not writen)");
+                  }
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "hdcp", strlen("hdcp"))) {
+               ret = run_efuse_cmd(argc, argv, buff);
+               if (!ret) {
+#ifndef EFUSE_READ_TEST_ENABLE
+                  sprintf(buff, "%s", "success:(efuse write hdcp success)");
+#else
+                  argv[1] = "read";
+                  argc = 3;
+                  ret = test_efuse_read(argc, argv, argv[3]);
+                  if (!ret)
+                     sprintf(buff, "%s", "success:(efuse write hdcp success)");
+                  else if(ret == -1) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read data not match write)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+                  else if(ret == -2) {
+                     sprintf(buff, "%s", "failed:(efuse write success,but test read fail)");
+                     printf("%s\n", buff);
+                     return -1;
+                  }
+#endif
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+#if !defined(CONFIG_SECURE_STORAGE_BURNED)
+            /* no command mach */
+            else {
+               sprintf(buff, "%s", "failed:(No command mached)");
+               printf("%s\n", buff);
+               return -1;
+            }
+#endif
+#endif   /* WRITE_TO_EFUSE_ENABLE */
+
+
+/* Burn key to nand/emmc */
+/* ---The actual function to read & write operation */
+#if defined(WRITE_TO_NAND_EMMC_ENABLE) || defined(WRITE_TO_NAND_ENABLE)
+            /* read/write version */
+            if (!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "version", strlen("version"))) {
+                if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                    sprintf(buff, "okay:(%s has been not initialized)", argv[0]);
+                else
+                    sprintf(buff, "failed:(%s has been not initialized)", argv[0]);
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "version", strlen("version"))) {
+               ret = ensure_secukey_init();
+               if (ret == 0) {                                            //init nand/emmc success.
+                  sprintf(buff, "success:(init %s success)", argv[0]);
+               }
+               else if(ret == 1) {                                     //nand/emmc already inited.
+                  sprintf(buff, "success:(%s already inited)", argv[0]);
+               }
+               else {                                                       //init nand/emmc failed!!
+                  sprintf(buff, "failed:(init %s failed)", argv[0]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write mac/mac_bt/mac_wifi/usid*/
+            else if(!strncmp(argv[1], "read", strlen("read")) && (!strncmp(argv[2], "mac", strlen("mac")) ||
+               !strncmp(argv[2], "mac_bt", strlen("mac_bt")) ||!strncmp(argv[2], "mac_wifi", strlen("mac_wifi")) ||
+               !strncmp(argv[2], "usid", strlen("usid")))) {
+               ret = cmd_secukey(argc, argv, buff);
+               if (!ret) {
+                    printf("%s_key_data=%s\n", argv[2], buff);
+                     memcpy(key_data, buff, strlen(buff));
+                     sprintf(buff, "success:(%s)", key_data);
+                }
+                else if(ret == 1) {
+                    if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "okay:(%s has been not writen)", argv[2]);
+                    else
+                        sprintf(buff, "failed:(%s has been not writen)", argv[2]);
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && (!strncmp(argv[2], "mac", strlen("mac")) ||
+               !strncmp(argv[2], "mac_bt", strlen("mac_bt")) ||!strncmp(argv[2], "mac_wifi", strlen("mac_wifi")) ||
+               !strncmp(argv[2], "usid", strlen("usid")))) {
+               for (i=0; i<4; i++) buff[i] = (char)((strlen(argv[3]) >> (i*8)) & 0xff) ;
+               ret = cmd_secukey(argc, argv, buff);
+               if (!ret)
+                  sprintf(buff, "success:(%s)", argv[3]);
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write hdcp2 */
+            /* two keys: hdcp2lc128, hdcp2key */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "hdcp2", strlen("hdcp2"))) {
+               char rKeyHdcp2Data[HDCP2_KEY_TOTAL_LEN] = {0};
+               argv[2] = (char *)HDCP2LC128_NAME;
+               printf("need to convert command again.cmd:\"%s %s %s\"\n", argv[0], argv[1], argv[2]);
+
+               ret = cmd_secukey(argc, argv, rKeyHdcp2Data);
+               if (!ret) {
+#ifdef HDCP_PRINT
+                    char hdcp2lc128Decryption[HDCP2LC128_LEN] = {0};
+                    printf("start to decrypt %s...\n", HDCP2LC128_NAME);
+                    hdcpDataDecryption(HDCP2LC128_LEN, rKeyHdcp2Data, hdcp2lc128Decryption);
+                    printf("%s is:\n", argv[2]);
+                    for (i=0; i<HDCP2LC128_LEN; i++)
+                        printf("%.2x:", hdcp2lc128Decryption[i]);
+                    printf("\n");
+#endif
+                    printf("%s has been writen,continue to read %s\n", HDCP2LC128_NAME, HDCP2KEY_NAME);
+                    memset(rKeyHdcp2Data, 0, sizeof(rKeyHdcp2Data));
+                    argv[2] = (char *)HDCP2KEY_NAME;
+                    printf("need to convert command again.cmd:\"%s %s %s\"\n", argv[0], argv[1], argv[2]);
+
+                    ret = cmd_secukey(argc, argv, rKeyHdcp2Data);
+                    if (!ret) {
+#ifdef HDCP_PRINT
+                        char hdcp2keyDecryption[HDCP2KEY_LEN] = {0};
+                        printf("start to decrypt %s...\n", HDCP2KEY_NAME);
+                        hdcpDataDecryption(HDCP2KEY_LEN, rKeyHdcp2Data, hdcp2keyDecryption);
+                        printf("%s is:\n", argv[2]);
+                        for (i=0; i<HDCP2KEY_LEN; i++)
+                            printf("%.2x:", hdcp2keyDecryption[i]);
+                        printf("\n");
+#endif
+                        sprintf(buff, "success:(%s & %s has been writen)", HDCP2LC128_NAME, HDCP2KEY_NAME);
+                    }
+                    else if(ret == 1) {
+                         sprintf(buff, "failed:(%s has been writen,but %s has been not writen)", HDCP2LC128_NAME, HDCP2KEY_NAME);
+                    }
+                    else {
+                      sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                      printf("%s\n", buff);
+                      return -1;
+                   }
+                }
+                else if(ret == 1) {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "okay:(%s has been not writen)", argv[2]);
+                     else
+                        sprintf(buff, "failed:(%s has been not writen)", argv[2]);
+                }
+                else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "hdcp2", strlen("hdcp2"))) {
+               char hdcp2lc128Encryption[HDCP2LC128_LEN] = {0};
+               printf("start to encrypt %s...\n", HDCP2LC128_NAME);
+               hdcpDataEncryption(HDCP2LC128_LEN, hdcp2lc128, hdcp2lc128Encryption);
+               argv[2] = (char *)HDCP2LC128_NAME;
+               argv[3] = (char *)hdcp2lc128Encryption;
+               printf("need to convert command again.cmd:\"%s %s %s ...\"\n", argv[0], argv[1], argv[2]);
+
+               for (i=0; i<4; i++) buff[i] = (char)((HDCP2LC128_LEN >> (i*8)) & 0xff) ;
+               ret = cmd_secukey(argc, argv, buff);
+               if (!ret) {
+                  printf("success to write %s,continue to write %s\n", HDCP2LC128_NAME, HDCP2KEY_NAME);
+                  char hdcp2keyEncryption[HDCP2KEY_LEN] = {0};
+                  printf("start to encrypt %s...\n", HDCP2KEY_NAME);
+                  hdcpDataEncryption(HDCP2KEY_LEN, hdcp2key, hdcp2keyEncryption);
+                  argv[2] = (char *)HDCP2KEY_NAME;
+                  argv[3] = (char *)hdcp2keyEncryption;
+                  printf("need to convert command again.cmd:\"%s %s %s ...\"\n", argv[0], argv[1], argv[2]);
+
+                  for (i=0; i<4; i++) buff[i] = (char)((HDCP2KEY_LEN >> (i*8)) & 0xff) ;
+                  ret = cmd_secukey(argc, argv, buff);
+                  if (!ret) {
+                        sprintf(buff, "success:(%s %s %s & %s success)", argv[0], argv[1], HDCP2LC128_NAME, HDCP2KEY_NAME);
+                  }
+                  else {
+                        sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                        printf("%s\n", buff);
+                        return -1;
+                  }
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write hdcp */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "hdcp", strlen("hdcp"))) {
+               ret = cmd_secukey(argc, argv, buff);
+               if (!ret) {
+#ifdef HDCP_PRINT
+                    printf("hdcp_key_data is:\n");
+                    for (i=0; i<HDCP_KEY_LEN; i++)
+                        printf("%.2x:", buff[i]);
+                    printf("\n");
+#endif
+                    sprintf(buff, "%s", "success:(hdcp has been writen)");
+                }
+                else if(ret == 1) {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "%s", "okay:(hdcp has been not writen)");
+                     else
+                        sprintf(buff, "%s", "failed:(hdcp has been not writen)");
+                }
+                else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "hdcp", strlen("hdcp"))) {
+               for (i=0; i<4; i++) buff[i] = (char)((HDCP_KEY_LEN >> (i*8)) & 0xff) ;
+               ret = cmd_secukey(argc, argv, buff);
+               if (!ret)
+                  sprintf(buff, "success:(%s %s %s success)", argv[0], argv[1], argv[2]);
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write boardid/serialno */
+            else if(!strncmp(argv[1], "read", strlen("read")) && (!strncmp(argv[2], "boardid", strlen("boardid")) ||
+                !strncmp(argv[2], "serialno", strlen("serialno")) || !strncmp(argv[2], "MFG_Serialno", strlen("MFG_Serialno")))) {
+               ret = cmd_secukey(argc, argv, buff);
+               if (!ret) {
+                    printf("%s_key_data=%s\n", argv[2], buff);
+                    memcpy(key_data, buff, strlen(buff));
+                    if (!strncmp(argv[2], "MFG_Serialno", strlen("MFG_Serialno")))
+                        sprintf(buff, "success:(%s)", key_data);
+                    else
+                        sprintf(buff, "success:(%s has been writen)", argv[2]);
+                }
+                else if(ret == 1) {
+                     if (sPctoolVersion >= PCTOOL_VERSION_1632)
+                        sprintf(buff, "okay:(%s has been not writen)", argv[2]);
+                     else
+                        sprintf(buff, "failed:(%s has been not writen)", argv[2]);
+                }
+                else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && (!strncmp(argv[2], "boardid", strlen("boardid")) ||
+                !strncmp(argv[2], "serialno", strlen("serialno")) || !strncmp(argv[2], "MFG_Serialno", strlen("MFG_Serialno")))) {
+               for (i=0; i<4; i++) buff[i] = (char)((strlen(argv[3]) >> (i*8)) & 0xff) ;
+               ret = cmd_secukey(argc, argv, buff);
+               if (!ret)
+                  sprintf(buff, "success:(%s %s %s success)", argv[0], argv[1], argv[2]);
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+#if !defined(CONFIG_SECURE_STORAGE_BURNED)
+            /* no command mach */
+            else {
+               sprintf(buff, "%s", "failed:(No command mached)");
+               printf("%s\n", buff);
+               return -1;
+            }
+#endif
+#endif   /* WRITE_TO_NAND_EMMC_ENABLE || WRITE_TO_NAND_ENABLE */
+
+if (key_device_index == 1) {
+	printf("%s\n",buff);
+	return 0;
+}
+
+/* Burn key to securestorage */
+/* ---The actual function to read & write operation */
+#if defined(CONFIG_SECURE_STORAGE_BURNED)
+//            if(key_device_index == 1) {
+//                printf("%s\n",buff);
+//                return 0;
+//            }
+
+            /* init securestore device and write random at same time */
+            if (!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "random", strlen("random"))) {
+               ret = ensure_securestore_key_init(key_data, random_len);
+               if (ret == 0) {                                            //init securestorage and write random success
+                  sprintf(buff, "success:(init %s and write random success)", argv[0]);
+               }
+               else if(ret == 1) {
+                  sprintf(buff, "success:(%s already inited and writed random)", argv[0]);
+               }
+               else {                                                       //init securestorage or write random failed!!
+                  sprintf(buff, "failed:(init %s or write random failed)", argv[0]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write widevinekeybox */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "widevinekeybox", strlen("widevinekeybox"))) {
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "%s", "success:(widevinekeybox has been writen)");
+               }
+               else if(ret == 1) {
+                  sprintf(buff, "%s", "okay:(widevinekeybox has been not writen)");
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "widevinekeybox", strlen("widevinekeybox"))) {
+               for (i=0; i<4; i++) buff[i] = (char)((widevinekeybox_len >> (i*8)) & 0xff) ;
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "success:(%s write widevinekeybox success)", argv[0]);
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write PlayReadykeybox */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "PlayReadykeybox", strlen("PlayReadykeybox"))) {
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "%s", "success:(PlayReadykeybox has been writen)");
+               }
+               else if(ret == 1) {
+                  sprintf(buff, "%s", "okay:(PlayReadykeybox has been not writen)");
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "PlayReadykeybox", strlen("PlayReadykeybox"))) {
+               for (i=0; i<4; i++) buff[i] = (char)((PlayReadykeybox_len >> (i*8)) & 0xff) ;
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "success:(%s write PlayReadykeybox success)", argv[0]);
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write MobiDRMPrivate */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "MobiDRMPrivate", strlen("MobiDRMPrivate"))) {
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "%s", "success:(MobiDRMPrivate has been writen)");
+               }
+               else if(ret == 1) {
+                  sprintf(buff, "%s", "okay:(MobiDRMPrivate has been not writen)");
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "MobiDRMPrivate", strlen("MobiDRMPrivate"))) {
+               for (i=0; i<4; i++) buff[i] = (char)((MobiDRMPrivate_len >> (i*8)) & 0xff) ;
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "success:(%s write MobiDRMPrivate success)", argv[0]);
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* read/write MobiDRMPublic */
+            else if(!strncmp(argv[1], "read", strlen("read")) && !strncmp(argv[2], "MobiDRMPublic", strlen("MobiDRMPublic"))) {
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "%s", "success:(MobiDRMPublic has been writen)");
+               }
+               else if(ret == 1) {
+                  sprintf(buff, "%s", "okay:(MobiDRMPublic has been not writen)");
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+            else if(!strncmp(argv[1], "write", strlen("write")) && !strncmp(argv[2], "MobiDRMPublic", strlen("MobiDRMPublic"))) {
+               for (i=0; i<4; i++) buff[i] = (char)((MobiDRMPublic_len >> (i*8)) & 0xff) ;
+               ret = cmd_securestore(argc, argv, buff);
+               if (!ret) {
+                  sprintf(buff, "success:(%s write MobiDRMPublic success)", argv[0]);
+               }
+               else {
+                  sprintf(buff, "failed:(%s %s %s failed)", argv[0], argv[1], argv[2]);
+                  printf("%s\n", buff);
+                  return -1;
+               }
+            }
+
+            /* no command mach */
+            else {
+               sprintf(buff, "%s", "failed:(No command mached)");
+               printf("%s\n", buff);
+               return -1;
+            }
+
+            // set "reboot_mode=charging",because it has been set "reboot_mode=usb_burning" when recovery shutdown
+            if (!strncmp(getenv("reboot_mode"), "usb_burning", strlen("usb_burning"))) {
+                printf("reboot_mode=usb_burning, now set reboot_mode=charging.\n");
+                setenv("reboot_mode", "charging");
+                saveenv();
+                if (!strncmp(getenv("reboot_mode"), "charging", strlen("charging")))
+                    printf("set env reboot_mode=charging ok\n");
+                else
+                    printf("set env reboot_mode=charging fail,now reboot_mode is:%s\n", getenv("reboot_mode"));
+            }
+#endif   /* CONFIG_SECURE_STORAGE_BURNED */
+      }
+      else {
+            if (run_command(cmd, flag)) {
+                strcpy(buff, "fail");
+                return -1;
+            }
+            else{
+                strcpy(buff, "okay");
+            }
+      }
+      printf("%s\n",buff);
+      return 0;
+}
+
+
+
+#if defined(WRITE_TO_NAND_EMMC_ENABLE) || defined(WRITE_TO_NAND_ENABLE)
+int ensure_secukey_init(void)
+{
+	int error = -1;
+
+	if (sInitedSecukey) {
+            printf("flash device already inited!!\n");
+            return 1;
+	}
+
+	printf("should be inited first!\n");
+
+	error = uboot_key_initial("auto");
+       if (error >= 0) {
+            printf("init key ok!!\n");
+            sInitedSecukey = 1;
+            return 0;
+       }
+       else
+            printf("init key fail!!\n");
+
+	return -1;
+}
+
+static char hex_to_asc(char para)
+{
+    if (para >= 0 && para <= 9)
+        para = para + '0';
+    else if(para >= 0xa && para <= 0xf)
+        para = para + 'a' - 0xa;
+
+    return para;
+}
+
+static char asc_to_hex(char para)
+{
+    if (para >= '0' && para <= '9')
+        para = para - '0';
+    else if(para >= 'a' && para <= 'f')
+        para = para - 'a' + 0xa;
+    else if(para >= 'A' && para <= 'F')
+        para = para - 'A' + 0xa;
+
+    return para;
+}
+
+/**
+  *     cmd_secukey
+  *     read: command in *argv[], and read datas saved in buf
+  *     return: 0->success, 1->have not writen, -1->failed
+  *
+  *     write: command in *argv[], and datas length in buf
+  *     return: 0->success, -1->failed
+  **/
+int cmd_secukey(int argc, char *argv[], char *buf)
+{
+    int i = 0, j = 0, ret = 0, error = -1, secukey_len = 0;
+    char *secukey_cmd = NULL, *secukey_name = NULL, *secukey_data = NULL;
+    char namebuf[AML_KEY_NAMELEN], databuf[4096], listkey[1024];
+
+    /* at least two arguments please */
+    if (argc < 2)
+        goto err;
+
+    memset(namebuf, 0, sizeof(namebuf));
+    memset(databuf, 0, sizeof(databuf));
+    memset(listkey, 0, sizeof(listkey));
+
+    secukey_cmd = (char *)argv[1];
+    if (sInitedSecukey) {
+        if (argc > 2 && argc < 5) {
+            if (!strncmp(secukey_cmd, "read", strlen("read"))) {
+                if (argc > 3)
+                    goto err;
+                ret = uboot_get_keylist(listkey);
+                printf("all key names list are(ret=%d):\n%s", ret, listkey);
+                secukey_name = (char *)argv[2];
+                strncpy(namebuf, secukey_name, strlen(secukey_name));
+                error = uboot_key_read(namebuf, databuf);
+                if (error >= 0) {    //read success
+                    if (strncmp(namebuf, HDCP2KEY_NAME, strlen(HDCP2KEY_NAME)) != 0) {
+                        memset(buf, 0, SECUKEY_BYTES);
+                        for (i=0,j=0; i<SECUKEY_BYTES*2; i+=2,j++) {
+                            buf[j]= (((asc_to_hex(databuf[i]))<<4) | (asc_to_hex(databuf[i+1])));
+                        }
+                    }
+                    else {
+                        memset(buf, 0, HDCP2_KEY_TOTAL_LEN);
+                        for (i=0,j=0; i<HDCP2_KEY_TOTAL_LEN*2; i+=2,j++) {
+                            buf[j]= (((asc_to_hex(databuf[i]))<<4) | (asc_to_hex(databuf[i+1])));
+                        }
+                    }
+                    printf("read ok!!\n");
+                    return 0;
+                }
+                else {                      // read error or have not been writen
+                    if (!strncmp(namebuf, "mac_bt", 6) || !strncmp(namebuf, "mac_wifi", 8))
+                        ;
+                    else if(!strncmp(namebuf, "mac", 3)) {
+                        memset(namebuf, 0, sizeof(namebuf));
+                        sprintf(namebuf, "%s", "mac\n");
+                    }
+
+                    if (strstr(listkey, namebuf)) {
+                        printf("find %s, but read error!!\n", namebuf);
+                        goto err;       // read error
+                    }
+                    else {
+                        printf("not find %s, and it doesn't be writen before!!\n", namebuf);
+                        return 1;       // has been not writen
+                    }
+                }
+            }
+            else if(!strncmp(secukey_cmd, "write", strlen("write"))) {
+                if (argc != 4)
+                    goto err;
+                secukey_name = (char *)argv[2];
+                secukey_data = (char *)argv[3];
+                strncpy(namebuf, secukey_name, strlen(secukey_name));
+                secukey_len = (int)((buf[3]<<24)|(buf[2]<<16)|(buf[1]<<8)|(buf[0]));
+                printf("write %s key's length is: %d bytes\n", namebuf, secukey_len);
+                for (i=0,j=0; i<secukey_len; i++,j++) {
+                    databuf[j]= hex_to_asc((secukey_data[i]>>4) & 0x0f);
+                    databuf[++j]= hex_to_asc((secukey_data[i]) & 0x0f);
+                    //printf("%02x:%02x:", databuf[j-1], databuf[j]);
+                }
+                error = uboot_key_write(namebuf, databuf);
+                if (error >= 0) {
+                    printf("write ok!!\n");
+                    return 0;
+                }
+                else {
+                    printf("write error!!\n");
+                    goto err;
+                }
+            }
+        }
+    }
+    else {
+        printf("flash device uninitialized!!\n");
+        goto err;
+    }
+
+err:
+    return -1;
+}
+#endif
+
+
+#if defined(CONFIG_SECURE_STORAGE_BURNED)
+int ensure_securestore_key_init(char *seed, int seed_len)
+{
+    int ret = -1;
+
+    if (sInitedSecurestore) {
+        printf("securestore key already inited and seed already writed!!\n");
+        return 1;
+    }
+
+    printf("start to init securestore key and write seed!!\n");
+
+    ret = securestore_key_init(seed, seed_len);
+    if (ret == 0) {
+        printf("init securestore key and write seed ok!!\n");
+        sInitedSecurestore = 1;
+        ret = 0;
+    }
+    else {
+        printf("init securestore key or write seed error\n");
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/**
+  *     cmd_securestore
+  *     read: command in *argv[], don't allow to read datas
+  *     return: 0->success, 1->have not writen, -1->failed
+  *
+  *     write: command in *argv[], and datas length in buf
+  *     return: 0->success, -1->failed
+  **/
+int cmd_securestore(int argc, char *argv[], char *buf)
+{
+    int error = -1;
+    unsigned int key_status = 0, sstorekey_len = 0;
+    char *sstorekey_cmd, *sstorekey_name, *sstorekey_data;
+    char name_buf[20], data_buf[4096];
+
+    /* at least two arguments please */
+    if (argc < 2)
+        goto err;
+
+    memset(name_buf, 0, sizeof(name_buf));
+    memset(data_buf, 0, sizeof(data_buf));
+
+    sstorekey_cmd = argv[1];
+    if (sInitedSecurestore) {
+        if (argc > 2 && argc < 5) {
+            if (!strncmp(sstorekey_cmd, "read", strlen("read"))) {
+                if (argc > 3)
+                    goto err;
+                sstorekey_name = argv[2];
+                strncpy(name_buf, sstorekey_name, strlen(sstorekey_name));
+                error = securestore_key_query(name_buf, &key_status);
+                if (!error) {
+                    printf("key_status=%d\n", key_status);
+                    if (key_status == 0) {             //key has been not writen
+                        printf("%s has been not writen!!\n", name_buf);
+                        return 1;
+                    }
+                    else if(key_status == 1) {    //key has been writen
+                        printf("%s has been writen!!\n", name_buf);
+                        return 0;
+                    }
+                    else {
+                        printf("key_status: %d,reserved\n", key_status);
+                        return -1;
+                    }
+                }
+                else {
+                    printf("err :%d,%s:%d\n", error, __func__, __LINE__);
+                    return -1;
+                }
+            }
+            else if(!strncmp(sstorekey_cmd, "write", strlen("write"))) {
+                if (argc != 4)
+                    goto err;
+                sstorekey_name = argv[2];
+                sstorekey_data = argv[3];
+                strncpy(name_buf, sstorekey_name, strlen(sstorekey_name));
+                sstorekey_len = (int)((buf[3]<<24)|(buf[2]<<16)|(buf[1]<<8)|(buf[0]));
+                printf("write %s key's length is: %d\n", name_buf, sstorekey_len);
+                error = securestore_key_write(name_buf, sstorekey_data, sstorekey_len, 0);
+                if (!error) {
+                    if (!securestore_key_query(name_buf, &key_status))
+                        printf("after write, query key_status=%d\n", key_status);
+                    printf("write %s ok!!\n", name_buf);
+                    return 0;
+                }
+                else {
+                    printf("write %s error!!\n", name_buf);
+                    goto err;
+                }
+            }
+        }
+    }
+    else {
+        printf("securestore device or securestore key uninitialized!!\n");
+        goto err;
+    }
+
+err:
+    return -1;
+}
+#endif
+
+char generalDataChange(const char input)
+{
+	int i;
+	char result = 0;
+
+	for (i=0; i<8; i++) {
+         if ((input & (1<<i)) != 0)
+            result |= (1<<(7-i));
+         else
+            result &= ~(1<<(7-i));
+	}
+
+	return result;
+}
+
+void hdcpDataEncryption(const int len, const char *input, char *out)
+{
+     int i = 0;
+
+     for (i=0; i<len; i++)
+         *out++ = generalDataChange(*input++);
+}
+
+void hdcpDataDecryption(const int len, const char *input, char *out)
+{
+     int i = 0;
+
+     for (i=0; i<len; i++)
+         *out++ = generalDataChange(*input++);
+}
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.c b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.c
new file mode 100644
index 0000000..43abe80
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.c
@@ -0,0 +1,697 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "platform.h"
+#include "usb_ch9.h"
+#include "dwc_pcd.h"
+#include "dwc_pcd_irq.h"
+#include <asm/arch/timer.h>
+
+
+pcd_struct_t this_pcd;
+dwc_ep_t g_dwc_eps[NUM_EP];
+
+extern void _mdelay(unsigned long ms);
+
+int dwc_core_init(void)
+{
+
+    int32_t         snpsid;
+
+    snpsid = dwc_read_reg32(DWC_REG_GSNPSID);
+    //printf("Value for SNPSID: 0x%08x\n", snpsid);
+    if ((snpsid & 0xFFFFF000) != 0x4F543000) {
+        ERR("Bad value for SNPSID: 0x%08x\n", snpsid);
+        return -1;
+    }
+
+    ERR("dwc core init is ok!\n");// show printf is ok.
+    /*
+     * Disable the global interrupt until all the interrupt
+     * handlers are installed.
+     */
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    ahbcfg.b.glblintrmsk = 1;   /* Enable interrupts bit */
+    dwc_modify_reg32(DWC_REG_GAHBCFG, ahbcfg.d32, 0);
+    /*
+     * Initialize the DWC_otg core.
+     */
+    dwc_otg_core_init();
+
+    dwc_modify_reg32(DWC_REG_DCTL,0,2);// Disconnect data line
+    dwc_otg_pcd_init();
+    dwc_modify_reg32(DWC_REG_DCTL,2,0);// Connect data line
+
+    /*
+     * Enable the global interrupt after all the interrupt
+     * handlers are installed.
+     */
+    dwc_otg_enable_global_interrupts();
+
+    return 0;
+}
+
+int
+dwc_otg_irq(void)
+{
+	dwc_common_irq();
+	dwc_pcd_irq();
+	return 0;
+}
+void dwc_otg_pullup(int is_on)
+{
+	if (is_on)
+		dwc_modify_reg32(DWC_REG_DCTL,2,0);// connect data line
+    else dwc_modify_reg32(DWC_REG_DCTL,0,2);// disconnect data line
+}
+static void dwc_otg_core_init(void) //Elvis Fool, add 'static'
+{
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    gusbcfg_data_t  usbcfg = {.d32 = 0 };
+ //   gi2cctl_data_t  i2cctl = {.d32 = 0 };
+//    hcfg_data_t     hcfg;
+#ifndef USE_FULL_SPEED
+	usbcfg.d32 = dwc_read_reg32(DWC_REG_GUSBCFG);
+
+	usbcfg.b.ulpi_ext_vbus_drv = 0;
+	usbcfg.b.term_sel_dl_pulse = 0;
+	dwc_write_reg32(DWC_REG_GUSBCFG,usbcfg.d32);
+#endif
+	/*
+	* Reset the Controller
+	*/
+	dwc_otg_core_reset();
+
+		usbcfg.d32 = dwc_read_reg32(DWC_REG_GUSBCFG);
+	usbcfg.b.srpcap = 0;
+	usbcfg.b.hnpcap = 0;
+#ifdef USE_FULL_SPEED
+	DBG("Core work on Full Speed\n");
+	usbcfg.b.physel = 1;  // Work at full speed
+	dwc_write_reg32(DWC_REG_GUSBCFG, usbcfg.d32);
+
+	dwc_otg_core_reset();
+/* for HOST
+	hcfg.d32 = dwc_read_reg32(DWC_REG_ hcfg);
+	hcfg.b.fslspclksel = val;
+	dwc_write_reg32(&_core_if->host_if->host_global_regs->hcfg, hcfg.d32);
+*/
+// for Device
+	dcfg_data_t     dcfg;
+	dcfg.d32 = dwc_read_reg32(DWC_REG_DCFG);
+	dcfg.b.devspd = 1;//Hi speed phy run at Full speed
+	dwc_write_reg32(DWC_REG_DCFG, dcfg.d32);
+#else
+	DBG("Core work on High Speed\n");
+	usbcfg.b.ulpi_utmi_sel = 1;
+	usbcfg.b.phyif = 0; // 16 bit
+	usbcfg.b.ddrsel = 0;
+	dwc_write_reg32(DWC_REG_GUSBCFG, usbcfg.d32);
+
+	dwc_otg_core_reset();
+#endif
+	ahbcfg.b.dmaenable = 0;
+	dwc_write_reg32(DWC_REG_GAHBCFG, ahbcfg.d32);
+
+
+    /*
+     * Enable common interrupts
+     */
+    dwc_otg_enable_common_interrupts();
+
+    /*
+     * Do device or host intialization based on mode during PCD and HCD
+     * initialization
+     */
+     if (dwc_read_reg32(DWC_REG_GINTSTS) & 0x1) {
+          DBG("Host Mode\n");
+          return ;
+    } else {
+        DBG("Device Mode\n");
+        dwc_otg_core_dev_init();
+    }
+
+}
+
+/**
+ * This function initialized the PCD portion of the driver.
+ *
+ */
+static int  dwc_otg_pcd_init(void)
+{
+        return 0;
+}
+
+
+/**
+ * Do core a soft reset of the core.  Be careful with this because it
+ * resets all the internal state machines of the core.
+ */
+static void dwc_otg_core_reset(void)		//Elvis Fool, add 'static'
+{
+    grstctl_t greset = {.d32 = 0 };
+    int             count = 0;
+
+    /*
+     * Wait for AHB master IDLE state.
+     */
+    do {
+        _udelay(10);
+        greset.d32 = dwc_read_reg32(DWC_REG_GRSTCTL);
+        if (++count > 100000) {
+            //DBG("%s() HANG! AHB Idle GRSTCTL=%0x\n", dwc_otg_core_reset, greset.d32);
+            return;
+        }
+    }
+    while (greset.b.ahbidle == 0);
+
+    /*
+     * Core Soft Reset
+     */
+    count = 0;
+    greset.b.csftrst = 1;
+    dwc_write_reg32(DWC_REG_GRSTCTL, greset.d32);
+    do {
+        greset.d32 = dwc_read_reg32(DWC_REG_GRSTCTL);
+        if (++count > 1000000) {
+            //DBG("%s() HANG! Soft Reset GRSTCTL=%0x\n", dwc_otg_core_reset, greset.d32);
+            break;
+        }
+    }
+    while (greset.b.csftrst == 1);
+
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    _mdelay(10);
+}
+
+static void dwc_otg_enable_common_interrupts(void)
+{
+        gintmsk_data_t intr_mask = { 0};
+        /* Clear any pending OTG Interrupts */
+        dwc_write_reg32(DWC_REG_GOTGINT, 0xFFFFFFFF);
+        /* Clear any pending interrupts */
+        dwc_write_reg32(DWC_REG_GINTSTS, 0xFFFFFFFF);
+        /*
+         * Enable the interrupts in the GINTMSK.
+         */
+        intr_mask.b.modemismatch = 1;
+        intr_mask.b.otgintr = 1;
+        intr_mask.b.rxstsqlvl = 1;
+        intr_mask.b.conidstschng = 1;
+        intr_mask.b.wkupintr = 1;
+        intr_mask.b.disconnect = 1;
+        intr_mask.b.usbsuspend = 1;
+        intr_mask.b.sessreqintr = 1;
+        dwc_write_reg32(DWC_REG_GINTMSK, intr_mask.d32);
+}
+
+/**
+ * This function enables the Device mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+static void dwc_otg_enable_device_interrupts(void)
+{
+        gintmsk_data_t intr_mask = {  0};
+
+        /* Disable all interrupts. */
+        dwc_write_reg32( DWC_REG_GINTMSK, 0);
+
+        /* Clear any pending interrupts */
+        dwc_write_reg32( DWC_REG_GINTSTS, 0xFFFFFFFF);
+
+        /* Enable the common interrupts */
+        dwc_otg_enable_common_interrupts( );
+
+        /* Enable interrupts */
+        intr_mask.b.usbreset = 1;
+        intr_mask.b.enumdone = 1;
+        intr_mask.b.epmismatch = 1;
+        intr_mask.b.inepintr = 1;
+        intr_mask.b.outepintr = 1;
+        intr_mask.b.erlysuspend = 1;
+
+        dwc_modify_reg32( DWC_REG_GINTMSK, intr_mask.d32, intr_mask.d32);
+
+}
+/**
+ * This function enables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+static void dwc_otg_enable_global_interrupts(void)
+{
+        gahbcfg_data_t ahbcfg = { 0};
+        ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
+        dwc_modify_reg32(DWC_REG_GAHBCFG, 0, ahbcfg.d32);
+}
+
+
+/**
+ * This function initializes the DWC_otg controller registers for
+ * device mode.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ *
+ */
+static void dwc_otg_core_dev_init(void)
+{
+        dcfg_data_t dcfg = { 0};
+        grstctl_t resetctl = { 0 };
+        int i;
+        fifosize_data_t nptxfifosize;
+
+        /* Restart the Phy Clock */
+        dwc_write_reg32(DWC_REG_PCGCCTL, 0);
+
+        /* Device configuration register */
+	dcfg.d32 = dwc_read_reg32(DWC_REG_DCFG);
+#ifdef USE_FULL_SPEED
+	dcfg.b.devspd = 1;//Hi speed phy run at Full speed
+#else
+	dcfg.b.devspd = 0;
+#endif
+	dcfg.b.perfrint = DWC_DCFG_FRAME_INTERVAL_80;
+	dwc_write_reg32(DWC_REG_DCFG, dcfg.d32);
+
+        /* Configure data FIFO sizes */
+
+	/* Rx FIFO */
+      dwc_write_reg32(DWC_REG_GRXFSIZ, 256 );
+      //DBG("new grxfsiz=%08x\n",dwc_read_reg32(DWC_REG_GRXFSIZ));
+
+	/* Non-periodic Tx FIFO */
+      nptxfifosize.b.depth  = 256;
+      nptxfifosize.b.startaddr = 256;
+      dwc_write_reg32(DWC_REG_GNPTXFSIZ, nptxfifosize.d32 );
+      //DBG("new gnptxfsiz=%08x\n",dwc_read_reg32(DWC_REG_GNPTXFSIZ));
+
+        /* Flush the FIFOs */
+      dwc_otg_flush_tx_fifo( 0x10); /* all Tx FIFOs */
+      dwc_otg_flush_rx_fifo();
+
+	/* Flush the Learning Queue. */
+      resetctl.b.intknqflsh = 1;
+      dwc_write_reg32( DWC_REG_GRSTCTL, resetctl.d32);
+
+        /* Clear all pending Device Interrupts */
+        dwc_write_reg32( DWC_REG_DIEPMSK, 0 );
+        dwc_write_reg32( DWC_REG_DOEPMSK, 0 );
+        dwc_write_reg32( DWC_REG_DAINT, 0xFFFFFFFF );
+        dwc_write_reg32( DWC_REG_DAINTMSK, 0 );
+
+        for (i=0; i < NUM_EP; i++) {
+		depctl_data_t depctl;
+		depctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(i));
+		if (depctl.b.epena) {
+			depctl.d32 = 0;
+			depctl.b.epdis = 1;
+			depctl.b.snak = 1;
+		} else {
+			depctl.d32 = 0;
+		}
+		dwc_write_reg32( DWC_REG_IN_EP_REG(i),depctl.d32);
+
+		depctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(i));
+		if (depctl.b.epena) {
+			depctl.d32 = 0;
+			depctl.b.epdis = 1;
+			depctl.b.snak = 1;
+		} else {
+			depctl.d32 = 0;
+		}
+		dwc_write_reg32( DWC_REG_OUT_EP_REG(i), depctl.d32);
+
+		/* Device IN/OUT Endpoint Transfer Size */
+		dwc_write_reg32(DWC_REG_IN_EP_TSIZE(i), 0);
+		dwc_write_reg32(DWC_REG_OUT_EP_TSIZE(i), 0);
+		/* Device IN/OUT Endpoint DMA Address Register */
+		dwc_write_reg32( DWC_REG_IN_EP_DMA(i), 0);
+		dwc_write_reg32( DWC_REG_OUT_EP_DMA(i), 0);
+		/* Device IN/OUT Endpoint Interrupt Register */
+		//dwc_write_reg32( DWC_REG_IN_EP_DMA(i), 0xFF);
+		//dwc_write_reg32( DWC_REG_OUT_EP_INTR(i), 0xFF);
+        }
+
+        //dwc_otg_set_vbus_power(_core_if, 0); //Power off VBus
+
+        dwc_otg_enable_device_interrupts();
+
+	  //DBG("init gintmsk: 0x%x\n",dwc_read_reg32(DWC_REG_GINTMSK));
+}
+/**
+ * Flush a Tx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _num Tx FIFO to flush.
+ */
+static void dwc_otg_flush_tx_fifo( const int _num ) 	//Elvis Fool, add 'static'
+{
+        grstctl_t greset = { 0};
+        int count = 0;
+
+
+	 DBG("dwc_otg_flush_tx_fifo: %d\n",_num);
+        greset.b.txfflsh = 1;
+        greset.b.txfnum = _num;
+        dwc_write_reg32(DWC_REG_GRSTCTL, greset.d32 );
+
+        do {
+                greset.d32 = dwc_read_reg32( DWC_REG_GRSTCTL);
+                if (++count > 10000) {
+                       // ERR("%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
+                       //           "dwc_otg_flush_tx_fifo", greset.d32,
+                       //           dwc_read_reg32( DWC_REG_GNPTXSTS));
+                        break;
+                }
+
+        } while (greset.b.txfflsh == 1);
+        /* Wait for 3 PHY Clocks*/
+        _udelay(1);
+}
+
+/**
+ * Flush Rx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static void dwc_otg_flush_rx_fifo(void)
+{
+        grstctl_t greset = { 0};
+        int count = 0;
+
+	  DBG("dwc_otg_flush_rx_fifo\n");
+        greset.b.rxfflsh = 1;
+        dwc_write_reg32( DWC_REG_GRSTCTL, greset.d32 );
+
+        do {
+                greset.d32 = dwc_read_reg32( DWC_REG_GRSTCTL);
+                if (++count > 10000) {
+                        //ERR("%s() HANG! GRSTCTL=%0x\n", "dwc_otg_flush_rx_fifo",
+                        //         greset.d32);
+                        break;
+                }
+        } while (greset.b.rxfflsh == 1);
+        /* Wait for 3 PHY Clocks*/
+        _udelay(1);
+}
+/**
+ * This function does the setup for a data transfer for EP0 and starts
+ * the transfer.  For an IN transfer, the packets will be loaded into
+ * the appropriate Tx FIFO in the ISR. For OUT transfers, the packets are
+ * unloaded from the Rx FIFO in the ISR.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP0 data.
+ */
+ #if 0
+void dwc_otg_ep0_start_transfer(dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	deptsiz0_data_t deptsiz;
+        gintmsk_data_t intr_mask = { 0};
+
+        _ep->total_len = _ep->xfer_len;
+
+	//DBG("dwc_otg_ep0_start_transfer: xfer_len:%d\n",_ep->xfer_len);
+	/* IN endpoint */
+	if (_ep->is_in == 1) {
+		gnptxsts_data_t tx_status = { 0};
+
+		tx_status.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+		if (tx_status.b.nptxqspcavail == 0) {
+			return;
+		}
+
+		depctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(0));
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_IN_EP_TSIZE(0));
+
+		/* Zero Length Packet? */
+		if (_ep->xfer_len == 0) {
+			deptsiz.b.xfersize = 0;
+			deptsiz.b.pktcnt = 1;
+		} else {
+			/* Program the transfer size and packet count
+			*  as follows: xfersize = N * maxpacket +
+			*  short_packet pktcnt = N + (short_packet
+			*  exist ? 1 : 0)
+			*/
+			if (_ep->xfer_len > _ep->maxpacket) {
+				_ep->xfer_len = _ep->maxpacket;
+				deptsiz.b.xfersize = _ep->maxpacket;
+			}
+			else {
+				deptsiz.b.xfersize = _ep->xfer_len;
+			}
+			deptsiz.b.pktcnt = 1;
+
+		}
+		dwc_write_reg32(DWC_REG_IN_EP_TSIZE(0), deptsiz.d32);
+             //DBG( "IN len=%d  xfersize=%d pktcnt=%d [%08x]\n",
+              //              _ep->xfer_len,deptsiz.b.xfersize, deptsiz.b.pktcnt, deptsiz.d32);
+
+
+		flush_cpu_cache();
+
+		/* EP enable, IN data in FIFO */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+		dwc_write_reg32(DWC_REG_IN_EP_REG(0), depctl.d32);
+
+		/**
+		 * Enable the Non-Periodic Tx FIFO empty interrupt, the
+		 * data will be written into the fifo by the ISR.
+		 */
+
+		/* First clear it from GINTSTS */
+		intr_mask.b.nptxfempty = 1;
+		dwc_modify_reg32( DWC_REG_GINTSTS,intr_mask.d32, 0);
+		dwc_modify_reg32( DWC_REG_GINTMSK,intr_mask.d32, intr_mask.d32);
+
+
+	} else { /* OUT endpoint */
+
+		depctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(0));
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_OUT_EP_TSIZE(0));
+
+		/* Program the transfer size and packet count as follows:
+		*  xfersize = N * (maxpacket + 4 - (maxpacket % 4))
+		*  pktcnt = N                                          */
+#if 0
+		if (_ep->xfer_len == 0) {
+			/* Zero Length Packet */
+			deptsiz.b.xfersize = _ep->maxpacket;
+			deptsiz.b.pktcnt = 1;
+		} else {
+			deptsiz.b.pktcnt =
+			(_ep->xfer_len + (_ep->maxpacket - 1)) /_ep->maxpacket;
+			deptsiz.b.xfersize = deptsiz.b.pktcnt * _ep->maxpacket;
+		}
+#else   // ep0 pktcnt is 1 bit
+
+		deptsiz.b.xfersize = _ep->maxpacket;
+		deptsiz.b.pktcnt = 1;
+		_udelay(1); // This is needed, don't know reason.
+#endif
+
+
+		dwc_write_reg32(DWC_REG_OUT_EP_TSIZE(0), deptsiz.d32);
+             //DBG( "OUT len=%d  xfersize=%d pktcnt=%d\n",
+             //               _ep->xfer_len,deptsiz.b.xfersize, deptsiz.b.pktcnt);
+
+
+		/* EP enable */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+		dwc_write_reg32 (DWC_REG_OUT_EP_REG(0), depctl.d32);
+	}
+
+	flush_cpu_cache();
+}
+ #endif
+
+void dwc_otg_ep_start_transfer(dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	deptsiz_data_t deptsiz;
+	int epctl_reg,epctltsize_reg;
+	int ep_num = _ep->num;
+	int is_in = _ep->is_in;
+	int ep_mps = _ep->maxpacket;
+
+	//DBG("dwc_otg_ep_start_transfer: xfer_len:%d\n",_ep->xfer_len);
+
+        _ep->total_len = _ep->xfer_len;
+
+	if (is_in) {
+		epctl_reg = DWC_REG_IN_EP_REG(ep_num);
+		epctltsize_reg = DWC_REG_IN_EP_TSIZE(ep_num);
+	}else{
+		epctl_reg = DWC_REG_OUT_EP_REG(ep_num);
+		epctltsize_reg = DWC_REG_OUT_EP_TSIZE(ep_num);
+	}
+
+	depctl.d32 = dwc_read_reg32(epctl_reg);
+	deptsiz.d32 = dwc_read_reg32(epctltsize_reg);
+
+	/* Zero Length Packet? */
+	if (_ep->xfer_len == 0) {
+		deptsiz.b.xfersize = is_in?0:ep_mps;
+		deptsiz.b.pktcnt = 1;
+	} else {
+		deptsiz.b.pktcnt =
+		(_ep->xfer_len + (ep_mps - 1)) /ep_mps;
+		if (is_in && _ep->xfer_len < ep_mps)
+			deptsiz.b.xfersize = _ep->xfer_len;
+		else
+			deptsiz.b.xfersize = deptsiz.b.pktcnt * ep_mps;
+	}
+
+	/* Fill size and count */
+	dwc_write_reg32(epctltsize_reg,deptsiz.d32);
+
+	/* EP enable */
+	depctl.b.cnak = 1;
+	depctl.b.epena = 1;
+	dwc_write_reg32 (epctl_reg, depctl.d32);
+
+	/* IN endpoint */
+	if (is_in) {
+		gintmsk_data_t intr_mask = {0};
+		//gnptxsts_data_t tx_status = { 0};
+
+		//tx_status.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+		//if (tx_status.b.nptxqspcavail == 0){
+		//	return;
+		//}
+
+		/**
+		 * Enable the Non-Periodic Tx FIFO empty interrupt, the
+		 * data will be written into the fifo by the ISR.
+		 */
+
+		/* First clear it from GINTSTS */
+		intr_mask.b.nptxfempty = 1;
+		dwc_modify_reg32( DWC_REG_GINTSTS,intr_mask.d32, 0);
+		dwc_modify_reg32( DWC_REG_GINTMSK,intr_mask.d32, intr_mask.d32);
+
+	}
+
+}
+int dwc_otg_ep_req_start(pcd_struct_t *pcd,int ep_num)
+{
+	dwc_ep_t *ep = &g_dwc_eps[ep_num];
+
+	ep->num = ep_num;
+	//DBG("dwc_otg_ep_req_start: ep%d\n",ep_num);
+        /* EP0 Transfer? */
+	if (ep_num == 0) {
+		//DBG("EP0 State: %d\n",pcd->ep0state);
+		switch (pcd->ep0state) {
+			case EP0_IN_DATA_PHASE:
+				break;
+
+			case EP0_OUT_DATA_PHASE:
+				if (pcd->request_config) {
+				        /* Work around for SetConfig cmd */
+				        /* Complete STATUS PHASE */
+				        ep->is_in = 1;
+				        pcd->ep0state = EP0_STATUS;
+				}
+				else if(pcd->length == 0)
+				{
+				        /* Work around for MSC Reset cmd */
+				        /* Complete STATUS PHASE */
+				        ep->is_in = 1;
+				        pcd->ep0state = EP0_STATUS;
+				}
+			break;
+
+			default:
+				return -1;
+		}
+
+		ep->start_xfer_buff = (uint8_t*)pcd->buf;
+		ep->xfer_buff = (uint8_t*)pcd->buf;
+		ep->xfer_len = pcd->length;
+		ep->xfer_count = 0;
+		ep->sent_zlp = 0;
+		ep->total_len = ep->xfer_len;
+		ep->maxpacket = 64;
+		dwc_otg_ep_start_transfer( ep );
+
+	} else {
+		/* Setup and start the Transfer for Bulk */
+		ep->start_xfer_buff = (uint8_t*)pcd->bulk_buf;
+		ep->xfer_buff = (uint8_t*)pcd->bulk_buf;
+		ep->xfer_len = pcd->bulk_len;
+		ep->xfer_count = 0;
+		ep->sent_zlp = 0;
+		ep->total_len = ep->xfer_len;
+		ep->maxpacket = BULK_EP_MPS;
+		ep->is_in = (ep_num == BULK_IN_EP_NUM);
+		dwc_otg_bulk_ep_activate( ep );
+		dwc_otg_ep_start_transfer( ep );
+	}
+
+	return 0;
+
+}
+
+static void dwc_otg_bulk_ep_activate(dwc_ep_t *ep)
+{
+	depctl_data_t depctl = {0};
+	daint_data_t daintmsk = {0};
+	int epctl;
+	int ep_num = ep->num;
+
+	if (ep->is_in) {
+		epctl = DWC_REG_IN_EP_REG(ep_num);
+		daintmsk.ep.in = 1<<BULK_IN_EP_NUM; //ep1:BULK_IN
+	}
+	else{
+		epctl = DWC_REG_OUT_EP_REG(ep_num);
+		daintmsk.ep.out = 1<<BULK_OUT_EP_NUM;//ep2:BULK_OUT
+	}
+
+	depctl.d32 = dwc_read_reg32(epctl);
+	if (!depctl.b.usbactep) {
+		depctl.b.mps = BULK_EP_MPS;
+		depctl.b.eptype = 2;//BULK_STYLE
+		depctl.b.setd0pid = 1;
+		depctl.b.txfnum = 0;   //Non-Periodic TxFIFO
+		depctl.b.usbactep = 1;
+
+		dwc_write_reg32(epctl, depctl.d32);
+	}
+
+	dwc_modify_reg32(DWC_REG_DAINTMSK, 0, daintmsk.d32);
+
+	return;
+}
+
+void dwc_otg_power_off_phy(void)
+{
+	dwc_write_reg32(DWC_REG_PCGCCTL, 0xF);
+}
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.h b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.h
new file mode 100644
index 0000000..12500bc
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.h
@@ -0,0 +1,2064 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __DWC_PCD_H__
+#define __DWC_PCD_H__
+
+//#define USE_FULL_SPEED
+
+#define NUM_EP	4
+
+#define BULK_IN_EP_NUM		1
+#define BULK_OUT_EP_NUM	2
+
+#ifdef USE_FULL_SPEED
+#define BULK_EP_MPS	(64)		//only for full speed
+#else
+#define BULK_EP_MPS (512)
+#endif
+
+#define DWC_REG_GOTGCTL	0x000 /** OTG Control and Status Register.  <i>Offset: 000h</i> */
+#define DWC_REG_GOTGINT	0x004 /** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+#define DWC_REG_GAHBCFG	0x008 /**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+#define DWC_REG_GUSBCFG	0x00C /**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+#define DWC_REG_GRSTCTL	0x010 /**Core Reset Register.	 <i>Offset: 010h</i> */
+#define DWC_REG_GINTSTS	0x014 /**Core Interrupt Register.	 <i>Offset: 014h</i> */
+#define DWC_REG_GINTMSK	0x018 /**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+#define DWC_REG_GRXSTSR	0x01C /**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+#define DWC_REG_GRXSTSP	0x020 /**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+#define DWC_REG_GRXFSIZ	0x024 /**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+#define DWC_REG_GNPTXFSIZ	0x028 /**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+#define DWC_REG_GNPTXSTS	0x02C /**Non Periodic Transmit FIFO/Queue Status Register (Read  * Only). <i>Offset: 02Ch</i> */
+#define DWC_REG_GI2CCTL	0x030 /**I2C Access Register.	 <i>Offset: 030h</i> */
+#define DWC_REG_GPVNDCTL	0x034 /**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+#define DWC_REG_GGPIO		0x038 /**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+#define DWC_REG_GUID		0x03C /**User ID Register.  <i>Offset: 03Ch</i> */
+#define DWC_REG_GSNPSID	0x040 /**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+#define DWC_REG_GHWCFG1	0x044 /**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+#define DWC_REG_GHWCFG2	0x048 /**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+#define DWC_REG_GHWCFG3	0x04C /**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+#define DWC_REG_GHWCFG4	0x050 /**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+#define DWC_REG_HPTXFSIZ	0x100 /** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+
+/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled,
+		otherwise Device Transmit FIFO#n Register.
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+#define DWC_REG_DPTXFSIZ_DIEPTXF		0x104
+
+#define DWC_REG_DCFG	0x800 /** Device Configuration Register. <i>Offset 800h</i> */
+#define DWC_REG_DCTL	0x804 /** Device Control Register. <i>Offset: 804h</i> */
+#define DWC_REG_DSTS	0x808 /** Device Status Register (Read Only). <i>Offset: 808h</i> */
+#define DWC_REG_DIEPMSK	0x810 /** Device IN Endpoint Common Interrupt Mask Register. <i>Offset: 810h</i> */
+#define DWC_REG_DOEPMSK	0x814 /** Device OUT Endpoint Common Interrupt Mask Register. <i>Offset: 814h</i> */
+#define DWC_REG_DAINT	0x818 /** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+#define DWC_REG_DAINTMSK	0x81C /** Device All Endpoints Interrupt Mask Register.  <i>Offset: 81Ch</i> */
+#define DWC_REG_DTKNQR1	0x820 /** Device IN Token Queue Read Register-1 (Read Only). <i>Offset: 820h</i> */
+#define DWC_REG_DTKNQR2	0x824 /** Device IN Token Queue Read Register-2 (Read Only). <i>Offset: 824h</i> */
+#define DWC_REG_DVBUGDIS	0x828 /** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+#define DWC_REG_DVBUSPULSE	0x82C /** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+#define DWC_REG_DTKNQR3	0x830
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */
+#define DWC_REG_DTKNQR4	0x834
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */
+#define DWC_REG_PCGCCTL	0xE00 /** Power and Clock Gating Control Register */
+
+#define DWC_EP_REGS_OFFSET	0x00
+#define DWC_EP_INTR_OFFSET	0x08
+#define DWC_EP_TSIZE_OFFSET	0x10
+#define DWC_EP_DMA_OFFSET		0x14
+
+#define DWC_IN_EP_REG_START 0x900
+#define DWC_OUT_EP_REG_START 0xB00
+
+#define DWC_REG_IN_EP_REG(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_REGS_OFFSET)
+#define DWC_REG_IN_EP_INTR(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_INTR_OFFSET)
+#define DWC_REG_IN_EP_TSIZE(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_TSIZE_OFFSET)
+#define DWC_REG_IN_EP_DMA(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_DMA_OFFSET)
+
+#define DWC_REG_OUT_EP_REG(x)		(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_REGS_OFFSET)
+#define DWC_REG_OUT_EP_INTR(x)	(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_INTR_OFFSET)
+#define DWC_REG_OUT_EP_TSIZE(x)	(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_TSIZE_OFFSET)
+#define DWC_REG_OUT_EP_DMA(x)	(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_DMA_OFFSET)
+
+
+#define DWC_REG_DATA_FIFO_START 0x1000
+#define DWC_REG_DATA_FIFO(ep)	(DWC_REG_DATA_FIFO_START + ep * 0x1000)
+
+/**
+ * The <code>dwc_ep</code> structure represents the state of a single
+ * endpoint when acting in device mode. It contains the data items
+ * needed for an endpoint to be activated and transfer packets.
+ */
+typedef struct dwc_ep {
+        /** EP number used for register address lookup */
+        uint8_t  num;
+        /** EP direction 0 = OUT */
+        unsigned is_in : 1;
+        /** EP active. */
+        unsigned active : 1;
+
+	  unsigned stopped : 1;
+	  unsigned disabling : 1;
+
+        /** Periodic Tx FIFO # for IN EPs For INTR EP set to 0 to use non-periodic Tx FIFO */
+        unsigned tx_fifo_num : 4;
+        /** EP type: 0 - Control, 1 - ISOC,  2 - BULK,  3 - INTR */
+        unsigned type : 2;
+#define DWC_OTG_EP_TYPE_CONTROL    0
+#define DWC_OTG_EP_TYPE_ISOC       1
+#define DWC_OTG_EP_TYPE_BULK       2
+#define DWC_OTG_EP_TYPE_INTR       3
+
+        /** DATA start PID for INTR and BULK EP */
+        unsigned data_pid_start : 1;
+        /** Frame (even/odd) for ISOC EP */
+        unsigned even_odd_frame : 1;
+        /** Max Packet bytes */
+        unsigned maxpacket : 11;
+
+        /** @name Transfer state */
+	/** @{ */
+
+	/**
+	 * Pointer to the beginning of the transfer buffer -- do not modify
+	 * during transfer.
+	 */
+
+	uint32_t dma_addr;
+
+	uint8_t *start_xfer_buff;
+        /** pointer to the transfer buffer */
+        uint8_t *xfer_buff;
+        /** Number of bytes to transfer */
+        unsigned xfer_len : 19;
+        /** Number of bytes transferred. */
+        unsigned xfer_count : 19;
+        /** Sent ZLP */
+        unsigned sent_zlp : 1;
+        /** Total len for control transfer */
+        unsigned total_len : 19;
+
+	/** @} */
+} dwc_ep_t;
+
+typedef struct pcd_struct_s{
+	 /** SETUP packet for EP0
+	 * This structure is allocated as a DMA buffer on PCD initialization
+	 * with enough space for up to 3 setup packets.
+	 */
+        union {
+                struct usb_ctrlrequest	req;
+                uint32_t	d32[2];
+        }setup_pkt;
+	 int ep0state;
+
+	 /* request */
+	 char * buf;
+	 int length;
+
+	  /* bulk req */
+	 char * bulk_buf;
+	 int bulk_len;		// one bulk transfer length
+	 int bulk_num;	// number of bulk transfer
+	 int bulk_data_len;// data len of all data
+	 int xfer_len;
+	 char bulk_out;	// flag
+	 char bulk_lock;	// bulk transfering
+	 //short bulk_seq;
+
+	 unsigned request_config : 1;
+	 unsigned request_enable : 1;
+
+}pcd_struct_t;
+
+extern pcd_struct_t this_pcd;
+extern dwc_ep_t g_dwc_eps[NUM_EP];
+
+/**
+ * @file
+ *
+ * This file contains the data structures for accessing the DWC_otg core registers.
+ *
+ * The application interfaces with the HS OTG core by reading from and
+ * writing to the Control and Status Register (CSR) space through the
+ * AHB Slave interface. These registers are 32 bits wide, and the
+ * addresses are 32-bit-block aligned.
+ * CSRs are classified as follows:
+ * - Core Global Registers
+ * - Device Mode Registers
+ * - Device Global Registers
+ * - Device Endpoint Specific Registers
+ * - Host Mode Registers
+ * - Host Global Registers
+ * - Host Port CSRs
+ * - Host Channel Specific Registers
+ *
+ * Only the Core Global registers can be accessed in both Device and
+ * Host modes. When the HS OTG core is operating in one mode, either
+ * Device or Host, the application must not access registers from the
+ * other mode. When the core switches from one mode to another, the
+ * registers in the new mode of operation must be reprogrammed as they
+ * would be after a power-on reset.
+ */
+
+/****************************************************************************/
+/** DWC_otg Core registers .
+ * The dwc_otg_core_global_regs structure defines the size
+ * and relative field offsets for the Core Global registers.
+ */
+typedef struct dwc_otg_core_global_regs
+{
+	/** OTG Control and Status Register.  <i>Offset: 000h</i> */
+	volatile uint32_t gotgctl;
+	/** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+	volatile uint32_t gotgint;
+	/**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+	volatile uint32_t gahbcfg;
+
+#define DWC_GLBINTRMASK		0x0001
+#define DWC_DMAENABLE		0x0020
+#define DWC_NPTXEMPTYLVL_EMPTY	0x0080
+#define DWC_NPTXEMPTYLVL_HALFEMPTY	0x0000
+#define DWC_PTXEMPTYLVL_EMPTY	0x0100
+#define DWC_PTXEMPTYLVL_HALFEMPTY	0x0000
+
+	/**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+	volatile uint32_t gusbcfg;
+	/**Core Reset Register.	 <i>Offset: 010h</i> */
+	volatile uint32_t grstctl;
+	/**Core Interrupt Register.	 <i>Offset: 014h</i> */
+	volatile uint32_t gintsts;
+	/**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+	volatile uint32_t gintmsk;
+	/**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+	volatile uint32_t grxstsr;
+	/**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+	volatile uint32_t grxstsp;
+	/**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+	volatile uint32_t grxfsiz;
+	/**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+	volatile uint32_t gnptxfsiz;
+	/**Non Periodic Transmit FIFO/Queue Status Register (Read
+	 * Only). <i>Offset: 02Ch</i> */
+	volatile uint32_t gnptxsts;
+	/**I2C Access Register.	 <i>Offset: 030h</i> */
+	volatile uint32_t gi2cctl;
+	/**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+	volatile uint32_t gpvndctl;
+	/**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+	volatile uint32_t ggpio;
+	/**User ID Register.  <i>Offset: 03Ch</i> */
+	volatile uint32_t guid;
+	/**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+	volatile uint32_t gsnpsid;
+	/**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+	volatile uint32_t ghwcfg1;
+	/**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+	volatile uint32_t ghwcfg2;
+#define DWC_SLAVE_ONLY_ARCH 0
+#define DWC_EXT_DMA_ARCH 1
+#define DWC_INT_DMA_ARCH 2
+
+#define DWC_MODE_HNP_SRP_CAPABLE	0
+#define DWC_MODE_SRP_ONLY_CAPABLE	1
+#define DWC_MODE_NO_HNP_SRP_CAPABLE		2
+#define DWC_MODE_SRP_CAPABLE_DEVICE		3
+#define DWC_MODE_NO_SRP_CAPABLE_DEVICE	4
+#define DWC_MODE_SRP_CAPABLE_HOST	5
+#define DWC_MODE_NO_SRP_CAPABLE_HOST	6
+
+	/**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+	volatile uint32_t ghwcfg3;
+	/**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+	volatile uint32_t ghwcfg4;
+	/** Reserved  <i>Offset: 054h-0FFh</i> */
+	uint32_t reserved[43];
+	/** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+	volatile uint32_t hptxfsiz;
+	/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled,
+		otherwise Device Transmit FIFO#n Register.
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+	volatile uint32_t dptxfsiz_dieptxf[15];
+} dwc_otg_core_global_regs_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Control
+ * and Status Register (GOTGCTL).  Set the bits using the bit
+ * fields then write the <i>d32</i> value to the register.
+ */
+typedef union gotgctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned sesreqscs : 1;
+		unsigned sesreq : 1;
+		unsigned reserved2_7 : 6;
+		unsigned hstnegscs : 1;
+		unsigned hnpreq : 1;
+		unsigned hstsethnpen : 1;
+		unsigned devhnpen : 1;
+		unsigned reserved12_15 : 4;
+		unsigned conidsts : 1;
+		unsigned reserved17 : 1;
+		unsigned asesvld : 1;
+		unsigned bsesvld : 1;
+		unsigned currmod : 1;
+		unsigned reserved21_31 : 11;
+	} b;
+} gotgctl_data_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Interrupt Register
+ * (GOTGINT).  Set/clear the bits using the bit fields then write the <i>d32</i>
+ * value to the register.
+ */
+typedef union gotgint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Current Mode */
+		unsigned reserved0_1 : 2;
+
+		/** Session End Detected */
+		unsigned sesenddet : 1;
+
+		unsigned reserved3_7 : 5;
+
+		/** Session Request Success Status Change */
+		unsigned sesreqsucstschng : 1;
+		/** Host Negotiation Success Status Change */
+		unsigned hstnegsucstschng : 1;
+
+		unsigned reserver10_16 : 7;
+
+		/** Host Negotiation Detected */
+		unsigned hstnegdet : 1;
+		/** A-Device Timeout Change */
+		unsigned adevtoutchng : 1;
+		/** Debounce Done */
+		unsigned debdone : 1;
+
+		unsigned reserved31_20 : 12;
+
+	} b;
+} gotgint_data_t;
+
+
+/**
+ * This union represents the bit fields of the Core AHB Configuration
+ * Register (GAHBCFG).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gahbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned glblintrmsk : 1;
+#define DWC_GAHBCFG_GLBINT_ENABLE		1
+
+		unsigned hburstlen : 4;
+#define DWC_GAHBCFG_INT_DMA_BURST_SINGLE	0
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR		1
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR4		3
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR8		5
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR16	7
+
+		unsigned dmaenable : 1;
+#define DWC_GAHBCFG_DMAENABLE			1
+		unsigned reserved : 1;
+		unsigned nptxfemplvl_txfemplvl : 1;
+		unsigned ptxfemplvl : 1;
+#define DWC_GAHBCFG_TXFEMPTYLVL_EMPTY		1
+#define DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY	0
+		unsigned reserved9_31 : 23;
+	} b;
+} gahbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core USB Configuration
+ * Register (GUSBCFG).	Set the bits using the bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union gusbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned toutcal : 3;
+		unsigned phyif : 1;
+		unsigned ulpi_utmi_sel : 1;
+		unsigned fsintf : 1;
+		unsigned physel : 1;
+		unsigned ddrsel : 1;
+		unsigned srpcap : 1;
+		unsigned hnpcap : 1;
+		unsigned usbtrdtim : 4;
+		unsigned nptxfrwnden : 1;
+		unsigned phylpwrclksel : 1;
+		unsigned otgutmifssel : 1;
+		unsigned ulpi_fsls : 1;
+		unsigned ulpi_auto_res : 1;
+		unsigned ulpi_clk_sus_m : 1;
+		unsigned ulpi_ext_vbus_drv : 1;
+		unsigned ulpi_int_vbus_indicator : 1;
+		unsigned term_sel_dl_pulse : 1;
+		unsigned reserved : 9;
+	} b;
+} gusbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core Reset Register
+ * (GRSTCTL).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union grstctl_data
+{
+	/** raw register data */
+	unsigned int d32;
+	/** register bits */
+	struct
+	{
+		/** Core Soft Reset (CSftRst) (Device and Host)
+		 *
+		 * The application can flush the control logic in the
+		 * entire core using this bit. This bit resets the
+		 * pipelines in the AHB Clock domain as well as the
+		 * PHY Clock domain.
+		 *
+		 * The state machines are reset to an IDLE state, the
+		 * control bits in the CSRs are cleared, all the
+		 * transmit FIFOs and the receive FIFO are flushed.
+		 *
+		 * The status mask bits that control the generation of
+		 * the interrupt, are cleared, to clear the
+		 * interrupt. The interrupt status bits are not
+		 * cleared, so the application can get the status of
+		 * any events that occurred in the core after it has
+		 * set this bit.
+		 *
+		 * Any transactions on the AHB are terminated as soon
+		 * as possible following the protocol. Any
+		 * transactions on the USB are terminated immediately.
+		 *
+		 * The configuration settings in the CSRs are
+		 * unchanged, so the software doesn't have to
+		 * reprogram these registers (Device
+		 * Configuration/Host Configuration/Core System
+		 * Configuration/Core PHY Configuration).
+		 *
+		 * The application can write to this bit, any time it
+		 * wants to reset the core. This is a self clearing
+		 * bit and the core clears this bit after all the
+		 * necessary logic is reset in the core, which may
+		 * take several clocks, depending on the current state
+		 * of the core.
+		 */
+		unsigned csftrst : 1;
+		/** Hclk Soft Reset
+		 *
+		 * The application uses this bit to reset the control logic in
+		 * the AHB clock domain. Only AHB clock domain pipelines are
+		 * reset.
+		 */
+		unsigned hsftrst : 1;
+		/** Host Frame Counter Reset (Host Only)<br>
+		 *
+		 * The application can reset the (micro)frame number
+		 * counter inside the core, using this bit. When the
+		 * (micro)frame counter is reset, the subsequent SOF
+		 * sent out by the core, will have a (micro)frame
+		 * number of 0.
+		 */
+		unsigned hstfrm : 1;
+		/** In Token Sequence Learning Queue Flush
+		 * (INTknQFlsh) (Device Only)
+		 */
+		unsigned intknqflsh : 1;
+		/** RxFIFO Flush (RxFFlsh) (Device and Host)
+		 *
+		 * The application can flush the entire Receive FIFO
+		 * using this bit.	<p>The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is reading from the RxFIFO nor the MAC
+		 * is writing the data in to the FIFO.	<p>The
+		 * application should wait until the bit is cleared
+		 * before performing any other operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned rxfflsh : 1;
+		/** TxFIFO Flush (TxFFlsh) (Device and Host).
+		 *
+		 * This bit is used to selectively flush a single or
+		 * all transmit FIFOs.	The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is writing into the TxFIFO nor the MAC
+		 * is reading the data out of the FIFO.	 <p>The
+		 * application should wait until the core clears this
+		 * bit, before performing any operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned txfflsh : 1;
+
+		/** TxFIFO Number (TxFNum) (Device and Host).
+		 *
+		 * This is the FIFO number which needs to be flushed,
+		 * using the TxFIFO Flush bit. This field should not
+		 * be changed until the TxFIFO Flush bit is cleared by
+		 * the core.
+		 *	 - 0x0 : Non Periodic TxFIFO Flush
+		 *	 - 0x1 : Periodic TxFIFO #1 Flush in device mode
+		 *	   or Periodic TxFIFO in host mode
+		 *	 - 0x2 : Periodic TxFIFO #2 Flush in device mode.
+		 *	 - ...
+		 *	 - 0xF : Periodic TxFIFO #15 Flush in device mode
+		 *	 - 0x10: Flush all the Transmit NonPeriodic and
+		 *	   Transmit Periodic FIFOs in the core
+		 */
+		unsigned txfnum : 5;
+		/** Reserved */
+		unsigned reserved11_29 : 19;
+		/** DMA Request Signal.	 Indicated DMA request is in
+		 * probress.  Used for debug purpose. */
+		unsigned dmareq : 1;
+		/** AHB Master Idle.  Indicates the AHB Master State
+		 * Machine is in IDLE condition. */
+		unsigned ahbidle : 1;
+	} b;
+} grstctl_t;
+
+
+/**
+ * This union represents the bit fields of the Core Interrupt Mask
+ * Register (GINTMSK).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned reserved0 : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned reserved16 : 1;
+		unsigned epmismatch : 1;
+		unsigned inepintr : 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintmsk_data_t;
+/**
+ * This union represents the bit fields of the Core Interrupt Register
+ * (GINTSTS).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union gintsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+#define DWC_SOF_INTR_MASK 0x0008
+	/** register bits */
+	struct
+	{
+#define DWC_HOST_MODE 1
+		unsigned curmode : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned intokenrx : 1;
+		unsigned epmismatch : 1;
+		unsigned inepint: 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union device_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned epnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+#define DWC_STS_DATA_UPDT		0x2				  // OUT Data Packet
+#define DWC_STS_XFER_COMP		0x3				  // OUT Data Transfer Complete
+
+#define DWC_DSTS_GOUT_NAK		0x1				  // Global OUT NAK
+#define DWC_DSTS_SETUP_COMP		0x4				  // Setup Phase Complete
+#define DWC_DSTS_SETUP_UPDT 0x6				  // SETUP Packet
+		unsigned pktsts : 4;
+		unsigned fn : 4;
+		unsigned reserved : 7;
+	} b;
+} device_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union host_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned chnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+		unsigned pktsts : 4;
+#define DWC_GRXSTS_PKTSTS_IN			  0x2
+#define DWC_GRXSTS_PKTSTS_IN_XFER_COMP	  0x3
+#define DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR 0x5
+#define DWC_GRXSTS_PKTSTS_CH_HALTED		  0x7
+
+		unsigned reserved : 11;
+	} b;
+} host_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the FIFO Size Registers (HPTXFSIZ,
+ * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element then
+ * read out the bits using the <i>b</i>it elements.
+ */
+typedef union fifosize_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned startaddr : 16;
+		unsigned depth : 16;
+	} b;
+} fifosize_data_t;
+
+/**
+ * This union represents the bit fields in the Non-Periodic Transmit
+ * FIFO/Queue Status Register (GNPTXSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union gnptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned nptxfspcavail : 16;
+		unsigned nptxqspcavail : 8;
+		/** Top of the Non-Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (Last entry for the selected
+		 *	  channel/EP)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - IN/OUT
+		 *	  - 2'b01 - Zero Length OUT
+		 *	  - 2'b10 - PING/Complete Split
+		 *	  - 2'b11 - Channel Halt
+		 *	- bits 30:27 - Channel/EP Number
+		 */
+		unsigned nptxqtop_terminate : 1;
+		unsigned nptxqtop_token : 2;
+		unsigned nptxqtop_chnep : 4;
+		unsigned reserved : 1;
+	} b;
+} gnptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Transmit
+ * FIFO Status Register (DTXFSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union dtxfsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned txfspcavail : 16;
+		unsigned reserved : 16;
+	} b;
+} dtxfsts_data_t;
+
+/**
+ * This union represents the bit fields in the I2C Control Register
+ * (I2CCTL). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gi2cctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned rwdata : 8;
+		unsigned regaddr : 8;
+		unsigned addr : 7;
+		unsigned i2cen : 1;
+		unsigned ack : 1;
+		unsigned i2csuspctl : 1;
+		unsigned i2cdevaddr : 2;
+		unsigned reserved : 2;
+		unsigned rw : 1;
+		unsigned bsydne : 1;
+	} b;
+} gi2cctl_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config1
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ep_dir0 : 2;
+		unsigned ep_dir1 : 2;
+		unsigned ep_dir2 : 2;
+		unsigned ep_dir3 : 2;
+		unsigned ep_dir4 : 2;
+		unsigned ep_dir5 : 2;
+		unsigned ep_dir6 : 2;
+		unsigned ep_dir7 : 2;
+		unsigned ep_dir8 : 2;
+		unsigned ep_dir9 : 2;
+		unsigned ep_dir10 : 2;
+		unsigned ep_dir11 : 2;
+		unsigned ep_dir12 : 2;
+		unsigned ep_dir13 : 2;
+		unsigned ep_dir14 : 2;
+		unsigned ep_dir15 : 2;
+	} b;
+} hwcfg1_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config2
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg2_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG2 */
+		unsigned op_mode : 3;
+#define DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG 0
+#define DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG 1
+#define DWC_HWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE_OTG 2
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE 3
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE 4
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST 5
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST 6
+
+		unsigned architecture : 2;
+		unsigned point2point : 1;
+		unsigned hs_phy_type : 2;
+#define DWC_HWCFG2_HS_PHY_TYPE_NOT_SUPPORTED 0
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI 1
+#define DWC_HWCFG2_HS_PHY_TYPE_ULPI 2
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI 3
+
+		unsigned fs_phy_type : 2;
+		unsigned num_dev_ep : 4;
+		unsigned num_host_chan : 4;
+		unsigned perio_ep_supported : 1;
+		unsigned dynamic_fifo : 1;
+		unsigned rx_status_q_depth : 2;
+		unsigned nonperio_tx_q_depth : 2;
+		unsigned host_perio_tx_q_depth : 2;
+		unsigned dev_token_q_depth : 5;
+		unsigned reserved31 : 1;
+	} b;
+} hwcfg2_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config3
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg3_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG3 */
+		unsigned xfer_size_cntr_width : 4;
+		unsigned packet_size_cntr_width : 3;
+		unsigned otg_func : 1;
+		unsigned i2c : 1;
+		unsigned vendor_ctrl_if : 1;
+		unsigned optional_features : 1;
+		unsigned synch_reset_type : 1;
+		unsigned ahb_phy_clock_synch : 1;
+		unsigned reserved15_13 : 3;
+		unsigned dfifo_depth : 16;
+	} b;
+} hwcfg3_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config4
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg4_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned num_dev_perio_in_ep : 4;
+		unsigned power_optimiz : 1;
+		unsigned min_ahb_freq : 9;
+		unsigned utmi_phy_data_width : 2;
+		unsigned num_dev_mode_ctrl_ep : 4;
+		unsigned iddig_filt_en : 1;
+		unsigned vbus_valid_filt_en : 1;
+		unsigned a_valid_filt_en : 1;
+		unsigned b_valid_filt_en : 1;
+		unsigned session_end_filt_en : 1;
+		unsigned ded_fifo_en : 1;
+		unsigned num_in_eps : 4;
+		unsigned reserved31_30 : 2;
+	} b;
+} hwcfg4_data_t;
+
+////////////////////////////////////////////
+// Device Registers
+/**
+ * Device Global Registers. <i>Offsets 800h-BFFh</i>
+ *
+ * The following structures define the size and relative field offsets
+ * for the Device Mode Registers.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_global_regs
+{
+	/** Device Configuration Register. <i>Offset 800h</i> */
+	volatile uint32_t dcfg;
+	/** Device Control Register. <i>Offset: 804h</i> */
+	volatile uint32_t dctl;
+	/** Device Status Register (Read Only). <i>Offset: 808h</i> */
+	volatile uint32_t dsts;
+	/** Reserved. <i>Offset: 80Ch</i> */
+	uint32_t unused;
+	/** Device IN Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 810h</i> */
+	volatile uint32_t diepmsk;
+	/** Device OUT Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 814h</i> */
+	volatile uint32_t doepmsk;
+	/** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+	volatile uint32_t daint;
+	/** Device All Endpoints Interrupt Mask Register.  <i>Offset:
+	 * 81Ch</i> */
+	volatile uint32_t daintmsk;
+	/** Device IN Token Queue Read Register-1 (Read Only).
+	 * <i>Offset: 820h</i> */
+	volatile uint32_t dtknqr1;
+	/** Device IN Token Queue Read Register-2 (Read Only).
+	 * <i>Offset: 824h</i> */
+	volatile uint32_t dtknqr2;
+	/** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+	volatile uint32_t dvbusdis;
+	/** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+	volatile uint32_t dvbuspulse;
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */
+	volatile uint32_t dtknqr3_dthrctl;
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */
+	volatile uint32_t dtknqr4_fifoemptymsk;
+} dwc_otg_device_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Device Configuration
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.  Write the
+ * <i>d32</i> member to the dcfg register.
+ */
+typedef union dcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Device Speed */
+		unsigned devspd : 2;
+		/** Non Zero Length Status OUT Handshake */
+		unsigned nzstsouthshk : 1;
+#define DWC_DCFG_SEND_STALL 1
+
+		unsigned reserved3 : 1;
+		/** Device Addresses */
+		unsigned devaddr : 7;
+		/** Periodic Frame Interval */
+		unsigned perfrint : 2;
+#define DWC_DCFG_FRAME_INTERVAL_80 0
+#define DWC_DCFG_FRAME_INTERVAL_85 1
+#define DWC_DCFG_FRAME_INTERVAL_90 2
+#define DWC_DCFG_FRAME_INTERVAL_95 3
+
+		unsigned reserved13_17 : 5;
+		/** In Endpoint Mis-match count */
+		unsigned epmscnt : 4;
+	} b;
+} dcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Device Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Remote Wakeup */
+		unsigned rmtwkupsig : 1;
+		/** Soft Disconnect */
+		unsigned sftdiscon : 1;
+		/** Global Non-Periodic IN NAK Status */
+		unsigned gnpinnaksts : 1;
+		/** Global OUT NAK Status */
+		unsigned goutnaksts : 1;
+		/** Test Control */
+		unsigned tstctl : 3;
+		/** Set Global Non-Periodic IN NAK */
+		unsigned sgnpinnak : 1;
+		/** Clear Global Non-Periodic IN NAK */
+		unsigned cgnpinnak : 1;
+		/** Set Global OUT NAK */
+		unsigned sgoutnak : 1;
+		/** Clear Global OUT NAK */
+		unsigned cgoutnak : 1;
+
+		unsigned reserved : 21;
+	} b;
+} dctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device Status
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Suspend Status */
+		unsigned suspsts : 1;
+		/** Enumerated Speed */
+		unsigned enumspd : 2;
+#define DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ 0
+#define DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ 1
+#define DWC_DSTS_ENUMSPD_LS_PHY_6MHZ		   2
+#define DWC_DSTS_ENUMSPD_FS_PHY_48MHZ		   3
+		/** Erratic Error */
+		unsigned errticerr : 1;
+		unsigned reserved4_7: 4;
+		/** Frame or Microframe Number of the received SOF */
+		unsigned soffn : 14;
+		unsigned reserved22_31 : 10;
+	} b;
+} dsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device IN EP Interrupt
+ * Register and the Device IN EP Common Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union diepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete mask */
+		unsigned xfercompl : 1;
+		/** Endpoint disable mask */
+		unsigned epdisabled : 1;
+		/** AHB Error mask */
+		unsigned ahberr : 1;
+		/** TimeOUT Handshake mask (non-ISOC EPs) */
+		unsigned timeout : 1;
+		/** IN Token received with TxF Empty mask */
+		unsigned intktxfemp : 1;
+		/** IN Token Received with EP mismatch mask */
+		unsigned intknepmis : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned inepnakeff : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned emptyintr : 1;
+
+		unsigned txfifoundrn : 1;
+
+		unsigned reserved08_31 : 23;
+		} b;
+} diepint_data_t;
+/**
+ * This union represents the bit fields in the Device IN EP Common
+ * Interrupt Mask Register.
+ */
+typedef union diepint_data diepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP Interrupt
+ * Registerand Device OUT EP Common Interrupt Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union doepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete */
+		unsigned xfercompl : 1;
+		/** Endpoint disable  */
+		unsigned epdisabled : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** Setup Phase Done (contorl EPs) */
+		unsigned setup : 1;
+		unsigned reserved04_31 : 28;
+	} b;
+} doepint_data_t;
+/**
+ * This union represents the bit fields in the Device OUT EP Common
+ * Interrupt Mask Register.
+ */
+typedef union doepint_data doepmsk_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device All EP Interrupt
+ * and Mask Registers.
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union daint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned in : 16;
+		/** OUT Endpoint bits */
+		unsigned out : 16;
+	} ep;
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned inep0	: 1;
+		unsigned inep1	: 1;
+		unsigned inep2	: 1;
+		unsigned inep3	: 1;
+		unsigned inep4	: 1;
+		unsigned inep5	: 1;
+		unsigned inep6	: 1;
+		unsigned inep7	: 1;
+		unsigned inep8	: 1;
+		unsigned inep9	: 1;
+		unsigned inep10 : 1;
+		unsigned inep11 : 1;
+		unsigned inep12 : 1;
+		unsigned inep13 : 1;
+		unsigned inep14 : 1;
+		unsigned inep15 : 1;
+		/** OUT Endpoint bits */
+		unsigned outep0	 : 1;
+		unsigned outep1	 : 1;
+		unsigned outep2	 : 1;
+		unsigned outep3	 : 1;
+		unsigned outep4	 : 1;
+		unsigned outep5	 : 1;
+		unsigned outep6	 : 1;
+		unsigned outep7	 : 1;
+		unsigned outep8	 : 1;
+		unsigned outep9	 : 1;
+		unsigned outep10 : 1;
+		unsigned outep11 : 1;
+		unsigned outep12 : 1;
+		unsigned outep13 : 1;
+		unsigned outep14 : 1;
+		unsigned outep15 : 1;
+	} b;
+} daint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN Token Queue
+ * Read Registers.
+ * - Read the register into the <i>d32</i> member.
+ * - READ-ONLY Register
+ */
+typedef union dtknq1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** In Token Queue Write Pointer */
+		unsigned intknwptr : 5;
+		/** Reserved */
+		unsigned reserved05_06 : 2;
+		/** write pointer has wrapped. */
+		unsigned wrap_bit : 1;
+		/** EP Numbers of IN Tokens 0 ... 4 */
+		unsigned epnums0_5 : 24;
+	}b;
+} dtknq1_data_t;
+
+/**
+ * This union represents Threshold control Register
+ * - Read and write the register into the <i>d32</i> member.
+ * - READ-WRITABLE Register
+ */
+typedef union dthrctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** non ISO Tx Thr. Enable */
+		unsigned non_iso_thr_en : 1;
+		/** ISO Tx Thr. Enable */
+		unsigned iso_thr_en : 1;
+		/** Tx Thr. Length */
+		unsigned tx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved11_15 : 5;
+		/** Rx Thr. Enable */
+		unsigned rx_thr_en : 1;
+		/** Rx Thr. Length */
+		unsigned rx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved26_31 : 6;
+	}b;
+} dthrctl_data_t;
+
+
+/**
+ * Device Logical IN Endpoint-Specific Registers. <i>Offsets
+ * 900h-AFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_in_ep_regs
+{
+	/** Device IN Endpoint Control Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t diepctl;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 04h</i> */
+	uint32_t reserved04;
+	/** Device IN Endpoint Interrupt Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t diepint;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device IN Endpoint Transfer Size
+	 * Register. <i>Offset:900h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t dieptsiz;
+	/** Device IN Endpoint DMA Address Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 14h</i> */
+	volatile uint32_t diepdma;
+	/** Device IN Endpoint Transmit FIFO Status Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 18h</i> */
+	volatile uint32_t dtxfsts;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 1Ch - 900h +
+	 * (ep_num * 20h) + 1Ch</i>*/
+	uint32_t reserved18;
+} dwc_otg_dev_in_ep_regs_t;
+
+/**
+ * Device Logical OUT Endpoint-Specific Registers. <i>Offsets:
+ * B00h-CFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_out_ep_regs
+{
+	/** Device OUT Endpoint Control Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t doepctl;
+	/** Device OUT Endpoint Frame number Register.	<i>Offset:
+	 * B00h + (ep_num * 20h) + 04h</i> */
+	volatile uint32_t doepfn;
+	/** Device OUT Endpoint Interrupt Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t doepint;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device OUT Endpoint Transfer Size Register. <i>Offset:
+	 * B00h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t doeptsiz;
+	/** Device OUT Endpoint DMA Address Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 14h</i> */
+	volatile uint32_t doepdma;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 18h - B00h +
+	 * (ep_num * 20h) + 1Ch</i> */
+	uint32_t unused[2];
+} dwc_otg_dev_out_ep_regs_t;
+
+/**
+ * This union represents the bit fields in the Device EP Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union depctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Maximum Packet Size
+		 * IN/OUT EPn
+		 * IN/OUT EP0 - 2 bits
+		 *	 2'b00: 64 Bytes
+		 *	 2'b01: 32
+		 *	 2'b10: 16
+		 *	 2'b11: 8 */
+		unsigned mps : 11;
+#define DWC_DEP0CTL_MPS_64	 0
+#define DWC_DEP0CTL_MPS_32	 1
+#define DWC_DEP0CTL_MPS_16	 2
+#define DWC_DEP0CTL_MPS_8	 3
+
+		/** Next Endpoint
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned nextep : 4;
+
+		/** USB Active Endpoint */
+		unsigned usbactep : 1;
+
+		/** Endpoint DPID (INTR/Bulk IN and OUT endpoints)
+		 * This field contains the PID of the packet going to
+		 * be received or transmitted on this endpoint. The
+		 * application should program the PID of the first
+		 * packet going to be received or transmitted on this
+		 * endpoint , after the endpoint is
+		 * activated. Application use the SetD1PID and
+		 * SetD0PID fields of this register to program either
+		 * D0 or D1 PID.
+		 *
+		 * The encoding for this field is
+		 *	 - 0: D0
+		 *	 - 1: D1
+		 */
+		unsigned dpid : 1;
+
+		/** NAK Status */
+		unsigned naksts : 1;
+
+		/** Endpoint Type
+		 *	2'b00: Control
+		 *	2'b01: Isochronous
+		 *	2'b10: Bulk
+		 *	2'b11: Interrupt */
+		unsigned eptype : 2;
+
+		/** Snoop Mode
+		 * OUT EPn/OUT EP0
+		 * IN EPn/IN EP0 - reserved */
+		unsigned snp : 1;
+
+		/** Stall Handshake */
+		unsigned stall : 1;
+
+		/** Tx Fifo Number
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned txfnum : 4;
+
+		/** Clear NAK */
+		unsigned cnak : 1;
+		/** Set NAK */
+		unsigned snak : 1;
+		/** Set DATA0 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA0. Set Even
+		 * (micro)frame (SetEvenFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to even (micro)
+		 * frame.
+		 */
+		unsigned setd0pid : 1;
+		/** Set DATA1 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA1 Set Odd
+		 * (micro)frame (SetOddFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to odd (micro) frame.
+		 */
+		unsigned setd1pid : 1;
+
+		/** Endpoint Disable */
+		unsigned epdis : 1;
+		/** Endpoint Enable */
+		unsigned epena : 1;
+		} b;
+} depctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 19;
+		/** Packet Count */
+		unsigned pktcnt : 10;
+		/** Multi Count - Periodic IN endpoints */
+		unsigned mc : 2;
+		unsigned reserved : 1;
+		} b;
+} deptsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP 0 Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz0_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 7;
+				/** Reserved */
+				unsigned reserved7_18 : 12;
+		/** Packet Count */
+		unsigned pktcnt : 1;
+				/** Reserved */
+		unsigned reserved20_28 : 9;
+				/**Setup Packet Count (DOEPTSIZ0 Only) */
+				unsigned supcnt : 2;
+				unsigned reserved31;
+		} b;
+} deptsiz0_data_t;
+
+
+/** Maximum number of Periodic FIFOs */
+#define MAX_PERIO_FIFOS 15
+/** Maximum number of Periodic FIFOs */
+#define MAX_TX_FIFOS 15
+
+/** Maximum number of Endpoints/HostChannels */
+#define MAX_EPS_CHANNELS 16
+
+/**
+ * The dwc_otg_dev_if structure contains information needed to manage
+ * the DWC_otg controller acting in device mode. It represents the
+ * programming view of the device-specific aspects of the controller.
+ */
+typedef struct dwc_otg_dev_if
+{
+	/** Pointer to device Global registers.
+	 * Device Global Registers starting at offset 800h
+	 */
+	dwc_otg_device_global_regs_t *dev_global_regs;
+#define DWC_DEV_GLOBAL_REG_OFFSET 0x800
+
+	/**
+	 * Device Logical IN Endpoint-Specific Registers 900h-AFCh
+	 */
+	dwc_otg_dev_in_ep_regs_t	 *in_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_IN_EP_REG_OFFSET 0x900
+#define DWC_EP_REG_OFFSET 0x20
+
+	/** Device Logical OUT Endpoint-Specific Registers B00h-CFCh */
+	dwc_otg_dev_out_ep_regs_t	 *out_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_OUT_EP_REG_OFFSET 0xB00
+
+	/* Device configuration information*/
+	uint8_t	 speed;				 /**< Device Speed	0: Unknown, 1: LS, 2:FS, 3: HS */
+	uint8_t	 num_in_eps;		 /**< Number # of Tx EP range: 0-15 exept ep0 */
+	uint8_t	 num_out_eps;		 /**< Number # of Rx EP range: 0-15 exept ep 0*/
+
+	/** Size of periodic FIFOs (Bytes) */
+	uint16_t perio_tx_fifo_size[MAX_PERIO_FIFOS];
+
+	/** Size of Tx FIFOs (Bytes) */
+	uint16_t tx_fifo_size[MAX_TX_FIFOS];
+
+	/** Thresholding enable flags and length varaiables **/
+	uint16_t rx_thr_en;
+	uint16_t iso_tx_thr_en;
+	uint16_t non_iso_tx_thr_en;
+
+	uint16_t rx_thr_length;
+	uint16_t tx_thr_length;
+
+} dwc_otg_dev_if_t;
+
+
+
+
+/////////////////////////////////////////////////
+// Host Mode Register Structures
+//
+/**
+ * The Host Global Registers structure defines the size and relative
+ * field offsets for the Host Mode Global Registers.  Host Global
+ * Registers offsets 400h-7FFh.
+*/
+typedef struct dwc_otg_host_global_regs
+{
+	/** Host Configuration Register.   <i>Offset: 400h</i> */
+	volatile uint32_t hcfg;
+	/** Host Frame Interval Register.	<i>Offset: 404h</i> */
+	volatile uint32_t hfir;
+	/** Host Frame Number / Frame Remaining Register. <i>Offset: 408h</i> */
+	volatile uint32_t hfnum;
+	/** Reserved.	<i>Offset: 40Ch</i> */
+	uint32_t reserved40C;
+	/** Host Periodic Transmit FIFO/ Queue Status Register. <i>Offset: 410h</i> */
+	volatile uint32_t hptxsts;
+	/** Host All Channels Interrupt Register. <i>Offset: 414h</i> */
+	volatile uint32_t haint;
+	/** Host All Channels Interrupt Mask Register. <i>Offset: 418h</i> */
+	volatile uint32_t haintmsk;
+} dwc_otg_host_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Configuration Register.
+ * Read the register into the <i>d32</i> member then set/clear the bits using
+ * the <i>b</i>it elements. Write the <i>d32</i> member to the hcfg register.
+ */
+typedef union hcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** FS/LS Phy Clock Select */
+		unsigned fslspclksel : 2;
+#define DWC_HCFG_30_60_MHZ 0
+#define DWC_HCFG_48_MHZ	   1
+#define DWC_HCFG_6_MHZ	   2
+
+		/** FS/LS Only Support */
+		unsigned fslssupp : 1;
+		} b;
+} hcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfir_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frint : 16;
+		unsigned reserved : 16;
+	} b;
+} hfir_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfnum_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frnum : 16;
+#define DWC_HFNUM_MAX_FRNUM 0x3FFF
+		unsigned frrem : 16;
+	} b;
+} hfnum_data_t;
+
+typedef union hptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned ptxfspcavail : 16;
+		unsigned ptxqspcavail : 8;
+		/** Top of the Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (last entry for the selected channel)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - Zero length
+		 *	  - 2'b01 - Ping
+		 *	  - 2'b10 - Disable
+		 *	- bits 30:27 - Channel Number
+		 *	- bit 31 - Odd/even microframe
+		 */
+		unsigned ptxqtop_terminate : 1;
+		unsigned ptxqtop_token : 2;
+		unsigned ptxqtop_chnum : 4;
+		unsigned ptxqtop_odd : 1;
+	} b;
+} hptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Port Control and Status
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hprt0 register.
+ */
+typedef union hprt0_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned prtconnsts : 1;
+		unsigned prtconndet : 1;
+		unsigned prtena : 1;
+		unsigned prtenchng : 1;
+		unsigned prtovrcurract : 1;
+		unsigned prtovrcurrchng : 1;
+		unsigned prtres : 1;
+		unsigned prtsusp : 1;
+		unsigned prtrst : 1;
+		unsigned reserved9 : 1;
+		unsigned prtlnsts : 2;
+		unsigned prtpwr : 1;
+		unsigned prttstctl : 4;
+		unsigned prtspd : 2;
+#define DWC_HPRT0_PRTSPD_HIGH_SPEED 0
+#define DWC_HPRT0_PRTSPD_FULL_SPEED 1
+#define DWC_HPRT0_PRTSPD_LOW_SPEED	2
+		unsigned reserved19_31 : 13;
+	} b;
+} hprt0_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haint_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haintmsk_data_t;
+
+/**
+ * Host Channel Specific Registers. <i>500h-5FCh</i>
+ */
+typedef struct dwc_otg_hc_regs
+{
+	/** Host Channel 0 Characteristic Register. <i>Offset: 500h + (chan_num * 20h) + 00h</i> */
+	volatile uint32_t hcchar;
+	/** Host Channel 0 Split Control Register. <i>Offset: 500h + (chan_num * 20h) + 04h</i> */
+	volatile uint32_t hcsplt;
+	/** Host Channel 0 Interrupt Register. <i>Offset: 500h + (chan_num * 20h) + 08h</i> */
+	volatile uint32_t hcint;
+	/** Host Channel 0 Interrupt Mask Register. <i>Offset: 500h + (chan_num * 20h) + 0Ch</i> */
+	volatile uint32_t hcintmsk;
+	/** Host Channel 0 Transfer Size Register. <i>Offset: 500h + (chan_num * 20h) + 10h</i> */
+	volatile uint32_t hctsiz;
+	/** Host Channel 0 DMA Address Register. <i>Offset: 500h + (chan_num * 20h) + 14h</i> */
+	volatile uint32_t hcdma;
+	/** Reserved.  <i>Offset: 500h + (chan_num * 20h) + 18h - 500h + (chan_num * 20h) + 1Ch</i> */
+	uint32_t reserved[2];
+} dwc_otg_hc_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Characteristics
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hcchar_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Maximum packet size in bytes */
+		unsigned mps : 11;
+
+		/** Endpoint number */
+		unsigned epnum : 4;
+
+		/** 0: OUT, 1: IN */
+		unsigned epdir : 1;
+
+		unsigned reserved : 1;
+
+		/** 0: Full/high speed device, 1: Low speed device */
+		unsigned lspddev : 1;
+
+		/** 0: Control, 1: Isoc, 2: Bulk, 3: Intr */
+		unsigned eptype : 2;
+
+		/** Packets per frame for periodic transfers. 0 is reserved. */
+		unsigned multicnt : 2;
+
+		/** Device address */
+		unsigned devaddr : 7;
+
+		/**
+		 * Frame to transmit periodic transaction.
+		 * 0: even, 1: odd
+		 */
+		unsigned oddfrm : 1;
+
+		/** Channel disable */
+		unsigned chdis : 1;
+
+		/** Channel enable */
+		unsigned chen : 1;
+	} b;
+} hcchar_data_t;
+
+typedef union hcsplt_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Port Address */
+		unsigned prtaddr : 7;
+
+		/** Hub Address */
+		unsigned hubaddr : 7;
+
+		/** Transaction Position */
+		unsigned xactpos : 2;
+#define DWC_HCSPLIT_XACTPOS_MID 0
+#define DWC_HCSPLIT_XACTPOS_END 1
+#define DWC_HCSPLIT_XACTPOS_BEGIN 2
+#define DWC_HCSPLIT_XACTPOS_ALL 3
+
+		/** Do Complete Split */
+		unsigned compsplt : 1;
+
+		/** Reserved */
+		unsigned reserved : 14;
+
+		/** Split Enble */
+		unsigned spltena : 1;
+	} b;
+} hcsplt_data_t;
+
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union hcint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer Complete */
+		unsigned xfercomp : 1;
+		/** Channel Halted */
+		unsigned chhltd : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** STALL Response Received */
+		unsigned stall : 1;
+		/** NAK Response Received */
+		unsigned nak : 1;
+		/** ACK Response Received */
+		unsigned ack : 1;
+		/** NYET Response Received */
+		unsigned nyet : 1;
+		/** Transaction Err */
+		unsigned xacterr : 1;
+		/** Babble Error */
+		unsigned bblerr : 1;
+		/** Frame Overrun */
+		unsigned frmovrun : 1;
+		/** Data Toggle Error */
+		unsigned datatglerr : 1;
+		/** Reserved */
+		unsigned reserved : 21;
+	} b;
+} hcint_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Transfer Size
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hctsiz_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Total transfer size in bytes */
+		unsigned xfersize : 19;
+
+		/** Data packets to transfer */
+		unsigned pktcnt : 10;
+
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control), SETUP (Control)
+		 */
+		unsigned pid : 2;
+#define DWC_HCTSIZ_DATA0 0
+#define DWC_HCTSIZ_DATA1 2
+#define DWC_HCTSIZ_DATA2 1
+#define DWC_HCTSIZ_MDATA 3
+#define DWC_HCTSIZ_SETUP 3
+
+		/** Do PING protocol when 1 */
+		unsigned dopng : 1;
+	} b;
+} hctsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Interrupt Mask
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcintmsk register.
+ */
+typedef union hcintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned xfercompl : 1;
+		unsigned chhltd : 1;
+		unsigned ahberr : 1;
+		unsigned stall : 1;
+		unsigned nak : 1;
+		unsigned ack : 1;
+		unsigned nyet : 1;
+		unsigned xacterr : 1;
+		unsigned bblerr : 1;
+		unsigned frmovrun : 1;
+		unsigned datatglerr : 1;
+		unsigned reserved : 21;
+	} b;
+} hcintmsk_data_t;
+
+/** OTG Host Interface Structure.
+ *
+ * The OTG Host Interface Structure structure contains information
+ * needed to manage the DWC_otg controller acting in host mode. It
+ * represents the programming view of the host-specific aspects of the
+ * controller.
+ */
+typedef struct dwc_otg_host_if
+{
+	/** Host Global Registers starting at offset 400h.*/
+	dwc_otg_host_global_regs_t *host_global_regs;
+#define DWC_OTG_HOST_GLOBAL_REG_OFFSET 0x400
+
+	/** Host Port 0 Control and Status Register */
+	volatile uint32_t *hprt0;
+#define DWC_OTG_HOST_PORT_REGS_OFFSET 0x440
+
+
+	/** Host Channel Specific Registers at offsets 500h-5FCh. */
+	dwc_otg_hc_regs_t *hc_regs[MAX_EPS_CHANNELS];
+#define DWC_OTG_HOST_CHAN_REGS_OFFSET 0x500
+#define DWC_OTG_CHAN_REGS_OFFSET 0x20
+
+
+	/* Host configuration information */
+	/** Number of Host Channels (range: 1-16) */
+	uint8_t	 num_host_channels;
+	/** Periodic EPs supported (0: no, 1: yes) */
+	uint8_t	 perio_eps_supported;
+	/** Periodic Tx FIFO Size (Only 1 host periodic Tx FIFO) */
+	uint16_t perio_tx_fifo_size;
+
+} dwc_otg_host_if_t;
+
+
+/**
+ * This union represents the bit fields in the Power and Clock Gating Control
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union pcgcctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Stop Pclk */
+		unsigned stoppclk : 1;
+		/** Gate Hclk */
+		unsigned gatehclk : 1;
+		/** Power Clamp */
+		unsigned pwrclmp : 1;
+		/** Reset Power Down Modules */
+		unsigned rstpdwnmodule : 1;
+		/** PHY Suspended */
+		unsigned physuspended : 1;
+
+		unsigned reserved : 27;
+	} b;
+} pcgcctl_data_t;
+
+#define DWC_OTG_EP_TYPE_CONTROL    0
+#define DWC_OTG_EP_TYPE_ISOC       1
+#define DWC_OTG_EP_TYPE_BULK       2
+#define DWC_OTG_EP_TYPE_INTR       3
+
+
+int dwc_core_init(void);
+
+static void dwc_otg_core_init(void);
+static int  dwc_otg_pcd_init(void);
+static void dwc_otg_core_reset(void);
+static void dwc_otg_enable_common_interrupts(void);
+static void dwc_otg_enable_device_interrupts(void);
+static void dwc_otg_enable_global_interrupts(void);
+static void dwc_otg_core_dev_init(void);
+static void dwc_otg_flush_tx_fifo( const int _num ) ;
+static void dwc_otg_flush_rx_fifo(void) ;
+int dwc_otg_ep_req_start(pcd_struct_t * _pcd,int ep_num);
+void dwc_otg_ep_start_transfer(dwc_ep_t *_ep);
+static void dwc_otg_bulk_ep_activate(dwc_ep_t *ep);
+void dwc_otg_power_off_phy(void);
+void dwc_otg_pullup(int is_on);
+
+#endif
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.c b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.c
new file mode 100644
index 0000000..c9909d3
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.c
@@ -0,0 +1,1198 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "platform.h"
+#include "usb_ch9.h"
+#include "dwc_pcd.h"
+#include "dwc_pcd_irq.h"
+//#define flush_cpu_cache()
+extern void do_gadget_setup( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl);
+extern void do_vendor_request( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl);
+extern void do_vendor_out_complete( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl);
+extern void do_bulk_complete( pcd_struct_t *_pcd);
+extern void do_modify_memory(u16 opcode,char * inbuff);
+
+static void ep0_out_start(void);
+static int32_t ep0_complete_request( pcd_struct_t * pcd);
+/**
+ * This function starts the Zero-Length Packet for the IN status phase
+ * of a 2 stage control transfer.
+ */
+static void do_setup_in_status_phase( pcd_struct_t *_pcd)
+{
+        dwc_ep_t *ep0 = &g_dwc_eps[0];
+        if (_pcd->ep0state == EP0_STALL) {
+                return;
+        }
+
+        _pcd->ep0state = EP0_STATUS;
+
+        DBG( "EP0 IN ZLP\n");
+        ep0->xfer_len = 0;
+        ep0->xfer_count = 0;
+        ep0->is_in = 1;
+
+        dwc_otg_ep_start_transfer( ep0 );
+
+        /* Prepare for more SETUP Packets */
+        ep0_out_start();
+
+}
+/**
+ * This function starts the Zero-Length Packet for the OUT status phase
+ * of a 2 stage control transfer.
+ */
+static void do_setup_out_status_phase( pcd_struct_t *_pcd)
+{
+        dwc_ep_t *ep0 = &g_dwc_eps[0];
+        if (_pcd->ep0state == EP0_STALL) {
+                return;
+        }
+        _pcd->ep0state = EP0_STATUS;
+
+        /* Prepare for more SETUP Packets */
+        //ep0_out_start( GET_CORE_IF(_pcd), _pcd );
+
+        DBG( "EP0 OUT ZLP\n");
+        ep0->xfer_len = 0;
+        ep0->xfer_count = 0;
+        ep0->is_in = 0;
+        dwc_otg_ep_start_transfer( ep0 );
+
+        /* Prepare for more SETUP Packets */
+        ep0_out_start( );
+
+}
+static void pcd_out_completed(pcd_struct_t *_pcd)
+{
+	do_vendor_out_complete(_pcd,(struct usb_ctrlrequest*)&_pcd->setup_pkt);
+}
+static void pcd_setup( pcd_struct_t *_pcd )
+{
+
+	struct usb_ctrlrequest	ctrl = _pcd->setup_pkt.req;
+	dwc_ep_t	*ep0 = &g_dwc_eps[0];
+	//deptsiz0_data_t doeptsize0 = { 0};
+
+	if (_pcd->request_enable == 0)
+		return;
+
+//	_pcd->setup_pkt.d32[0] = 0;
+//	_pcd->setup_pkt.d32[1] = 0;
+	_pcd->request_enable = 0;
+
+        //doeptsize0.d32 = dwc_read_reg32( DWC_REG_OUT_EP_TSIZE(0));
+
+        if (ctrl.bRequestType & USB_DIR_IN) {
+                ep0->is_in = 1;
+                _pcd->ep0state = EP0_IN_DATA_PHASE;
+        } else {
+                ep0->is_in = 0;
+                _pcd->ep0state = EP0_OUT_DATA_PHASE;
+        }
+
+
+	if ((ctrl.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD) {
+		/* handle non-standard (class/vendor) requests in the gadget driver */
+		//do_gadget_setup(_pcd, &ctrl );
+		DBG("Vendor requset\n");
+		do_vendor_request(_pcd, &ctrl );
+		dwc_otg_ep_req_start(_pcd,0);
+		return;
+	}
+
+        /** @todo NGS: Handle bad setup packet? */
+
+        switch (ctrl.bRequest) {
+#if 0
+        case USB_REQ_GET_STATUS:
+
+                switch (ctrl.bRequestType & USB_RECIP_MASK) {
+                case USB_RECIP_DEVICE:
+                        *status = 0x1; /* Self powered */
+                        *status |= _pcd->remote_wakeup_enable << 1;
+                        break;
+
+                case USB_RECIP_INTERFACE:
+                        *status = 0;
+                        break;
+
+                case USB_RECIP_ENDPOINT:
+                        ep = get_ep_by_addr(_pcd, ctrl.wIndex);
+                        if ( ep == 0 || ctrl.wLength > 2) {
+                                ep0_do_stall(_pcd, -EOPNOTSUPP);
+                                return;
+                        }
+                        /** @todo check for EP stall */
+                        *status = ep->stopped;
+                        break;
+                }
+                _pcd->ep0_pending = 1;
+
+                ep0->dwc_ep.start_xfer_buff = (uint8_t *)status;
+                ep0->dwc_ep.xfer_buff = (uint8_t *)status;
+                ep0->dwc_ep.dma_addr = _pcd->status_buf_dma_handle;
+                ep0->dwc_ep.xfer_len = 2;
+                ep0->dwc_ep.xfer_count = 0;
+                ep0->dwc_ep.total_len = ep0->dwc_ep.xfer_len;
+                dwc_otg_ep0_start_transfer( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+                break;
+
+        case USB_REQ_CLEAR_FEATURE:
+                do_clear_feature( _pcd );
+                break;
+
+        case USB_REQ_SET_FEATURE:
+                do_set_feature( _pcd );
+                break;
+ #endif
+        case USB_REQ_SET_ADDRESS:
+                if (ctrl.bRequestType == USB_RECIP_DEVICE) {
+                        dcfg_data_t dcfg = { 0 };
+
+			    //DBG("Set address: %d\n",ctrl.wValue);
+                        dcfg.b.devaddr = ctrl.wValue;
+                        dwc_modify_reg32(DWC_REG_DCFG,0, dcfg.d32);
+                        do_setup_in_status_phase( _pcd );
+                        return;
+                }
+                break;
+
+        case USB_REQ_SET_INTERFACE:
+        case USB_REQ_SET_CONFIGURATION:
+                _pcd->request_config = 1;   /* Configuration changed */
+               // do_gadget_setup(_pcd, &ctrl );
+               // break;
+
+        default:
+                /* Call the Gadget Driver's setup functions */
+                do_gadget_setup(_pcd, &ctrl );
+                dwc_otg_ep_req_start(_pcd,0);
+		break;
+        }
+}
+
+/**
+ * This function handles EP0 Control transfers.
+ *
+ * The state of the control tranfers are tracked in
+ * <code>ep0state</code>.
+ * is_in : 1 -- IN Trans
+ * is_in : 0 -- OUT/SETUP Trans
+ */
+static void handle_ep0( int is_in )
+{
+	pcd_struct_t * _pcd = &this_pcd;
+	dwc_ep_t * ep0 = &g_dwc_eps[0];
+
+        switch (_pcd->ep0state) {
+        case EP0_DISCONNECT:
+		  DBG("EP0 DISCONNECT\n");
+                break;
+
+	case EP0_IDLE:
+                _pcd->request_config = 0;
+                DBG("Enter PCD Setup()\n");
+                pcd_setup( _pcd );
+                break;
+
+	case EP0_IN_DATA_PHASE:
+
+		if (ep0->xfer_count < ep0->total_len) {
+			DBG("FIX ME!! dwc_otg_ep0_continue_transfer!\n");
+			//dwc_otg_ep0_continue_transfer ( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+		}
+		else {
+			ep0_complete_request( _pcd );
+		}
+                break;
+
+	case EP0_OUT_DATA_PHASE:
+                ep0_complete_request(_pcd );
+		   pcd_out_completed(_pcd);
+                break;
+
+
+	case EP0_STATUS:
+
+                ep0_complete_request( _pcd );
+                _pcd->ep0state = EP0_IDLE;
+                ep0->stopped = 1;
+                ep0->is_in = 0;  /* OUT for next SETUP */
+
+                break;
+
+        case EP0_STALL:
+                ERR("EP0 STALLed, should not get here pcd_setup()\n");
+                break;
+        }
+}
+
+/**
+ * This function completes the request for the EP.  If there are
+ * additional requests for the EP in the queue they will be started.
+ */
+static void complete_ep( int ep_num,int is_in )
+{
+	deptsiz_data_t deptsiz;
+	pcd_struct_t *pcd = &this_pcd;
+	dwc_ep_t *ep = &g_dwc_eps[ep_num];
+
+	if (is_in) {
+
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_IN_EP_TSIZE(ep_num));
+		if (deptsiz.b.xfersize == 0 && deptsiz.b.pktcnt == 0 &&
+                    ep->xfer_count == ep->xfer_len) {
+
+			ep->start_xfer_buff = 0;
+			ep->xfer_buff = 0;
+			ep->xfer_len = 0;
+		}
+	}
+	else {/* OUT Transfer */
+
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_OUT_EP_TSIZE(ep_num));
+
+		pcd->xfer_len = ep->xfer_count;
+
+		ep->start_xfer_buff = 0;
+		ep->xfer_buff = 0;
+		ep->xfer_len = 0;
+	}
+	do_bulk_complete(pcd);
+}
+/**
+ * This function completes the ep0 control transfer.
+ */
+static int32_t ep0_complete_request( pcd_struct_t * pcd)
+{
+
+        deptsiz0_data_t deptsiz;
+        int is_last = 0;
+	 dwc_ep_t* ep = &g_dwc_eps[0];
+
+	 DBG("ep0_complete_request()\n");
+        if (pcd->ep0state == EP0_STATUS) {
+                is_last = 1;
+        } else if (ep->xfer_len == 0) {
+		ep->xfer_len = 0;
+		ep->xfer_count = 0;
+		ep->sent_zlp = 1;
+		dwc_otg_ep_start_transfer( ep );
+		return 1;
+	}
+	else if (ep->is_in) {
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_IN_EP_TSIZE(0) );
+		if (deptsiz.b.xfersize == 0) {
+			/* Is a Zero Len Packet needed? */
+			do_setup_out_status_phase(pcd);
+		}
+        } else {
+			/* ep0-OUT */
+			do_setup_in_status_phase(pcd);
+	}
+
+        /* Complete the request */
+        if (is_last) {
+                ep->start_xfer_buff = 0;
+                ep->xfer_buff = 0;
+                ep->xfer_len = 0;
+                return 1;
+        }
+        return 0;
+}
+/**
+ * This function reads a packet from the Rx FIFO into the destination
+ * buffer.  To read SETUP data use dwc_otg_read_setup_packet.
+ *
+ * @param _dest   Destination buffer for the packet.
+ * @param _bytes  Number of bytes to copy to the destination.
+ */
+static void dwc_otg_read_packet(uint8_t *_dest, uint16_t _bytes)	//Elvis Fool, add 'static'
+{
+	int i;
+	uint32_t buffer =0;
+	uint8_t*  pbyte = _dest;
+	/**
+	 * @todo Account for the case where _dest is not dword aligned. This
+	 * requires reading data from the FIFO into a uint32_t temp buffer,
+	 * then moving it into the data buffer.
+	 */
+	//DBG("dwc_otg_read_packet() dest: %p, len: %d\n",_dest,_bytes);
+	if (((unsigned long long)_dest &0x3) == 0)
+		for (i=0; i<_bytes; i+=4) {
+			*(uint32_t*)_dest = dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+			_dest+=4;
+		}
+	else
+		for (i=0; i<_bytes; i++) {
+			if ((i % 4) ==0)
+				buffer =dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+
+			*(uint8_t*)pbyte ++ = buffer;
+			buffer >>= 8;
+		}
+
+	return;
+}
+
+/**
+ * This function writes a packet into the Tx FIFO associated with the
+ * EP.  For non-periodic EPs the non-periodic Tx FIFO is written.  For
+ * periodic EPs the periodic Tx FIFO associated with the EP is written
+ * with all packets for the next micro-frame.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to write packet for.
+ * @param _dma Indicates if DMA is being used.
+ */
+void dwc_otg_ep_write_packet( dwc_ep_t *_ep)
+{
+	/**
+	 * The buffer is padded to DWORD on a per packet basis in
+	 * slave/dma mode if the MPS is not DWORD aligned.  The last
+	 * packet, if short, is also padded to a multiple of DWORD.
+	 *
+	 * ep->xfer_buff always starts DWORD aligned in memory and is a
+	 * multiple of DWORD in length
+	 *
+	 * ep->xfer_len can be any number of bytes
+	 *
+	 * ep->xfer_count is a multiple of ep->maxpacket until the last
+	 *  packet
+	 *
+	 * FIFO access is DWORD */
+
+	uint32_t i;
+	uint32_t byte_count;
+	uint32_t dword_count;
+	uint32_t fifo;
+        uint8_t *data_buff = _ep->xfer_buff;
+        uint32_t temp_data ;
+
+	//DBG("dwc_otg_ep_write_packet() : %d\n",_ep->xfer_len);
+        if (_ep->xfer_count >= _ep->xfer_len) {
+                //DWC_WARN("%s() No data for EP%d!!!\n", "dwc_otg_ep_write_packet", _ep->num);
+                return;
+        }
+
+	/* Find the byte length of the packet either short packet or MPS */
+	if ((_ep->xfer_len - _ep->xfer_count) < _ep->maxpacket) {
+		byte_count = _ep->xfer_len - _ep->xfer_count;
+	}
+	else {
+		byte_count = _ep->maxpacket;
+	}
+
+	/* Find the DWORD length, padded by extra bytes as neccessary if MPS
+	 * is not a multiple of DWORD */
+	dword_count =  (byte_count + 3) / 4;
+
+
+       //fifo = _core_if->data_fifo[_ep->num];
+     fifo = DWC_REG_DATA_FIFO(_ep->num);
+
+
+	for (i=0; i<dword_count; i++) {
+		temp_data =get_unaligned(data_buff);
+		dwc_write_reg32( fifo, temp_data );
+		data_buff += 4;
+	}
+
+
+	_ep->xfer_count += byte_count;
+        _ep->xfer_buff += byte_count;
+
+	flush_cpu_cache();
+
+}
+/**
+ * This function reads a setup packet from the Rx FIFO into the destination
+ * buffer.  This function is called from the Rx Status Queue Level (RxStsQLvl)
+ * Interrupt routine when a SETUP packet has been received in Slave mode.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _dest Destination buffer for packet data.
+ */
+void dwc_otg_read_setup_packet(uint32_t *_dest)
+{
+	/* Get the 8 bytes of a setup transaction data */
+
+	DBG("dwc_otg_read_setup_packet()\n");
+	/* Pop 2 DWORDS off the receive data FIFO into memory */
+	_dest[0] = dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+	_dest[1] = dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+}
+
+
+
+/**
+ * handle the IN EP disable interrupt.
+ */
+static void handle_in_ep_disable_intr(uint32_t _epnum)
+{
+#if 0
+        deptsiz_data_t dieptsiz = { 0 };
+        dctl_data_t dctl = { 0 };
+        depctl_data_t diepctl = { 0 };
+        dwc_ep_t *ep = &g_dwc_eps[_epnum];
+
+        if (ep->stopped) {
+                /* Flush the Tx FIFO */
+                /** @todo NGS: This is not the correct FIFO */
+                dwc_otg_flush_tx_fifo( core_if, 0 );
+                /* Clear the Global IN NP NAK */
+                dctl.d32 = 0;
+                dctl.b.cgnpinnak = 1;
+                dwc_modify_reg32(&dev_if->in_ep_regs[_epnum]->diepctl,
+                                 diepctl.d32, diepctl.d32);
+                /* Restart the transaction */
+                if (dieptsiz.b.pktcnt != 0 ||
+                    dieptsiz.b.xfersize != 0) {
+                        restart_transfer( _pcd, _epnum );
+                }
+        }
+#endif
+}
+
+/**
+ * Handler for the IN EP timeout handshake interrupt.
+ */
+static void handle_in_ep_timeout_intr(uint32_t _epnum)
+{
+
+        dctl_data_t dctl = { 0 };
+        dwc_ep_t *ep = &g_dwc_eps[_epnum];
+
+        gintmsk_data_t intr_mask = {0};
+
+
+        /* Disable the NP Tx Fifo Empty Interrrupt */
+
+	intr_mask.b.nptxfempty = 1;
+	dwc_modify_reg32( DWC_REG_GINTMSK, intr_mask.d32, 0);
+        /** @todo NGS Check EP type.
+         * Implement for Periodic EPs */
+        /*
+         * Non-periodic EP
+         */
+        /* Enable the Global IN NAK Effective Interrupt */
+        intr_mask.b.ginnakeff = 1;
+        dwc_modify_reg32( DWC_REG_GINTMSK, 0, intr_mask.d32);
+
+        /* Set Global IN NAK */
+        dctl.b.sgnpinnak = 1;
+        dwc_modify_reg32( DWC_REG_DCTL,dctl.d32, dctl.d32);
+
+        ep->stopped = 1;
+
+}
+
+///////////////////////////////////////////////////////////////////////
+/**
+ * This function handles the Rx Status Queue Level Interrupt, which
+ * indicates that there is a least one packet in the Rx FIFO.  The
+ * packets are moved from the FIFO to memory, where they will be
+ * processed when the Endpoint Interrupt Register indicates Transfer
+ * Complete or SETUP Phase Done.
+ *
+ * Repeat the following until the Rx Status Queue is empty:
+ *   -#	Read the Receive Status Pop Register (GRXSTSP) to get Packet
+ *     	info
+ *   -#	If Receive FIFO is empty then skip to step Clear the interrupt
+ *     	and exit
+ *   -#	If SETUP Packet call dwc_otg_read_setup_packet to copy the
+ *   	SETUP data to the buffer
+ *   -#	If OUT Data Packet call dwc_otg_read_packet to copy the data
+ *     	to the destination buffer
+ */
+int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(void)
+{
+	gintmsk_data_t gintmask = { 0 };
+	device_grxsts_data_t status;
+	gintsts_data_t gintsts;
+	dwc_ep_t *ep;
+
+
+        DBG("dwc_otg_pcd_handle_rx_status_q_level_intr()\n");
+        /* Disable the Rx Status Queue Level interrupt */
+        gintmask.b.rxstsqlvl= 1;
+        dwc_modify_reg32( DWC_REG_GINTMSK, gintmask.d32, 0);
+
+        /* Get the Status from the top of the FIFO */
+        status.d32 = dwc_read_reg32( DWC_REG_GRXSTSP);
+
+        //DBG("rx status: ep%d, pktsts: %d\n",status.b.epnum,status.b.pktsts);
+
+        /* Get pointer to EP structure */
+	if (status.b.epnum == 0)
+	{
+		ep = &g_dwc_eps[0];
+	}
+	else
+	{
+		ep = &g_dwc_eps[status.b.epnum];
+	}
+
+        switch (status.b.pktsts) {
+        case DWC_DSTS_GOUT_NAK:
+                DBG( "Global OUT NAK\n");
+                break;
+
+        case DWC_STS_DATA_UPDT:
+                DBG( "OUT Data Packet\n");
+                if (status.b.bcnt && ep->xfer_buff) {
+                        /** @todo NGS Check for buffer overflow? */
+                        dwc_otg_read_packet( ep->xfer_buff,status.b.bcnt);
+                        ep->xfer_count += status.b.bcnt;
+                        ep->xfer_buff += status.b.bcnt;
+                }
+                break;
+
+        case DWC_STS_XFER_COMP:
+                DBG("OUT Complete\n");
+                break;
+
+        case DWC_DSTS_SETUP_COMP:
+		   DBG("SETUP Complete\n");
+                break;
+
+        case DWC_DSTS_SETUP_UPDT:
+		   DBG("SETUP update\n");
+                dwc_otg_read_setup_packet( this_pcd.setup_pkt.d32);
+		   this_pcd.request_enable = 1;
+
+                ep->xfer_count += status.b.bcnt;
+                break;
+
+        default:
+                //DBG( "Invalid Packet Status (0x%0x)\n", status.b.pktsts);
+                break;
+
+        }
+
+        /* Enable the Rx Status Queue Level interrupt */
+        dwc_modify_reg32( DWC_REG_GINTMSK, 0, gintmask.d32);
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.rxstsqlvl = 1;
+	dwc_write_reg32 ( DWC_REG_GINTSTS, gintsts.d32);
+
+        return 1;
+}
+
+
+/**
+ * This interrupt occurs when the non-periodic Tx FIFO is half-empty.
+ * The active request is checked for the next packet to be loaded into
+ * the non-periodic Tx FIFO.
+ */
+int32_t dwc_otg_pcd_handle_np_tx_fifo_empty_intr(void)
+{
+        gnptxsts_data_t txstatus = {0};
+        gintsts_data_t gintsts;
+
+        int epnum = 0;
+        dwc_ep_t *ep = 0;
+        uint32_t len = 0;
+        int dwords;
+	 depctl_data_t depctl;
+
+	DBG("dwc_otg_pcd_handle_np_tx_fifo_empty_intr()\n");
+        /* Get the epnum from the IN Token Learning Queue. */
+	for (epnum=0; epnum < NUM_EP; epnum++)
+	{
+
+		ep = &g_dwc_eps[epnum];
+
+
+		/* IN endpoint ? */
+		if (epnum && !ep->is_in ) {
+			continue;
+	        }
+		depctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(epnum));
+	       if (depctl.b.epena != 1)
+			continue;
+
+		 if (ep->type == DWC_OTG_EP_TYPE_INTR && ep->xfer_len == 0)
+			continue;
+
+		 flush_cpu_cache();
+
+	        len = ep->xfer_len - ep->xfer_count;
+	        if (len > ep->maxpacket) {
+	                len = ep->maxpacket;
+	        }
+	        dwords = (len + 3)/4;
+
+		 //DBG("nptx: write data to fifo, ep%d , size %d\n",epnum,len);
+	        /* While there is space in the queue and space in the FIFO and
+	         * More data to tranfer, Write packets to the Tx FIFO */
+	        txstatus.d32 = dwc_read_reg32( DWC_REG_GNPTXSTS );
+	        while  (txstatus.b.nptxqspcavail > 0 &&
+	                txstatus.b.nptxfspcavail > dwords &&
+	                ep->xfer_count < ep->xfer_len) {
+
+			   flush_cpu_cache();
+
+			   /* Write the FIFO */
+	                dwc_otg_ep_write_packet( ep );
+
+	                len = ep->xfer_len - ep->xfer_count;
+	                if (len > ep->maxpacket) {
+	                        len = ep->maxpacket;
+	                }
+	                dwords = (len + 3)/4;
+			   flush_cpu_cache();
+			   //txstatus.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+#if 1
+			   /*
+				  TODO:  Remove these code.
+				  Because, if code break from "while"(Line427), an incomplete-in-trans will occour.
+				  Then the tansfer will break.
+			   */
+			   int retry = 50000;	//retry times
+			   while (retry--)
+			   {
+			       txstatus.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+				if(txstatus.b.nptxqspcavail > 0  || //txstatus.b.nptxfspcavail <= dwords ||
+					ep->xfer_count >= ep->xfer_len)
+					break;
+				else
+				{
+					flush_cpu_cache();
+				}
+
+			   }
+			   if (retry <= 0)
+			   {
+				//DWC_ERROR("TxFIFO FULL: Can't trans data to HOST !\n");
+			   }
+
+			   /* END todo */
+#endif
+	        }
+
+	}
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.nptxfempty = 1;
+	dwc_write_reg32 (DWC_REG_GINTSTS, gintsts.d32);
+
+        return 1;
+}
+/**
+ * Read the device status register and set the device speed in the
+ * data structure.
+ * Set up EP0 to receive SETUP packets by calling dwc_ep0_activate.
+ */
+int32_t dwc_otg_pcd_handle_enum_done_intr(void)
+{
+	gintsts_data_t gintsts;
+	gusbcfg_data_t gusbcfg;
+	//dsts_data_t dsts;
+	depctl_data_t diepctl;
+	depctl_data_t doepctl;
+	dctl_data_t dctl ={0};
+
+	DBG("SPEED ENUM\n");
+
+	/* Read the Device Status and Endpoint 0 Control registers */
+	//dsts.d32 = dwc_read_reg32(DWC_REG_DSTS);
+	diepctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(0) );
+	doepctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(0));
+
+	/* Set the MPS of the IN EP based on the enumeration speed */
+	diepctl.b.mps = DWC_DEP0CTL_MPS_64;
+	dwc_write_reg32(DWC_REG_IN_EP_REG(0) , diepctl.d32);
+
+	/* Enable OUT EP for receive */
+	doepctl.b.epena = 1;
+	dwc_write_reg32(DWC_REG_OUT_EP_REG(0), doepctl.d32);
+
+	dctl.b.cgnpinnak = 1;
+	dwc_modify_reg32(DWC_REG_DCTL, dctl.d32, dctl.d32);
+
+        if (this_pcd.ep0state == EP0_DISCONNECT) {
+                this_pcd.ep0state = EP0_IDLE;
+        } else if (this_pcd.ep0state == EP0_STALL) {
+                this_pcd.ep0state = EP0_IDLE;
+        }
+
+	 this_pcd.ep0state = EP0_IDLE;
+
+
+	/* Set USB turnaround time based on device speed and PHY interface. */
+	gusbcfg.d32 = dwc_read_reg32(DWC_REG_GUSBCFG);
+#if 0
+	if (_pcd->gadget.speed == USB_SPEED_HIGH) {
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_ULPI) {
+			/* ULPI interface */
+			gusbcfg.b.usbtrdtim = 9;
+		}
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_UTMI) {
+			/* UTMI+ interface */
+			if (GET_CORE_IF(_pcd)->core_params->phy_utmi_width == 16) {
+				gusbcfg.b.usbtrdtim = 5;
+			} else {
+				gusbcfg.b.usbtrdtim = 9;
+			}
+		}
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI) {
+			/* UTMI+  OR  ULPI interface */
+			if (gusbcfg.b.ulpi_utmi_sel == 1) {
+				/* ULPI interface */
+				gusbcfg.b.usbtrdtim = 9;
+			} else {
+				/* UTMI+ interface */
+				if (GET_CORE_IF(_pcd)->core_params->phy_utmi_width == 16) {
+					gusbcfg.b.usbtrdtim = 5;
+				} else {
+					gusbcfg.b.usbtrdtim = 9;
+				}
+			}
+		}
+	} else {
+		/* Full or low speed */
+		gusbcfg.b.usbtrdtim = 9;
+	}
+#else
+	/* Full or low speed */
+	gusbcfg.b.usbtrdtim = 5;
+#endif
+	dwc_write_reg32(DWC_REG_GUSBCFG, gusbcfg.d32);
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.enumdone = 1;
+	dwc_write_reg32(DWC_REG_GINTSTS,gintsts.d32 );
+	return 1;
+}
+///////////////////////////////////////////////////////////////////
+/**
+ * This interrupt indicates that an OUT EP has a pending Interrupt.
+ * The sequence for handling the OUT EP interrupt is shown below:
+ * -#	Read the Device All Endpoint Interrupt register
+ * -#	Repeat the following for each OUT EP interrupt bit set (from
+ *   	LSB to MSB).
+ * -#	Read the Device Endpoint Interrupt (DOEPINTn) register
+ * -#	If "Transfer Complete" call the request complete function
+ * -#	If "Endpoint Disabled" complete the EP disable procedure.
+ * -#	If "AHB Error Interrupt" log error
+ * -#	If "Setup Phase Done" process Setup Packet (See Standard USB
+ *   	Command Processing)
+ */
+static int32_t dwc_otg_pcd_handle_out_ep_intr(void)
+{
+#define CLEAR_OUT_EP_INTR(__epnum,__intr) \
+do { \
+        doepint_data_t doepint = { 0 }; \
+	doepint.b.__intr = 1; \
+	dwc_write_reg32(DWC_REG_OUT_EP_INTR(__epnum), \
+			doepint.d32); \
+} while (0)
+
+        uint32_t ep_intr;
+        doepint_data_t doepint = { 0 };
+        uint32_t epnum = 0;
+//	 uint32_t epnum_trans = 0;
+        gintsts_data_t gintsts;
+
+        DBG( "dwc_otg_pcd_handle_out_ep_intr()\n" );
+
+	/* Read in the device interrupt bits */
+        ep_intr = (dwc_read_reg32(DWC_REG_DAINT) &
+                dwc_read_reg32( DWC_REG_DAINTMSK));
+        ep_intr =( (ep_intr & 0xffff0000) >> 16);
+
+	/* Clear the OUTEPINT in GINTSTS */
+	gintsts.d32 = 0;
+	gintsts.b.outepintr = 1;
+	dwc_write_reg32 (DWC_REG_GINTSTS, gintsts.d32);
+	dwc_write_reg32(DWC_REG_DAINT, 0xFFFF0000 );
+
+        while ( ep_intr ) {
+            if (ep_intr&0x1) {
+                    doepint.d32 = (dwc_read_reg32( DWC_REG_OUT_EP_INTR(epnum)) &
+						dwc_read_reg32(DWC_REG_DOEPMSK));
+
+                    /* Transfer complete */
+			if ( doepint.b.xfercompl ) {
+				DBG("EP%d OUT Xfer Complete\n", epnum);
+
+				/* Clear the bit in DOEPINTn for this interrupt */
+				CLEAR_OUT_EP_INTR(epnum,xfercompl);
+
+				if (epnum == 0) {
+					handle_ep0( 0 );
+				} else {
+					complete_ep( epnum,0 );
+				}
+                    }
+                    /* Endpoint disable  */
+                    if ( doepint.b.epdisabled ) {
+                            DBG("EP%d OUT disabled\n", epnum);
+				/* Clear the bit in DOEPINTn for this interrupt */
+				CLEAR_OUT_EP_INTR(epnum,epdisabled);
+                    }
+                    /* AHB Error */
+                    if ( doepint.b.ahberr ) {
+                            DBG("EP%d OUT AHB Error\n", epnum);
+				CLEAR_OUT_EP_INTR(epnum,ahberr);
+                    }
+                    /* Setup Phase Done (contorl EPs) */
+                    if ( doepint.b.setup ) {
+                            handle_ep0( 0 );
+				CLEAR_OUT_EP_INTR(epnum,setup);
+                    }
+            }
+		epnum++;
+		ep_intr >>=1;
+        }
+
+        return 1;
+
+#undef CLEAR_OUT_EP_INTR
+}
+/**
+ * This interrupt indicates that an IN EP has a pending Interrupt.
+ * The sequence for handling the IN EP interrupt is shown below:
+ * -#	Read the Device All Endpoint Interrupt register
+ * -#	Repeat the following for each IN EP interrupt bit set (from
+ *   	LSB to MSB).
+ * -#	Read the Device Endpoint Interrupt (DIEPINTn) register
+ * -#	If "Transfer Complete" call the request complete function
+ * -#	If "Endpoint Disabled" complete the EP disable procedure.
+ * -#	If "AHB Error Interrupt" log error
+ * -#	If "Time-out Handshake" log error
+ * -#	If "IN Token Received when TxFIFO Empty" write packet to Tx
+ *   	FIFO.
+ * -#	If "IN Token EP Mismatch" (disable, this is handled by EP
+ *   	Mismatch Interrupt)
+ */
+static int32_t dwc_otg_pcd_handle_in_ep_intr(void)
+{
+#define CLEAR_IN_EP_INTR(__epnum,__intr) \
+do { \
+        diepint_data_t diepint = { 0 }; \
+	diepint.b.__intr = 1; \
+	dwc_write_reg32(DWC_REG_IN_EP_INTR(__epnum), \
+			diepint.d32); \
+} while (0)
+
+        diepint_data_t diepint = { 0 };
+//        depctl_data_t diepctl = { 0 };
+        uint32_t ep_intr;
+        uint32_t epnum = 0;
+        gintmsk_data_t intr_mask = {0};
+        gintsts_data_t gintsts;
+
+	 DBG( "dwc_otg_pcd_handle_in_ep_intr()\n" );
+
+	/* Read in the device interrupt bits */
+        ep_intr = (dwc_read_reg32(DWC_REG_DAINT) &
+                dwc_read_reg32( DWC_REG_DAINTMSK));
+        ep_intr =( (ep_intr & 0xffff) );
+
+
+	/* Clear the INEPINT in GINTSTS */
+	/* Clear all the interrupt bits for all IN endpoints in DAINT */
+	gintsts.d32 = 0;
+	gintsts.b.inepint = 1;
+	dwc_write_reg32 (DWC_REG_GINTSTS, gintsts.d32);
+	dwc_write_reg32(DWC_REG_DAINT, 0xFFFF );
+	flush_cpu_cache();
+
+	/* Service the Device IN interrupts for each endpoint */
+        while ( ep_intr ) {
+                if (ep_intr&0x1) {
+
+                        diepint.d32 = (dwc_read_reg32( DWC_REG_IN_EP_INTR(epnum)) &
+									dwc_read_reg32(DWC_REG_DAINTMSK));
+                        /* Transfer complete */
+                        if ( diepint.b.xfercompl ) {
+
+
+                                /* Disable the NP Tx FIFO Empty
+                                 * Interrrupt */
+                                intr_mask.b.nptxfempty = 1;
+                                dwc_modify_reg32( DWC_REG_GINTMSK, intr_mask.d32, 0);
+
+                                /* Clear the bit in DIEPINTn for this interrupt */
+                                CLEAR_IN_EP_INTR(epnum,xfercompl);
+
+                                /* Complete the transfer */
+					if (epnum == 0) {
+						handle_ep0( 0 );
+					} else {
+						complete_ep( epnum,1 );
+					}
+                        }
+                        /* Endpoint disable  */
+                        if ( diepint.b.epdisabled ) {
+                                handle_in_ep_disable_intr( epnum );
+
+                                /* Clear the bit in DIEPINTn for this interrupt */
+                                CLEAR_IN_EP_INTR(epnum,epdisabled);
+                        }
+                        /* AHB Error */
+                        if ( diepint.b.ahberr ) {
+				/* Clear the bit in DIEPINTn for this interrupt */
+				CLEAR_IN_EP_INTR(epnum,ahberr);
+                        }
+                        /* TimeOUT Handshake (non-ISOC IN EPs) */
+                        if ( diepint.b.timeout ) {
+                                handle_in_ep_timeout_intr( epnum );
+
+				CLEAR_IN_EP_INTR(epnum,timeout);
+                        }
+                        /** IN Token received with TxF Empty */
+                        if (diepint.b.intktxfemp) {
+#if 0
+                                if (!ep->stopped && epnum != 0) {
+                                        diepmsk_data_t diepmsk = { 0};
+                                        diepmsk.b.intktxfemp = 1;
+                                        dwc_modify_reg32( &dev_if->dev_global_regs->diepmsk, diepmsk.d32, 0 );
+                                        start_next_request(ep);
+                                }
+#endif
+				CLEAR_IN_EP_INTR(epnum,intktxfemp);
+                        }
+                        /** IN Token Received with EP mismatch */
+                        if (diepint.b.intknepmis) {
+				CLEAR_IN_EP_INTR(epnum,intknepmis);
+                        }
+                        /** IN Endpoint NAK Effective */
+                        if (diepint.b.inepnakeff) {
+				CLEAR_IN_EP_INTR(epnum,inepnakeff);
+                        }
+                }
+                epnum++;
+                ep_intr >>=1;
+        }
+
+        return 1;
+
+#undef CLEAR_IN_EP_INTR
+}
+/**
+ * This function configures EP0 to receive SETUP packets.
+ *
+ * @todo NGS: Update the comments from the HW FS.
+ *
+ *  -# Program the following fields in the endpoint specific registers
+ *  for Control OUT EP 0, in order to receive a setup packet
+ * 	- DOEPTSIZ0.Packet Count = 3 (To receive up to 3 back to back
+ * 	  setup packets)
+ *	- DOEPTSIZE0.Transfer Size = 24 Bytes (To receive up to 3 back
+ *	  to back setup packets)
+ *      - In DMA mode, DOEPDMA0 Register with a memory address to
+ *        store any setup packets received
+ *
+ */
+static void ep0_out_start(void)
+{
+	deptsiz0_data_t doeptsize0 = { 0};
+	depctl_data_t doepctl = { 0 };
+
+	doeptsize0.b.supcnt = 3;
+	doeptsize0.b.pktcnt = 1;
+	doeptsize0.b.xfersize = 8*3;
+
+	DBG("ep0_out_start()\n");
+	dwc_write_reg32( DWC_REG_OUT_EP_TSIZE(0),doeptsize0.d32 );
+
+
+	// EP enable
+	doepctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(0));
+	doepctl.b.epena = 1;
+
+	doepctl.d32 = 0x80008000;
+	dwc_write_reg32(DWC_REG_OUT_EP_REG(0),doepctl.d32);
+
+	flush_cpu_cache();
+}
+/**
+ * This interrupt occurs when a USB Reset is detected.  When the USB
+ * Reset Interrupt occurs the device state is set to DEFAULT and the
+ * EP0 state is set to IDLE.
+ *  -#	Set the NAK bit for all OUT endpoints (DOEPCTLn.SNAK = 1)
+ *  -#	Unmask the following interrupt bits
+ *  	- DAINTMSK.INEP0 = 1 (Control 0 IN endpoint)
+ * 	- DAINTMSK.OUTEP0 = 1 (Control 0 OUT endpoint)
+ * 	- DOEPMSK.SETUP = 1
+ * 	- DOEPMSK.XferCompl = 1
+ * 	- DIEPMSK.XferCompl = 1
+ *	- DIEPMSK.TimeOut = 1
+ *  -# Program the following fields in the endpoint specific registers
+ *  for Control OUT EP 0, in order to receive a setup packet
+ * 	- DOEPTSIZ0.Packet Count = 3 (To receive up to 3 back to back
+ * 	  setup packets)
+ *	- DOEPTSIZE0.Transfer Size = 24 Bytes (To receive up to 3 back
+ *	  to back setup packets)
+ *      - In DMA mode, DOEPDMA0 Register with a memory address to
+ *        store any setup packets received
+ * At this point, all the required initialization, except for enabling
+ * the control 0 OUT endpoint is done, for receiving SETUP packets.
+ */
+int32_t dwc_otg_pcd_handle_usb_reset_intr(void)
+{
+
+        depctl_data_t doepctl = { 0};
+        daint_data_t daintmsk = { 0};
+        doepmsk_data_t doepmsk = { 0};
+        diepmsk_data_t diepmsk = { 0};
+        dcfg_data_t dcfg = { 0 };
+        depctl_data_t diepctl = { 0};
+        depctl_data_t diepctl_rd = { 0};
+        grstctl_t resetctl = { 0 };
+        dctl_data_t dctl = { 0 };
+        int i = 0;
+        gintsts_data_t gintsts;
+
+
+        DBG("\nUSB RESET\n");
+
+
+        /* Clear the Remote Wakeup Signalling */
+        dctl.b.rmtwkupsig = 1;
+        dwc_modify_reg32( DWC_REG_DCTL,dctl.d32, 0 );
+
+        /* Disable all active IN EPs */
+        diepctl.b.epdis = 1;
+        diepctl.b.snak = 1;
+        for (i=0; i < NUM_EP; i++) {
+                diepctl_rd.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(i));
+                if (diepctl_rd.b.epena) {
+                        dwc_write_reg32(DWC_REG_IN_EP_REG(i),diepctl.d32 );
+                }
+        }
+
+        /* Set NAK for all OUT EPs */
+        doepctl.b.snak = 1;
+        for (i=0; i < NUM_EP; i++) {
+                dwc_write_reg32(DWC_REG_OUT_EP_REG(i), doepctl.d32 );
+        }
+
+        /* Flush the NP Tx FIFO */
+        dwc_otg_flush_tx_fifo( 0 );
+        /* Flush the Learning Queue */
+        resetctl.b.intknqflsh = 1;
+        dwc_write_reg32( DWC_REG_GRSTCTL, resetctl.d32);
+
+        daintmsk.b.inep0 = 1;
+        daintmsk.b.outep0 = 1;
+        dwc_write_reg32( DWC_REG_DAINTMSK, daintmsk.d32 );
+
+        doepmsk.b.setup = 1;
+        doepmsk.b.xfercompl = 1;
+        doepmsk.b.ahberr = 1;
+        doepmsk.b.epdisabled = 1;
+        dwc_write_reg32( DWC_REG_DOEPMSK, doepmsk.d32 );
+
+        diepmsk.b.xfercompl = 1;
+        diepmsk.b.timeout = 1;
+        diepmsk.b.epdisabled = 1;
+        diepmsk.b.ahberr = 1;
+        dwc_write_reg32( DWC_REG_DIEPMSK, diepmsk.d32 );
+        /* Reset Device Address */
+        dcfg.d32 = dwc_read_reg32( DWC_REG_DCFG);
+        dcfg.b.devaddr = 0;
+        dwc_write_reg32( DWC_REG_DCFG, dcfg.d32);
+
+        /* setup EP0 to receive SETUP packets */
+        ep0_out_start();
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.usbreset = 1;
+	dwc_write_reg32 ( DWC_REG_GINTSTS, gintsts.d32);
+
+	flush_cpu_cache();
+        return 1;
+}
+
+
+///////////////////////////////////////////////////////////////////
+int dwc_common_irq(void)
+{
+	gotgint_data_t gotgint;
+
+	gotgint.d32 = dwc_read_reg32(DWC_REG_GOTGINT);
+	if (gotgint.d32 == 0)
+		return 0;
+//	if(gotgint.b.sesreqsucstschng)
+//	{
+//		DBG("Session Request Success Status Change\n");
+//	}
+	dwc_write_reg32(DWC_REG_GOTGINT,gotgint.d32); // clear intr
+
+
+	return 0;
+}
+
+int dwc_pcd_irq(void)
+{
+	gintsts_data_t  gintr_status;
+	gintsts_data_t  gintr_msk;
+
+	gintr_msk.d32 = dwc_read_reg32(DWC_REG_GINTMSK);
+	gintr_status.d32 = dwc_read_reg32(DWC_REG_GINTSTS);
+	if ((gintr_status.d32 & gintr_msk.d32)== 0)
+		return 0;
+
+	//DBG("irq gintmsk:  0x%08x\n",gintr_msk.d32);
+	//DBG("irq gintrsts: 0x%08x\n",gintr_status.d32);
+
+	gintr_status.d32 = gintr_status.d32 & gintr_msk.d32;
+	//DBG("irq gintmsk & gintrsts = 0x%08x\n",gintr_status.d32);
+
+	if (gintr_status.b.rxstsqlvl) {
+	    dwc_otg_pcd_handle_rx_status_q_level_intr();
+	}
+	if (gintr_status.b.nptxfempty) {
+	    dwc_otg_pcd_handle_np_tx_fifo_empty_intr( );
+	}
+
+	if (gintr_status.b.usbreset) {
+	   dwc_otg_pcd_handle_usb_reset_intr( );
+	}
+	if (gintr_status.b.enumdone) {
+	    dwc_otg_pcd_handle_enum_done_intr();
+	}
+	if (gintr_status.b.epmismatch) {
+	    //dwc_otg_pcd_handle_ep_mismatch_intr( core_if );
+	}
+	if (gintr_status.b.inepint) {
+	    dwc_otg_pcd_handle_in_ep_intr();
+	}
+	if (gintr_status.b.outepintr) {
+	    dwc_otg_pcd_handle_out_ep_intr( );
+	}
+
+	dwc_write_reg32(DWC_REG_GINTSTS,gintr_status.d32);
+	flush_cpu_cache();
+	return 0;
+}
+
+
+
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.h b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.h
new file mode 100644
index 0000000..ae9cabb
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.h
@@ -0,0 +1,41 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/dwc_pcd_irq.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __DWC_PCD_IRQ_H__
+#define __DWC_PCD_IRQ_H__
+
+int dwc_pcd_irq(void);
+int dwc_otg_irq(void);
+
+/**
+ * States of EP0.
+ */
+typedef enum ep0_state {
+	EP0_DISCONNECT,		/* no host */
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_STATUS,
+	EP0_STALL,
+} ep0state_e;
+
+extern int dwc_common_irq(void);
+#endif
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/platform.c b/drivers/usb/gadget/aml_tiny_usbtool/platform.c
new file mode 100644
index 0000000..c389eae
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/platform.c
@@ -0,0 +1,165 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/platform.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "platform.h"
+#include <asm/arch/timer.h>
+
+#define PREI_USB_PHY_A_REG_BASE       0xC0000000  //0x2100
+#define PREI_USB_PHY_B_REG_BASE       0xC0000020	//0X2108
+
+#ifdef __USE_PORT_B
+#define PREI_USB_PHY_REG_BASE   PREI_USB_PHY_B_REG_BASE
+#else
+#define PREI_USB_PHY_REG_BASE   PREI_USB_PHY_A_REG_BASE
+#endif
+//#define P_RESET1_REGISTER						   (volatile unsigned long *)0xc1104408
+#define P_RESET1_REGISTER_USB                           (volatile unsigned long *)0xc1104408
+
+#define USB_CLK_SEL_XTAL				0
+#define USB_CLK_SEL_XTAL_DIV_2	1
+#define USB_CLK_SEL_DDR_PLL			2
+#define USB_CLK_SEL_MPLL_OUT0		3
+#define USB_CLK_SEL_MPLL_OUT1		4
+#define USB_CLK_SEL_MPLL_OUT2		5
+#define USB_CLK_SEL_FCLK_DIV2		6
+#define USB_CLK_SEL_FCLK_DIV3		7
+/* typedef struct usb_aml_regs {
+	 volatile uint32_t config;
+	 volatile uint32_t ctrl;
+	 volatile uint32_t endp_intr;
+	 volatile uint32_t adp_bc;
+	 volatile uint32_t dbg_uart;
+	 volatile uint32_t test;
+	 volatile uint32_t tune;
+ } usb_aml_regs_t;
+ typedef union usb_config_data {*/
+	 /** raw register data */
+/*	 uint32_t d32;*/
+	 /** register bits */
+/*	 struct {
+		 unsigned clk_en:1;
+		 unsigned clk_sel:3;
+		 unsigned clk_div:7;
+		 unsigned reserved:20;
+		 unsigned test_trig:1;
+	 } b;
+ } usb_config_data_t;
+ typedef union usb_ctrl_data {*/
+	 /** raw register data */
+/*	 uint32_t d32;*/
+	 /** register bits */
+/*	 struct {
+		 unsigned soft_prst:1;
+		 unsigned soft_hreset:1;
+		 unsigned ss_scaledown_mode:2;
+		 unsigned clk_det_rst:1;
+		 unsigned intr_sel:1;
+		 unsigned reserved:2;
+		 unsigned clk_detected:1;
+		 unsigned sof_sent_rcvd_tgl:1;
+		 unsigned sof_toggle_out:1;
+		 unsigned not_used:4;
+		 unsigned por:1;
+		 unsigned sleepm:1;
+		 unsigned txbitstuffennh:1;
+		 unsigned txbitstuffenn:1;
+		 unsigned commononn:1;
+		 unsigned refclksel:2;
+		 unsigned fsel:3;
+		 unsigned portreset:1;
+		 unsigned thread_id:6;
+	 } b;
+ } usb_ctrl_data_t;*/
+/*
+	cfg = 0 : EXT clock
+	cfg = 1 : INT clock
+*/
+static void set_usb_phy_config(int cfg)
+{
+
+	const int time_dly = 500;
+	usb_aml_regs_t * usb_aml_regs = (usb_aml_regs_t * )PREI_USB_PHY_REG_BASE;
+	usb_config_data_t config;
+	usb_ctrl_data_t control;
+
+	/*CLK_GATE_ON(USB0);*/
+	//if(!IS_CLK_GATE_ON(USB0)){
+	//	SET_CBUS_REG_MASK(GCLK_REG_USB0, GCLK_MASK_USB0);
+	//}
+	/*printf("%s %d\n", __func__, __LINE__);*/
+	cfg = cfg;//avoid compiler warning
+	/**P_RESET1_REGISTER = (1<<2);//usb reset*/
+	*P_RESET1_REGISTER_USB = (1<<2);//usb reset
+	_udelay(time_dly);//by Sam: delay after reset
+
+	config.d32 = usb_aml_regs->config;
+
+//    config.b.clk_sel    = 0;
+//    config.b.clk_div    = 1;
+//    config.b.clk_32k_alt_sel = 1;
+	usb_aml_regs->config = config.d32;
+
+	control.d32 = usb_aml_regs->ctrl;
+	control.b.fsel = 5;
+	control.b.por = 1;
+	usb_aml_regs->ctrl = control.d32;
+	_udelay(time_dly);
+
+	control.b.por = 0;
+	usb_aml_regs->ctrl = control.d32;
+	_udelay(time_dly);//by Sam: delay 0.5s to wait usb clam down
+
+	control.d32 = usb_aml_regs->ctrl;
+	if (!control.b.clk_detected) {
+		printf("Error, usb phy clock not detected!\n");
+	}
+
+	return;
+}
+
+#if 0
+int chip_watchdog(void)
+{
+	watchdog_clear();
+	return 0;
+};
+#endif
+#if 1
+void usb_memcpy(char * dst,char * src,int len)
+{
+	 while (len--)
+	 {
+		 *(unsigned char*)dst = *(unsigned char*)src;
+		 dst++;
+		 src++;
+	 }
+ }
+void usb_memcpy_32bits(int *dst,int *src,int len)
+{
+	while (len--)
+	{
+		*dst = *src;
+		dst++;
+		src++;
+	}
+}
+#endif
+
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/platform.h b/drivers/usb/gadget/aml_tiny_usbtool/platform.h
new file mode 100644
index 0000000..28dc84b
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/platform.h
@@ -0,0 +1,212 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/platform.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __PLATFORM_H__
+#define __PLATFORM_H__
+
+//#include "romboot.h"
+//Elvis Fool
+//#pragma Offwarn(88)  /* disable "Expression has no side-effects" print debug info*/
+
+#if 0
+
+/* ISO C Standard Definitions */
+typedef char               int8_t;
+typedef	short int          int16_t;
+typedef	int                int32_t;
+typedef	long               int64_t;
+typedef	unsigned char      uint8_t;
+typedef	unsigned short int uint16_t;
+typedef	unsigned int       uint32_t;
+typedef	unsigned long      uint64_t;
+
+typedef unsigned   char    u8_t;
+typedef signed     char    s8_t;
+typedef unsigned   short   u16_t;
+typedef signed     short   s16_t;
+typedef unsigned   int     u32_t;
+typedef signed     int     s32_t;
+typedef unsigned   long    u64_t;
+typedef signed     long    s64_t;
+
+/* Linux definitions */
+typedef u8_t     __u8;
+typedef s8_t     __s8;
+typedef u16_t    __u16;
+typedef s16_t    __s16;
+typedef u32_t    __u32;
+typedef s32_t    __s32;
+typedef u64_t    __u64;
+typedef s64_t    __s64;
+
+typedef u8_t     u_int8_t;
+typedef u16_t    u_int16_t;
+typedef u32_t    u_int32_t;
+typedef u64_t    u_int64_t;
+
+typedef s8_t     s8;
+typedef u8_t     u8;
+typedef s16_t    s16;
+typedef u16_t    u16;
+typedef s32_t    s32;
+typedef u32_t    u32;
+typedef u64_t    u64;
+
+typedef __u16    __le16;
+typedef __u16    __be16;
+typedef __u32    __le32;
+typedef __u32    __be32;
+typedef __u64    __le64;
+typedef __u64    __be64;
+#endif
+
+/* A3,CS2,M3 chip, PORT_A is OTG, work as ROM Boot port */
+#ifdef __USE_PORT_B
+#define PORT_REG_OFFSET   0x80000
+#else
+#define PORT_REG_OFFSET   0
+#endif
+
+
+/*M3*/
+#define DWC_REG_BASE  (0xC9000000 + PORT_REG_OFFSET)
+#define PERI_BASE_ADDR               0xc1100000
+#define ISABASE                      0x01000000
+
+#define PREI_USB_PHY_REG              0xc0000000 //0xC1108400
+
+#define PREI_USB_PHY_A_REG3           0xc0000000
+#define PREI_USB_PHY_B_REG4           0xc0000020
+
+#define PREI_USB_PHY_A_POR      (1 << 0)
+#define PREI_USB_PHY_B_POR      (1 << 1)
+#define PREI_USB_PHY_CLK_SEL    (7 << 5) // changed from A1H
+#define PREI_USB_PHY_CLK_GATE 	(1 << 8)
+#define PREI_USB_PHY_B_AHB_RSET     (1 << 11)
+#define PREI_USB_PHY_B_CLK_RSET     (1 << 12)
+#define PREI_USB_PHY_B_PLL_RSET     (1 << 13)
+#define PREI_USB_PHY_A_AHB_RSET     (1 << 17)
+#define PREI_USB_PHY_A_CLK_RSET     (1 << 18)
+#define PREI_USB_PHY_A_PLL_RSET     (1 << 19)
+#define PREI_USB_PHY_A_DRV_VBUS     (1 << 20)
+#define PREI_USB_PHY_B_DRV_VBUS			(1 << 21)
+#define PREI_USB_PHY_B_CLK_DETECT   (1 << 22)
+#define PREI_USB_PHY_CLK_DIV        (0x7f << 24)
+#define PREI_USB_PHY_A_CLK_DETECT   (1 << 31)
+
+#define PREI_USB_PHY_A_REG3_IDDIG_OVR	(1 << 23)
+#define PREI_USB_PHY_A_REG3_IDDIG_VAL	(1 << 24)
+
+#define PREI_USB_PHY_B_REG4_IDDIG_OVR	(1 << 23)
+#define PREI_USB_PHY_B_REG4_IDDIG_VAL	(1 << 24)
+
+
+
+/***********************************************/
+#define WRITE_PERI_REG(reg, val) *(volatile unsigned *)(PERI_BASE_ADDR + ((reg)<<2)) = (val)
+#define READ_PERI_REG(reg) (*(volatile unsigned *)(PERI_BASE_ADDR + ((reg)<<2)))
+
+#define CLEAR_PERIPHS_REG_BITS(reg, mask) WRITE_PERI_REG(reg, (READ_PERI_REG(reg)&(~(mask))))
+#define SET_PERIPHS_REG_BITS(reg, mask)   WRITE_PERI_REG(reg, (READ_PERI_REG(reg)|(mask)))
+
+#define WRITE_ISA_REG(reg, val) *(volatile unsigned *)(ISABASE + (reg)) = (val)
+#define READ_ISA_REG(reg) (*(volatile unsigned *)(ISABASE + (reg)))
+
+#define CLEAR_ISA_REG_MASK(reg, mask) WRITE_ISA_REG(reg, (READ_ISA_REG(reg)&(~mask)))
+#define SET_ISA_REG_MASK(reg, mask)   WRITE_ISA_REG(reg, (READ_ISA_REG(reg)|(mask)))
+/***********************************************/
+
+
+
+
+
+#define IREG_TIMER_E_COUNT            0x2655
+
+
+#define flush_cpu_cache()
+
+
+#define dwc_write_reg32(x, v) 	(*(volatile uint32_t *)(unsigned long long)(x + DWC_REG_BASE))=v
+#define dwc_read_reg32(x) (*(volatile uint32_t*)(unsigned long long)(x + DWC_REG_BASE))
+// void dwc_modify_reg32( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+#define dwc_modify_reg32(x, c, s) 	(*(volatile uint32_t *)(unsigned long long)(x + DWC_REG_BASE))=( ((dwc_read_reg32(x)) & (~c)) | (s))
+
+//#define __constant_cpu_to_le16(x) (x)
+//#define __constant_cpu_to_le32(x) (x)
+//#define cpu_to_le16(x)      (x)
+//#define  cpu_to_le32(x)     (x)
+//#define le16_to_cpu(x)      (x)
+//#define le32_to_cpu(x)      (x)
+#define get_unaligned_16(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8))
+#define get_unaligned_32(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+#define get_unaligned(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+
+#ifndef max
+#define max(a, b)	(((a) > (b))? (a): (b))
+#endif
+#ifndef min
+#define min(a, b)	(((a) < (b))? (a): (b))
+#endif
+
+#define EXT_CLOCK	0
+#define INT_CLOCK	1
+
+
+// 32 bit TimerE, 1us
+#define USB_ROM_CONN_TIMEOUT		5*1000*1000  //us (5s timeout,)
+
+
+/* Meet with spec */
+#define USB_ROM_VER_MAJOR	0
+#define USB_ROM_STAGE_MAJOR	0
+#define USB_ROM_STAGE_MINOR	16		// IPL = 0,	SPL = 8, TPL = 16
+
+#ifdef CONFIG_M6
+#define USB_ROM_VER_MINOR	8				// SPEC Version
+#else
+#define USB_ROM_VER_MINOR	7				// SPEC Version
+#endif
+
+#if 1
+#define PRINTF(x...)	do{}while(0)
+#else
+#define PRINTF(x...) printf(x)
+#endif
+
+#define ERR(x...) PRINTF(x)
+#define DBG(x...) PRINTF(x)
+#define USB_ERR(x...)	PRINTF(x)
+#define USB_DBG(x...) PRINTF(x)
+
+
+static void set_usb_phy_config(int cfg);
+void usb_parameter_init(int time_out);
+int chip_utimer_set(int val);
+int chip_watchdog(void);
+//#define udelay __udelay
+//#define wait_ms(a) _udelay(a*1000);
+int update_utime(void);
+int get_utime(void);
+//int chip_watchdog(void);
+//#define usb_memcpy(dst,src,len) rom_memcpy((unsigned)src,(unsigned)dst,(unsigned)len)
+//#define usb_memcpy_32bits(dst,src,len) rom_memcpy((unsigned)src,(unsigned)dst,(unsigned)len)
+
+#endif
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/usb_boot.c b/drivers/usb/gadget/aml_tiny_usbtool/usb_boot.c
new file mode 100644
index 0000000..4e3cf22
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/usb_boot.c
@@ -0,0 +1,76 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/usb_boot.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "usb_boot.h"
+#include "usb_pcd.h"
+
+void set_usb_phy_config(void)
+{
+    int time_dly = 500;
+    usb_aml_regs_t * usb_aml_regs = (usb_aml_regs_t * )PREI_USB_PHY_REG_BASE;
+    usb_config_data_t config;
+    usb_ctrl_data_t control;
+
+    *P_RESET1_REGISTER = (1<<2);//usb reset
+
+    // select rtc 32k
+    config.d32 = usb_aml_regs->config;
+
+    config.b.clk_32k_alt_sel= 1;
+    usb_aml_regs->config = config.d32;
+
+    // select 24MHz reference
+    control.d32 = usb_aml_regs->ctrl;
+
+    control.b.fsel = 5;
+    control.b.por = 1;
+    usb_aml_regs->ctrl = control.d32;
+
+    _udelay(time_dly);
+    control.b.por = 0;
+    usb_aml_regs->ctrl = control.d32;
+
+    _udelay(time_dly);
+}
+
+// static const char __attribute__((aligned(4))) usb_msg[] = "enter usb boot";
+
+int usb_boot(int timeout_type)
+{
+    C_ROM_BOOT_DEBUG->usb_boot_cnt++;
+    // serial_puts( usb_msg );
+    set_usb_phy_config();
+
+    usb_parameter_init(timeout_type);
+
+    if (usb_pcd_init())
+        return 0;
+
+    while (1) {
+        watchdog_clear();
+        if (usb_pcd_irq())
+            break;
+    }
+
+    return 0;
+}
+
+
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/usb_boot.h b/drivers/usb/gadget/aml_tiny_usbtool/usb_boot.h
new file mode 100644
index 0000000..426f02b
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/usb_boot.h
@@ -0,0 +1,370 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/usb_boot.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __USB_BOOT_H__
+#define __USB_BOOT_H__
+#include <asm/arch/romboot.h>
+
+#define USB_DEBUG 1
+/* ISO C Standard Definitions */
+typedef unsigned   char    u8_t;
+typedef signed     char    s8_t;
+typedef unsigned   short   u16_t;
+typedef signed     short   s16_t;
+typedef unsigned   int     u32_t;
+typedef signed     int     s32_t;
+#if 0
+typedef unsigned   long  long  u64_t;
+typedef signed     long   long s64_t;
+#else
+typedef unsigned   long  u64_t;
+typedef signed     long  s64_t;
+#endif
+/* Linux definitions */
+typedef u8_t     __u8;
+typedef s8_t     __s8;
+typedef u16_t    __u16;
+typedef s16_t    __s16;
+typedef u32_t    __u32;
+typedef s32_t    __s32;
+//typedef u64_t    __u64;
+//typedef s64_t    __s64;
+
+typedef u8_t     u_int8_t;
+typedef u16_t    u_int16_t;
+typedef u32_t    u_int32_t;
+//typedef u64_t    u_int64_t;
+
+typedef s8_t     s8;
+typedef u8_t     u8;
+typedef s16_t    s16;
+typedef u16_t    u16;
+typedef s32_t    s32;
+typedef u32_t    u32;
+//typedef u64_t    u64;
+
+typedef __u16    __le16;
+typedef __u16    __be16;
+typedef __u32    __le32;
+typedef __u32    __be32;
+typedef __u64    __le64;
+typedef __u64    __be64;
+
+
+/* A3,CS2,M3,M6 chip, PORT_A is OTG, work as ROM Boot port */
+#ifdef __USE_PORT_B
+#define PORT_REG_OFFSET   0x80000
+#else
+#define PORT_REG_OFFSET   0
+#endif
+
+
+/*M6*/
+#define DWC_REG_BASE  			(0xC9000000 + PORT_REG_OFFSET)
+//#define PERI_BASE_ADDR               0xC1100000
+#define ISABASE                      0x01000000
+
+#define PREI_USB_PHY_A_REG_BASE       0xC0000000
+#define PREI_USB_PHY_B_REG_BASE       0xC0000020
+
+#ifdef __USE_PORT_B
+#define PREI_USB_PHY_REG_BASE   PREI_USB_PHY_B_REG_BASE
+#else
+#define PREI_USB_PHY_REG_BASE   PREI_USB_PHY_A_REG_BASE
+#endif
+
+typedef struct usb_aml_regs {
+    volatile uint32_t config;
+    volatile uint32_t ctrl;
+    volatile uint32_t endp_intr;
+    volatile uint32_t adp_bc;
+    volatile uint32_t dbg_uart;
+    volatile uint32_t test;
+    volatile uint32_t tune;
+} usb_aml_regs_t;
+
+typedef union usb_config_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned clk_en:1;
+        unsigned clk_sel:3;
+        unsigned clk_div:7;
+        unsigned reserved0:4;
+        unsigned clk_32k_alt_sel:1;
+        unsigned reserved1:15;
+        unsigned test_trig:1;
+    } b;
+} usb_config_data_t;
+
+typedef union usb_ctrl_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned soft_prst:1;
+        unsigned soft_hreset:1;
+        unsigned ss_scaledown_mode:2;
+        unsigned clk_det_rst:1;
+        unsigned intr_sel:1;
+        unsigned dbnce_fltr_bypass:1;
+        unsigned reserved:1;
+        unsigned clk_detected:1;
+        unsigned sof_sent_rcvd_tgl:1;
+        unsigned sof_toggle_out:1;
+        unsigned not_used:4;
+        unsigned por:1;
+        unsigned sleepm:1;
+        unsigned txbitstuffennh:1;
+        unsigned txbitstuffenn:1;
+        unsigned commononn:1;
+        unsigned refclksel:2;
+        unsigned fsel:3;
+        unsigned portreset:1;
+        unsigned thread_id:6;
+    } b;
+} usb_ctrl_data_t;
+
+typedef union usb_endp_intr_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned int0:1;
+        unsigned int1:1;
+        unsigned int2:1;
+        unsigned int3:1;
+        unsigned int4:1;
+        unsigned int5:1;
+        unsigned int6:1;
+        unsigned int7:1;
+        unsigned int8:1;
+        unsigned int9:1;
+        unsigned int10:1;
+        unsigned int11:1;
+        unsigned int12:1;
+        unsigned int13:1;
+        unsigned int14:1;
+        unsigned int15:1;
+        unsigned int16:1;
+        unsigned int17:1;
+        unsigned int18:1;
+        unsigned int19:1;
+        unsigned int20:1;
+        unsigned int21:1;
+        unsigned int22:1;
+        unsigned int23:1;
+        unsigned int24:1;
+        unsigned int25:1;
+        unsigned int26:1;
+        unsigned int27:1;
+        unsigned int28:1;
+        unsigned int29:1;
+        unsigned int30:1;
+        unsigned int31:1;
+    } b;
+} usb_endp_intr_data_t;
+
+typedef union usb_adp_bc_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned vbusvldextsel:1;
+        unsigned vbusvldext:1;
+        unsigned otgdisable:1;
+        unsigned idpullup:1;
+        unsigned drvvbus:1;
+        unsigned adp_prb_en:1;
+        unsigned adp_dischrg:1;
+        unsigned adp_chrg:1;
+        unsigned sessend:1;
+        unsigned device_sess_vld:1;
+        unsigned bvalid:1;
+        unsigned avalid:1;
+        unsigned iddig:1;
+        unsigned vbusvalid:1;
+        unsigned adp_probe:1;
+        unsigned adp_sense:1;
+        unsigned aca_enable:1;
+        unsigned dcd_enable:1;
+        unsigned vdatdetenb:1;
+        unsigned vdatsrcenb:1;
+        unsigned chrgsel:1;
+        unsigned chg_det:1;
+        unsigned aca_pin_range_c:1;
+        unsigned aca_pin_range_b:1;
+        unsigned aca_pin_range_a:1;
+        unsigned aca_pin_gnd:1;
+        unsigned aca_pin_float:1;
+        unsigned not_used:5;
+    } b;
+} usb_adp_bc_data_t;
+
+typedef union usb_dbg_uart_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned bypass_sel:1;
+        unsigned bypass_dm_en:1;
+        unsigned bypass_dp_en:1;
+        unsigned bypass_dm_data:1;
+        unsigned bypass_dp_data:1;
+        unsigned fsv_minus:1;
+        unsigned fsv_plus:1;
+        unsigned burn_in_test:1;
+        unsigned loopbackenb:1;
+        unsigned set_iddq:1;
+        unsigned ate_reset:1;
+        unsigned reserved:4;
+        unsigned not_used:17;
+    } b;
+} usb_dbg_uart_data_t;
+
+typedef union phy_test_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned data_in:4;
+        unsigned data_in_en:4;
+        unsigned addr:4;
+        unsigned data_out_sel:1;
+        unsigned clk:1;
+        unsigned vatestenb:2;
+        unsigned data_out:4;
+        unsigned not_used:12;
+    } b;
+} phy_test_data_t;
+
+typedef union phy_tune_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tx_res_tune:2;
+        unsigned tx_hsxv_tune:2;
+        unsigned tx_vref_tune:4;
+        unsigned tx_rise_tune:2;
+        unsigned tx_preemp_pulse_tune:1;
+        unsigned tx_preemp_amp_tune:2;
+        unsigned tx_fsls_tune:4;
+        unsigned sqrx_tune:3;
+        unsigned otg_tune:3;
+        unsigned comp_dis_tune:3;
+        unsigned not_used:6;
+    } b;
+} phy_tune_data_t;
+
+
+
+/***********************************************/
+#define WRITE_PERI_REG(reg, val) *(volatile unsigned *)(PERI_BASE_ADDR + ((reg)<<2)) = (val)
+#define READ_PERI_REG(reg) (*(volatile unsigned *)(PERI_BASE_ADDR + ((reg)<<2)))
+
+#define CLEAR_PERIPHS_REG_BITS(reg, mask) WRITE_PERI_REG(reg, (READ_PERI_REG(reg)&(~(mask))))
+#define SET_PERIPHS_REG_BITS(reg, mask)   WRITE_PERI_REG(reg, (READ_PERI_REG(reg)|(mask)))
+
+#define WRITE_ISA_REG(reg, val) *(volatile unsigned *)(ISABASE + (reg)) = (val)
+#define READ_ISA_REG(reg) (*(volatile unsigned *)(ISABASE + (reg)))
+
+#define CLEAR_ISA_REG_MASK(reg, mask) WRITE_ISA_REG(reg, (READ_ISA_REG(reg)&(~mask)))
+#define SET_ISA_REG_MASK(reg, mask)   WRITE_ISA_REG(reg, (READ_ISA_REG(reg)|(mask)))
+/***********************************************/
+
+
+
+
+
+
+#define flush_cpu_cache()
+
+
+//#define dwc_write_reg32(x, v) 	(*(volatile uint32_t *)((u64)x + DWC_REG_BASE))=v
+//#define dwc_read_reg32(x) (*(volatile uint32_t*)((u64)x + DWC_REG_BASE))
+// void dwc_modify_reg32( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+//#define dwc_modify_reg32(x, c, s) 	(*(volatile uint32_t *)((u64)x + DWC_REG_BASE))=( ((dwc_read_reg32(x)) & (~c)) | (s))
+
+//#define __constant_cpu_to_le16(x) (x)
+//#define __constant_cpu_to_le32(x) (x)
+//#define cpu_to_le16(x)      (x)
+//#define  cpu_to_le32(x)     (x)
+//#define le16_to_cpu(x)      (x)
+//#define le32_to_cpu(x)      (x)
+#define get_unaligned_16(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8))
+#define get_unaligned_32(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+#define get_unaligned(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+
+#ifndef max
+#define max(a, b)	(((a) > (b))? (a): (b))
+#endif
+#ifndef min
+#define min(a, b)	(((a) < (b))? (a): (b))
+#endif
+
+//#define EXT_CLOCK	1
+//#define INT_CLOCK	0
+
+#define TIMEOUT_LONG	0
+#define TIMEOUT_SHORT	1
+// 32 bit TimerE, 1us
+#define USB_ROM_LONE_TIMEOUT		5*1000*1000  //us (5s timeout,)
+#define USB_ROM_SHORT_TIMEOUT		30*1000		//30ms
+
+/* Meet with spec */
+//#define USB_ROM_VER_MAJOR	2
+//#define USB_ROM_VER_MINOR	0				// SPEC Version
+#define USB_ROM_STAGE_MAJOR	0
+//#define USB_ROM_STAGE_MINOR	0		// IPL = 0,	SPL = 8, TPL = 16
+
+#ifdef HAS_PRINTF
+extern int printk(const char *fmt, ...);
+#endif
+
+#define NOOP	do{}while(0)
+
+#if defined(USB_DEBUG) && defined(HAS_PRINTF)
+#define PRINTF(x...) printk(x)
+#else
+//#define PRINTF(x...) NOOP
+#endif
+
+#define ERR(x...) PRINTF(x)
+#define DWC_PRINT(x...) PRINTF(x)
+//#define DBG(x...) NOOP//PRINTF(x)
+#define INFO(x...) NOOP
+
+#define USB_ERR(x...)	PRINTF(x)
+#define USB_DBG(x...) PRINTF(x)
+
+void usb_parameter_init(int delay_type);
+void clean_short_timeout(void);
+
+//#define wait_ms(a) _udelay(a*1000);
+
+//int chip_watchdog(void);
+//#define usb_memcpy(dst,src,len) memcpy((void*)dst,(void*)src,(int)len)
+//#define usb_memcpy_32bits(dst,src,len) memcpy((void*)dst,(void*)src,(int)len)
+//unsigned int get_time(void);
+
+#endif
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/usb_ch9.h b/drivers/usb/gadget/aml_tiny_usbtool/usb_ch9.h
new file mode 100644
index 0000000..711598f
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/usb_ch9.h
@@ -0,0 +1,703 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/usb_ch9.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __LINUX_USB_CH9_H
+#define __LINUX_USB_CH9_H
+
+/**
+ * @file usb_ch9.h
+ * @brief This file holds USB constants and structures that are needed for USB
+ * device APIs.  These are used by the USB device model, which is defined
+ * in chapter 9 of the USB 2.0 specification.  Linux has several APIs in C
+ * that need these:
+ *
+ * - the master/host side Linux-USB kernel driver API;
+ * - the "usbfs" user space API; and
+ * - the Linux "gadget" slave/device/peripheral side driver API.
+ *
+ * USB 2.0 adds an additional "On The Go" (OTG) mode, which lets systems
+ * act either as a USB master/host or as a USB slave/device.  That means
+ * the master and slave side APIs benefit from working well together.
+ *
+ * There's also "Wireless USB", using low power short range radios for
+ * peripheral interconnection but otherwise building on the USB framework.
+ *
+ * @addtogroup usb_core
+ */
+/*@{*/
+
+#include <linux/types.h>
+
+/*******************************************************
+* CONTROL REQUEST SUPPORT
+********************************************************/
+
+/// USB directions, to device
+/// This bit flag is used in endpoint descriptors' bEndpointAddress field.
+/// It's also one of three fields in control requests bRequestType.
+#define USB_DIR_OUT     0
+/// USB directions, to host
+/// This bit flag is used in endpoint descriptors' bEndpointAddress field.
+/// It's also one of three fields in control requests bRequestType.
+#define USB_DIR_IN      0x80
+
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_MASK       (0x03 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_STANDARD   (0x00 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_CLASS      (0x01 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_VENDOR     (0x02 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_RESERVED   (0x03 << 5)
+
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_MASK        0x1f
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_DEVICE      0x00
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_INTERFACE   0x01
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_ENDPOINT    0x02
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_OTHER       0x03
+
+/*
+ * Standard requests, for the bRequest field of a SETUP packet.
+ *
+ * These are qualified by the bRequestType field, so that for example
+ * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved
+ * by a GET_STATUS request.
+ */
+#define USB_REQ_GET_STATUS    0x00
+#define USB_REQ_CLEAR_FEATURE   0x01
+#define USB_REQ_SET_FEATURE   0x03
+#define USB_REQ_SET_ADDRESS   0x05
+#define USB_REQ_GET_DESCRIPTOR    0x06
+#define USB_REQ_SET_DESCRIPTOR    0x07
+#define USB_REQ_GET_CONFIGURATION 0x08
+#define USB_REQ_SET_CONFIGURATION 0x09
+#define USB_REQ_GET_INTERFACE   0x0A
+#define USB_REQ_SET_INTERFACE   0x0B
+#define USB_REQ_SYNCH_FRAME   0x0C
+
+/// Wireless USB
+#define USB_REQ_SET_ENCRYPTION    0x0D/
+
+#define USB_REQ_GET_ENCRYPTION    0x0E
+#define USB_REQ_SET_HANDSHAKE   0x0F
+#define USB_REQ_GET_HANDSHAKE   0x10
+#define USB_REQ_SET_CONNECTION    0x11
+#define USB_REQ_SET_SECURITY_DATA 0x12
+#define USB_REQ_GET_SECURITY_DATA 0x13
+#define USB_REQ_SET_WUSB_DATA   0x14
+#define USB_REQ_LOOPBACK_DATA_WRITE 0x15
+#define USB_REQ_LOOPBACK_DATA_READ  0x16
+#define USB_REQ_SET_INTERFACE_DS  0x17
+
+/*
+ * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and
+ * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there
+ * are at most sixteen features of each type.)
+ */
+/// (read only)
+#define USB_DEVICE_SELF_POWERED   0
+
+/// dev may initiate wakeup
+#define USB_DEVICE_REMOTE_WAKEUP  1
+
+/// (wired high speed only)
+#define USB_DEVICE_TEST_MODE      2
+
+/// (wireless)
+#define USB_DEVICE_BATTERY        2
+
+/// (otg) dev may initiate HNP
+#define USB_DEVICE_B_HNP_ENABLE   3
+
+/// (wireless
+#define USB_DEVICE_WUSB_DEVICE    3
+
+/// (otg) RH port supports HNP
+#define USB_DEVICE_A_HNP_SUPPORT  4
+
+/// (otg) other RH port does
+#define USB_DEVICE_A_ALT_HNP_SUPPORT  5
+
+/// (special devices only)
+#define USB_DEVICE_DEBUG_MODE     6
+
+
+
+
+
+
+/// IN/OUT will STALL
+#define USB_ENDPOINT_HALT   0
+
+
+#define USB_SETUP_PACKET_SIZE 8
+
+/**
+ * SETUP data for a USB device control request
+ *
+ * This structure is used to send control requests to a USB device.  It matches
+ * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
+ * USB spec for a fuller description of the different fields, and what they are
+ * used for.
+ *
+ * Note that the driver for any interface can issue control requests.
+ * For most devices, interfaces don't coordinate with each other, so
+ * such requests may be made at any time.
+ */
+struct usb_ctrlrequest {
+        /// matches the USB bmRequestType field
+        __u8  bRequestType;
+
+        /// matches the USB bRequest field
+        __u8  bRequest;
+
+        /// matches the USB wValue field (le16 byte order)
+        __u16 wValue;
+
+        /// matches the USB wIndex field (le16 byte order)
+        __u16 wIndex;
+
+        /// matches the USB wLength field (le16 byte order)
+        __u16 wLength;
+}  __attribute__ ((packed));
+typedef struct usb_ctrlrequest usb_ctrlrequest_t;
+
+
+/*
+ * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or
+ * (rarely) accepted by SET_DESCRIPTOR.
+ *
+ * Note that all multi-byte values here are encoded in little endian
+ * byte order "on the wire".  But when exposed through Linux-USB APIs,
+ * they've been converted to cpu byte order.
+ */
+
+/*
+ * Descriptor types ... USB 2.0 spec table 9.5
+ */
+#define USB_DT_DEVICE     0x01
+#define USB_DT_CONFIG     0x02
+#define USB_DT_STRING     0x03
+#define USB_DT_INTERFACE    0x04
+#define USB_DT_ENDPOINT     0x05
+#define USB_DT_DEVICE_QUALIFIER   0x06
+#define USB_DT_OTHER_SPEED_CONFIG 0x07
+#define USB_DT_INTERFACE_POWER    0x08
+/* these are from a minor usb 2.0 revision (ECN) */
+#define USB_DT_OTG      0x09
+#define USB_DT_DEBUG      0x0a
+#define USB_DT_INTERFACE_ASSOCIATION  0x0b
+/* these are from the Wireless USB spec */
+#define USB_DT_SECURITY     0x0c
+#define USB_DT_KEY      0x0d
+#define USB_DT_ENCRYPTION_TYPE    0x0e
+#define USB_DT_BOS      0x0f
+#define USB_DT_DEVICE_CAPABILITY  0x10
+#define USB_DT_WIRELESS_ENDPOINT_COMP 0x11
+
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_DEVICE    0x21
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_CONFIG    0x22
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_STRING    0x23
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_INTERFACE   0x24
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_ENDPOINT    0x25
+
+/** All standard descriptors have these 2 fields at the beginning */
+struct usb_descriptor_header {
+        __u8  bLength;
+        __u8  bDescriptorType;
+} __attribute__ ((packed));
+typedef struct usb_descriptor_header usb_descriptor_header_t;
+
+
+
+/** USB_DT_DEVICE: Device descriptor */
+struct usb_device_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+        __u16 bcdUSB;
+        __u8  bDeviceClass;
+        __u8  bDeviceSubClass;
+        __u8  bDeviceProtocol;
+        __u8  bMaxPacketSize0;
+        __u16 idVendor;
+        __u16 idProduct;
+        __u16 bcdDevice;
+        __u8  iManufacturer;
+        __u8  iProduct;
+        __u8  iSerialNumber;
+        __u8  bNumConfigurations;
+} __attribute__ ((packed));
+typedef struct usb_device_descriptor usb_device_descriptor_t;
+
+#define USB_DT_DEVICE_SIZE    18
+
+
+/*
+ * Device and/or Interface Class codes
+ * as found in bDeviceClass or bInterfaceClass
+ * and defined by www.usb.org documents
+ */
+/// for DeviceClass
+#define USB_CLASS_PER_INTERFACE   0
+
+#define USB_CLASS_AUDIO     1
+#define USB_CLASS_COMM      2
+#define USB_CLASS_HID     3
+#define USB_CLASS_PHYSICAL    5
+#define USB_CLASS_STILL_IMAGE   6
+#define USB_CLASS_PRINTER   7
+#define USB_CLASS_MASS_STORAGE    8
+#define USB_CLASS_HUB     9
+#define USB_CLASS_CDC_DATA    0x0a
+
+/// chip+ smart card
+#define USB_CLASS_CSCID     0x0b
+
+/// content security
+#define USB_CLASS_CONTENT_SEC   0x0d
+
+#define USB_CLASS_VIDEO     0x0e
+#define USB_CLASS_WIRELESS_CONTROLLER 0xe0
+#define USB_CLASS_MISC			0xef
+#define USB_CLASS_APP_SPEC    0xfe
+#define USB_CLASS_VENDOR_SPEC   0xff
+
+
+/**
+ * USB_DT_CONFIG: Configuration descriptor information.
+ *
+ * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the
+ * descriptor type is different.  Highspeed-capable devices can look
+ * different depending on what speed they're currently running.  Only
+ * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG
+ * descriptors.
+ */
+struct usb_config_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+        __u16 wTotalLength;
+        __u8  bNumInterfaces;
+        __u8  bConfigurationValue;
+        __u8  iConfiguration;
+        __u8  bmAttributes;
+        __u8  bMaxPower;
+
+        struct usb_interface *interface;
+
+        /// Extra descriptors
+        unsigned char *extra;
+
+        int extralen;
+} __attribute__ ((packed));
+typedef struct usb_config_descriptor usb_config_descriptor_t;
+
+#define USB_DT_CONFIG_SIZE    9
+
+/* from config descriptor bmAttributes */
+/// from config descriptor bmAttributes: must be set
+#define USB_CONFIG_ATT_ONE    (1 << 7)
+
+/// from config descriptor bmAttributes: self powered
+#define USB_CONFIG_ATT_SELFPOWER  (1 << 6)
+
+/// from config descriptor bmAttributes: can wakeup
+#define USB_CONFIG_ATT_WAKEUP   (1 << 5)
+
+/// from config descriptor bmAttributes: battery powered
+#define USB_CONFIG_ATT_BATTERY    (1 << 4)
+
+
+/** USB_DT_STRING: String descriptor */
+struct usb_string_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+
+        /// UTF-16LE encoded
+        __u16 wData[1];
+} __attribute__ ((packed));
+typedef struct usb_string_descriptor usb_string_descriptor_t;
+
+/*
+ * note that "string" zero is special, it holds language codes that
+ * the device supports, not Unicode characters.
+ */
+
+
+/** USB_DT_INTERFACE: Interface descriptor */
+struct usb_interface_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+        __u8  bInterfaceNumber;
+        __u8  bAlternateSetting;
+        __u8  bNumEndpoints;
+        __u8  bInterfaceClass;
+        __u8  bInterfaceSubClass;
+        __u8  bInterfaceProtocol;
+        __u8  iInterface;
+
+        struct usb_endpoint_descriptor *endpoint;
+
+        /// Extra descriptors
+        unsigned char *extra;
+
+        int extralen;
+} __attribute__ ((packed));
+typedef struct usb_interface_descriptor usb_interface_descriptor_t;
+
+#if 0
+typedef struct usb_interface {
+        struct usb_interface_descriptor *altsetting;
+
+        int act_altsetting;             /* active alternate setting */
+        int num_altsetting;             /* number of alternate settings */
+        int max_altsetting;             /* total memory allocated */
+
+        void *private_data;
+} usb_interface_t;
+#endif
+
+#define USB_DT_INTERFACE_SIZE   9
+
+
+/** USB_DT_ENDPOINT: Endpoint descriptor */
+struct usb_endpoint_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+
+        __u8  bEndpointAddress;
+        __u8  bmAttributes;
+        __u16 wMaxPacketSize;
+        __u8  bInterval;
+
+        /// NOTE:  these two are _only_ in audio endpoints.
+        /// use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof.
+        __u8  bRefresh;
+        __u8  bSynchAddress;
+
+        /// Extra descriptors
+
+        unsigned char *extra;
+        int extralen;
+} __attribute__ ((packed));
+typedef struct usb_endpoint_descriptor usb_endpoint_descriptor_t;
+
+#define USB_DT_ENDPOINT_SIZE    7
+
+/// Audio extension
+#define USB_DT_ENDPOINT_AUDIO_SIZE  9
+
+
+/*
+ * Endpoints Macro
+ */
+/// in bEndpointAddress
+#define USB_ENDPOINT_NUMBER_MASK  0x0f
+
+#define USB_ENDPOINT_DIR_MASK   0x80
+
+/// in bmAttributes
+#define USB_ENDPOINT_XFERTYPE_MASK  0x03
+
+#define USB_ENDPOINT_XFER_CONTROL 0
+#define USB_ENDPOINT_XFER_ISOC    1
+#define USB_ENDPOINT_XFER_BULK    2
+#define USB_ENDPOINT_XFER_INT   3
+#define USB_ENDPOINT_MAX_ADJUSTABLE 0x80
+
+
+
+/** USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */
+struct usb_qualifier_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __le16 bcdUSB;
+  __u8  bDeviceClass;
+  __u8  bDeviceSubClass;
+  __u8  bDeviceProtocol;
+  __u8  bMaxPacketSize0;
+  __u8  bNumConfigurations;
+  __u8  bRESERVED;
+} __attribute__ ((packed));
+
+
+
+/** USB_DT_OTG (from OTG 1.0a supplement) */
+struct usb_otg_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  /// support for HNP, SRP, etc
+  __u8  bmAttributes;
+} __attribute__ ((packed));
+
+/// from usb_otg_descriptor.bmAttributes
+#define USB_OTG_SRP   (1 << 0)
+/// swap host/device roles
+#define USB_OTG_HNP   (1 << 1)
+
+
+/** USB_DT_DEBUG:  for special highspeed devices, replacing serial console */
+struct usb_debug_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  /// bulk endpoints with 8 byte maxpacket
+  __u8  bDebugInEndpoint;
+  __u8  bDebugOutEndpoint;
+};
+
+
+/** USB_DT_INTERFACE_ASSOCIATION: groups interfaces */
+struct usb_interface_assoc_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  bFirstInterface;
+  __u8  bInterfaceCount;
+  __u8  bFunctionClass;
+  __u8  bFunctionSubClass;
+  __u8  bFunctionProtocol;
+  __u8  iFunction;
+};
+
+
+
+/**
+ * USB_DT_SECURITY:  group of wireless security descriptors, including
+ * encryption types available for setting up a CC/association.
+ */
+struct usb_security_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __le16 wTotalLength;
+  __u8  bNumEncryptionTypes;
+};
+
+
+/**
+ * USB_DT_KEY:  used with {GET,SET}_SECURITY_DATA; only public keys
+ * may be retrieved.
+ */
+struct usb_key_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  tTKID[3];
+  __u8  bReserved;
+  __u8  bKeyData[0];
+};
+
+
+/** USB_DT_ENCRYPTION_TYPE:  bundled in DT_SECURITY groups */
+struct usb_encryption_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  bEncryptionType;
+#define USB_ENC_TYPE_UNSECURE   0
+
+/// non-wireless mode
+#define USB_ENC_TYPE_WIRED    1
+
+/// aes128/cbc session
+#define USB_ENC_TYPE_CCM_1    2
+
+/// rsa3072/sha1 auth
+#define USB_ENC_TYPE_RSA_1    3
+
+  /// use in SET_ENCRYPTION
+  __u8  bEncryptionValue;
+
+  __u8  bAuthKeyIndex;
+};
+
+
+
+/** USB_DT_BOS:  group of wireless capabilities */
+struct usb_bos_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __le16 wTotalLength;
+  __u8  bNumDeviceCaps;
+};
+
+
+/** USB_DT_DEVICE_CAPABILITY:  grouped with BOS */
+struct usb_dev_cap_header {
+  __u8  bLength;
+  __u8  bDescriptorType;
+  __u8  bDevCapabilityType;
+};
+
+#define USB_CAP_TYPE_WIRELESS_USB 1
+
+/** Ultra Wide Band */
+struct usb_wireless_cap_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+  __u8  bDevCapabilityType;
+
+  __u8  bmAttributes;
+#define USB_WIRELESS_P2P_DRD    (1 << 1)
+#define USB_WIRELESS_BEACON_MASK  (3 << 2)
+#define USB_WIRELESS_BEACON_SELF  (1 << 2)
+#define USB_WIRELESS_BEACON_DIRECTED  (2 << 2)
+#define USB_WIRELESS_BEACON_NONE  (3 << 2)
+
+  /// bit rates, Mbps
+  __le16 wPHYRates;
+
+/// always set
+#define USB_WIRELESS_PHY_53   (1 << 0)
+
+#define USB_WIRELESS_PHY_80   (1 << 1)
+
+/// always set
+#define USB_WIRELESS_PHY_107    (1 << 2)
+
+#define USB_WIRELESS_PHY_160    (1 << 3)
+
+/// always set
+#define USB_WIRELESS_PHY_200    (1 << 4)
+
+#define USB_WIRELESS_PHY_320    (1 << 5)
+#define USB_WIRELESS_PHY_400    (1 << 6)
+#define USB_WIRELESS_PHY_480    (1 << 7)
+
+  /// TFI power levels
+  __u8  bmTFITXPowerInfo;
+
+  /// FFI power levels
+  __u8  bmFFITXPowerInfo;
+
+  __le16 bmBandGroup;
+  __u8  bReserved;
+};
+
+
+/**
+ * USB_DT_WIRELESS_ENDPOINT_COMP:  companion descriptor associated with
+ * each endpoint descriptor for a wireless device
+ */
+struct usb_wireless_ep_comp_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  bMaxBurst;
+  __u8  bMaxSequence;
+  __le16 wMaxStreamDelay;
+  __le16 wOverTheAirPacketSize;
+  __u8  bOverTheAirInterval;
+  __u8  bmCompAttributes;
+
+/// in bmCompAttributes
+#define USB_ENDPOINT_SWITCH_MASK  0x03
+
+#define USB_ENDPOINT_SWITCH_NO    0
+#define USB_ENDPOINT_SWITCH_SWITCH  1
+#define USB_ENDPOINT_SWITCH_SCALE 2
+};
+
+
+/**
+ * USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless
+ * host and a device for connection set up, mutual authentication, and
+ * exchanging short lived session keys.  The handshake depends on a CC.
+ */
+struct usb_handshake {
+  __u8 bMessageNumber;
+  __u8 bStatus;
+  __u8 tTKID[3];
+  __u8 bReserved;
+  __u8 CDID[16];
+  __u8 nonce[16];
+  __u8 MIC[8];
+};
+
+
+/**
+ * USB_REQ_SET_CONNECTION modifies or revokes a connection context (CC).
+ * A CC may also be set up using non-wireless secure channels (including
+ * wired USB!), and some devices may support CCs with multiple hosts.
+ */
+struct usb_connection_context {
+  /// persistent host id
+  __u8 CHID[16];
+
+  /// device id (unique w/in host context)
+  __u8 CDID[16];
+
+  /// connection key
+  __u8 CK[16];
+};
+
+
+
+/** USB 2.0 defines three speeds, here's how Linux identifies them */
+
+enum usb_device_speed {
+  USB_SPEED_UNKNOWN = 0,      /** enumerating */
+  USB_SPEED_LOW, USB_SPEED_FULL,    /** usb 1.1 */
+  USB_SPEED_HIGH,       /** usb 2.0 */
+  USB_SPEED_VARIABLE,     /** wireless (usb 2.5) */
+};
+
+/**
+ * USB device state
+ */
+enum usb_device_state {
+  /** NOTATTACHED isn't in the USB spec, and this state acts
+   * the same as ATTACHED ... but it's clearer this way.
+   */
+  USB_STATE_NOTATTACHED = 0,
+
+  /** the chapter 9 device states */
+  USB_STATE_ATTACHED,
+  USB_STATE_POWERED,
+  USB_STATE_DEFAULT,     /** limited function */
+  USB_STATE_ADDRESS,
+  USB_STATE_CONFIGURED,  /** most functions */
+
+  USB_STATE_SUSPENDED    /** Note: there are actually four different SUSPENDED
+                             states, returning to POWERED, DEFAULT, ADDRESS, or
+                             CONFIGURED respectively when SOF tokens flow again.
+                         */
+};
+
+
+/*@}*/
+#endif  /* __LINUX_USB_CH9_H */
+
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.c b/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.c
new file mode 100644
index 0000000..31954d6
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.c
@@ -0,0 +1,765 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/mach-types.h>
+#include <asm/arch/romboot.h>
+#include "platform.h"
+#include "usb_ch9.h"
+#include "dwc_pcd.h"
+#include "dwc_pcd_irq.h"
+#include "usb_pcd.h"
+#include "config.h"
+#include "usb_boot.h"
+#include <asm/arch/timer.h>
+
+
+#define DRIVER_VENDOR_ID	0x1B8E  //Amlogic's VerdorID
+#define DRIVER_PRODUCT_ID	0xC003
+#define DRIVER_VERSION       0x0100
+
+extern void usb_memcpy(char * dst,char * src,int len);
+extern int burn_board(const char *dev, void *mem_addr, u64 offset, u64 size);
+extern int usb_run_command (const char *cmd, char *buffer);
+
+#define STRING_MANUFACTURER	1
+#define STRING_PRODUCT		2
+#define STRING_SERIAL		3
+#define STRING_CONFIG		4
+#define STRING_INTERFACE	5
+static const struct usb_device_descriptor
+device_desc = {
+	sizeof device_desc,		//__u8  bLength;
+        USB_DT_DEVICE,			//__u8  bDescriptorType;
+#ifdef USE_FULL_SPEED
+        __constant_cpu_to_le16(0x0110),	//__u16 bcdUSB;
+#else
+		__constant_cpu_to_le16(0x0200),	//__u16 bcdUSB;
+#endif
+        USB_CLASS_PER_INTERFACE,	//__u8  bDeviceClass;
+        0,				//__u8  bDeviceSubClass;
+        0,				//__u8  bDeviceProtocol;
+        64,				//__u8  bMaxPacketSize0;
+        __constant_cpu_to_le16(DRIVER_VENDOR_ID),	//__u16 idVendor;
+        __constant_cpu_to_le16(DRIVER_PRODUCT_ID),	//__u16 idProduct;
+        __constant_cpu_to_le16(0x0007),	//__u16 bcdDevice;
+        STRING_MANUFACTURER,		//__u8  iManufacturer;
+        STRING_PRODUCT,			//__u8  iProduct;
+        STRING_SERIAL,			//__u8  iSerialNumber;
+        1				//__u8  bNumConfigurations;
+};
+#define INTF_CONFIG_DESC_LEN  23
+#define TOTAL_CONFIG_DESC_LEN	(INTF_CONFIG_DESC_LEN + USB_DT_CONFIG_SIZE)
+static const struct usb_config_descriptor
+config_desc = {
+	USB_DT_CONFIG_SIZE,		//__u8  bLength;
+        USB_DT_CONFIG,			//__u8  bDescriptorType;
+        TOTAL_CONFIG_DESC_LEN,				//__u16 wTotalLength;
+        1,				//__u8  bNumInterfaces;
+        1,			//__u8  bConfigurationValue;
+        0,//STRING_CONFIG,			//__u8  iConfiguration;
+        USB_CONFIG_ATT_ONE |
+        USB_CONFIG_ATT_SELFPOWER,	//__u8  bmAttributes;
+        1				//__u8  MaxPower;
+};
+/*
+static struct usb_interface_descriptor
+intf_desc = {
+	9,//sizeof intf_desc,		//__u8  bLength;
+	USB_DT_INTERFACE,		//__u8  bDescriptorType;
+					//
+	0,				//__u8  bInterfaceNumber;
+	0,				//__u8  bAlternateSetting;
+	2,				//__u8  bNumEndpoints;
+	USB_CLASS_MASS_STORAGE,		//__u8  bInterfaceClass;
+	USB_SC_SCSI,			//__u8  bInterfaceSubClass;
+	USB_PR_BULK,			//__u8  bInterfaceProtocol;
+	0//STRING_INTERFACE		//__u8  iInterface;
+};*/
+static const unsigned char intf_desc[INTF_CONFIG_DESC_LEN]={
+	0x09,// length
+	0x04,//USB_DT_INTERFACE
+	0x00,//bInterfaceNumber
+	0x00,//bAlternateSetting
+	0x02,//bNumEndpoints
+	0xFF,//bInterfaceClass, 0xFF =  USB_CLASS_VENDOR_SPEC
+	0x00,//bInterfaceSubClass
+	0x00,//bInterfaceProtocol
+	0x00,//iInterface
+
+	0x07,//Length
+	0x05,//USB_DT_ENDPOINT
+	0x80 | BULK_IN_EP_NUM,// 1 -- IN
+	0x02,// Bulk
+#ifndef USE_FULL_SPEED
+	0x00,//
+	0x02,// 64 bytes MPS
+#else
+	0x40,//
+	0x00,// 64 bytes MPS
+#endif
+	0x00,
+
+	0x07,//Length
+	0x05,//USB_DT_ENDPOINT
+	0x00 | BULK_OUT_EP_NUM,// 2 -- OUT
+	0x02,// Bulk
+#ifndef USE_FULL_SPEED
+	0x00,//
+	0x02,// 64 bytes MPS
+#else
+	0x40,//
+	0x00,// 64 bytes MPS
+#endif
+	0x00
+};
+
+#define DT_STRING_ID_LEN  4
+static const  char dt_string_id[DT_STRING_ID_LEN]={
+	DT_STRING_ID_LEN,
+	USB_DT_STRING,
+	0x09,
+	0x04,
+};
+#define DT_STRING_VID_LEN 16
+static const char dt_string_vid[DT_STRING_VID_LEN]={
+	DT_STRING_VID_LEN,
+	USB_DT_STRING,
+	'A',
+	0,
+	'm',
+	0,
+	'l',
+	0,
+	'o',
+	0,
+	'g',
+	0,
+	'i',
+	0,
+	'c',
+	0
+};
+#if defined(CONFIG_AML_MESON_8)
+#define _PLATFORM_CHIP_INDEX    '8'
+#elif defined(CONFIG_AML_MESON_6)
+#define _PLATFORM_CHIP_INDEX    '6'
+#elif defined(CONFIG_AML_G9TV)
+#define _PLATFORM_CHIP_INDEX    '9'
+#elif defined(CONFIG_AML_MESON_GX)
+#define _PLATFORM_CHIP_INDEX	'8'
+#else
+#error "chip not supported!"
+#endif// #if defined(CONFIG_AML_MESON_8)
+
+#define DT_STRING_PID_LEN 16
+static const char dt_string_pid[DT_STRING_PID_LEN]={
+	DT_STRING_PID_LEN,
+	USB_DT_STRING,
+	'M',
+	0,
+	_PLATFORM_CHIP_INDEX,
+	0,
+	'-',
+	0,
+	'C',
+	0,
+	'H',
+	0,
+	'I',
+	0,
+	'P',
+	0
+};
+#define DT_STRING_SERIAL_LEN	18
+static const char dt_string_serial[DT_STRING_SERIAL_LEN]={
+	DT_STRING_SERIAL_LEN,
+	USB_DT_STRING,
+	'2',
+	0,
+	'0',
+	0,
+	'1',
+	0,
+	'5',
+	0,
+	'0',
+	0,
+	'6',
+	0,
+	'0',
+	0,
+	'1',
+	0
+};
+int usb_pcd_init(void)
+{
+	return dwc_core_init();
+}
+
+static unsigned int need_check_timeout;
+static unsigned int usb_timeout_type; /* 0: long, 1: short */
+static unsigned int time_start;
+static unsigned int time_out_val;
+static unsigned int need_password;/* 0: no password, 1 need check */
+static unsigned int password_ok;/* 0: not ok,  1: ok*/
+static unsigned int password_cnt;
+
+
+void usb_parameter_init(int time_out)
+{
+	usb_timeout_type = time_out;
+	/*
+	 FIXME, from efuse setting
+	 */
+	need_password = 1;
+	password_cnt = 0;
+	if (need_password == 0)
+		password_ok = 1;
+	else
+		password_ok = 0;
+
+	need_check_timeout = 1;
+	if (usb_timeout_type == TIMEOUT_LONG)
+		time_out_val = USB_ROM_LONE_TIMEOUT; // wait PC GetDescriptor command
+	else
+		time_out_val = USB_ROM_SHORT_TIMEOUT; // wait suspend intrrupt
+	time_start = get_time();
+	/* clear utimer */
+/*
+	need_check_timeout=get_timer(need_check_timeout)?get_timer(need_check_timeout):1;
+	if (time_out)
+	{
+		time_out_val = time_out; // wait PC GetDescriptor command for 1us changed by Elvis
+
+	}
+	else
+	{
+		time_out_val = USB_ROM_CONN_TIMEOUT; // wait PC GetDescriptor command
+	}
+*/
+}
+
+/*
+ * Return 0: password check failed
+ *		  1: password check ok or no password
+ */
+static int password_checked(void)
+{
+	if (need_password)
+		return password_ok;
+	else
+		return 1;
+}
+/*
+ * Return 1: verify passed
+ *		  0: verify failed
+ */
+static int verify_password(pcd_struct_t *_pcd)
+{
+	/*
+	  FIXME
+	 */
+	if ( _pcd->length > 64 )
+		return 0;
+	else
+		return 1;
+}
+void clean_short_timeout(void)
+{
+	if (usb_timeout_type == TIMEOUT_SHORT) {
+		USB_DBG("--Clean short timeout\n");
+		need_check_timeout = 0;
+	}
+}
+
+int usb_pcd_irq(void)
+{
+	if (need_check_timeout) {
+		if (get_time() - time_start > time_out_val) {
+			dwc_otg_power_off_phy();
+			return 2;// return to other device boot
+		}
+	}
+
+	return dwc_otg_irq();
+}
+
+//#define buff ((char*)PCD_BUFF)
+static char _buf[512];
+#define buff ((char*)_buf)
+void start_bulk_transfer(pcd_struct_t *_pcd)
+{
+	_pcd->bulk_lock = 1; // TODO : add lock code.
+	dwc_otg_ep_req_start(_pcd,_pcd->bulk_out?BULK_OUT_EP_NUM:BULK_IN_EP_NUM);
+}
+/**
+ * This functions delegates the setup command to the gadget driver.
+ */
+void do_gadget_setup( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl)
+{
+	int			value;
+	u16			w_index = ctrl->wIndex;
+	u16			w_value = ctrl->wValue;
+	u16			w_length = ctrl->wLength;
+
+	/* usually this just stores reply data in the pre-allocated ep0 buffer,
+	 * but config change events will also reconfigure hardware. */
+	switch (ctrl->bRequest) {
+
+	  case USB_REQ_GET_DESCRIPTOR:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD |
+								USB_RECIP_DEVICE))
+			break;
+		//time_out_val = USB_ROM_DRIVER_TIMEOUT;// Wait SetConfig (PC install driver OK)
+		need_check_timeout = 0;
+		switch (w_value >> 8) {
+			case USB_DT_DEVICE:
+				USB_DBG("--get device descriptor\n\n");
+				value = min(w_length, (u16) sizeof device_desc);
+				usb_memcpy(buff, (char*)&device_desc, value);
+				_pcd->buf = buff;
+				_pcd->length = value;
+				break;
+			case USB_DT_DEVICE_QUALIFIER:
+				USB_DBG("--get device qualifier\n\n");
+				break;
+			case USB_DT_OTHER_SPEED_CONFIG:
+				DBG("--get other speed configuration descriptor\n");
+				DBG("--other speed configuration descriptor length :%d\n", value);
+				break;
+			case USB_DT_CONFIG:
+				USB_DBG("--get configuration descriptor: size %d\n",w_length);
+				if (w_length > USB_DT_CONFIG_SIZE)
+				{
+					value = TOTAL_CONFIG_DESC_LEN;
+					usb_memcpy(buff+USB_DT_CONFIG_SIZE,(void*)&intf_desc[0],INTF_CONFIG_DESC_LEN);
+				}
+				else
+					value = w_length;
+				usb_memcpy(buff, (void*)&config_desc, USB_DT_CONFIG_SIZE);
+				_pcd->buf = buff;
+				_pcd->length = value;
+				USB_DBG("--configuration descriptor length :%d\n\n", value);
+				break;
+			case USB_DT_STRING:
+				USB_DBG("--get string descriptor: id: %d\n",w_value & 0xff);
+				switch (w_value & 0xff) {
+					case 0: // IDs
+						usb_memcpy(buff,(void*)dt_string_id,DT_STRING_ID_LEN);
+						break;
+					case 1: // STRING_MANUFACTURER
+						usb_memcpy(buff,(void*)dt_string_vid,DT_STRING_VID_LEN);
+
+						break;
+					case 2://STRING_PRODUCT
+						usb_memcpy(buff,(void*)dt_string_pid,DT_STRING_PID_LEN);
+						break;
+					case 3://STRING_SERIAL
+					default:
+						usb_memcpy(buff,(void*)dt_string_serial,DT_STRING_SERIAL_LEN);
+						break;
+					}
+				_pcd->buf = buff;
+				_pcd->length = buff[0];
+				USB_DBG("--get string descriptor: return length: %d\n\n",_pcd->length);
+				break;
+			}
+			break;
+
+	case USB_REQ_SET_CONFIGURATION:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD |
+				USB_RECIP_DEVICE))
+			break;
+		USB_DBG("--set configuration\n\n");
+		_pcd->buf = 0;
+		_pcd->length = 0;
+		_pcd->request_config = 1;   /* Configuration changed */
+		//need_check_timeout = 0;
+		break;
+
+	case USB_REQ_GET_CONFIGURATION:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD |
+				USB_RECIP_DEVICE))
+			break;
+		USB_DBG("--get configuration\n\n");
+		buff[0] = 1;
+		_pcd->buf = buff;
+		_pcd->length = 1;
+		break;
+
+	default:
+		USB_ERR("--unknown control req %02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+	}
+	if (w_index != 0)
+		w_index = 0; //remove compile warning
+	return ;
+}
+/**
+ * This functions delegates vendor ctrl request.
+ */
+void do_vendor_request( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl)
+{
+	u32			value =0;
+	u16			w_index = ctrl->wIndex;
+	u16			w_value = ctrl->wValue;
+	u16			w_length = ctrl->wLength;
+    //unsigned* 	_u32Buf = (unsigned*)buff;
+
+	switch (ctrl->bRequest) {
+
+	  case AM_REQ_WRITE_MEM:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		USB_DBG("--am req write memory\n");
+		value = (w_value << 16) + w_index;
+		USB_DBG("addr = 0x%08X, size = %d\n\n",value,w_length);
+		if (password_checked()) {
+			_pcd->buf = (char *)(unsigned long long)value; // copy to dst memory directly
+			_pcd->length = w_length;
+		}else{
+			USB_DBG("  password verfiy failed!\n");
+			_pcd->buf = buff;
+			_pcd->length = w_length;
+		}
+		break;
+
+	  case AM_REQ_READ_MEM:
+	  case AM_REQ_READ_AUX:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		value = (w_value << 16) + w_index;
+		USB_DBG("--am req read memory\n");
+				USB_DBG("addr = 0x%08X, size = %d\n\n",value,w_length);
+		if (password_checked()) {
+			usb_memcpy((char *)buff,(char*)(unsigned long long)value,w_length);
+
+			_pcd->buf = buff;
+			_pcd->length = w_length;
+		}else{
+			USB_DBG("  password verfiy failed!\n");
+			usb_memcpy((char *)buff,"BAD PASSWORD",w_length);
+			_pcd->buf = buff;
+			_pcd->length = w_length;
+		}
+		break;
+/*
+	  case AM_REQ_READ_AUX:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		unsigned int data = 0;
+		value = (w_value << 16) + w_index;
+
+		//data = _lr(value);
+		//(unsigned int *)buff = data;
+                _u32Buf[0] = data;
+
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+*/
+	  case AM_REQ_FILL_MEM:
+	  case AM_REQ_WRITE_AUX:
+	  case AM_REQ_MODIFY_MEM:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_RUN_IN_ADDR:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		value = (w_value << 16) + w_index;
+		USB_DBG("--am req run in addr %p\n\n",value);
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_WR_LARGE_MEM:
+		value = 1;
+	  case AM_REQ_RD_LARGE_MEM:
+		USB_DBG("--am req large %s mem \n\n",value?"write":"read");
+
+		_pcd->bulk_len = w_value;	// block length
+		_pcd->bulk_num = w_index; // number of block
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_IDENTIFY_HOST:
+		buff[0] = USB_ROM_VER_MAJOR;
+		buff[1] = USB_ROM_VER_MINOR;
+		buff[2] = USB_ROM_STAGE_MAJOR;
+		buff[3] = USB_ROM_STAGE_MINOR;
+		buff[4] = need_password;
+		buff[5] = password_ok;
+		buff[6] = 0;
+		buff[7] = 0;
+
+		if (w_length > 8)
+			w_length = 8;
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		need_check_timeout = 0;
+		USB_DBG("--am req identify %x:%x, %x:%x\n\n",
+			buff[0],buff[1],buff[2],buff[3]);
+		USB_DBG("-- [4:5 6:7]      %x:%x, %x:%x\n\n",
+			buff[4],buff[5],buff[6],buff[7]);
+		break;
+	  case AM_REQ_PASSWORD:
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		password_ok = 0;
+		break;
+	  case AM_REQ_NOP:
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		USB_DBG("--am AM_REQ_NOP \n");
+		break;
+
+	  case AM_REQ_TPL_CMD:
+	  case AM_REQ_TPL_STAT:
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  default:
+		USB_ERR("--unknown vendor req %02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+		break;
+	}
+
+	return;
+}
+/*
+ * This function will be called after a whole SETUP-OUT-IN transfer.
+ */
+void do_vendor_out_complete( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl)
+{
+	u32			value = 0;
+	u16			w_index = ctrl->wIndex;
+	u16			w_value = ctrl->wValue;
+	u16			w_length = ctrl->wLength;
+	unsigned int running_flags;
+	void (*fp)(void);
+	char * buf;
+    unsigned * _u32Buf = (unsigned *)buff;
+
+	//USB_DBG("do_vendor_out_complete()\n");
+	switch (ctrl->bRequest) {
+
+	  case AM_REQ_WRITE_MEM:
+	  case AM_REQ_WRITE_AUX:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+			USB_DBG("--am req write memory completed\n\n");
+		break;
+
+	  case AM_REQ_FILL_MEM:
+		if (!password_checked())
+			break;
+		buf = _pcd->buf;
+		unsigned long long addr,i;
+		for (i = 0; i < _pcd->length; i+=8) {
+			addr = *((unsigned int *)&buf[i]) ;
+			value = *((unsigned int *)&buf[i+4]) ;
+			*(unsigned int*)addr = value;
+		}
+		break;
+/*
+	  case AM_REQ_WRITE_AUX:
+		buf = _pcd->buf;
+		//unsigned int data =0;
+
+		//data = *((unsigned int *)&buf[0]) ; //reg value
+		value = (w_value << 16) + w_index; //aux reg
+
+		//_sr(data,value);
+		break;
+*/
+	  case AM_REQ_MODIFY_MEM:
+		if (password_checked())
+			do_modify_memory(w_value,_pcd->buf);
+		else
+			USB_DBG(" Fill memory password check failed!\n");
+		break;
+
+	  case AM_REQ_RUN_IN_ADDR:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		if (!password_checked()) {
+			USB_DBG("  run in addr password check failed!\n");
+			break;
+		}
+		value = (w_value << 16) + w_index;
+		buf = _pcd->buf;
+		running_flags = *((unsigned int *)&buf[0]);
+		USB_DBG("--run addr = 0x%08X, with running flags 0x%08X\n",value,running_flags);
+		fp = (void(*)(void))(unsigned long long)value;
+		if (!(running_flags & AM_RUNNING_FLAGS_KEEP_POWER_ON)) {
+			dwc_otg_power_off_phy();
+			USB_DBG("  usb controller is power off!\n");
+		}
+		fp();
+		break;
+
+	  case AM_REQ_WR_LARGE_MEM:
+		value = 1; // is_out = 1
+	  case AM_REQ_RD_LARGE_MEM:
+		_pcd->bulk_out = value; // read or write
+		_pcd->bulk_buf = (char *)(unsigned long long)_u32Buf[0];//(*(unsigned int*)buff); // board address
+		if (!password_checked())
+			_pcd->bulk_buf = buff;
+		_pcd->bulk_data_len = _u32Buf[1];//(*(unsigned int*) &buff[4]); // data length
+		start_bulk_transfer(_pcd);
+		USB_DBG("--bulk %s addr = 0x%X, size = %d\n\n",value?"write":"read",_pcd->bulk_buf,_pcd->bulk_data_len);
+		break;
+	  case AM_REQ_PASSWORD:
+		if (verify_password(_pcd)) {
+			password_ok = 1;
+			password_cnt = 0;
+		}else{
+			password_ok = 0;
+			password_cnt++;
+			if (password_cnt > 3) {
+				/*
+				  FIXME
+				*/
+				USB_ERR("password failed 3 times, reboot!\n");
+				while (1) ;
+			}
+		}
+		break;
+
+	  case AM_REQ_TPL_CMD:
+		  // this is an example for any command
+		if (!w_index) {// assume subcode is 0
+			char dev[16] = {0};
+			u64 offset = 0;
+			u64 tmp = 0;
+			u32 mem_addr = _u32Buf[0];//(u32)(*(unsigned int*)buff);
+
+			offset |= (*(unsigned int*)&buff[16]);
+			tmp = (*(unsigned int*)&buff[20]);
+			offset |= (tmp << 32);
+
+			u32 size = (*(unsigned int*)&buff[12]);
+			usb_memcpy(dev,&buff[32],16);
+			burn_board(dev, (void *)(unsigned long long)mem_addr, offset, size);
+		}
+		else if(w_index == 1){
+			char cmd[CMD_BUFF_SIZE];
+			memcpy(cmd, buff, CMD_BUFF_SIZE);
+			if (strncmp(cmd,"bootm",(sizeof("bootm")-1)) == 0) {
+				dwc_otg_pullup(0);//disconnect
+			}
+			usb_run_command(cmd, buff);
+		}
+		break;
+
+	  default:
+		USB_ERR("--unknown vendor req comp %02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+		break;
+	}
+	if (w_length != 0)
+		w_length = 0;//remove compile warning
+	return;
+}
+/*
+ * This function will be called after a whole bulk out transfer.
+ */
+void do_bulk_complete( pcd_struct_t *_pcd)
+{
+	_pcd->bulk_lock = 0;
+	_pcd->bulk_num--;
+	_pcd->bulk_data_len -= _pcd->xfer_len;
+
+	if (_pcd->bulk_num)
+	{
+		_pcd->bulk_buf += _pcd->bulk_len;
+		start_bulk_transfer(_pcd);
+	}
+
+}
+
+void do_modify_memory(u16 opcode, char *inbuff)
+{
+	unsigned int *mem,*mem2;
+	unsigned int data,mask;
+
+	mem = *(unsigned int**)&inbuff[0];
+	data = *(unsigned int*)&inbuff[4];
+	mask = *(unsigned int*)&inbuff[8];
+	mem2= *(unsigned int**)&inbuff[12];
+
+	switch (opcode) {
+	  case 0: //*mem = data
+		*mem = data;
+		break;
+
+	  case 1:// *mem = (data & mask)
+		*mem = data & mask;
+		break;
+
+	  case 2:// *mem =(*mem | mask)
+		*mem = *mem | mask;
+		break;
+
+	  case 3:// *mem = (data & (~mask))
+		*mem =  (data & (~mask));
+		break;
+
+	  case 4:// *mem = (data & mask) |(*mem & ~mask)
+		*mem = (data & mask) |(*mem & ~mask);
+		break;
+
+	  case 5:// *mem = *mem2
+		*mem = *mem2;
+		break;
+
+	  case 6:// *mem = (*mem2 & mask)
+		*mem = (*mem2 & mask);
+		break;
+
+	  case 7:// while(data--) {*mem++ = *mem2++}
+		while (data--) {
+			*mem++ = *mem2++;
+		}
+		break;
+
+	  default:
+		break;
+	}
+
+}
diff --git a/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.h b/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.h
new file mode 100644
index 0000000..387bd40
--- /dev/null
+++ b/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.h
@@ -0,0 +1,55 @@
+
+/*
+ * drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __USB_PCD_H__
+#define __USB_PCD_H__
+#include <asm/types.h>
+
+#define CMD_BUFF_SIZE		512
+
+int usb_pcd_init(void);
+int usb_pcd_irq(void);
+
+// Vendor request defines
+#define AM_REQ_WRITE_MEM	0x01
+#define AM_REQ_READ_MEM	0x02
+#define AM_REQ_FILL_MEM	0x03
+#define AM_REQ_MODIFY_MEM	0x04
+#define AM_REQ_RUN_IN_ADDR	0x05
+#define AM_REQ_WRITE_AUX	0x06
+#define AM_REQ_READ_AUX		0x07
+
+#define AM_REQ_WR_LARGE_MEM	0x11
+#define AM_REQ_RD_LARGE_MEM	0x12
+#define AM_REQ_IDENTIFY_HOST	0x20
+
+#define AM_REQ_TPL_CMD	0x30
+#define AM_REQ_TPL_STAT 0x31
+
+#define AM_REQ_PASSWORD 0x35
+#define AM_REQ_NOP		0x36
+
+#define AM_RUNNING_FLAGS_KEEP_POWER_ON	0x10
+
+
+void do_modify_memory(u16 opcode, char *inbuff);
+
+#endif
diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 0df4b2a..ff972a9 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -165,9 +165,11 @@ static int ep_matches(
 	if (USB_ENDPOINT_XFER_BULK == type) {
 		int size = ep->maxpacket;
 
+#if !defined(CONFIG_MACH_ODROIDC2)
 		/* min() doesn't work on bitfields with gcc-3.5 */
 		if (size > 64)
 			size = 64;
+#endif
 		put_unaligned(cpu_to_le16(size), &desc->wMaxPacketSize);
 	}
 	return 1;
diff --git a/drivers/usb/gadget/f_fastboot.c b/drivers/usb/gadget/f_fastboot.c
index 310175a..18703a6 100644
--- a/drivers/usb/gadget/f_fastboot.c
+++ b/drivers/usb/gadget/f_fastboot.c
@@ -18,6 +18,7 @@
 #include <linux/usb/gadget.h>
 #include <linux/usb/composite.h>
 #include <linux/compiler.h>
+#include <usb/fastboot.h>
 #include <version.h>
 #include <g_dnl.h>
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
@@ -32,7 +33,11 @@
 
 #define RX_ENDPOINT_MAXIMUM_PACKET_SIZE_2_0  (0x0200)
 #define RX_ENDPOINT_MAXIMUM_PACKET_SIZE_1_1  (0x0040)
+#if defined(CONFIG_MACH_ODROIDC2)
+#define TX_ENDPOINT_MAXIMUM_PACKET_SIZE      (0x0200)
+#else
 #define TX_ENDPOINT_MAXIMUM_PACKET_SIZE      (0x0040)
+#endif
 
 /* The 64 defined bytes plus \0 */
 #define RESPONSE_LEN	(64 + 1)
@@ -123,6 +128,50 @@ static struct usb_gadget_strings *fastboot_strings[] = {
 
 static void rx_handler_command(struct usb_ep *ep, struct usb_request *req);
 
+#define FASTBOOT_MAXPENTRY		16
+
+static char *transfer_buffer = (void *)CONFIG_USB_FASTBOOT_BUF_ADDR;
+static fastboot_ptentry ptable[FASTBOOT_MAXPENTRY];
+static unsigned int pcount;
+
+void fastboot_flash_reset_ptn(void)
+{
+	pcount = 0;
+}
+
+void fastboot_flash_add_ptn(fastboot_ptentry *ptn)
+{
+	if (pcount < FASTBOOT_MAXPENTRY) {
+		memcpy((ptable + pcount), ptn, sizeof(*ptn));
+		pcount++;
+	}
+}
+
+fastboot_ptentry *fastboot_flash_find_ptn(const char *name)
+{
+	unsigned int n;
+
+	for (n = 0; n < pcount; n++) {
+		/* Make sure a substring is not accepted */
+		if (strlen(name) == strlen(ptable[n].name)) {
+			if (0 == strcmp(ptable[n].name, name))
+				return ptable + n;
+		}
+	}
+	return 0;
+}
+
+void fastboot_flash_dump_ptn(void)
+{
+	unsigned int n;
+
+	for (n = 0; n < pcount; n++) {
+		fastboot_ptentry *ptn = ptable + n;
+		printf("ptn %d name='%s'", n, ptn->name);
+		printf(" start=%d len=%d\n", ptn->start, ptn->length);
+	}
+}
+
 static void fastboot_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	int status = req->status;
@@ -363,6 +412,24 @@ static void cb_getvar(struct usb_ep *ep, struct usb_request *req)
 			strncat(response, s, chars_left);
 		else
 			strcpy(response, "FAILValue not set");
+	} else if (!strcmp_l1("partition-type:", cmd)) {
+		const char *partition_name = cmd + 15;
+
+		if (!strcmp_l1(partition_name, "all")) {
+			sprintf(response, "OKAY");
+		} else {
+			/* FIXME: partition-type would be required to supported
+			 * to return its type per each partition.
+			 */
+			fastboot_ptentry* ptn
+				= fastboot_flash_find_ptn(partition_name);
+			if (ptn) {
+				strncat(response, "raw", sizeof(response));
+			} else {
+				sprintf(response, "FAILunknown partition %s",
+						partition_name);
+			}
+		}
 	} else {
 		error("unknown variable: %s\n", cmd);
 		strcpy(response, "FAILVariable not implemented");
@@ -397,8 +464,7 @@ static void rx_handler_dl_image(struct usb_ep *ep, struct usb_request *req)
 	if (buffer_size < transfer_size)
 		transfer_size = buffer_size;
 
-	memcpy((void *)CONFIG_USB_FASTBOOT_BUF_ADDR + download_bytes,
-	       buffer, transfer_size);
+	memcpy((void *)transfer_buffer + download_bytes, buffer, transfer_size);
 
 	pre_dot_num = download_bytes / BYTES_PER_DOT;
 	download_bytes += transfer_size;
@@ -506,13 +572,34 @@ static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 
 	strcpy(response, "FAILno flash device defined");
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
-	fb_mmc_flash_write(cmd, (void *)CONFIG_USB_FASTBOOT_BUF_ADDR,
-			   download_bytes, response);
+	fb_mmc_flash_write(cmd, (void *)transfer_buffer, download_bytes,
+			response);
 #endif
 	fastboot_tx_write_str(response);
 }
 #endif
 
+int fastboot_oem(const char *cmd)
+{
+	printf("fastboot_oem:%s", cmd);
+	if (!strcmp(cmd, "format"))
+		return do_format();
+	return -1;
+}
+
+static void cb_oem(struct usb_ep *ep, struct usb_request *req)
+{
+	char *cmd = req->buf;
+
+	printf("calling fastboot oem!! : %s\n", cmd);
+	int r = fastboot_oem(cmd + 4);
+	if (r < 0) {
+		fastboot_tx_write_str("FAIL");
+	} else {
+		fastboot_tx_write_str("OKAY");
+	}
+}
+
 struct cmd_dispatch_info {
 	char *cmd;
 	void (*cb)(struct usb_ep *ep, struct usb_request *req);
@@ -534,6 +621,9 @@ static const struct cmd_dispatch_info cmd_dispatch_info[] = {
 	}, {
 		.cmd = "continue",
 		.cb = cb_continue,
+	}, {
+		.cmd = "oem",
+		.cb = cb_oem,
 	},
 #ifdef CONFIG_FASTBOOT_FLASH
 	{
@@ -549,6 +639,8 @@ static void rx_handler_command(struct usb_ep *ep, struct usb_request *req)
 	void (*func_cb)(struct usb_ep *ep, struct usb_request *req) = NULL;
 	int i;
 
+	*(cmdbuf + req->actual) = '\0';
+
 	for (i = 0; i < ARRAY_SIZE(cmd_dispatch_info); i++) {
 		if (!strcmp_l1(cmd_dispatch_info[i].cmd, cmdbuf)) {
 			func_cb = cmd_dispatch_info[i].cb;
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index e045957..f5e7421 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -973,7 +973,7 @@ static int do_write(struct fsg_common *common)
 
 			/* If an error occurred, report it and its position */
 			if (nwritten < amount) {
-				printf("nwritten:%d amount:%d\n", nwritten,
+				printf("nwritten:%zd amount:%d\n", nwritten,
 				       amount);
 				curlun->sense_data = SS_WRITE_ERROR;
 				curlun->info_valid = 1;
diff --git a/drivers/usb/gadget/s3c_udc_otg.c b/drivers/usb/gadget/s3c_udc_otg.c
index 7653f03..e6325e2 100644
--- a/drivers/usb/gadget/s3c_udc_otg.c
+++ b/drivers/usb/gadget/s3c_udc_otg.c
@@ -799,13 +799,13 @@ static struct s3c_udc memory = {
 int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
 {
 	struct s3c_udc *dev = &memory;
-	int retval = 0;
+	int retval = 0, i;
 
 	debug("%s: %p\n", __func__, pdata);
 
 	dev->pdata = pdata;
 
-	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
+	reg = (struct s3c_usbotg_reg *)(uintptr_t)pdata->regs_otg;
 
 	/* regs_otg = (void *)pdata->regs_otg; */
 
@@ -818,15 +818,16 @@ int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
 
 	the_controller = dev;
 
-	usb_ctrl = memalign(CONFIG_SYS_CACHELINE_SIZE,
-			    ROUND(sizeof(struct usb_ctrlrequest),
-				  CONFIG_SYS_CACHELINE_SIZE));
-	if (!usb_ctrl) {
-		error("No memory available for UDC!\n");
-		return -ENOMEM;
+	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
+		dev->dma_buf[i] = memalign(CONFIG_SYS_CACHELINE_SIZE,
+					   DMA_BUFFER_SIZE);
+		dev->dma_addr[i] = (dma_addr_t) (uintptr_t) dev->dma_buf[i];
+		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
+					(unsigned long) (dev->dma_buf[i]
+							 + DMA_BUFFER_SIZE));
 	}
-
-	usb_ctrl_dma_addr = (dma_addr_t) usb_ctrl;
+	usb_ctrl = dev->dma_buf[0];
+	usb_ctrl_dma_addr = dev->dma_addr[0];
 
 	udc_reinit(dev);
 
diff --git a/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c b/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c
index 7e7a2c2..9dcda0b 100644
--- a/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c
+++ b/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c
@@ -110,7 +110,8 @@ static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
 
 	ctrl =  readl(&reg->out_endp[ep_num].doepctl);
 
-	writel((unsigned int) ep->dma_buf, &reg->out_endp[ep_num].doepdma);
+	writel(the_controller->dma_addr[ep_index(ep)+1],
+	       &reg->out_endp[ep_num].doepdma);
 	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
 	       &reg->out_endp[ep_num].doeptsiz);
 	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
@@ -133,6 +134,7 @@ int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
 	u32 *buf, ctrl = 0;
 	u32 length, pktcnt;
 	u32 ep_num = ep_index(ep);
+	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
 
 	buf = req->req.buf + req->req.actual;
 	length = req->req.length - req->req.actual;
@@ -142,10 +144,10 @@ int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
 
 	ep->len = length;
 	ep->dma_buf = buf;
+	memcpy(p, ep->dma_buf, length);
 
-	flush_dcache_range((unsigned long) ep->dma_buf,
-			   (unsigned long) ep->dma_buf +
-			   ROUND(ep->len, CONFIG_SYS_CACHELINE_SIZE));
+	flush_dcache_range((unsigned long) p ,
+			   (unsigned long) p + DMA_BUFFER_SIZE);
 
 	if (length == 0)
 		pktcnt = 1;
@@ -158,7 +160,8 @@ int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
 	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
 		;
 
-	writel((unsigned long) ep->dma_buf, &reg->in_endp[ep_num].diepdma);
+	writel(the_controller->dma_addr[ep_index(ep)+1],
+	       &reg->in_endp[ep_num].diepdma);
 	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
 	       &reg->in_endp[ep_num].dieptsiz);
 
@@ -191,6 +194,7 @@ static void complete_rx(struct s3c_udc *dev, u8 ep_num)
 	struct s3c_ep *ep = &dev->ep[ep_num];
 	struct s3c_request *req = NULL;
 	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
+	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
 
 	if (list_empty(&ep->queue)) {
 		debug_cond(DEBUG_OUT_EP != 0,
@@ -210,23 +214,10 @@ static void complete_rx(struct s3c_udc *dev, u8 ep_num)
 
 	xfer_size = ep->len - xfer_size;
 
-	/*
-	 * NOTE:
-	 *
-	 * Please be careful with proper buffer allocation for USB request,
-	 * which needs to be aligned to CONFIG_SYS_CACHELINE_SIZE, not only
-	 * with starting address, but also its size shall be a cache line
-	 * multiplication.
-	 *
-	 * This will prevent from corruption of data allocated immediatelly
-	 * before or after the buffer.
-	 *
-	 * For armv7, the cache_v7.c provides proper code to emit "ERROR"
-	 * message to warn users.
-	 */
-	invalidate_dcache_range((unsigned long) ep->dma_buf,
-				(unsigned long) ep->dma_buf +
-				ROUND(xfer_size, CONFIG_SYS_CACHELINE_SIZE));
+	invalidate_dcache_range((unsigned long) p,
+				(unsigned long) p + DMA_BUFFER_SIZE);
+
+	memcpy(ep->dma_buf, p, ep->len);
 
 	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
 	is_short = (xfer_size < ep->ep.maxpacket);
@@ -720,14 +711,19 @@ static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
 
 int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
 {
-	invalidate_dcache_range((unsigned long)cp, (unsigned long)cp +
-				ROUND(max, CONFIG_SYS_CACHELINE_SIZE));
+	u32 bytes;
+
+	bytes = sizeof(struct usb_ctrlrequest);
+
+	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
+				(unsigned long) ep->dev->dma_buf[ep_index(ep)]
+				+ DMA_BUFFER_SIZE);
 
 	debug_cond(DEBUG_EP0 != 0,
-		   "%s: bytes=%d, ep_index=%d 0x%p\n", __func__,
-		   max, ep_index(ep), cp);
+		   "%s: bytes=%d, ep_index=%d %p\n", __func__,
+		   bytes, ep_index(ep), ep->dev->dma_buf[ep_index(ep)]);
 
-	return max;
+	return bytes;
 }
 
 /**
@@ -859,12 +855,14 @@ static int s3c_ep0_write(struct s3c_udc *dev)
 	return 1;
 }
 
+u16	g_status;
+
 int s3c_udc_get_status(struct s3c_udc *dev,
 		struct usb_ctrlrequest *crq)
 {
 	u8 ep_num = crq->wIndex & 0x7F;
-	u16 g_status = 0;
 	u32 ep_ctrl;
+	u32 *p = the_controller->dma_buf[1];
 
 	debug_cond(DEBUG_SETUP != 0,
 		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
@@ -902,13 +900,12 @@ int s3c_udc_get_status(struct s3c_udc *dev,
 		return 1;
 	}
 
-	memcpy(usb_ctrl, &g_status, sizeof(g_status));
+	memcpy(p, &g_status, sizeof(g_status));
 
-	flush_dcache_range((unsigned long) usb_ctrl,
-			   (unsigned long) usb_ctrl +
-			   ROUND(sizeof(g_status), CONFIG_SYS_CACHELINE_SIZE));
+	flush_dcache_range((unsigned long) p,
+			   (unsigned long) p + DMA_BUFFER_SIZE);
 
-	writel(usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
+	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
 	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
 	       &reg->in_endp[EP0_CON].dieptsiz);
 
diff --git a/drivers/usb/gadget/v2_burning/Makefile b/drivers/usb/gadget/v2_burning/Makefile
new file mode 100644
index 0000000..746ca39
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+EXTRA_CFLAGS = -I./v2_common -I./v2_usb_tool -I./v2_sdc_burn
+
+obj-$(CONFIG_AML_V2_FACTORY_BURN) += aml_v2_burn.o
+
+aml_v2_burn-y = aml_v2_burning.o
+aml_v2_burn-y += v2_usb_tool/optimus_core.o v2_usb_tool/optimus_transform.o
+aml_v2_burn-y += v2_common/optimus_download.o v2_common/optimus_buffer_manager.o v2_common/optimus_simg2img.o
+aml_v2_burn-y += v2_common/optimus_progress.o
+ifdef CONFIG_AML_FACTORY_BURN_LOCAL_UPGRADE
+aml_v2_burn-y += v2_common/optimus_img_decoder.o v2_common/optimus_fat.o
+aml_v2_burn-y += v2_sdc_burn/optimus_sdc_update.o v2_sdc_burn/optimus_sdc_burn.o v2_sdc_burn/optimus_ini_parser.o
+aml_v2_burn-y += v2_sdc_burn/optimus_ini__aml_sdc_burn.o
+aml_v2_burn-y += v2_usb_burn/optimus_usb_burn.o v2_usb_burn/optimus_usb_update.o
+aml_v2_burn-$(CONFIG_UNIFY_KEY_MANAGE) += v2_common/optimus_download_key.o
+aml_v2_burn-$(CONFIG_SD_BURNING_SUPPORT_UI) += v2_common/optimus_progress_ui.o
+aml_v2_burn-$(CONFIG_SD_BURNING_SUPPORT_LED) += v2_sdc_burn/optimus_led.o
+aml_v2_burn-y += aml_sysrecovery/aml_sysrecovery.o
+aml_v2_burn-$(CONFIG_DETECT_SYS_RECOVERY_KEY) += aml_sysrecovery/cmd_detect_sys_recovery_key.o
+aml_v2_burn-$(CONFIG_SUPPORT_SDC_KEYBURN) += v2_sdc_burn/sdc_burnkeys/optimus_key_burn.o
+aml_v2_burn-$(CONFIG_SUPPORT_SDC_KEYBURN) += v2_sdc_burn/sdc_burnkeys/sdc_keysprovider.o v2_sdc_burn/sdc_burnkeys/sdc_bootPart_license.o
+endif#ifdef CONFIG_AML_FACTORY_BURN_LOCAL_UPGRADE
+
diff --git a/drivers/usb/gadget/v2_burning/aml_sysrecovery/aml_sysrecovery.c b/drivers/usb/gadget/v2_burning/aml_sysrecovery/aml_sysrecovery.c
new file mode 100644
index 0000000..f2dbc8b
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/aml_sysrecovery/aml_sysrecovery.c
@@ -0,0 +1,207 @@
+/*
+ * \file        sysrecovery.c
+ * \brief
+ *
+ * \version     1.0.0
+ * \date        Friday,14/11/21
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2014 Amlogic. All Rights Reserved.
+ *
+ */
+#include "../v2_burning_i.h"
+#include "../v2_sdc_burn/optimus_sdc_burn_i.h"
+#include "../v2_sdc_burn/optimus_led.h"
+
+#define CONFIG_AML_SYS_RECOVERY_CLEAR_USR_DATA  1
+
+static int optimus_sysrec_check_whole_img_before_burn(const char* partName)
+{
+        //TODO:
+        return 0;
+}
+
+#if CONFIG_AML_SYS_RECOVERY_CLEAR_USR_DATA
+//clear data parts then the parts will formatted when firtsboot
+//As fill half parttition need so much time, I just clear 2M
+static int optimus_sysrec_clear_usr_data_parts(void)
+{
+        const char* const _usrDataParts[] = {"data",};
+        const int   dataPartsNum          = sizeof(_usrDataParts)/sizeof(const char*);
+        const unsigned    BufSz = 1U<<20;//1MB
+        unsigned char*    clearBuf= (unsigned char*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+        int partIndex = 0;
+        int ret = 0;
+
+        memset(clearBuf, 0xff, BufSz);
+        for (partIndex = 0; partIndex < dataPartsNum; ++partIndex)
+        {
+                u64 partCap = 0;
+                unsigned char* thePart = (unsigned char*)_usrDataParts[partIndex];
+                int rcode = 0;
+                u64 offset = 0;
+                u64 ClearSz = 2U<<20;
+
+                DWN_MSG("To clear data part[%s]\n", thePart);
+                rcode = store_get_partititon_size(thePart, &partCap);
+                if (rcode) {
+                        DWN_ERR("Fail to get partSz for part[%s]\n", thePart);
+                        return rcode;
+                }
+                partCap <<= 9;
+                //FIXME: If there is fschk before firstboot, the 2MB to destroy the data if not enough
+                /*ClearSz = partCap>>1;*/
+                DWN_MSG("partCap 0x%llxMB, ClearSz=%llxMb\n", (partCap>>20), (ClearSz>>20));
+
+                for (; offset < ClearSz; offset += BufSz)
+                {
+                        rcode = store_write_ops(thePart, clearBuf, offset, BufSz);
+                        if (rcode) {
+                                DWN_ERR("Failed when clear data part[%s], rcode=%d\n", thePart, rcode);
+                                ret += rcode;
+                        }
+                }
+        }
+
+        return ret;
+}
+#endif//#if CONFIG_AML_SYS_RECOVERY_CLEAR_USR_DATA
+
+/*
+ *.partName: aml_sysrecovery
+ *.needVerify: 1 then verify partitions that contain verify file; 0 then not to verify for faster burning
+ */
+static int optimus_sysrec_burn_package_from_partition(const char* partName, const unsigned needVerifyWhileBurn,
+                const unsigned verifyPackageBeforeBurn)
+{
+        extern ConfigPara_t g_sdcBurnPara ;
+        ConfigPara_t* pSdcCfgPara = &g_sdcBurnPara;
+        __hdle hUiProgress = NULL;
+        HIMAGE hImg = NULL;
+        int ret = 0;
+
+        ret = optimus_storage_init(0);//Init all partitions for burning
+
+        if (verifyPackageBeforeBurn)
+        {
+                ret = optimus_sysrec_check_whole_img_before_burn(partName);
+                if (ret) {
+                        DWN_ERR("Failed in crc check the burning package.\n");
+                        return __LINE__;
+                }
+        }
+
+        hImg = image_open("store", "0", AML_SYS_RECOVERY_PART, "");
+        if (!hImg) {
+                DWN_ERR("Fail to open image in part %s\n", AML_SYS_RECOVERY_PART);
+                ret = __LINE__; goto _finish;
+        }
+
+        if (video_res_prepare_for_upgrade(hImg)) {
+                DWN_ERR("Fail when prepare bm res or init video for upgrade\n");
+                ret = __LINE__; goto _finish;
+        }
+        show_logo_to_report_burning();
+
+        hUiProgress = optimus_progress_ui_request_for_sdc_burn();
+        if (!hUiProgress) {
+                DWN_ERR("request progress handle failed!\n");
+                ret = __LINE__; goto _finish;
+        }
+        optimus_progress_ui_direct_update_progress(hUiProgress, UPGRADE_STEPS_AFTER_DISK_INIT_OK);
+
+        int hasBootloader = 0;
+        u64 datapartsSz = optimus_img_decoder_get_data_parts_size(hImg, &hasBootloader);
+        DWN_MSG("datapartsSz=[%8u]MB\n", (unsigned)(datapartsSz >> 20));
+        ret = optimus_progress_ui_set_smart_mode(hUiProgress, datapartsSz,
+                        UPGRADE_STEPS_FOR_BURN_DATA_PARTS_IN_PKG(!pSdcCfgPara->burnEx.bitsMap.mediaPath));
+        if (ret) {
+                DWN_ERR("Fail to set smart mode\n");
+                ret = __LINE__; goto _finish;
+        }
+
+        pSdcCfgPara->burnParts.burn_num = 0;
+        ret = optimus_sdc_burn_partitions(pSdcCfgPara, hImg, hUiProgress, needVerifyWhileBurn);
+        if (ret) {
+                DWN_ERR("Fail when burn partitions\n");
+                ret = __LINE__; goto _finish;
+        }
+
+        ret = optimus_sdc_burn_dtb_load(hImg);
+        if (ITEM_NOT_EXIST != ret && ret) {
+                DWN_ERR("Fail in load dtb for sdc_burn\n");
+                ret = __LINE__; goto _finish;
+        }
+        ret = optimus_save_loaded_dtb_to_flash();
+        if (ret) {
+                DWN_ERR("FAiled in dtb wr\n");
+                return __LINE__;
+        }
+
+        optimus_progress_ui_direct_update_progress(hUiProgress, UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK);
+
+#if CONFIG_AML_SYS_RECOVERY_CLEAR_USR_DATA
+        optimus_sysrec_clear_usr_data_parts();
+#endif// #if CONFIG_AML_SYS_RECOVERY_CLEAR_USR_DATA
+#if 1
+        if (hasBootloader)
+        {//burn bootloader
+                ret = optimus_burn_bootlader(hImg);
+                if (ret) {
+                        DWN_ERR("Fail in burn bootloader\n");
+                        goto _finish;
+                }
+                ret = optimus_set_burn_complete_flag();
+                if (ret) {
+                        DWN_ERR("Fail in set_burn_complete_flag\n");
+                        ret = __LINE__; goto _finish;
+                }
+        }
+#endif
+        optimus_progress_ui_direct_update_progress(hUiProgress, UPGRADE_STEPS_AFTER_BURN_BOOTLOADER_OK);
+
+_finish:
+        image_close(hImg);
+        optimus_progress_ui_report_upgrade_stat(hUiProgress, !ret);
+        optimus_report_burn_complete_sta(ret, 1/*pSdcCfgPara->custom.rebootAfterBurn*/);
+        optimus_progress_ui_release(hUiProgress);
+        //optimus_storage_exit();//temporary not exit storage driver when failed as may continue burning after burn
+        return ret;
+}
+
+static int do_aml_sysrecovery(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int rcode = 0;
+    unsigned needVerify         = (1 < argc) ? simple_strtoul(argv[1], NULL, 0) : 0;
+    unsigned verifyPackageBeforeBurn = (2 < argc) ? simple_strtoul(argv[2], NULL, 0) : 0;
+
+    if (argc < 2 ) {
+        cmd_usage(cmdtp);
+        return __LINE__;
+    }
+
+    show_logo_to_report_burning();//indicate enter flow of burning! when 'run update'
+    if (optimus_led_open(LED_TYPE_PWM)) {
+        DWN_ERR("Fail to open led for burn\n");
+        return __LINE__;
+    }
+    optimus_led_show_in_process_of_burning();
+
+    optimus_work_mode_set(OPTIMUS_WORK_MODE_SYS_RECOVERY);
+    rcode = optimus_sysrec_burn_package_from_partition(AML_SYS_RECOVERY_PART, needVerify, verifyPackageBeforeBurn);
+
+    return rcode;
+}
+
+U_BOOT_CMD(
+   aml_sysrecovery,     //command name
+   3,                   //maxargs
+   0,                   //repeatable
+   do_aml_sysrecovery,         //command function
+   "Burning with amlogic format package from partition sysrecovery",           //description
+   "argv: needVerify [,checkWholeImgBeforeBurn]\n"//usage
+   "    --@needVerify: 0 then skip to verify the partition even have verify file."
+   "    --@checkWholeImgBeforeBurn: 1 then crc32 check the burn package in partition sysrecovery before actual burn"
+   "   eg:'aml_sysrecovery 0': burn from partition aml_sysrecovery without verify"
+);
+
diff --git a/drivers/usb/gadget/v2_burning/aml_sysrecovery/cmd_detect_sys_recovery_key.c b/drivers/usb/gadget/v2_burning/aml_sysrecovery/cmd_detect_sys_recovery_key.c
new file mode 100644
index 0000000..0a33f97
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/aml_sysrecovery/cmd_detect_sys_recovery_key.c
@@ -0,0 +1,108 @@
+/*
+ * \file        cmd_detect_sys_recovery_key.c
+ * \brief       Detect whether user want to enter sys_recovery
+ *
+ * \version     1.0.0
+ * \date        14/11/25
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2014 Amlogic. All Rights Reserved.
+ *
+ */
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+#include <command.h>
+#include <malloc.h>
+#include <amlogic/gpio.h>
+
+#define debugP(fmt...) //printf("L%d:", __LINE__),printf(fmt)
+#define errorP(fmt...) printf("[ERR]L%d:", __LINE__),printf(fmt)
+#define MsgP(fmt...)   printf("[msg]"fmt)
+
+static int store_key_open(const char* keyName, const char* keyType)
+{
+        int pin = -1;
+
+        pin=gpioname_to_pin(keyName);
+        if (pin<0) {
+                errorP("wrong gpio name %s\n",keyName);
+                return -1;
+        }
+        udelay(100);
+
+        return pin;
+}
+
+static int is_sys_recovery_key_pressed(int hKey)
+{
+        int val = -1;
+
+        val=amlogic_get_value(hKey);
+
+        return val != 1;
+}
+
+static int assert_key_is_pressed_in_a_period(unsigned nMillSeconds, const char* keyName, const char* keyType)
+{
+        unsigned start = 0;
+        int hKey = -1;
+
+        hKey = store_key_open(keyName, keyType);
+        if (hKey < 0) {
+                errorP("Fail to init key for aml_sysrecovery, hKey=%d\n", hKey);
+                return __LINE__;
+        }
+
+        if (!is_sys_recovery_key_pressed(hKey)) {
+                return __LINE__;
+        }
+
+        MsgP("pin=%d\n",hKey);
+        start = get_timer(0);
+        while (is_sys_recovery_key_pressed(hKey))
+        {
+                const unsigned pressTime = (unsigned)get_timer(start) ;
+                if (pressTime > nMillSeconds) {
+                        MsgP("store key pressed time %d[ms]\n", pressTime);
+                        return 0;
+                }
+        }
+        if (!is_sys_recovery_key_pressed(hKey)) {
+                MsgP("key released in time %u[ms]\n", (unsigned)get_timer(start));
+                return __LINE__;
+        }
+
+        return 1;//restore key released in time @nMillSeconds
+}
+
+//test If the recovery_key pressed time >= @nMillSeconds
+int do_sys_rec_key(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int rcode = 0;
+    unsigned nMillSeconds = 0;
+    const char* keyName =  NULL;
+    const char* keyType = "gpio";
+
+    if (2 > argc) {
+        cmd_usage(cmdtp);
+        return __LINE__;
+    }
+
+    nMillSeconds = simple_strtoul(argv[1], NULL, 0);
+    keyName = argc > 2 ? argv[2] :"GPIOX_16";
+    rcode = assert_key_is_pressed_in_a_period(nMillSeconds, keyName, keyType);
+
+    return rcode;
+}
+
+
+U_BOOT_CMD(
+   get_restore_key,      //command name
+   5,               //maxargs
+   1,               //repeatable
+   do_sys_rec_key,   //command function
+   "check if user press sys_recovery key",           //description
+   "Usage: sys_recovery nMillSeconds [GPIOX_16] [key_type]\n"   //usage
+);
+
diff --git a/drivers/usb/gadget/v2_burning/aml_v2_burning.c b/drivers/usb/gadget/v2_burning/aml_v2_burning.c
new file mode 100644
index 0000000..c8f6523
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/aml_v2_burning.c
@@ -0,0 +1,172 @@
+/*
+ * \file        aml_v2_burning.c
+ * \brief       common interfaces for version 2 burning
+ *
+ * \version     1.0.0
+ * \date        09/15/2013
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#include "v2_burning_i.h"
+#include <mmc.h>
+#include <asm/arch/secure_apb.h>
+#include <asm/arch/io.h>
+#include <asm/arch/bl31_apis.h>
+
+#ifndef BOOT_DEVICE_USB
+#define BOOT_DEVICE_SD                  4
+#define BOOT_DEVICE_USB                 5
+#endif// #ifndef BOOT_DEVICE_USB
+
+extern int v2_usbburning(unsigned timeout);
+extern int optimus_burn_package_in_sdmmc(const char* sdc_cfg_file);
+extern void close_usb_phy_clock(int cfg);
+
+//check ${sdcburncfg} exist in external mmc and internal flash not burned yet!
+int aml_check_is_ready_for_sdc_produce(void)
+{
+    char* sdc_cfg_file = NULL;
+    const char* cmd = NULL;
+    int ret = 0;
+
+    //if reboot_mode is MESON_SDC_BURNER_REBOOT, then this booting is skip_booted for sdc_burning
+    if (/*MESON_SDC_BURNER_REBOOT != reboot_mode*/ 0) {
+            /*DWN_MSG("reboot_mode=0x%x\n", (unsigned int)reboot_mode);*/
+            return 1;//not ready
+    }
+
+    cmd = "mmcinfo";
+    ret = run_command(cmd, 0);
+    if (ret) {
+        DWN_MSG("mmcinfo failed!\n");
+        return 0;//not ready
+    }
+
+    sdc_cfg_file = getenv("sdcburncfg");
+    if (!sdc_cfg_file) {
+        sdc_cfg_file = "aml_sdc_burn.ini";
+        setenv("sdcburncfg", sdc_cfg_file); }
+
+    cmd = "fatsize mmc 0 ${sdcburncfg}";
+    ret = run_command(cmd, 0);
+    if (ret) {
+        DWN_DBG("%s not exist\n", sdc_cfg_file);
+        return 0;
+    }
+
+    return 1;//is ready for sdcard producing
+}
+
+static unsigned _get_romcode_boot_id(void)
+{
+        DWN_DBG("P_AO_SEC_GP_CFG0=0x%p\n", P_AO_SEC_GP_CFG0);
+        const unsigned boot_id = readl(P_AO_SEC_GP_CFG0) & 0xf;
+
+        DWN_DBG("boot_id()=%x\n", boot_id);
+        return boot_id;
+}
+
+//is the uboot loaded from usb otg
+int is_tpl_loaded_from_usb(void)
+{
+        const int boot_id  = _get_romcode_boot_id();
+        const unsigned forceUsbBoot = readl(P_AO_SEC_GP_CFG7) ;
+        DWN_DBG("forceUsbBoot=%p, %x\n", P_AO_SEC_GP_CFG7, forceUsbBoot);
+        int ret = (BOOT_DEVICE_USB == boot_id) || ( forceUsbBoot & (1U<<31) );
+
+        return ret;
+}
+
+//is the uboot loaded from sdcard mmc 0
+//note only sdmmc supported by romcode when external device boot
+int is_tpl_loaded_from_ext_sdmmc(void)
+{
+    return (BOOT_DEVICE_SD == _get_romcode_boot_id());
+}
+
+//Check if uboot loaded from external sdmmc or usb otg
+int aml_burn_check_uboot_loaded_for_burn(int flag)
+{
+    int usb_boot = is_tpl_loaded_from_usb();
+    int sdc_boot = is_tpl_loaded_from_ext_sdmmc();
+
+    return usb_boot || sdc_boot;
+}
+
+//1, is booted from external sdmmc: check if aml_sdc_burn.ini existed
+//2, if loaded from usb, ready for burn
+int aml_burn_check_is_ready_for_burn(int flag, bd_t* bis)
+{
+        if (is_tpl_loaded_from_usb()) {
+                return 1;
+        }
+
+        if (is_tpl_loaded_from_ext_sdmmc())
+        {
+                return aml_check_is_ready_for_sdc_produce();
+        }
+
+        return 0;
+}
+
+//producing mode means boot from raw flash, i.e, uboot is loaded from usb
+int aml_burn_usb_producing(int flag, bd_t* bis)
+{
+    flag = flag; bis = bis;//avoid compile warning
+
+    set_usb_boot_function(CLEAR_USB_BOOT);
+    optimus_work_mode_set(OPTIMUS_WORK_MODE_USB_PRODUCE);
+
+    close_usb_phy_clock(0);//disconect before re-connect to enhance pc compatibility
+    return v2_usbburning(20000);
+}
+
+int aml_burn_sdc_producing(int flag, bd_t* bis)
+{
+    optimus_work_mode_set(OPTIMUS_WORK_MODE_SDC_PRODUCE);
+
+    return optimus_burn_package_in_sdmmc(getenv("sdcburncfg"));
+}
+
+//burning flash from romboot stage
+int aml_burn_factory_producing(int flag, bd_t* bis)
+{
+        if (is_tpl_loaded_from_usb())
+        {
+                return aml_burn_usb_producing(flag, bis);
+        }
+
+        if (is_tpl_loaded_from_ext_sdmmc())
+        {
+                return aml_burn_sdc_producing(flag, bis);
+        }
+
+        DWN_ERR("Shouldnot reach here!\n");
+        return 0;
+}
+
+int aml_try_factory_usb_burning(int flag, bd_t* bis)
+{
+        if (!is_tpl_loaded_from_usb()) return 1;
+
+#ifdef CONFIG_GENERIC_MMC
+        DWN_MSG("MMC init in usb\n");
+	mmc_initialize(bis);
+#endif
+        return aml_burn_usb_producing(flag, bis);
+}
+
+int aml_try_factory_sdcard_burning(int flag, bd_t* bis)
+{
+        if (!is_tpl_loaded_from_ext_sdmmc()) return 1;
+
+        if ( aml_check_is_ready_for_sdc_produce() )
+        {
+            return aml_burn_sdc_producing(flag, bis);
+        }
+
+        return 0;
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_burning_i.h b/drivers/usb/gadget/v2_burning/v2_burning_i.h
new file mode 100644
index 0000000..38d8072
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_burning_i.h
@@ -0,0 +1,38 @@
+/*
+ * \file        v2_burning_i.h
+ * \brief       internal include interfaces
+ *
+ * \version     1.0.0
+ * \date        2013/11/4
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+
+#ifndef __V2_BURNING_I_H__
+#define __V2_BURNING_I_H__
+
+#include <config.h>
+#include <common.h>
+#include <environment.h>
+#include <asm/string.h>
+#include <asm-generic/errno.h>
+#include <asm/byteorder.h>
+#include <malloc.h>
+#include <u-boot/sha1.h>
+
+#include <amlogic/aml_v2_burning.h>
+//#include <asm/arch/reboot.h>
+#include <asm/arch/romboot.h>
+//#include <amlogic/aml_lcd.h>
+#include <amlogic/storage_if.h>
+#include "v2_common/sparse_format.h"
+#include "v2_common/optimus_download.h"
+#include "v2_common/amlImage_if.h"
+#include "v2_common/optimus_progress_ui.h"
+
+extern int cli_simple_parse_line(char *line, char *argv[]);
+
+#endif//ifndef __V2_BURNING_I_H__
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/amlImage_if.h b/drivers/usb/gadget/v2_burning/v2_common/amlImage_if.h
new file mode 100644
index 0000000..15373c1
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/amlImage_if.h
@@ -0,0 +1,124 @@
+/* * \file        amlImage_if.h
+ * \brief       Amlogic firmware image interface
+ *
+ * \version     1.0.0
+ * \date        2013/5/21
+ * \author      Sam.Wu <yihui.wu@Amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc. All Rights Reserved.
+ *
+ */
+#ifndef __AMLIMAGE_IF_H__
+#define __AMLIMAGE_IF_H__
+
+#define IMAGE_MAGIC	                0x27b51956	 /* Image Magic Number		*/
+
+#define AML_FRMWRM_VER_V1       0X01
+#define AML_FRMWRM_VER_V2       0X02
+#define ITEM_NAME_LEN_V1        0X20
+#define ITEM_NAME_LEN_V2        0X100
+
+typedef void*               __hdle;
+
+#pragma pack(push,4)
+typedef struct _AmlFirmwareItem_s
+{
+    __u32           itemId;
+    __u32           fileType;           //image file type, sparse and normal
+    __u64           curoffsetInItem;    //current offset in the item
+    const __u64     offsetInImage;      //item offset in the image
+    const __u64     itemSz;             //item size in the image
+    char            itemMainType[ITEM_NAME_LEN_V1];   //item main type and sub type used to index the item
+    char            itemSubType[ITEM_NAME_LEN_V1];    //item main type and sub type used to index the item
+    char            reserve[32];//don't care fields
+}ItemInfo_V1;
+#pragma pack(pop)
+
+#pragma pack(push,4)
+typedef struct _AmlFirmwareItem2_s
+{
+    __u32           itemId;
+    __u32           fileType;           //image file type, sparse and normal
+    __u64           curoffsetInItem;    //current offset in the item
+    const __u64     offsetInImage;      //item offset in the image
+    const __u64     itemSz;             //item size in the image
+    char            itemMainType[ITEM_NAME_LEN_V2];   //item main type and sub type used to index the item
+    char            itemSubType[ITEM_NAME_LEN_V2];    //item main type and sub type used to index the item
+    char            reserve[32];//don't care fields
+}ItemInfo_V2;
+#pragma pack(pop)
+
+#pragma pack(push,4)
+typedef struct _AmlFirmwareImg_s
+{
+        __u32      crc;             //check sum of the image
+        __u32      version;         //firmware version
+        __u32      magic;           //magic No. to say it is Amlogic firmware image
+        __u64      imageSz;         //total size of this image file
+        __u32      itemAlginSize;   //align size for each item
+        __u32      itemNum;         //item number in the image, each item a file
+        char       reserve[36];
+}AmlFirmwareImg_t;
+#pragma pack(pop)
+
+
+typedef void* HIMAGE;
+typedef void* HIMAGEITEM;
+
+#define IMAGE_ITEM_TYPE_NORMAL  0
+#define IMAGE_ITEM_TYPE_SPARSE  0XFE
+
+enum {
+        IMAGE_IF_TYPE_MMC       = 0XEE,         //read amlogic burning package from 'mmc 0/1'
+        IMAGE_IF_TYPE_USB             ,         //read amlogic burning package from 'usb 0'
+        IMAGE_IF_TYPE_STORE           ,         //read amlogic burning package using store interface
+};
+
+#define IMG_OFFSET_IN_PART      0
+
+//open a Amlogic firmware image
+//return value is a handle
+HIMAGE image_open(const char* interface, const char* device, const char* part, const char* imgPath);
+
+//check the image's crc32
+//return 0 when check ok,otherwise return -1
+int image_check(HIMAGE hImg);
+
+//close a Amlogic firmware image
+int image_close(HIMAGE hImg);
+
+//get item count of specify main type
+int image_get_item_count(HIMAGE hImg, const char* mainType);
+
+//open a item in the image
+//@hImage: image handle;
+//@mainType, @subType: main type and subtype to index the item, such as ["IMAGE", "SYSTEM"]
+HIMAGEITEM image_item_open(HIMAGE hImg, const char* mainType, const char* subType);
+
+//close a item
+int image_item_close(HIMAGEITEM hItem);
+
+__u64 image_item_get_size(HIMAGEITEM hItem);
+
+
+//get image item type, current used type is normal or sparse
+int image_item_get_type(HIMAGEITEM hItem);
+
+//read item data, like standard fread
+int image_item_read(HIMAGE hImg, HIMAGEITEM hItem, void* pBuf, const __u32 wantSz);
+
+//relocate the read pointer to read the item data, like standard fseek
+int image_item_seek(HIMAGE , HIMAGEITEM , __s64 , __u32 );
+
+unsigned image_item_get_first_cluster_size(HIMAGE hImg, HIMAGEITEM hItem);
+unsigned image_get_cluster_size(HIMAGEITEM hImg);//Assert read offset and read size is multiple size of thsi unit
+
+int get_item_name(HIMAGE hImg, int itemId, const char** main_type, const char** sub_type);
+
+int get_total_itemnr(HIMAGE hImg);
+
+u64 optimus_img_decoder_get_data_parts_size(HIMAGE hImg, int* hasBootloader);
+
+
+#endif//ifndef __AMLIMAGE_IF_H__
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_buffer_manager.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_buffer_manager.c
new file mode 100644
index 0000000..71b533f
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_buffer_manager.c
@@ -0,0 +1,320 @@
+/*
+ * \file        optimus_buffer_manager.c
+ * \brief       buffer manager for download data: A thin layer between receiving partition data and writing flash
+ *
+ * \version     1.0.0
+ * \date        2013/5/2
+ * \author      Sam.Wu <yihui.wu@Amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+#include "../v2_burning_i.h"
+
+#define OPTIMUS_SLOT_STA_FREE               (0)//buffer slot not used yet
+#define OPTIMUS_SLOT_STA_USED               (0xee)//buffer slot current used for download
+#define OPTIMUS_SLOT_STA_LEFT               (0xdd)//buffer slot not disposed over
+
+#define PKT_TRANSFER_STA_EMPTY              0
+#define PKT_TRANSFER_STA_WORKING            1
+#define PKT_TRANSFER_STA_END                2
+
+typedef struct bufManager{
+    const u8*       transferBuf;//transfer buffer address
+    const u32       transferBufSz;//transfer buffer size to
+
+    const u32       transferUnitSz;//64k
+    u32             writeBackUnitSz;//for NAND is transferSz, for sparse is transferUnitSz
+
+    u64             tplcmdTotalSz;//total size of a file-system packet
+
+    u32             totalSlotNum;//total slot number that already tranfferred
+    u32             mediaAlignSz;//nand write align size, 16K/32k
+
+    u32             nextWriteBackSlot;//when reach n* (writeBackUnitSz/transferUnitSz), then write back the recevied data to media
+    u32             leftDataSz;//left data size, Assert that 'leftDataInBackBuf + leftDataSz == transferBuf'
+
+    s16             isUpload;
+    s16             pktTransferSta;
+    u32             destMediaType;
+
+    u32             partBaseOffset;//TODO: change it to memory address when dest media type is memory
+    u32             itemOffsetNotAlignClusterSz_f;//For sdcard burning, item offset of aml_upgrade_package.img is not aligned to bytespercluster of FAT fs(_f means not changed inited)
+
+}BufManager;
+
+//TODO: if want to speed-up such as soft PING-PONG buffer, use multiple BufManager
+static BufManager _bufManager =
+{
+//constant members
+    .transferBuf        = (const u8*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR,
+    .transferBufSz      = OPTIMUS_DOWNLOAD_TRANSFER_BUF_TOTALSZ,
+    .transferUnitSz     = OPTIMUS_DOWNLOAD_SLOT_SZ,
+
+//different for each command, note a command corresponding to a download file
+//must create/destroy for a command
+    .writeBackUnitSz    = OPTIMUS_DOWNLOAD_SLOT_SZ,
+
+    .totalSlotNum      = 0,//not slot data recevied yet!
+
+    .leftDataSz         = 0,
+    .tplcmdTotalSz      = 0,
+    .nextWriteBackSlot  = 0,//always 0 when upload??
+
+    .isUpload           = 0,
+    .pktTransferSta     = PKT_TRANSFER_STA_EMPTY,
+
+    .itemOffsetNotAlignClusterSz_f  = 0,
+};
+
+int optimus_buf_manager_init(const unsigned mediaAlignSz)
+{
+    if (OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR != (uint64_t)_bufManager.transferBuf) {
+        DWN_ERR("Fatal fail in init-express, init here instead!\n");
+        return OPT_DOWN_FAIL;
+    }
+    _bufManager.mediaAlignSz = mediaAlignSz;
+
+    DWN_DBG("transfer=0x%p, transferBufSz=0x%x, transferUnitSz=0x%x, writeBackUnitSz=0x%x, totalSlotNum=%d\n", _bufManager.transferBuf,
+            _bufManager.transferBufSz,  _bufManager.transferUnitSz,     _bufManager.writeBackUnitSz,        _bufManager.totalSlotNum);
+
+    return OPT_DOWN_OK;
+}
+
+int optimus_buf_manager_exit(void)
+{
+    return 0;
+}
+
+int optimus_buf_manager_tplcmd_init(const char* mediaType,  const char* partName,   const u64 partBaseOffset,
+                            const char* imgType, const u64 pktTotalSz, const int isUpload,
+                            const unsigned itemSizeNotAligned /* if item offset 3 and bytepercluste 4k, then it's 4k -3 */)
+{
+    u32 writeBackUnitSz = OPTIMUS_VFAT_IMG_WRITE_BACK_SZ;
+    const u64 pktSz4BufManager = pktTotalSz - itemSizeNotAligned;
+
+    if (!strcmp("sparse", imgType)
+            || itemSizeNotAligned/* use max memory if item 'itemOffset % bytespercluster != 0'*/)
+    {
+        writeBackUnitSz = OPTIMUS_SIMG_WRITE_BACK_SZ;
+    }
+
+    if (!strcmp("bootloader", partName))
+    {
+        if (pktSz4BufManager > _bufManager.transferBufSz) {
+            DWN_ERR("packet size 0x%x too large, max is 0x%x\n", (u32)pktSz4BufManager, _bufManager.transferBufSz);
+            return OPT_DOWN_FAIL;
+        }
+        /*writeBackUnitSz = OPTIMUS_BOOTLOADER_MAX_SZ;*/
+        writeBackUnitSz             = pktSz4BufManager + _bufManager.transferUnitSz - 1;
+        writeBackUnitSz             >>= OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS;
+        writeBackUnitSz             <<= OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS;
+    }
+
+    _bufManager.destMediaType   = OPTIMUS_MEDIA_TYPE_STORE;
+    if (!strcmp("mem", mediaType))
+    {
+            writeBackUnitSz             = pktSz4BufManager + _bufManager.transferUnitSz - 1;
+            writeBackUnitSz             >>= OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS;
+            writeBackUnitSz             <<= OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS;
+
+        _bufManager.destMediaType   = OPTIMUS_MEDIA_TYPE_MEM;
+
+        if (partBaseOffset>>32) {
+            DWN_ERR("partBaseOffset 0x%llx more than 4G!!\n", partBaseOffset);
+            return OPT_DOWN_FAIL;
+        }
+        _bufManager.partBaseOffset = (u32)partBaseOffset;
+    }
+
+    if (_bufManager.transferBufSz < writeBackUnitSz && strcmp("mem", mediaType)) {
+        DWN_ERR("write back size 0x%x > max size 0x%x\n", writeBackUnitSz, _bufManager.transferBufSz);
+        return OPT_DOWN_FAIL;
+    }
+    if (_bufManager.transferUnitSz > writeBackUnitSz) {
+        DWN_ERR("write back size %d < align size %d\n", writeBackUnitSz, _bufManager.mediaAlignSz);
+        return OPT_DOWN_FAIL;
+    }
+    DWN_DBG("writeBackUnitSz = 0x%x, pktSz4BufManager = %lld\n", writeBackUnitSz, pktSz4BufManager);
+
+    _bufManager.writeBackUnitSz     = writeBackUnitSz;
+    _bufManager.totalSlotNum        = 0;
+    _bufManager.isUpload            = isUpload;
+    _bufManager.pktTransferSta      = PKT_TRANSFER_STA_EMPTY;
+
+    if (_bufManager.isUpload)
+    {
+        _bufManager.nextWriteBackSlot = 0;//always 0 if upload
+    }
+    else//has write back if download
+    {
+        if (pktSz4BufManager < writeBackUnitSz)
+        {
+            _bufManager.nextWriteBackSlot  = ((u32)pktSz4BufManager + _bufManager.transferUnitSz - 1)/_bufManager.transferUnitSz;//first slot index to write back to media
+        }
+        else
+        {
+            _bufManager.nextWriteBackSlot  = writeBackUnitSz/_bufManager.transferUnitSz;//first slot index to write back to media
+        }
+
+    }
+
+    _bufManager.itemOffsetNotAlignClusterSz_f = itemSizeNotAligned;
+    _bufManager.leftDataSz                  = itemSizeNotAligned;//data size in the buffer that not write back to media yet in previous transfer
+    _bufManager.tplcmdTotalSz               = pktSz4BufManager;
+
+    optimus_progress_init((u32)(_bufManager.tplcmdTotalSz>>32), (u32)_bufManager.tplcmdTotalSz, 0, 100);
+    DWN_MSG("totalSlotNum = %d, nextWriteBackSlot %d\n", _bufManager.totalSlotNum, _bufManager.nextWriteBackSlot);
+
+    return OPT_DOWN_OK;
+}
+
+int optimus_buf_manager_get_buf_for_bulk_transfer(char** pBuf, const unsigned wantSz, const unsigned sequenceNo, char* errInfo)
+{
+    const unsigned totalSlotNum      = _bufManager.totalSlotNum;
+    const u64 totalTransferSz        = ((u64)totalSlotNum) * _bufManager.transferUnitSz;//data size already transferred
+    const u64 leftPktSz              = (totalTransferSz > _bufManager.tplcmdTotalSz) ? 0 :(_bufManager.tplcmdTotalSz - totalTransferSz);
+    const int isLastTransfer         = (leftPktSz == wantSz);//totalTransferSz + wantSz >= _bufManager.tplcmdTotalSz;
+    const u32 bufSzNotDisposed       = ((u32)totalTransferSz)% _bufManager.writeBackUnitSz;//buffer data not disposed, bufSz is always writeBackUnitSz
+    const u8* BufBase = (OPTIMUS_MEDIA_TYPE_MEM != _bufManager.destMediaType)  ? _bufManager.transferBuf :
+                        (u8*)(u64)_bufManager.partBaseOffset ;
+
+    if (wantSz < _bufManager.transferUnitSz && !isLastTransfer) {
+        DWN_ERR("only last transfer can less 64K, this index %d at size 0x%u illegle\n", totalSlotNum + 1, wantSz);
+        return OPT_DOWN_FAIL;
+    }
+
+    //TODO: totalSlotNum + 1 == sequenceNo
+    if (totalSlotNum + 1 != sequenceNo) {//ASSERT it ??
+
+    }
+
+    *pBuf  = (char*)(bufSzNotDisposed + BufBase);
+    DWN_DBG("bufSzNotDisposed 0x%x, _bufManager.transferBuf 0x%p, _bufManager.partBaseOffset 0x%x, *pBuf 0x%p\n",
+            bufSzNotDisposed, _bufManager.transferBuf, _bufManager.partBaseOffset, *pBuf);
+
+    _bufManager.pktTransferSta      = PKT_TRANSFER_STA_WORKING;
+
+    //prepare data for upload
+    if (!bufSzNotDisposed && _bufManager.isUpload)
+    {
+        u32 wantSz = (leftPktSz > _bufManager.writeBackUnitSz) ? _bufManager.writeBackUnitSz : ((u32)leftPktSz);
+        DWN_DBG("want size 0x%x\n", wantSz);
+
+        u32 readSz = optimus_dump_storage_data((u8*)BufBase, wantSz, errInfo);
+        if (readSz != wantSz) {
+            DWN_ERR("Want read %u, but %u\n", wantSz, readSz);
+            return OPT_DOWN_FAIL;
+        }
+    }
+
+    return OPT_DOWN_OK;
+}
+
+int optimus_buf_manager_report_transfer_complete(const u32 transferSz, char* errInfo)
+{
+    const unsigned totalSlotNum      = _bufManager.totalSlotNum;
+    const u64 totalTransferSz        = ((u64)totalSlotNum) * _bufManager.transferUnitSz + transferSz;
+    const u64 leftPktSz              = (totalTransferSz > _bufManager.tplcmdTotalSz) ? 0 :(_bufManager.tplcmdTotalSz - totalTransferSz);
+    const u32 thisWriteBackSz        = (_bufManager.transferUnitSz == transferSz) ? _bufManager.writeBackUnitSz : ((u32)totalTransferSz % _bufManager.writeBackUnitSz);
+    const u8* BufBase = (OPTIMUS_MEDIA_TYPE_MEM != _bufManager.destMediaType)  ? _bufManager.transferBuf :
+                        (u8*)(u64)_bufManager.partBaseOffset ;
+
+    DWN_DBG("transferSz=0x%x\n", transferSz);
+    //state fileds to update
+    _bufManager.totalSlotNum += 1;
+    if (_bufManager.totalSlotNum == _bufManager.nextWriteBackSlot)
+    {
+        u32   burnSz   = 0;
+        u32   leftSz   = _bufManager.leftDataSz;//data size not write to media in previous write back, > 0 only when not normal packet
+        const u32 size = leftSz + thisWriteBackSz;
+        const u8* data = (u8*)BufBase -leftSz;
+        const unsigned reserveNotAlignSz = leftPktSz ? _bufManager.itemOffsetNotAlignClusterSz_f : 0;//reserve
+
+        //call cb function to write to media
+        DWN_DBG("size 0x%x, reserveNotAlignSz 0x%x\n", size, reserveNotAlignSz);
+        burnSz = optimus_download_img_data(data, size - reserveNotAlignSz, errInfo);
+        if (burnSz <= leftSz || !burnSz) {
+            DWN_ERR("this burn size %d <= last left size %d, data 0x%p\n", burnSz, leftSz, data);
+            return OPT_DOWN_FAIL;
+        }
+        if (size - reserveNotAlignSz < burnSz) {
+            DWN_ERR("Exception:siz 0x%x < burnSz 0x%x\n", size - reserveNotAlignSz, burnSz);
+            return OPT_DOWN_FAIL;
+        }
+
+        leftSz = size - burnSz;
+        if (leftSz)
+        {
+            const u8* src = data + burnSz;
+            u8* dest = (u8*)BufBase - leftSz;
+
+            if (totalTransferSz >= _bufManager.tplcmdTotalSz) {
+                DWN_ERR("Exception:packet end but data left 0x%x, totalTransferSz 0x%llx, cmd sz 0x%llx!\n",
+                        leftSz, totalTransferSz, _bufManager.tplcmdTotalSz);
+                return OPT_DOWN_FAIL;
+            }
+
+            if (leftSz > OPTIMUS_SPARSE_IMG_LEFT_DATA_MAX_SZ) {
+                DWN_ERR("Exception, left data sz 0x%x > back buf sz 0x%x!\n", leftSz, OPTIMUS_SPARSE_IMG_LEFT_DATA_MAX_SZ);
+                return OPT_DOWN_FAIL;
+            }
+            if (leftSz & 0x03) {
+                DWN_ERR("Exception, copy size not align to 4! May will copy fail!\n");
+                return OPT_DOWN_FAIL;
+            }
+
+            DWN_DBG("MV:left size 0x%08x, src %p, dest %p\n", leftSz, src, dest);
+            memcpy(dest, src, leftSz);
+        }
+
+        //update _bufManager.leftDataSz and _bufManager.nextWriteBackSlot
+        _bufManager.leftDataSz = leftSz;
+        if (leftPktSz >= _bufManager.writeBackUnitSz)
+        {
+            _bufManager.nextWriteBackSlot += _bufManager.writeBackUnitSz/_bufManager.transferUnitSz;
+        }
+        else
+        {
+            _bufManager.nextWriteBackSlot += ((u32)leftPktSz + _bufManager.transferUnitSz - 1)/_bufManager.transferUnitSz;
+        }
+    }
+
+    optimus_update_progress(transferSz);//report burning steps
+    return OPT_DOWN_OK;
+}
+
+int is_largest_data_transferring(void)
+{
+    const unsigned totalSlotNum      = _bufManager.totalSlotNum;
+    const u64 totalTransferSz        = ((u64)totalSlotNum) * _bufManager.transferUnitSz;//data size already transferred
+
+    return (PKT_TRANSFER_STA_WORKING == _bufManager.pktTransferSta)
+        && (_bufManager.tplcmdTotalSz > totalTransferSz);//as last packet may less than 64k, var totalSlotNum may > _bufManager.tplcmdTotalSz
+}
+
+int set_largest_data_transfer_sta_end(void)
+{
+    _bufManager.pktTransferSta = PKT_TRANSFER_STA_END;
+    return 0;
+}
+
+//command data format: [0-3]reserver, [4-7]dataLen, [8-11]sequence number, [12-15]check sum
+int optimus_buf_manager_get_command_data_for_upload_transfer(u8* cmdDataBuf, const unsigned bufLen)
+{
+    const unsigned totalSlotNum      = _bufManager.totalSlotNum;
+    const u64 totalTransferSz        = ((u64)totalSlotNum) * _bufManager.transferUnitSz;
+    const u64 leftPktSz              = (totalTransferSz > _bufManager.tplcmdTotalSz) ? 0 :(_bufManager.tplcmdTotalSz - totalTransferSz);
+    const unsigned thisTransDataLen = (leftPktSz > _bufManager.transferUnitSz) ? _bufManager.transferUnitSz : ((u32)leftPktSz);
+
+    DWN_DBG("thisTransDataLen 0x%x, left 0x%x, total 0x%x\n", thisTransDataLen, (u32)leftPktSz, (u32)totalTransferSz);
+    DWN_DBG("totalSlotNum %d, totalTransferSz 0x%x\n", totalSlotNum, (u32)totalTransferSz);
+    memset(cmdDataBuf, bufLen, 0);
+    *(unsigned*)(cmdDataBuf + 0) = 0xefe8;
+    *(unsigned*)(cmdDataBuf + 4) = thisTransDataLen;//Fill transfer data length of this bulk transfer
+
+    _bufManager.pktTransferSta      = PKT_TRANSFER_STA_WORKING;
+    return 0;
+}
+
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_download.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_download.c
new file mode 100644
index 0000000..a67c726
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_download.c
@@ -0,0 +1,1272 @@
+/*
+ * \file        optimu_download.c
+ * \brief
+ *
+ * \version     1.0.0
+ * \date        2013/4/25
+ * \author      Sam.Wu <yihui.wu@amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc. All Rights Reserved.
+ *
+ */
+#include "../v2_burning_i.h"
+#include <libfdt.h>
+#include <partition_table.h>
+#include <asm/arch/secure_apb.h>
+#include <asm/arch/bl31_apis.h>
+#include <asm/io.h>
+
+extern unsigned int get_multi_dt_entry(unsigned long fdt_addr);
+int is_optimus_storage_inited(void);
+
+#if !defined(CONFIG_UNIFY_KEY_MANAGE)
+int v2_key_read(const char* keyName, u8* keyVal, const unsigned keyValLen, char* errInfo, unsigned* fmtLen)
+{
+    DWN_ERR("burn key not supported as CONFIG_UNIFY_KEY_MANAGE undef!!");
+    return OPT_DOWN_FAIL;
+}
+
+unsigned v2_key_burn(const char* keyName, const u8* keyVal, const unsigned keyValLen, char* errInfo)
+{
+    DWN_ERR("burn key not supported as CONFIG_UNIFY_KEY_MANAGE undef!!");
+    return OPT_DOWN_FAIL;
+}
+
+int v2_key_command(const int argc, char * const argv[], char *info)
+{
+
+    DWN_ERR("burn key not supported as CONFIG_UNIFY_KEY_MANAGE undef!!");
+    return OPT_DOWN_FAIL;
+}
+#endif//#ifndef CONFIG_UNIFY_KEY_MANAGE
+
+static unsigned long _dtb_is_loaded = 0;
+
+
+#define IMG_VERIFY_ALG_NONE     0 //not need to veryfy
+#define IMG_VERIFY_ALG_SHA1SUM  1
+#define IMG_VERIFY_ALG_CRC32    2
+#define IMG_VERIFY_ALG_ADDSUM   3
+
+#define OPTIMUS_IMG_STA_EMPTY           0
+#define OPTIMUS_IMG_STA_PRE_BURN        1 //has get tplcmd load
+#define OPTIMUS_IMG_STA_BURN_ING        2
+#define OPTIMUS_IMG_STA_BURN_COMPLETE   3
+#define OPTIMUS_IMG_STA_BURN_FAILED     4
+#define OPTIMUS_IMG_STA_VERIFY_ING      5
+#define OPTIMUS_IMG_STA_VERIFY_END      6
+
+#define IMG_TYPE_SPARSE (0xfe)
+#define IMG_TYPE_NORMAL 0
+#define IMG_TYPE_BOOTLOADER (0xfd)
+
+//Image info for burnning and verify
+//FIXME: how to assert that image not larger than the partition
+#define IMG_BURN_INFO_SZ    96
+struct ImgBurnInfo{
+    u8  imgType;    //0 normal, 1 sparse
+    u8  verifyAlgorithm;//0--sha1sum, 1--crc32, 2--addsum
+    u8  imgBurnSta;//
+    u8  storageMediaType;//NAND default,
+    u8  resrv4Align[4];
+
+    u64 nextMediaOffset;//image size already  received
+    u64 imgPktSz;//total size of the file image
+    u64 imgSzDisposed;//total size alreay disposed
+    u64 partBaseOffset;//start offset of this part
+
+    void* devHdle;
+    char partName[32];//
+
+    u8  burnInfoPrivate[IMG_BURN_INFO_SZ - 32 - sizeof(void*) - sizeof(u64) * 5];//needed private info when verify, for example when we read ext4 to sparse file
+};
+
+static struct ImgBurnInfo OptimusImgBurnInfo = {0};
+
+struct imgBurnInfo_sparse{
+
+};
+
+struct imgBurnInfo_normal{
+};
+
+struct imgBurnInfo_bootloader{
+    u32     transferBufAddr;
+    u32     transferBufSzTotal;
+
+};
+
+COMPILE_TIME_ASSERT(IMG_BURN_INFO_SZ == sizeof(struct ImgBurnInfo));
+
+#if 1
+//asset logical partition size >= CFG size in storage.c
+//nand often make mistake this size, emmc should always ok
+static int _assert_logic_partition_cap(const char* thePartName, const uint64_t nandPartCap)
+{
+        extern struct partitions * part_table;
+
+        int partIndex                   = 0;
+        struct partitions * thePart     = NULL;
+
+        for (thePart = part_table; partIndex < MAX_PART_NAME_LEN; ++thePart, ++partIndex)
+        {
+                const uint64_t partSzInBytes = thePart->size;
+                if (memcmp(thePartName, thePart->name, strlen(thePartName))) continue;
+
+                DWN_DBG("cfg partSzInBytes %llx for part(%s)\n", partSzInBytes, thePartName);
+                if (NAND_PART_SIZE_FULL == partSzInBytes) {return 0;}
+                if (partSzInBytes > nandPartCap) {
+                        DWN_ERR("partSz of logic part(%s): sz dts %llx > Sz flash %llx\n",
+                                        thePartName, partSzInBytes, nandPartCap);
+                        return __LINE__;
+                }
+
+                return 0;
+        }
+
+        DWN_ERR("Can't find your download part(%s)\n", thePartName);
+        return __LINE__;
+}
+#else
+#define _assert_logic_partition_cap(...)        0
+#endif
+
+//return value is the actual size it write
+static int optimus_download_bootloader_image(struct ImgBurnInfo* pDownInfo, u32 dataSzReceived, const u8* data)
+{
+    int ret = OPT_DOWN_OK;
+    uint64_t size = dataSzReceived;
+
+    if (dataSzReceived < pDownInfo->imgPktSz) {
+        DWN_ERR("please write back bootloader after all data rx end.0x(%x, %x)\n", dataSzReceived, (u32)pDownInfo->imgPktSz);
+        return 0;
+    }
+
+#if 0
+    ret = _check_partition_table_consistency((unsigned)data);
+    if (ret) {
+        DWN_ERR("Fail in _check_partition_table_consistency\n");
+        return 0;
+    }
+#endif
+    if (size > (1U<<20)) {
+        DWN_ERR("uboot.bin size 0x%llx > 1M unsupported\n", size);
+        return 0;
+    }
+
+    size = size <= 0x60000 ? 0x60000 : (1U<<20);//384K when non-secure_os, 1M when secure_os
+    ret = store_boot_write((unsigned char*)data, 0, size);
+
+    return ret ? 0 : dataSzReceived;
+}
+
+static int optimus_verify_bootloader(struct ImgBurnInfo* pDownInfo, u8* genSum)
+{
+    int ret = OPT_DOWN_OK;
+    unsigned char* pBuf = (unsigned char*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+    uint64_t size = 0;
+
+    /*size = 0x60000;////////////TODO:hardcode len!!*/
+    size=pDownInfo->imgPktSz;
+    ret = store_boot_read(pBuf, (u64)0, size);
+    if (ret) {
+        DWN_ERR("Fail to read bootloader\n");
+        return __LINE__;
+    }
+
+    sha1_csum(pBuf, (u32)pDownInfo->imgPktSz, genSum);
+
+    return ret;
+}
+
+
+u32 optimus_cb_simg_write_media(const unsigned destAddrInSec, const unsigned dataSzInBy, const char* data)
+{
+    int ret = OPT_DOWN_OK;
+    unsigned char* partName = (unsigned char*)OptimusImgBurnInfo.partName;
+
+    if (OPTIMUS_MEDIA_TYPE_STORE < OptimusImgBurnInfo.storageMediaType) {
+        DWN_ERR("storage type %d not supported yet!\n", OptimusImgBurnInfo.storageMediaType);
+        return OPT_DOWN_FAIL;
+    }
+
+    DWN_DBG("1addrOffset=0x%llx, dataSz=0x%x, data = 0x%p\t", (((u64)destAddrInSec)<<9), dataSzInBy, (void*)data);
+    //FIXME:why dirty value if not convert to u64
+    ret = store_write_ops(partName, (u8*)data, (((u64)destAddrInSec)<<9), (u64)dataSzInBy);
+    if (ret) {
+        DWN_ERR("Fail to write to media, ret = %d\n", ret);
+        return 0;
+    }
+
+    return dataSzInBy;
+}
+
+//return value: the data size disposed
+static u32 optimus_download_sparse_image(struct ImgBurnInfo* pDownInfo, u32 dataSz, const u8* data)
+{
+    u32 unParsedDataLen = 0;
+    int flashOffset = 0;
+    const u64 addrOffset = pDownInfo->nextMediaOffset;
+
+    flashOffset = optimus_simg_to_media((char*)data, dataSz, &unParsedDataLen, ((u32)(addrOffset>>9)));
+    if (flashOffset < 0) {
+        DWN_ERR("Fail in parse simg. src 0x%p, size 0x%x, unParsedDataLen 0x%x, ret %d\n", data, dataSz, unParsedDataLen, flashOffset);
+        return 0;
+    }
+    pDownInfo->nextMediaOffset += ((u64)flashOffset)<<9;
+
+    return dataSz - unParsedDataLen;
+}
+
+//Normal image can write directly to NAND, best aligned to 16K when write
+//FIXME: check it aligned to 16K when called
+//1, write to media     2 -- save the verify info
+static u32 optimus_download_normal_image(struct ImgBurnInfo* pDownInfo, u32 dataSz, const u8* data)
+{
+    int ret = 0;
+    u64 addrOrOffsetInBy = pDownInfo->nextMediaOffset;
+
+    DWN_DBG("addrOffset=0x%llx, dataSz=0x%x, data = 0x%p\n", addrOrOffsetInBy, dataSz, data);
+
+    ret = store_write_ops((u8*)pDownInfo->partName, (u8*)data, addrOrOffsetInBy, (u64)dataSz);
+    if (ret) {
+        DWN_ERR("Fail to write to media\n");
+        return 0;
+    }
+
+    pDownInfo->nextMediaOffset += dataSz;
+
+    return dataSz;
+}
+
+static int optimus_storage_open(struct ImgBurnInfo* pDownInfo, const u8* data, const u32 dataSz)
+{
+    int ret = OPT_DOWN_OK;
+    const char* partName = (const char*)pDownInfo->partName;
+    const int imgType = pDownInfo->imgType;
+    const int MediaType = pDownInfo->storageMediaType;
+
+    if (!pDownInfo->imgSzDisposed && OPTIMUS_IMG_STA_PRE_BURN == pDownInfo->imgBurnSta)
+    {
+        DWN_MSG("Burn Start...\n");
+        pDownInfo->imgBurnSta = OPTIMUS_IMG_STA_BURN_ING;
+    }
+    else if(pDownInfo->imgSzDisposed == pDownInfo->imgPktSz && OPTIMUS_IMG_STA_BURN_COMPLETE == pDownInfo->imgBurnSta)
+    {
+        DWN_MSG("Verify Start...\n");
+        pDownInfo->imgBurnSta = OPTIMUS_IMG_STA_VERIFY_ING;
+    }
+
+    switch (MediaType)
+    {
+        case OPTIMUS_MEDIA_TYPE_NAND:
+        case OPTIMUS_MEDIA_TYPE_SDMMC:
+        case OPTIMUS_MEDIA_TYPE_STORE:
+            {
+                if (IMG_TYPE_BOOTLOADER != pDownInfo->imgType && !pDownInfo->devHdle) //if not bootloader and device not open
+                {
+                    /*pDownInfo->devHdle = aml_nftl_get_dev(partName);*/
+                    pDownInfo->devHdle = (void*)1;
+                    if (!pDownInfo->devHdle) {
+                        DWN_ERR("Fail to open nand part %s\n", partName);
+                        return OPT_DOWN_FAIL;
+                    }
+
+                    if (IMG_TYPE_SPARSE == imgType)
+                    {
+                        ret = optimus_simg_probe(data, dataSz);
+                        if (!ret) {
+                            DWN_ERR("Fail in sparse format probe,ret=%d\n", ret);
+                            return OPT_DOWN_FAIL;
+                        }
+                        return optimus_simg_parser_init(data);
+                    }
+                }
+                else//is bootloader, than do nothing
+                {
+                    return OPT_DOWN_OK;
+                }
+            }
+            break;
+
+        case OPTIMUS_MEDIA_TYPE_KEY_UNIFY:
+            break;
+
+        case OPTIMUS_MEDIA_TYPE_MEM:
+            break;
+
+        default:
+            DWN_MSG("Error MediaType %d\n", MediaType);
+            return OPT_DOWN_FAIL;
+    }
+
+    return ret;
+}
+
+static int optimus_storage_close(struct ImgBurnInfo* pDownInfo)
+{
+    if (pDownInfo->imgSzDisposed == pDownInfo->imgPktSz && OPTIMUS_IMG_STA_BURN_ING == pDownInfo->imgBurnSta)
+    {
+        pDownInfo->imgBurnSta = OPTIMUS_IMG_STA_BURN_COMPLETE;
+        DWN_MSG("Burn complete\n");
+
+        return OPT_DOWN_OK;
+    }
+
+    if (!pDownInfo->imgSzDisposed && OPTIMUS_IMG_STA_VERIFY_ING == pDownInfo->imgBurnSta)
+    {
+        pDownInfo->imgBurnSta = OPTIMUS_IMG_STA_VERIFY_END;
+        DWN_MSG("Verify End\n");
+        return OPT_DOWN_OK;
+    }
+
+    return OPT_DOWN_OK;
+}
+
+
+//return value is the data size that actual dealed
+static u32 optimus_storage_write(struct ImgBurnInfo* pDownInfo, u64 addrOrOffsetInBy, unsigned dataSz, const u8* data, char* errInfo)
+{
+    u32 burnSz = 0;
+    const u32 imgType = pDownInfo->imgType;
+    const int MediaType = pDownInfo->storageMediaType;
+
+    addrOrOffsetInBy += pDownInfo->partBaseOffset;
+    DWN_DBG("[0x]Data %p, addrOrOffsetInBy %llx, dataSzInBy %x\n", data, addrOrOffsetInBy, dataSz);
+
+    if (OPTIMUS_IMG_STA_BURN_ING != pDownInfo->imgBurnSta) {
+        sprintf(errInfo, "Error burn sta %d\n", pDownInfo->imgBurnSta);
+        DWN_ERR(errInfo);
+        return 0;
+    }
+
+    switch (MediaType)
+    {
+        case OPTIMUS_MEDIA_TYPE_NAND:
+        case OPTIMUS_MEDIA_TYPE_SDMMC:
+        case OPTIMUS_MEDIA_TYPE_STORE:
+            {
+                switch (imgType)
+                {
+                    case IMG_TYPE_NORMAL:
+                        burnSz = optimus_download_normal_image(pDownInfo, dataSz, data);
+                        break;
+
+                    case IMG_TYPE_BOOTLOADER:
+                        burnSz = optimus_download_bootloader_image(pDownInfo, dataSz, data);
+                        break;
+
+                    case IMG_TYPE_SPARSE:
+                        burnSz = optimus_download_sparse_image(pDownInfo, dataSz, data);
+                        break;
+
+                    default:
+                        DWN_ERR("error image type %d\n", imgType);
+                }
+            }
+            break;
+
+        case OPTIMUS_MEDIA_TYPE_KEY_UNIFY:
+            {
+                burnSz = v2_key_burn(pDownInfo->partName, data, dataSz, errInfo);
+                if (burnSz != dataSz) {//return value is write size
+                    DWN_ERR("burn key failed\n");
+                    return 0;
+                }
+            }
+            break;
+
+        case OPTIMUS_MEDIA_TYPE_MEM:
+        {
+            u8* buf = (u8*)addrOrOffsetInBy;
+            if (buf != data) {
+                DWN_ERR("buf(%llx) != data(%p)\n", addrOrOffsetInBy, data);
+                return 0;
+            }
+            if (!strcmp("dtb", pDownInfo->partName)) //as memory write back size = min[fileSz, 2G], so reach here if downloaded ok!
+            {
+                unsigned char* dtbLoadAddr = (unsigned char*)OPTIMUS_DTB_LOAD_ADDR;
+                unsigned char* srcDownDtb = (unsigned char*)data;
+
+                memcpy(dtbLoadAddr, srcDownDtb, dataSz);
+                DWN_MSG("load dt.img to 0x%p, sz=0x%x\n", dtbLoadAddr, dataSz);
+                _dtb_is_loaded = dataSz;
+            }
+
+            burnSz = dataSz;
+        }
+        break;
+
+        default:
+            sprintf(errInfo, "Error MediaType %d\n", MediaType);
+            DWN_ERR(errInfo);
+    }
+
+    return burnSz;
+}
+
+//TODO: to consist with optimus_storage_write, return value should be readSzInBy
+static int optimus_storage_read(struct ImgBurnInfo* pDownInfo, u64 addrOrOffsetInBy,
+                            unsigned readSzInBy, unsigned char* buff, char* errInfo)
+{
+    int ret = 0;
+    const int MediaType = pDownInfo->storageMediaType;
+    unsigned char* partName = (unsigned char*)pDownInfo->partName;
+
+    addrOrOffsetInBy += pDownInfo->partBaseOffset;
+
+    switch (MediaType)
+    {
+        case OPTIMUS_MEDIA_TYPE_NAND:
+        case OPTIMUS_MEDIA_TYPE_SDMMC:
+        case OPTIMUS_MEDIA_TYPE_STORE:
+            {
+                if (IMG_TYPE_BOOTLOADER == pDownInfo->imgType)
+                {
+                    ret = store_boot_read(buff, addrOrOffsetInBy, (u64)readSzInBy);
+                }
+                else
+                {
+                    ret = store_read_ops(partName, buff, addrOrOffsetInBy, (u64)readSzInBy);
+                }
+                if (ret) {
+                    if (errInfo) sprintf(errInfo, "Read failed\n") ;
+                    DWN_ERR("Read failed\n");
+                    return OPT_DOWN_FAIL;
+                }
+
+            }
+            break;
+
+        case OPTIMUS_MEDIA_TYPE_KEY_UNIFY:
+            {
+                unsigned fmtLen = 0;
+                if (addrOrOffsetInBy) {
+                    DWN_ERR("OH NO, IS key len > 64K!!? addrOrOffsetInBy is 0x%llx not 0\n", addrOrOffsetInBy);
+                    return OPT_DOWN_FAIL;
+                }
+                ret = v2_key_read(pDownInfo->partName, buff, readSzInBy, errInfo, &fmtLen);
+            }
+            break;
+
+        case OPTIMUS_MEDIA_TYPE_MEM:
+        {
+            u8* buf = (u8*)addrOrOffsetInBy;
+            if (addrOrOffsetInBy >> 32) {
+                DWN_ERR("mem addr 0x%llx too large\n", addrOrOffsetInBy);
+            }
+            if (buf != buff) {
+                DWN_ERR("buf(%llx) != buff(%p)\n", addrOrOffsetInBy, buff);
+            }
+        }
+        break;
+
+        default:
+            DWN_MSG("Error MediaType %d\n", MediaType);
+            return OPT_DOWN_FAIL;
+    }
+
+    return ret;
+}
+
+//return value is the size actual write to media
+//Paras: const char* partName, const char* imgType, const char* verifyAlgorithm
+static u32 optimus_func_download_image(struct ImgBurnInfo* pDownInfo, u32 dataSz, const u8* data, char* errInfo)
+{
+    int burnSz = 0;
+    int ret = 0;
+    u64 nextMediaOffset = pDownInfo->nextMediaOffset;
+
+    DWN_DBG("data=0x%p, sz=0x%x, offset=%llx\n", data, dataSz, nextMediaOffset);
+
+    ret = optimus_storage_open(pDownInfo, data, dataSz);
+    if (OPT_DOWN_OK != ret) {
+        sprintf(errInfo, "Fail to open stoarge\n");
+        DWN_ERR(errInfo);
+        return 0;
+    }
+
+    burnSz = optimus_storage_write(pDownInfo, nextMediaOffset, dataSz, data, errInfo);
+    if (!burnSz) {
+        DWN_ERR("Fail in optimus_storage_write, data 0x%p, wantSz 0x%x\n", data, dataSz);
+        goto _err;
+    }
+    pDownInfo->imgSzDisposed += burnSz;
+
+    ret = optimus_storage_close(pDownInfo);
+    if (ret) {
+        DWN_ERR("Fail to close media\n");
+        return 0;
+    }
+
+    return burnSz;
+
+_err:
+    optimus_storage_close(pDownInfo);
+    pDownInfo->imgBurnSta = OPTIMUS_IMG_STA_BURN_FAILED;////
+    return 0;
+}
+
+//TODO: add _errInfo as argument to pass more info
+static int _parse_img_download_info(struct ImgBurnInfo* pDownInfo, const char* partName,
+                                     const u64 imgSz, const char* imgType, const char* mediaType, const u64 partBaseOffset)
+{
+    u64 partCap = 0;
+    int ret = 0;
+
+    memset(pDownInfo, 0, sizeof(struct ImgBurnInfo));//clear burnning info
+
+    //TODO: check format is normal/bootloader if upload!!
+
+    if (!strcmp("sparse", imgType))
+    {
+        pDownInfo->imgType = IMG_TYPE_SPARSE;
+    }
+    else if(!strcmp("bootloader", partName))
+    {
+        pDownInfo->imgType = IMG_TYPE_BOOTLOADER;
+    }
+    else if(!strcmp("normal", imgType))
+    {
+        pDownInfo->imgType = IMG_TYPE_NORMAL;
+    }
+    else{
+        DWN_ERR("err image type %s\n", imgType);
+        return __LINE__;
+    }
+
+    if (!strcmp("store", mediaType))
+    {
+        pDownInfo->storageMediaType = OPTIMUS_MEDIA_TYPE_STORE;
+    }
+    else if(!strcmp("nand", mediaType))
+    {
+        pDownInfo->storageMediaType = OPTIMUS_MEDIA_TYPE_NAND;
+    }
+    else if(!strcmp("sdmmc", mediaType))
+    {
+        pDownInfo->storageMediaType = OPTIMUS_MEDIA_TYPE_SDMMC;
+    }
+    else if(!strcmp("spiflash", mediaType))
+    {
+        pDownInfo->storageMediaType = OPTIMUS_MEDIA_TYPE_SPIFLASH;
+    }
+    else if(!strcmp("key", mediaType))
+    {
+        pDownInfo->storageMediaType = OPTIMUS_MEDIA_TYPE_KEY_UNIFY;
+
+        if (OPTIMUS_DOWNLOAD_SLOT_SZ <= imgSz) {
+            DWN_ERR("size (0x%llx) for key %s invalid!!\n", imgSz, partName);
+            return __LINE__;
+        }
+    }
+    else if(!strcmp("mem", mediaType))
+    {
+        pDownInfo->storageMediaType = OPTIMUS_MEDIA_TYPE_MEM;
+    }
+    else{
+        DWN_ERR("error mediaType %s\n", mediaType);
+        return __LINE__;
+    }
+
+    pDownInfo->partBaseOffset   = partBaseOffset;
+    memcpy(pDownInfo->partName, partName, strlen(partName));
+
+    if (OPTIMUS_MEDIA_TYPE_MEM > pDownInfo->storageMediaType) //if command for burning partition
+    {
+        if (strcmp("bootloader", partName)) //get size if not bootloader
+        {
+            ret = store_get_partititon_size((u8*)partName, &partCap);
+            if (ret) {
+                DWN_ERR("Fail to get size for part %s\n", partName);
+                return __LINE__;
+            }
+            partCap <<= 9;//trans sector to byte
+            DWN_MSG("flash LOGIC partCap 0x%llxB\n", partCap);
+            if (imgSz > partCap) {
+                DWN_ERR("imgSz 0x%llx out of cap 0x%llx\n", imgSz, partCap);
+                return __LINE__;
+            }
+            ret = _assert_logic_partition_cap(partName, partCap);
+            if (ret) {
+                    DWN_ERR("Fail in _assert_logic_partition_cap\n");
+                    return __LINE__;
+            }
+        }
+    }
+
+    pDownInfo->nextMediaOffset  = pDownInfo->imgSzDisposed = 0;
+    pDownInfo->imgPktSz         = imgSz;
+    pDownInfo->imgBurnSta       = OPTIMUS_IMG_STA_PRE_BURN;
+
+    DWN_MSG("Down(%s) part(%s) sz(0x%llx) fmt(%s)\n", mediaType, partName, pDownInfo->imgPktSz, imgType);
+
+    return 0;
+}
+
+int optimus_download_init(void)
+{
+    memset(&OptimusImgBurnInfo, 0, sizeof(struct ImgBurnInfo));
+    return 0;
+}
+
+int optimus_download_exit(void)
+{
+    return 0;
+}
+
+int optimus_parse_img_download_info(const char* partName, const u64 imgSz, const char* imgType, const char* mediaType, const u64 partBaseOffset)
+{
+    return _parse_img_download_info(&OptimusImgBurnInfo, partName, imgSz, imgType, mediaType, partBaseOffset);
+}
+
+static int _disk_intialed_ok = 0;
+
+int is_optimus_storage_inited(void)
+{
+        return _disk_intialed_ok;
+}
+
+int optimus_save_loaded_dtb_to_flash(void)
+{
+        unsigned char* dtbLoadedAddr = (unsigned char*)OPTIMUS_DTB_LOAD_ADDR;
+
+        if (!_dtb_is_loaded) return 0;
+
+        //dtb erasing before write
+        store_erase_ops((u8*)"dtb", 0, 0, 0);
+        return store_dtb_rw(dtbLoadedAddr, _dtb_is_loaded, 1);
+}
+
+int optimus_storage_init(int toErase)
+{
+    int ret = 0;
+    char* cmd = NULL;
+    unsigned char* dtbLoadedAddr = (unsigned char*)OPTIMUS_DTB_LOAD_ADDR;
+
+    if (_disk_intialed_ok) {//To assert only actual disk intialed once
+        DWN_MSG("Disk inited again.\n");
+        return 0;
+    }
+
+    if (OPTIMUS_WORK_MODE_USB_PRODUCE != optimus_work_mode_get()) //Already inited in other work mode
+    {
+        DWN_MSG("Exit before re-init\n");
+        store_exit();
+    }
+
+    if (!_dtb_is_loaded) {
+        DWN_WRN("dtb is not loaded yet\n");
+    }
+    else{
+        ret = get_partition_from_dts(dtbLoadedAddr);
+        if (ret) {
+            DWN_ERR("Failed at get_partition_from_dts\n");
+            return __LINE__;
+        }
+    }
+
+    switch (toErase)
+    {
+        case 0://NO erase
+            ret = store_init(1);
+            break;
+
+        case 3://erase all(with key)
+            {
+                cmd = "store disprotect key";
+                DWN_MSG("run cmd [%s]\n", cmd);
+                ret = run_command(cmd, 0);
+                if (ret) {
+                    DWN_ERR("Fail when run cmd[%s], ret %d\n", cmd, ret);
+                    break;
+                }
+            }
+        case 1://normal erase, store init 3
+            ret = store_init(3);
+            break;
+
+        case 4://force erase all
+            {
+                cmd = "store disprotect key; store disprotect hynix";
+                DWN_MSG("run cmd [%s]\n", cmd);
+                ret = run_command(cmd, 0);
+                if (ret) {
+                    DWN_ERR("Fail when run cmd[%s], ret %d\n", cmd, ret);
+                    break;
+                }
+            }
+        case 2:
+            ret = store_init(4);
+            break;
+
+        default:
+            DWN_ERR("Unsupported erase flag %d\n", toErase); ret = -__LINE__;
+            break;
+    }
+
+    if (!ret)
+    {
+        _disk_intialed_ok  = 1;
+        _disk_intialed_ok += toErase <<16;
+
+        ret = optimus_save_loaded_dtb_to_flash();
+        if (ret) {
+                DWN_ERR("FAiled in dtb wr\n");
+                return __LINE__;
+        }
+
+        if (OPTIMUS_WORK_MODE_USB_PRODUCE == optimus_work_mode_get()) //env not relocated in this case
+        {
+            DWN_MSG("usb producing env_relocate\n");
+            env_relocate();
+        }
+
+        if (_dtb_is_loaded)
+        {
+                unsigned long fdtAddr = (unsigned long)dtbLoadedAddr;
+#ifdef CONFIG_MULTI_DTB
+                fdtAddr = get_multi_dt_entry(fdtAddr);
+#endif// #ifdef CONFIG_MULTI_DTB
+                ret = fdt_check_header((char*)fdtAddr);
+                if (ret) {
+                        DWN_ERR("Fail in fdt check header\n");
+                        return __LINE__;
+                }
+                /*setenv("dtb_mem_addr", simple_itoa(fdtAddr));*/
+                char _cmd[64];
+                sprintf(_cmd, "setenv dtb_mem_addr 0x%lx", fdtAddr);//itoa is decimal, not mistake if others specify 16 in strtoul
+                run_command(_cmd, 0);
+        }
+    }
+
+    return ret;
+}
+
+int optimus_storage_exit(void)
+{
+    _disk_intialed_ok = 0;
+    DWN_MSG("store_exit yet!!\n");
+    return store_exit();
+}
+
+int is_optimus_on_burn(void)//is now transfering image
+{
+    return (OPTIMUS_IMG_STA_BURN_ING == OptimusImgBurnInfo.imgBurnSta);
+}
+
+int is_optimus_pre_burn(void)    //is now has get "download command"
+{
+    return (OPTIMUS_IMG_STA_PRE_BURN == OptimusImgBurnInfo.imgBurnSta);
+}
+
+int is_optimus_to_burn_ready(void)
+{
+    return (OPTIMUS_IMG_STA_PRE_BURN == OptimusImgBurnInfo.imgBurnSta);
+}
+
+int is_optimus_burn_complete(void)
+{
+    int is_burn_completed = 0;
+
+    is_burn_completed = (OPTIMUS_IMG_STA_BURN_COMPLETE == OptimusImgBurnInfo.imgBurnSta);
+    if (!is_burn_completed) {
+        DWN_MSG("imgSzDisposed 0x%llx != imgPktSz 0x%llx\n", OptimusImgBurnInfo.imgSzDisposed, OptimusImgBurnInfo.imgPktSz);
+    }
+
+    return is_burn_completed;
+}
+
+u32 optimus_download_img_data(const u8* data, const u32 size, char* errInfo)
+{
+    return optimus_func_download_image(&OptimusImgBurnInfo, size, data, errInfo);
+}
+
+static int optimus_sha1sum_verify_partition(const char* partName, const u64 verifyLen, const u8 imgType, u8* genSum)
+{
+    int ret = 0;
+    u8* buff = (u8*) OPTIMUS_SHA1SUM_BUFFER_ADDR;
+    const u32 buffSz = OPTIMUS_SHA1SUM_BUFFER_LEN;
+    sha1_context ctx;
+    u64 leftLen = verifyLen;
+
+    if (strcmp(partName, OptimusImgBurnInfo.partName)) {
+        DWN_ERR("partName %s err, must %s\n", partName, OptimusImgBurnInfo.partName);
+        return OPT_DOWN_FAIL;
+    }
+
+    if (!is_optimus_burn_complete()) {
+        return OPT_DOWN_FAIL;
+    }
+
+    memset(buff, 0xde, 1024);//clear 1kb data before verfiy, in case read buffer not overlapped
+    if (IMG_TYPE_BOOTLOADER == imgType)
+    {
+        return optimus_verify_bootloader(&OptimusImgBurnInfo, genSum);
+    }
+    else if(IMG_TYPE_SPARSE == imgType)//sparse image
+    {
+        ret = optimus_sparse_back_info_probe();
+        if (OPT_DOWN_TRUE != ret) {
+            DWN_ERR("Fail to probe back sparse info\n");
+            return OPT_DOWN_FAIL;
+        }
+    }
+
+    ret = optimus_storage_open(&OptimusImgBurnInfo, NULL, 0);
+    if (ret) {
+        DWN_ERR("Fail to open storage for read\n");
+        return OPT_DOWN_FAIL;
+    }
+
+    sha1_starts(&ctx);
+
+    DWN_MSG("To verify part %s in fmt %s\n", partName, (IMG_TYPE_SPARSE == imgType) ? "sparse": "normal");
+    if (IMG_TYPE_SPARSE == imgType) //sparse image
+    {
+        for (; leftLen;)
+        {
+            u32 spHeadSz   = 0;
+            u32 chunkDataLen    = 0;
+            u64 chunkDataOffset = 0;
+            u8* head = NULL;
+
+            ret = optimus_sparse_get_chunk_data(&head, &spHeadSz, &chunkDataLen, &chunkDataOffset);
+            if (ret) {
+                DWN_ERR("Fail to get chunk data\n");
+                goto _finish;
+            }
+
+            sha1_update(&ctx, head, spHeadSz);
+
+            leftLen -= spHeadSz + chunkDataLen;//update image read info
+
+            for (;chunkDataLen;)
+            {
+                const int thisReadLen = (chunkDataLen > buffSz) ? buffSz : chunkDataLen;
+
+                ret = optimus_storage_read(&OptimusImgBurnInfo, chunkDataOffset, thisReadLen, buff, NULL);
+                if (ret) {
+                    DWN_ERR("Fail to read at offset 0x[%x, %8x], len=0x%8x\n", ((u32)(chunkDataOffset>>32)), (u32)chunkDataOffset, thisReadLen);
+                    goto _finish;
+                }
+
+                sha1_update(&ctx, buff, thisReadLen);
+
+                chunkDataLen    -= thisReadLen;
+                chunkDataOffset += thisReadLen;
+            }
+
+            if (leftLen && !spHeadSz) {
+                DWN_ERR("Fail to read when pkt len left 0x%x\n", (u32)leftLen);
+                break;
+            }
+        }
+    }
+    else//normal image
+    {
+        for (; leftLen;)
+        {
+            int thisReadLen = (leftLen > buffSz) ? buffSz : ((u32)leftLen);
+            u64 addrOffset = verifyLen - leftLen;
+
+            ret = optimus_storage_read(&OptimusImgBurnInfo, addrOffset, thisReadLen, buff, NULL);
+            if (ret) {
+                DWN_ERR("Fail to read at offset 0x[%x, %8x], len=0x%8x\n", ((u32)(addrOffset>>32)), (u32)addrOffset, thisReadLen);
+                goto _finish;
+            }
+
+            sha1_update(&ctx, buff, thisReadLen);
+
+            leftLen -= thisReadLen;
+        }
+
+    }
+
+_finish:
+    OptimusImgBurnInfo.imgSzDisposed = leftLen;
+    sha1_finish(&ctx, genSum);
+    optimus_storage_close(&OptimusImgBurnInfo);
+
+    return ret;
+}
+
+//usage: verify sha1sum nand srcSum part_name size imgType
+int optimus_media_download_verify(const int argc, char * const argv[], char *info)
+{
+    const char* verifyType      = argv[1];
+    const char* srcSum          = argv[2];
+    static u8  verifyResult[20];
+    static char sha1Result[42];
+    const u8 srcImgType = OptimusImgBurnInfo.imgType;
+    const char* partName = OptimusImgBurnInfo.partName;
+    u64 verifyLen = OptimusImgBurnInfo.imgPktSz;
+    int ret = 0;
+
+	if (argc != 3) {
+		strcpy(info, "failed:need 3 args\n");
+        printf(info);
+		return -1;
+	}
+
+    if (strcmp(verifyType, "sha1sum")) {
+        ret = __LINE__;
+        sprintf(info, "verifyType [%s] err, ret %d!\n", verifyType, ret);
+        DWN_ERR(info);
+        return ret;
+    }
+
+    ret = optimus_sha1sum_verify_partition(partName, verifyLen, srcImgType, verifyResult);
+    if (ret) {
+        DWN_ERR("Fail to gen check sum\n");
+        return __LINE__;
+    }
+
+    ret = optimus_hex_data_2_ascii_str(verifyResult, 20, sha1Result, 42);
+    if (ret) {
+        DWN_ERR("Failed when format sha1 to string\n");
+        return __LINE__;
+    }
+
+    /*DWN_MSG("%s %s\n", verifyType, sha1Result);*/
+    ret = strcmp(sha1Result, srcSum);
+    if (ret) {
+        sprintf(info, "failed:Verify Failed with %s, origin sum \"%s\" != gen sum \"%s\"\n", verifyType, srcSum, sha1Result);
+        DWN_ERR(info);
+        return __LINE__;
+    }
+
+    DWN_MSG("VERIFY OK \n");
+    return ret;
+}
+
+int optimus_key_burn_init(const char* keyType)
+{
+    int ret = 0;
+
+    if (!strcmp("efuse", keyType))
+    {
+        return ret;
+    }
+
+    if (!strcmp("secure", keyType))
+    {
+        return ret;
+    }
+
+    DWN_ERR("unsported key type %s\n", keyType);
+    return OPT_DOWN_FAIL;
+}
+
+//update tplcmd dev0 "download nand part_name imageType imgSz"
+//update tplcmd dev0 "download get_status"
+int optimus_parse_download_cmd(int argc, char* argv[])
+{
+    const int isUpload = !strcmp("upload", argv[0]);
+    const char* mediaType   = argv[1];
+    const char* part_name   = argv[2];
+    const char* imgType     = argv[3];
+    const char* imgSzStr    = argv[4];
+    u64   imgSzInBy   = 0;
+    u64   partBaseOffset = 0;
+    int ret = 0;
+
+    if (!strcmp("get_status", mediaType))
+    {
+        return !is_optimus_burn_complete();
+    }
+
+    if (!strcmp("is_ready", mediaType))
+    {
+        return !is_optimus_to_burn_ready();
+    }
+
+    if (5 > argc) {
+        printf("argc[%d] too few, use \"download nand part_name imageType imgSz\"\n", argc);
+        return  __LINE__;
+    }
+
+    imgSzInBy = simple_strtoull(imgSzStr, NULL, 0);
+
+    if (!strcmp("mem", mediaType))
+    {
+        char* endp = NULL;
+        partBaseOffset = simple_strtoull(part_name, &endp, 0);
+        if (0 != *endp) //not a valid 0-terminated c string
+        {
+            if (!strcmp("dtb", part_name))
+            {
+                partBaseOffset = OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+                DWN_DBG("dtb down to %llx\n", partBaseOffset);
+            }
+        }
+    }
+
+    ret = optimus_parse_img_download_info(part_name, imgSzInBy, imgType, mediaType, partBaseOffset);
+    if (ret) {
+        DWN_ERR("Fail in init download info\n");
+        return __LINE__;
+    }
+
+    ret = optimus_buf_manager_tplcmd_init(mediaType, part_name, partBaseOffset, imgType, imgSzInBy, isUpload, 0);
+    if (ret) {
+        DWN_ERR("Fail in init download info\n");
+        return __LINE__;
+    }
+
+    return OPT_DOWN_OK;
+}
+
+u32 optimus_dump_storage_data(u8* pBuf, const u32 wantSz, char* errInfo)
+{
+    struct ImgBurnInfo* pDownInfo = &OptimusImgBurnInfo;
+    u64 nextMediaOffset = pDownInfo->nextMediaOffset;
+    int ret = 0;
+
+    DWN_DBG("pBuf=0x%p, wantSz=0x%x, nextMediaOffset=%x\n", pBuf, wantSz, (u32)nextMediaOffset);
+
+    ret = optimus_storage_open(pDownInfo, pBuf, wantSz);
+    if (OPT_DOWN_OK != ret) {
+        sprintf(errInfo, "Fail to open stoarge\n");
+        DWN_ERR(errInfo);
+        return 0;
+    }
+
+    ret = optimus_storage_read(pDownInfo, nextMediaOffset, wantSz, pBuf, errInfo);
+    if (ret) {
+        DWN_ERR("Failed \n");
+        goto _err;
+    }
+    pDownInfo->imgSzDisposed    += wantSz;
+    pDownInfo->nextMediaOffset  += wantSz;
+
+    ret = optimus_storage_close(pDownInfo);
+    if (ret) {
+        DWN_ERR("Fail to close media\n");
+        return 0;
+    }
+
+    return wantSz;
+
+_err:
+    optimus_storage_close(pDownInfo);
+    pDownInfo->imgBurnSta = OPTIMUS_IMG_STA_BURN_FAILED;////
+    return 0;
+}
+
+static int _optimusWorkMode = OPTIMUS_WORK_MODE_NONE;
+
+int optimus_work_mode_get(void)
+{
+    return _optimusWorkMode;
+}
+
+int optimus_work_mode_set(int workmode)
+{
+    _optimusWorkMode = workmode;
+    return 0;
+}
+
+int is_the_flash_first_burned(void)
+{
+    const char* s = getenv("upgrade_step");
+
+    DWN_MSG("====>upgrade_step=%s<=====\n", s ? s : "<UNDEFINED>");
+
+    return !strcmp(s, "0");//"0" indicate first boot
+}
+
+//FIXME: check whether 'saveenv' failed and exception when usb prodcing mode from code boot mode if without env_relocate
+int optimus_set_burn_complete_flag(void)
+{
+    int rc = 0;
+    const int IsTplLoadedFromBurningPackage = aml_burn_check_uboot_loaded_for_burn(0);
+    char upgrade_step[8];
+
+    if (IsTplLoadedFromBurningPackage)
+    {
+        /*rc = run_command("defenv", 0);//use new env directly if uboot is new !!!*/
+        set_default_env("## save_setting ##\n");//use new env directly if uboot is new !!!
+#if 0
+        const char* def_env_initargs = getenv("initargs");
+        const char* def_env_bootargs = getenv("bootargs");
+        if (!strstr(getenv("initargs"), "storage") && getenv("initargs") && 0) {
+                rc = run_command("setenv initargs ${initargs} storage=${store}", 0);
+                DWN_MSG("[initargs=%s]\n", getenv("initargs"));
+        }
+        else if(!strstr(getenv("bootargs"), "storage") && getenv("bootargs") && 0){//user not configure storage in 'bootargs' of default env
+                rc = run_command("setenv bootargs ${bootargs} storage=${store}", 0);
+                DWN_MSG("[bootargs=%s]\n", getenv("bootargs"));
+        }
+#endif
+    }
+
+    //Enable firstboot when flash empty to wipe_data/wipe_cache
+    setenv("firstboot", "1");
+    upgrade_step[0] = '1' + IsTplLoadedFromBurningPackage;
+    upgrade_step[1] = '\0';
+    DWN_MSG("Set upgrade_step to %s\n", upgrade_step);
+    rc = setenv("upgrade_step", upgrade_step);
+    if (rc) {
+        DWN_ERR("Fail to set upgraded_step to 1\n");
+    }
+    rc = run_command("saveenv", 0);
+    if (rc) {
+        DWN_ERR("Fail to saveenv to flash\n");
+    }
+    udelay(200);
+
+    return rc;
+}
+
+static int _optimus_set_reboot_mode(const int cfgFlag)
+{
+    char cmdbuf[96];
+    const char* reboot_mode = NULL;
+    switch (cfgFlag)
+    {
+        case OPTIMUS_BURN_COMPLETE__REBOOT_UPDATE:
+            reboot_mode = "update";
+            break;
+
+        case OPTIMUS_BURN_COMPLETE__REBOOT_SDC_BURN:
+            /*reboot_mode = MESON_SDC_BURNER_REBOOT;  */
+            break;
+
+        case OPTIMUS_BURN_COMPLETE__REBOOT_NORMAL:
+        default:
+            reboot_mode = "normal";
+            break;
+    }
+
+    sprintf(cmdbuf, "reboot %s", reboot_mode);
+
+    return run_command(cmdbuf, 0);
+}
+
+void optimus_reset(const int cfgFlag)
+{
+    unsigned i = 0x100;
+
+    //set reboot mode
+    _optimus_set_reboot_mode(cfgFlag);
+    printf("Burn Reboot...\n");//Add printf to delay to save env
+    while (--i) ;
+
+    /*disable_interrupts();*/
+	reset_cpu(0);
+
+    while (i++)
+    {
+        unsigned ret = i;
+        unsigned mask = 1U<<20;
+
+        mask -= 1;
+        ret &= mask;
+        if (!ret) {
+            printf("To reseting...\n");
+        }
+    }
+}
+
+void optimus_poweroff(void)
+{
+#ifndef CONFIG_POWER_KEY_SUPPORTED_FOR_BURN //default not support power key
+    DWN_MSG("stop here as poweroff and powerkey not supported in platform!\n");
+    DWN_MSG("You can <Ctrl-c> to reboot\n");
+    while (!ctrlc()) continue;
+    optimus_reset(OPTIMUS_BURN_COMPLETE__REBOOT_NORMAL);
+#else
+    printf("To poweroff\n");
+    run_command("poweroff", 0);
+    printf("!!!After run command poweroff!!\n");
+#endif// #if CONFIG_POWER_KEY_SUPPORTED_FOR_BURN
+
+    return;
+}
+
+//use choice = 0xfu to query is_burn_completed
+int optimus_burn_complete(const int choice)
+{
+    static unsigned _isBurnComplete = 0;
+    int rc = 0;
+
+    switch (choice)
+    {
+        case OPTIMUS_BURN_COMPLETE__POWEROFF_AFTER_POWERKEY://wait power key to power off, for sdc_burn
+            {
+#ifndef CONFIG_POWER_KEY_SUPPORTED_FOR_BURN
+                    optimus_poweroff();
+#endif// #if CONFIG_POWER_KEY_SUPPORTED_FOR_BURN
+                    DWN_MSG("PLS short-press power key to shut down\n");
+                    do
+                    {
+                            rc = run_command("getkey", 0);
+                    }while(rc);
+            }
+        case OPTIMUS_BURN_COMPLETE__POWEROFF_DIRECT:
+            optimus_poweroff();
+            break;
+
+        case OPTIMUS_BURN_COMPLETE__POWEROFF_AFTER_DISCONNECT:
+            DWN_MSG("Pls un-plug USB line to poweroff\n");
+            _isBurnComplete = 0xefe;
+            break;
+        case OPTIMUS_BURN_COMPLETE__QUERY:
+            return (0xefe == _isBurnComplete);
+
+        case OPTIMUS_BURN_COMPLETE__REBOOT_UPDATE:
+        case OPTIMUS_BURN_COMPLETE__REBOOT_NORMAL:
+            {
+                optimus_reset(choice);
+            }
+            break;
+
+
+        default:
+            rc = 1;
+            DWN_ERR("Error burn_complete flag %d\n", choice);
+    }
+
+    return rc;
+}
+
+static int optimus_enable_romboot_skip_boot(const char* extBootDev)
+{
+    if (!strcmp("usb", extBootDev))
+    {
+#if ROM_BOOT_SKIP_BOOT_ENABLED_4_USB
+        set_usb_boot_function(FORCE_USB_BOOT);
+#endif// #if ROM_BOOT_SKIP_BOOT_ENABLED_4_USB
+    }
+
+    if (!strcmp("sdc", extBootDev))
+    {
+#if ROM_BOOT_SKIP_BOOT_ENABLED_4_SDC
+#error "undefined yet"
+#endif// #if ROM_BOOT_SKIP_BOOT_ENABLED_4_SDC
+    }
+
+    return 0;
+}
+
+//I assume that store_inited yet when "bootloader_is_old"!!!!
+int optimus_erase_bootloader(const char* extBootDev)
+{
+    if (!strcmp("usb", extBootDev))
+    {
+#if ROM_BOOT_SKIP_BOOT_ENABLED_4_USB
+    return optimus_enable_romboot_skip_boot("usb");
+#endif// #if ROM_BOOT_SKIP_BOOT_ENABLED_4_USB
+    }
+
+    if (!strcmp("sdc", extBootDev))
+    {
+#if ROM_BOOT_SKIP_BOOT_ENABLED_4_SDC
+    return optimus_enable_romboot_skip_boot("sdc");
+#endif// #if ROM_BOOT_SKIP_BOOT_ENABLED_4_SDC
+    }
+
+    return store_erase_ops((u8*)"boot", 0, 0, 0);
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_download.h b/drivers/usb/gadget/v2_burning/v2_common/optimus_download.h
new file mode 100644
index 0000000..9e1cf8f
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_download.h
@@ -0,0 +1,190 @@
+/*
+ * \file        optimus_download.h
+ * \brief       common included files for optimus_*.c
+ *
+ * \version     1.0.0
+ * \date        2013/5/3
+ * \author      Sam.Wu <yihui.wu@Amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+
+#ifndef __OPTIMUS_DOWNLOAD_H__
+#define __OPTIMUS_DOWNLOAD_H__
+
+
+int optimus_buf_manager_init(const unsigned mediaAlignSz);
+int optimus_buf_manager_exit(void);
+int optimus_buf_manager_tplcmd_init(const char* mediaType, const char* partName, u64 partBaseOffset,
+                            const char* imgType, const u64 pktTotalSz, const int isUpload,
+                            const unsigned itemSizeNotAligned);
+int optimus_buf_manager_get_buf_for_bulk_transfer(char** pBuf, const unsigned wantSz, const unsigned sequenceNo, char* errInfo);
+int optimus_buf_manager_report_transfer_complete(const u32 transferSz, char* errInfo);
+int is_largest_data_transferring(void);
+int optimus_buf_manager_get_command_data_for_upload_transfer(u8* cmdDataBuf, const unsigned bufLen);
+
+int optimus_download_init(void);
+int optimus_download_exit(void);
+int optimus_parse_download_cmd(int argc, char* argv[]);
+int optimus_parse_img_download_info(const char* part_name, const u64 imgSz, const char* imgType, const char* mediaType, const u64 partBaseOffset);
+int is_optimus_to_burn_ready(void);//ready before burn
+u32 optimus_download_img_data(const u8* data, const u32 size, char* errInfo);
+int is_optimus_on_burn(void);    //is now transferring image
+int is_optimus_pre_burn(void);    //is now has get "download command"
+int optimus_media_download_verify(const int argc, char * const argv[], char *info);
+
+u32 optimus_dump_storage_data(u8* pBuf, const u32 wantSz, char* errInfo);
+
+
+//for key opearations
+//
+int v2_key_command(const int argc, char * const argv[], char *info);
+
+/*
+ *This fucntion called by mread command, mread= bulkcmd "upload key .." + n * upload transfer, for key n==1
+ *Attentions: return 0 if success, else failed
+ *@keyName: key name in null-terminated c style string
+ *@keyVal: the buffer to read back the key value
+ *@keyValLen: keyVal len is strict when read, i.e, user must know the length of key he/she wnat to read!!
+ *@errInfo: start it with success if burned ok, or format error info into it tell pc burned failed
+ */
+int v2_key_read(const char* keyName, u8* keyVal, const unsigned keyValLen, char* errInfo, unsigned* fmtLen);
+
+/*
+ *This fucntion called by mwrite command, mread= bulkcmd "download key .." + n * download transfer, for key n==1
+ *Attentions: return value is the key length if burn sucess
+ *@keyName: key name in null-terminated c style string
+ *@keyVal: key value download from USB, "the value for sepecial keyName" may need de-encrypt by user code
+ *@keyValLen: the key value downloaded from usb transfer!
+ *@errInfo: start it with success if burned ok, or format error info into it tell pc burned failed
+ */
+unsigned v2_key_burn(const char* keyName, const u8* keyVal, const unsigned keyValLen, char* errInfo);
+
+#define DDR_MEM_ADDR_START  ( CONFIG_SYS_SDRAM_BASE + (16<<20) )
+
+//  |<---Back 2M---->|<------------USB transfer Buf 64 ----------->|<--Backed sparse format info for verify-->|
+//      Back buf                          Transfer buf
+//TODO: move memory mapping to comman shared header file
+//FIXME:Make sure [0x818<<20, 0x839<<20] not used by others
+//[Buffer 0] DRAM_START, DRAM_START+2M, This range can't be accessed
+//[Buffer 1] Buffer to Back up partition image data that not write back to flash,
+#define OPTIMUS_SPARSE_IMG_LEFT_DATA_ADDR_LOW   (DDR_MEM_ADDR_START + (2U<<20))//Don't access First 1M address
+#define OPTIMUS_SPARSE_IMG_LEFT_DATA_MAX_SZ    (0X2<<20) //back up address for sparse image, 2M
+
+//[Buffer 2] This 64M buffer is used to cache image data received from USB download,
+//            This Buffer size  should be 64M, other size has pending bugs when sparse image is very large.
+#define OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR      (OPTIMUS_SPARSE_IMG_LEFT_DATA_ADDR_LOW + OPTIMUS_SPARSE_IMG_LEFT_DATA_MAX_SZ)
+#define OPTIMUS_DOWNLOAD_TRANSFER_BUF_TOTALSZ   (0X40<<20)//64M
+
+#define OPTIMUS_DOWNLOAD_SLOT_SZ                (64<<10)    //64K
+#define OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS     (16)    //64K
+#define OPTIMUS_DOWNLOAD_SLOT_NUM               (OPTIMUS_DOWNLOAD_TRANSFER_BUF_TOTALSZ/OPTIMUS_DOWNLOAD_SLOT_SZ)
+
+//[Buffer 3] This buffer is used to Back up sparse chunk headers for verifying sparse image
+#define OPTIMUS_DOWNLOAD_SPARSE_INFO_FOR_VERIFY (OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR + OPTIMUS_DOWNLOAD_TRANSFER_BUF_TOTALSZ)
+#define OPTIMUS_DOWNLOAD_SPS_VERIFY_BACK_INFO_SZ (0x2U<<20)
+
+//[Buffer 4] This buffer is used for filling filled-value CHUNK_TYPE_FILL type sparse chunk,
+#define OPTIMUS_SPARSE_IMG_FILL_VAL_BUF         (OPTIMUS_DOWNLOAD_SPARSE_INFO_FOR_VERIFY + OPTIMUS_DOWNLOAD_SPS_VERIFY_BACK_INFO_SZ)
+#define OPTIMUS_SPARSE_IMG_FILL_BUF_SZ          OPTIMUS_DOWNLOAD_SLOT_SZ
+
+//[Buffer 5] This buffer to cache header of burning package when not usb burning
+#define OPTIMUS_BURN_PKG_HEAD_BUF_ADDR          (OPTIMUS_SPARSE_IMG_FILL_VAL_BUF + OPTIMUS_SPARSE_IMG_FILL_BUF_SZ)
+#define OPTIMUS_BURN_PKG_HEAD_BUF_SZ            (1U<<20)//1M should be enough!
+
+//[Buffer 6] This buffer is used to cache logo resources for upgrading
+////buffer to display logo, 10M used now
+#define OPTIMUS_DOWNLOAD_DISPLAY_BUF            (OPTIMUS_BURN_PKG_HEAD_BUF_ADDR + OPTIMUS_BURN_PKG_HEAD_BUF_SZ)
+#define OPTIMUS_DOWNLOAD_BUF_FREE_USE           (OPTIMUS_DOWNLOAD_DISPLAY_BUF + (10U<<20))//free buffer not used by downloading, 2 + 64 + 2 + 10
+
+#define OPTIMUS_VFAT_IMG_WRITE_BACK_SZ          (OPTIMUS_DOWNLOAD_SLOT_SZ*1)//update complete alogrithm if change it
+#define OPTIMUS_SIMG_WRITE_BACK_SZ              OPTIMUS_DOWNLOAD_TRANSFER_BUF_TOTALSZ
+#define OPTIMUS_MEMORY_WRITE_BACK_SZ            (0X2U<<30)//2GBytes
+#define OPTIMUS_BOOTLOADER_MAX_SZ               (2U<<20)//max size is 2M ??
+
+#define OPTIMUS_SHA1SUM_BUFFER_ADDR             OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR
+#define OPTIMUS_SHA1SUM_BUFFER_LEN              (OPTIMUS_DOWNLOAD_TRANSFER_BUF_TOTALSZ/8) //16M each time
+
+//As key size < 64K, So buffer [OPTIMUS_SPARSE_IMG_LEFT_DATA_ADDR_LOW, OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR) not used when download key
+#define OPTIMUS_KEY_DECRYPT_BUF                 OPTIMUS_SPARSE_IMG_LEFT_DATA_ADDR_LOW//buffer for decrypt the key
+#define OPTIMUS_KEY_DECRYPT_BUF_SZ              OPTIMUS_DOWNLOAD_SLOT_SZ
+
+#define OPTIMUS_DTB_LOAD_ADDR                   DDR_MEM_ADDR_START
+
+#define COMPILE_TYPE_CHK(expr, t)       typedef char t[(expr) ? 1 : -1]
+#define COMPILE_TIME_ASSERT(expr)       typedef char assert_type[(expr) ? 1 : -1]
+
+#define OPT_DOWN_OK     0
+#define OPT_DOWN_FAIL   1
+#define OPT_DOWN_TRUE   1
+#define OPT_DOWN_FALSE  0
+
+#define OPTIMUS_MEDIA_TYPE_NAND         0   //nand is default
+#define OPTIMUS_MEDIA_TYPE_SDMMC        1
+#define OPTIMUS_MEDIA_TYPE_SPIFLASH     2
+#define OPTIMUS_MEDIA_TYPE_STORE        3   //store stands for one of nand/emmc/spi, which smart identified by stoarge driver
+#define OPTIMUS_MEDIA_TYPE_MEM          4   //memory, dram and sram
+#define OPTIMUS_MEDIA_TYPE_KEY_UNIFY    5
+
+//Following for optimus_simg2img.c
+int optimus_simg_probe(const u8* source, const u32 length);
+int optimus_simg_parser_init(const u8* source);
+u32 optimus_cb_simg_write_media(const unsigned destAddrInSec, const unsigned dataSzInBy, const char* data);
+int optimus_simg_to_media(char* simgPktHead, const u32 pktLen, u32* unParsedDataLen, const u32 flashAddrInSec);
+int optimus_sparse_get_chunk_data(u8** head, u32* headSz, u32* dataSz, u64* dataOffset);
+int optimus_sparse_back_info_probe(void);
+
+unsigned add_sum(const void* pBuf, const unsigned size);//Add-sum used for 64K transfer
+
+//outStr will be null-terminater after format
+int optimus_hex_data_2_ascii_str(const unsigned char* hexData, const unsigned nBytes, char* outStr, const unsigned strSz);
+
+//for prompting step info
+int optimus_progress_init(const unsigned itemSzHigh, const unsigned itemSzLow, const u32 startStep, const u32 endStep);
+int optimus_progress_exit(void);
+int optimus_update_progress(const unsigned thisBurnSz);
+
+#define DWN_ERR(fmt ...) printf("ERR(%s)L%d:", __FILE__, __LINE__);printf(fmt)
+#define DWN_MSG(fmt ...) printf("[MSG]"fmt)
+#define DWN_WRN(fmt ...) printf("[WRN]"fmt)
+#define DWN_DBG(...)
+#define DWN_HERE()    printf("f(%s)L%d\n", __FILE__, __LINE__)
+
+//common internal function
+int optimus_erase_bootloader(const char* extBootDev);
+void optimus_reset(const int cfgFlag);
+int optimus_storage_init(int toErase);//init dest burning staorge
+int optimus_storage_exit(void);
+int is_optimus_storage_inited(void);
+void optimus_poweroff(void);
+int optimus_burn_complete(const int choice);
+int is_the_flash_first_burned(void);
+int optimus_set_burn_complete_flag(void);//set 'upgrade_step 1' after burnning success
+
+#define OPTIMUS_WORK_MODE_NONE            0
+#define OPTIMUS_WORK_MODE_USB_UPDATE      (0xefe5)
+#define OPTIMUS_WORK_MODE_USB_PRODUCE     (0xefe6)
+#define OPTIMUS_WORK_MODE_SDC_UPDATE      (0xefe7)
+#define OPTIMUS_WORK_MODE_SDC_PRODUCE     (0xefe8)
+#define OPTIMUS_WORK_MODE_SYS_RECOVERY    (0xefe9)
+int optimus_work_mode_get(void);
+int optimus_work_mode_set(int workmode);
+
+#define OPTIMUS_BURN_COMPLETE__POWEROFF_DIRECT              (0X0)
+#define OPTIMUS_BURN_COMPLETE__REBOOT_NORMAL                (0x1)
+#define OPTIMUS_BURN_COMPLETE__POWEROFF_AFTER_POWERKEY      (0x2)
+#define OPTIMUS_BURN_COMPLETE__POWEROFF_AFTER_DISCONNECT    (0x3)
+#define OPTIMUS_BURN_COMPLETE__REBOOT_SDC_BURN              (0xdc)
+#define OPTIMUS_BURN_COMPLETE__REBOOT_UPDATE                (0xeb)
+#define OPTIMUS_BURN_COMPLETE__QUERY                        (0xe1)
+
+#define ROM_BOOT_SKIP_BOOT_ENABLED_4_USB      1//skip boot to usb supported by romboot
+#define ROM_BOOT_SKIP_BOOT_ENABLED_4_SDC      0//skip boot sdcard supported by romboot
+
+//ENV for auto jump into producing
+#define _ENV_TIME_OUT_TO_AUTO_BURN "identifyWaitTime"
+#define AML_SYS_RECOVERY_PART      "aml_sysrecovery"
+
+#endif//ifndef __OPTIMUS_DOWNLOAD_H__
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_download_key.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_download_key.c
new file mode 100644
index 0000000..4863d82
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_download_key.c
@@ -0,0 +1,234 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  v2_download_key.c
+ *
+ *        Version:  1.0
+ *        Created:  2013/9/4 14:10:07
+ *       Compiler:  gcc
+ *
+ *         Author:  Sam Wu (yihui.wu@amlogic.com)
+ *   Organization:  Amlogic Inc.
+ *
+ *       Revision:  none
+ *    Description:  Funcitions and command to burn keys with key_unify driver
+ *
+ * =====================================================================================
+ */
+#include "../v2_burning_i.h"
+#include <amlogic/keyunify.h>
+
+#ifndef CMD_BUFF_SIZE
+#define CMD_BUFF_SIZE (512)
+#endif// #ifndef CMD_BUFF_SIZE
+
+/*
+ *This fucntion called by mwrite command, mread= bulkcmd "download key .." + n * download transfer, for key n==1
+ *Attentions: "return value is the key length" if burn sucess
+
+ *@keyName: key name in null-terminated c style string
+ *@keyVal: key value download from USB, "the value for sepecial keyName" may need de-encrypt by user code
+ *@keyValLen: the key value downloaded from usb transfer!
+ *@errInfo: start it with success if burned ok, or format error info into it tell pc burned failed
+ */
+unsigned v2_key_burn(const char* keyName, const u8* keyVal, const unsigned keyValLen, char* errInfo)
+{
+    int ret = 0;
+    unsigned writtenLen = 0;
+
+    DWN_DBG("to write key[%s] in len=%d\n", keyName, keyValLen);
+    ret = key_manage_write(keyName, keyVal, keyValLen);
+    if (ret) {
+        DWN_ERR("Fail to write key[%s] in len=%d\n", keyName, keyValLen);
+        return 0;
+    }
+
+    writtenLen = ret >=0 ? keyValLen : 0;
+    return writtenLen;
+}
+
+
+/*
+ *This fucntion called by mread command, mread= bulkcmd "upload key .." + n * upload transfer, for key n==1
+ *Attentions: return 0 if success, else failed
+ *@keyName: key name in null-terminated c style string
+ *@keyVal: the buffer to read back the key value
+ *@keyValLen: keyVal len is strict when read, i.e, user must know the length of key he/she wnat to read!!
+ *@errInfo: start it with success if burned ok, or format error info into it tell pc burned failed
+ */
+int v2_key_read(const char* keyName, u8* keyVal, const unsigned keyValLen, char* errInfo, unsigned* fmtLen)
+{
+    ssize_t keysize = 0;
+    int rc = 0;
+
+    rc = key_manage_query_size(keyName, &keysize);
+    if (rc) {
+        sprintf(errInfo, "failed to query key size, err=%d\n", rc);
+        DWN_ERR(errInfo);
+        return __LINE__;
+    }
+
+    rc = key_manage_read(keyName, keyVal, keyValLen);
+
+    *fmtLen = (unsigned)keysize;
+    return rc;
+}
+
+//key command: 1, key init seed_in_str; 2, key uninit
+//argv[0] can be 'key' from usb tool, or 'aml_key_burn/misc' from sdc_burn
+int v2_key_command(const int argc, char * const argv[], char *info)
+{
+    const char* keyCmd = argv[1];
+    int rcode = 0;
+    int subCmd_argc = argc - 1;
+    char* const * subCmd_argv = argv + 1;
+
+    DWN_DBG("argc=%d, argv[%s, %s, %s, %s]\n", argc, argv[0], argv[1], argv[2], argv[3]);
+    if (argc < 2) {
+        sprintf(info, "argc < 2, need key subcmd\n");
+        DWN_ERR(info);
+        return __LINE__;
+    }
+
+    if (!strcmp("init", keyCmd))
+    {
+        if (argc < 3) {
+            sprintf(info, "failed:cmd [key init] must take argument (seedNum)\n");
+            DWN_ERR(info);
+            return __LINE__;
+        }
+
+        rcode = key_manage_init(subCmd_argv[1], subCmd_argv[2]);
+    }
+    else if(!strcmp("uninit", keyCmd))
+    {
+        rcode = key_manage_exit();
+    }
+    else if(!strcmp("is_burned", keyCmd))
+    {
+        if (subCmd_argc < 2) {
+            sprintf(info, "failed: %s %s need a keyName\n", argv[0], argv[1]);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+        const char* queryKey = subCmd_argv[1];
+        int keyIsBurned = 0;
+
+        rcode = key_manage_query_exist(queryKey, &keyIsBurned);
+        if (rcode) {
+            sprintf(info, "failed to query key state, rcode %d\n", rcode);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+        sprintf(info, "%s:key[%s] was %s burned", keyIsBurned ? "success" : "failed",
+                        queryKey, keyIsBurned ? "" : "NOT");
+        rcode = !keyIsBurned;
+    }
+    else if(!strcmp("can_write", keyCmd))
+    {
+        if (subCmd_argc < 2) {
+            sprintf(info, "failed: %s %s need a keyName\n", argv[0], argv[1]);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+        const char* queryKey = subCmd_argv[1];
+        int exist = 0;
+        int canOverWrite = 0;
+
+        rcode = key_manage_query_canOverWrite(queryKey, &canOverWrite);
+        if (rcode) {
+            sprintf(info, "failed in query key over write, rcode %d\n", rcode);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+        rcode = key_manage_query_exist(queryKey, &exist);
+        if (rcode) {
+            sprintf(info, "failed in query key exist, rcode %d\n", rcode);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+
+        int canWrite = ! (exist && !canOverWrite);
+        sprintf(info, "%s:key[%s] %s can write(exist=%d, canOverWrite=%d)\n",
+                canWrite ? "success" : "failed", queryKey, canWrite ? "" : "NOT", exist, canOverWrite);
+        rcode = !canWrite;
+    }
+    else if(!strcmp("can_read", keyCmd))
+    {
+        int isSecure    = 0;
+        int exist       = 0;
+        const char* queryKey = subCmd_argv[1];
+
+        rcode = key_manage_query_exist(queryKey, &exist);
+        if (rcode) {
+            sprintf(info, "failed in query key exist, rcode %d\n", rcode);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+        rcode = key_manage_query_secure(queryKey,&isSecure);
+        if (rcode) {
+            sprintf(info, "failed in query key secure, rcode %d\n", rcode);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+        sprintf(info, "%s:key[%s] %s can read\n",
+                isSecure ? "failed" : "success", queryKey, isSecure ? "NOT" : "");
+        rcode = isSecure;
+    }
+    else if(!strcmp("write", keyCmd))
+    {
+        const char* keyName = subCmd_argv[1];
+        const char* keyValInStr = subCmd_argv[2];
+
+        if (subCmd_argc < 3) {
+            sprintf(info, "failed: %s %s need a keyName and keyValInStr\n", argv[0], argv[1]);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+
+        rcode = v2_key_burn(keyName, (u8*)keyValInStr, strlen(keyValInStr), info);
+        rcode = (strlen(keyValInStr) == rcode) ? 0 : __LINE__;
+    }
+    else if(!strcmp("read", keyCmd))
+    {
+        const char* keyName = subCmd_argv[1];
+        const int cswBufLen = CMD_BUFF_SIZE - sizeof("success") + 1;
+        unsigned char* keyValBuf = (unsigned char*)info + CMD_BUFF_SIZE - cswBufLen;
+
+        if (subCmd_argc < 2) {
+            sprintf(info, "failed: %s %s need a keyName\n", argv[0], argv[1]);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+
+        sprintf(info, "keyman read %s 0x%p str", keyName, keyValBuf);
+        rcode = run_command(info, 0);
+        if (!rcode)
+            sprintf(info, "success:%s=[%s]", keyName, getenv(keyName));
+        else
+            sprintf(info, "failed in read key");
+    }
+    else if(!strcmp("get_len", keyCmd))
+    {
+        ssize_t keySz       = 0;
+        const char* queryKey = subCmd_argv[1];
+
+        rcode = key_manage_query_size(queryKey,&keySz);
+        if (rcode) {
+            sprintf(info, "failed in query key size, rcode %d\n", rcode);
+            DWN_ERR(info);
+            return __LINE__;
+        }
+        sprintf(info, "success%zd\n", keySz);
+        rcode = !keySz;
+    }
+    else{
+        sprintf(info, "failed:Error keyCmd[%s]\n", keyCmd);
+        DWN_ERR(info);
+        rcode = __LINE__;
+    }
+
+    DWN_DBG("rcode 0x%x\n", rcode);
+    return rcode;
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_fat.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_fat.c
new file mode 100644
index 0000000..23761b2
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_fat.c
@@ -0,0 +1,1383 @@
+/*
+ * fat.c
+ *
+ * R/O (V)FAT 12/16/32 filesystem implementation by Marcus Sundberg
+ *
+ * 2002-07-28 - rjones@nexus-tech.net - ported to ppcboot v1.1.6
+ * 2003-03-10 - kharris@nexus-tech.net - ported to uboot
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../v2_burning_i.h"
+#include <part.h>
+#include <fat.h>
+#include <partition_table.h>
+#include <mmc.h>
+#include <linux/ctype.h>
+
+#undef  FAT_ERROR
+#define FAT_ERROR(fmt...) printf("[FAT_ERR]L%d,", __LINE__),printf(fmt)
+#ifndef FAT_DPRINT
+#define FAT_DPRINT(fmt ...)      //printf("[FAT_DP]L%d,", __LINE__),printf(fmt)
+#endif
+
+#ifndef SECTOR_SIZE
+#define SECTOR_SIZE 512
+#endif
+#ifndef FS_BLOCK_SIZE
+#define FS_BLOCK_SIZE   SECTOR_SIZE
+#endif
+
+#define FAT_MSG(fmt...) printf("[fat]"fmt)
+
+static int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr);
+
+#if 0
+int optimus_sdc_burn_switch_to_extmmc(void)
+{
+    static struct mmc *mmc = NULL;
+
+    //Attention: So far the work flow of sdc_burn or sdc_update after store_init(0), so device_boot_flag is setup yet!
+    if (SPI_EMMC_FLAG != device_boot_flag && EMMC_BOOT_FLAG != device_boot_flag) {
+        return 0;
+    }
+
+    if (!mmc)
+    {
+        mmc = find_mmc_device(0);
+        if (!mmc) {
+            FAT_ERROR("Fail to find mmc 0 device");
+            return __LINE__;
+        }
+    }
+    if (mmc_init(mmc)) {
+        FAT_ERROR("Fail to init mmc 0 device");
+        return __LINE__;
+    }
+
+    return 0;
+}
+#else
+int optimus_sdc_burn_switch_to_extmmc(void)
+{
+        return 0;
+}
+#endif//
+
+static int v2_ext_mmc_read(__u32 startblock, __u32 nBlk, __u8 * bufptr)
+{
+    int ret = 0;
+    char* usb_update = getenv("usb_update");
+    if (strcmp(usb_update,"1"))
+    {
+            ret = optimus_sdc_burn_switch_to_extmmc();
+            if (ret) {
+                    FAT_ERROR("failed in switch to extmmc.\n");
+                    return __LINE__;
+            }
+    }
+
+    ret = disk_read(startblock, nBlk, bufptr);
+
+    return ret;
+}
+
+/*
+ * Convert a string to lowercase.
+ */
+static void
+downcase(char *str)
+{
+	while (*str != '\0') {
+        *str = tolower(*str);
+        str++;
+    }
+}
+
+static  block_dev_desc_t *cur_dev = NULL;
+static unsigned long part_offset = 0;
+static int cur_part = 1;
+
+#define DOS_PART_TBL_OFFSET		0x1be
+#define DOS_PART_MAGIC_OFFSET	0x1fe
+#define FAT_FS_TYPE_OFFSET		0x36
+#define FAT32_FS_TYPE_OFFSET		0x52
+
+static int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr)
+{
+    startblock += part_offset;
+	if (cur_dev == NULL)
+        return -1;
+	if (cur_dev->block_read) {
+        return cur_dev->block_read (cur_dev->dev
+            , startblock, getsize, (unsigned long *)bufptr);
+    }
+    return -1;
+}
+
+int optimus_fat_register_device(block_dev_desc_t *dev_desc, int part_no)
+{
+    unsigned char buffer[SECTOR_SIZE];
+    disk_partition_t info;
+
+	if (!dev_desc->block_read)
+        return -1;
+    cur_dev = dev_desc;
+    /* check if we have a MBR (on floppies we have only a PBR) */
+	if (dev_desc->block_read (dev_desc->dev, 0, 1, (ulong *) buffer) != 1) {
+        printf ("** Can't read from device %d **\n", dev_desc->dev);
+        return -1;
+    }
+	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
+        buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
+        /* no signature found */
+        return -1;
+    }
+#if (defined(CONFIG_CMD_IDE) || \
+     defined(CONFIG_CMD_SATA) || \
+     defined(CONFIG_CMD_SCSI) || \
+     defined(CONFIG_CMD_USB) || \
+     defined(CONFIG_MMC) || \
+     defined(CONFIG_SYSTEMACE) )
+    /* First we assume, there is a MBR */
+	if (!get_partition_info (dev_desc, part_no, &info)) {
+        part_offset = info.start;
+        cur_part = part_no;
+		if (dev_desc->block_read (dev_desc->dev, part_offset, 1, (ulong *) buffer) != 1) {
+			if (dev_desc->block_read (dev_desc->dev, 0, 1, (ulong *) buffer) != 1) {
+                printf ("** Can't read from device %d **\n", dev_desc->dev);
+                return -1;
+            }
+            cur_part = 1;
+            part_offset = 0;
+        }
+		if (strncmp((char *)&buffer[FAT_FS_TYPE_OFFSET], "FAT", 3) && strncmp((char *)&buffer[FAT32_FS_TYPE_OFFSET],"FAT",3))
+            return -1;
+    } else if (!strncmp((char *)&buffer[FAT_FS_TYPE_OFFSET], "FAT", 3) || !strncmp((char *)&buffer[FAT32_FS_TYPE_OFFSET],"FAT",3)) {
+        /* ok, we assume we are on a PBR only */
+        cur_part = 1;
+        part_offset = 0;
+    } else {
+        printf ("** Partition %d not valid on device %d **\n",
+                part_no, dev_desc->dev);
+        return -1;
+    }
+
+#else
+	if (!strncmp((char *)&buffer[FAT_FS_TYPE_OFFSET],"FAT",3) || !strncmp((char *)&buffer[FAT32_FS_TYPE_OFFSET],"FAT",3)) {
+        /* ok, we assume we are on a PBR only */
+        cur_part = 1;
+        part_offset = 0;
+        info.start = part_offset;
+    } else {
+        /* FIXME we need to determine the start block of the
+         * partition where the DOS FS resides. This can be done
+         * by using the get_partition_info routine. For this
+         * purpose the libpart must be included.
+         */
+        part_offset = 32;
+        cur_part = 1;
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Get the first occurence of a directory delimiter ('/' or '\') in a string.
+ * Return index into string if found, -1 otherwise.
+ */
+static int
+dirdelim(char *str)
+{
+	char *start = str;
+
+	while (*str != '\0') {
+		if (ISDIRDELIM(*str)) return str - start;
+		str++;
+	}
+	return -1;
+}
+
+
+/*
+ * Match volume_info fs_type strings.
+ * Return 0 on match, -1 otherwise.
+ */
+static int
+compare_sign(char *str1, char *str2)
+{
+	char *end = str1+SIGNLEN;
+
+	while (str1 != end) {
+		if (*str1 != *str2) {
+			return -1;
+		}
+		str1++;
+		str2++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Extract zero terminated short name from a directory entry.
+ */
+static void get_name (dir_entry *dirent, char *s_name)
+{
+	char *ptr;
+
+	memcpy (s_name, dirent->name, 8);
+	s_name[8] = '\0';
+	ptr = s_name;
+	while (*ptr && *ptr != ' ')
+		ptr++;
+	if (dirent->ext[0] && dirent->ext[0] != ' ') {
+		*ptr = '.';
+		ptr++;
+		memcpy (ptr, dirent->ext, 3);
+		ptr[3] = '\0';
+		while (*ptr && *ptr != ' ')
+			ptr++;
+	}
+	*ptr = '\0';
+	if (*s_name == DELETED_FLAG)
+		*s_name = '\0';
+	else if (*s_name == aRING)
+		*s_name = DELETED_FLAG;
+	downcase (s_name);
+}
+
+/*
+ * Get the cluster entry at index 'entry' in a FAT (12/16/32) table.
+ * On failure 0x00 is returned.
+ */
+static __u32
+get_fatent(fsdata *mydata, __u32 entry/*cluster index*/)
+{
+	__u32 bufnum;
+	__u32 offset;
+	__u32 ret = 0x00;//On failure 0x00 is returned.
+
+	switch (mydata->fatsize) {
+	case 32:
+		bufnum = entry / FAT32BUFSIZE;
+		offset = entry - bufnum * FAT32BUFSIZE;
+		break;
+	case 16:
+		bufnum = entry / FAT16BUFSIZE;
+		offset = entry - bufnum * FAT16BUFSIZE;
+		break;
+	case 12:
+		bufnum = entry / FAT12BUFSIZE;
+		offset = entry - bufnum * FAT12BUFSIZE;
+		break;
+
+	default:
+		/* Unsupported FAT size */
+		return ret;
+	}
+
+	/* Read a new block of FAT entries into the cache. */
+    /* this block of FAT entries is not cached */
+	if (bufnum != mydata->fatbufnum) {
+		int getsize = FATBUFSIZE/FS_BLOCK_SIZE;//==6
+		__u8 *bufptr = mydata->fatbuf;
+		__u32 fatlength = mydata->fatlength;
+		__u32 startblock = bufnum * FATBUFBLOCKS;
+
+		fatlength *= SECTOR_SIZE;	/* We want it in bytes now */
+		startblock += mydata->fat_sect;	/* Offset from start of disk */
+
+		if (getsize > fatlength) getsize = fatlength;
+		if (v2_ext_mmc_read(startblock, getsize, bufptr) < 0) {
+			FAT_ERROR("Error reading FAT blocks\n");
+			return ret;
+		}
+		mydata->fatbufnum = bufnum;
+	}
+
+	/* Get the actual entry from the table */
+	switch (mydata->fatsize) {
+	case 32:
+	FAT_DPRINT("mydata=0x%p, fatbuf=0x%p, offset=%d\n", mydata, mydata->fatbuf, offset);
+		ret = FAT2CPU32(((__u32*)mydata->fatbuf)[offset]);
+		break;
+	case 16:
+		ret = FAT2CPU16(((__u16*)mydata->fatbuf)[offset]);
+		break;
+	case 12: {
+		__u32 off16 = (offset*3)/4;
+		__u16 val1, val2;
+
+		switch (offset & 0x3) {
+		case 0:
+			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
+			ret &= 0xfff;
+			break;
+		case 1:
+			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
+			val1 &= 0xf000;
+			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
+			val2 &= 0x00ff;
+			ret = (val2 << 4) | (val1 >> 12);
+			break;
+		case 2:
+			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
+			val1 &= 0xff00;
+			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
+			val2 &= 0x000f;
+			ret = (val2 << 8) | (val1 >> 8);
+			break;
+		case 3:
+			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);;
+			ret = (ret & 0xfff0) >> 4;
+			break;
+		default:
+			break;
+		}
+	}
+	break;
+	}
+	FAT_DPRINT("ret: %d, offset: %d\n", ret, offset);
+
+	return ret;
+}
+
+static int optimus_fat_get_fat_next_entry(fsdata* mydata, __u32 curclust, __u32* nextEntry, __u32 filesize, __u32 offset)
+{
+		//not next ccluster as file end
+        if (offset >= filesize) return 0;
+
+		curclust = get_fatent(mydata, curclust);//get next cluster index
+        if (CHECK_CLUST(curclust, mydata->fatsize)) {
+				FAT_ERROR("curclust: 0x%x\n", curclust);
+				FAT_ERROR("Invalid FAT entry\n");
+				return __LINE__;
+		}
+
+		*nextEntry = curclust;
+		return 0;
+}
+
+/*
+ * Read at most 'size' bytes from the specified cluster into 'buffer'.
+ * Return 0 on success, -1 otherwise.
+ */
+static int
+get_cluster(fsdata *mydata, const __u32 clustnum, __u8 *buffer, const unsigned long size)
+{
+	int idx = 0;
+	__u32 startsect;
+
+	if (clustnum > 0) {
+		startsect = mydata->data_begin + clustnum*mydata->clust_size;
+	} else {
+		startsect = mydata->rootdir_sect;
+	}
+
+	FAT_DPRINT("gc - clustnum: %d, startsect: %d\n", clustnum, startsect);
+	if (v2_ext_mmc_read(startsect, size/FS_BLOCK_SIZE , buffer) < 0) {
+		FAT_DPRINT("Error reading data\n");
+		return -1;
+	}
+	if (size % FS_BLOCK_SIZE) {
+		__u8 tmpbuf[FS_BLOCK_SIZE];
+		idx= size/FS_BLOCK_SIZE;
+		if (v2_ext_mmc_read(startsect + idx, 1, tmpbuf) < 0) {
+			FAT_ERROR("Error reading data\n");
+			return -1;
+		}
+		buffer += idx*FS_BLOCK_SIZE;
+
+		memcpy(buffer, tmpbuf, size % FS_BLOCK_SIZE);
+		return 0;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_SUPPORT_VFAT
+/*
+ * Extract the file name information from 'slotptr' into 'l_name',
+ * starting at l_name[*idx].
+ * Return 1 if terminator (zero byte) is found, 0 otherwise.
+ */
+static int
+slot2str(dir_slot *slotptr, char *l_name, int *idx)
+{
+	int j;
+
+	for (j = 0; j <= 8; j += 2) {
+		l_name[*idx] = slotptr->name0_4[j];
+		if (l_name[*idx] == 0x00) return 1;
+		(*idx)++;
+	}
+	for (j = 0; j <= 10; j += 2) {
+		l_name[*idx] = slotptr->name5_10[j];
+		if (l_name[*idx] == 0x00) return 1;
+		(*idx)++;
+	}
+	for (j = 0; j <= 2; j += 2) {
+		l_name[*idx] = slotptr->name11_12[j];
+		if (l_name[*idx] == 0x00) return 1;
+		(*idx)++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Extract the full long filename starting at 'retdent' (which is really
+ * a slot) into 'l_name'. If successful also copy the real directory entry
+ * into 'retdent'
+ * Return 0 on success, -1 otherwise.
+ */
+__attribute__ ((__aligned__(__alignof__(dir_entry))))
+__u8 get_vfatname_block[MAX_CLUSTSIZE];
+static int
+get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
+		  dir_entry *retdent, char *l_name)
+{
+	dir_entry *realdent;
+	dir_slot  *slotptr = (dir_slot*) retdent;
+	__u8	  *nextclust = cluster + mydata->clust_size * SECTOR_SIZE;
+	__u8	   counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
+	int idx = 0;
+
+	while ((__u8*)slotptr < nextclust) {
+		if (counter == 0) break;
+		if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
+			return -1;
+		slotptr++;
+		counter--;
+	}
+
+	if ((__u8*)slotptr >= nextclust) {
+		dir_slot *slotptr2;
+
+		slotptr--;
+		curclust = get_fatent(mydata, curclust);
+		if (CHECK_CLUST(curclust, mydata->fatsize)) {
+			FAT_ERROR("curclust: 0x%x\n", curclust);
+			FAT_ERROR("Invalid FAT entry\n");
+			return -1;
+		}
+		if (get_cluster(mydata, curclust, get_vfatname_block,
+				mydata->clust_size * SECTOR_SIZE) != 0) {
+						FAT_ERROR("Error: reading directory block\n");
+			return -1;
+		}
+		slotptr2 = (dir_slot*) get_vfatname_block;
+		while (slotptr2->id > 0x01) {
+			slotptr2++;
+		}
+		/* Save the real directory entry */
+		realdent = (dir_entry*)slotptr2 + 1;
+		while ((__u8*)slotptr2 >= get_vfatname_block) {
+			slot2str(slotptr2, l_name, &idx);
+			slotptr2--;
+		}
+	} else {
+		/* Save the real directory entry */
+		realdent = (dir_entry*)slotptr;
+	}
+
+	do {
+		slotptr--;
+		if (slot2str(slotptr, l_name, &idx)) break;
+	} while (!(slotptr->id & LAST_LONG_ENTRY_MASK));
+
+	l_name[idx] = '\0';
+	if (*l_name == DELETED_FLAG) *l_name = '\0';
+	else if (*l_name == aRING) *l_name = DELETED_FLAG;
+	downcase(l_name);
+
+	/* Return the real directory entry */
+	memcpy(retdent, realdent, sizeof(dir_entry));
+
+	return 0;
+}
+
+
+/* Calculate short name checksum */
+static __u8
+mkcksum(const char *str)
+{
+	int i;
+	__u8 ret = 0;
+
+	for (i = 0; i < 11; i++) {
+		ret = (((ret&1)<<7)|((ret&0xfe)>>1)) + str[i];
+	}
+
+	return ret;
+}
+#endif
+
+
+/*
+ * Get the directory entry associated with 'filename' from the directory
+ * starting at 'startsect'
+ */
+__attribute__ ((__aligned__(__alignof__(dir_entry))))
+static __u8 get_dentfromdir_block[MAX_CLUSTSIZE];
+static dir_entry *get_dentfromdir (fsdata * mydata, int startsect,
+				   char *filename, dir_entry * retdent,
+				   int dols)
+{
+    __u16 prevcksum = 0xffff;
+    __u32 curclust = START (retdent);
+    int files = 0, dirs = 0;
+
+    FAT_DPRINT ("get_dentfromdir: %s\n", filename);
+    while (1) {
+	dir_entry *dentptr;
+	int i;
+
+	if (get_cluster (mydata, curclust, get_dentfromdir_block,
+		 mydata->clust_size * SECTOR_SIZE) != 0) {
+	    FAT_DPRINT ("Error: reading directory block\n");
+	    return NULL;
+	}
+	dentptr = (dir_entry *) get_dentfromdir_block;
+	for (i = 0; i < DIRENTSPERCLUST; i++) {
+	    char s_name[14], l_name[256];
+
+	    l_name[0] = '\0';
+	    if (dentptr->name[0] == DELETED_FLAG) {
+		    dentptr++;
+		    continue;
+	    }
+	    if ((dentptr->attr & ATTR_VOLUME)) {
+#ifdef CONFIG_SUPPORT_VFAT
+		if ((dentptr->attr & ATTR_VFAT) &&
+		    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
+		    prevcksum = ((dir_slot *) dentptr)
+			    ->alias_checksum;
+		    get_vfatname (mydata, curclust, get_dentfromdir_block,
+				  dentptr, l_name);
+		    if (dols) {
+			int isdir = (dentptr->attr & ATTR_DIR);
+			char dirc;
+			int doit = 0;
+
+			if (isdir) {
+			    dirs++;
+			    dirc = '/';
+			    doit = 1;
+			} else {
+			    dirc = ' ';
+			    if (l_name[0] != 0) {
+				files++;
+				doit = 1;
+			    }
+			}
+			if (doit) {
+			    if (dirc == ' ') {
+				printf (" %8ld   %s%c\n",
+					(long) FAT2CPU32 (dentptr->size),
+					l_name, dirc);
+			    } else {
+				printf ("            %s%c\n", l_name, dirc);
+			    }
+			}
+			dentptr++;
+			continue;
+		    }
+		    FAT_DPRINT ("vfatname: |%s|\n", l_name);
+		} else
+#endif
+		{
+		    /* Volume label or VFAT entry */
+		    dentptr++;
+		    continue;
+		}
+	    }
+	    if (dentptr->name[0] == 0) {
+		if (dols) {
+		    printf ("\n%d file(s), %d dir(s)\n\n", files, dirs);
+		}
+		FAT_DPRINT ("Dentname == NULL - %d\n", i);
+		return NULL;
+	    }
+#ifdef CONFIG_SUPPORT_VFAT
+	    if (dols && mkcksum (dentptr->name) == prevcksum) {
+		dentptr++;
+		continue;
+	    }
+#endif
+	    get_name (dentptr, s_name);
+	    if (dols) {
+		int isdir = (dentptr->attr & ATTR_DIR);
+		char dirc;
+		int doit = 0;
+
+		if (isdir) {
+		    dirs++;
+		    dirc = '/';
+		    doit = 1;
+		} else {
+		    dirc = ' ';
+		    if (s_name[0] != 0) {
+			files++;
+			doit = 1;
+		    }
+		}
+		if (doit) {
+		    if (dirc == ' ') {
+			printf (" %8ld   %s%c\n",
+				(long) FAT2CPU32 (dentptr->size), s_name,
+				dirc);
+		    } else {
+			printf ("            %s%c\n", s_name, dirc);
+		    }
+		}
+		dentptr++;
+		continue;
+	    }
+	    if (strcmp (filename, s_name) && strcmp (filename, l_name)) {
+		FAT_DPRINT ("Mismatch: |%s|%s|\n", s_name, l_name);
+		dentptr++;
+		continue;
+	    }
+	    memcpy (retdent, dentptr, sizeof (dir_entry));
+
+	    FAT_DPRINT ("DentName: %s", s_name);
+	    FAT_DPRINT (", start: 0x%x", START (dentptr));
+	    FAT_DPRINT (", size:  0x%x %s\n",
+			FAT2CPU32 (dentptr->size),
+			(dentptr->attr & ATTR_DIR) ? "(DIR)" : "");
+
+	    return retdent;
+	}
+	curclust = get_fatent (mydata, curclust);
+	if (CHECK_CLUST(curclust, mydata->fatsize)) {
+	    FAT_DPRINT ("curclust: 0x%x\n", curclust);
+	    FAT_ERROR ("Invalid FAT entry\n");
+	    return NULL;
+	}
+    }
+
+    return NULL;
+}
+
+
+/*
+ * Read boot sector and volume info from a FAT filesystem
+ */
+static int
+read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
+{
+	__u8 block[FS_BLOCK_SIZE];
+	volume_info *vistart;
+	char *fstype;
+
+	if (disk_read(0, 1, block) < 0) {
+		FAT_ERROR("Error: reading block\n");
+		return -1;
+	}
+
+	memcpy(bs, block, sizeof(boot_sector));
+	bs->reserved	= FAT2CPU16(bs->reserved);
+	bs->fat_length	= FAT2CPU16(bs->fat_length);
+	bs->secs_track	= FAT2CPU16(bs->secs_track);
+	bs->heads	= FAT2CPU16(bs->heads);
+#if 0 /* UNUSED */
+	bs->hidden	= FAT2CPU32(bs->hidden);
+#endif
+	bs->total_sect	= FAT2CPU32(bs->total_sect);
+
+	/* FAT32 entries */
+	if (bs->fat_length == 0) {
+		/* Assume FAT32 */
+		bs->fat32_length = FAT2CPU32(bs->fat32_length);
+		bs->flags	 = FAT2CPU16(bs->flags);
+		bs->root_cluster = FAT2CPU32(bs->root_cluster);
+		bs->info_sector  = FAT2CPU16(bs->info_sector);
+		bs->backup_boot  = FAT2CPU16(bs->backup_boot);
+		vistart = (volume_info*) (block + sizeof(boot_sector));
+		*fatsize = 32;
+	} else {
+		vistart = (volume_info*) &(bs->fat32_length);
+		*fatsize = 0;
+	}
+	memcpy(volinfo, vistart, sizeof(volume_info));
+
+	/*
+	 * Terminate fs_type string. Writing past the end of vistart
+	 * is ok - it's just the buffer.
+	 */
+	fstype = vistart->fs_type;
+	fstype[8] = '\0';
+
+	if (*fatsize == 32) {
+		if (compare_sign(FAT32_SIGN, vistart->fs_type) == 0) {
+			return 0;
+		}
+	} else {
+		if (compare_sign(FAT12_SIGN, vistart->fs_type) == 0) {
+			*fatsize = 12;
+			return 0;
+		}
+		if (compare_sign(FAT16_SIGN, vistart->fs_type) == 0) {
+			*fatsize = 16;
+			return 0;
+		}
+	}
+
+	FAT_ERROR("Error: broken fs_type sign\n");
+	return -1;
+}
+
+__attribute__ ((__aligned__(__alignof__(dir_entry))))
+__u8 do_fat_read_block[MAX_CLUSTSIZE];
+
+//////////////////////////////////////////////////////////////////////
+
+__attribute__ ((__aligned__(__alignof__(dir_entry))))
+__u8 _do_fat_read_block[MAX_CLUSTSIZE];
+
+
+#define FILE_MAX 2
+struct _fs_info
+{
+    fsdata datablock;
+    volume_info volinfo;
+    boot_sector bs;
+
+    char *fat_buf;
+    unsigned fat_buf_cluster_index;//remember the index that which cluster was cached
+};
+
+struct file
+{
+    dir_entry dent;
+    unsigned long offset;
+    unsigned long filesize;
+    __u32 curclust;//next cluster to read
+    __u32 headclust;
+
+};
+
+static struct file files[FILE_MAX];
+static struct _fs_info fs_info[FILE_MAX];
+static int _fd[FILE_MAX] = {0};
+#define OPTIMUS_FD_MAGIC        (0XEFE80025)
+#define OPTIMUS_INVAL_FD        (-1)
+
+static int get_fd(void)
+{
+        int index = 0;
+
+        for (; index < FILE_MAX; ++index) {
+                if (OPTIMUS_FD_MAGIC != _fd[index]) {//fd not used
+                        _fd[index] = OPTIMUS_FD_MAGIC;
+                        return index;
+                }
+        }
+
+        return OPTIMUS_INVAL_FD;
+}
+
+static void put_fd(int fd_index)
+{
+    if (fd_index >= 0)
+        _fd[fd_index] = 0;
+    return;
+}
+
+/* wherehence: 0 to seek from start of file; 1 to seek from current position from file */
+int do_fat_fseek(int fd, const __u64 offset, int wherehence)
+{
+    unsigned long curoffset;
+    unsigned long offset_in_clust;
+	unsigned long seeked;
+    const unsigned int bytesperclust = fs_info[fd].datablock.clust_size * SECTOR_SIZE;
+    const unsigned long filesize = files[fd].filesize;
+    __u32 curclust;
+
+    if (fd<0) {
+        FAT_ERROR("invalid fd %d\n", fd);
+        return -1;
+    }
+
+    curclust = files[fd].curclust;
+    curoffset = files[fd].offset;
+
+    if (wherehence == 0)
+    {
+        const unsigned long curClusterOffset = curoffset - (curoffset & (bytesperclust - 1));
+
+        if (offset > filesize) {
+            FAT_ERROR("offset %llx > filesize %lx\n", offset, filesize);
+            return -1;
+        }
+
+        if (offset < curoffset) //seek from head if want to seek backwards
+        {
+            curclust = files[fd].headclust;
+            seeked=0;
+        }
+        else if(curClusterOffset + bytesperclust > offset)//Not need to actual seek as just in the right cluster
+        {
+            files[fd].offset = offset;
+            return 0;
+        }
+        else//seek from the current cluster
+        {
+            seeked = curoffset - (curoffset & (bytesperclust - 1));//curclust not need to change
+            FAT_MSG("Seek 0x%llx from 0x%lx\n", offset, curoffset);
+        }
+
+        /* seek to offset */
+        while (1)
+        {
+
+            if (seeked + bytesperclust > offset)
+            {
+                fsdata* mydata = &fs_info[fd].datablock;
+                __u8*   clusterCache = (__u8*)fs_info[fd].fat_buf;
+
+                files[fd].curclust = curclust;
+                files[fd].offset = offset;
+
+                if ((offset & (bytesperclust - 1)) && curclust != fs_info[fd].fat_buf_cluster_index)
+                {//cache the cluster if want to read from the offset where not align in cluster, and not cached yet
+                    if (get_cluster(mydata, curclust, clusterCache, (int)bytesperclust) != 0) {
+                        FAT_ERROR("Error reading cluster\n");
+                        return -1;
+                    }
+                    fs_info[fd].fat_buf_cluster_index = curclust;
+                }
+
+                break;
+            }
+
+            curclust = get_fatent(&fs_info[fd].datablock, curclust);
+
+            seeked += bytesperclust;
+        }
+    }
+    else if(wherehence == 1)//this branch not used and not checked!
+    {
+        if (offset + curoffset > filesize) {
+            DWN_ERR("offset 0x%llx + curoffset 0x%lx > filesize 0x%lx\n", offset, curoffset, filesize);
+            return __LINE__;
+        }
+        if (offset == 0)
+            return 0;
+
+        curclust = files[fd].curclust;
+
+        seeked=0;
+        /* seek to offset */
+
+        offset_in_clust = curoffset % bytesperclust;
+
+        if (offset_in_clust + offset <= bytesperclust)
+        {
+            files[fd].offset += offset;
+            return 0;
+        }
+        else
+        {
+            //round down to cluster boundry.
+            const __u64 aimOffset = offset + offset_in_clust;
+            /*offset += offset_in_clust;*/
+
+            while (1) {
+
+                if (seeked + bytesperclust > aimOffset)
+                {
+                    files[fd].curclust = curclust;
+                    files[fd].offset = aimOffset;
+                    break;
+                }
+
+                curclust = get_fatent(&fs_info[fd].datablock, curclust);
+
+                seeked += bytesperclust;
+            }
+        }
+
+    }
+
+    return 0;
+}
+
+long do_fat_fopen(const char *filename)
+{
+    unsigned int bytesperclust;
+    char fnamecopy[2048];
+    fsdata *mydata;
+    int fd;
+    dir_entry *dentptr;
+    char *subname = "";
+    int rootdir_size, cursect;
+    int idx, isdir = 0;
+    boot_sector* bs = NULL;
+    struct _fs_info* theFsInfo = NULL;
+    /*int firsttime;*/
+
+    if ((fd = get_fd()) < 0) {
+        FAT_ERROR("get_fd failed\n");
+        return -1;
+    }
+
+    theFsInfo = fs_info + fd;
+    mydata  = &theFsInfo->datablock;
+    bs      = &theFsInfo->bs;
+
+    if (read_bootsectandvi (bs, &theFsInfo->volinfo, &mydata->fatsize)) {
+        FAT_ERROR ("Error: reading boot sector\n");
+        put_fd(fd);
+        return -1;
+    }
+    if (mydata->fatsize == 32) {
+        mydata->fatlength = bs->fat32_length;
+    } else {
+        mydata->fatlength = bs->fat_length;
+    }
+    mydata->fat_sect = bs->reserved;
+    cursect = mydata->rootdir_sect
+        = mydata->fat_sect + mydata->fatlength * bs->fats;
+    mydata->clust_size = bs->cluster_size;
+    mydata->sect_size = (bs->sector_size[1] << 8) + bs->sector_size[0];
+    if (mydata->fatsize == 32) {
+        rootdir_size = mydata->clust_size;
+        mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
+            - (mydata->clust_size * 2);
+    } else {
+        rootdir_size = ((bs->dir_entries[1] * (int) 256 + bs->dir_entries[0])
+                * sizeof (dir_entry)) / SECTOR_SIZE;
+        mydata->data_begin = mydata->rootdir_sect + rootdir_size
+            - (mydata->clust_size * 2);
+    }
+    mydata->fatbufnum = -1;
+    mydata->fatbuf = memalign(ARCH_DMA_MINALIGN, FATBUFSIZE);
+	if (mydata->fatbuf == NULL) {
+        debug("Error: allocating memory\n");
+        put_fd(fd);
+        return -1;
+    }
+
+    FAT_DPRINT("sect_size=0x%x\n", mydata->sect_size);
+    FAT_DPRINT ("FAT%d, fatlength: %d\n", mydata->fatsize, mydata->fatlength);
+    FAT_DPRINT ("Rootdir begins at sector: %d, offset: %x, size: %d\n"
+            "Data begins at: %d\n",
+            mydata->rootdir_sect, mydata->rootdir_sect * SECTOR_SIZE,
+            rootdir_size, mydata->data_begin);
+    FAT_DPRINT ("Cluster size: %d\n", mydata->clust_size);
+/* "cwd" is always the root... */
+    while (ISDIRDELIM (*filename))
+        filename++;
+    /* Make a copy of the filename and convert it to lowercase */
+    strcpy (fnamecopy, filename);
+    downcase (fnamecopy);
+    if (*fnamecopy == '\0') {
+        put_fd(fd);
+        return -1;
+    } else if ((idx = dirdelim (fnamecopy)) >= 0) {
+        isdir = 1;
+        fnamecopy[idx] = '\0';
+        subname = fnamecopy + idx + 1;
+        /* Handle multiple delimiters */
+        while (ISDIRDELIM (*subname))
+            subname++;
+    }
+
+    while (1)
+    {
+        int i;
+
+        if (v2_ext_mmc_read(cursect, mydata->clust_size, _do_fat_read_block) < 0) {
+            FAT_ERROR ("Error: reading rootdir block\n");
+            put_fd(fd);
+            return -1;
+        }
+        dentptr = (dir_entry *) _do_fat_read_block;
+        for (i = 0; i < DIRENTSPERBLOCK; i++) {
+            char s_name[14], l_name[256];
+
+            l_name[0] = '\0';
+            if ((dentptr->attr & ATTR_VOLUME)) {
+#ifdef CONFIG_SUPPORT_VFAT
+                if (((dentptr->attr & ATTR_VFAT) == ATTR_VFAT) &&
+                        (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
+                    get_vfatname (mydata, 0, _do_fat_read_block, dentptr, l_name);
+                    FAT_DPRINT("l_name=%s\n", l_name);
+                }
+                else
+#endif
+                {
+                    /* Volume label or VFAT entry */
+                    dentptr++;
+                    continue;
+                }
+            } else if (dentptr->name[0] == 0) {
+                FAT_DPRINT ("RootDentname == NULL - %d\n", i);
+                put_fd(fd);
+                return -1;
+            }
+
+            get_name (dentptr, s_name);
+
+            if (strcmp (fnamecopy, s_name) && strcmp (fnamecopy, l_name)) {
+                FAT_DPRINT ("RootMismatch: |%s|%s|\n", s_name, l_name);
+                dentptr++;
+                continue;
+            }
+            if (isdir && !(dentptr->attr & ATTR_DIR))
+            {
+                put_fd(fd);
+                return -1;
+            }
+            FAT_DPRINT ("RootName: %s", s_name);
+            FAT_DPRINT (", start: 0x%x", START (dentptr));
+            FAT_DPRINT (", size:  0x%x %s\n",
+                    FAT2CPU32 (dentptr->size), isdir ? "(DIR)" : "");
+
+            goto rootdir_done;  /* We got a match */
+        }
+        cursect++;
+    }
+rootdir_done:
+
+    /*firsttime = 1;*/
+    while (isdir) {
+        int startsect = mydata->data_begin
+            + START (dentptr) * mydata->clust_size;
+        dir_entry dent;
+        char *nextname = NULL;
+
+        dent = *dentptr;
+        dentptr = &dent;
+
+        idx = dirdelim (subname);
+        if (idx >= 0) {
+            subname[idx] = '\0';
+            nextname = subname + idx + 1;
+            /* Handle multiple delimiters */
+            while (ISDIRDELIM (*nextname))
+                nextname++;
+        } else {
+            isdir = 0;
+        }
+
+        if (get_dentfromdir (mydata, startsect, subname, dentptr, 0) == NULL) {
+            put_fd(fd);
+            return -1;
+        }
+
+        if (idx >= 0) {
+            if (!(dentptr->attr & ATTR_DIR))
+            {
+                put_fd(fd);
+                return -1;
+            }
+            subname = nextname;
+        }
+    }
+
+    files[fd].dent = *dentptr;
+    files[fd].offset = 0;
+    files[fd].curclust = files[fd].headclust = START(dentptr);
+    files[fd].filesize = FAT2CPU32(dentptr->size);
+    FAT_MSG("Filesize is 0x%lxB[%luM]\n", files[fd].filesize, (files[fd].filesize>>20));
+
+    bytesperclust = fs_info[fd].datablock.clust_size * SECTOR_SIZE;
+    fs_info[fd].fat_buf_cluster_index = 0;//0 is invalid
+    fs_info[fd].fat_buf = malloc(bytesperclust);
+    if (!fs_info[fd].fat_buf)
+    {
+        if (fd >= 0)
+        {
+            memset(&files[fd], 0, sizeof(struct file));
+            memset(&fs_info[fd], 0, sizeof(struct _fs_info));
+        }
+        put_fd(fd);
+        return -1;
+    }
+    return fd;
+}
+
+unsigned do_fat_get_bytesperclust(int fd)
+{
+	const unsigned bytesperclust = fs_info[fd].datablock.clust_size * SECTOR_SIZE;
+
+    if (fd < 0) {
+        FAT_ERROR("Invalid fd %d\n", fd);
+        return -1;
+    }
+
+    return bytesperclust;
+}
+
+// clusters need to read:
+// data moddule: <first cluser not engouh cluster> + <n * Consecutive clusters > + <last cluster not engouh cluster>
+long do_fat_fread(int fd, __u8 *buffer, unsigned long maxsize)
+{
+        __u32 gotsize = 0;
+        __u32 curclust;
+        unsigned long actsize = maxsize;
+        unsigned long offset;
+        unsigned long offset_in_clust;
+        struct _fs_info* theFsInfo = fs_info + fd;
+        const unsigned bytesperclust = theFsInfo->datablock.clust_size * SECTOR_SIZE;
+        fsdata* mydata = &fs_info[fd].datablock;
+        struct file* pFile = files + fd;
+        int ret = 0;
+
+        if (fd < 0) {
+                FAT_ERROR("Invalid fd %d\n", fd);
+                return -1;
+        }
+
+        offset = pFile->offset;
+        curclust = pFile->curclust;
+
+        /* calc actual size to read */
+        if (offset + maxsize > pFile->filesize) {
+                FAT_ERROR("offset(0x%lx) + wantsz(0x%lx) > filesize(0x%lx)\n", offset, maxsize, pFile->filesize);
+                return 0;
+        }
+        FAT_DPRINT("offset=0x%lx, readsz=%lx, bytesperclust=%x, curclust=%x\n",
+                        offset, actsize, bytesperclust, curclust);
+
+        /* Deal with partial data at the first cluster */
+
+        /* Data occupation in cluster 1
+           Case 1:
+
+cluster1 :   |####____|
+
+Case 2:
+cluster1 :   |########|
+
+Case 3:
+cluster1 :   |__####__|
+
+Case 4:
+cluster1 :   |__######|
+*/
+
+        offset_in_clust = (offset % bytesperclust);
+        if (offset_in_clust != 0)
+        {
+                FAT_DPRINT("offset_in_clust 0x%lx, curclust 0x%x, cached 0x%x\n",
+                                offset_in_clust, curclust, theFsInfo->fat_buf_cluster_index);
+                if (curclust != theFsInfo->fat_buf_cluster_index)
+                {//should seldom reach here if the image item consecutive
+                        FAT_MSG("offset_in_clust 0x%lx\n", offset_in_clust);
+                        /* Use vfat_buf as intermedia buffer to deal with the situation that size of _buf_ is smaller than a cluster */
+                        //FIXME:check if the fat_buf cache the data user wanted, and copy directly if wanted!!
+                        if (get_cluster(mydata, curclust, (__u8*)fs_info[fd].fat_buf, (int)bytesperclust) != 0) {
+                                FAT_ERROR("Error reading cluster\n");
+                                return -1;
+                        }
+                        fs_info[fd].fat_buf_cluster_index = curclust;
+                }
+
+                if (actsize < (bytesperclust - offset_in_clust))
+                {/* Case 3: the end of the cluster is not reached */
+                        memcpy(buffer, fs_info[fd].fat_buf+ offset_in_clust, actsize);
+                        offset += actsize;
+                        gotsize = actsize;
+                        goto exit;
+                }
+                else
+                {/* Case 4 */
+                        gotsize = bytesperclust - offset_in_clust;
+                        memcpy(buffer, fs_info[fd].fat_buf+ offset_in_clust, gotsize);
+                        FAT_DPRINT("buffer=%p, gotsize=0x%x, offset_in_clust=0x%lx\n", buffer, gotsize, offset_in_clust);
+                        actsize -= gotsize;
+                        offset += gotsize;
+                        buffer += gotsize;
+
+                        //update cluster index if seeked to next cluster
+                        ret = optimus_fat_get_fat_next_entry(mydata, curclust, &curclust, pFile->filesize, offset);
+                        if (ret) {
+                                FAT_ERROR("Fail in get next entry, ret=%d\n", __LINE__);
+                                return 0;
+                        }
+                }
+        }
+
+        if ( (unsigned long)buffer  & ( SECTOR_SIZE - 1 ) )
+        {
+                FAT_ERROR("buffer[0x%p] not align sector\n", buffer);
+                return 0;
+        }
+
+        FAT_DPRINT("while actsize=0x%lx, buffer=0x%p\n", actsize, buffer);
+        //Following disposing data which 'offset % bytesperclust == 0', that is start from align offset
+        //if left data length >= bytesperclust, can read to user buffer directly
+        while (actsize >= bytesperclust)
+        {
+                __u32 endclust; //last cluster index of this consecutive clusters
+                __u32 newclust = 0; //new cluster index of next consecutive clusters
+                unsigned thisConsecutiveLen = 0;
+
+                endclust = curclust;
+                thisConsecutiveLen       =      bytesperclust;
+                actsize                 -=      bytesperclust;
+
+                /* search for consecutive clusters until get enghou size*/
+                for (; actsize >= bytesperclust; actsize -= bytesperclust, thisConsecutiveLen += bytesperclust)
+                {
+                       //for actsize >= bytesperclust
+                        newclust = get_fatent(mydata, endclust);//get next cluster index
+                        if (CHECK_CLUST(newclust, mydata->fatsize)) {
+                                FAT_ERROR("curclust: 0x%x, bytesperclust=0x%x\n", newclust, bytesperclust);
+                                FAT_ERROR("Invalid FAT entry,actsize=0x%lx\n", actsize);
+                                goto exit;
+                        }
+                        //clusters not consecutive
+                        if ((newclust -1)!= endclust) break;
+                        endclust                =       newclust;//update curclust for next read
+                }
+
+                if (get_cluster(mydata, curclust, buffer, thisConsecutiveLen) != 0) {
+                        FAT_ERROR("Error reading cluster\n");
+                        return -1;
+                }
+                buffer  += thisConsecutiveLen;
+                gotsize += thisConsecutiveLen;
+                offset  += thisConsecutiveLen;
+
+                ret = optimus_fat_get_fat_next_entry(mydata, endclust, &curclust, pFile->filesize, offset);
+                if (ret) {
+                        FAT_ERROR("Fail in get next entry, ret=%d\n", __LINE__);
+                        return 0;
+                }
+                /*DWN_DBG("thisConsecutiveLen 0x%x\n", thisConsecutiveLen);*/
+
+        }// while (actsize >= bytesperclust)
+
+        //left data not enough one cluster
+        if (actsize) //Left data in the 'next' cluster < bytesperclust
+        {
+                __u8*   clusterCache = (__u8*)theFsInfo->fat_buf;
+
+                if (get_cluster(mydata, curclust, clusterCache, bytesperclust) != 0) {
+                        FAT_ERROR("Error reading cluster\n");
+                        return -1;
+                }
+                theFsInfo->fat_buf_cluster_index = curclust;
+                memcpy(buffer, clusterCache, actsize);
+
+                gotsize += actsize;
+                offset  += actsize;
+
+                //If this message printed when burning, we saied the bootloader is above data parts in image.cfg, or
+                //sdc_burn not burn data partitions in the order in image
+                FAT_MSG("0x:leftSz %x < BPS %x, gotSz %x\n", (unsigned)actsize, bytesperclust, gotsize);//bpc:bytesperclust
+                actsize  = 0;///end the loop
+        }
+
+exit:
+
+        pFile->offset = offset;
+        pFile->curclust = curclust;
+        return gotsize;
+}
+
+void
+do_fat_fclose(int fd)
+{
+
+    if (fd >= 0)
+    {
+        memset(&files[fd], 0, sizeof(struct file));
+        memset(&fs_info[fd], 0, sizeof(struct _fs_info));
+    }
+
+    if (fs_info[fd].fat_buf)
+    {
+        free(fs_info[fd].fat_buf);
+        fs_info[fd].fat_buf=0;
+    }
+    if (fs_info[fd].datablock.fatbuf)
+    {
+        free(fs_info[fd].datablock.fatbuf);
+        fs_info[fd].datablock.fatbuf = NULL;
+    }
+
+    put_fd(fd);
+}
+
+// added by scy
+//if image not exist, return 0
+s64 do_fat_get_fileSz(const char* imgItemPath)
+{
+    char cmdBuf[256] = "";
+    int rcode = 0;
+    const char* envFileSz = NULL;
+    const char* usb_update = getenv("usb_update");
+
+    if (!strcmp(usb_update,"1"))
+    {
+        //fatexist usb host 0 imgItemPath
+        sprintf(cmdBuf, "fatsize usb 0 %s", imgItemPath);
+    }
+    else
+    {
+        rcode = optimus_sdc_burn_switch_to_extmmc();
+        sprintf(cmdBuf, "fatsize mmc 0 %s", imgItemPath);
+    }
+    /*SDC_DBG("to run cmd [%s]\n", cmdBuf);*/
+    rcode = run_command(cmdBuf, 0);
+    if (rcode) {
+        printf("fail in cmd [%s], rcode %d\n", cmdBuf, rcode);
+        return 0;//item size is 0
+    }
+    envFileSz = getenv("filesize");
+    /*SDC_DBG("size of item %s is 0x%s\n", imgItemPath, envFileSz);*/
+
+    return simple_strtoull(envFileSz, NULL, 16);
+}
+
+//<0 if failed, 0 is normal, 1 is sparse, others reserved
+int do_fat_get_file_format(const char* imgFilePath, unsigned char* pbuf, const unsigned bufSz)
+{
+    int readSz = 0;
+
+    int hFile = do_fat_fopen(imgFilePath);
+    if (hFile < 0) {
+        printf("Fail to open file (%s)\n", imgFilePath);
+        return -1;
+    }
+
+    readSz = do_fat_fread(hFile, pbuf, bufSz);
+    if (readSz <= 0) {
+        printf("Fail to read file(%s), readSz=%d\n", imgFilePath, readSz);
+        do_fat_fclose(hFile);
+        return -1;
+    }
+
+    readSz = optimus_simg_probe(pbuf, readSz);
+
+    do_fat_fclose(hFile);
+
+    return readSz;
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_img_decoder.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_img_decoder.c
new file mode 100644
index 0000000..30bdd08
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_img_decoder.c
@@ -0,0 +1,601 @@
+/*
+ * \file        optimus_img_decoder.c
+ * \brief
+ *
+ * \version     1.0.0
+ * \date        2013-7-8
+ * \author      Sam.Wu <yihui.wu@amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#include "../v2_sdc_burn/optimus_sdc_burn_i.h"
+
+//FIMXE:
+COMPILE_TYPE_CHK(128 == sizeof(ItemInfo_V1), _op_a);
+COMPILE_TYPE_CHK(576 == sizeof(ItemInfo_V2), __op_a2);
+COMPILE_TYPE_CHK(64  == sizeof(AmlFirmwareImg_t), __op_b);
+
+typedef struct _ImgSrcIf{
+        unsigned        devIf;             //mmc/usb/store
+        unsigned        devNo;          //0/1/2
+        unsigned        devAlignSz;     //64K for store
+        unsigned        reserv2Align64;
+        uint64_t        itemCurSeekOffsetInImg;//fread will auto seek the @readSz, but for STORE we must do it
+
+        char            partName[28];       //partIndex <= 28 (+4 if partIndex not used)
+        unsigned        partIndex;      //partIndex and part
+        unsigned char   resrv[512 - 32 - 24];
+}ImgSrcIf_t;
+
+COMPILE_TYPE_CHK(512  == sizeof(ImgSrcIf_t), bb);
+#define MAX_ITEM_NUM 48
+
+typedef struct _ImgInfo_s
+{
+        ImgSrcIf_t          imgSrcIf;
+        AmlFirmwareImg_t    imgHead;//Must begin align 512, or store read wiill exception
+        union               ItemInfo_u{
+                            ItemInfo_V1 v1[MAX_ITEM_NUM];
+                            ItemInfo_V2 v2[MAX_ITEM_NUM];
+        }itemInfo;
+
+}ImgInfo_t;
+
+typedef struct _AmlFirmwareItem0_s
+{
+    __u32           itemId;
+    __u32           fileType;           //image file type, sparse and normal
+    __u64           curoffsetInItem;    //current offset in the item
+    __u64           offsetInImage;      //item offset in the image
+    __u64           itemSz;             //item size in the image
+    const char*     itemMainType;
+    const char*     itemSubType;
+}ItemInfo;
+
+static int _hFile = -1;
+
+//open a Amlogic firmware image
+//return value is a handle
+HIMAGE image_open(const char* interface, const char* device, const char* part, const char* imgPath)
+{
+    const int HeadSz = sizeof(ImgInfo_t) - sizeof(ImgSrcIf_t);
+    ImgInfo_t* hImg = (ImgInfo_t*)OPTIMUS_BURN_PKG_HEAD_BUF_ADDR;
+    int ret = 0;
+    ImgSrcIf_t* pImgSrcIf = NULL;
+    unsigned imgVer = 0;
+
+    pImgSrcIf = &hImg->imgSrcIf;
+    memset(pImgSrcIf, 0, sizeof(ImgSrcIf_t));
+
+    if (!strcmp("store", interface))
+    {
+            DWN_DBG("imgHead=0x%p, hImg=%p\n", &hImg->imgHead, hImg);
+            ret = store_read_ops((u8*)part, (u8*)&hImg->imgHead, IMG_OFFSET_IN_PART, HeadSz);
+            if (ret) {
+                    DWN_ERR("Fail to read image header.\n");
+                    ret = __LINE__; goto _err;
+            }
+
+            pImgSrcIf->devIf = IMAGE_IF_TYPE_STORE;
+            pImgSrcIf->devAlignSz = 4*1024;//512;//OPTIMUS_DOWNLOAD_SLOT_SZ;
+            strcpy(pImgSrcIf->partName, part);
+    }
+    else
+    {
+            int pFile = do_fat_fopen(imgPath);
+            if (pFile < 0) {
+                    DWN_ERR("Fail to open file %s\n", imgPath);
+                    goto _err;
+            }
+            _hFile = pFile;
+
+            ret = do_fat_fread(pFile, (u8*)&hImg->imgHead, HeadSz);
+            if (ret != HeadSz) {
+                    DWN_ERR("want to read %d, but %d\n", HeadSz, ret);
+                    goto _err;
+            }
+
+            pImgSrcIf->devAlignSz = do_fat_get_bytesperclust(pFile);
+    }
+
+    if (IMAGE_MAGIC != hImg->imgHead.magic) {
+        DWN_ERR("error magic 0x%x\n", hImg->imgHead.magic);
+        goto _err;
+    }
+    imgVer = hImg->imgHead.version;
+    if (AML_FRMWRM_VER_V1 !=  imgVer && AML_FRMWRM_VER_V2 != imgVer) {
+        DWN_ERR("error verison 0x%x\n", hImg->imgHead.version);
+        goto _err;
+    }
+    DWN_MSG("image version [0x%08x]\n", imgVer);
+    if (MAX_ITEM_NUM < hImg->imgHead.itemNum) {
+            DWN_ERR("max itemNum(%d)<actual itemNum (%d)\n", MAX_ITEM_NUM, hImg->imgHead.itemNum);
+            goto _err;
+    }
+
+    return hImg;
+_err:
+    return NULL;
+}
+
+
+//close a Amlogic firmware image
+int image_close(HIMAGE hImg)
+{
+    DWN_MSG("to close image\n");
+
+    if (_hFile >= 0)do_fat_fclose(_hFile) , _hFile = -1;
+
+    if (hImg) {
+        hImg = NULL;
+    }
+    return 0;
+}
+
+static const ItemInfo* image_item_get_item_info_byid(HIMAGE hImg, const int itemIndex)
+{
+        ImgInfo_t* imgInfo = (ImgInfo_t*)hImg;
+        const unsigned imgVer = imgInfo->imgHead.version;
+        static ItemInfo theItem;
+
+        switch (imgVer)
+        {
+                case AML_FRMWRM_VER_V2:
+                        {
+                                ItemInfo_V2* pItem = &imgInfo->itemInfo.v2[itemIndex];
+                                theItem.itemMainType    = pItem->itemMainType;
+                                theItem.itemSubType     = pItem->itemSubType;
+                                theItem.itemSz          = pItem->itemSz;
+                                theItem.offsetInImage   = pItem->offsetInImage;
+                                theItem.curoffsetInItem = pItem->curoffsetInItem;
+                                theItem.fileType        = pItem->fileType;
+                                theItem.itemId          = pItem->itemId;
+                        }
+                        break;
+
+                case AML_FRMWRM_VER_V1:
+                        {
+                                ItemInfo_V1* pItem = &imgInfo->itemInfo.v1[itemIndex];
+                                theItem.itemMainType    = pItem->itemMainType;
+                                theItem.itemSubType     = pItem->itemSubType;
+                                theItem.itemSz          = pItem->itemSz;
+                                theItem.offsetInImage   = pItem->offsetInImage;
+                                theItem.curoffsetInItem = pItem->curoffsetInItem;
+                                theItem.fileType        = pItem->fileType;
+                                theItem.itemId          = pItem->itemId;
+                        }
+                        break;
+
+                default:
+                        DWN_ERR("Exception, imgVer=0x%x\n", imgVer);
+                        return NULL;
+        }
+
+        return &theItem;
+}
+
+//open a item in the image
+//@hImage: image handle;
+//@mainType, @subType: main type and subtype to index the item, such as ["IMAGE", "SYSTEM"]
+HIMAGEITEM image_item_open(HIMAGE hImg, const char* mainType, const char* subType)
+{
+    ImgInfo_t* imgInfo          = (ImgInfo_t*)hImg;
+    const int itemNr            = imgInfo->imgHead.itemNum;
+    const ItemInfo*      pItem  = NULL;
+    int i = 0;
+
+    for (; i < itemNr ;i++)
+    {
+            pItem = image_item_get_item_info_byid(hImg, i);
+            if (!pItem) {
+                    DWN_ERR("Fail to get item at index %d\n", i);
+                    return NULL;
+            }
+
+            if (!strcmp(mainType, pItem->itemMainType) && !strcmp(subType, pItem->itemSubType))
+            {
+                    break;
+            }
+    }
+    if (i >= itemNr) {
+        DWN_WRN("Can't find item [%s, %s]\n", mainType, subType);
+        return NULL;
+    }
+
+    if (i != pItem->itemId) {
+        DWN_ERR("itemid %d err, should %d\n", pItem->itemId, i);
+        return NULL;
+    }
+
+    if (IMAGE_IF_TYPE_STORE != imgInfo->imgSrcIf.devIf)
+    {
+            DWN_DBG("Item offset 0x%llx\n", pItem->offsetInImage);
+            i = do_fat_fseek(_hFile, pItem->offsetInImage, 0);
+            if (i) {
+                    DWN_ERR("fail to seek, offset is 0x%x\n", (u32)pItem->offsetInImage);
+                    return NULL;
+            }
+    }
+    imgInfo->imgSrcIf.itemCurSeekOffsetInImg = pItem->offsetInImage;
+
+    return (HIMAGEITEM)pItem;
+}
+
+//Need this if item offset in the image file is not aligned to bytesPerCluster of FAT
+unsigned image_item_get_first_cluster_size(HIMAGE hImg, HIMAGEITEM hItem)
+{
+    const ImgInfo_t* imgInfo = (ImgInfo_t*)hImg;
+    ItemInfo* pItem = (ItemInfo*)hItem;
+    unsigned itemSizeNotAligned = 0;
+    const unsigned fat_bytesPerCluste = imgInfo->imgSrcIf.devAlignSz;
+
+    itemSizeNotAligned = pItem->offsetInImage & (fat_bytesPerCluste - 1);
+    itemSizeNotAligned = fat_bytesPerCluste - itemSizeNotAligned;
+
+    DWN_MSG("itemSizeNotAligned 0x%x\n", itemSizeNotAligned);
+    return itemSizeNotAligned;
+}
+
+unsigned image_get_cluster_size(HIMAGEITEM hImg)
+{
+    const ImgInfo_t* imgInfo = (ImgInfo_t*)hImg;
+    const unsigned fat_bytesPerCluste = imgInfo->imgSrcIf.devAlignSz;
+
+    return fat_bytesPerCluste;
+}
+
+//close a item
+int image_item_close(HIMAGEITEM hItem)
+{
+    return 0;
+}
+
+__u64 image_item_get_size(HIMAGEITEM hItem)
+{
+    ItemInfo* pItem = (ItemInfo*)hItem;
+
+    return pItem->itemSz;
+}
+
+
+//get image item type, current used type is normal or sparse
+int image_item_get_type(HIMAGEITEM hItem)
+{
+    ItemInfo* pItem = (ItemInfo*)hItem;
+
+    return pItem->fileType;
+}
+
+//read item data, like standard fread
+int image_item_read(HIMAGE hImg, HIMAGEITEM hItem, void* pBuf, const __u32 wantSz)
+{
+    ImgInfo_t* imgInfo = (ImgInfo_t*)hImg;
+    unsigned readSz = 0;
+
+    if (IMAGE_IF_TYPE_STORE == imgInfo->imgSrcIf.devIf)
+    {
+            unsigned char* part = (unsigned char*)imgInfo->imgSrcIf.partName;
+            const uint64_t offsetInPart = imgInfo->imgSrcIf.itemCurSeekOffsetInImg + IMG_OFFSET_IN_PART;
+            int rc = 0;
+            const unsigned storeBlkSz      = imgInfo->imgSrcIf.devAlignSz;
+            const unsigned offsetNotAlign = offsetInPart & (storeBlkSz - 1);
+            const unsigned sizeNotAlignInFirstBlk = storeBlkSz - offsetNotAlign;//in the the first block and its offset not aligned
+
+            //Attention: deal with the align issue in "optimus_burn_one_partition", then not need to modify "do_fat_fread"
+            if (offsetNotAlign)
+            {
+                    unsigned char* bufInABlk = NULL;
+                    const uint64_t readOffset = offsetInPart - offsetNotAlign;
+                    const unsigned bufLen = sizeNotAlignInFirstBlk < wantSz ? sizeNotAlignInFirstBlk : (wantSz);
+                    unsigned thisTotalReadSz = wantSz;
+
+                    DWN_MSG("offsetInPart %llx, wantSz=%x\n", offsetInPart, wantSz);
+                    bufInABlk = (u8*)malloc(storeBlkSz);
+                    rc = store_read_ops(part, bufInABlk, readOffset, storeBlkSz);
+                    if (rc) {
+                            DWN_ERR("Fail to read: readOffset=%llx, storeBlkSz=%x\n", readOffset, storeBlkSz);
+                            free(bufInABlk);
+                            return __LINE__;
+                    }
+                    memcpy(pBuf, bufInABlk + offsetNotAlign, bufLen);
+                    thisTotalReadSz -= bufLen;
+                    pBuf            += bufLen/sizeof(void);
+                    free(bufInABlk);
+
+                    if (sizeNotAlignInFirstBlk < wantSz && offsetNotAlign)
+                    {
+                            rc = store_read_ops(part, (u8*)pBuf, (offsetInPart + sizeNotAlignInFirstBlk), thisTotalReadSz);
+                            if (rc) {
+                                    DWN_ERR("Fail in store_read_ops to read %u at offset %llx.\n", wantSz,
+                                                    offsetInPart + sizeNotAlignInFirstBlk);
+                                    return __LINE__;
+                            }
+                    }
+            }
+            else
+            {
+                    rc = store_read_ops(part, (u8*)pBuf, offsetInPart, wantSz);
+                    if (rc) {
+                            DWN_ERR("Fail in store_read_ops to read %u at offset %llx.\n", wantSz, offsetInPart);
+                            return __LINE__;
+                    }
+            }
+
+            imgInfo->imgSrcIf.itemCurSeekOffsetInImg += wantSz;
+    }
+    else
+    {
+            readSz = do_fat_fread(_hFile, pBuf, wantSz);
+            if (readSz != wantSz) {
+                    DWN_ERR("want to read 0x%x, but 0x%x\n", wantSz, readSz);
+                    return __LINE__;
+            }
+    }
+
+    return 0;
+}
+
+int get_total_itemnr(HIMAGE hImg)
+{
+    ImgInfo_t* imgInfo = (ImgInfo_t*)hImg;
+
+    return imgInfo->imgHead.itemNum;
+}
+
+HIMAGEITEM get_item(HIMAGE hImg, int itemId)
+{
+    int ret = 0;
+    ImgInfo_t* imgInfo = (ImgInfo_t*)hImg;
+    const ItemInfo* pItem    = NULL;
+
+    pItem = image_item_get_item_info_byid(hImg, itemId);
+    if (!pItem) {
+            DWN_ERR("Fail to get item at index %d\n", itemId);
+            return NULL;
+    }
+    if (itemId != pItem->itemId) {
+        DWN_ERR("itemid %d err, should %d\n", pItem->itemId, itemId);
+        return NULL;
+    }
+    DWN_MSG("get item [%s, %s] at %d\n", pItem->itemMainType, pItem->itemSubType, itemId);
+
+    if (IMAGE_IF_TYPE_STORE != imgInfo->imgSrcIf.devIf)
+    {
+            ret = do_fat_fseek(_hFile, pItem->offsetInImage, 0);
+            if (ret) {
+                    DWN_ERR("fail to seek, offset is 0x%x, ret=%d\n", (u32)pItem->offsetInImage, ret);
+                    return NULL;
+            }
+    }
+    imgInfo->imgSrcIf.itemCurSeekOffsetInImg = pItem->offsetInImage;
+
+    return (HIMAGEITEM)pItem;
+}
+
+int get_item_name(HIMAGE hImg, int itemId, const char** main_type, const char** sub_type)
+{
+    const ItemInfo* pItem    = NULL;
+
+    pItem = image_item_get_item_info_byid(hImg, itemId);
+    if (!pItem) {
+            DWN_ERR("Fail to get item at index %d\n", itemId);
+            return __LINE__;
+    }
+    if (itemId != pItem->itemId) {
+        DWN_ERR("itemid %d err, should %d\n", pItem->itemId, itemId);
+        return __LINE__;
+    }
+    DWN_DBG("get item [%s, %s] at %d\n", pItem->itemMainType, pItem->itemSubType, itemId);
+
+    *main_type = pItem->itemMainType;
+    *sub_type  = pItem->itemSubType;
+
+    return OPT_DOWN_OK;
+}
+
+__u64 image_get_item_size_by_index(HIMAGE hImg, const int itemId)
+{
+    const ItemInfo* pItem    = NULL;
+
+    pItem = image_item_get_item_info_byid(hImg, itemId);
+    if (!pItem) {
+            DWN_ERR("Fail to get item at index %d\n", itemId);
+            return 0;
+    }
+    if (itemId != pItem->itemId) {
+        DWN_ERR("itemid %d err, should %d\n", pItem->itemId, itemId);
+        return __LINE__;
+    }
+    DWN_DBG("get item [%s, %s] at %d\n", pItem->itemMainType, pItem->itemSubType, itemId);
+
+    return pItem->itemSz;
+}
+
+u64 optimus_img_decoder_get_data_parts_size(HIMAGE hImg, int* hasBootloader)
+{
+    int i = 0;
+    int ret = 0;
+    u64 dataPartsSz = 0;
+    const int totalItemNum = get_total_itemnr(hImg);
+
+    *hasBootloader = 0;
+    for (i = 0; i < totalItemNum; i++)
+    {
+        const char* main_type = NULL;
+        const char* sub_type  = NULL;
+
+        ret = get_item_name(hImg, i, &main_type, &sub_type);
+        if (ret) {
+            DWN_ERR("Exception:fail to get item name!\n");
+            return __LINE__;
+        }
+
+        if (strcmp("PARTITION", main_type)) { continue; }
+        if (!strcmp("bootloader", sub_type)) {
+                *hasBootloader = 1;
+                continue;
+        }
+        if (!strcmp(AML_SYS_RECOVERY_PART, sub_type))
+        {
+                if (OPTIMUS_WORK_MODE_SYS_RECOVERY == optimus_work_mode_get()) continue;
+        }
+
+        dataPartsSz += image_get_item_size_by_index(hImg, i);
+    }
+
+    return dataPartsSz;
+}
+
+#define MYDBG 0
+#if MYDBG
+static int test_item(HIMAGE hImg, const char* main_type, const char* sub_type, char* pBuf, const int sz)
+{
+    HIMAGEITEM hItem = NULL;
+    int ret = 0;
+
+    hItem = image_item_open(hImg, main_type, sub_type);
+    if (!hItem) {
+        DWN_ERR("fail to open %s, %s\n", main_type, sub_type);
+        return __LINE__;
+    }
+
+    ret = image_item_read(hImg, hItem, pBuf, sz);
+    if (ret) {
+        DWN_ERR("fail to read\n");
+        goto _err;
+    }
+    if (64 >= sz)DWN_MSG("%s\n", pBuf) ;
+
+_err:
+    image_item_close(hItem);
+    return ret;
+}
+
+static int test_pack(const char* interface, const char* device, const char* part, const char* imgPath)
+{
+    const int ImagBufLen = OPTIMUS_DOWNLOAD_SLOT_SZ;
+    char* pBuf = (char*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR + ImagBufLen;
+    int ret = 0;
+    int i = 0;
+    HIMAGEITEM hItem = NULL;
+
+    if (!strcmp("store", interface))
+    {
+            ret = run_command("store init 1", 0);
+            if (ret) {
+                    DWN_ERR("Fail in init mmc, Does sdcard not plugged in?\n");
+                    return __LINE__;
+            }
+    }
+    else
+    {
+            s64 fileSz = 0;
+
+            ret = run_command("mmcinfo", 0);
+            if (ret) {
+                    DWN_ERR("Fail in init mmc, Does sdcard not plugged in?\n");
+                    return __LINE__;
+            }
+
+            fileSz = do_fat_get_fileSz(imgPath);
+            if (!fileSz) {
+                    DWN_ERR("file %s not exist\n", imgPath);
+                    return __LINE__;
+            }
+    }
+
+    HIMAGE hImg = image_open(interface, device, part, imgPath);
+    if (!hImg) {
+        DWN_ERR("Fail to open image\n");
+        return __LINE__;
+    }
+
+    const int itemNr = get_total_itemnr(hImg);
+    for (i = 0; i < itemNr ; i++)
+    {
+        __u64 itemSz = 0;
+        int fileType = 0;
+
+        hItem = get_item(hImg, i);
+        if (!hItem) {
+            DWN_ERR("Fail to open item at id %d\n", i);
+            break;
+        }
+
+        itemSz = image_item_get_size(hItem);
+        DWN_MSG("Item Sz is 0x%llx\n", itemSz);
+
+        unsigned wantSz = ImagBufLen > itemSz ? (unsigned)itemSz : ImagBufLen;
+        unsigned itemSizeNotAligned = 0;
+        char* readBuf = pBuf;
+        unsigned readSz = wantSz;
+
+        itemSizeNotAligned = image_item_get_first_cluster_size(hImg, hItem);
+        if (itemSizeNotAligned)
+        {
+                ret = image_item_read(hImg, hItem, readBuf, itemSizeNotAligned);
+                readSz = (wantSz > itemSizeNotAligned) ? (wantSz - itemSizeNotAligned) : 0;
+        }
+
+        if (readSz)
+        {
+                ret = image_item_read(hImg, hItem, readBuf + itemSizeNotAligned, readSz);
+                if (ret) {
+                        DWN_ERR("fail to read item data\n");
+                        break;
+                }
+        }
+
+        fileType = image_item_get_type(hItem);
+        if (IMAGE_ITEM_TYPE_SPARSE == fileType)
+        {
+                DWN_MSG("sparse packet\n");
+                ret = optimus_simg_probe((const u8*)pBuf, wantSz);
+                if (!ret) {
+                        DWN_ERR("item data error, should sparse, but no\n");
+                        break;
+                }
+        }
+    }
+
+#if 1
+    test_item(hImg, "PARTITION", "logo", pBuf, ImagBufLen);
+    test_item(hImg, "VERIFY", "logo", pBuf, 50);
+#endif
+
+    image_close(hImg);
+    return 0;
+}
+
+static int do_unpack(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int rcode = 0;
+    const char* imgPath = "a";
+
+#if 1
+    if (2 > argc) imgPath = "dt.img";
+#else
+    if (2 > argc) {
+        cmd_usage(cmdtp);
+        return -1;
+    }
+#endif//#if MYDBG
+    DWN_MSG("argc %d, %s, %s\n", argc, argv[0], argv[1]);
+
+    rcode = test_pack("mmc", "0", "aml_sysrecovery", imgPath);
+
+    DWN_MSG("rcode %d\n", rcode);
+    return rcode;
+}
+
+U_BOOT_CMD(
+   unpack,      //command name
+   5,               //maxargs
+   1,               //repeatable
+   do_unpack,   //command function
+   "unpack the image in sdmmc ",           //description
+   "Usage: unpack imagPath\n"   //usage
+);
+#endif//#if MYDBG
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_progress.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_progress.c
new file mode 100644
index 0000000..3080fc3
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_progress.c
@@ -0,0 +1,142 @@
+/*
+ * \file        optimus_report_progress.c
+ * \brief       display and print progress info when burning a partition
+ *
+ * \version     1.0.0
+ * \date        2013/6/23
+ * \author      Sam.Wu <wuehui@allwinnertech.com>
+ *
+ * Copyright (c) 2013 Allwinner Technology. All Rights Reserved.
+ *
+ */
+#include "../v2_burning_i.h"
+
+#define OPTIMUS_PROMPT_SIZE_MIN     (4U<<20)//mininal size to prompt burning progress step
+
+struct ProgressInfo{
+    u32     itemSzLow;
+    u32     itemSzHigh;
+
+    u8      startStep;
+    u8      endStep;
+    u8      totalStepNum;
+    u8      currentStep;
+
+    u32     bytesToIncOneStep;
+    u32     unReportSzInByte;
+
+    u32     bytesToUpdateStep;
+    u32     reserv;
+
+};
+static struct ProgressInfo _progressInfo = {0};
+
+int optimus_progress_init(const unsigned itemSzHigh, const unsigned itemSzLow, const u32 startStep, const u32 endStep)
+{
+    _progressInfo.itemSzLow     = itemSzLow;
+    _progressInfo.itemSzHigh    = itemSzHigh;
+
+    _progressInfo.startStep     = startStep;
+    _progressInfo.endStep       = endStep;
+    _progressInfo.currentStep   = startStep;
+    _progressInfo.totalStepNum  = endStep - startStep;
+
+    _progressInfo.unReportSzInByte  = 0;//clear it
+
+    //ATTENTION: as divisor / is lossy, _progressInfo.bytesToIncOneStep * _progressInfo.totalStepNum <= item size, so 100% is sometimes not exactly Burn Completed!!
+    _progressInfo.bytesToIncOneStep = ((((u64)itemSzHigh)<<32) + itemSzLow) / _progressInfo.totalStepNum;
+    _progressInfo.bytesToUpdateStep = (OPTIMUS_PROMPT_SIZE_MIN > _progressInfo.bytesToIncOneStep) ? OPTIMUS_PROMPT_SIZE_MIN : _progressInfo.bytesToIncOneStep;
+
+
+    DWN_DBG("item size 0x[%x, %x], currentStep %d, totalStepNum %d, bytesToIncOneStep 0x%x\n",
+            itemSzHigh, itemSzLow, _progressInfo.currentStep, _progressInfo.totalStepNum, _progressInfo.bytesToIncOneStep);
+    return 0;
+}
+
+int optimus_progress_exit(void)
+{
+    return 0;
+}
+
+int optimus_update_progress(const unsigned thisBurnSz)
+{
+    _progressInfo.unReportSzInByte += thisBurnSz;
+
+    if (_progressInfo.bytesToUpdateStep > _progressInfo.unReportSzInByte) {
+        return 0;
+    }
+
+    //if it is first time to prompt UI progress steps
+    if (_progressInfo.unReportSzInByte == thisBurnSz && _progressInfo.startStep + 1 == _progressInfo.currentStep)
+    {
+        printf("\n");
+    }
+
+    _progressInfo.currentStep       += _progressInfo.unReportSzInByte / _progressInfo.bytesToIncOneStep;
+    _progressInfo.unReportSzInByte  %= _progressInfo.bytesToIncOneStep;
+
+    printf("Downloading %%%d\r", _progressInfo.currentStep);
+    if (_progressInfo.currentStep == _progressInfo.endStep) {
+        printf("\n");
+    }
+
+    return 0;
+}
+
+//outStr will be null-terminater after format
+int optimus_hex_data_2_ascii_str(const unsigned char* hexData, const unsigned nBytes, char* outStr, const unsigned strSz)
+{
+    int i = 1;
+    if (strSz < 2 * nBytes + 1) {
+        DWN_ERR("strSz(%d) > 2 * nBytes(%d)\n", strSz, nBytes);
+        return __LINE__;
+    }
+
+    sprintf(outStr, "%02x", hexData[0]);
+    for (; i < nBytes; ++i)
+    {
+        sprintf(outStr, "%s%02x", outStr, hexData[i]);
+    }
+
+    return 0;
+}
+
+unsigned add_sum(const void* pBuf, const unsigned size)
+{
+    unsigned sum		 =	0;
+    const unsigned* data = (const unsigned*)pBuf;
+    unsigned wordLen 	 = size>>2;
+    unsigned rest 		 = size & 3;
+
+    for (; wordLen/4; wordLen -= 4)
+    {
+        sum += *data++;
+        sum += *data++;
+        sum += *data++;
+        sum += *data++;
+    }
+    while (wordLen--)
+    {
+        sum += *data++;
+    }
+
+    if (rest == 0)
+    {
+        ;
+    }
+    else if(rest == 1)
+    {
+        sum += (*data) & 0xff;
+    }
+    else if(rest == 2)
+    {
+        sum += (*data) & 0xffff;
+    }
+    else if(rest == 3)
+    {
+        sum += (*data) & 0xffffff;
+    }
+
+    return sum;
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_progress_ui.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_progress_ui.c
new file mode 100644
index 0000000..ed479fb
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_progress_ui.c
@@ -0,0 +1,652 @@
+/*
+ * \file        optimus_progress_ui.c
+ * \brief       Show progress info to UI
+ *
+ * \version     1.0.0
+ * \date        2013/10/13
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+#include "../v2_burning_i.h"
+#include <bmp_layout.h>
+#include <lcd.h>
+#include <video_font.h>
+
+#ifdef CONFIG_VIDEO_AMLLCD
+extern int lcd_drawchars (ushort x, ushort y, uchar *str, int count);
+#else
+#define lcd_drawchars(x, y, str, count)
+#define lcd_printf(fmt...)
+#endif// #ifdef CONFIG_VIDEO_AMLLCD
+
+#ifdef CONFIG_AML_VOUT
+#define _VIDEO_DEV_OPEN "hdmitx hpd;osd open;osd clear;vout output ${outputmode};bmp scale;"
+#else
+#define _VIDEO_DEV_OPEN "video dev bl_on;"
+#endif// #ifdef CONFIG_VIDEO_AMLTVOUT
+
+const char* const UpgradeLogoAddr = (const char*)(OPTIMUS_DOWNLOAD_DISPLAY_BUF + OPTIMUS_DOWNLOAD_SLOT_SZ);
+
+static int optimus_prepare_upgrading_bmps(HIMAGE hImg)
+{
+    char env_buf[96];
+    static const char* bmpsLoadAddr = (const char*)UpgradeLogoAddr;
+    int ret = 0;
+
+    sprintf(env_buf, "unpackimg 0x%p", bmpsLoadAddr);
+    ret = run_command(env_buf, 0);
+    if (!ret) return 0;
+    bmpsLoadAddr = UpgradeLogoAddr;//Reset to default if unapckimg directly failed
+
+    //imgread res logo ${loadaddr_misc};
+    sprintf(env_buf, "imgread res logo 0x%p", bmpsLoadAddr);
+    ret = run_command(env_buf, 0);
+    if (!ret) {
+        sprintf(env_buf, "unpackimg 0x%p", bmpsLoadAddr);
+        ret = run_command(env_buf, 0);
+    }
+
+    if (ret && hImg)
+    {//Failed to load logo resources from memory, then Load it from package
+        unsigned imgItemSz = 0;
+        HIMAGEITEM hItem = NULL;
+
+        DWN_MSG("Use upgrade res in pkg\n");
+        hItem = image_item_open(hImg, "logo", "aml_sdc_burn");
+        DWN_MSG("logo for sdc UPGRADE[%s]\n", hItem ? "aml_sdc_burn" : "PARTITION");
+        if (!hItem) {
+            hItem = image_item_open(hImg, "PARTITION", "logo");
+        }
+        if (!hItem) {
+                DWN_ERR("Fail to get logo.PARTITION for display logo\n");
+                return __LINE__;
+        }
+
+        imgItemSz = (unsigned)image_item_get_size(hItem);
+        const unsigned itemSzNotAligned = image_item_get_first_cluster_size(hImg, hItem);
+        if (itemSzNotAligned /*& 0x7*/) {//Not Aligned 8bytes/64bits, mmc dma read will failed
+            DWN_MSG("align 4 mmc read...\t");//Assert Make 'DDR' buffer addr align 8
+            bmpsLoadAddr += image_get_cluster_size(hImg);
+            bmpsLoadAddr -= itemSzNotAligned;
+            sprintf(env_buf, "unpackimg 0x%p", bmpsLoadAddr);
+        }
+        ret = image_item_read(hImg, hItem, (char*)bmpsLoadAddr, imgItemSz);
+        if (ret) {
+            DWN_ERR("Fail to read item logo\n");
+            image_item_close(hItem); return __LINE__;
+        }
+        image_item_close(hItem);
+
+        ret = run_command(env_buf, 0);
+        if (ret) {
+            DWN_ERR("Exception: Fail to unpack image in the package.\n");
+            return __LINE__;
+        }
+    }
+
+    return ret;
+}
+
+//if env upgrade_logo_offset exist, use bmp resources existed in memory
+int video_res_prepare_for_upgrade(HIMAGE hImg)
+{
+    const char* env_name  = NULL;
+    int ret = 0;
+
+    ret = optimus_prepare_upgrading_bmps(hImg);
+    if (ret) {
+        DWN_ERR("Fail in loading bmps for upgradig\n");
+        return __LINE__;
+    }
+
+    //video prepare to show upgrade bmp
+#ifdef CONFIG_VIDEO_AMLLCD
+    if (OPTIMUS_WORK_MODE_SDC_PRODUCE == optimus_work_mode_get())
+    {
+            DWN_MSG("LCD Initialize for upgrade:\n");
+            aml_lcd_init();
+    }
+#endif// #ifdef CONFIG_VIDEO_AMLLCD
+
+    DWN_MSG("echo video prepare for upgrade\n");
+    env_name = _VIDEO_DEV_OPEN;
+    ret = run_command(env_name, 0);
+    /*if (ret) goto _fail;*/
+
+    return 0;
+
+    DWN_ERR("Fail in run_command[%s]\n", env_name);
+    return ret;
+}
+
+static int _show_burn_logo(const char* bmpOffsetName) //Display logo to report burning result is failed
+{
+    int ret = 0;
+    char bmpCmd[64] = "bmp display %s";
+    char* bmpAddrEnv = getenv((char*)bmpOffsetName);
+
+    if (!bmpAddrEnv) {
+        DWN_MSG("Reload bmps env.\n");
+        ret = optimus_prepare_upgrading_bmps(NULL);
+        if (ret) {
+            DWN_ERR("Fail in re-unpack res img\n");
+            return __LINE__;
+        }
+        bmpAddrEnv = getenv((char*)bmpOffsetName);
+    }
+    sprintf(bmpCmd, "bmp display %s ", bmpAddrEnv);
+
+    ret = run_command(bmpCmd, 0);
+    if (ret) {
+        DWN_ERR("Fail in run[%s], bmpOffsetName=%s\n", bmpCmd, bmpOffsetName);
+        return __LINE__;
+    }
+#ifdef CONFIG_OSD_SCALE_ENABLE
+    /*run_command("bmp scale", 0);*/
+#endif// #ifdef CONFIG_OSD_SCALE_ENABLE
+
+    return 0;
+}
+
+//Display logo to report platform is in burning state
+int show_logo_to_report_burning(void)
+{
+    return _show_burn_logo("upgrade_upgrading_offset");
+}
+
+int show_logo_to_report_burn_success(void)
+{
+    int ret = 0;
+
+    ret = _show_burn_logo("upgrade_success_offset");
+    if (ret) {
+        DWN_ERR("Fail in display logo upgrade_success_offset\n");
+        return __LINE__;
+    }
+    lcd_printf("PLS short-press the power key to shut down\n");
+
+    return 0;
+}
+
+static int show_logo_report_burn_ui_error(void)
+{
+    int ret = 0;
+
+    ret = _show_burn_logo("upgrade_error_offset");
+    if (ret) {
+        DWN_ERR("Fail in display logo upgrade_error\n");
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+//Horizontal progress bar
+//_f means not changed after initialized
+typedef struct _uiProgress{
+    //For smart mode
+    u64         smartModeTotalBytes_f;//fixed
+    u64         smartModeLeftBytes;
+
+    unsigned    nDownBytesOnePercent_f;//update 1% if .nDownBytesOnePercent, (==.totalDownloadBytes/totalPercents)
+
+//For total
+    int         totalPercents_f; //Total width for display the progress bar, should < 'display_width'
+
+    int         curPercent;//curent percent of the progress
+    int         endPercent_f;//.endPercent + 1 - .startPerCent = .totalPercents, this field is fixed
+
+    int         progressBarWidth_f;//pixel width of the progress bar bmp
+    int         progressBarHeight_f;//pixel height of the progress bar bmp
+
+    unsigned    totalProgressBarWidth_f;//total pixel width of the progress bar, use 'display_width'/100*100 ?
+    unsigned    nProgressBarOnePercent_f;//times to display bar.if .totalProgressBarWidth=2000, .progressBarWidth=2, .totalPercents=100, then .nProgressBarOnePercent=10
+
+    int         nextProgressBarX;
+    int         progressBarY_f;//As this is a horizon progress bar, y coordinate is fixed.
+
+    int         upgradeStepX_f;
+    int         upgradeStepY_f;
+
+    unsigned    bmpAddr_f;
+    unsigned    reservToAlign64;
+}UiProgress_t;
+
+
+__hdle optimus_progress_ui_request(int totalPercents_f, int startPercent, unsigned long bmpBarAddr,
+                                    int display_width,  int progressBarY_f )
+{
+    UiProgress_t* pUiProgress = NULL;
+    bmp_header_t* bmpHeadInfo = (bmp_header_t*)bmpBarAddr;
+    const unsigned commonMultiple = totalPercents_f * bmpHeadInfo->width;
+
+    if (display_width < commonMultiple) {
+        DWN_ERR("pic width too large!! width(%d) * totalPercents_f(%d) >= display_width(%d)\n",
+                bmpHeadInfo->width, totalPercents_f, display_width);
+        show_logo_report_burn_ui_error(); return NULL;
+    }
+    pUiProgress = (UiProgress_t*)malloc(sizeof(UiProgress_t));
+    if (!pUiProgress) {
+        DWN_ERR("Fail when malloc for UiProgress_t\n");
+        show_logo_report_burn_ui_error(); return NULL;
+    }
+
+    pUiProgress->totalPercents_f            = totalPercents_f;
+    pUiProgress->curPercent                 = startPercent;
+    pUiProgress->endPercent_f               = startPercent + totalPercents_f;
+
+
+    pUiProgress->bmpAddr_f                  = bmpBarAddr;
+    pUiProgress->progressBarWidth_f         = bmpHeadInfo->width;
+    pUiProgress->progressBarHeight_f        = bmpHeadInfo->height;
+    DWN_MSG("w,h[%u,%u]\n", pUiProgress->progressBarWidth_f, pUiProgress->progressBarHeight_f);
+
+    pUiProgress->totalProgressBarWidth_f    = /* common multiple of totalPercents_f and progress bar width */
+                     (display_width / commonMultiple) * commonMultiple;
+    pUiProgress->nProgressBarOnePercent_f   = pUiProgress->totalProgressBarWidth_f / totalPercents_f;
+
+    pUiProgress->nextProgressBarX            = display_width - pUiProgress->totalProgressBarWidth_f;
+    pUiProgress->nextProgressBarX           /= 2;
+
+    pUiProgress->progressBarY_f             = progressBarY_f;
+    DWN_DBG("barYCor %d\n", progressBarY_f);
+
+    pUiProgress->upgradeStepX_f              = pUiProgress->nextProgressBarX;
+    pUiProgress->upgradeStepY_f              = progressBarY_f - VIDEO_FONT_HEIGHT;
+    DWN_DBG("upgradeStepX_f %d, upgradeStepY_f %d\n", pUiProgress->upgradeStepX_f, pUiProgress->upgradeStepY_f);
+
+    DWN_DBG("totalProgressBarWidth_f %d, nProgressBarOnePercent_f %d, nextProgressBarX %d\n",
+            pUiProgress->totalProgressBarWidth_f, pUiProgress->nProgressBarOnePercent_f, pUiProgress->nextProgressBarX);
+
+    return (__hdle)pUiProgress;
+}
+
+int optimus_progress_ui_set_smart_mode(__hdle hUiProgress, const u64 smartModeTotalBytes_f, const unsigned smartModePercents)
+{
+    UiProgress_t* pUiProgress   = (UiProgress_t*)hUiProgress;
+
+    if (!smartModeTotalBytes_f || !smartModePercents) {
+        DWN_ERR("arg error!, smartModeTotalBytes_f %lld, smartModePercents %u\n", smartModeTotalBytes_f, smartModePercents);
+        show_logo_report_burn_ui_error();
+        return __LINE__;
+    }
+    pUiProgress->smartModeTotalBytes_f     = smartModeTotalBytes_f;
+    pUiProgress->nDownBytesOnePercent_f     = smartModeTotalBytes_f/smartModePercents;
+    DWN_DBG("nDownBytesOnePercent_f %d\n", pUiProgress->nDownBytesOnePercent_f);
+    pUiProgress->smartModeLeftBytes     = 0;
+
+    return 0;
+}
+
+int optimus_progress_ui_set_unfocus_bkg(__hdle hUiProgress, unsigned long unfocusBmpAddr)
+{
+    UiProgress_t* pUiProgress   = (UiProgress_t*)hUiProgress;
+    bmp_header_t* bkgBmpHead    = (bmp_header_t*)unfocusBmpAddr;
+    const unsigned barHeight    = pUiProgress->progressBarHeight_f;
+    const unsigned bkgHeight    = bkgBmpHead->height;
+    const unsigned bkgWidth     = bkgBmpHead->width;
+    const int nProgressBar      = pUiProgress->totalPercents_f
+                    * pUiProgress->nProgressBarOnePercent_f / bkgWidth;
+    int progressBarX            = pUiProgress->nextProgressBarX;
+    const int progressBarY      = pUiProgress->progressBarY_f;
+
+    int i = 0;
+
+    //allow width not equal, but height must equal!
+    if (barHeight != bkgHeight) {
+        DWN_ERR("barHeight %d != bkgHeight %d\n", barHeight, bkgHeight);
+        show_logo_report_burn_ui_error();
+        return __LINE__;
+    }
+
+    //show the progress bar to update progress to video device
+    for (i=0; i < nProgressBar; ++i)
+    {
+        char cmd[64];
+
+        sprintf(cmd, "bmp display 0x%lx %d %d", unfocusBmpAddr, progressBarX, progressBarY);
+        if (run_command(cmd, 0)) {
+            DWN_ERR("Fail to in cmd[%s]\n", cmd);
+            show_logo_report_burn_ui_error();
+            return __LINE__;
+        }
+
+        progressBarX += bkgWidth;
+    }
+
+#ifdef CONFIG_OSD_SCALE_ENABLE
+    //run_command("bmp scale", 0);
+#endif// #ifdef CONFIG_OSD_SCALE_ENABLE
+
+    return 0;
+}
+
+static int optimus_progress_ui_set_steps(__hdle hUiProgress, int steps)
+{
+    UiProgress_t* pUiProgress   = (UiProgress_t*)hUiProgress;
+    const int curPercent        = pUiProgress->curPercent;
+    char strStep[16];
+
+    sprintf(strStep, "%d%%", steps);
+    lcd_drawchars((ushort)pUiProgress->upgradeStepX_f, (ushort)pUiProgress->upgradeStepY_f, (uchar*)strStep, strlen(strStep));
+
+    if (UPGRADE_STEPS_AFTER_IMAGE_OPEN_OK == curPercent)
+    {
+        lcd_printf("[OK]Open image\n");
+    }
+    if (UPGRADE_STEPS_AFTER_DISK_INIT_OK == curPercent)
+    {
+        lcd_printf("[OK]Disk initial\n");
+    }
+    else if(UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK == curPercent)
+    {
+        lcd_printf("[OK]Burn Data Partitons\n");
+    }
+    else if(UPGRADE_STEPS_AFTER_BURN_BOOTLOADER_OK == curPercent)
+    {
+        lcd_printf("[OK]Burn bootloader\n");
+    }
+
+    return 0;
+}
+
+int optimus_progress_ui_direct_update_progress(__hdle hUiProgress, const int percents)
+{
+    UiProgress_t* pUiProgress = (UiProgress_t*)hUiProgress;
+    const int     nPercents   = percents - pUiProgress->curPercent;
+    const int     nProgressBar= nPercents * pUiProgress->nProgressBarOnePercent_f / pUiProgress->progressBarWidth_f;
+    int   i = 0;
+
+    //if already up to this user percents, not need to update yet!
+    if (percents > pUiProgress->endPercent_f) {
+        DWN_ERR("user percents(%d) beyond max (%d)\n", percents, pUiProgress->endPercent_f);
+        show_logo_report_burn_ui_error();
+        return __LINE__;
+    }
+    if (nPercents <= 0) {
+        DWN_MSG("curPercent(%d) >= percents(%d)\n", pUiProgress->curPercent, percents);
+        show_logo_report_burn_ui_error();
+        return 0;
+    }
+
+    DWN_DBG("curPercent %d, percents %d, nPercents %d\n", pUiProgress->curPercent, percents, nPercents);
+    DWN_DBG("nProgressBar %d, %d\n", nProgressBar, pUiProgress->progressBarWidth_f);
+
+    //show the progress bar to update progress to video device
+    for (i=0; i < nProgressBar; ++i)
+    {
+        const int progressBarX          = pUiProgress->nextProgressBarX;
+        const int progressBarY          = pUiProgress->progressBarY_f;
+        const unsigned bmpAddr          = pUiProgress->bmpAddr_f;
+        char cmd[64];
+
+        sprintf(cmd, "bmp display %x %d %d ", bmpAddr, progressBarX, progressBarY);
+        if (run_command(cmd, 0)) {
+            DWN_ERR("Fail to in cmd[%s]\n", cmd);
+            show_logo_report_burn_ui_error();
+            return __LINE__;
+        }
+
+        pUiProgress->nextProgressBarX += pUiProgress->progressBarWidth_f;
+    }
+#ifdef CONFIG_OSD_SCALE_ENABLE
+    //run_command("bmp scale", 0);
+#endif// #ifdef CONFIG_OSD_SCALE_ENABLE
+
+    pUiProgress->curPercent                 = percents;
+
+    optimus_progress_ui_set_steps(hUiProgress, percents);
+
+    return 0;
+}
+
+//intelligent mode, update progress by download bytes
+int optimus_progress_ui_update_by_bytes(__hdle hUiPrgress, const unsigned nBytes)
+{
+    UiProgress_t* pUiProgress   = (UiProgress_t*)hUiPrgress;
+    const unsigned nDownBytesOnePercent_f = pUiProgress->nDownBytesOnePercent_f;
+    const unsigned bytesNotReport         = nBytes + pUiProgress->smartModeLeftBytes;
+    int percentsIncreased       = 0;
+    unsigned leftBytes          = 0;
+    int         ret             = 0;
+    int percentsToReport        = 0;
+
+    //bytes not enghout to update one percent
+    if (bytesNotReport < nDownBytesOnePercent_f)
+    {
+        pUiProgress->smartModeLeftBytes = bytesNotReport;
+        return 0;
+    }
+    percentsIncreased   = bytesNotReport / nDownBytesOnePercent_f;
+    leftBytes           = bytesNotReport - percentsIncreased * nDownBytesOnePercent_f;
+
+    percentsToReport    = percentsIncreased + pUiProgress->curPercent;
+    DWN_DBG("update ui to [%d%%]\n", percentsToReport);
+    ret = optimus_progress_ui_direct_update_progress(hUiPrgress, percentsToReport);
+    pUiProgress->smartModeLeftBytes = leftBytes;
+
+    return ret;
+}
+
+int optimus_progress_ui_release(__hdle hUiPrgress)
+{
+    UiProgress_t* pUiProgress = (UiProgress_t*)hUiPrgress;
+
+    DWN_MSG("Release prgress bar res\n");
+    if (pUiProgress)
+    {
+        free(pUiProgress), pUiProgress = NULL;
+    }
+
+    return 0;
+}
+
+__hdle optimus_progress_ui_request_for_sdc_burn(void)
+{
+    __hdle hUiProgress = NULL;
+    unsigned barAddr = simple_strtoul(getenv("upgrade_bar_offset"), NULL, 0);
+    unsigned display_width = simple_strtoul(getenv("fb_width"), NULL, 0);
+    unsigned display_height = simple_strtoul(getenv("fb_height"), NULL, 0);
+    bmp_header_t* upgrading  = (bmp_header_t*)simple_strtoul(getenv("upgrade_upgrading_offset"), NULL, 0);
+    const unsigned loadingHeight = upgrading->height;
+    const unsigned barYCor       =
+        (3* display_height + loadingHeight)/4;//display_height - (display_height/2 - loadingHeight/2)/2;
+    unsigned unfocusBmpAddr = simple_strtoul(getenv("upgrade_unfocus_offset"), NULL, 0);
+
+    if (!barAddr) {
+        DWN_ERR("Fail to getenv[%s=%s]\n",
+                "upgrade_bar_offset", getenv("upgrade_bar_offset"));
+        show_logo_report_burn_ui_error();
+        return NULL;
+    }
+    if (!display_width) {
+        DWN_ERR("Fail to getenv[%s=%s]\n",
+                "fb_width", getenv("fb_width"));
+        show_logo_report_burn_ui_error(); return NULL;
+    }
+    if (!display_height) {
+        DWN_ERR("Fail to getenv[%s=%s]\n",
+                "fb_height", getenv("fb_height")); return NULL;
+    }
+    if (!upgrading) {
+        DWN_ERR("Fail to getenv[%s=%s]\n",
+                "upgrade_upgrading_offset", getenv("upgrade_upgrading_offset"));
+        show_logo_report_burn_ui_error(); return NULL;
+    }
+    if (!unfocusBmpAddr) {
+        DWN_ERR("Fail to getenv[%s=%s]\n",
+                "upgrade_unfocus_offset", getenv("upgrade_unfocus_offset"));
+        show_logo_report_burn_ui_error(); return NULL;
+    }
+    DWN_DBG("upgrade_unfocus_offset=%s\n", getenv("upgrade_unfocus_offset"));
+
+    DWN_MSG("dw,dh[%u, %u]\n", display_width, display_height);
+    hUiProgress = optimus_progress_ui_request(100, 0,barAddr, display_width, barYCor);
+    if (!hUiProgress) {
+        DWN_ERR("Fail to request progress bar\n");
+        return NULL;
+    }
+
+    if (optimus_progress_ui_set_unfocus_bkg(hUiProgress, unfocusBmpAddr)) {
+        DWN_ERR("Fail to set bkg\n");
+        return NULL;;
+    }
+
+    return hUiProgress;
+}
+
+int optimus_progress_ui_report_upgrade_stat(__hdle hUiProgress, const int isSuccess)
+{
+    UiProgress_t* pUiProgress = (UiProgress_t*)hUiProgress;
+    const int curPercent      = pUiProgress->curPercent;
+
+    if (isSuccess)
+    {
+        optimus_progress_ui_direct_update_progress(hUiProgress, 100);
+        _show_burn_logo("upgrade_success_offset");
+        lcd_printf("Burning Success^^\nPLS SHORT-PRESS the power key to shut down\n");
+        return 0;
+    }
+
+    _show_burn_logo("upgrade_fail_offset");
+    lcd_printf("[Failed] at ");
+    //Followings failure
+    if (UPGRADE_STEPS_AFTER_IMAGE_OPEN_OK == curPercent)
+    {
+        lcd_printf("Disk initial!!\n");
+    }
+    else if(UPGRADE_STEPS_AFTER_DISK_INIT_OK < curPercent && UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK > curPercent)
+    {
+        lcd_printf("Burning Data Partitons[%d%%]\n", curPercent);
+    }
+    else if(UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK == curPercent)
+    {
+        lcd_printf("Burning bootloader\n");
+    }
+    else if(UPGRADE_STEPS_AFTER_BURN_BOOTLOADER_OK == curPercent)
+    {
+        lcd_printf("Burn complete\n");
+    }
+    lcd_printf("PLS LONG-PRESS the power key to shut down\n");
+
+    return 0;
+}
+
+int optimus_progress_ui_printf(const char* fmt, ...)
+{
+	va_list args;
+	char buf[CONFIG_SYS_PBSIZE];
+
+	va_start(args, fmt);
+	vsprintf(buf, fmt, args);
+	va_end(args);
+
+	lcd_printf(buf);
+    return 0;
+}
+
+#define PROGRESS_BAR_TEST 0
+#if PROGRESS_BAR_TEST
+static int do_progress_bar_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    //bmp display $upgrade_bar_offset x,y,width
+    static __hdle hProgressBar = NULL;
+    int percents = 0;
+
+    if (argc < 2) {
+        cmd_usage(cmdtp);
+        return __LINE__;
+    }
+
+    if (!strcmp("rel", argv[1])) {
+        optimus_progress_ui_release(hProgressBar);
+        hProgressBar = NULL;
+        return 0;
+    }
+
+    run_command("imgread res logo $loadaddr; unpackimg $loadaddr", 0);
+    run_command("setenv outputmode 1080p60hz;", 0);
+
+    if (!hProgressBar)
+    {
+        unsigned barAddr = simple_strtoul(getenv("upgrade_bar_offset"), NULL, 0);
+        unsigned display_width = simple_strtoul(getenv("fb_width"), NULL, 0);
+        unsigned display_height = simple_strtoul(getenv("fb_height"), NULL, 0);
+        bmp_header_t* upgrading  = (bmp_header_t*)simple_strtoul(getenv("upgrade_upgrading_offset"), NULL, 0);
+        const unsigned loadingHeight = upgrading->height;
+        const unsigned barYCor       =
+            (3* display_height + loadingHeight)/4;//display_height - (display_height/2 - loadingHeight/2)/2;
+        unsigned unfocusBmpAddr = simple_strtoul(getenv("upgrade_unfocus_offset"), NULL, 0);
+
+        if (!barAddr) {
+            DWN_ERR("Fail to getenv[%s=%s]\n",
+                    "upgrade_bar_offset", getenv("upgrade_bar_offset")); return __LINE__;
+        }
+        if (!display_width) {
+            DWN_ERR("Fail to getenv[%s=%s]\n",
+                   "fb_width", getenv("fb_width")); return __LINE__;
+        }
+        if (!display_height) {
+            DWN_ERR("Fail to getenv[%s=%s]\n",
+                    "fb_height", getenv("fb_height")); return __LINE__;
+        }
+        if (!upgrading) {
+            DWN_ERR("Fail to getenv[%s=%s]\n",
+                    "upgrade_upgrading_offset", getenv("upgrade_upgrading_offset")); return __LINE__;
+        }
+        if (!unfocusBmpAddr) {
+            DWN_ERR("Fail to getenv[%s=%s]\n",
+                    "upgrade_unfocus_offset", getenv("upgrade_unfocus_offset")); return __LINE__;
+        }
+
+        hProgressBar = optimus_progress_ui_request(100, 0, barAddr, display_width, barYCor);
+        if (!hProgressBar) {
+            DWN_ERR("Fail to request progress bar\n");
+            return __LINE__;
+        }
+
+        if (optimus_progress_ui_set_unfocus_bkg(hProgressBar, unfocusBmpAddr)) {
+            DWN_ERR("Fail to set bkg\n");
+            return __LINE__;
+        }
+        lcd_printf("-----25%%");
+    }
+
+    //dir: directly show percents
+    if (!strcmp("dir", argv[1]))
+    {
+        percents = simple_strtoul(argv[2], NULL, 10);
+        optimus_progress_ui_direct_update_progress(hProgressBar, percents);
+    }
+    else if(!strcmp("nb", argv[1]))//smart mode, display in bytes
+    {
+        static u64 dataBytes = 0;
+        unsigned nBytes = simple_strtoul(argv[2], NULL, 10);
+
+        if (!dataBytes) {
+            dataBytes = 2u*1024*1024*1024;
+            if (optimus_progress_ui_set_smart_mode(hProgressBar, dataBytes, 90)) {
+                DWN_ERR("Fail to set smart mode\n");
+                return __LINE__;
+            }
+        }
+        optimus_progress_ui_update_by_bytes(hProgressBar, nBytes);
+    }
+
+
+    return 0;
+}
+
+U_BOOT_CMD(
+   bar,      //command name
+   5,               //maxargs
+   0,               //repeatable
+   do_progress_bar_test,   //command function
+   "Test dynamic upgrade progress bar",           //description
+   "argv: dir [percents]: show percents directlry\n"//usage
+   "argv: nb [bytes]: smart mode, show percents with bytes\n"//usage
+);
+#endif//#if PROGRESS_BAR_TEST
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_progress_ui.h b/drivers/usb/gadget/v2_burning/v2_common/optimus_progress_ui.h
new file mode 100644
index 0000000..ae2c497
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_progress_ui.h
@@ -0,0 +1,82 @@
+/*
+ * \file        optimus_progress_ui.h
+ * \brief       interfaces of optimus_progress_ui.c
+ *
+ * \version     1.0.0
+ * \date        2013/10/13
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+#ifndef __OPTIMUS_PROGRESS_UI__
+#define __OPTIMUS_PROGRESS_UI__
+
+//after erase_bootloader, before store_init
+#define UPGRADE_STEPS_AFTER_IMAGE_OPEN_OK               2//disk_initialed failed if hang up here
+#define UPGRADE_STEPS_AFTER_DISK_INIT_OK                5//burn data parts failed if hang up in [6, 95]
+#define UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK          95
+#define UPGRADE_STEPS_AFTER_BURN_BOOTLOADER_OK          98
+
+#define UPGRADE_STEPS_FOR_BURN_DATA_PARTS_IN_PKG(allInPkg)     \
+    ((allInPkg) ? (UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK - UPGRADE_STEPS_AFTER_DISK_INIT_OK - 1) : (UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK - UPGRADE_STEPS_AFTER_DISK_INIT_OK - 10))
+
+#if CONFIG_SD_BURNING_SUPPORT_UI
+int show_logo_to_report_burning(void);//show bmp 'upgrade_upgrading'
+
+int show_logo_to_report_burn_failed(void); //Display logo to report burning result is failed
+
+int show_logo_to_report_burn_success(void);
+
+__hdle optimus_progress_ui_request(const int totalPercents_f,       int startPercent,
+                                 unsigned long bmpBarAddr,       int display_width,  int progressBarY_f );
+__hdle optimus_progress_ui_request_for_sdc_burn(void);
+
+int optimus_progress_ui_release(__hdle hUiPrgress);
+
+int optimus_progress_ui_set_unfocus_bkg(__hdle hUiProgress, unsigned long unfocusBmpAddr);
+
+int optimus_progress_ui_direct_update_progress(__hdle hUiProgress, const int percents);
+
+int optimus_progress_ui_report_upgrade_stat(__hdle hUiProgress, const int isSuccess);
+
+//smart mode with bytes
+int optimus_progress_ui_set_smart_mode(__hdle hUiProgress, const u64 smartModeTotalBytes_f, const unsigned smartModePercents);
+int optimus_progress_ui_update_by_bytes(__hdle hUiPrgress, const unsigned nBytes);
+
+int optimus_progress_ui_printf(const char* fmt, ...);
+
+int video_res_prepare_for_upgrade(HIMAGE hImg);
+
+#else
+
+#define video_res_prepare_for_upgrade(hImg) 0
+
+#define show_logo_to_report_burning()
+
+#define show_logo_to_report_burn_failed()   0
+
+#define show_logo_to_report_burn_success()  0
+
+#define optimus_progress_ui_request(totalPercents_f,startPercent, bmpBarAddr,display_width,progressBarY_f ) 1
+
+#define optimus_progress_ui_request_for_sdc_burn() (void*)1
+
+#define optimus_progress_ui_release(hUiPrgress)     do{}while(0)
+
+#define optimus_progress_ui_set_unfocus_bkg(hUiProgress, unfocusBmpAddr)    0
+
+#define optimus_progress_ui_direct_update_progress(a ...)   do{}while(0)
+
+//smart mode with bytes
+#define optimus_progress_ui_set_smart_mode(a ...)  0
+#define optimus_progress_ui_update_by_bytes(hUiPrgress, nBytes) do{}while(0)
+
+#define  optimus_progress_ui_report_upgrade_stat(a ...) do{}while(0)
+
+#define optimus_progress_ui_printf(a ...) do{}while(0)
+
+#endif//#if CONFIG_SD_BURNING_SUPPORT_UI
+
+#endif//ifndef __OPTIMUS_PROGRESS_UI__
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_simg2img.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_simg2img.c
new file mode 100644
index 0000000..339c010
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_simg2img.c
@@ -0,0 +1,436 @@
+/*
+ * \file        optimus_simg2img.c
+ * \brief       sparse image to ext4 image in optimus system
+ *              a sparse image consit of "file_header + chunk_num * (chunk_header + [chunk_data]),
+ *              chunk data can be empty when chunk type is CHUNK_TYPE_DONT_CARE"
+ *
+ * \version     1.0.0
+ * \date        2013/5/6
+ * \author      Sam.Wu <yihui.wu@Amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc. All Rights Reserved.
+ *
+ */
+#include "../v2_burning_i.h"
+#include <partition_table.h>
+
+#define sperr               DWN_ERR
+#define spmsg(fmt ...)      //printf("spmsg:"fmt)
+#define spdbg(fmt ...)      //printf("SP:"), printf(__VA_ARGS__)
+
+#define  SPARSE_HEADER_MAJOR_VER 1
+#define  CHUNK_HEAD_SIZE        sizeof(chunk_header_t)
+#define  FILE_HEAD_SIZE         sizeof(sparse_header_t)
+
+//states for a sparse packet, initialized when sparse packet probed
+static struct
+{
+    unsigned leftChunkNum;//chunks that not parsed yet
+    unsigned chunksBufLen;//>=OPTIMUS_DOWNLOAD_SPARSE_TRANSFER_SZ
+
+    unsigned sparseBlkSz;//block size of sparse format packet
+    unsigned parsedPacketCrc;//crc value for packet that already parsed
+
+    int      pktHeadLen;
+    u32      reservetoAlign64;
+
+    //If long chunk data sz > write back size(e.g. 64M), write it at next write back time, This can't reduce copy and use less buffer
+    u32      notWrBackSz4LongChunk;
+    u32      nextFlashAddr4LastLongChunk; //flash start Addr not write back chunk data , in sector
+
+    //back up infomation for verify
+    u32      chunkInfoBackAddr;//file header and chunk info back address
+    u32      backChunkNum;      //chunk number backed
+    u64      chunkOffset;
+
+}_spPacketStates;
+
+//0 is not sparse packet header, else is sparse packet_header
+int optimus_simg_probe(const u8* source, const u32 length)
+{
+	sparse_header_t *header = (sparse_header_t*) source;
+
+    if (length < sizeof(sparse_header_t)) {
+        sperr("length %d < sparse_header_t len %d\n", length, (int)FILE_HEAD_SIZE);
+        return 0;
+    }
+	if (header->magic != SPARSE_HEADER_MAGIC) {
+		spmsg("sparse bad magic, expect 0x%x but 0x%x\n", SPARSE_HEADER_MAGIC, header->magic);
+		return 0;
+	}
+
+    if(!(SPARSE_HEADER_MAJOR_VER == header->major_version
+                && FILE_HEAD_SIZE == header->file_hdr_sz
+                && CHUNK_HEAD_SIZE == header->chunk_hdr_sz))
+    {
+        sperr("want 0x [%x, %x, %x], but [%x, %x, %x]\n",
+                SPARSE_HEADER_MAJOR_VER,    (unsigned)FILE_HEAD_SIZE,             (unsigned)CHUNK_HEAD_SIZE,
+                header->major_version,      header->file_hdr_sz,        header->chunk_hdr_sz);
+        return 0;
+    }
+
+
+	return 1;
+}
+
+int optimus_simg_parser_init(const u8* source)
+{
+	sparse_header_t *header = (sparse_header_t*) source;
+
+    memset(&_spPacketStates, 0, sizeof(_spPacketStates));
+    _spPacketStates.leftChunkNum    = header->total_chunks;
+    _spPacketStates.parsedPacketCrc = 0;
+    _spPacketStates.pktHeadLen      = header->file_hdr_sz;
+    _spPacketStates.sparseBlkSz     = header->blk_sz;//often 4k
+    spmsg("totalChunkNum %d, fileHeadSz 0x%x, chunkHeadSz 0x%x\n", _spPacketStates.leftChunkNum, _spPacketStates.pktHeadLen, CHUNK_HEAD_SIZE);
+
+    //for verify
+    _spPacketStates.chunkInfoBackAddr = OPTIMUS_DOWNLOAD_SPARSE_INFO_FOR_VERIFY;
+    _spPacketStates.backChunkNum      = 0;
+    memcpy((void*)(u64)_spPacketStates.chunkInfoBackAddr, header, sizeof(sparse_header_t));
+    spmsg("back header addr 0x%x\n", _spPacketStates.chunkInfoBackAddr);
+
+	return OPT_DOWN_OK;
+}
+
+//return value: flash address offset in sector in this time dispose
+//call this method to parse sparse format data and write it to media
+//@flashAddrInSec: flash write address of first chunk
+//@simgPktHead   : buffered sparse image
+//@pktLen        : buffered sparse data len
+//@unParsedDataLen: data length need write at next write back time
+//      Take care the size to align 64K for flash and and addres to align sector!!!!
+int optimus_simg_to_media(char* simgPktHead, const u32 pktLen, u32* unParsedDataLen, const u32 flashAddrInSec)
+{
+    const unsigned notWrBackSz4LongChunk = _spPacketStates.notWrBackSz4LongChunk;
+    unsigned unParsedBufLen = pktLen - _spPacketStates.pktHeadLen;
+    u32 flashAddrStart = flashAddrInSec;
+    chunk_header_t* pChunk = (chunk_header_t*)(simgPktHead + _spPacketStates.pktHeadLen);
+    chunk_header_t* backChunkHead = (chunk_header_t*)(_spPacketStates.chunkInfoBackAddr + FILE_HEAD_SIZE) + _spPacketStates.backChunkNum;
+
+    if (notWrBackSz4LongChunk && !_spPacketStates.pktHeadLen/*0 if head*/)
+    {
+        //const chunk_header_t* pLastLongChunk = backChunkHead - 1;////
+        //const unsigned leftLongChunk_dataLen = pLastLongChunk->total_sz;
+        const unsigned leftLongChunk_flashAddr = _spPacketStates.nextFlashAddr4LastLongChunk;
+        unsigned writeLen = 0;
+        unsigned thisWriteLen = 0;
+
+        thisWriteLen = notWrBackSz4LongChunk >= pktLen ? pktLen : notWrBackSz4LongChunk;
+        if (notWrBackSz4LongChunk > thisWriteLen) {
+            //Align write size to 64K for flash write until last flash write
+            //At least make sure align to sector as flashAddress in sector here!!!
+            thisWriteLen >>= OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS; thisWriteLen <<= OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS;
+            spmsg("pktLen(0x%08x) < long chunk leftLen 0x%x08\n", pktLen, notWrBackSz4LongChunk);
+        }
+        spmsg("notWrBackSz4LongChunk 0x%08x, thisWriteLen 0x%08x, flashAddr 0x%08xSec\n", notWrBackSz4LongChunk, thisWriteLen, leftLongChunk_flashAddr);
+
+        writeLen = optimus_cb_simg_write_media(leftLongChunk_flashAddr, thisWriteLen, simgPktHead);
+        if (thisWriteLen != writeLen) {
+            sperr("Want to write left chunk sz 0x%x, but only 0x%x\n", thisWriteLen, writeLen);
+            return -__LINE__;
+        }
+
+        unParsedBufLen -= thisWriteLen;
+        _spPacketStates.notWrBackSz4LongChunk -= thisWriteLen;
+
+        if (notWrBackSz4LongChunk >= pktLen) //packet data ended
+        {
+            _spPacketStates.nextFlashAddr4LastLongChunk += thisWriteLen>>9;//address needed next write time
+            *unParsedDataLen = unParsedBufLen;
+            return 0;//the long chunk not disposed all yet!
+        }
+
+        pChunk = (chunk_header_t*)(simgPktHead + notWrBackSz4LongChunk + _spPacketStates.pktHeadLen);
+    }
+
+
+    spdbg("headLen=0x%x, leftNum=%d, backNum %d\n", _spPacketStates.pktHeadLen, _spPacketStates.leftChunkNum, _spPacketStates.backChunkNum);
+    for (;_spPacketStates.leftChunkNum && !_spPacketStates.notWrBackSz4LongChunk; _spPacketStates.leftChunkNum--)
+    {
+        //chunk data for ext4, but maybe empty in sparse, that is why called sparse format
+        const unsigned chunkDataLen = pChunk->chunk_sz * _spPacketStates.sparseBlkSz;
+        unsigned thisWriteLen = 0;
+
+        if (CHUNK_HEAD_SIZE > unParsedBufLen) {//total size not enough for CHUNK_HEAD_SIZE yet!!
+            spmsg("unParsedBufLen 0x%x < head sz 0x%x\n", unParsedBufLen, CHUNK_HEAD_SIZE);
+            break;
+        }
+
+        switch (pChunk->chunk_type)
+        {
+        case CHUNK_TYPE_RAW:
+            {
+                unsigned wantWrLen = chunkDataLen;
+
+                if (CHUNK_HEAD_SIZE + chunkDataLen != pChunk->total_sz) {
+                    sperr("sparse: bad chunk size: head 0x%x + data 0x%x != total 0x%x\n",
+                            (unsigned)CHUNK_HEAD_SIZE, chunkDataLen, pChunk->total_sz);
+                    return -__LINE__;
+                }
+
+                if (pChunk->total_sz > unParsedBufLen)//left data not enough for this chunk (chunk header + chunk data)
+                {
+                    const unsigned unParseChunkDataLen = unParsedBufLen - CHUNK_HEAD_SIZE;
+
+                    wantWrLen = (unParseChunkDataLen >> OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS) << OPTIMUS_DOWNLOAD_SLOT_SZ_SHIFT_BITS;
+                    _spPacketStates.notWrBackSz4LongChunk = chunkDataLen - wantWrLen;
+                    _spPacketStates.nextFlashAddr4LastLongChunk = flashAddrStart + (wantWrLen>>9);
+                    spmsg("Not enough one chunk: unParseChunkDataLen 0x%x ,chunk data len 0x%x, wantWrLen 0x%x, left 0x%08x\n",
+                            unParseChunkDataLen, chunkDataLen, wantWrLen, _spPacketStates.notWrBackSz4LongChunk);
+                }
+
+                if (wantWrLen)
+                {
+                    thisWriteLen = optimus_cb_simg_write_media(flashAddrStart, wantWrLen, (char*)pChunk + CHUNK_HEAD_SIZE);
+                    if (thisWriteLen != wantWrLen) {
+                        sperr("Fail to write to flash, want to write %dB, but %dB\n", wantWrLen, thisWriteLen);
+                        return -__LINE__;
+                    }
+                }
+            }
+            break;
+
+        case CHUNK_TYPE_DONT_CARE:
+            {
+                DWN_DBG("don't care chunk\n");
+                if (CHUNK_HEAD_SIZE != pChunk->total_sz) {
+                    sperr("bogus DONT CARE chunk\n");
+                    return -__LINE__;
+                }
+
+            }
+            break;
+
+        case CHUNK_TYPE_FILL:
+            {
+                    const unsigned fillVal = *(unsigned*)(pChunk + 1);
+                    unsigned LeftDataLen   = chunkDataLen;
+                    unsigned temp_flashAddrStart = flashAddrStart;
+                    unsigned* pFillValBuf = (unsigned*)OPTIMUS_SPARSE_IMG_FILL_VAL_BUF;
+                    const unsigned FillBufSz = OPTIMUS_SPARSE_IMG_FILL_BUF_SZ;
+                    static unsigned _filledBufValidLen = 0;
+                    const unsigned thisChunkFilledLen = min(chunkDataLen, FillBufSz);
+                    int _NeedFillAsNotErasedYet = 0;
+
+                    spdbg("CHUNK_TYPE_FILL,fillVal=0x%8x, chunkDataLen=0x%8x, thisChunkFilledLen=0x%x\n",
+                                    fillVal, chunkDataLen, thisChunkFilledLen);
+                    if (CHUNK_HEAD_SIZE + 4 != pChunk->total_sz) {
+                            sperr("error FILL chunk\n");
+                            return -__LINE__;
+                    }
+                    switch (device_boot_flag) {
+                            case EMMC_BOOT_FLAG:
+                            case SPI_EMMC_FLAG:
+                                    _NeedFillAsNotErasedYet = (fillVal != 0);
+                                    break;
+
+                            case NAND_BOOT_FLAG:
+                            case SPI_NAND_FLAG:
+                                    _NeedFillAsNotErasedYet = (fillVal != 0XFFFFFFFFU);
+                                    break;
+                            default:
+                                    _NeedFillAsNotErasedYet = 1;
+                                    break;
+                    }
+                    //for, emmc, if fillVal is 0, then _NeedFillAsNotErasedYet = false if "disk_inital > 0"
+                    if (!_NeedFillAsNotErasedYet)_NeedFillAsNotErasedYet = (is_optimus_storage_inited()>>16) == 0;// == 0 means 'disk_inital 0'
+
+                    if (_NeedFillAsNotErasedYet)
+                    {
+                            if (!_filledBufValidLen) {
+                                    DWN_MSG("CHUNK_TYPE_FILL\n");
+                            }
+                            if (fillVal != *pFillValBuf && _filledBufValidLen) {
+                                    _filledBufValidLen = 0;
+                            }
+                            if (_filledBufValidLen < thisChunkFilledLen) {
+                                    int i = _filledBufValidLen>>2;
+                                    unsigned* temBuf = pFillValBuf + i;
+
+                                    while (i++ < (thisChunkFilledLen>>2)) *temBuf++ = fillVal;
+                                    _filledBufValidLen = thisChunkFilledLen;
+                            }
+
+                            do {
+                                    unsigned actualWrLen = 0;
+
+                                    thisWriteLen = min(LeftDataLen, thisChunkFilledLen);
+
+                                    actualWrLen = optimus_cb_simg_write_media(temp_flashAddrStart, thisWriteLen, (char*)pFillValBuf);
+                                    if (actualWrLen != thisWriteLen) {
+                                            sperr("FILL_CHUNK:Want write 0x%x Bytes, but 0x%x\n", thisWriteLen, actualWrLen);
+                                            break;
+                                    }
+
+                                    temp_flashAddrStart += thisWriteLen >> 9;
+                                    LeftDataLen -= thisWriteLen;
+                            }while(LeftDataLen);
+                    }
+                    thisWriteLen = 4;///////////
+            }
+            break;
+        case CHUNK_TYPE_CRC32:
+            sperr("CHUNK_TYPE_CRC32 unsupported yet!\n");
+            return -__LINE__;
+        default:
+            sperr("unknown chunk ID 0x%x at %p\n", pChunk->chunk_type, pChunk);
+            return -__LINE__;
+        }
+
+        /////update for next chunk
+        unParsedBufLen                  -= CHUNK_HEAD_SIZE + thisWriteLen;
+        flashAddrStart                  += chunkDataLen>>9;
+        memcpy(backChunkHead, pChunk, CHUNK_HEAD_SIZE);//back up verify chunk info
+        spdbg("index %d ,tp 0x%x\n", _spPacketStates.backChunkNum, backChunkHead->chunk_type);
+        ++_spPacketStates.backChunkNum;
+        ++backChunkHead;
+
+        pChunk                           =  (chunk_header_t*)((u64)pChunk + pChunk->total_sz);
+    }
+
+    spmsg("leftChunkNum %d, bak num %d\n", _spPacketStates.leftChunkNum, _spPacketStates.backChunkNum);
+
+    _spPacketStates.pktHeadLen      = 0;//>0 only when first time
+
+    *unParsedDataLen = unParsedBufLen;
+    return (flashAddrStart - flashAddrInSec);
+}
+
+int optimus_sparse_back_info_probe(void)
+{
+    int ret = 0;
+
+    if (_spPacketStates.leftChunkNum)
+    {
+        DWN_ERR("%d chunk left, image not burn completed!!\n", _spPacketStates.leftChunkNum);
+        return OPT_DOWN_FALSE;
+    }
+
+    ret = optimus_simg_probe((u8*)(u64)_spPacketStates.chunkInfoBackAddr, FILE_HEAD_SIZE);
+    DWN_DBG("back h addr 0x%x\n", _spPacketStates.chunkInfoBackAddr);
+
+    return ret;
+}
+
+//get next chunk data to read from ext4 partition
+int optimus_sparse_get_chunk_data(u8** head, u32* headSz, u32* dataSz, u64* dataOffset)
+{
+    chunk_header_t* pChunk = (chunk_header_t*)(_spPacketStates.chunkInfoBackAddr + FILE_HEAD_SIZE) + _spPacketStates.leftChunkNum;//chunk header
+
+    *headSz = *dataOffset = *dataSz = 0;
+    DWN_DBG("leftNum %d\n", _spPacketStates.backChunkNum);
+
+    if (!_spPacketStates.leftChunkNum) //file header
+    {
+        *headSz = FILE_HEAD_SIZE;
+        *head   = (u8*)(u64)_spPacketStates.chunkInfoBackAddr;
+    }
+    else
+    {
+        *head = (u8*)pChunk;
+    }
+
+    //parse until RAW chunk or no chunk left
+    for (;_spPacketStates.leftChunkNum < _spPacketStates.backChunkNum;)
+    {
+        const unsigned chunkDataLen = pChunk->chunk_sz * _spPacketStates.sparseBlkSz;
+
+        switch (pChunk->chunk_type)
+        {
+        case CHUNK_TYPE_RAW:
+            {
+                if (CHUNK_HEAD_SIZE + chunkDataLen != pChunk->total_sz) {
+                    sperr("sparse: bad chunk size!\n");
+                    return OPT_DOWN_FAIL;
+                }
+
+                *dataSz = chunkDataLen;
+            }
+            break;
+
+        case CHUNK_TYPE_DONT_CARE:
+            {
+                spdbg("don't care chunk\n");
+                if (CHUNK_HEAD_SIZE != pChunk->total_sz) {
+                    sperr("bogus DONT CARE chunk\n");
+                    return OPT_DOWN_FAIL;
+                }
+            }
+            break;
+
+        case CHUNK_TYPE_FILL:
+            {
+                spdbg("CHUNK_TYPE_FILL\n");
+                if (CHUNK_HEAD_SIZE + 4 != pChunk->total_sz) {
+                    sperr("bogus DONT CARE chunk\n");
+                    return OPT_DOWN_FAIL;
+                }
+                *dataSz = 4;///////
+            }
+            break;
+
+
+        default:
+            sperr("unknown chunk ID 0x%x, parsed %d, total %d\n", pChunk->chunk_type, _spPacketStates.leftChunkNum, _spPacketStates.backChunkNum);
+            return OPT_DOWN_FAIL;
+        }
+
+        //update backed chunk info
+        *dataOffset = _spPacketStates.chunkOffset;//attention that offset < totalDataLen
+
+        _spPacketStates.chunkOffset += chunkDataLen;;
+        *headSz += CHUNK_HEAD_SIZE;
+        ++pChunk;
+        ++_spPacketStates.leftChunkNum;
+
+        if (*dataSz) break;
+    }
+
+    spdbg("left %d, total %d\n", _spPacketStates.leftChunkNum, _spPacketStates.backChunkNum);
+    return OPT_DOWN_OK;
+}
+
+
+#if 0
+int do_timestamp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+/*const char* optimus_time_stamp(void)*/
+{
+    const char* _formatStr = "[%5d.%03d]";
+    static char TimeStr[32] ;
+    int timeMSec = 0;
+    ulong curTimeInUSec = 0;
+static ulong timeInUSec = 0;
+
+    if (!timeInUSec)
+    {
+        timeInUSec = get_timer(timeInUSec);
+        return 0;
+    }
+    timeInUSec = curTimeInUSec = get_timer(timeInUSec);//timer unit is in uS
+
+    /*printf("time %x, %x\n", (u32)(timeInUSec>>32), (u32)timeInUSec);*/
+    /*if(!timeInUSec) return "";//As eFG_printf and uart_printf use while(*str) to determin whether to print, here make use it to not to print*/
+
+    /*curTimeInUSec    /= 1000;//time to mSec*/
+    timeMSec   = curTimeInUSec % 1000;
+    curTimeInUSec    /= 1000;//time to Second
+
+    sprintf(TimeStr, _formatStr, (u32)curTimeInUSec, timeMSec);
+    printf(TimeStr);
+    printf("\n");
+
+    /*return TimeStr;*/
+    return 0;
+}
+
+U_BOOT_CMD(
+   timestamp,      //command name
+   5,               //maxargs
+   1,               //repeatable
+   do_timestamp,   //command function
+   "Burning a partition from sdmmc ",           //description
+   "Usage: sdc_update partiton image_file_path fileFmt(sparse or normal)\n"   //usage
+);
+#endif//#if 0
+
diff --git a/drivers/usb/gadget/v2_burning/v2_common/sparse_format.h b/drivers/usb/gadget/v2_burning/v2_common/sparse_format.h
new file mode 100644
index 0000000..6c62c34
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_common/sparse_format.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+typedef struct sparse_header {
+  __le32	magic;		/* 0xed26ff3a */
+  __le16	major_version;	/* (0x1) - reject images with higher major versions */
+  __le16	minor_version;	/* (0x0) - allow images with higer minor versions */
+  __le16	file_hdr_sz;	/* 28 bytes for first revision of the file format */
+  __le16	chunk_hdr_sz;	/* 12 bytes for first revision of the file format */
+  __le32	blk_sz;		/* block size in bytes, must be a multiple of 4 (4096) */
+  __le32	total_blks;	/* total blocks in the non-sparse output image */
+  __le32	total_chunks;	/* total chunks in the sparse input image */
+  __le32	image_checksum; /* CRC32 checksum of the original data, counting "don't care" */
+				/* as 0. Standard 802.3 polynomial, use a Public Domain */
+				/* table implementation */
+} sparse_header_t;
+
+#define SPARSE_HEADER_MAGIC	0xed26ff3a
+
+#define CHUNK_TYPE_RAW		0xCAC1
+#define CHUNK_TYPE_FILL		0xCAC2
+#define CHUNK_TYPE_DONT_CARE	0xCAC3
+#define CHUNK_TYPE_CRC32    0xCAC4
+
+typedef struct chunk_header {
+  __le16	chunk_type;	/* 0xCAC1 -> raw; 0xCAC2 -> fill; 0xCAC3 -> don't care */
+  __le16	reserved1;
+  __le32	chunk_sz;	/* in blocks in output image */
+  __le32	total_sz;	/* in bytes of chunk input file including chunk header and data */
+} chunk_header_t;
+
+/* Following a Raw or Fill or CRC32 chunk is data.
+ *  For a Raw chunk, it's the data in chunk_sz * blk_sz.
+ *  For a Fill chunk, it's 4 bytes of the fill data.
+ *  For a CRC32 chunk, it's 4 bytes of CRC32
+ */
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_ini__aml_sdc_burn.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_ini__aml_sdc_burn.c
new file mode 100644
index 0000000..861f09c
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_ini__aml_sdc_burn.c
@@ -0,0 +1,474 @@
+/*
+ * \file        optimus_ini__aml_sdc_burn.c
+ * \brief       parse the aml_sdc_burn.ini
+ *
+ * \version     1.0.0
+ * \date        2015/2/3
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "optimus_sdc_burn_i.h"
+
+#define dbg(fmt ...)  //printf("[INI_SDC]"fmt)
+#define msg           DWN_MSG
+#define err           DWN_ERR
+
+#define  SET_BURN_PARTS     "burn_parts"
+#define  SET_CUSTOM_PARA    "common"
+#define  SET_BURN_PARA_EX    "burn_ex"
+#define  SET_BURN_DISPLAY    "display"
+
+static const char* _iniSets[] = {
+    SET_BURN_PARTS      ,
+    SET_CUSTOM_PARA     ,
+    SET_BURN_PARA_EX    ,
+    SET_BURN_DISPLAY    ,
+};
+
+#define TOTAL_SET_NUM   ( sizeof(_iniSets)/sizeof(const char*) )
+
+ConfigPara_t g_sdcBurnPara = {
+    .setsBitMap.burnParts   = 0,
+    .setsBitMap.custom      = 0,
+    .setsBitMap.burnEx      = 0,
+
+    .burnParts      = {
+        .burn_num           = 0,
+        .bitsMap4BurnParts  = 0,
+    },
+
+    .custom         = {
+        .eraseBootloader    = 1,//default to erase bootloader!
+        .eraseFlash         = 0,
+        .bitsMap.eraseBootloader    = 0,
+        .bitsMap.eraseFlash         = 0,
+    },
+
+    .burnEx         = {
+        .bitsMap.pkgPath    = 0,
+        .bitsMap.mediaPath  = 0,
+    },
+};
+
+static int init_config_para(ConfigPara_t* pCfgPara)
+{
+    memset(pCfgPara, 0, sizeof(ConfigPara_t));
+
+    pCfgPara->setsBitMap.burnParts   = 0;
+    pCfgPara->setsBitMap.custom      = 0;
+    pCfgPara->setsBitMap.burnEx      = 0;
+
+    pCfgPara->burnParts.burn_num           = 0;
+    pCfgPara->burnParts.bitsMap4BurnParts  = 0;
+
+    pCfgPara->custom.eraseBootloader    = 1;//default to erase bootloader!
+    pCfgPara->custom.eraseFlash         = 0;
+    pCfgPara->custom.bitsMap.eraseBootloader    = 0;
+    pCfgPara->custom.bitsMap.eraseFlash         = 0;
+
+    pCfgPara->burnEx.bitsMap.pkgPath    = 0;
+    pCfgPara->burnEx.bitsMap.mediaPath  = 0;
+
+    return 0;
+}
+
+int print_burn_parts_para(const BurnParts_t* pBurnParts)
+{
+    int partIndex = 0;
+
+    printf("[%s]\n", SET_BURN_PARTS);
+    printf("burn_num         = %d\n", pBurnParts->burn_num);
+
+    for (; partIndex < pBurnParts->burn_num; ++partIndex)
+    {
+        printf("burn_part%d       = %s\n", partIndex, pBurnParts->burnParts[partIndex]);
+    }
+    printf("\n");
+
+    return 0;
+}
+
+static int print_sdc_burn_para(const ConfigPara_t* pCfgPara)
+{
+    printf("\n=========sdc_burn_paras=====>>>\n");
+
+    {
+        const CustomPara_t* pCustom = &pCfgPara->custom;
+
+        printf("[%s]\n", SET_CUSTOM_PARA);
+        printf("erase_bootloader = %d\n", pCustom->eraseBootloader);
+        printf("erase_flash      = %d\n", pCustom->eraseFlash);
+        printf("reboot           = 0x%x\n", pCustom->rebootAfterBurn);
+        printf("key_overwrite    = 0x%x\n", pCustom->keyOverwrite);
+        printf("\n");
+    }
+
+    {
+        const BurnEx_t*     pBurnEx = &pCfgPara->burnEx;
+
+        printf("[%s]\n", SET_BURN_PARA_EX);
+        printf("package          = %s\n", pBurnEx->pkgPath);
+        printf("media            = %s\n", pBurnEx->mediaPath);
+        printf("\n");
+    }
+
+    print_burn_parts_para(&pCfgPara->burnParts);
+
+    printf("<<<<=====sdc_burn_paras======\n\n");
+
+    return 0;
+}
+
+static int parse_set_burnEx(const char* key, const char* strVal)
+{
+    BurnEx_t* pBurnEx = &g_sdcBurnPara.burnEx;
+
+    if (!strcmp("package", key))
+    {
+        if (pBurnEx->bitsMap.pkgPath) {
+            err("key package in burn_ex is duplicated!\n");
+            return __LINE__;
+        }
+        if (!strVal) {
+            err("value for package in set burn_ex can't be empty!\n");
+            return __LINE__;
+        }
+
+        strcpy(pBurnEx->pkgPath, strVal);
+        pBurnEx->bitsMap.pkgPath = 1;
+
+        return 0;
+    }
+
+    if (!strcmp("media", key))
+    {
+        if (pBurnEx->bitsMap.mediaPath) {
+            err("key media in burn_ex is duplicated!\n");
+            return __LINE__;
+        }
+        if (strVal)
+        {
+            strcpy(pBurnEx->mediaPath, strVal);
+            pBurnEx->bitsMap.mediaPath = 1;
+        }
+
+        return 0;
+    }
+
+    return 0;
+}
+
+static int parse_set_display(const char* key, const char* strVal)
+{
+    BurnDisplay_t* pburnDisplay = &g_sdcBurnPara.display;
+
+    if (!strcmp("outputmode", key))
+    {
+        if (pburnDisplay->bitsMap4Display & (1U<<0)) {
+            err("key outputmode in burn_ex is duplicated!\n");
+            return __LINE__;
+        }
+        if (!strVal) {
+            err("value for package in set burn_ex can't be empty!\n");
+            return __LINE__;
+        }
+        setenv(key, strVal);
+        DWN_MSG("^^Set %s to (%s) for upgrade^^\n", key, strVal);
+        pburnDisplay->bitsMap4Display |= 1U<<0;
+
+        return 0;
+    }
+
+    return 0;
+}
+
+static int parse_set_custom_para(const char* key, const char* strVal)
+{
+    CustomPara_t* pCustome = &g_sdcBurnPara.custom;
+    const unsigned cfgVal  = strVal ? simple_strtoul(strVal, NULL, 0) : 0;
+
+    if (!strcmp(key, "erase_bootloader"))
+    {
+        if (pCustome->bitsMap.eraseBootloader) {
+            goto _key_dup;
+        }
+
+        if (strVal)
+        {
+            pCustome->eraseBootloader = cfgVal;
+            pCustome->bitsMap.eraseBootloader = 1;
+        }
+
+    }
+
+    if (!strcmp(key, "erase_flash"))
+    {
+        if (pCustome->bitsMap.eraseFlash) {
+            goto _key_dup;
+        }
+
+        if (strVal)
+        {
+            pCustome->eraseFlash = cfgVal;
+            pCustome->bitsMap.eraseFlash = 1;
+        }
+
+    }
+
+    if (!strcmp(key, "reboot"))
+    {
+        if (pCustome->bitsMap.rebootAfterBurn) {
+            goto _key_dup;
+        }
+
+        if (strVal)
+        {
+            pCustome->rebootAfterBurn = cfgVal;
+            pCustome->bitsMap.rebootAfterBurn = 1;
+        }
+
+    }
+
+    if (!strcmp(key, "key_overwrite"))
+    {
+        if (pCustome->bitsMap.keyOverwrite) {
+            goto _key_dup;
+        }
+
+        if (strVal)
+        {
+            pCustome->keyOverwrite = cfgVal;
+            pCustome->bitsMap.keyOverwrite = 1;
+        }
+
+    }
+
+    return 0;
+
+_key_dup:
+    err("key %s is duplicated!\n", key);
+    return -1;
+}
+
+#if 0
+int check_custom_para(const CustomPara_t* pCustome)
+{
+    //TODO: not completed!!
+    return 0;
+}
+#endif
+
+static int parse_burn_parts(const char* key, const char* strVal)
+{
+    BurnParts_t* pBurnParts = &g_sdcBurnPara.burnParts;
+
+    if ( !strcmp("burn_num", key) )
+    {
+        if (!strVal) {
+            err("burn_num in burn_parts can't be empty!!");
+            return __LINE__;
+        }
+
+        pBurnParts->burn_num = simple_strtoul(strVal, NULL, 0);
+        if (pBurnParts->burn_num < 1) {
+            err("value for burn_num in burn_parts in invalid\n");
+            return __LINE__;
+        }
+
+        return 0;
+    }
+
+    if (pBurnParts->burn_num < 1) {
+        err("burn_num is not config or 0 ??\n");
+        return __LINE__;
+    }
+
+    {
+        const char burn_partx[] = "burn_partx";
+        const int  validKeyLen = sizeof(burn_partx) - 2;
+        const int totalBurnNum = pBurnParts->burn_num;
+        int burnIndex = 0;
+        char* partName = NULL;
+
+        if (strncmp(burn_partx, key, validKeyLen))
+        {
+            err("error burn part name [%s]\n", key);
+            return __LINE__;
+        }
+
+        burnIndex = key[validKeyLen] - '0';
+        if (!(burnIndex >= 0 && burnIndex < totalBurnNum))
+        {
+            err("Error \"%s\", only burn_part[0~%d] is valid as burn_num is %d\n",
+                key, totalBurnNum - 1, totalBurnNum);
+            return __LINE__;
+        }
+
+        if (pBurnParts->bitsMap4BurnParts & (1U<<burnIndex)) {
+            err("key %s is duplicated in burn_parts\n", key);
+            return __LINE__;
+        }
+        pBurnParts->bitsMap4BurnParts |= 1U<<burnIndex;
+
+        partName = (char*)pBurnParts->burnParts[burnIndex];
+        if (!strVal) {
+            err("value of %s can't empty\n", key);
+            return __LINE__;
+        }
+
+        if (!strcmp("bootloader", strVal)) {
+            err("bootloader not need to configure at burn_parts\n");
+            return __LINE__;
+        }
+
+        strcpy(partName, strVal);
+    }
+
+    return 0;
+}
+
+int check_cfg_burn_parts(const ConfigPara_t* burnPara)
+{
+    const BurnParts_t* pBurnParts = &burnPara->burnParts;
+    const int cfgBurnNum    = pBurnParts->burn_num;
+    const unsigned bitsMap  = pBurnParts->bitsMap4BurnParts;
+    int mediaPathHasCfg = burnPara->burnEx.bitsMap.mediaPath;
+    int i = 0;
+
+
+    for (i = 0; i < cfgBurnNum; i++)
+    {
+        int b = bitsMap & (1U<<i);
+
+        if (!b) {
+            err("Please cfg burn_part%d\n", i);
+            return __LINE__;
+        }
+
+        if (mediaPathHasCfg)
+        {
+            if (!strcmp(pBurnParts->burnParts[i], "media")) {
+                DWN_ERR("media can't cfg in both media_path and burn_parts\n");
+                return __LINE__;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int optimus_aml_sdc_ini_check_set_valid(const char* setName)
+{
+        const char* pName = NULL;
+        int i = 0;
+        int isValid = 0;
+
+        for (; i < TOTAL_SET_NUM && !isValid; ++i)
+        {
+                pName = _iniSets[i];
+                isValid = !strcmp(setName, pName);
+        }
+
+
+        return isValid;
+}
+
+static int optimus_aml_sdc_burn_ini_parse_usr_cfg(const char* setName, const char* keyName, const char* usrKeyVal)
+{
+        int ret = 0;
+
+        if (!strcmp(SET_BURN_PARTS, setName))
+        {
+                return parse_burn_parts(keyName, usrKeyVal);
+        }
+        if (!strcmp(SET_CUSTOM_PARA, setName))
+        {
+                return parse_set_custom_para(keyName, usrKeyVal);
+        }
+        if (!strcmp(SET_BURN_PARA_EX, setName))
+        {
+                return parse_set_burnEx(keyName, usrKeyVal);
+        }
+        if (!strcmp(SET_BURN_DISPLAY, setName))
+        {
+                return parse_set_display(keyName, usrKeyVal);
+        }
+
+        return ret;
+}
+
+int parse_ini_cfg_file(const char* filePath)
+{
+    const int MaxFileSz = OPTIMUS_DOWNLOAD_SLOT_SZ;
+    char* CfgFileLoadAddr = (char*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+    int rcode = 0;
+    const int MaxLines = 1024;//
+    char* lines[MaxLines];
+    int   validLineNum = 0;
+
+    init_config_para(&g_sdcBurnPara);
+
+    validLineNum = parse_ini_file_2_valid_lines(filePath, CfgFileLoadAddr, MaxFileSz, lines);
+    if (!validLineNum) {
+        err("error in parse ini file\n");
+        return __LINE__;
+    }
+
+    rcode = optimus_ini_trans_lines_2_usr_params((const char* *)lines, validLineNum,
+                                                    optimus_aml_sdc_ini_check_set_valid,
+                                                    optimus_aml_sdc_burn_ini_parse_usr_cfg);
+    if (rcode) {
+            err("Fail in get cfg from %s\n", filePath);
+            return __LINE__;
+    }
+
+    rcode = check_cfg_burn_parts(&g_sdcBurnPara);
+    if (rcode) {
+        err("Fail in check burn parts.\n");
+        return __LINE__;
+    }
+
+    print_sdc_burn_para(&g_sdcBurnPara);
+
+    return 0;
+}
+
+#define MYDBG 0
+#if MYDBG
+int do_ini_parser(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int rcode = 0;
+    const char* filePath = "dos_dc_burn.ini";
+
+    //mmc info to ensure sdcard inserted and inited, mmcinfo outer as there U-disk later
+    rcode = run_command("mmcinfo", 0);
+    if (rcode) {
+        err("Fail in init mmc, Does sdcard not plugged in?\n");
+        return __LINE__;
+    }
+
+    if (2 <= argc) {
+        filePath = argv[1];
+    }
+
+    rcode = parse_ini_cfg_file(filePath);
+    if (rcode) {
+        err("error in parse ini file\n");
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+U_BOOT_CMD(
+   ini_parser,      //command name
+   5,               //maxargs
+   0,               //repeatable
+   do_ini_parser,   //command function
+   "Burning a partition from sdmmc ",           //description
+   "Usage: sdc_update partiton image_file_path fileFmt(android sparse, other normal) [,verify_file]\n"   //usage
+);
+#endif//#if MYDBG
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_ini_parser.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_ini_parser.c
new file mode 100644
index 0000000..3d2e753
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_ini_parser.c
@@ -0,0 +1,428 @@
+/*
+ * \file        optimus_ini_parser.c
+ * \brief       ini parsing utilities for sdc burnning
+ *
+ * \version     1.0.0
+ * \date        2013-7-11
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#include "optimus_sdc_burn_i.h"
+
+#define dbg(fmt ...)  //printf("[INI]"fmt)
+#define msg           DWN_MSG
+#define err           DWN_ERR
+
+#define MAX_ARGS    4
+#define is_space_char(c) ('\t' == c || ' ' == c)
+#define is_delimeter(c)  ('[' == c || ']' == c || '=' == c)
+
+#define is_valid_char(c) ( ('0' <= c && '9' >= c) || ('_' == c)\
+                        || ('a' <= c && 'z' >= c) || ('A' <= c && 'Z' >= c) ) \
+                        || ('.' == c) || ('\\' == c) || ('/' == c) || ('-' == c) \
+                        || (':' == c)
+
+static int line_is_valid(const char* line)
+{
+    char c = 0;
+
+    while (c = *line++, c)
+    {
+        int ret = is_delimeter(c) || is_valid_char(c) || is_space_char(c);
+
+        if (!ret) {
+            err("invalid chars! ascii val(0x%x)\n", c);
+            return 0;
+        }
+    }
+
+    return 1;//line is valid
+}
+
+//valid lines type: set or key/value pair
+enum _INI_LINE_TYPE{
+    INI_LINE_TYPE_ERR       = 0,
+    INI_LINE_TYPE_SET          ,
+    INI_LINE_TYPE_KE_VALUE     ,
+};
+
+//this func is used after line_is_valid
+static int line_2_words(char* line, char* argv[], const int maxWords)
+{
+    int nargs = 0;
+    char cur = 0;
+
+    for (cur = *line; is_space_char(cur); cur = *++line) {}
+
+    argv[nargs++] = line;
+    for (;cur = *line, cur; ++line)
+    {
+        if (!is_space_char(cur)) continue;
+        //following do with space character
+
+        *line = 0;
+        for (cur = *++line; is_space_char(cur) && cur; cur = *++line) {}//ignore all space between words
+
+        if (!cur) break;//line ended
+
+        argv[nargs++] = line;
+        if (maxWords <= nargs) {
+            err("too many words num %d, max is %d\n", nargs, maxWords);
+            return 0;
+        }
+    }
+
+    return nargs;
+}
+
+//step1:first loop to seprate buffer to lines
+int _optimus_parse_buf_2_lines(char* pTextBuf, const unsigned textSz,
+                const char* lines[], unsigned* totalLineNum, const unsigned MaxLines)
+{
+        const char* curLine = pTextBuf;
+        char* pTemp = pTextBuf;
+        unsigned i = 0;
+        unsigned lineNum = 0;
+
+        pTextBuf[textSz] = '\0';
+        //loop to seprate buffer to lines
+        for (i = 0; i < textSz ; i++, ++pTemp)
+        {
+                char c = *pTemp;
+                const int isFileEnd = i + 1 >= textSz;
+
+                if (MaxLines <= lineNum) {
+                        DWN_ERR("total line number %d too many, at most %d lines!\n", lineNum, MaxLines);
+                        break;
+                }
+
+                if ('\r' != c && '\n' != c) {
+                        continue;
+                }
+                *pTemp = 0;///
+
+                if (isFileEnd) {
+                        dbg("fileend:curLine=[%s]\n", curLine);
+                        lines[lineNum++] = curLine;
+                        break;//End to read file if file ended
+                }
+
+                if ('\r' == c) //for DOS \r\n mode
+                {
+                        if ('\n' == pTemp[1])
+                        {
+                                lines[lineNum++] = curLine;
+
+                                ++pTemp;
+                                curLine = pTemp + 1;
+                                ++i;//skip '\n' which follows '\r'
+                        }
+                        else
+                        {
+                                DWN_ERR("Syntax error at line %d, DOS end \\r\\n, but \\r%x\n", lineNum + 1, pTemp[1]);
+                                return __LINE__;
+                        }
+                }
+                else if('\n' == c)//for UNIX '\n' mode
+                {
+                        lines[lineNum++] = curLine;
+                        curLine = pTemp + 1;
+                }
+
+                dbg("Get Line[%03d]: %s\n", lineNum, lines[lineNum - 1]);
+        }
+
+        *totalLineNum = lineNum;
+        return 0;
+}
+
+//abandon comments lines and space lines,
+//but not decrease thie line numbers
+int _optimus_abandon_ini_comment_lines(char* lines[], const unsigned lineNum)
+{
+    unsigned lineIndex = 0;
+    for (lineIndex = 0; lineIndex < lineNum ; lineIndex++)
+    {
+        int isSpaceLine = 1;
+        char c = 0;
+        char* thisLine = lines[lineIndex];
+
+        while (c = *thisLine++, c)
+        {
+            //escape space and tab
+            if (is_space_char(c))
+            {
+                continue;
+            }
+
+            isSpaceLine = 0;//no space line
+            //test if frist char is comment delimeter
+            if (';' == c)
+            {
+                lines[lineIndex] = NULL;//invalid comment lines
+            }
+        }
+
+        //if all character is space or tab, also invlalid it
+        if (isSpaceLine)
+        {
+            lines[lineIndex] = NULL;
+        }
+    }
+
+    return 0;
+}
+
+//Return value is the valid line numbers
+//1, Read the whole file content to buffer
+//2, parse file content to lines
+//3, parse each valid line
+int parse_ini_file_2_valid_lines(const char* filePath, char* iniBuf, const unsigned bufSz, char* lines[])
+{
+    const int MaxLines = 1024;//
+    int ret = 0;
+    unsigned fileSz = bufSz;
+    unsigned lineNum = 0;
+    int hFile = -1;
+    unsigned readLen = 0;
+
+    fileSz = (unsigned)do_fat_get_fileSz(filePath);
+    if (!fileSz) {
+            err("File %s not exist in sdcard??\n", filePath);
+            return 0;
+    }
+    if (fileSz >= bufSz) {
+            err("file size 0x%x illegal, > bufSz 0x%x\n", fileSz, bufSz);
+            return 0;
+    }
+    DWN_MSG("ini sz 0x%xB\n", fileSz);
+
+    hFile = do_fat_fopen(filePath);
+    if (hFile < 0) {
+            err("Fail to open file %s\n", filePath);
+            return 0;
+    }
+
+    readLen = do_fat_fread(hFile, (u8*)iniBuf, fileSz);
+    if (readLen != fileSz) {
+            err("failed to load cfg file, want size 0x%x, but 0x%x\n", fileSz, readLen);
+            do_fat_fclose(hFile);
+            return 0;
+    }
+    iniBuf[fileSz] = 0;
+
+    do_fat_fclose(hFile);
+
+    dbg("\\r is 0x%x\t, \\n is 0x%x\n", '\r', '\n');
+
+    //step1:first loop to seprate buffer to lines
+    ret = _optimus_parse_buf_2_lines(iniBuf, fileSz, (const char**)lines, &lineNum, MaxLines);
+    if (ret) {
+            err("Fail to parse buf to lines.ret=%d\n", ret);
+            return 0;
+    }
+
+    //step 2: abandon comment or space lines
+    ret = _optimus_abandon_ini_comment_lines(lines, lineNum);
+
+    return lineNum;
+}
+
+int optimus_ini_trans_lines_2_usr_params(const char* const lines[], const unsigned lineNum,
+                        int (*pCheckSetUseFul)(const char* setName),
+                        int (*pParseCfgVal)(const char* setName, const char* keyName, const char* keyVal))
+{
+        const int MaxWordsALine = 32;
+        char* wordsALine[MaxWordsALine];
+        int ret = 0;
+        int nwords = 0;
+        unsigned i = 0;
+        unsigned lineIndex = 0;
+        const int MaxUsefulSets = 8;
+        const char* cacheSetNames[MaxUsefulSets];
+        const char* CurrentSetName = NULL;
+
+        while (i < MaxUsefulSets) cacheSetNames[i++] = NULL;
+
+        dbg("\nvalid lines:\n");
+        for (lineIndex = 0; lineIndex < lineNum ; lineIndex++)
+        {
+                int lineType = INI_LINE_TYPE_ERR;
+                const char* iniKey = NULL;
+                const char* iniVal = NULL;
+                const char* iniSet = NULL;
+
+                const char* const curLine = lines[lineIndex];
+
+                if (!curLine) continue;//comment or space lines
+
+                if (!line_is_valid(curLine)) //only comment lines can contain non-ASCII letters
+                {
+                        err("line %d contain invalid chars\n", lineIndex + 1);
+                        ret = __LINE__;
+                        break;
+                }
+                dbg("%3d: %s\n",lineIndex, curLine);
+
+                nwords = line_2_words((char*)curLine, wordsALine, MaxWordsALine);
+                if (nwords <= 0) {
+                        ret = __LINE__;
+                        break;
+                }
+                if (nwords > 3) {
+                        err("line %d error: ini support at most 3 words, but %d\n", lineIndex + 1, nwords);
+                        ret = __LINE__;
+                        break;
+                }
+
+                switch (nwords)
+                {
+                        case 3:
+                                {
+                                        if (!strcmp("=", wordsALine[1]))//k/v pair
+                                        {
+                                                lineType = INI_LINE_TYPE_KE_VALUE;
+                                                iniKey = wordsALine[0]; iniVal = wordsALine[2];
+                                                break;
+                                        }
+                                        else if(!strcmp("[" , wordsALine[0]) && !strcmp("]" , wordsALine[2]))//set line
+                                        {
+                                                lineType = INI_LINE_TYPE_SET;
+                                                iniSet = wordsALine[1];
+                                                break;
+                                        }
+                                        else
+                                        {
+                                                lineType = INI_LINE_TYPE_ERR;
+                                                err("Ini syntax error when parse line %d\n", lineIndex + 1);
+                                                ret = __LINE__; break;
+                                        }
+                                }
+                                break;
+
+                        case 2:
+                                {
+                                        if ('[' == wordsALine[0][0]) //set like "[set ]" or "[ set]"
+                                        {
+                                                if (!strcmp("]", wordsALine[1]))
+                                                {
+                                                        lineType = INI_LINE_TYPE_SET;
+                                                        iniSet = wordsALine[0] + 1;
+                                                        break;
+                                                }
+                                                else if (']' == wordsALine[1][strlen(wordsALine[1]) - 1] && !strcmp("[", wordsALine[0]))
+                                                {
+                                                        lineType = INI_LINE_TYPE_SET;
+                                                        iniSet = wordsALine[1];
+                                                        wordsALine[1][strlen(wordsALine[1]) - 1] = 0;
+                                                        break;
+                                                }
+                                        }
+                                        else if(!strcmp("=", wordsALine[1]))//k/v pair like "key = "
+                                        {
+                                                lineType = INI_LINE_TYPE_KE_VALUE;
+                                                iniKey = wordsALine[0];
+                                                break;
+                                        }
+                                        else if('=' == wordsALine[1][0])//k/v pair like "key =v" or "key= v"
+                                        {
+                                                lineType = INI_LINE_TYPE_KE_VALUE;
+                                                iniKey = wordsALine[0];
+                                                iniVal = wordsALine[1] + 1;
+                                                break;
+                                        }
+                                        else if ('=' == wordsALine[0][strlen(wordsALine[0]) - 1])//k/v pair like "key= v"
+                                        {
+                                                wordsALine[0][strlen(wordsALine[0]) - 1] = 0;
+                                                lineType = INI_LINE_TYPE_KE_VALUE;
+                                                iniKey = wordsALine[0];
+                                                iniVal = wordsALine[1];
+                                        }
+                                }
+                                break;
+
+                        case 1:
+                                {
+                                        char* word = wordsALine[0];
+                                        char firstChar = word[0];
+                                        char lastChar  = word[strlen(word) - 1];
+
+                                        if ('[' == firstChar && ']' == lastChar)
+                                        {
+                                                lineType = INI_LINE_TYPE_SET;
+                                                iniSet = word + 1;
+                                                word[strlen(word) - 1] = 0;
+                                                break;
+                                        }
+                                        else
+                                        {
+                                                char c = 0;
+
+                                                iniKey = word;
+                                                while (c = *word++, c)
+                                                {
+                                                        if ('=' == c)//TODO: not assert only delimeter in a line yet
+                                                        {
+                                                                lineType = INI_LINE_TYPE_KE_VALUE;
+                                                                *--word = 0;
+                                                                iniVal = ++word;
+                                                                iniVal = *iniVal ? iniVal : NULL;
+                                                                break;
+                                                        }
+                                                }
+                                        }
+                                }
+                                break;
+
+                        default:
+                                break;
+                }
+
+                if (INI_LINE_TYPE_SET == lineType)
+                {
+                        int setIndex = 0;
+
+                        dbg("set line, set is %s\n", iniSet);
+                        CurrentSetName = NULL;
+                        if ( !pCheckSetUseFul(iniSet) ) {//the set don't care
+                                continue;
+                        }
+
+                        //Check the useful set name is not duplicated!
+                        for (setIndex = 0; setIndex < MaxUsefulSets; ++setIndex) {
+                                const char* pset = cacheSetNames[setIndex];
+                                if (!pset) {
+                                        CurrentSetName = cacheSetNames[setIndex] = iniSet;
+                                        break;
+                                }
+                                if (!strcmp(pset, iniSet)) {
+                                        ret = __LINE__;
+                                        goto _set_duplicated;
+                                }
+                        }
+                }
+                else if(INI_LINE_TYPE_KE_VALUE == lineType && CurrentSetName)
+                {
+                        dbg("k/v line, key (%s), val (%s)\n", iniKey, iniVal);
+
+                       ret = pParseCfgVal(CurrentSetName, iniKey, iniVal);
+                       if (ret) {
+                               goto _line_err;
+                       }
+                }
+        }
+
+        return ret;
+
+_line_err:
+        err("Fail to parse line %d\n", lineIndex + 1);
+        return ret;
+
+_set_duplicated:
+        err("line %d err:set is duplicated!!\n", lineIndex + 1);
+        return ret;
+}
+
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_led.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_led.c
new file mode 100644
index 0000000..8c86235
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_led.c
@@ -0,0 +1,155 @@
+/*
+ * \file        optimus_led.c
+ * \brief       use led to indicate burning states
+ *
+ * \version     1.0.0
+ * \date        2013/11/9
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+#include "../v2_burning_i.h"
+#include "optimus_led.h"
+
+#define OPTIMUS_LED_SRC_IS_PWM      1//pwm type led
+
+typedef enum{
+    OPTIMUS_LED_STATE_INVALID   = 0XF0  ,
+    OPTIMUS_LED_STATE_RED               ,//Burning failed if stay on this state
+    OPTIMUS_LED_STATE_GREEN             ,
+    OPTIMUS_LED_STATE_SLOW_FLICKERING   ,
+    OPTIMUS_LED_STATE_FAST_FLICKERING   ,//fast flickering to catch the eye that it's burning successful
+
+}OptimusLedStates_e;
+
+#if OPTIMUS_LED_SRC_IS_PWM
+#define PWM_CHANNEL_INDEX   5
+
+static int optimus_pwm_led_show_state(OptimusLedStates_e ledState)
+{
+    int rc = 0;
+    int PwmHighLevelPeriod = 0;
+    int PwmLowLevelPeriod  = 0;
+    char cmdStr[64];
+
+    switch (ledState)
+    {
+        case OPTIMUS_LED_STATE_SLOW_FLICKERING:
+            {
+                PwmHighLevelPeriod = 0xfffe;
+                PwmLowLevelPeriod  = PwmHighLevelPeriod;
+
+                sprintf(cmdStr, "pwm config %d %d %d", PWM_CHANNEL_INDEX, PwmHighLevelPeriod, PwmLowLevelPeriod);
+            }
+            break;
+
+        case OPTIMUS_LED_STATE_FAST_FLICKERING:
+            {
+                PwmHighLevelPeriod = 0x2000;
+                PwmLowLevelPeriod  = PwmHighLevelPeriod;
+
+                sprintf(cmdStr, "pwm config %d %d %d", PWM_CHANNEL_INDEX, PwmHighLevelPeriod, PwmLowLevelPeriod);
+            }
+            break;
+
+        case OPTIMUS_LED_STATE_GREEN:
+            {
+                PwmHighLevelPeriod = 0;
+                PwmLowLevelPeriod  = 0xffffu;//always low level
+
+                sprintf(cmdStr, "pwm config %d %d %d", PWM_CHANNEL_INDEX, PwmHighLevelPeriod, PwmLowLevelPeriod);
+            }
+            break;
+
+        case OPTIMUS_LED_STATE_RED:
+            {
+                PwmHighLevelPeriod = 0xffffu;//always high level
+                PwmLowLevelPeriod  = 0;
+
+                sprintf(cmdStr, "pwm config %d %d %d", PWM_CHANNEL_INDEX, PwmHighLevelPeriod, PwmLowLevelPeriod);
+            }
+            break;
+        default:
+            DWN_ERR("invlaid pwm state %d\n", ledState);
+            return __LINE__;
+    }
+
+    rc = run_command(cmdStr, 0);
+    if (rc) {
+        DWN_ERR("Fail in run_cmd[%s], ret=%d\n", cmdStr, rc);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+int optimus_led_open(int ledType)
+{
+    const int clkSel    = 0;
+    const int clkDiv    = 0x7f;
+    const int pinIndex  = 0;
+    char cmdStr[64];
+    int rc = 0;
+
+    sprintf(cmdStr, "pwm enable %d %d %d %d", PWM_CHANNEL_INDEX, pinIndex, clkSel, clkDiv);
+    rc = run_command(cmdStr, 0);
+    if (rc) {
+        DWN_ERR("Fail in run_cmd[%s], ret=%d\n", cmdStr, rc);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+int optimus_led_close(void)
+{
+    int rc = 0;
+    char cmdStr[64];
+
+    sprintf(cmdStr, "pwm disable %d", PWM_CHANNEL_INDEX);
+    rc = run_command(cmdStr, 0);
+
+    return rc;
+}
+
+int optimus_led_show_in_process_of_burning(void)
+{
+    return optimus_pwm_led_show_state(OPTIMUS_LED_STATE_SLOW_FLICKERING);
+}
+
+int optimus_led_show_burning_success(void)
+{
+    optimus_pwm_led_show_state(OPTIMUS_LED_STATE_FAST_FLICKERING);
+
+    return 0;
+}
+
+int optimus_led_show_burning_failure(void)
+{
+    return optimus_pwm_led_show_state(OPTIMUS_LED_STATE_RED);
+}
+
+#else
+int optimus_led_open(int ledType)
+{
+    return 0;
+}
+
+int optimus_led_close(void)
+{
+    return 0;
+}
+
+int optimus_led_show_in_process_of_burning(void)
+{
+    return 0;
+}
+
+int optimus_led_show_burning_success(void)
+{
+    return 0;
+}
+#endif// #if OPTIMUS_LED_SRC_IS_PWM
+
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_led.h b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_led.h
new file mode 100644
index 0000000..40ae2c3
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_led.h
@@ -0,0 +1,40 @@
+/*
+ * \file        optimus_led.h
+ * \brief       show burning states by LED
+ *              current supported LED source is PWM, other type not supported yet!
+ *
+ * \version     1.0.0
+ * \date        2013/11/9
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic Inc.. All Rights Reserved.
+ *
+ */
+#ifndef __OPTIMUS_LED_H__
+#define __OPTIMUS_LED_H__
+
+#define LED_TYPE_PWM        0xabcd
+
+#if CONFIG_SD_BURNING_SUPPORT_LED
+
+int optimus_led_open(int ledType);//open the led for show burning states
+
+int optimus_led_close(void);
+
+int optimus_led_show_in_process_of_burning(void);
+
+int optimus_led_show_burning_success(void);
+
+int optimus_led_show_burning_failure(void);
+
+#else
+#define optimus_led_open(ledType)                   0
+#define optimus_led_close()                         0
+#define optimus_led_show_in_process_of_burning()    do{}while(0)
+#define optimus_led_show_burning_success()          do{}while(0)
+#define optimus_led_show_burning_failure()          do{}while(0)
+
+#endif// #if CONFIG_SD_BURNING_SUPPORT_LED
+
+#endif//ifndef __OPTIMUS_LED_H__
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn.c
new file mode 100644
index 0000000..ad3cf77
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn.c
@@ -0,0 +1,779 @@
+/*
+ * \file        optimus_sdc_burn.c
+ * \brief       burning itself from Pheripheral tf/sdmmc card
+ *
+ * \version     1.0.0
+ * \date        2013-7-11
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#include "optimus_sdc_burn_i.h"
+#include "optimus_led.h"
+
+static int is_bootloader_old(void)
+{
+    int sdc_boot = is_tpl_loaded_from_ext_sdmmc();
+
+    return !sdc_boot;
+}
+
+int get_burn_parts_from_img(HIMAGE hImg, ConfigPara_t* pcfgPara)
+{
+    BurnParts_t* pburnPartsCfg = &pcfgPara->burnParts;
+    int i = 0;
+    int ret = 0;
+    int burnNum = 0;
+    const int totalItemNum = get_total_itemnr(hImg);
+
+    for (i = 0; i < totalItemNum; i++)
+    {
+        const char* main_type = NULL;
+        const char* sub_type  = NULL;
+
+        ret = get_item_name(hImg, i, &main_type, &sub_type);
+        if (ret) {
+            DWN_ERR("Exception:fail to get item name!\n");
+            return __LINE__;
+        }
+
+        if (!strcmp("PARTITION", main_type))
+        {
+            char* partName = pburnPartsCfg->burnParts[burnNum];
+
+            if (!strcmp("bootloader", sub_type)) continue;
+            if (!strcmp(AML_SYS_RECOVERY_PART, sub_type))
+            {
+                    if (OPTIMUS_WORK_MODE_SYS_RECOVERY == optimus_work_mode_get()) continue;
+            }
+
+            strcpy(partName, sub_type);
+            pburnPartsCfg->bitsMap4BurnParts |= 1U<<burnNum;
+            burnNum += 1;
+        }
+    }
+
+    if (burnNum)
+    {
+        pburnPartsCfg->burn_num = burnNum;
+
+        ret = check_cfg_burn_parts(pcfgPara);
+        if (ret) {
+            DWN_ERR("Fail in check burn parts\n");
+            return __LINE__;
+        }
+        print_burn_parts_para(pburnPartsCfg);
+    }
+
+    return OPT_DOWN_OK;
+}
+
+int optimus_verify_partition(const char* partName, HIMAGE hImg, char* _errInfo)
+{
+#define MaxSz (64 - 7) //verify file to at most 64B to corresponding to USB burn, strlen("verify ") == 7
+
+    char* argv[4];
+    int ret = 0;
+    HIMAGEITEM hImgItem = NULL;
+    int imgItemSz = 0;
+    char CmdVerify[MaxSz + 7] = {0};
+
+    hImgItem = image_item_open(hImg, "VERIFY", partName);
+    if (!hImgItem) {
+        DWN_ERR("Fail to open verify file for part (%s)\n", partName);
+        return ITEM_NOT_EXIST;
+    }
+
+    imgItemSz = (int)image_item_get_size(hImgItem);
+    if (imgItemSz > MaxSz || !imgItemSz) {
+        DWN_ERR("verify file size %d for part %s invalid, max is %d\n", imgItemSz, partName, MaxSz);
+        ret = __LINE__; goto _finish;
+    }
+    DWN_DBG("item sz %u\n", imgItemSz);
+
+    ret = image_item_read(hImg, hImgItem, CmdVerify, imgItemSz);
+    if (ret) {
+        DWN_ERR("Fail to read verify item for part %s\n", partName);
+        goto _finish;
+    }
+    CmdVerify[imgItemSz] = 0;
+    DWN_DBG("verify[%s]\n", CmdVerify);
+
+    argv[0] = "verify";
+    ret = cli_simple_parse_line(CmdVerify, argv + 1);
+    if (ret != 2) {
+        DWN_ERR("verify cmd argc must be 2, but %d\n", ret);
+        return __LINE__;
+    }
+
+    ret = optimus_media_download_verify(3, argv, _errInfo);
+    if (ret) {
+        DWN_ERR("Fail when verify\n");
+        return __LINE__;
+    }
+
+_finish:
+    image_item_close(hImgItem);
+    return ret;
+}
+
+//.NeedVerify: Try to get verify file if .NeedVerify == 1
+static int optimus_burn_one_partition(const char* partName, HIMAGE hImg, __hdle hUiProgress, int NeedVerify)
+{
+    int rcode = 0;
+    s64 imgItemSz       = 0;
+    s64 leftItemSz      = 0;
+    u32 thisReadLen     = 0;
+    __hdle hImgItem     = NULL;
+    char* downTransBuf  = NULL;//get buffer from optimus_buffer_manager
+    const unsigned ItemReadBufSz = OPTIMUS_DOWNLOAD_SLOT_SZ;//read this size from image item each time
+    unsigned sequenceNo = 0;
+    const char* fileFmt = NULL;
+    /*static */char _errInfo[512];
+    unsigned itemSizeNotAligned = 0;
+
+    printf("\n");
+    DWN_MSG("=====>To burn part [%s]\n", partName);
+    optimus_progress_ui_printf("Burning part[%s]\n", partName);
+    hImgItem = image_item_open(hImg, "PARTITION", partName);
+    if (!hImgItem) {
+        DWN_ERR("Fail to open item for part (%s)\n", partName);
+        return __LINE__;
+    }
+
+    imgItemSz = leftItemSz = image_item_get_size(hImgItem);
+    if (!imgItemSz) {
+        DWN_ERR("image size is 0 , image of part (%s) not exist ?\n", partName);
+        return __LINE__;
+    }
+
+    fileFmt = (IMAGE_ITEM_TYPE_SPARSE == image_item_get_type(hImgItem)) ? "sparse" : "normal";
+
+    itemSizeNotAligned = image_item_get_first_cluster_size(hImg, hImgItem);
+    leftItemSz        -= itemSizeNotAligned;
+    rcode = sdc_burn_buf_manager_init(partName, imgItemSz, fileFmt, itemSizeNotAligned);
+    if (rcode) {
+        DWN_ERR("fail in sdc_burn_buf_manager_init, rcode %d\n", rcode);
+        return __LINE__;
+    }
+
+    //for each loop:
+    //1, get buffer from buffer_manager,
+    //2, read item data to buffer,
+    //3, report data ready to buffer_manager
+    for (; leftItemSz > 0; leftItemSz -= thisReadLen, sequenceNo++)
+    {
+        thisReadLen = leftItemSz > ItemReadBufSz ? ItemReadBufSz: (u32)leftItemSz;
+
+        rcode = optimus_buf_manager_get_buf_for_bulk_transfer(&downTransBuf, thisReadLen, sequenceNo, _errInfo);
+        if (rcode) {
+            DWN_ERR("fail in get buf, msg[%s]\n", _errInfo);
+            goto _finish;
+        }
+
+		//If the item head is not alinged to FAT cluster, Read it firstly to speed up mmc read
+        if (itemSizeNotAligned && !sequenceNo)
+        {
+            DWN_MSG("itemSizeNotAligned 0x%x\n", itemSizeNotAligned);
+            rcode = image_item_read(hImg, hImgItem, downTransBuf - itemSizeNotAligned, itemSizeNotAligned);
+            if (rcode) {
+                DWN_ERR("fail in read data from item,rcode %d, len 0x%x, sequenceNo %d\n", rcode, itemSizeNotAligned, sequenceNo);
+                goto _finish;
+            }
+        }
+
+        rcode = image_item_read(hImg, hImgItem, downTransBuf, thisReadLen);
+        if (rcode) {
+            DWN_ERR("fail in read data from item,rcode %d\n", rcode);
+            goto _finish;
+        }
+
+        rcode = optimus_buf_manager_report_transfer_complete(thisReadLen, _errInfo);
+        if (rcode) {
+            DWN_ERR("fail in report data ready, rcode %d\n", rcode);
+            goto _finish;
+        }
+        if (hUiProgress)optimus_progress_ui_update_by_bytes(hUiProgress, thisReadLen) ;
+    }
+
+    DWN_DBG("BURN part %s %s!\n", partName, leftItemSz ? "FAILED" : "SUCCESS");
+
+_finish:
+    image_item_close(hImgItem);
+
+    if (rcode) {
+        DWN_ERR("Fail to burn part(%s) with in format (%s) before verify\n", partName, fileFmt);
+        optimus_progress_ui_printf("Failed at burn part[%s] befor VERIFY\n", partName);
+        return rcode;
+    }
+
+#if 1
+    if (!NeedVerify) {
+            return rcode;
+    }
+    rcode = optimus_verify_partition(partName, hImg, _errInfo);
+    if (ITEM_NOT_EXIST == rcode)
+    {
+        printf("WRN:part(%s) NOT verified\n", partName);
+        return 0;
+    }
+    if (rcode) {
+        printf("Fail in verify part(%s)\n", partName);
+        optimus_progress_ui_printf("Failed at VERIFY part[%s]\n", partName);
+        return __LINE__;
+    }
+#endif//#fi 0
+
+    return rcode;
+}
+
+int optimus_sdc_burn_partitions(ConfigPara_t* pCfgPara, HIMAGE hImg, __hdle hUiProgress, int NeedVerify)
+{
+    BurnParts_t* cfgParts = &pCfgPara->burnParts;
+    int burnNum       = cfgParts->burn_num;
+    int i = 0;
+    int rcode = 0;
+
+    //update burn_parts para if burnNum is 0, i.e, not configured
+    if (!burnNum)
+    {
+        rcode = get_burn_parts_from_img(hImg, pCfgPara);
+        if (rcode) {
+            DWN_ERR("Fail to get burn parts from image\n");
+            return __LINE__;
+        }
+        burnNum = cfgParts->burn_num;
+        DWN_DBG("Data part num %d\n", burnNum);
+    }
+    if (!burnNum) {
+        DWN_ERR("Data part num is 0!!\n");
+        return __LINE__;
+    }
+
+    for (i = 0; i < burnNum; i++)
+    {
+        const char* partName = cfgParts->burnParts[i];
+
+        rcode = optimus_burn_one_partition(partName, hImg, hUiProgress, NeedVerify);
+        if (rcode) {
+            DWN_ERR("Fail in burn part %s\n", partName);
+            return __LINE__;
+        }
+    }
+
+    return rcode;
+}
+
+//not need to verify as not config ??
+int optimus_sdc_burn_media_partition(const char* mediaImgPath, const char* verifyFile)
+{
+    //TODO:change configure to 'partName = image' and work it using cmd 'sdc_update'
+    return optimus_burn_partition_image("media", mediaImgPath, "normal", verifyFile, 0);
+}
+
+int optimus_burn_bootlader(HIMAGE hImg)
+{
+    int rcode = 0;
+    int NeedVerify = 1;
+
+    rcode = optimus_burn_one_partition("bootloader", hImg, NULL, NeedVerify);
+    if (rcode) {
+        DWN_ERR("Fail when burn bootloader\n");
+        return __LINE__;
+    }
+
+    return rcode;
+}
+
+//flag, 0 is burn completed, else burn failed
+int optimus_report_burn_complete_sta(int isFailed, int rebootAfterBurn)
+{
+    if (isFailed)
+    {
+        DWN_MSG("=====Burn Failed!!!!!\n");
+        DWN_MSG("PLS long-press power key to shut down\n");
+        optimus_led_show_burning_failure();
+        while (1) {
+            /*if(ctrlc())run_command("reset", 0);*/
+        }
+
+        return __LINE__;
+    }
+
+    DWN_MSG("======sdc burn SUCCESS.\n");
+    optimus_led_show_burning_success();
+    optimus_burn_complete(rebootAfterBurn ? rebootAfterBurn : OPTIMUS_BURN_COMPLETE__POWEROFF_AFTER_POWERKEY);//set complete flag and poweroff if burn successful
+    return 0;
+}
+
+int optimus_sdc_burn_dtb_load(HIMAGE hImg)
+{
+    s64 itemSz = 0;
+    HIMAGEITEM hImgItem = NULL;
+    int rc = 0;
+    const char* partName = "dtb";
+    u64 partBaseOffset = OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+    unsigned char* dtbTransferBuf     = (unsigned char*)partBaseOffset;
+
+    //meson1.dtb but not meson.dtb for m8 compatible
+    hImgItem = image_item_open(hImg, partName, "meson1");
+    if (!hImgItem) {
+        DWN_WRN("Fail to open item [meson,%s]\n", partName);
+        return ITEM_NOT_EXIST;
+    }
+
+    itemSz = image_item_get_size(hImgItem);
+    if (!itemSz) {
+        DWN_ERR("Item size 0\n");
+        image_item_close(hImgItem); return __LINE__;
+    }
+
+#if 1
+    const unsigned itemSzNotAligned = image_item_get_first_cluster_size(hImg, hImgItem);
+    if (itemSzNotAligned /*& 0x7*/) {//Not Aligned 8bytes/64bits, mmc dma read will failed
+        DWN_MSG("align 4 mmc read...\t");//Assert Make 'DDR' buffer addr align 8
+        dtbTransferBuf += image_get_cluster_size(hImg) - itemSzNotAligned;
+        partBaseOffset += image_get_cluster_size(hImg) - itemSzNotAligned;
+    }
+#endif
+
+    rc = image_item_read(hImg, hImgItem, dtbTransferBuf, (unsigned)itemSz);
+    if (rc) {
+        DWN_ERR("Failed at item read, rc = %d\n", rc);
+        image_item_close(hImgItem); return __LINE__;
+    }
+    image_item_close(hImgItem);
+
+    rc = optimus_parse_img_download_info(partName, itemSz, "normal", "mem", partBaseOffset);
+    if (rc) {
+        DWN_ERR("Failed in init down info\n"); return __LINE__;
+    }
+
+    {
+        unsigned wrLen = 0;
+        char errInfo[512];
+
+        wrLen = optimus_download_img_data(dtbTransferBuf, (unsigned)itemSz, errInfo);
+        rc = (wrLen == itemSz) ? 0 : __LINE__;
+    }
+
+    return rc;
+}
+
+#if CONFIG_SUPPORT_SDC_KEYBURN
+//fetch the keys names which need be burned from item[conf, keys]
+static int sdc_burn_get_user_key_names(HIMAGE hImg, const char* **pKeysName, unsigned* keysNum)
+{
+        int rc = 0;
+        HIMAGEITEM hImgItem = NULL;
+        unsigned itemSz = 0;
+        unsigned char* thisReadBuf     = (unsigned char*)OPTIMUS_SPARSE_IMG_FILL_VAL_BUF;//This buf is not used and not need reuse when burning keys
+        const unsigned thisReadBufSz   = (OPTIMUS_SPARSE_IMG_FILL_BUF_SZ >> 1);
+        const char* *keysName = (const char**)(thisReadBuf + thisReadBufSz);
+
+        hImgItem = image_item_open(hImg, "conf", "keys");
+        if (!hImgItem) {
+                DWN_ERR("Fail to open keys.conf\n");
+                return ITEM_NOT_EXIST;
+        }
+
+        itemSz = (unsigned)image_item_get_size(hImgItem);
+        if (!itemSz) {
+                DWN_ERR("Item size 0\n");
+                image_item_close(hImgItem); return __LINE__;
+        }
+
+        const unsigned itemSzNotAligned = image_item_get_first_cluster_size(hImg, hImgItem);
+        if (itemSzNotAligned /*& 0x7*/) {//Not Aligned 8bytes/64bits, mmc dma read will failed
+            DWN_MSG("align 4 mmc read...\t");//Assert Make 'DDR' buffer addr align 8
+            thisReadBuf += image_get_cluster_size(hImg);
+            thisReadBuf -= itemSzNotAligned;
+        }
+        rc = image_item_read(hImg, hImgItem, thisReadBuf, itemSz);
+        if (rc) {
+                DWN_ERR("Failed at item read, rc = %d\n", rc);
+                image_item_close(hImgItem); return __LINE__;
+        }
+        image_item_close(hImgItem);
+
+        if (itemSz >= thisReadBufSz) {
+                DWN_ERR("itemSz(0x%x) of keys.conf too large, > max 0x%x.\n", itemSz, thisReadBufSz);
+                return __LINE__;
+        }
+
+        rc = _optimus_parse_buf_2_lines((char*)thisReadBuf, itemSz, keysName, keysNum, 16);
+        if (rc) {
+                DWN_ERR("Fail in parse buf_2_lines\n");
+                return __LINE__;
+        }
+
+        rc = _optimus_abandon_ini_comment_lines((char**)keysName, *keysNum);
+
+        *pKeysName = keysName;
+        return rc;
+}
+
+//check key is burned yet --> need  keyOverWrite -->can_write
+static int sdc_check_key_need_to_burn(const char* keyName, const int keyOverWrite)
+{
+        int rc = 0;
+        char _cmd[96];
+
+        sprintf(_cmd, "aml_key_burn misc is_burned %s", keyName);
+        rc = run_command(_cmd, 0);
+        if (rc < 0) {
+                DWN_ERR("Fail in check key is_burned\n");
+                return -__LINE__;
+        }
+        DWN_MSG("key[%s] is %s burned\n", keyName, rc ? "NOT" : "DO");
+        if (rc) {//not success
+                return 1;//need burn as not burned yet.
+        }
+        if (!keyOverWrite) {
+                DWN_MSG("User choose not to overwrite the key\n");
+                return 0;
+        }
+
+        sprintf(_cmd, "aml_key_burn misc can_write %s", keyName);
+        rc = run_command(_cmd, 0);
+        if (rc) {
+                DWN_ERR("Fail in check key[%s] is_burned\n", keyName);
+                return -__LINE__;
+        }
+        DWN_MSG("key[%s] is %s can_write\n", keyName, rc ? "NOT" : "DO");
+        return !rc;
+}
+
+//burn the amlogic keys like USB_Burning_Tool
+static int sdc_burn_aml_keys(HIMAGE hImg, const int keyOverWrite)
+{
+        int rc = 0;
+        const char* *keysName = NULL;
+        unsigned keysNum = 0;
+        const char** pCurKeysName = NULL;
+        unsigned index = 0;
+
+        rc = run_command("aml_key_burn probe vfat sdc", 0);
+        if (rc) {
+                DWN_ERR("Fail in probe for aml_key_burn\n");
+                return __LINE__;
+        }
+
+        {
+                unsigned random32 = 0;
+                unsigned seed = 0;
+                char cmd[96];
+
+                random32 = seed = get_timer(0) + 12345;//FIXME:make it random
+                /*random32 = random_u32(seed);*/
+                DWN_MSG("random value is 0x%x\n", random32);
+                sprintf(cmd, "aml_key_burn init 0x%x", random32);
+
+                rc = run_command(cmd, 0);
+                if (rc) {
+                        DWN_ERR("Fail in cmd[%s]\n", cmd);
+                        return __LINE__;
+                }
+        }
+
+        rc = sdc_burn_get_user_key_names(hImg, &keysName, &keysNum);
+        if (ITEM_NOT_EXIST != rc && rc) {
+                DWN_ERR("Fail to parse keys.conf, rc =%d\n", rc);
+                return __LINE__;
+        }
+        DWN_MSG("keys.conf:\n");
+        for (index = 0; index < keysNum; ++index)printf("\tkey[%d]\t%s\n", index, keysName[index]) ;
+
+        rc =  optimus_sdc_keysprovider_init();
+        if (rc) {
+                DWN_ERR("Fail in optimus_sdc_keysprovider_init\n");
+                return __LINE__;
+        }
+
+        pCurKeysName = keysName;
+        for (index = 0; index < keysNum; ++index)
+        {
+                const char* const keyName = *pCurKeysName++;
+
+                if (!keyName) continue;
+                DWN_MSG("\n");
+                DWN_MSG("Now to burn key <---- [%s] ----> %d \n", keyName, index);
+                rc = sdc_check_key_need_to_burn(keyName, keyOverWrite);
+                if (rc < 0) {
+                        DWN_ERR("Fail when when check stauts for key(%s)\n", keyName);
+                        /*return __LINE__;*/
+                }
+                if (!rc) continue;//not need to burn this key
+
+                //0, init the key license parser
+                const void* pHdle = NULL;
+                rc = optimus_sdc_keysprovider_open(keyName, &pHdle);
+                if (rc) {
+                        DWN_ERR("Fail in init license for key[%s]\n", keyName);
+                        return __LINE__;
+                }
+
+                //1,using cmd_keysprovider to read a key to memory
+                u8* keyValue = (u8*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+                unsigned keySz = OPTIMUS_DOWNLOAD_SLOT_SZ;//buffer size
+                rc = optimus_sdc_keysprovider_get_keyval(pHdle, keyValue, &keySz);
+                if (rc) {
+                        DWN_ERR("Fail to get value for key[%s]\n", keyName);
+                        return __LINE__;
+                }
+
+                //3, burn the key
+                rc = optimus_keysburn_onekey(keyName, (u8*)keyValue, keySz);
+                if (rc) {
+                        DWN_ERR("Fail in burn the key[%s] at addr=%p, sz=%d\n", keyName, keyValue, keySz);
+                        return __LINE__;
+                }
+
+                //3,report burn result to cmd_keysprovider
+                rc = optimus_sdc_keysprovider_update_license(pHdle);
+                if (rc) {
+                        DWN_ERR("Fail in update license for key[%s]\n", keyName);
+                        return __LINE__;
+                }
+        }
+
+        rc = optimus_sdc_keysprovider_exit();
+        if (rc) {
+                DWN_ERR("Fail in optimus_sdc_keysprovider_exit\n");
+                return __LINE__;
+        }
+
+        rc = run_command("aml_key_burn uninit", 0);
+        if (rc) {
+                DWN_ERR("Fail in uninit for aml_key_burn\n");
+                return __LINE__;
+        }
+
+        return 0;
+}
+#else
+#define sdc_burn_aml_keys(fmt...)     0
+#endif// #if CONFIG_SUPPORT_SDC_KEYBURN
+
+int optimus_burn_with_cfg_file(const char* cfgFile)
+{
+    extern ConfigPara_t g_sdcBurnPara ;
+
+    int ret = 0;
+    HIMAGE hImg = NULL;
+    ConfigPara_t* pSdcCfgPara = &g_sdcBurnPara;
+    const char* pkgPath = pSdcCfgPara->burnEx.pkgPath;
+    __hdle hUiProgress = NULL;
+
+    ret = parse_ini_cfg_file(cfgFile);
+    if (ret) {
+        DWN_ERR("Fail to parse file %s\n", cfgFile);
+        ret = __LINE__; goto _finish;
+    }
+
+    if (pSdcCfgPara->custom.eraseBootloader && strcmp("1", getenv("usb_update")))
+    {
+        if (is_bootloader_old())
+        {
+            DWN_MSG("To erase OLD bootloader !\n");
+            ret = optimus_erase_bootloader("sdc");
+            if (ret) {
+                DWN_ERR("Fail to erase bootloader\n");
+                ret = __LINE__; goto _finish;
+            }
+
+#if defined(CONFIG_VIDEO_AMLLCD)
+            //axp to low power off LCD, no-charging
+            DWN_MSG("To close LCD\n");
+            ret = run_command("video dev disable", 0);
+            if (ret) {
+                printf("Fail to close back light\n");
+                /*return __LINE__;*/
+            }
+#endif// #if defined(CONFIG_VIDEO_AMLLCD)
+
+            DWN_MSG("Reset to load NEW uboot from ext-mmc!\n");
+            optimus_reset(OPTIMUS_BURN_COMPLETE__REBOOT_SDC_BURN);
+            return __LINE__;//should never reach here!!
+        }
+    }
+
+    if (OPTIMUS_WORK_MODE_SDC_PRODUCE == optimus_work_mode_get()) //led not depend on image res, can init early
+    {
+        if (optimus_led_open(LED_TYPE_PWM)) {
+            DWN_ERR("Fail to open led for sdc_produce\n");
+            return __LINE__;
+        }
+        optimus_led_show_in_process_of_burning();
+    }
+
+    hImg = image_open("mmc", "0", "1", pkgPath);
+    if (!hImg) {
+        DWN_ERR("Fail to open image %s\n", pkgPath);
+        ret = __LINE__; goto _finish;
+    }
+
+    //update dtb for burning drivers
+    ret = optimus_sdc_burn_dtb_load(hImg);
+    if (ITEM_NOT_EXIST != ret && ret) {
+        DWN_ERR("Fail in load dtb for sdc_burn\n");
+        ret = __LINE__; goto _finish;
+    }
+
+    if (video_res_prepare_for_upgrade(hImg)) {
+        DWN_ERR("Fail when prepare bm res or init video for upgrade\n");
+        image_close(hImg);
+        return __LINE__;
+    }
+    show_logo_to_report_burning();
+
+    hUiProgress = optimus_progress_ui_request_for_sdc_burn();
+    if (!hUiProgress) {
+        DWN_ERR("request progress handle failed!\n");
+        ret = __LINE__; goto _finish;
+    }
+    optimus_progress_ui_direct_update_progress(hUiProgress, UPGRADE_STEPS_AFTER_IMAGE_OPEN_OK);
+
+    int hasBootloader = 0;
+    u64 datapartsSz = optimus_img_decoder_get_data_parts_size(hImg, &hasBootloader);
+
+    int eraseFlag = pSdcCfgPara->custom.eraseFlash;
+    if (!datapartsSz) {
+            eraseFlag = 0;
+            DWN_MSG("Disable erase as data parts size is 0\n");
+    }
+    ret = optimus_storage_init(eraseFlag);
+    if (ret) {
+        DWN_ERR("Fail to init stoarge for sdc burn\n");
+        return __LINE__;
+    }
+
+    optimus_progress_ui_direct_update_progress(hUiProgress, UPGRADE_STEPS_AFTER_DISK_INIT_OK);
+
+    if (datapartsSz)
+    {
+            ret = optimus_progress_ui_set_smart_mode(hUiProgress, datapartsSz,
+                            UPGRADE_STEPS_FOR_BURN_DATA_PARTS_IN_PKG(!pSdcCfgPara->burnEx.bitsMap.mediaPath));
+            if (ret) {
+                    DWN_ERR("Fail to set smart mode\n");
+                    ret = __LINE__; goto _finish;
+            }
+
+            ret = optimus_sdc_burn_partitions(pSdcCfgPara, hImg, hUiProgress, 1);
+            if (ret) {
+                    DWN_ERR("Fail when burn partitions\n");
+                    ret = __LINE__; goto _finish;
+            }
+    }
+
+    if (pSdcCfgPara->burnEx.bitsMap.mediaPath) //burn media image
+    {
+        const char* mediaPath = pSdcCfgPara->burnEx.mediaPath;
+
+        ret = optimus_sdc_burn_media_partition(mediaPath, NULL);//no progress bar info if have partition image not in package
+        if (ret) {
+            DWN_ERR("Fail to burn media partition with image %s\n", mediaPath);
+            optimus_storage_exit();
+            ret = __LINE__;goto _finish;
+        }
+    }
+    optimus_progress_ui_direct_update_progress(hUiProgress, UPGRADE_STPES_AFTER_BURN_DATA_PARTS_OK);
+
+    //TO burn nandkey/securekey/efusekey
+    ret = sdc_burn_aml_keys(hImg, pSdcCfgPara->custom.keyOverwrite);
+    if (ret) {
+            DWN_ERR("Fail in sdc_burn_aml_keys\n");
+            ret = __LINE__;goto _finish;
+    }
+
+#if 1
+    if (hasBootloader)
+    {//burn bootloader
+            ret = optimus_burn_bootlader(hImg);
+            if (ret) {
+                    DWN_ERR("Fail in burn bootloader\n");
+                    goto _finish;
+            }
+            else
+            {//update bootloader ENV only when bootloader image is burned
+                    ret = optimus_set_burn_complete_flag();
+                    if (ret) {
+                            DWN_ERR("Fail in set_burn_complete_flag\n");
+                            ret = __LINE__; goto _finish;
+                    }
+            }
+    }
+#endif
+    optimus_progress_ui_direct_update_progress(hUiProgress, UPGRADE_STEPS_AFTER_BURN_BOOTLOADER_OK);
+
+_finish:
+    image_close(hImg);
+    optimus_progress_ui_report_upgrade_stat(hUiProgress, !ret);
+    optimus_report_burn_complete_sta(ret, pSdcCfgPara->custom.rebootAfterBurn);
+    optimus_progress_ui_release(hUiProgress);
+    //optimus_storage_exit();//temporary not exit storage driver when failed as may continue burning after burn
+    return ret;
+}
+
+int optimus_burn_package_in_sdmmc(const char* sdc_cfg_file)
+{
+    int rcode = 0;
+
+#if 0//this asserted by 'run update' and 'aml_check_is_ready_for_sdc_produce'
+    rcode = do_fat_get_fileSz(sdc_cfg_file);
+    if (!rcode) {
+        printf("The [%s] not exist in bootable mmc card\n", sdc_cfg_file);
+        return __LINE__;
+    }
+#endif//#if 0
+
+    rcode = optimus_device_probe("mmc", "0");
+    if (rcode) {
+        DWN_ERR("Fail to detect device mmc 0\n");
+        return __LINE__;
+    }
+
+    setenv("usb_update","0");
+    rcode = optimus_burn_with_cfg_file(sdc_cfg_file);
+
+    return rcode;
+}
+
+int do_sdc_burn(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int rcode = 0;
+    const char* sdc_cfg_file = argv[1];
+
+    if (argc < 2 ) {
+        return CMD_RET_USAGE;
+    }
+
+    if ( !aml_check_is_ready_for_sdc_produce() ) {
+        DWN_DBG("Not ready\n");
+        return __LINE__;
+    }
+
+    optimus_work_mode_set(OPTIMUS_WORK_MODE_SDC_UPDATE);
+    show_logo_to_report_burning();//indicate enter flow of burning! when 'run update'
+    if (optimus_led_open(LED_TYPE_PWM)) {
+        DWN_ERR("Fail to open led for burn\n");
+        return __LINE__;
+    }
+    optimus_led_show_in_process_of_burning();
+
+    rcode = optimus_burn_package_in_sdmmc(sdc_cfg_file);
+
+    return rcode;
+}
+
+U_BOOT_CMD(
+   sdc_burn,      //command name
+   5,               //maxargs
+   0,               //repeatable
+   do_sdc_burn,   //command function
+   "Burning with amlogic format package in sdmmc ",           //description
+   "argv: [sdc_burn_cfg_file]\n"//usage
+   "    -aml_sdc_burn.ini is usually used configure file\n"
+);
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn_i.h b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn_i.h
new file mode 100644
index 0000000..33ac76b
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn_i.h
@@ -0,0 +1,136 @@
+/*
+ * \file        optimus_sdc_burn_i.h
+ * \brief       internal struct types and interfaces for sdc burn
+ *
+ * \version     1.0.0
+ * \date        2013-7-12
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __OPTIMUS_SDC_BURN_I_H__
+#define __OPTIMUS_SDC_BURN_I_H__
+
+#include "../v2_burning_i.h"
+#include <fat.h>
+#include <part.h>
+
+#define ITEM_NOT_EXIST   0x55
+
+typedef struct _burnEx{
+    char        pkgPath[128];
+    char        mediaPath[128];
+    struct {
+        unsigned pkgPath    : 1;
+        unsigned mediaPath  : 1;
+        unsigned reserv     : 32 - 2;
+    }bitsMap;
+}BurnEx_t;
+
+typedef struct _customPara{
+    int         eraseBootloader;
+    int         eraseFlash;
+    int         rebootAfterBurn;
+    int         keyOverwrite;
+    struct{
+        unsigned eraseBootloader    : 1;
+        unsigned eraseFlash         : 1;
+        unsigned rebootAfterBurn    : 1;
+        unsigned keyOverwrite       : 1;
+        unsigned resev              : 32 - 4;
+    }bitsMap;
+}CustomPara_t;
+
+#define MAX_BURN_PARTS      (32)
+#define PART_NAME_LEN_MAX   (32)
+
+typedef struct _burnParts{
+    int         burn_num;
+    char        burnParts[MAX_BURN_PARTS][PART_NAME_LEN_MAX];
+    unsigned    bitsMap4BurnParts;
+}BurnParts_t;
+
+typedef struct _burnDisplay{
+    char*       outputmode;
+    unsigned    bitsMap4Display;
+}BurnDisplay_t;
+
+typedef struct _ConfigPara{
+    BurnParts_t     burnParts;
+    CustomPara_t    custom;
+    BurnEx_t        burnEx;
+    BurnDisplay_t   display;
+    struct {
+        unsigned    burnParts : 1;
+        unsigned    custom    : 1;
+        unsigned    burnEx    : 1;
+        unsigned    display   : 1;
+        unsigned    reserv    : 32 - 4;
+    }setsBitMap;
+}ConfigPara_t;
+
+//ini parser
+int _optimus_parse_buf_2_lines(char* pTextBuf, const unsigned textSz, const char* lines[],
+                unsigned* totalLineNum, const unsigned MaxLines);//parse text context to linces delimitted by (\r)\n
+int parse_ini_file_2_valid_lines(const char* filePath, char* iniBuf, const unsigned bufSz, char* lines[]);
+int _optimus_abandon_ini_comment_lines(char* lines[], const unsigned lineNum);
+int optimus_ini_trans_lines_2_usr_params(const char* const lines[], const unsigned lineNum,
+                        int (*pCheckSetUseFul)(const char* setName),
+                        int (*pParseCfgVal)(const char* setName, const char* keyName, const char* keyVal));
+
+int parse_ini_cfg_file(const char* filePath);
+
+int check_cfg_burn_parts(const ConfigPara_t* burnPara);
+int print_burn_parts_para(const BurnParts_t* pBurnParts);
+
+int sdc_burn_verify(const char* verifyFile);
+
+//burn a partition with a image file
+int optimus_burn_partition_image(const char* partName, const char* imgItemPath, const char* fileFmt, const char* verifyFile, const unsigned itemSizeNotAligned);
+
+int sdc_burn_buf_manager_init(const char* partName, s64 imgItemSz, const char* fileFmt,
+                            const unsigned itemSizeNotAligned /* if item offset 3 and bytepercluste 4k, then it's 4k -3 */);
+
+int get_burn_parts_from_img(HIMAGE hImg, ConfigPara_t* pcfg);
+
+//declare for aml_sysrecovery
+int optimus_sdc_burn_partitions(ConfigPara_t* pCfgPara, HIMAGE hImg, __hdle hUiProgress, int needVerify);
+int optimus_sdc_burn_dtb_load(HIMAGE hImg);
+
+int optimus_burn_bootlader(HIMAGE hImg);
+
+int optimus_report_burn_complete_sta(int isFailed, int rebootAfterBurn);
+
+
+int optimus_sdc_burn_switch_to_extmmc(void);
+
+int optimus_save_loaded_dtb_to_flash(void);
+
+//Followings are For burn keys only
+int optimus_sdc_keysprovider_init(void);
+int optimus_sdc_keysprovider_exit(void);
+int optimus_sdc_keysprovider_open(const char* keyName, const void** pHdle);
+int optimus_sdc_keysprovider_get_keyval(const void* pHdle, u8* pBuf, unsigned* keySz);
+int optimus_sdc_keysprovider_update_license(const void* pHdle);
+
+int optimus_keysburn_onekey(const char* keyName, u8* keyVal, unsigned keyValLen);
+
+
+//for fat fs
+long do_fat_fopen(const char *filename);
+long do_fat_fread(int fd, __u8 *buffer, unsigned long maxsize);
+void do_fat_fclose(int fd);
+s64 do_fat_get_fileSz(const char* imgItemPath);
+int do_fat_fseek(int fd, const __u64 offset, int wherehence);
+unsigned do_fat_get_bytesperclust(int fd);
+int optimus_device_probe(const char* interface, const char* inPart);
+int optimus_fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+
+//<0 if failed, 0 is normal, 1 is sparse, others reserved
+int do_fat_get_file_format(const char* imgFilePath, unsigned char* pbuf, const unsigned bufSz);
+
+extern int aml_check_is_ready_for_sdc_produce(void);
+
+#endif//#ifndef __OPTIMUS_SDC_BURN_I_H__
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_update.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_update.c
new file mode 100644
index 0000000..9e2aa6b
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_update.c
@@ -0,0 +1,334 @@
+/*
+ * \file        optimus_sdc_update.c
+ * \brief       sdc_update command to burn a parition image from mmc
+ *              this update based on the burner is latest: (uboot for burnner can run from peripherals such as sdmmc/usb)
+ *
+ * \version     1.0.0
+ * \date        2014-9-15
+ * \author      Sam.Wu <yihui.wu@amlogic.com>
+ *				Chunyu.Song <chunyu.song@amlogic.com>
+ * Copyright (c) 2014 Amlogic. All Rights Reserved.
+ *
+ */
+#include "optimus_sdc_burn_i.h"
+
+typedef int __hFileHdl;
+
+#define BURN_DBG 0
+#if BURN_DBG
+#define SDC_DBG(fmt...) printf(fmt)
+#else
+#define SDC_DBG(fmt...)
+#endif//if BURN_DBG
+
+#define SDC_MSG         DWN_MSG
+#define SDC_ERR         DWN_ERR
+
+static char _errInfo[512] = "";
+
+//default is mmc 0:1, i.e, part 1 of first registered mmc device
+int optimus_device_probe(const char* interface, const char* inPart)
+{
+	block_dev_desc_t *dev_desc=NULL;
+	int dev=0;
+	int part=1;
+	char *ep;
+
+	dev = (int)simple_strtoul(inPart, &ep, 16);
+	dev_desc = get_dev((char*)interface,dev);
+	if (dev_desc == NULL) {
+		puts("\n** Invalid boot device **\n");
+		return 1;
+	}
+	if (*ep) {
+		if (*ep != ':') {
+			puts("\n** Invalid boot device, use `dev[:part]' **\n");
+			return 1;
+		}
+		part = (int)simple_strtoul(++ep, NULL, 16);
+	}
+	if (optimus_fat_register_device(dev_desc,part) != 0) {
+		printf("\n** Unable to use %s %d:%d for device probe **\n",
+			interface, dev, part);
+		return 1;
+	}
+
+    return 0;
+}
+
+
+__hFileHdl opt_file_open(const char* imgItemPath)
+{
+    __hFileHdl hFile = 0;
+
+#if 0
+    //FIXME: Check this probe needed!!!
+    if (device_probe("mmc", "0")) {
+        SDC_ERR("Fail to probe mmc 0");
+        return -1;
+    }
+#endif//#if 0
+
+    hFile = do_fat_fopen(imgItemPath);
+
+    return hFile;
+}
+
+int opt_file_read(__hFileHdl hFile, u8* buffer, const unsigned size)
+{
+    unsigned readSz = do_fat_fread(hFile, buffer, size);
+    if (readSz != size) {
+        SDC_ERR("Want to read 0x%x, but 0x%x\n", size, readSz);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+int opt_file_close(__hFileHdl hFile)
+{
+    do_fat_fclose(hFile);
+
+    return 0;
+}
+
+//part size 0 if failed
+s64 storage_get_partition_size_in_byte(const char* partName)
+{
+    int ret = 0;
+    u64 size = 0;
+
+#if 1
+    ret = store_get_partititon_size((u8*)partName, &size);
+    if (ret) {
+        SDC_ERR("Fail to get size for part %s\n", partName);
+        return 0;
+    }
+    size <<= 9;//trans sector to byte
+#endif
+
+    return size;
+}
+
+//0 is OK, others failed
+int sdc_burn_buf_manager_init(const char* partName, s64 imgItemSz, const char* fileFmt,
+        const unsigned itemSizeNotAligned /* if item offset 3 and bytepercluste 4k, then it's 4k -3 */)
+{
+    int rcode = 0;
+    s64 partCapInByte   = 0;
+    const char* destMediaType = "store";
+    const u64 partBaseOffset = 0;
+
+    if (strcmp("bootloader", partName)) //TODO:bootloader size can't get yet!
+    {
+        partCapInByte = storage_get_partition_size_in_byte(partName);
+        if (partCapInByte < imgItemSz || !partCapInByte) {
+            SDC_ERR("partCapInByte 0x[%x, %x] < imgItemSz 0x[%x, %x]\n",
+                    (u32)(partCapInByte>>32), (u32)partCapInByte, (u32)(imgItemSz>>32), (u32)imgItemSz);
+            return __LINE__;
+        }
+    }
+
+    rcode = optimus_parse_img_download_info(partName, imgItemSz, fileFmt, destMediaType, partBaseOffset);
+    if (rcode) {
+        SDC_ERR("fail in init down info, rcode %d\n", rcode);
+        return __LINE__;
+    }
+    rcode = optimus_buf_manager_tplcmd_init(destMediaType, partName, 0, fileFmt, imgItemSz, 0, itemSizeNotAligned);
+    if (rcode) {
+        SDC_ERR("Fail in buf manager init\n");
+        return __LINE__;
+    }
+
+    return rcode;
+}
+
+int sdc_burn_verify(const char* verifyFile)
+{
+    int rcode = 0;
+    char* argv[8];
+    char  verifyCmd[64] = "";
+    char cmdBuf[64];
+    char *usb_update = getenv("usb_update");
+
+    run_command("mmcinfo", 0);
+    if (!strcmp(usb_update,"1")) {
+          sprintf(cmdBuf, "%s 0x%p %s",  "fatload usb 0 ", verifyCmd, verifyFile);
+    }
+    else{
+          sprintf(cmdBuf, "%s 0x%p %s",  "fatload mmc 0 ", verifyCmd, verifyFile);
+    }
+    SDC_DBG("To run cmd [%s]\n", cmdBuf);
+    rcode = run_command(cmdBuf, 0);
+    if (rcode < 0) {
+        SDC_ERR("Fail in cmd fatload\n");
+        return __LINE__;
+    }
+    SDC_MSG("cmd verify[%s]\n", verifyCmd);
+
+    rcode = cli_simple_parse_line(verifyCmd, argv + 1);
+    if (rcode != 2) {
+        SDC_ERR("verify cmd argc must be 2, but %d\n", rcode);
+        return __LINE__;
+    }
+    argv[0] = "verify";
+
+    rcode = optimus_media_download_verify(3, argv, _errInfo);
+    if (rcode) {
+        SDC_ERR("Fail to verify\n");
+        return __LINE__;
+    }
+    return 0;
+}
+
+int optimus_burn_partition_image(const char* partName, const char* imgItemPath, const char* fileFmt, const char* verifyFile, const unsigned itemSizeNotAligned)
+{
+    int rcode = 0;
+    s64 imgItemSz       = 0;
+    s64 leftItemSz      = 0;
+    u32 thisReadLen     = 0;
+    __hFileHdl hImgItem     = 0;
+    char* downTransBuf  = NULL;//get buffer from optimus_buffer_manager
+    const unsigned ItemReadBufSz = OPTIMUS_DOWNLOAD_SLOT_SZ;//read this size from image item each time
+    unsigned sequenceNo = 0;
+
+    imgItemSz = leftItemSz = do_fat_get_fileSz(imgItemPath);
+    if (!imgItemSz) {
+        SDC_ERR("Fail to get image %s from mmc\n", imgItemPath);
+        return __LINE__;
+    }
+
+    rcode = sdc_burn_buf_manager_init(partName, imgItemSz, fileFmt, itemSizeNotAligned);
+    if (rcode) {
+        SDC_ERR("fail in sdc_burn_buf_manager_init, rcode %d\n", rcode);
+        return __LINE__;
+    }
+
+    hImgItem = opt_file_open(imgItemPath);
+    if (hImgItem < 0) {
+        SDC_ERR("Fail to open the item %s\n", imgItemPath);
+        return __LINE__;
+    }
+
+    /*optimus_progress_init((u32)(imgItemSz>>32), (u32)imgItemSz, 0, 100);*/
+
+    //for each loop:
+    //1, get buffer from buffer_manager,
+    //2, read item data to buffer,
+    //3, report data ready to buffer_manager
+    for (; leftItemSz > 0; leftItemSz -= thisReadLen, sequenceNo++)
+    {
+        thisReadLen = leftItemSz > ItemReadBufSz ? ItemReadBufSz: (u32)leftItemSz;
+
+        rcode = optimus_buf_manager_get_buf_for_bulk_transfer(&downTransBuf, thisReadLen, sequenceNo, _errInfo);
+        if (rcode) {
+            SDC_ERR("fail in get buf, msg[%s]\n", _errInfo);
+            goto _finish;
+        }
+
+        rcode = opt_file_read(hImgItem, (u8*)downTransBuf, thisReadLen);
+        if (rcode) {
+            SDC_ERR("fail in read data from item,rcode %d\n", rcode);
+            goto _finish;
+        }
+
+        rcode = optimus_buf_manager_report_transfer_complete(thisReadLen, _errInfo);
+        if (rcode) {
+            SDC_ERR("fail in report data ready, rcode %d\n", rcode);
+            goto _finish;
+        }
+
+        /*optimus_update_progress(thisReadLen);//report burning steps*/
+    }
+
+    if (leftItemSz <= 0) {
+        printf("BURN %s to part %s OK!\n", imgItemPath, partName);
+    }
+
+_finish:
+    opt_file_close(hImgItem);
+
+    if (!rcode && verifyFile)
+    {
+        rcode = sdc_burn_verify(verifyFile);
+    }
+
+    printf("=====>Burn part %s in fmt %s %s<======\n\n", partName, fileFmt, rcode ? "FAILED!!": "OK");
+    return rcode;
+}
+
+//step 1: get script file size, and get script file contents
+//step 2: read image file
+//"Usage: sdc_update partiton image_file_path [imgFmt, verifyFile]\n"   //usage
+int do_sdc_update(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int rcode = 0;
+    const char* partName    = argv[1];
+    const char* imgItemPath = argv[2];
+    const char* fileFmt     = argc > 3 ? argv[3] : NULL;
+    const char* verifyFile  = argc > 4 ? argv[4] : NULL;
+
+    setenv("usb_update","0");
+#if BURN_DBG
+    printf("argc %d, %s, %s\n", argc, argv[0], argv[1]);
+    if (argc < 3)
+    {
+        partName    = "system";
+        imgItemPath = "rec.img";
+        fileFmt     = "normal";
+        verifyFile  = "recovery.verify";
+    }
+#else
+	if (argc < 3) {
+        cmd_usage(cmdtp);
+		return __LINE__;
+	}
+#endif//#if BURN_DBG
+
+    //mmc info to ensure sdcard inserted and inited
+    rcode = run_command("mmcinfo", 0);
+    if (rcode) {
+        SDC_ERR("Fail in init mmc, Does sdcard not plugged in?\n");
+        return __LINE__;
+    }
+
+    rcode = optimus_device_probe("mmc", "0");
+    if (rcode) {
+        SDC_ERR("Fail to detect device mmc 0\n");
+        return __LINE__;
+    }
+
+    if (!fileFmt)
+    {
+        rcode = do_fat_get_file_format(imgItemPath, (u8*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR, (8*1024));
+        if (rcode < 0) {
+            SDC_ERR("Fail when parse file format\n");
+            return __LINE__;
+        }
+        fileFmt = rcode ? "sparse" : "normal";
+    }
+
+    rcode = optimus_burn_partition_image(partName, imgItemPath, fileFmt, verifyFile, 0);
+    if (rcode) {
+        SDC_ERR("Fail to burn partition (%s) with image file (%s) in format (%s)\n", partName, imgItemPath, fileFmt);
+    }
+
+    return rcode;
+}
+
+U_BOOT_CMD(
+   sdc_update,      //command name
+   5,               //maxargs
+   0,               //repeatable
+   do_sdc_update,   //command function
+   "Burning a partition with image file in sdmmc card",           //description
+   "    argv: <part_name> <image_file_path> <[,fileFmt]> <[,verify_file]> \n"   //usage
+   "    - <fileFmt> parameter is optional, if you know it you can specify it.\n"
+   "        for Android, system.img and data.img is \"sparse\" format, other is \"normal\"\n"   //usage
+   "    - <verify_file> parameter is optional, if you have it you can specify it.\n"
+   "    - e.g. \n"
+   "        to burn partition boot with boot.img of mmc 0 : \"sdc_update boot boot.img\"\n"   //usage
+   "        to burn partition system with system.img of mmc 0 : \"sdc_update system system.img\"\n"   //usage
+);
+
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/optimus_key_burn.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/optimus_key_burn.c
new file mode 100644
index 0000000..88871b3
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/optimus_key_burn.c
@@ -0,0 +1,299 @@
+/*
+ * \file        optimus_key_burn.c
+ * \brief       burning keys from sdcard like update.exe
+ *
+ * \version     1.0.0
+ * \date        2014/12/25
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2014 Amlogic. All Rights Reserved.
+ *
+ */
+
+/*
+ *
+ * This cmd [aml_key_burn] aim to burn keys like 'update.exe', and mainly used for myself.
+ * like update.exe, the key in here is single and not need to sperate
+ * e.g, for comparison, here to burn a hdcp key using aml_key_burn and update.exe
+ *     0. update.exe identify .                                 <-----> aml_key_burn probe vfat sdc
+ *     1. update.exe mwrite meson.dtb mem dtb normal .          <-----> aml_key_burn meson_dtb meson.dtb
+ *     2, update.exe bulkcmd "key init 0x1234"                  <-----> aml_key_burn init 0x1234
+ *     3, update.exe mwrite key hdcp normal hdcp308.val         <-----> aml_key_burn burn hdcp hdcp308.val
+ *              other keys
+ *     4, update.exe bulkcmd "key uninit"                       <-----> aml_key_burn uninit
+ *
+ */
+#include "../optimus_sdc_burn_i.h"
+#include <amlogic/keyunify.h>
+
+#define _AML_KEY_ERR(fmt...)    sprintf(_errInfo, fmt), DWN_ERR(_errInfo)
+
+static char _errInfo[512] = "";
+
+
+typedef enum{
+        DEV_FILE_FMT_VFAT       = 0xee,
+        DEV_FILE_FMT_EXT2
+}DevFileFmt_e;
+
+typedef enum{
+        DEV_INTF_EXT_SDMMC      = 0xdd,
+        DEV_INTF_EXT_UDISK            ,
+}DevIntf_e;
+
+static struct optKeyInfo_s{
+        DevFileFmt_e            fileFmt;
+        DevIntf_e               intf;//interface
+} _optKeyInfo;
+/*
+ * <aml_key_burn probe> device_format interface
+ */
+static int do_opt_keysburn_probe(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int rc = 0;
+        const char* device_format = argv[2];//vfat
+        const char* device_interf = argv[3];//sdc/udisk
+
+        if (4 > argc) {
+                _AML_KEY_ERR("failed:argc: %d < 4\n", argc);
+                return __LINE__;
+        }
+        if (!strcmp(device_format, "vfat")) {
+                _optKeyInfo.fileFmt = DEV_FILE_FMT_VFAT;
+        }
+        else{
+                _AML_KEY_ERR("failed:device_format %s unsupported yet\n", device_format);
+                return __LINE__;
+        }
+
+        if (!strcmp("sdc", device_interf))
+        {
+                static int _mmcprobe = 0;
+
+                if (!_mmcprobe)
+                {
+                        rc = run_command("mmcinfo", 0);
+                        if (rc) {
+                                _AML_KEY_ERR("failed: in mmcinfo\n");
+                                return __LINE__;
+                        }
+                        rc = optimus_device_probe("mmc", "0");
+                        if (rc) {
+                                _AML_KEY_ERR("Fail to detect device mmc 0\n");
+                                return __LINE__;
+                        }
+                        _mmcprobe = 1;
+                }
+                _optKeyInfo.intf = DEV_INTF_EXT_SDMMC;
+        }
+        else if(!strcmp("udisk", device_interf))
+        {
+                static int _udiskProbe = 0;
+
+                if (!_udiskProbe)
+                {
+                        rc = run_command("usb start 0", 0);
+                        if (rc) {
+                                _AML_KEY_ERR("Fail in mmcinfo\n");
+                                return __LINE__;
+                        }
+                        rc = optimus_device_probe("usb", "0");
+                        if (rc) {
+                                _AML_KEY_ERR("Fail to detect device mmc 0\n");
+                                return __LINE__;
+                        }
+                        _udiskProbe = 1;
+                }
+                _optKeyInfo.intf = DEV_INTF_EXT_UDISK;
+        }
+        else{
+                _AML_KEY_ERR("device_interf %s unsupported\n", device_interf);
+                return -__LINE__;
+        }
+
+        return rc;
+}
+
+static int do_opt_keysburn_init(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int rc = 0;
+
+        if (3 > argc)
+        {
+                cmd_usage(cmdtp);
+                return __LINE__;
+        }
+        rc = v2_key_command(argc, argv, _errInfo);
+        if (rc) {
+                DWN_ERR("Fail to init key driver.\n");
+                return -__LINE__;
+        }
+
+        return rc;
+}
+
+static int do_opt_keysburn_uninit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int rc = 0;
+
+        rc = v2_key_command(argc, argv, _errInfo);
+        if (rc) {
+                DWN_ERR("Fail to init key driver.\n");
+                return -__LINE__;
+        }
+        return rc;
+}
+
+static int do_opt_keysburn_misc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int rc = 0;
+
+        --argc, ++argv;//skip the misc subcmd
+        rc = v2_key_command(argc, argv, _errInfo);
+        if (rc < 0) {
+                return -__LINE__;
+        }
+
+        return rc;
+}
+
+static int optimus_read_keyfile_2_mem(const char* filePath, u8* buf, unsigned* keyValLen)
+{
+        int rc = 0;
+        unsigned keySz = 0;
+
+        if (DEV_FILE_FMT_VFAT == _optKeyInfo.fileFmt)
+        {
+                long hFile = -1;
+                unsigned readSz = 0;
+
+#if 1//FIXME: remove this mmcinfo
+                /*rc = run_command("mmcinfo 0", 0);*/
+                rc = optimus_sdc_burn_switch_to_extmmc();
+                if (rc) {
+                        DWN_ERR("Fail in mmcinfo\n");
+                        return __LINE__;
+                }
+#endif//
+                keySz = (unsigned)do_fat_get_fileSz(filePath);//can support both sdc and udisk
+                if (!keySz) {
+                        DWN_ERR("size is 0 of file [%s]\n", filePath);
+                        return __LINE__;
+                }
+
+                hFile = do_fat_fopen(filePath);
+                if (hFile < 0) {
+                        DWN_ERR("Fail to open file[%s]\n", filePath);
+                        return __LINE__;
+                }
+
+                readSz = do_fat_fread(hFile, buf, keySz);
+                if (readSz != keySz) {
+                        DWN_ERR("Want read %d bytes, but %d\n", keySz, readSz);
+                        return __LINE__;
+                }
+
+                do_fat_fclose(hFile);
+        }
+
+        *keyValLen = keySz;
+        return rc;
+}
+
+int optimus_keysburn_onekey(const char* keyName, u8* keyVal, unsigned keyValLen)
+{
+        int rc = 0;
+        unsigned wrLen = 0;
+
+        DWN_MSG("keyName[%s], keyValAddr=%p,len=%d\n", keyName, keyVal, keyValLen);
+        wrLen = v2_key_burn(keyName, keyVal, keyValLen, _errInfo);
+        DWN_MSG("writeLen=====%d\n", wrLen);
+        rc = wrLen != keyValLen;
+        DWN_MSG("%s in burn key[%s]\n", rc ? "failed" : "success", keyName);
+
+        return rc;
+}
+
+static int do_opt_keysburn_burn(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int rc = 0;
+        const char* keyName = argv[2];
+        u8* keyVal = (u8*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+        unsigned keyValLen = 0;
+
+        if (4 > argc) {
+                _AML_KEY_ERR("argc=%d < 4\n", argc);
+                return __LINE__;
+        }
+        if (argc > 4)
+        {
+                keyVal          = (u8*)simple_strtoul(argv[3], NULL, 16);
+                keyValLen       = simple_strtoul(argv[4], NULL, 0);
+        }
+        else//The key is file in the specified device
+        {
+                const char* filePath = argv[3];
+
+                rc = optimus_read_keyfile_2_mem(filePath, keyVal, &keyValLen);
+                if (rc) {
+                        _AML_KEY_ERR("Fail to read file[%s]\n", filePath);
+                        return __LINE__;
+                }
+        }
+        rc = optimus_keysburn_onekey(keyName, keyVal, keyValLen);
+
+        return rc;
+}
+
+
+static cmd_tbl_t cmd_opt_key_burn[] = {
+	U_BOOT_CMD_MKENT(probe,       4, 0, do_opt_keysburn_probe, "", ""),
+	U_BOOT_CMD_MKENT(init,        3, 0, do_opt_keysburn_init, "", ""),
+	U_BOOT_CMD_MKENT(uninit,      2, 0, do_opt_keysburn_uninit, "", ""),
+	U_BOOT_CMD_MKENT(burn,        5, 0, do_opt_keysburn_burn, "", ""),
+	U_BOOT_CMD_MKENT(misc,        6, 0, do_opt_keysburn_misc, "", ""),
+};
+
+static int do_aml_key_burn(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int rc = 0;
+	cmd_tbl_t *c;
+
+        sprintf(_errInfo, "success");
+	c = find_cmd_tbl(argv[1], cmd_opt_key_burn, ARRAY_SIZE(cmd_opt_key_burn));
+
+        if (!c) {
+                DWN_ERR("Can't find subcmd[%s]\n", argv[1]);
+		return 1;
+        }
+
+        rc = c->cmd(cmdtp, flag, argc, argv);
+        DWN_MSG("[key]%s\n", _errInfo);
+        if (rc < 0) {
+                DWN_ERR("Fail in cmd[%s %s].ret=%d\n", argv[1], argv[2], rc);
+                return -__LINE__;
+        }
+        rc = strncmp("success", _errInfo, 7);
+
+        return rc;
+}
+
+U_BOOT_CMD(
+   aml_key_burn,      //command name
+   6,               //maxargs
+   0,               //repeatable
+   do_aml_key_burn,   //command function
+   "Burning keys from external device(sdmmc/udisk/memory) other than usb device",           //description
+   "argv: aml_key_burn ...\n"//usage
+   "<probe> file_system interface --- init external device/interface\n"//usage
+   "    - e.g.1, for fat sdcard  : <aml_key_burn probe> vfat sdc\n"
+   "    - e.g.2, for fat udisk   : <aml_key_burn probe> vfat udisk\n"
+   "\n"
+   "<init/uninit> random_value --- init nandkey/efusekey driver\n"//usage
+   "\n"
+   "<burn> keyName keyFilePath(keyBufAddr keySize) --- init external device/interface\n"//usage
+   "    - e.g.1, write hdcp key with hdcp308.key from sdcard: <aml_key_burn burn> hdcp hdcp308.key\n"
+   "    - e.g.2, write hdcp key in addr 0x200000 : <aml_key_burn burn> hdcp 0x200000 308\n"
+   "\n"
+);
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_bootPart_license.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_bootPart_license.c
new file mode 100644
index 0000000..3324a16
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_bootPart_license.c
@@ -0,0 +1,239 @@
+/*
+ * \file        sdc_bootPart_license.c
+ * \brief
+ *
+ * \version     1.0.0
+ * \date        2015/3/10
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "../optimus_sdc_burn_i.h"
+#include "sdc_bootPart_license.h"
+#include <crc.h>
+
+COMPILE_TYPE_CHK(AML_BOOT_PART_KEY_HEAD_SZ == sizeof(BootPartKeyInf_head_t), _aa1);
+COMPILE_TYPE_CHK(AML_BOOT_PART_KEY_ITEM_SZ == sizeof(BootPartKeyInf_Item_t), _aa2);
+
+#define _OPT_BOOT_PART_LIC_INFO_LOADADDR        (OPTIMUS_DOWNLOAD_SPARSE_INFO_FOR_VERIFY)
+#define _pOptBootPartLicHeadInf                 (BootPartKeyInf_head_t*)(_OPT_BOOT_PART_LIC_INFO_LOADADDR)
+
+//Load boot part license info from external emmc to memory
+//As "mmc read" is slow, I load it from external mmc only once
+int optimus_sdc_bootPart_lic_download(void)
+{
+        const unsigned maxLen = 2U<<20;//
+        const unsigned firstReadLen = 2U<<10;//2K
+        const char* _cmdStr =  "mmc read 1 0x%x, 0x%x 0x%x";
+        BootPartKeyInf_head_t* pBootPartKeyInfHead      = _pOptBootPartLicHeadInf;
+        char _cmdBuf[96];
+        int rc = 0;
+
+//1, Read from _OPT_BOOT_PART_LIC_INFO_LOADADDR
+        rc = run_command("mmcinfo", 0);
+        if (rc) {
+                DWN_ERR("Fail to init external sdcard\n");
+                return __LINE__;
+        }
+
+        memset(pBootPartKeyInfHead, 0, AML_BOOT_PART_KEY_HEAD_SZ + AML_BOOT_PART_KEY_ITEM_SZ * 64);
+        sprintf(_cmdBuf, _cmdStr, _OPT_BOOT_PART_LIC_INFO_LOADADDR, AML_BOOT_PART_KEY_HEAD_OFFSET, firstReadLen);
+        DWN_MSG("cmd[%s]\n", _cmdBuf);
+        rc = run_command(_cmdBuf, 0);
+        if (rc) {
+                DWN_ERR("Fail in cmd[%s]\n", _cmdBuf);
+                return __LINE__;
+        }
+
+        rc = (AML_BOOT_PART_KEY_HEAD_VERSION == pBootPartKeyInfHead->version)
+                && (AML_BOOT_PART_KEY_HEAD_MAGIC == pBootPartKeyInfHead->magic);
+        if (!rc)
+        {
+                DWN_MSG("Ver[0x%x] or magic[0x%8x] error\n",
+                                pBootPartKeyInfHead->version, pBootPartKeyInfHead->magic);
+                //Create the image header
+                pBootPartKeyInfHead->magic      = AML_BOOT_PART_KEY_HEAD_MAGIC;
+                pBootPartKeyInfHead->version    = AML_BOOT_PART_KEY_HEAD_VERSION;
+                pBootPartKeyInfHead->alignSz    = AML_BOOT_PART_ALIGN_SZ;
+                pBootPartKeyInfHead->imgSz      = sizeof(BootPartKeyInf_head_t);
+                pBootPartKeyInfHead->imgItemNum = 0;
+
+                return 0;
+        }
+        const unsigned totalLen = pBootPartKeyInfHead->imgSz;
+        if (totalLen > maxLen) {
+                DWN_ERR("totalLen=0x%x > max=0x%x\n", totalLen, maxLen);
+                return __LINE__;
+        }
+
+        DWN_MSG("totalLen=0x%x\n", totalLen);
+        const unsigned genCrc = crc32(0, (u8*)&pBootPartKeyInfHead->magic,
+                        totalLen - sizeof(unsigned int));
+        if (genCrc != pBootPartKeyInfHead->hcrc) {
+                DWN_ERR("genCrc(0x%x) != savedCrc(0x%x), pls clear the card using tool\n",
+                                genCrc, pBootPartKeyInfHead->hcrc);
+                return __LINE__;
+        }
+        DWN_MSG("genCrc=0x%x\n", genCrc);
+
+        if (totalLen > firstReadLen)
+        {
+                const unsigned leftLen  = totalLen - firstReadLen;
+                sprintf(_cmdBuf, _cmdStr, _OPT_BOOT_PART_LIC_INFO_LOADADDR,
+                                AML_BOOT_PART_KEY_HEAD_OFFSET + firstReadLen, leftLen);
+                DWN_MSG("cmd[%s]\n", _cmdBuf);
+                rc = run_command(_cmdBuf, 0);
+                if (rc) {
+                        DWN_ERR("Fail in cmd[%s]\n", _cmdBuf);
+                        return __LINE__;
+                }
+        }
+
+        return 0;
+}
+
+int optimus_sdc_bootPart_lic_upload(void)
+{
+        const char* _cmdStr =  "mmc write 1 0x%x, 0x%x 0x%x";
+        BootPartKeyInf_head_t* pBootPartKeyInfHead      = _pOptBootPartLicHeadInf;
+        char _cmdBuf[96];
+        int rc = 0;
+
+        rc = (AML_BOOT_PART_KEY_HEAD_VERSION == pBootPartKeyInfHead->version)
+                && (AML_BOOT_PART_KEY_HEAD_MAGIC == pBootPartKeyInfHead->magic);
+        if (!rc) {
+                DWN_MSG("Ver[0x%x] or magic[0x%8x] error\n",
+                                pBootPartKeyInfHead->version, pBootPartKeyInfHead->magic);
+                return __LINE__;
+        }
+
+        rc = run_command("mmcinfo", 0);
+        if (rc) {
+                DWN_ERR("Fail to init external sdcard\n");
+                return __LINE__;
+        }
+        DWN_MSG("imgSz=0x%x\n", pBootPartKeyInfHead->imgSz);
+        //Update crc32 in image header
+        const unsigned genCrc = crc32(0, (u8*)&pBootPartKeyInfHead->magic,
+                        pBootPartKeyInfHead->imgSz - sizeof(unsigned int));
+        pBootPartKeyInfHead->hcrc = genCrc;
+        DWN_MSG("genCrc=0x%x\n", genCrc);
+
+        const unsigned totalLen = pBootPartKeyInfHead->imgSz;
+        sprintf(_cmdBuf, _cmdStr, _OPT_BOOT_PART_LIC_INFO_LOADADDR, AML_BOOT_PART_KEY_HEAD_OFFSET, totalLen);
+        rc = run_command(_cmdBuf, 0);
+        if (rc) {
+                DWN_ERR("Fail in cmd[%s]\n", _cmdBuf);
+                return __LINE__;
+        }
+
+        return 0;
+}
+
+//* keyInfAddr is sizeof the key info
+//
+//*/
+int optimus_sdc_bootPart_lic_get_key_infdata(const char* keyName, void** keyInfAddr)
+{
+        BootPartKeyInf_head_t* pBootPartKeyInfHead      = _pOptBootPartLicHeadInf;
+        BootPartKeyInf_Item_t* pBootPartKeyItemInf      = (BootPartKeyInf_Item_t*)(pBootPartKeyInfHead + 1);
+        const unsigned itemCnt                          = pBootPartKeyInfHead->imgItemNum;
+        int rc                                          = 0;
+        int itemIndex                                   = 0;
+
+        *keyInfAddr = NULL;
+
+        DWN_MSG("Get lic info for key[%s]\n", keyName);
+        //2, check _pOptBootPartLicHeadInf
+        rc = (AML_BOOT_PART_KEY_HEAD_VERSION == pBootPartKeyInfHead->version)
+                && (AML_BOOT_PART_KEY_HEAD_MAGIC == pBootPartKeyInfHead->magic);
+        if (!rc) {
+                DWN_MSG("Ver[0x%x] or magic[0x%8x]\n",
+                                pBootPartKeyInfHead->version, pBootPartKeyInfHead->magic);
+                return 0;
+        }
+
+        //3, find the item and return the count, return 0 if not found
+        for(itemIndex = 0; itemIndex < itemCnt; ++itemIndex,
+                        pBootPartKeyItemInf = (BootPartKeyInf_Item_t*)(pBootPartKeyItemInf->nextItemInfOffset + _OPT_BOOT_PART_LIC_INFO_LOADADDR))
+        {
+                const unsigned char* theKeyName = pBootPartKeyItemInf->keyName;
+
+                rc = memcmp(keyName, theKeyName, strlen(keyName));
+                if (rc) continue;
+                *keyInfAddr = ++pBootPartKeyItemInf;
+                return 0;
+        }
+
+        return 0;
+}
+
+//add an key info item if any, or update it
+int optimus_sdc_bootPart_lic_update_key_inf(const char* keyName, unsigned char* keyVal, unsigned int keyLen)
+{
+        BootPartKeyInf_head_t* pBootPartKeyInfHead      = _pOptBootPartLicHeadInf;
+        BootPartKeyInf_Item_t* pBootPartKeyItemInf      = (BootPartKeyInf_Item_t*)(pBootPartKeyInfHead + 1);
+        const unsigned itemCnt                          = pBootPartKeyInfHead->imgItemNum;
+        int rc                                          = 0;
+        int itemIndex                                   = 0;
+
+        DWN_MSG("update lic info for key[%s]\n", keyName);
+        //2, check _pOptBootPartLicHeadInf
+        rc = (AML_BOOT_PART_KEY_HEAD_VERSION == pBootPartKeyInfHead->version)
+                && (AML_BOOT_PART_KEY_HEAD_MAGIC == pBootPartKeyInfHead->magic);
+        if (!rc) {
+                DWN_MSG("Ver[0x%x] or magic[0x%8x]\n",
+                                pBootPartKeyInfHead->version, pBootPartKeyInfHead->magic);
+                return __LINE__;
+        }
+
+        BootPartKeyInf_Item_t* prevItemInf = NULL;
+        //3, find the item and return the count, return 0 if not found
+        for(itemIndex = 0; itemIndex < itemCnt; ++itemIndex,
+                        prevItemInf     = pBootPartKeyItemInf,
+                        pBootPartKeyItemInf = (BootPartKeyInf_Item_t*)(pBootPartKeyItemInf->itemSz + (unsigned long)pBootPartKeyItemInf))
+        {
+                const unsigned char* theKeyName = pBootPartKeyItemInf->keyName;
+
+                rc = memcmp(keyName, theKeyName, strlen(keyName));
+                if (rc) continue;
+
+                if (AML_BOOT_PART_KEY_ITEM_MAGIC != pBootPartKeyItemInf->magic) {
+                        DWN_ERR("Excp: item magic 0x%x eror, must be 0x%x\n",
+                                        pBootPartKeyItemInf->magic, AML_BOOT_PART_KEY_ITEM_MAGIC);
+                        return __LINE__;
+                }
+                //write key founded, update the total data
+                DWN_MSG("Find item at index %d\n", itemIndex);
+                if (pBootPartKeyItemInf->itemSz != keyLen + sizeof(BootPartKeyInf_Item_t)) {
+                        DWN_ERR("Excp: oldlen %d != newlen %d\n", pBootPartKeyItemInf->itemSz, keyLen);
+                        return __LINE__;
+                }
+                return 0;//To simple it just return
+        }
+        if (prevItemInf)
+        {
+                prevItemInf->nextItemInfOffset = (unsigned long)pBootPartKeyItemInf - _OPT_BOOT_PART_LIC_INFO_LOADADDR;
+        }
+
+        if (itemIndex != itemCnt) {
+                DWN_ERR("Exp:itemIndex[%d] != itemCnt[%d]\n", itemIndex, itemCnt);
+                return __LINE__;
+        }
+        memcpy(pBootPartKeyItemInf + 1, keyVal, keyLen);
+        //update item info
+        pBootPartKeyItemInf->itemIndex  = itemIndex;
+        pBootPartKeyItemInf->itemSz     = keyLen + sizeof(BootPartKeyInf_Item_t);
+        memcpy(pBootPartKeyItemInf->keyName, keyName, strlen(keyName));
+        pBootPartKeyItemInf->version    = AML_BOOT_PART_KEY_ITEM_VERSION;
+        pBootPartKeyItemInf->magic      = AML_BOOT_PART_KEY_ITEM_MAGIC;
+        //
+        //Update head info
+        pBootPartKeyInfHead->imgSz += keyLen;
+        ++pBootPartKeyInfHead->imgItemNum;
+
+        return 0;
+
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_bootPart_license.h b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_bootPart_license.h
new file mode 100644
index 0000000..37503ad
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_bootPart_license.h
@@ -0,0 +1,70 @@
+/*
+ * \file        sdc_bootPart_license.h
+ * \brief       Interfaces to read/update license in boot part
+ *
+ * \version     1.0.0
+ * \date        2015/3/10
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __V2_SDC_BURN_SDC_BOOTPART_LICENSE_H__
+#define __V2_SDC_BURN_SDC_BOOTPART_LICENSE_H__
+
+#define AML_BOOT_PART_KEY_HEAD_OFFSET           (0x4U<<20)
+#define AML_BOOT_PART_KEY_HEAD_MAGIC            0X2143494C  //"LIC!"
+#define AML_BOOT_PART_KEY_HEAD_VERSION          0x01
+#define AML_BOOT_PART_KEY_HEAD_SZ               (128)
+#define AML_BOOT_PART_ALIGN_SZ                  (16)
+
+#define AML_BOOT_PART_KEY_ITEM_MAGIC            0X4D455449  //"ITEM!"
+#define AML_BOOT_PART_KEY_ITEM_VERSION          0x01
+#define AML_BOOT_PART_KEY_ITEM_SZ               (128)
+#define AML_BOOT_PART_KEY_ITEM_NAME_LEN         16
+
+#pragma pack(push, 4)
+typedef struct _bootPartKeyInf_head{
+        unsigned int    hcrc;
+        unsigned int    magic;
+
+        unsigned int    version;
+        unsigned int    alignSz;
+
+        unsigned int    imgSz;
+        unsigned int    imgItemNum;
+
+        unsigned char   reserv[AML_BOOT_PART_KEY_HEAD_SZ - sizeof(unsigned int) * 6];
+}BootPartKeyInf_head_t;
+#pragma pack(pop)
+
+#pragma pack(push, 4)
+typedef struct _bootPartKeyInf_Item{
+        unsigned int    magic;
+        unsigned int    version;
+
+        unsigned int    itemIndex;
+        unsigned int    itemSz;//including this inf head
+
+        unsigned int    nextItemInfOffset;
+        unsigned int    reserv;
+
+        unsigned char   keyName[AML_BOOT_PART_KEY_ITEM_NAME_LEN];
+
+        unsigned char   resv1[AML_BOOT_PART_KEY_ITEM_SZ - sizeof(unsigned) * 6 - AML_BOOT_PART_KEY_ITEM_NAME_LEN];
+}BootPartKeyInf_Item_t;
+#pragma pack(pop)
+
+//Read license inf from external emmc boot part
+int optimus_sdc_bootPart_lic_download(void);
+
+//update the license inf to external mmc boot part
+int optimus_sdc_bootPart_lic_upload(void);
+
+int optimus_sdc_bootPart_lic_get_key_infdata(const char* keyName, void** keyInfAddr);
+
+//add an key info item if any, or update it
+int optimus_sdc_bootPart_lic_update_key_inf(const char* keyName, unsigned char* keyVal, unsigned int keyLen);
+
+#endif//ifndef __V2_SDC_BURN_SDC_BOOTPART_LICENSE_H__
+
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_keysprovider.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_keysprovider.c
new file mode 100644
index 0000000..91914fe
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/sdc_burnkeys/sdc_keysprovider.c
@@ -0,0 +1,502 @@
+/*
+ * \file        sdc_keysprovider.c
+ * \brief       Parse users' nankey/efusekey like PC's keysprovider.dll in sdcard burning mode
+ *
+ * \version     1.0.0
+ * \date        2014/12/25
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2014 Amlogic. All Rights Reserved.
+ *
+ */
+#include "../optimus_sdc_burn_i.h"
+#include "sdc_bootPart_license.h"
+
+#define _KEYS_PRV_DBG(fmt...) //DWN_MSG(fmt)
+#define _KEYS_PRV_ITEM_INF_ADDR_4_CONSIST     (OPTIMUS_DOWNLOAD_DISPLAY_BUF + 48 * 1024)
+#define _KEYS_PRV_ITEM_INF_ADDR_MISC          (OPTIMUS_DOWNLOAD_DISPLAY_BUF + 52 * 1024)
+
+#define _KEY_VAL_TMP_BUF            (OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR - OPTIMUS_DOWNLOAD_SLOT_SZ)
+static struct {
+        char*                   keyBuf;
+        unsigned                keySize;
+}_currentKey = {0};
+
+//Note: keys which read only is not need to update license, and so not need stored in boot partition
+//Typedef for keys structs in sdcard boot partition
+#if 1
+#define AML_BOOT_PART_KEY_IMG_OFFSET            (0X2U<<20)
+#define AML_BOOT_PART_KEY_IMG_MAGIC_LEN         8
+#define AML_BOOT_PART_KEY_IMG_MAGIC_V1          "AML_KEY!"
+#define AML_BOOT_PART_KEY_IMG_ALIGN_SZ          512
+#define AML_BOOT_PART_KEY_IMG_HEAD_SZ           (64)
+
+#define AML_BOOT_PART_KEY_ITEM_INF_LEN          (64)
+#define AML_BOOT_PART_KEY_ITEM_NAME_LEN_MAX     (16)
+
+//struct for the keys head which stored in boot partition
+#pragma pack(push, 4)
+typedef struct {
+        __u32           crc;
+        __s32           version;
+
+        __u8            magic[AML_BOOT_PART_KEY_IMG_MAGIC_LEN];
+
+        __u32           imgSz;
+        __u32           imgItemNum;
+
+        __u32           alignSz;//512
+        __u8            resrv[AML_BOOT_PART_KEY_IMG_HEAD_SZ - 8 * 3 - 4];
+
+}AmlBootPartKeysHead_t;
+#pragma pack(pop)
+
+#pragma pack(push, 4)
+typedef struct {
+        __u8            keyName[AML_BOOT_PART_KEY_ITEM_NAME_LEN_MAX];
+
+        __u32           itemIndex;
+        __u32           itemSz;         //equl to sizeof of each key
+
+        __u32           itemBodyOffset;
+        __u32           itemHasConf;//this item name is configured in keys.conf
+
+        __u8            resrv[32];
+
+}KeyInfo_t;
+#pragma pack(pop)
+
+#define MAX_KEY_INF_NUM                 5       //the max key numbers supported at the same time
+
+typedef struct {
+        AmlBootPartKeysHead_t           bootPartKeyHead;
+        KeyInfo_t                       keysInf[MAX_KEY_INF_NUM];
+}BootPartKeyInf_t;
+
+#endif//image for keys END #if 1
+
+#define debugP(fmt...) //printf("L%d:", __LINE__),printf(fmt)
+#define errorP(fmt...) printf("Err[keyspr]L%d:", __LINE__),printf(fmt)
+#define wrnP(fmt...)   printf("Wrn[keyspr]L%d:", __LINE__),printf(fmt)
+#define MsgP(fmt...)   printf("Msg[keyspr]L%d:", __LINE__),printf(fmt)
+
+#define KEY_MAP_MAGIC   0xeeffaa00
+
+enum {
+        KEY_FMT__MAC            = 0XBB,         //string format like 00:01:02:03:04:05
+        KEY_FMT__ONLEYONE             ,         //only one format means read the total license file as key value
+        KEY_FMT__HDCP                 ,
+        KEY_FMT__HDCP2                ,
+};
+
+//Different keyNames can have the same key format
+typedef int (*pFunc_getKeyValByLic)(const char* licensePath, u8* keyVal, unsigned* keyValLen, const char* keyName);
+typedef int (*pFunc_updateLic)(const char* keyName, const char* licensePath);//update the licnese file when burn succeed
+
+typedef struct _keyFmtMapping{
+        unsigned                magic;
+        const char* const       keyName;
+        const char* const       licenseFile;
+        const unsigned          keyFmt;
+        pFunc_getKeyValByLic    get_key_val;
+        pFunc_updateLic         update_license;
+}KeyFmtMap_t;
+
+static int get_key_val_for_fmt_mac(const char* licenseName, u8* keyVal, unsigned* keyValLen, const char* keyName);
+static int get_key_val_for_fmt_hdcp(const char* licenseName, u8* keyVal, unsigned* keyValLen, const char* keyName);
+static int get_key_val_for_fmt_hdcp2rx(const char* licenseName, u8* keyVal, unsigned* keyValLen, const char* keyName);
+static int get_key_val_for_fmt_onlyone(const char* licenseName, u8* keyVal, unsigned* keyValLen, const char* keyName);
+
+static int update_lic_for_fmt_mac(const char* keyName, const char* licenseName);
+static int update_lic_for_fmt_hdcp(const char* keyName, const char* licenseName);
+static int update_lic_for_fmt_hdcp2rx(const char* keyName, const char* licenseName);
+
+static const KeyFmtMap_t _keysFmtMapping[] = {
+        /*     magic,           keyname                  license file name      keyFmt*/
+        [0] = {KEY_MAP_MAGIC,   "mac",                  "license/mac_ether.ini"  , KEY_FMT__MAC     , get_key_val_for_fmt_mac    , update_lic_for_fmt_mac    },
+        [1] = {KEY_MAP_MAGIC,   "mac_bt",               "license/mac_bt.ini"     , KEY_FMT__MAC     , get_key_val_for_fmt_mac    , update_lic_for_fmt_mac    },
+        [2] = {KEY_MAP_MAGIC,   "mac_wifi",             "license/mac_wifi.ini"   , KEY_FMT__MAC     , get_key_val_for_fmt_mac    , update_lic_for_fmt_mac    },
+        [3] = {KEY_MAP_MAGIC,   "hdcp",                 "license/HDCP_LIENCE"    , KEY_FMT__HDCP    , get_key_val_for_fmt_hdcp   , update_lic_for_fmt_hdcp   },
+        [4] = {KEY_MAP_MAGIC,   "hdcp2",                "license/HDCP2_LIENCE"   , KEY_FMT__HDCP2   , get_key_val_for_fmt_hdcp2rx, update_lic_for_fmt_hdcp2rx},
+        [5] = {KEY_MAP_MAGIC,   "secure_boot_set",      "license/SECURE_BOOT_SET", KEY_FMT__ONLEYONE, get_key_val_for_fmt_onlyone, NULL},
+};
+#define _SupportKeysNum (sizeof(_keysFmtMapping)/sizeof(KeyFmtMap_t))
+
+#if 1   //mac begin
+static int optimus_sdc_burn_check_mac_ini_set_is_valid(const char* setName)
+{
+        const char* macSets[] = {"Group1", "Group2", "Group3"};
+        const int   nSet      = sizeof(macSets)/sizeof(char*);
+        int         index     = 0;
+        int         rc        = 0;
+
+        for (; index < nSet && !rc; ++index)
+        {
+                rc = !strcmp(setName, macSets[index]);
+        }
+
+        return rc;
+}
+
+typedef struct {
+        char            startMac[17 + 3];       //+2 to align 4
+        char            endMac[17 + 3];         //+2 to align 4
+        unsigned        total;
+        unsigned        used;
+}MacGroup_t;
+
+typedef struct {
+        unsigned        actualGroup;
+        MacGroup_t      groups[3];//max group is 3
+}KeyInf_mac_t;
+
+typedef struct {
+        const char*             start;
+        const char*             end;
+        unsigned                used;
+        unsigned                total;//total = end + 1 - start
+}MacCfg_t;
+
+/*static KeyInf_mac_t _bootPart_keyInf_Mac;//Mac key info stored in boot partition*/
+
+static int optimus_update_mac_str_current_val(char* startVal, unsigned used)
+{
+        int i = 0;
+
+        if (17 != strlen(startVal)) {
+                DWN_ERR("start(%s) fmt error.\n", startVal);
+                return __LINE__;
+        }
+
+        MsgP("start[%s], used=%d\n", startVal, used);
+        for (i = 5; i >= 0 && used; --i, (used >>= 8))
+        {
+                char* grp2       = startVal + i * 3;
+                unsigned grp2Val = simple_strtoul(grp2, NULL, 16);
+
+                DWN_DBG("gpp2(%s)grep2=%d, used=%d\n", grp2, grp2Val, used);
+                grp2Val += used & 0xff;
+                if (grp2Val > 0xff)
+                {
+                        used    += 0x100;
+                        grp2Val &= 0xff;
+                }
+                sprintf(grp2, "%02x", grp2Val);
+                DWN_DBG("grp[%d]%s\n", i, grp2);
+        }
+        DWN_MSG("Update mac [%s]\n", startVal);
+
+        return 0;
+}
+
+static int _optimus_get_mac_diff(MacCfg_t* macCfg)
+{
+        const char* start       = macCfg->start;
+        const char* end         = macCfg->end;
+        __u64 startVal          = 0;
+        __u64 endVal            = 0;
+        int i                   = 0;
+
+        for (i = 0; i < 6; ++i, start += 3, end += 3)
+        {
+                startVal += simple_strtoul(start, NULL, 16);
+                endVal   += simple_strtoul(end, NULL, 16);
+
+                startVal <<= 8;
+                endVal   <<= 8;
+        }
+        startVal >>= 8;
+        endVal   >>= 8;
+        DWN_MSG("mac range[%04x%08x, %04x%08x]\n",
+                        (unsigned)(startVal>>32), (unsigned)(startVal),
+                        (unsigned)(endVal>>32),   (unsigned)endVal      );
+        macCfg->total = (unsigned)(endVal + 1 - startVal);
+        return 0;
+}
+
+//update the mac value extracted from mac.ini
+//To simplest the case, currently one group is supported
+static int optimus_sdc_burn_parse_mac_ini_key_value(const char* setName, const char* keyName, const char* usrKeyVal)
+{
+        int rc = 0;
+        int grpN = 0;
+        MacCfg_t* currentMacCfg = (MacCfg_t*)_KEYS_PRV_ITEM_INF_ADDR_MISC;
+        char* keyBuf = (char*)_KEY_VAL_TMP_BUF;
+        KeyInf_mac_t* pKeyInf4Consist = (KeyInf_mac_t*)_KEYS_PRV_ITEM_INF_ADDR_4_CONSIST;
+
+        rc = strncmp("Group", setName, 5) || ( 6 != strlen(setName) );
+        if (rc) {//mac.ini only care Groupn
+                return 0;
+        }
+        grpN = setName[5] - '1'; //'1' not '0'
+        if (grpN > 3) {
+                DWN_ERR("Can only support grp1 ~ grp3 now!, grp[%s] not ok\n", setName);
+                return __LINE__;
+        }
+        pKeyInf4Consist->actualGroup = grpN + 1;
+        MacGroup_t* pKeyConsist = pKeyInf4Consist->groups + grpN;
+
+        _KEYS_PRV_DBG("grp[%d]key=[%s], val=[%s]\n", grpN, keyName, usrKeyVal);
+        //the mac cfg must be in the order: start + end (+used)
+        if (!strcmp("start", keyName))
+        {
+                currentMacCfg->start = usrKeyVal;//value in memory
+                _currentKey.keySize = strlen(usrKeyVal);
+                strcpy(keyBuf, currentMacCfg->start);
+                keyBuf[_currentKey.keySize] = 0;
+                _currentKey.keyBuf = keyBuf;
+                DWN_DBG("keybuf[%s]\n", keyBuf);
+                memcpy(pKeyConsist->startMac, usrKeyVal, strlen(usrKeyVal));
+        }
+        else if (!strcmp("end", keyName))
+        {
+                currentMacCfg->end = usrKeyVal;
+                _currentKey.keySize = strlen(usrKeyVal);
+                _optimus_get_mac_diff(currentMacCfg);
+                memcpy(pKeyConsist->endMac, usrKeyVal, strlen(usrKeyVal));
+                pKeyConsist->total = currentMacCfg->total;
+        }
+        else if(!strcmp("used", keyName))
+        {
+                currentMacCfg->used = simple_strtoul(usrKeyVal, NULL, 0);
+                if (currentMacCfg->used >= currentMacCfg->total) {
+                        DWN_ERR("mac used(%d) >= total(%d)\n", currentMacCfg->used , currentMacCfg->total);
+                        return __LINE__;
+                }
+                pKeyConsist->used = currentMacCfg->used;
+        }
+
+        if (17 != _currentKey.keySize) {
+                errorP("key size %d of mac(%s) is error, must be 17\n", _currentKey.keySize, usrKeyVal);
+                return __LINE__;
+        }
+
+        return 0;
+}
+
+static int _update_mac_with_cfg_and_bootpart(KeyInf_mac_t* pKeyInf4Consist, KeyInf_mac_t* pKeyInfInBootPart,
+                u8* keyVal, unsigned* keyValLen)
+{
+        const int grpNum = pKeyInf4Consist->actualGroup;
+        MacGroup_t* theMacGrpCfg        = NULL;
+        MacGroup_t* theMacGrpInBootPart = NULL;
+        unsigned    currentUsed         = 0;
+        int i = 0;
+
+        theMacGrpCfg = pKeyInf4Consist->groups;
+        currentUsed  = theMacGrpCfg->used;
+        for (; i < grpNum; ++i, ++theMacGrpCfg)
+        {
+                const unsigned leftInCfg = theMacGrpCfg->total - theMacGrpCfg->used;
+                unsigned leftCnt         = leftInCfg;
+                if (pKeyInfInBootPart)
+                {
+                        theMacGrpInBootPart             = pKeyInfInBootPart->groups + i;
+                        const unsigned leftInBoot       = theMacGrpInBootPart->total - theMacGrpInBootPart->used;
+                        DWN_MSG("leftInCfg=%u, leftInBoot=%u, used=%u\n", leftCnt, leftInBoot, theMacGrpInBootPart->used);
+                        if (leftCnt < leftInBoot) {
+                                DWN_ERR("Excp:leftInCfg[%u] < leftInBoot[%u]\n", leftCnt, leftInBoot);
+                                return __LINE__;
+                        }
+                        if (theMacGrpInBootPart->total != theMacGrpCfg->total) {
+                                DWN_ERR("Excp:cfg total[%u] != boot total[%u]\n",
+                                                theMacGrpCfg->total, theMacGrpInBootPart->total);
+                                return __LINE__;
+                        }
+                        currentUsed = ++theMacGrpInBootPart->used;//used is saved by prev burned
+                }
+                if (currentUsed < theMacGrpCfg->total) {//Find it
+                        DWN_MSG("Found available at grp[%d], total=%u, used=%u\n",
+                                        i, theMacGrpCfg->total, currentUsed);
+                        break;
+                }
+        }
+
+        if (i == grpNum) {
+                DWN_ERR("Can't find available grp,i=%d\n", i);
+                return __LINE__;
+        }
+
+        *keyValLen = strlen(theMacGrpCfg->startMac);
+        memcpy(keyVal, theMacGrpCfg->startMac, *keyValLen);
+        i = optimus_update_mac_str_current_val((char*)keyVal, currentUsed);
+        return i;
+}
+
+//step 1: parsing license/mac.ini to get 'start' and 'used'
+//step 2: search the key info in the boot key, if not existed , then append the keyinfo and update total count
+//step 3: check the 'start' and 'used' is same as which in the boot partition if existed
+//step 3: get the count recorded in the uboot partition
+static int get_key_val_for_fmt_mac(const char* licPath, u8* keyVal, unsigned* keyValLen, const char* keyName)
+{
+        const int MaxLines = 256;//
+        char* lines[MaxLines];
+        int rc = __LINE__;
+        int validLineNum = 0;
+        KeyInf_mac_t* pKeyInfInBootPart = NULL;
+        KeyInf_mac_t* pKeyInf4Consist = (KeyInf_mac_t*)_KEYS_PRV_ITEM_INF_ADDR_4_CONSIST;
+
+        memset(pKeyInf4Consist, 0, sizeof(KeyInf_mac_t));
+        validLineNum = parse_ini_file_2_valid_lines(licPath, (char*)keyVal, *keyValLen, lines);
+        if (!validLineNum) {
+                DWN_ERR("error in parse ini file\n");
+                return __LINE__;
+        }
+
+        rc = optimus_ini_trans_lines_2_usr_params((const char* *)lines, validLineNum,
+                        optimus_sdc_burn_check_mac_ini_set_is_valid,
+                        optimus_sdc_burn_parse_mac_ini_key_value);
+        if (rc) {
+                DWN_ERR("Fail in get cfg from %s\n", licPath);
+                return __LINE__;
+        }
+        *keyValLen = _currentKey.keySize;
+        memcpy(keyVal, _currentKey.keyBuf, _currentKey.keySize);
+        keyVal[_currentKey.keySize] = 0;
+
+#if 1
+        rc = optimus_sdc_bootPart_lic_get_key_infdata(keyName, (void**)&pKeyInfInBootPart);
+        if (rc) {
+                DWN_ERR("Fail in get key inf from boot part\n");
+                return __LINE__;
+        }
+#endif
+        rc = _update_mac_with_cfg_and_bootpart(pKeyInf4Consist, pKeyInfInBootPart, keyVal, keyValLen);
+
+        return rc;
+}
+
+static int update_lic_for_fmt_mac(const char* keyName, const char* licenseName)
+{
+        int rc = 0;
+
+        rc = optimus_sdc_bootPart_lic_update_key_inf(keyName, (u8*)_KEYS_PRV_ITEM_INF_ADDR_4_CONSIST, sizeof(KeyInf_mac_t));
+
+        return rc;
+}
+#endif//MAC
+
+
+static int get_key_val_for_fmt_hdcp(const char* licenseName, u8* keyVal, unsigned* keyValLen, const char* keyName)
+{
+        int rc = __LINE__;
+
+
+        return rc;
+}
+
+static int get_key_val_for_fmt_hdcp2rx(const char* licenseName, u8* keyVal, unsigned* keyValLen, const char* keyName)
+{
+        int rc = __LINE__;
+
+
+        return rc;
+}
+
+static int get_key_val_for_fmt_onlyone(const char* licenseName, u8* keyVal, unsigned* keyValLen, const char* keyName)
+{
+        int rc = 0;
+        char _cmd[96];
+
+        optimus_sdc_burn_switch_to_extmmc();
+
+        sprintf(_cmd, "fatload mmc 0:1 0x%p %s", keyVal, licenseName);
+        rc = run_command(_cmd, 0);
+        if (rc) {
+                errorP("failed in cmd[%s]\n", _cmd);
+                return __LINE__;
+        }
+
+        *keyValLen = simple_strtoul(getenv("filesize"), NULL, 16);
+
+        return rc;
+}
+
+static int update_lic_for_fmt_hdcp(const char* keyName, const char* licenseName)
+{
+        int rc = 0;
+
+
+        return rc;
+}
+
+static int update_lic_for_fmt_hdcp2rx(const char* keyName, const char* licenseName)
+{
+        int rc = 0;
+
+
+        return rc;
+}
+
+int optimus_sdc_keysprovider_init(void)
+{
+        /*return optimus_sdc_bootPart_lic_download();*/
+        return 0;
+}
+
+int optimus_sdc_keysprovider_exit(void)
+{
+        /*return optimus_sdc_bootPart_lic_upload();*/
+        return 0;
+}
+
+//check whether the key license is existed and supported
+//keyName is getted from keys.conf in package like PC burning tool
+int optimus_sdc_keysprovider_open(const char* keyName, const void** pHdle)
+{
+        int i = 0;
+        int rc = __LINE__;
+
+        const KeyFmtMap_t* pMappedKey = &_keysFmtMapping[0];
+        for (i=0; i < _SupportKeysNum; ++i, ++pMappedKey) {
+                rc = strcmp(keyName, pMappedKey->keyName);
+                if (rc) continue;//keyName not mapped
+                *pHdle = pMappedKey;
+                return 0;
+        }
+
+        return rc;
+}
+
+int optimus_sdc_keysprovider_get_keyval(const void* pHdle, u8* pBuf, unsigned* keySz)
+{
+        const KeyFmtMap_t* pMappedKey = (const KeyFmtMap_t*)pHdle;
+        const char* const  keyName    = pMappedKey->keyName;
+        const char*        licPath    = pMappedKey->licenseFile;
+        int rc = 0;
+
+        if (KEY_MAP_MAGIC != pMappedKey->magic) {
+                errorP("magic should be %x, but %x\n", KEY_MAP_MAGIC, pMappedKey->magic);
+                return __LINE__;
+        }
+        rc = pMappedKey->get_key_val(licPath, pBuf, keySz, keyName);
+        if (rc) {
+                errorP("Fail in getKeyVal for key[%s] at lic path[%s]\n", keyName, licPath);
+                return __LINE__;
+        }
+
+        return rc;
+}
+
+int optimus_sdc_keysprovider_update_license(const void* pHdle)
+{
+        const KeyFmtMap_t* pMappedKey = (const KeyFmtMap_t*)pHdle;
+        const char* const  keyName    = pMappedKey->keyName;
+        const char*        licPath    = pMappedKey->licenseFile;
+        int rc = 0;
+
+        if (KEY_MAP_MAGIC != pMappedKey->magic) {
+                errorP("magic should be %x, but %x\n", KEY_MAP_MAGIC, pMappedKey->magic);
+                return __LINE__;
+        }
+        if (!pMappedKey->update_license) return 0;
+
+        rc = pMappedKey->update_license(keyName, licPath);
+        if (rc) {
+                errorP("Fail in getKeyVal for key[%s] at lic path[%s]\n", keyName, licPath);
+                return __LINE__;
+        }
+
+        return 0;
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_burn/optimus_usb_burn.c b/drivers/usb/gadget/v2_burning/v2_usb_burn/optimus_usb_burn.c
new file mode 100644
index 0000000..2b73d32
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_burn/optimus_usb_burn.c
@@ -0,0 +1,86 @@
+/*
+ * \file        optimus_usb_burn.c
+ * \brief       burning itself from Pheripheral usb host
+ *
+ * \version     1.0.0
+ * \date        2014-9-15
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *				Chunyu.Song <chunyu.song@amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#include "../v2_sdc_burn/optimus_sdc_burn_i.h"
+#include "../v2_sdc_burn/optimus_led.h"
+
+extern int optimus_burn_with_cfg_file(const char* cfgFile);
+
+// added by scy
+int optimus_burn_package_in_usb(const char* sdc_cfg_file)
+{
+    int rcode = 0;
+
+    DWN_MSG("usb start\n");
+    rcode = run_command("usb start", 0);
+    if (rcode) {
+        DWN_ERR("Fail in init usb host, Does usb host not plugged in?\n");
+        return __LINE__;
+    }
+
+#if 1//this asserted by 'run update' and 'aml_check_is_ready_for_sdc_produce'
+    rcode = do_fat_get_fileSz(sdc_cfg_file);
+    if (!rcode) {
+        DWN_ERR("The [%s] not exist in udisk\n", sdc_cfg_file);
+        return __LINE__;
+    }
+#endif//#if 0
+
+    rcode = optimus_device_probe("usb", "0");
+    if (rcode) {
+        DWN_ERR("Fail to detect device usb 0\n");
+        return __LINE__;
+    }
+
+    rcode = optimus_burn_with_cfg_file(sdc_cfg_file);
+
+    return rcode;
+}
+
+
+// added by scy
+int do_usb_burn(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+
+    int rcode = 0;
+    const char* sdc_cfg_file = argv[1];
+
+	setenv("usb_update","1");
+
+    if (argc < 2 ) {
+        cmd_usage(cmdtp);
+        return __LINE__;
+    }
+
+    optimus_work_mode_set(OPTIMUS_WORK_MODE_SDC_UPDATE);
+    show_logo_to_report_burning();//indicate enter flow of burning! when 'run update'
+    if (optimus_led_open(LED_TYPE_PWM)) {
+        DWN_ERR("Fail to open led for burn\n");
+        return __LINE__;
+    }
+    optimus_led_show_in_process_of_burning();
+
+    rcode = optimus_burn_package_in_usb(sdc_cfg_file);
+
+    return rcode;
+}
+
+// added by scy
+U_BOOT_CMD(
+   usb_burn,      //command name
+   5,               //maxargs
+   0,               //repeatable
+   do_usb_burn,   //command function
+   "Burning with amlogic format package in usb ",           //description
+   "argv: [sdc_burn_cfg_file]\n"//usage
+   "    -aml_sdc_burn.ini is usually used configure file\n"
+);
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_burn/optimus_usb_update.c b/drivers/usb/gadget/v2_burning/v2_usb_burn/optimus_usb_update.c
new file mode 100644
index 0000000..d31f51b
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_burn/optimus_usb_update.c
@@ -0,0 +1,131 @@
+/*
+ * \file        optimus_usb_update.c
+ * \brief       usb_update command to burn a parition image from usb host
+ *              this update based on the burner is latest: (uboot for burnner can run from peripherals such as sdmmc/usb)
+ *
+ * \version     1.0.0
+ * \date        2014-9-15
+ * \author      Chunyu.Song<chunyu.song@amlogic.com>
+ *		        Sam.Wu <yihui.wu@amlogic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#include "../v2_sdc_burn/optimus_sdc_burn_i.h"
+
+typedef int __hFileHdl;
+
+#define BURN_DBG 0
+#if BURN_DBG
+#define SDC_DBG(fmt...) printf(fmt)
+#else
+#define SDC_DBG(fmt...)
+#endif//if BURN_DBG
+
+#define SDC_MSG         DWN_MSG
+#define SDC_ERR         DWN_ERR
+
+//static char _errInfo[512] = "";
+// count usb start,to reduce the time-consuming of excuting usb start
+int usb_start_count = 0;
+
+//step 1: get script file size, and get script file contents
+//step 2: read image file
+//"Usage: usb_update partiton image_file_path [imgFmt, verifyFile]\n"   //usage
+int do_usb_update(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rcode = 0;
+
+    const char* partName    = argv[1];
+    const char* imgItemPath = argv[2];
+    const char* fileFmt     = argc > 3 ? argv[3] : NULL;
+    const char* verifyFile  = argc > 4 ? argv[4] : NULL;
+
+	setenv("usb_update", "1");
+	printf("usb_start_count %d\n", usb_start_count);
+#if BURN_DBG
+    printf("argc %d, %s, %s\n", argc, argv[0], argv[1]);
+    if (argc < 3)
+    {
+		partName    = "system";
+		imgItemPath = "rec.img";
+		fileFmt     = "normal";
+		verifyFile  = "recovery.verify";
+    }
+#else
+	if (argc < 3) {
+        cmd_usage(cmdtp);
+		return __LINE__;
+	}
+#endif//#if BURN_DBG
+
+if (usb_start_count == 0)
+{
+    //usb start to ensure usb host inserted and inited
+    rcode = run_command("usb start", 0);
+    usb_start_count++;
+    if (rcode) {
+        SDC_ERR("Fail in init usb, Does usb host not plugged in?\n");
+        return __LINE__;
+    }
+}
+
+#if 0
+    if (!do_fat_get_fileSz(imgItemPath)) {
+        SDC_ERR("file (%s) not existed\n", imgItemPath);
+        return __LINE__;
+    }
+#else
+    rcode = optimus_device_probe("usb", "0");
+/*
+	if (rcode) {
+        SDC_ERR("Fail to detect device usb 0\n");
+        return __LINE__;
+    }
+    */
+#endif//#if 0
+
+    if (!fileFmt)
+    {
+        rcode = do_fat_get_file_format(imgItemPath, (u8*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR, (8*1024));
+        if (rcode < 0) {
+            SDC_ERR("Fail when parse file format\n");
+            return __LINE__;
+        }
+        fileFmt = rcode ? "sparse" : "normal";
+    }
+
+#if 0
+    if (!getenv("disk_initial")) //if disk_initial command not executed for burning
+    {
+        rcode = optimus_storage_init(0);//can't erase as not full updating
+        if (rcode) {
+            SDC_ERR("Fail in init storage, rcode %d\n", rcode);
+            return rcode;
+        }
+        setenv("disk_initial", "0");
+    }
+#endif//#if 0
+
+    rcode = optimus_burn_partition_image(partName, imgItemPath, fileFmt, verifyFile, 0);
+    if (rcode) {
+        SDC_ERR("Fail to burn partition (%s) with image file (%s) in format (%s)\n", partName, imgItemPath, fileFmt);
+    }
+
+    return rcode;
+}
+
+U_BOOT_CMD(
+   usb_update,      //command name
+   5,               //maxargs
+   0,               //repeatable
+   do_usb_update,   //command function
+   "Burning a partition with image file in usb host",           //description
+   "    argv: <part_name> <image_file_path> <[,fileFmt]> <[,verify_file]> \n"   //usage
+   "    - <fileFmt> parameter is optional, if you know it you can specify it.\n"
+   "        for Android, system.img and data.img is \"sparse\" format, other is \"normal\"\n"   //usage
+   "    - <verify_file> parameter is optional, if you have it you can specify it.\n"
+   "    - e.g. \n"
+   "        to burn partition boot with boot.img of usb 0 : \"usb_update boot boot.img\"\n"   //usage
+   "        to burn partition system with system.img of usb 0 : \"usb_update system system.img\"\n"   //usage
+);
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd.c b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd.c
new file mode 100644
index 0000000..f1a8e31
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd.c
@@ -0,0 +1,739 @@
+/* dwc controller pcd drivers  */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-24 @ Shanghai
+ *
+ */
+#include "../v2_burning_i.h"
+#include "platform.h"
+#include "usb_ch9.h"
+#include "dwc_pcd.h"
+#include "dwc_pcd_irq.h"
+
+pcd_struct_t this_pcd ;//FIXME:This PCD should point to different or cause bug!!
+
+dwc_ep_t g_dwc_eps[NUM_EP];
+
+int dwc_core_init(void)
+{
+    gotgctl_data_t gctrldata;
+    int32_t         snpsid;
+
+    memset(&this_pcd, 0, sizeof(this_pcd));
+
+    DBG("DWC_REG_GSNPSID 0x%x\n", DWC_REG_GSNPSID+DWC_REG_BASE);
+    snpsid = dwc_read_reg32(DWC_REG_GSNPSID);
+
+    if ( !( 0x4F542000 == (snpsid & 0xFFFFF000) || 0x4F543000 == (snpsid & 0xFFFFF000) ) ) {
+        printf("%s,Bad value for SNPSID: 0x%08x\n", __func__, snpsid);
+        return -1;
+    }
+
+#if 1
+    /*GOTGCTL*/
+    gctrldata.d32 = dwc_read_reg32(DWC_REG_GOTGCTL);//Can this GOTGCTL read before dwc_otg_core_init() ??
+    if (!gctrldata.b.asesvld || !gctrldata.b.bsesvld) {
+            printf("GOTGCTL=0x%08x, asesvld=%x, bsesvld=%x\n",
+                            gctrldata.d32, gctrldata.b.asesvld, gctrldata.b.bsesvld);
+            return __LINE__;
+
+    }
+#endif//
+
+    DBG("dwc core init is ok!\n");// show printf is ok.
+    /*
+     * Disable the global interrupt until all the interrupt
+     * handlers are installed.
+     */
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    ahbcfg.b.glblintrmsk = 1;   /* Enable interrupts bit */
+    dwc_modify_reg32(DWC_REG_GAHBCFG, ahbcfg.d32, 0);
+    /*
+     * Initialize the DWC_otg core.
+     */
+    dwc_otg_core_init();
+
+    dwc_modify_reg32(DWC_REG_DCTL,0,2);// Disconnect data line
+    dwc_otg_pcd_init();
+    dwc_modify_reg32(DWC_REG_DCTL,2,0);// Connect data line
+
+    /*
+     * Enable the global interrupt after all the interrupt
+     * handlers are installed.
+     */
+    dwc_otg_enable_global_interrupts();
+
+    return 0;
+}
+
+int dwc_otg_irq(void)
+{
+	int ret1,ret2;
+
+	ret1 = dwc_common_irq();
+	ret2 = dwc_pcd_irq();
+	return (ret1+ret2);
+}
+
+void dwc_otg_pullup(int is_on)
+{
+	if (is_on)
+		dwc_modify_reg32(DWC_REG_DCTL,2,0);// connect data line
+    else dwc_modify_reg32(DWC_REG_DCTL,0,2);// disconnect data line
+}
+static void dwc_otg_core_init() //Elvis Fool, add 'static'
+{
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    gusbcfg_data_t  usbcfg = {.d32 = 0 };
+ //   gi2cctl_data_t  i2cctl = {.d32 = 0 };
+//    hcfg_data_t     hcfg;
+#ifndef USE_FULL_SPEED
+	usbcfg.d32 = dwc_read_reg32(DWC_REG_GUSBCFG);
+
+	usbcfg.b.ulpi_ext_vbus_drv = 0;
+	usbcfg.b.term_sel_dl_pulse = 0;
+	dwc_write_reg32(DWC_REG_GUSBCFG,usbcfg.d32);
+#endif
+	/*
+	* Reset the Controller
+	*/
+	dwc_otg_core_reset();
+
+		usbcfg.d32 = dwc_read_reg32(DWC_REG_GUSBCFG);
+	usbcfg.b.srpcap = 0;
+	usbcfg.b.hnpcap = 0;
+#ifdef USE_FULL_SPEED
+	dcfg_data_t     dcfg;
+	printf("Full Speed\n");
+	usbcfg.b.physel = 1;  // Work at full speed
+	dwc_write_reg32(DWC_REG_GUSBCFG, usbcfg.d32);
+
+	dwc_otg_core_reset();
+/* for HOST
+	hcfg.d32 = dwc_read_reg32(DWC_REG_ hcfg);
+	hcfg.b.fslspclksel = val;
+	dwc_write_reg32(&_core_if->host_if->host_global_regs->hcfg, hcfg.d32);
+*/
+// for Device
+	dcfg.d32 = dwc_read_reg32(DWC_REG_DCFG);
+	dcfg.b.devspd = 1;//Hi speed phy run at Full speed
+	dwc_write_reg32(DWC_REG_DCFG, dcfg.d32);
+#else
+	DBG("High Speed\n");
+	usbcfg.b.ulpi_utmi_sel = 1;
+	usbcfg.b.phyif = 0; // 16 bit
+	usbcfg.b.ddrsel = 0;
+	dwc_write_reg32(DWC_REG_GUSBCFG, usbcfg.d32);
+
+	dwc_otg_core_reset();
+#endif
+	ahbcfg.b.dmaenable = 0;
+	dwc_write_reg32(DWC_REG_GAHBCFG, ahbcfg.d32);
+
+
+    /*
+     * Enable common interrupts
+     */
+    dwc_otg_enable_common_interrupts();
+
+    /*
+     * Do device or host intialization based on mode during PCD and HCD
+     * initialization
+     */
+     if (dwc_read_reg32(DWC_REG_GINTSTS) & 0x1) {
+          DBG("Host Mode\n");
+          return ;
+    } else {
+        DBG("Device Mode\n");
+        dwc_otg_core_dev_init();
+    }
+
+}
+
+/**
+ * This function initialized the PCD portion of the driver.
+ *
+ */
+static int  dwc_otg_pcd_init()
+{
+        return 0;
+}
+
+
+/**
+ * Do core a soft reset of the core.  Be careful with this because it
+ * resets all the internal state machines of the core.
+ */
+static void dwc_otg_core_reset(void)		//Elvis Fool, add 'static'
+{
+    grstctl_t greset = {.d32 = 0 };
+    int             count = 0;
+
+    /*
+     * Wait for AHB master IDLE state.
+     */
+    do {
+        udelay(10);
+        greset.d32 = dwc_read_reg32(DWC_REG_GRSTCTL);
+        if (++count > 100000) {
+            //DBG("%s() HANG! AHB Idle GRSTCTL=%0x\n", dwc_otg_core_reset, greset.d32);
+            return;
+        }
+    }
+    while (greset.b.ahbidle == 0);
+
+    /*
+     * Core Soft Reset
+     */
+    count = 0;
+    greset.b.csftrst = 1;
+    dwc_write_reg32(DWC_REG_GRSTCTL, greset.d32);
+    do {
+        greset.d32 = dwc_read_reg32(DWC_REG_GRSTCTL);
+        if (++count > 1000000) {
+            //DBG("%s() HANG! Soft Reset GRSTCTL=%0x\n", dwc_otg_core_reset, greset.d32);
+            break;
+        }
+    }
+    while (greset.b.csftrst == 1);
+
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    wait_ms(10);
+}
+
+static void dwc_otg_enable_common_interrupts()
+{
+        gintmsk_data_t intr_mask = { 0};
+        /* Clear any pending OTG Interrupts */
+        dwc_write_reg32(DWC_REG_GOTGINT, 0xFFFFFFFF);
+        /* Clear any pending interrupts */
+        dwc_write_reg32(DWC_REG_GINTSTS, 0xFFFFFFFF);
+        /*
+         * Enable the interrupts in the GINTMSK.
+         */
+        intr_mask.b.modemismatch = 1;
+        intr_mask.b.otgintr = 1;
+        intr_mask.b.rxstsqlvl = 1;
+        intr_mask.b.conidstschng = 1;
+        intr_mask.b.wkupintr = 1;
+        intr_mask.b.disconnect = 1;
+        intr_mask.b.usbsuspend = 1;
+        intr_mask.b.sessreqintr = 1;
+        dwc_write_reg32(DWC_REG_GINTMSK, intr_mask.d32);
+}
+
+/**
+ * This function enables the Device mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+static void dwc_otg_enable_device_interrupts()
+{
+        gintmsk_data_t intr_mask = {  0};
+
+        /* Disable all interrupts. */
+        dwc_write_reg32( DWC_REG_GINTMSK, 0);
+
+        /* Clear any pending interrupts */
+        dwc_write_reg32( DWC_REG_GINTSTS, 0xFFFFFFFF);
+
+        /* Enable the common interrupts */
+        dwc_otg_enable_common_interrupts( );
+
+        /* Enable interrupts */
+        intr_mask.b.usbreset = 1;
+        intr_mask.b.enumdone = 1;
+        intr_mask.b.epmismatch = 1;
+        intr_mask.b.inepintr = 1;
+        intr_mask.b.outepintr = 1;
+        intr_mask.b.erlysuspend = 1;
+
+        dwc_modify_reg32( DWC_REG_GINTMSK, intr_mask.d32, intr_mask.d32);
+
+}
+/**
+ * This function enables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+static void dwc_otg_enable_global_interrupts( )
+{
+        gahbcfg_data_t ahbcfg = { 0};
+        ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
+        dwc_modify_reg32(DWC_REG_GAHBCFG, 0, ahbcfg.d32);
+}
+
+
+/**
+ * This function initializes the DWC_otg controller registers for
+ * device mode.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ *
+ */
+static void dwc_otg_core_dev_init(void)
+{
+        dcfg_data_t dcfg = { 0};
+        grstctl_t resetctl = { 0 };
+        int i;
+        fifosize_data_t nptxfifosize;
+
+        /* Restart the Phy Clock */
+        dwc_write_reg32(DWC_REG_PCGCCTL, 0);
+
+        /* Device configuration register */
+	dcfg.d32 = dwc_read_reg32(DWC_REG_DCFG);
+#ifdef USE_FULL_SPEED
+	dcfg.b.devspd = 1;//Hi speed phy run at Full speed
+#else
+	dcfg.b.devspd = 0;
+#endif
+	dcfg.b.perfrint = DWC_DCFG_FRAME_INTERVAL_80;
+	dwc_write_reg32(DWC_REG_DCFG, dcfg.d32);
+
+        /* Configure data FIFO sizes */
+
+	/* Rx FIFO */
+      dwc_write_reg32(DWC_REG_GRXFSIZ, 256 );
+      //DBG("new grxfsiz=%08x\n",dwc_read_reg32(DWC_REG_GRXFSIZ));
+
+	/* Non-periodic Tx FIFO */
+      nptxfifosize.b.depth  = 256;
+      nptxfifosize.b.startaddr = 256;
+      dwc_write_reg32(DWC_REG_GNPTXFSIZ, nptxfifosize.d32 );
+      //DBG("new gnptxfsiz=%08x\n",dwc_read_reg32(DWC_REG_GNPTXFSIZ));
+
+        /* Flush the FIFOs */
+      dwc_otg_flush_tx_fifo( 0x10); /* all Tx FIFOs */
+      dwc_otg_flush_rx_fifo();
+
+	/* Flush the Learning Queue. */
+      resetctl.b.intknqflsh = 1;
+      dwc_write_reg32( DWC_REG_GRSTCTL, resetctl.d32);
+
+        /* Clear all pending Device Interrupts */
+        dwc_write_reg32( DWC_REG_DIEPMSK, 0 );
+        dwc_write_reg32( DWC_REG_DOEPMSK, 0 );
+        dwc_write_reg32( DWC_REG_DAINT, 0xFFFFFFFF );
+        dwc_write_reg32( DWC_REG_DAINTMSK, 0 );
+
+        for (i=0; i < NUM_EP; i++) {
+		depctl_data_t depctl;
+		depctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(i));
+		if (depctl.b.epena) {
+			depctl.d32 = 0;
+			depctl.b.epdis = 1;
+			depctl.b.snak = 1;
+		} else {
+			depctl.d32 = 0;
+		}
+		dwc_write_reg32( DWC_REG_IN_EP_REG(i),depctl.d32);
+
+		depctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(i));
+		if (depctl.b.epena) {
+			depctl.d32 = 0;
+			depctl.b.epdis = 1;
+			depctl.b.snak = 1;
+		} else {
+			depctl.d32 = 0;
+		}
+		dwc_write_reg32( DWC_REG_OUT_EP_REG(i), depctl.d32);
+
+		/* Device IN/OUT Endpoint Transfer Size */
+		dwc_write_reg32(DWC_REG_IN_EP_TSIZE(i), 0);
+		dwc_write_reg32(DWC_REG_OUT_EP_TSIZE(i), 0);
+		/* Device IN/OUT Endpoint DMA Address Register */
+		dwc_write_reg32( DWC_REG_IN_EP_DMA(i), 0);
+		dwc_write_reg32( DWC_REG_OUT_EP_DMA(i), 0);
+		/* Device IN/OUT Endpoint Interrupt Register */
+		//dwc_write_reg32( DWC_REG_IN_EP_DMA(i), 0xFF);
+		//dwc_write_reg32( DWC_REG_OUT_EP_INTR(i), 0xFF);
+        }
+
+        //d wc_otg_set_vbus_power(_core_if, 0); //Power off VBus
+
+        dwc_otg_enable_device_interrupts();
+
+	  DBG("init gintmsk: 0x%x\n",dwc_read_reg32(DWC_REG_GINTMSK));
+}
+/**
+ * Flush a Tx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _num Tx FIFO to flush.
+ */
+static void dwc_otg_flush_tx_fifo( const int _num ) 	//Elvis Fool, add 'static'
+{
+        grstctl_t greset = { 0};
+        int count = 0;
+
+
+	 DBG("dwc_otg_flush_tx_fifo: %d\n",_num);
+        greset.b.txfflsh = 1;
+        greset.b.txfnum = _num;
+        dwc_write_reg32(DWC_REG_GRSTCTL, greset.d32 );
+
+        do {
+                greset.d32 = dwc_read_reg32( DWC_REG_GRSTCTL);
+                if (++count > 10000) {
+                       // ERR("%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
+                       //           "dwc_otg_flush_tx_fifo", greset.d32,
+                       //           dwc_read_reg32( DWC_REG_GNPTXSTS));
+                        break;
+                }
+
+        } while (greset.b.txfflsh == 1);
+        /* Wait for 3 PHY Clocks*/
+        udelay(1);
+}
+
+/**
+ * Flush Rx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static void dwc_otg_flush_rx_fifo( )
+{
+        grstctl_t greset = { 0};
+        int count = 0;
+
+	  DBG("dwc_otg_flush_rx_fifo\n");
+        greset.b.rxfflsh = 1;
+        dwc_write_reg32( DWC_REG_GRSTCTL, greset.d32 );
+
+        do {
+                greset.d32 = dwc_read_reg32( DWC_REG_GRSTCTL);
+                if (++count > 10000) {
+                        //ERR("%s() HANG! GRSTCTL=%0x\n", "dwc_otg_flush_rx_fifo",
+                        //         greset.d32);
+                        break;
+                }
+        } while (greset.b.rxfflsh == 1);
+        /* Wait for 3 PHY Clocks*/
+        udelay(1);
+}
+/**
+ * This function does the setup for a data transfer for EP0 and starts
+ * the transfer.  For an IN transfer, the packets will be loaded into
+ * the appropriate Tx FIFO in the ISR. For OUT transfers, the packets are
+ * unloaded from the Rx FIFO in the ISR.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP0 data.
+ */
+ #if 0
+void dwc_otg_ep0_start_transfer(dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	deptsiz0_data_t deptsiz;
+        gintmsk_data_t intr_mask = { 0};
+
+        _ep->total_len = _ep->xfer_len;
+
+	//DBG("dwc_otg_ep0_start_transfer: xfer_len:%d\n",_ep->xfer_len);
+	/* IN endpoint */
+	if (_ep->is_in == 1) {
+		gnptxsts_data_t tx_status = { 0};
+
+		tx_status.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+		if (tx_status.b.nptxqspcavail == 0) {
+			return;
+		}
+
+		depctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(0));
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_IN_EP_TSIZE(0));
+
+		/* Zero Length Packet? */
+		if (_ep->xfer_len == 0) {
+			deptsiz.b.xfersize = 0;
+			deptsiz.b.pktcnt = 1;
+		} else {
+			/* Program the transfer size and packet count
+			*  as follows: xfersize = N * maxpacket +
+			*  short_packet pktcnt = N + (short_packet
+			*  exist ? 1 : 0)
+			*/
+			if (_ep->xfer_len > _ep->maxpacket) {
+				_ep->xfer_len = _ep->maxpacket;
+				deptsiz.b.xfersize = _ep->maxpacket;
+			}
+			else {
+				deptsiz.b.xfersize = _ep->xfer_len;
+			}
+			deptsiz.b.pktcnt = 1;
+
+		}
+		dwc_write_reg32(DWC_REG_IN_EP_TSIZE(0), deptsiz.d32);
+             //DBG( "IN len=%d  xfersize=%d pktcnt=%d [%08x]\n",
+              //              _ep->xfer_len,deptsiz.b.xfersize, deptsiz.b.pktcnt, deptsiz.d32);
+
+
+		flush_cpu_cache();
+
+		/* EP enable, IN data in FIFO */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+		dwc_write_reg32(DWC_REG_IN_EP_REG(0), depctl.d32);
+
+		/**
+		 * Enable the Non-Periodic Tx FIFO empty interrupt, the
+		 * data will be written into the fifo by the ISR.
+		 */
+
+		/* First clear it from GINTSTS */
+		intr_mask.b.nptxfempty = 1;
+		dwc_modify_reg32( DWC_REG_GINTSTS,intr_mask.d32, 0);
+		dwc_modify_reg32( DWC_REG_GINTMSK,intr_mask.d32, intr_mask.d32);
+
+
+	} else { /* OUT endpoint */
+
+		depctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(0));
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_OUT_EP_TSIZE(0));
+
+		/* Program the transfer size and packet count as follows:
+		*  xfersize = N * (maxpacket + 4 - (maxpacket % 4))
+		*  pktcnt = N                                          */
+#if 0
+		if (_ep->xfer_len == 0) {
+			/* Zero Length Packet */
+			deptsiz.b.xfersize = _ep->maxpacket;
+			deptsiz.b.pktcnt = 1;
+		} else {
+			deptsiz.b.pktcnt =
+			(_ep->xfer_len + (_ep->maxpacket - 1)) /_ep->maxpacket;
+			deptsiz.b.xfersize = deptsiz.b.pktcnt * _ep->maxpacket;
+		}
+#else   // ep0 pktcnt is 1 bit
+
+		deptsiz.b.xfersize = _ep->maxpacket;
+		deptsiz.b.pktcnt = 1;
+		udelay(1); // This is needed, don't know reason.
+#endif
+
+
+		dwc_write_reg32(DWC_REG_OUT_EP_TSIZE(0), deptsiz.d32);
+             //DBG( "OUT len=%d  xfersize=%d pktcnt=%d\n",
+             //               _ep->xfer_len,deptsiz.b.xfersize, deptsiz.b.pktcnt);
+
+
+		/* EP enable */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+		dwc_write_reg32 (DWC_REG_OUT_EP_REG(0), depctl.d32);
+	}
+
+	flush_cpu_cache();
+}
+ #endif
+
+void dwc_otg_ep_start_transfer(dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	deptsiz_data_t deptsiz;
+	int epctl_reg,epctltsize_reg;
+	int ep_num = _ep->num;
+	int is_in = _ep->is_in;
+	int ep_mps = _ep->maxpacket;
+
+	//DBG("dwc_otg_ep_start_transfer: xfer_len:%d\n",_ep->xfer_len);
+
+        _ep->total_len = _ep->xfer_len;
+
+	if (is_in) {
+		epctl_reg = DWC_REG_IN_EP_REG(ep_num);
+		epctltsize_reg = DWC_REG_IN_EP_TSIZE(ep_num);
+	}else{
+		epctl_reg = DWC_REG_OUT_EP_REG(ep_num);
+		epctltsize_reg = DWC_REG_OUT_EP_TSIZE(ep_num);
+	}
+
+	depctl.d32 = dwc_read_reg32(epctl_reg);
+	deptsiz.d32 = dwc_read_reg32(epctltsize_reg);
+
+	/* Zero Length Packet? */
+	if (_ep->xfer_len == 0) {
+		deptsiz.b.xfersize = is_in?0:ep_mps;
+		deptsiz.b.pktcnt = 1;
+	}
+    else {
+		deptsiz.b.pktcnt = (_ep->xfer_len + (ep_mps - 1)) /ep_mps;
+		if (is_in && _ep->xfer_len < ep_mps)
+			deptsiz.b.xfersize = _ep->xfer_len;
+		else
+            deptsiz.b.xfersize = deptsiz.b.pktcnt * ep_mps;
+            /*deptsiz.b.xfersize = _ep->xfer_len - _ep->xfer_count;////////victor fixed*/
+	}
+
+	/* Fill size and count */
+	dwc_write_reg32(epctltsize_reg,deptsiz.d32);
+
+	/* EP enable */
+	depctl.b.cnak = 1;
+	depctl.b.epena = 1;
+	dwc_write_reg32 (epctl_reg, depctl.d32);
+
+	/* IN endpoint */
+	if (is_in) {
+		gintmsk_data_t intr_mask = {0};
+		//gnptxsts_data_t tx_status = { 0};
+
+		//tx_status.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+		//if (tx_status.b.nptxqspcavail == 0){
+		//	return;
+		//}
+
+		/**
+		 * Enable the Non-Periodic Tx FIFO empty interrupt, the
+		 * data will be written into the fifo by the ISR.
+		 */
+
+		/* First clear it from GINTSTS */
+		intr_mask.b.nptxfempty = 1;
+		dwc_modify_reg32( DWC_REG_GINTSTS,intr_mask.d32, 0);
+		dwc_modify_reg32( DWC_REG_GINTMSK,intr_mask.d32, intr_mask.d32);
+
+	}
+
+}
+
+int dwc_otg_ep_req_start(pcd_struct_t *pcd,int ep_num)
+{
+	dwc_ep_t *ep = &g_dwc_eps[ep_num];
+
+	ep->num = ep_num;
+	//DBG("dwc_otg_ep_req_start: ep%d\n",ep_num);
+        /* EP0 Transfer? */
+	if (ep_num == 0)
+    {
+		//DBG("EP0 State: %d\n",pcd->ep0state);
+		switch (pcd->ep0state)
+        {
+			case EP0_IN_DATA_PHASE:
+				break;
+
+			case EP0_OUT_DATA_PHASE:
+				if (pcd->request_config) {
+				        /* Work around for SetConfig cmd */
+				        /* Complete STATUS PHASE */
+				        ep->is_in = 1;
+				        pcd->ep0state = EP0_STATUS;
+				}
+				else if(pcd->length == 0)
+				{
+				        /* Work around for MSC Reset cmd */
+				        /* Complete STATUS PHASE */
+				        ep->is_in = 1;
+				        pcd->ep0state = EP0_STATUS;
+				}
+			break;
+
+			default:
+				return -1;
+		}
+
+		ep->start_xfer_buff = (uint8_t*)pcd->buf;
+		ep->xfer_buff = (uint8_t*)pcd->buf;
+		ep->xfer_len = pcd->length;
+		ep->xfer_count = 0;
+		ep->sent_zlp = 0;
+		ep->total_len = ep->xfer_len;
+		ep->maxpacket = 64;
+		dwc_otg_ep_start_transfer( ep );
+
+	}
+    else {
+		/* Setup and start the Transfer for Bulk */
+		ep->start_xfer_buff = (uint8_t*)pcd->bulk_buf + pcd->bulk_xfer_len;
+		ep->xfer_buff = (uint8_t*)pcd->bulk_buf + pcd->bulk_xfer_len;
+        ep->xfer_len = pcd->bulk_len;
+        /*ep->xfer_len  = MIN(pcd->bulk_data_len , pcd->bulk_len);////Victor fixed!!*/
+		ep->xfer_count = 0;
+		ep->sent_zlp = 0;
+		ep->total_len = ep->xfer_len;
+		ep->maxpacket = BULK_EP_MPS;
+		ep->is_in = (ep_num == BULK_IN_EP_NUM);
+        //tranfer  failed here after printf here
+
+		dwc_otg_bulk_ep_activate( ep );
+        /*printf("start_xfer_buf=0x%x, xfer_buf=0x%x, xfer_len 0x%x\n", ep->start_xfer_buff, ep->xfer_buff, ep->xfer_len);*/
+		dwc_otg_ep_start_transfer( ep );
+	}
+
+	return 0;
+
+}
+
+static void dwc_otg_bulk_ep_activate(dwc_ep_t *ep)
+{
+	depctl_data_t depctl = {0};
+	daint_data_t daintmsk = {0};
+	int epctl;
+	int ep_num = ep->num;
+
+	if (ep->is_in) {
+		epctl = DWC_REG_IN_EP_REG(ep_num);
+		daintmsk.ep.in = 1<<BULK_IN_EP_NUM; //ep1:BULK_IN
+	}
+	else{
+		epctl = DWC_REG_OUT_EP_REG(ep_num);
+		daintmsk.ep.out = 1<<BULK_OUT_EP_NUM;//ep2:BULK_OUT
+	}
+
+	depctl.d32 = dwc_read_reg32(epctl);
+	if (!depctl.b.usbactep) {
+		depctl.b.mps = BULK_EP_MPS;
+		depctl.b.eptype = 2;//BULK_STYLE
+		depctl.b.setd0pid = 1;
+		depctl.b.txfnum = 0;   //Non-Periodic TxFIFO
+		depctl.b.usbactep = 1;
+
+		dwc_write_reg32(epctl, depctl.d32);
+	}
+
+	dwc_modify_reg32(DWC_REG_DAINTMSK, 0, daintmsk.d32);
+
+	return;
+}
+
+int dwc_otg_bulk_ep_enable(int is_in)
+{
+    depctl_data_t depctl = {0};
+	daint_data_t daintmsk = {0};
+	int epctl;
+	const int ep_num = is_in ? BULK_IN_EP_NUM : BULK_OUT_EP_NUM;
+
+	if (is_in) {
+		epctl = DWC_REG_IN_EP_REG(ep_num);
+		daintmsk.ep.in = 1<<BULK_IN_EP_NUM; //ep1:BULK_IN
+	}
+	else{
+		epctl = DWC_REG_OUT_EP_REG(ep_num);
+		daintmsk.ep.out = 1<<BULK_OUT_EP_NUM;//ep2:BULK_OUT
+	}
+
+	depctl.d32 = dwc_read_reg32(epctl);
+	if (!depctl.b.usbactep) {
+		depctl.b.mps = BULK_EP_MPS;
+		depctl.b.eptype = 2;//BULK_STYLE
+		depctl.b.setd0pid = 1;
+		depctl.b.txfnum = 0;   //Non-Periodic TxFIFO
+		depctl.b.usbactep = 1;
+
+        dwc_write_reg32(epctl, depctl.d32);
+	}
+
+	dwc_modify_reg32(DWC_REG_DAINTMSK, 0, daintmsk.d32);
+
+	return 0;
+}
+
+void dwc_otg_power_off_phy(void)
+{
+	dwc_write_reg32(DWC_REG_PCGCCTL, 0xF);
+}
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd.h b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd.h
new file mode 100644
index 0000000..5b7a69e
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd.h
@@ -0,0 +1,2079 @@
+/* dwc controller pcd drivers header */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-24 @ Shanghai
+ * From synopsys head file
+ */
+
+#ifndef __DWC_PCD_H__
+#define __DWC_PCD_H__
+
+//#define USE_FULL_SPEED
+
+#define NUM_EP	4
+
+#define BULK_IN_EP_NUM		1
+#define BULK_OUT_EP_NUM	2
+
+#ifdef USE_FULL_SPEED
+#define BULK_EP_MPS	(64)		//only for full speed
+#else
+#define BULK_EP_MPS (512)
+#endif
+
+#define DWC_REG_GOTGCTL	0x000 /** OTG Control and Status Register.  <i>Offset: 000h</i> */
+#define DWC_REG_GOTGINT	0x004 /** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+#define DWC_REG_GAHBCFG	0x008 /**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+#define DWC_REG_GUSBCFG	0x00C /**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+#define DWC_REG_GRSTCTL	0x010 /**Core Reset Register.	 <i>Offset: 010h</i> */
+#define DWC_REG_GINTSTS	0x014 /**Core Interrupt Register.	 <i>Offset: 014h</i> */
+#define DWC_REG_GINTMSK	0x018 /**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+#define DWC_REG_GRXSTSR	0x01C /**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+#define DWC_REG_GRXSTSP	0x020 /**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+#define DWC_REG_GRXFSIZ	0x024 /**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+#define DWC_REG_GNPTXFSIZ	0x028 /**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+#define DWC_REG_GNPTXSTS	0x02C /**Non Periodic Transmit FIFO/Queue Status Register (Read  * Only). <i>Offset: 02Ch</i> */
+#define DWC_REG_GI2CCTL	0x030 /**I2C Access Register.	 <i>Offset: 030h</i> */
+#define DWC_REG_GPVNDCTL	0x034 /**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+#define DWC_REG_GGPIO		0x038 /**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+#define DWC_REG_GUID		0x03C /**User ID Register.  <i>Offset: 03Ch</i> */
+#define DWC_REG_GSNPSID	0x040 /**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+#define DWC_REG_GHWCFG1	0x044 /**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+#define DWC_REG_GHWCFG2	0x048 /**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+#define DWC_REG_GHWCFG3	0x04C /**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+#define DWC_REG_GHWCFG4	0x050 /**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+#define DWC_REG_HPTXFSIZ	0x100 /** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+
+/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled,
+		otherwise Device Transmit FIFO#n Register.
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+#define DWC_REG_DPTXFSIZ_DIEPTXF		0x104
+
+#define DWC_REG_DCFG	0x800 /** Device Configuration Register. <i>Offset 800h</i> */
+#define DWC_REG_DCTL	0x804 /** Device Control Register. <i>Offset: 804h</i> */
+#define DWC_REG_DSTS	0x808 /** Device Status Register (Read Only). <i>Offset: 808h</i> */
+#define DWC_REG_DIEPMSK	0x810 /** Device IN Endpoint Common Interrupt Mask Register. <i>Offset: 810h</i> */
+#define DWC_REG_DOEPMSK	0x814 /** Device OUT Endpoint Common Interrupt Mask Register. <i>Offset: 814h</i> */
+#define DWC_REG_DAINT	0x818 /** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+#define DWC_REG_DAINTMSK	0x81C /** Device All Endpoints Interrupt Mask Register.  <i>Offset: 81Ch</i> */
+#define DWC_REG_DTKNQR1	0x820 /** Device IN Token Queue Read Register-1 (Read Only). <i>Offset: 820h</i> */
+#define DWC_REG_DTKNQR2	0x824 /** Device IN Token Queue Read Register-2 (Read Only). <i>Offset: 824h</i> */
+#define DWC_REG_DVBUGDIS	0x828 /** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+#define DWC_REG_DVBUSPULSE	0x82C /** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+#define DWC_REG_DTKNQR3	0x830
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */
+#define DWC_REG_DTKNQR4	0x834
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */
+#define DWC_REG_PCGCCTL	0xE00 /** Power and Clock Gating Control Register */
+
+#define DWC_EP_REGS_OFFSET	0x00
+#define DWC_EP_INTR_OFFSET	0x08
+#define DWC_EP_TSIZE_OFFSET	0x10
+#define DWC_EP_DMA_OFFSET		0x14
+
+#define DWC_IN_EP_REG_START 0x900
+#define DWC_OUT_EP_REG_START 0xB00
+
+#define DWC_REG_IN_EP_REG(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_REGS_OFFSET)
+#define DWC_REG_IN_EP_INTR(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_INTR_OFFSET)
+#define DWC_REG_IN_EP_TSIZE(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_TSIZE_OFFSET)
+#define DWC_REG_IN_EP_DMA(x)	(DWC_IN_EP_REG_START + x*0x20 + DWC_EP_DMA_OFFSET)
+
+#define DWC_REG_OUT_EP_REG(x)		(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_REGS_OFFSET)
+#define DWC_REG_OUT_EP_INTR(x)	(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_INTR_OFFSET)
+#define DWC_REG_OUT_EP_TSIZE(x)	(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_TSIZE_OFFSET)
+#define DWC_REG_OUT_EP_DMA(x)	(DWC_OUT_EP_REG_START + x*0x20 + DWC_EP_DMA_OFFSET)
+
+
+#define DWC_REG_DATA_FIFO_START 0x1000
+#define DWC_REG_DATA_FIFO(ep)	(DWC_REG_DATA_FIFO_START + ep * 0x1000)
+
+/**
+ * The <code>dwc_ep</code> structure represents the state of a single
+ * endpoint when acting in device mode. It contains the data items
+ * needed for an endpoint to be activated and transfer packets.
+ */
+typedef struct dwc_ep {
+        /** EP number used for register address lookup */
+        uint8_t  num;
+        /** EP direction 0 = OUT */
+        unsigned is_in : 1;
+        /** EP active. */
+        unsigned active : 1;
+
+	  unsigned stopped : 1;
+	  unsigned disabling : 1;
+
+        /** Periodic Tx FIFO # for IN EPs For INTR EP set to 0 to use non-periodic Tx FIFO */
+        unsigned tx_fifo_num : 4;
+        /** EP type: 0 - Control, 1 - ISOC,  2 - BULK,  3 - INTR */
+        unsigned type : 2;
+#define DWC_OTG_EP_TYPE_CONTROL    0
+#define DWC_OTG_EP_TYPE_ISOC       1
+#define DWC_OTG_EP_TYPE_BULK       2
+#define DWC_OTG_EP_TYPE_INTR       3
+
+        /** DATA start PID for INTR and BULK EP */
+        unsigned data_pid_start : 1;
+        /** Frame (even/odd) for ISOC EP */
+        unsigned even_odd_frame : 1;
+        /** Max Packet bytes */
+        unsigned maxpacket : 11;
+
+        /** @name Transfer state */
+	/** @{ */
+
+	/**
+	 * Pointer to the beginning of the transfer buffer -- do not modify
+	 * during transfer.
+	 */
+
+	uint32_t dma_addr;
+
+	uint8_t *start_xfer_buff;
+        /** pointer to the transfer buffer */
+        uint8_t *xfer_buff;
+        /** Number of bytes to transfer */
+        unsigned xfer_len : 19;
+        /** Number of bytes transferred. */
+        unsigned xfer_count : 19;
+        /** Sent ZLP */
+        unsigned sent_zlp : 1;
+        /** Total len for control transfer */
+        unsigned total_len : 19;
+
+	/** @} */
+} dwc_ep_t;
+
+typedef struct pcd_struct_s{
+	 /** SETUP packet for EP0
+	 * This structure is allocated as a DMA buffer on PCD initialization
+	 * with enough space for up to 3 setup packets.
+	 */
+    union {
+        struct usb_ctrlrequest	req;
+        uint32_t	d32[2];
+    }setup_pkt;
+	 int ep0state;
+
+	 /* for USB_REQ_GET_STATUS */
+	 unsigned status;
+
+     struct {
+         u8     type;//1-->setup+out+in, others: reseved
+         u8     setup_complete;
+         u8     out_complete;
+         u8     in_complete;
+     }cmdtype;
+
+	  /* request */
+	 volatile char * buf;
+
+	 int length;
+
+	  /* bulk req */
+	 char * bulk_buf;
+	 int bulk_len;		// one bulk transfer length
+	 int bulk_num;	// number of bulk transfer
+	 int bulk_data_len;// data len of all data
+	 int xfer_len;
+	 char bulk_out;	// flag
+	 char bulk_lock;	// bulk transfering
+	 //short bulk_seq;
+
+     short isPktResended;//is this 64K transfer is re-send
+     int bulk_xfer_len;//data len already transferred //added by Sam.Wu
+     unsigned origiSum;//data checksum in every 64K transfer //added by Sam.Wu
+     unsigned sequenceNo;
+     int      xferNeedReply;
+
+	 unsigned request_config : 1;
+	 unsigned request_enable : 1;
+     unsigned request_reserv : 30;
+
+}pcd_struct_t;
+
+extern pcd_struct_t this_pcd;
+extern dwc_ep_t g_dwc_eps[NUM_EP];
+
+/**
+ * @file
+ *
+ * This file contains the data structures for accessing the DWC_otg core registers.
+ *
+ * The application interfaces with the HS OTG core by reading from and
+ * writing to the Control and Status Register (CSR) space through the
+ * AHB Slave interface. These registers are 32 bits wide, and the
+ * addresses are 32-bit-block aligned.
+ * CSRs are classified as follows:
+ * - Core Global Registers
+ * - Device Mode Registers
+ * - Device Global Registers
+ * - Device Endpoint Specific Registers
+ * - Host Mode Registers
+ * - Host Global Registers
+ * - Host Port CSRs
+ * - Host Channel Specific Registers
+ *
+ * Only the Core Global registers can be accessed in both Device and
+ * Host modes. When the HS OTG core is operating in one mode, either
+ * Device or Host, the application must not access registers from the
+ * other mode. When the core switches from one mode to another, the
+ * registers in the new mode of operation must be reprogrammed as they
+ * would be after a power-on reset.
+ */
+
+/****************************************************************************/
+/** DWC_otg Core registers .
+ * The dwc_otg_core_global_regs structure defines the size
+ * and relative field offsets for the Core Global registers.
+ */
+typedef struct dwc_otg_core_global_regs
+{
+	/** OTG Control and Status Register.  <i>Offset: 000h</i> */
+	volatile uint32_t gotgctl;
+	/** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+	volatile uint32_t gotgint;
+	/**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+	volatile uint32_t gahbcfg;
+
+#define DWC_GLBINTRMASK		0x0001
+#define DWC_DMAENABLE		0x0020
+#define DWC_NPTXEMPTYLVL_EMPTY	0x0080
+#define DWC_NPTXEMPTYLVL_HALFEMPTY	0x0000
+#define DWC_PTXEMPTYLVL_EMPTY	0x0100
+#define DWC_PTXEMPTYLVL_HALFEMPTY	0x0000
+
+	/**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+	volatile uint32_t gusbcfg;
+	/**Core Reset Register.	 <i>Offset: 010h</i> */
+	volatile uint32_t grstctl;
+	/**Core Interrupt Register.	 <i>Offset: 014h</i> */
+	volatile uint32_t gintsts;
+	/**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+	volatile uint32_t gintmsk;
+	/**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+	volatile uint32_t grxstsr;
+	/**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+	volatile uint32_t grxstsp;
+	/**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+	volatile uint32_t grxfsiz;
+	/**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+	volatile uint32_t gnptxfsiz;
+	/**Non Periodic Transmit FIFO/Queue Status Register (Read
+	 * Only). <i>Offset: 02Ch</i> */
+	volatile uint32_t gnptxsts;
+	/**I2C Access Register.	 <i>Offset: 030h</i> */
+	volatile uint32_t gi2cctl;
+	/**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+	volatile uint32_t gpvndctl;
+	/**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+	volatile uint32_t ggpio;
+	/**User ID Register.  <i>Offset: 03Ch</i> */
+	volatile uint32_t guid;
+	/**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+	volatile uint32_t gsnpsid;
+	/**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+	volatile uint32_t ghwcfg1;
+	/**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+	volatile uint32_t ghwcfg2;
+#define DWC_SLAVE_ONLY_ARCH 0
+#define DWC_EXT_DMA_ARCH 1
+#define DWC_INT_DMA_ARCH 2
+
+#define DWC_MODE_HNP_SRP_CAPABLE	0
+#define DWC_MODE_SRP_ONLY_CAPABLE	1
+#define DWC_MODE_NO_HNP_SRP_CAPABLE		2
+#define DWC_MODE_SRP_CAPABLE_DEVICE		3
+#define DWC_MODE_NO_SRP_CAPABLE_DEVICE	4
+#define DWC_MODE_SRP_CAPABLE_HOST	5
+#define DWC_MODE_NO_SRP_CAPABLE_HOST	6
+
+	/**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+	volatile uint32_t ghwcfg3;
+	/**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+	volatile uint32_t ghwcfg4;
+	/** Core LPM Configuration register <i>Offset: 054h</i>*/
+	volatile uint32_t glpmcfg;
+	/** Global PowerDn Register <i>Offset: 058h</i> */
+	volatile uint32_t gpwrdn;
+	/** Global DFIFO SW Config Register  <i>Offset: 05Ch</i> */
+	volatile uint32_t gdfifocfg;
+	/** ADP Control Register  <i>Offset: 060h</i> */
+	volatile uint32_t adpctl;
+	/** Reserved  <i>Offset: 064h-0FFh</i> */
+	volatile uint32_t reserved39[39];
+	/** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+	volatile uint32_t hptxfsiz;
+	/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled,
+		otherwise Device Transmit FIFO#n Register.
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+	volatile uint32_t dptxfsiz_dieptxf[15];
+} dwc_otg_core_global_regs_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Control
+ * and Status Register (GOTGCTL).  Set the bits using the bit
+ * fields then write the <i>d32</i> value to the register.
+ */
+typedef union gotgctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned sesreqscs : 1;
+		unsigned sesreq : 1;
+		unsigned reserved2_7 : 6;
+		unsigned hstnegscs : 1;
+		unsigned hnpreq : 1;
+		unsigned hstsethnpen : 1;
+		unsigned devhnpen : 1;
+		unsigned reserved12_15 : 4;
+		unsigned conidsts : 1;
+		unsigned reserved17 : 1;
+		unsigned asesvld : 1;
+		unsigned bsesvld : 1;
+		unsigned currmod : 1;
+		unsigned reserved21_31 : 11;
+	} b;
+} gotgctl_data_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Interrupt Register
+ * (GOTGINT).  Set/clear the bits using the bit fields then write the <i>d32</i>
+ * value to the register.
+ */
+typedef union gotgint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Current Mode */
+		unsigned reserved0_1 : 2;
+
+		/** Session End Detected */
+		unsigned sesenddet : 1;
+
+		unsigned reserved3_7 : 5;
+
+		/** Session Request Success Status Change */
+		unsigned sesreqsucstschng : 1;
+		/** Host Negotiation Success Status Change */
+		unsigned hstnegsucstschng : 1;
+
+		unsigned reserver10_16 : 7;
+
+		/** Host Negotiation Detected */
+		unsigned hstnegdet : 1;
+		/** A-Device Timeout Change */
+		unsigned adevtoutchng : 1;
+		/** Debounce Done */
+		unsigned debdone : 1;
+
+		unsigned reserved31_20 : 12;
+
+	} b;
+} gotgint_data_t;
+
+
+/**
+ * This union represents the bit fields of the Core AHB Configuration
+ * Register (GAHBCFG).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gahbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned glblintrmsk : 1;
+#define DWC_GAHBCFG_GLBINT_ENABLE		1
+
+		unsigned hburstlen : 4;
+#define DWC_GAHBCFG_INT_DMA_BURST_SINGLE	0
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR		1
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR4		3
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR8		5
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR16	7
+
+		unsigned dmaenable : 1;
+#define DWC_GAHBCFG_DMAENABLE			1
+		unsigned reserved : 1;
+		unsigned nptxfemplvl_txfemplvl : 1;
+		unsigned ptxfemplvl : 1;
+#define DWC_GAHBCFG_TXFEMPTYLVL_EMPTY		1
+#define DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY	0
+		unsigned reserved9_31 : 23;
+	} b;
+} gahbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core USB Configuration
+ * Register (GUSBCFG).	Set the bits using the bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union gusbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned toutcal : 3;
+		unsigned phyif : 1;
+		unsigned ulpi_utmi_sel : 1;
+		unsigned fsintf : 1;
+		unsigned physel : 1;
+		unsigned ddrsel : 1;
+		unsigned srpcap : 1;
+		unsigned hnpcap : 1;
+		unsigned usbtrdtim : 4;
+		unsigned nptxfrwnden : 1;
+		unsigned phylpwrclksel : 1;
+		unsigned otgutmifssel : 1;
+		unsigned ulpi_fsls : 1;
+		unsigned ulpi_auto_res : 1;
+		unsigned ulpi_clk_sus_m : 1;
+		unsigned ulpi_ext_vbus_drv : 1;
+		unsigned ulpi_int_vbus_indicator : 1;
+		unsigned term_sel_dl_pulse : 1;
+		unsigned reserved : 9;
+	} b;
+} gusbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core Reset Register
+ * (GRSTCTL).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union grstctl_data
+{
+	/** raw register data */
+	unsigned int d32;
+	/** register bits */
+	struct
+	{
+		/** Core Soft Reset (CSftRst) (Device and Host)
+		 *
+		 * The application can flush the control logic in the
+		 * entire core using this bit. This bit resets the
+		 * pipelines in the AHB Clock domain as well as the
+		 * PHY Clock domain.
+		 *
+		 * The state machines are reset to an IDLE state, the
+		 * control bits in the CSRs are cleared, all the
+		 * transmit FIFOs and the receive FIFO are flushed.
+		 *
+		 * The status mask bits that control the generation of
+		 * the interrupt, are cleared, to clear the
+		 * interrupt. The interrupt status bits are not
+		 * cleared, so the application can get the status of
+		 * any events that occurred in the core after it has
+		 * set this bit.
+		 *
+		 * Any transactions on the AHB are terminated as soon
+		 * as possible following the protocol. Any
+		 * transactions on the USB are terminated immediately.
+		 *
+		 * The configuration settings in the CSRs are
+		 * unchanged, so the software doesn't have to
+		 * reprogram these registers (Device
+		 * Configuration/Host Configuration/Core System
+		 * Configuration/Core PHY Configuration).
+		 *
+		 * The application can write to this bit, any time it
+		 * wants to reset the core. This is a self clearing
+		 * bit and the core clears this bit after all the
+		 * necessary logic is reset in the core, which may
+		 * take several clocks, depending on the current state
+		 * of the core.
+		 */
+		unsigned csftrst : 1;
+		/** Hclk Soft Reset
+		 *
+		 * The application uses this bit to reset the control logic in
+		 * the AHB clock domain. Only AHB clock domain pipelines are
+		 * reset.
+		 */
+		unsigned hsftrst : 1;
+		/** Host Frame Counter Reset (Host Only)<br>
+		 *
+		 * The application can reset the (micro)frame number
+		 * counter inside the core, using this bit. When the
+		 * (micro)frame counter is reset, the subsequent SOF
+		 * sent out by the core, will have a (micro)frame
+		 * number of 0.
+		 */
+		unsigned hstfrm : 1;
+		/** In Token Sequence Learning Queue Flush
+		 * (INTknQFlsh) (Device Only)
+		 */
+		unsigned intknqflsh : 1;
+		/** RxFIFO Flush (RxFFlsh) (Device and Host)
+		 *
+		 * The application can flush the entire Receive FIFO
+		 * using this bit.	<p>The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is reading from the RxFIFO nor the MAC
+		 * is writing the data in to the FIFO.	<p>The
+		 * application should wait until the bit is cleared
+		 * before performing any other operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned rxfflsh : 1;
+		/** TxFIFO Flush (TxFFlsh) (Device and Host).
+		 *
+		 * This bit is used to selectively flush a single or
+		 * all transmit FIFOs.	The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is writing into the TxFIFO nor the MAC
+		 * is reading the data out of the FIFO.	 <p>The
+		 * application should wait until the core clears this
+		 * bit, before performing any operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned txfflsh : 1;
+
+		/** TxFIFO Number (TxFNum) (Device and Host).
+		 *
+		 * This is the FIFO number which needs to be flushed,
+		 * using the TxFIFO Flush bit. This field should not
+		 * be changed until the TxFIFO Flush bit is cleared by
+		 * the core.
+		 *	 - 0x0 : Non Periodic TxFIFO Flush
+		 *	 - 0x1 : Periodic TxFIFO #1 Flush in device mode
+		 *	   or Periodic TxFIFO in host mode
+		 *	 - 0x2 : Periodic TxFIFO #2 Flush in device mode.
+		 *	 - ...
+		 *	 - 0xF : Periodic TxFIFO #15 Flush in device mode
+		 *	 - 0x10: Flush all the Transmit NonPeriodic and
+		 *	   Transmit Periodic FIFOs in the core
+		 */
+		unsigned txfnum : 5;
+		/** Reserved */
+		unsigned reserved11_29 : 19;
+		/** DMA Request Signal.	 Indicated DMA request is in
+		 * probress.  Used for debug purpose. */
+		unsigned dmareq : 1;
+		/** AHB Master Idle.  Indicates the AHB Master State
+		 * Machine is in IDLE condition. */
+		unsigned ahbidle : 1;
+	} b;
+} grstctl_t;
+
+
+/**
+ * This union represents the bit fields of the Core Interrupt Mask
+ * Register (GINTMSK).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned reserved0 : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned reserved16 : 1;
+		unsigned epmismatch : 1;
+		unsigned inepintr : 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintmsk_data_t;
+/**
+ * This union represents the bit fields of the Core Interrupt Register
+ * (GINTSTS).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union gintsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+#define DWC_SOF_INTR_MASK 0x0008
+	/** register bits */
+	struct
+	{
+#define DWC_HOST_MODE 1
+		unsigned curmode : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned intokenrx : 1;
+		unsigned epmismatch : 1;
+		unsigned inepint: 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union device_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned epnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+#define DWC_STS_DATA_UPDT		0x2				  // OUT Data Packet
+#define DWC_STS_XFER_COMP		0x3				  // OUT Data Transfer Complete
+
+#define DWC_DSTS_GOUT_NAK		0x1				  // Global OUT NAK
+#define DWC_DSTS_SETUP_COMP		0x4				  // Setup Phase Complete
+#define DWC_DSTS_SETUP_UPDT 0x6				  // SETUP Packet
+		unsigned pktsts : 4;
+		unsigned fn : 4;
+		unsigned reserved : 7;
+	} b;
+} device_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union host_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned chnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+		unsigned pktsts : 4;
+#define DWC_GRXSTS_PKTSTS_IN			  0x2
+#define DWC_GRXSTS_PKTSTS_IN_XFER_COMP	  0x3
+#define DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR 0x5
+#define DWC_GRXSTS_PKTSTS_CH_HALTED		  0x7
+
+		unsigned reserved : 11;
+	} b;
+} host_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the FIFO Size Registers (HPTXFSIZ,
+ * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element then
+ * read out the bits using the <i>b</i>it elements.
+ */
+typedef union fifosize_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned startaddr : 16;
+		unsigned depth : 16;
+	} b;
+} fifosize_data_t;
+
+/**
+ * This union represents the bit fields in the Non-Periodic Transmit
+ * FIFO/Queue Status Register (GNPTXSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union gnptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned nptxfspcavail : 16;
+		unsigned nptxqspcavail : 8;
+		/** Top of the Non-Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (Last entry for the selected
+		 *	  channel/EP)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - IN/OUT
+		 *	  - 2'b01 - Zero Length OUT
+		 *	  - 2'b10 - PING/Complete Split
+		 *	  - 2'b11 - Channel Halt
+		 *	- bits 30:27 - Channel/EP Number
+		 */
+		unsigned nptxqtop_terminate : 1;
+		unsigned nptxqtop_token : 2;
+		unsigned nptxqtop_chnep : 4;
+		unsigned reserved : 1;
+	} b;
+} gnptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Transmit
+ * FIFO Status Register (DTXFSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union dtxfsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned txfspcavail : 16;
+		unsigned reserved : 16;
+	} b;
+} dtxfsts_data_t;
+
+/**
+ * This union represents the bit fields in the I2C Control Register
+ * (I2CCTL). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gi2cctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned rwdata : 8;
+		unsigned regaddr : 8;
+		unsigned addr : 7;
+		unsigned i2cen : 1;
+		unsigned ack : 1;
+		unsigned i2csuspctl : 1;
+		unsigned i2cdevaddr : 2;
+		unsigned reserved : 2;
+		unsigned rw : 1;
+		unsigned bsydne : 1;
+	} b;
+} gi2cctl_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config1
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ep_dir0 : 2;
+		unsigned ep_dir1 : 2;
+		unsigned ep_dir2 : 2;
+		unsigned ep_dir3 : 2;
+		unsigned ep_dir4 : 2;
+		unsigned ep_dir5 : 2;
+		unsigned ep_dir6 : 2;
+		unsigned ep_dir7 : 2;
+		unsigned ep_dir8 : 2;
+		unsigned ep_dir9 : 2;
+		unsigned ep_dir10 : 2;
+		unsigned ep_dir11 : 2;
+		unsigned ep_dir12 : 2;
+		unsigned ep_dir13 : 2;
+		unsigned ep_dir14 : 2;
+		unsigned ep_dir15 : 2;
+	} b;
+} hwcfg1_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config2
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg2_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG2 */
+		unsigned op_mode : 3;
+#define DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG 0
+#define DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG 1
+#define DWC_HWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE_OTG 2
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE 3
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE 4
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST 5
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST 6
+
+		unsigned architecture : 2;
+		unsigned point2point : 1;
+		unsigned hs_phy_type : 2;
+#define DWC_HWCFG2_HS_PHY_TYPE_NOT_SUPPORTED 0
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI 1
+#define DWC_HWCFG2_HS_PHY_TYPE_ULPI 2
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI 3
+
+		unsigned fs_phy_type : 2;
+		unsigned num_dev_ep : 4;
+		unsigned num_host_chan : 4;
+		unsigned perio_ep_supported : 1;
+		unsigned dynamic_fifo : 1;
+		unsigned rx_status_q_depth : 2;
+		unsigned nonperio_tx_q_depth : 2;
+		unsigned host_perio_tx_q_depth : 2;
+		unsigned dev_token_q_depth : 5;
+		unsigned reserved31 : 1;
+	} b;
+} hwcfg2_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config3
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg3_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG3 */
+		unsigned xfer_size_cntr_width : 4;
+		unsigned packet_size_cntr_width : 3;
+		unsigned otg_func : 1;
+		unsigned i2c : 1;
+		unsigned vendor_ctrl_if : 1;
+		unsigned optional_features : 1;
+		unsigned synch_reset_type : 1;
+		unsigned ahb_phy_clock_synch : 1;
+		unsigned reserved15_13 : 3;
+		unsigned dfifo_depth : 16;
+	} b;
+} hwcfg3_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config4
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg4_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned num_dev_perio_in_ep : 4;
+		unsigned power_optimiz : 1;
+		unsigned min_ahb_freq : 9;
+		unsigned utmi_phy_data_width : 2;
+		unsigned num_dev_mode_ctrl_ep : 4;
+		unsigned iddig_filt_en : 1;
+		unsigned vbus_valid_filt_en : 1;
+		unsigned a_valid_filt_en : 1;
+		unsigned b_valid_filt_en : 1;
+		unsigned session_end_filt_en : 1;
+		unsigned ded_fifo_en : 1;
+		unsigned num_in_eps : 4;
+		unsigned reserved31_30 : 2;
+	} b;
+} hwcfg4_data_t;
+
+////////////////////////////////////////////
+// Device Registers
+/**
+ * Device Global Registers. <i>Offsets 800h-BFFh</i>
+ *
+ * The following structures define the size and relative field offsets
+ * for the Device Mode Registers.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_global_regs
+{
+	/** Device Configuration Register. <i>Offset 800h</i> */
+	volatile uint32_t dcfg;
+	/** Device Control Register. <i>Offset: 804h</i> */
+	volatile uint32_t dctl;
+	/** Device Status Register (Read Only). <i>Offset: 808h</i> */
+	volatile uint32_t dsts;
+	/** Reserved. <i>Offset: 80Ch</i> */
+	uint32_t unused;
+	/** Device IN Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 810h</i> */
+	volatile uint32_t diepmsk;
+	/** Device OUT Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 814h</i> */
+	volatile uint32_t doepmsk;
+	/** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+	volatile uint32_t daint;
+	/** Device All Endpoints Interrupt Mask Register.  <i>Offset:
+	 * 81Ch</i> */
+	volatile uint32_t daintmsk;
+	/** Device IN Token Queue Read Register-1 (Read Only).
+	 * <i>Offset: 820h</i> */
+	volatile uint32_t dtknqr1;
+	/** Device IN Token Queue Read Register-2 (Read Only).
+	 * <i>Offset: 824h</i> */
+	volatile uint32_t dtknqr2;
+	/** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+	volatile uint32_t dvbusdis;
+	/** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+	volatile uint32_t dvbuspulse;
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */
+	volatile uint32_t dtknqr3_dthrctl;
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */
+	volatile uint32_t dtknqr4_fifoemptymsk;
+} dwc_otg_device_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Device Configuration
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.  Write the
+ * <i>d32</i> member to the dcfg register.
+ */
+typedef union dcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Device Speed */
+		unsigned devspd : 2;
+		/** Non Zero Length Status OUT Handshake */
+		unsigned nzstsouthshk : 1;
+#define DWC_DCFG_SEND_STALL 1
+
+		unsigned reserved3 : 1;
+		/** Device Addresses */
+		unsigned devaddr : 7;
+		/** Periodic Frame Interval */
+		unsigned perfrint : 2;
+#define DWC_DCFG_FRAME_INTERVAL_80 0
+#define DWC_DCFG_FRAME_INTERVAL_85 1
+#define DWC_DCFG_FRAME_INTERVAL_90 2
+#define DWC_DCFG_FRAME_INTERVAL_95 3
+
+		unsigned reserved13_17 : 5;
+		/** In Endpoint Mis-match count */
+		unsigned epmscnt : 4;
+	} b;
+} dcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Device Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Remote Wakeup */
+		unsigned rmtwkupsig : 1;
+		/** Soft Disconnect */
+		unsigned sftdiscon : 1;
+		/** Global Non-Periodic IN NAK Status */
+		unsigned gnpinnaksts : 1;
+		/** Global OUT NAK Status */
+		unsigned goutnaksts : 1;
+		/** Test Control */
+		unsigned tstctl : 3;
+		/** Set Global Non-Periodic IN NAK */
+		unsigned sgnpinnak : 1;
+		/** Clear Global Non-Periodic IN NAK */
+		unsigned cgnpinnak : 1;
+		/** Set Global OUT NAK */
+		unsigned sgoutnak : 1;
+		/** Clear Global OUT NAK */
+		unsigned cgoutnak : 1;
+
+		unsigned reserved : 21;
+	} b;
+} dctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device Status
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Suspend Status */
+		unsigned suspsts : 1;
+		/** Enumerated Speed */
+		unsigned enumspd : 2;
+#define DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ 0
+#define DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ 1
+#define DWC_DSTS_ENUMSPD_LS_PHY_6MHZ		   2
+#define DWC_DSTS_ENUMSPD_FS_PHY_48MHZ		   3
+		/** Erratic Error */
+		unsigned errticerr : 1;
+		unsigned reserved4_7: 4;
+		/** Frame or Microframe Number of the received SOF */
+		unsigned soffn : 14;
+		unsigned reserved22_31 : 10;
+	} b;
+} dsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device IN EP Interrupt
+ * Register and the Device IN EP Common Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union diepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete mask */
+		unsigned xfercompl : 1;
+		/** Endpoint disable mask */
+		unsigned epdisabled : 1;
+		/** AHB Error mask */
+		unsigned ahberr : 1;
+		/** TimeOUT Handshake mask (non-ISOC EPs) */
+		unsigned timeout : 1;
+		/** IN Token received with TxF Empty mask */
+		unsigned intktxfemp : 1;
+		/** IN Token Received with EP mismatch mask */
+		unsigned intknepmis : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned inepnakeff : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned emptyintr : 1;
+
+		unsigned txfifoundrn : 1;
+
+		unsigned reserved08_31 : 23;
+		} b;
+} diepint_data_t;
+/**
+ * This union represents the bit fields in the Device IN EP Common
+ * Interrupt Mask Register.
+ */
+typedef union diepint_data diepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP Interrupt
+ * Registerand Device OUT EP Common Interrupt Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union doepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete */
+		unsigned xfercompl : 1;
+		/** Endpoint disable  */
+		unsigned epdisabled : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** Setup Phase Done (contorl EPs) */
+		unsigned setup : 1;
+		unsigned reserved04_31 : 28;
+	} b;
+} doepint_data_t;
+/**
+ * This union represents the bit fields in the Device OUT EP Common
+ * Interrupt Mask Register.
+ */
+typedef union doepint_data doepmsk_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device All EP Interrupt
+ * and Mask Registers.
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union daint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned in : 16;
+		/** OUT Endpoint bits */
+		unsigned out : 16;
+	} ep;
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned inep0	: 1;
+		unsigned inep1	: 1;
+		unsigned inep2	: 1;
+		unsigned inep3	: 1;
+		unsigned inep4	: 1;
+		unsigned inep5	: 1;
+		unsigned inep6	: 1;
+		unsigned inep7	: 1;
+		unsigned inep8	: 1;
+		unsigned inep9	: 1;
+		unsigned inep10 : 1;
+		unsigned inep11 : 1;
+		unsigned inep12 : 1;
+		unsigned inep13 : 1;
+		unsigned inep14 : 1;
+		unsigned inep15 : 1;
+		/** OUT Endpoint bits */
+		unsigned outep0	 : 1;
+		unsigned outep1	 : 1;
+		unsigned outep2	 : 1;
+		unsigned outep3	 : 1;
+		unsigned outep4	 : 1;
+		unsigned outep5	 : 1;
+		unsigned outep6	 : 1;
+		unsigned outep7	 : 1;
+		unsigned outep8	 : 1;
+		unsigned outep9	 : 1;
+		unsigned outep10 : 1;
+		unsigned outep11 : 1;
+		unsigned outep12 : 1;
+		unsigned outep13 : 1;
+		unsigned outep14 : 1;
+		unsigned outep15 : 1;
+	} b;
+} daint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN Token Queue
+ * Read Registers.
+ * - Read the register into the <i>d32</i> member.
+ * - READ-ONLY Register
+ */
+typedef union dtknq1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** In Token Queue Write Pointer */
+		unsigned intknwptr : 5;
+		/** Reserved */
+		unsigned reserved05_06 : 2;
+		/** write pointer has wrapped. */
+		unsigned wrap_bit : 1;
+		/** EP Numbers of IN Tokens 0 ... 4 */
+		unsigned epnums0_5 : 24;
+	}b;
+} dtknq1_data_t;
+
+/**
+ * This union represents Threshold control Register
+ * - Read and write the register into the <i>d32</i> member.
+ * - READ-WRITABLE Register
+ */
+typedef union dthrctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** non ISO Tx Thr. Enable */
+		unsigned non_iso_thr_en : 1;
+		/** ISO Tx Thr. Enable */
+		unsigned iso_thr_en : 1;
+		/** Tx Thr. Length */
+		unsigned tx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved11_15 : 5;
+		/** Rx Thr. Enable */
+		unsigned rx_thr_en : 1;
+		/** Rx Thr. Length */
+		unsigned rx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved26_31 : 6;
+	}b;
+} dthrctl_data_t;
+
+
+/**
+ * Device Logical IN Endpoint-Specific Registers. <i>Offsets
+ * 900h-AFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_in_ep_regs
+{
+	/** Device IN Endpoint Control Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t diepctl;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 04h</i> */
+	uint32_t reserved04;
+	/** Device IN Endpoint Interrupt Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t diepint;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device IN Endpoint Transfer Size
+	 * Register. <i>Offset:900h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t dieptsiz;
+	/** Device IN Endpoint DMA Address Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 14h</i> */
+	volatile uint32_t diepdma;
+	/** Device IN Endpoint Transmit FIFO Status Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 18h</i> */
+	volatile uint32_t dtxfsts;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 1Ch - 900h +
+	 * (ep_num * 20h) + 1Ch</i>*/
+	uint32_t reserved18;
+} dwc_otg_dev_in_ep_regs_t;
+
+/**
+ * Device Logical OUT Endpoint-Specific Registers. <i>Offsets:
+ * B00h-CFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_out_ep_regs
+{
+	/** Device OUT Endpoint Control Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t doepctl;
+	/** Device OUT Endpoint Frame number Register.	<i>Offset:
+	 * B00h + (ep_num * 20h) + 04h</i> */
+	volatile uint32_t doepfn;
+	/** Device OUT Endpoint Interrupt Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t doepint;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device OUT Endpoint Transfer Size Register. <i>Offset:
+	 * B00h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t doeptsiz;
+	/** Device OUT Endpoint DMA Address Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 14h</i> */
+	volatile uint32_t doepdma;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 18h - B00h +
+	 * (ep_num * 20h) + 1Ch</i> */
+	uint32_t unused[2];
+} dwc_otg_dev_out_ep_regs_t;
+
+/**
+ * This union represents the bit fields in the Device EP Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union depctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Maximum Packet Size
+		 * IN/OUT EPn
+		 * IN/OUT EP0 - 2 bits
+		 *	 2'b00: 64 Bytes
+		 *	 2'b01: 32
+		 *	 2'b10: 16
+		 *	 2'b11: 8 */
+		unsigned mps : 11;
+#define DWC_DEP0CTL_MPS_64	 0
+#define DWC_DEP0CTL_MPS_32	 1
+#define DWC_DEP0CTL_MPS_16	 2
+#define DWC_DEP0CTL_MPS_8	 3
+
+		/** Next Endpoint
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned nextep : 4;
+
+		/** USB Active Endpoint */
+		unsigned usbactep : 1;
+
+		/** Endpoint DPID (INTR/Bulk IN and OUT endpoints)
+		 * This field contains the PID of the packet going to
+		 * be received or transmitted on this endpoint. The
+		 * application should program the PID of the first
+		 * packet going to be received or transmitted on this
+		 * endpoint , after the endpoint is
+		 * activated. Application use the SetD1PID and
+		 * SetD0PID fields of this register to program either
+		 * D0 or D1 PID.
+		 *
+		 * The encoding for this field is
+		 *	 - 0: D0
+		 *	 - 1: D1
+		 */
+		unsigned dpid : 1;
+
+		/** NAK Status */
+		unsigned naksts : 1;
+
+		/** Endpoint Type
+		 *	2'b00: Control
+		 *	2'b01: Isochronous
+		 *	2'b10: Bulk
+		 *	2'b11: Interrupt */
+		unsigned eptype : 2;
+
+		/** Snoop Mode
+		 * OUT EPn/OUT EP0
+		 * IN EPn/IN EP0 - reserved */
+		unsigned snp : 1;
+
+		/** Stall Handshake */
+		unsigned stall : 1;
+
+		/** Tx Fifo Number
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned txfnum : 4;
+
+		/** Clear NAK */
+		unsigned cnak : 1;
+		/** Set NAK */
+		unsigned snak : 1;
+		/** Set DATA0 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA0. Set Even
+		 * (micro)frame (SetEvenFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to even (micro)
+		 * frame.
+		 */
+		unsigned setd0pid : 1;
+		/** Set DATA1 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA1 Set Odd
+		 * (micro)frame (SetOddFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to odd (micro) frame.
+		 */
+		unsigned setd1pid : 1;
+
+		/** Endpoint Disable */
+		unsigned epdis : 1;
+		/** Endpoint Enable */
+		unsigned epena : 1;
+		} b;
+} depctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 19;
+		/** Packet Count */
+		unsigned pktcnt : 10;
+		/** Multi Count - Periodic IN endpoints */
+		unsigned mc : 2;
+		unsigned reserved : 1;
+		} b;
+} deptsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP 0 Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz0_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 7;
+				/** Reserved */
+				unsigned reserved7_18 : 12;
+		/** Packet Count */
+		unsigned pktcnt : 1;
+				/** Reserved */
+		unsigned reserved20_28 : 9;
+				/**Setup Packet Count (DOEPTSIZ0 Only) */
+				unsigned supcnt : 2;
+				unsigned reserved31;
+		} b;
+} deptsiz0_data_t;
+
+
+/** Maximum number of Periodic FIFOs */
+#define MAX_PERIO_FIFOS 15
+/** Maximum number of Periodic FIFOs */
+#define MAX_TX_FIFOS 15
+
+/** Maximum number of Endpoints/HostChannels */
+#define MAX_EPS_CHANNELS 16
+
+/**
+ * The dwc_otg_dev_if structure contains information needed to manage
+ * the DWC_otg controller acting in device mode. It represents the
+ * programming view of the device-specific aspects of the controller.
+ */
+typedef struct dwc_otg_dev_if
+{
+	/** Pointer to device Global registers.
+	 * Device Global Registers starting at offset 800h
+	 */
+	dwc_otg_device_global_regs_t *dev_global_regs;
+#define DWC_DEV_GLOBAL_REG_OFFSET 0x800
+
+	/**
+	 * Device Logical IN Endpoint-Specific Registers 900h-AFCh
+	 */
+	dwc_otg_dev_in_ep_regs_t	 *in_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_IN_EP_REG_OFFSET 0x900
+#define DWC_EP_REG_OFFSET 0x20
+
+	/** Device Logical OUT Endpoint-Specific Registers B00h-CFCh */
+	dwc_otg_dev_out_ep_regs_t	 *out_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_OUT_EP_REG_OFFSET 0xB00
+
+	/* Device configuration information*/
+	uint8_t	 speed;				 /**< Device Speed	0: Unknown, 1: LS, 2:FS, 3: HS */
+	uint8_t	 num_in_eps;		 /**< Number # of Tx EP range: 0-15 exept ep0 */
+	uint8_t	 num_out_eps;		 /**< Number # of Rx EP range: 0-15 exept ep 0*/
+
+	/** Size of periodic FIFOs (Bytes) */
+	uint16_t perio_tx_fifo_size[MAX_PERIO_FIFOS];
+
+	/** Size of Tx FIFOs (Bytes) */
+	uint16_t tx_fifo_size[MAX_TX_FIFOS];
+
+	/** Thresholding enable flags and length varaiables **/
+	uint16_t rx_thr_en;
+	uint16_t iso_tx_thr_en;
+	uint16_t non_iso_tx_thr_en;
+
+	uint16_t rx_thr_length;
+	uint16_t tx_thr_length;
+
+} dwc_otg_dev_if_t;
+
+
+
+
+/////////////////////////////////////////////////
+// Host Mode Register Structures
+//
+/**
+ * The Host Global Registers structure defines the size and relative
+ * field offsets for the Host Mode Global Registers.  Host Global
+ * Registers offsets 400h-7FFh.
+*/
+typedef struct dwc_otg_host_global_regs
+{
+	/** Host Configuration Register.   <i>Offset: 400h</i> */
+	volatile uint32_t hcfg;
+	/** Host Frame Interval Register.	<i>Offset: 404h</i> */
+	volatile uint32_t hfir;
+	/** Host Frame Number / Frame Remaining Register. <i>Offset: 408h</i> */
+	volatile uint32_t hfnum;
+	/** Reserved.	<i>Offset: 40Ch</i> */
+	uint32_t reserved40C;
+	/** Host Periodic Transmit FIFO/ Queue Status Register. <i>Offset: 410h</i> */
+	volatile uint32_t hptxsts;
+	/** Host All Channels Interrupt Register. <i>Offset: 414h</i> */
+	volatile uint32_t haint;
+	/** Host All Channels Interrupt Mask Register. <i>Offset: 418h</i> */
+	volatile uint32_t haintmsk;
+} dwc_otg_host_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Configuration Register.
+ * Read the register into the <i>d32</i> member then set/clear the bits using
+ * the <i>b</i>it elements. Write the <i>d32</i> member to the hcfg register.
+ */
+typedef union hcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** FS/LS Phy Clock Select */
+		unsigned fslspclksel : 2;
+#define DWC_HCFG_30_60_MHZ 0
+#define DWC_HCFG_48_MHZ	   1
+#define DWC_HCFG_6_MHZ	   2
+
+		/** FS/LS Only Support */
+		unsigned fslssupp : 1;
+		} b;
+} hcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfir_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frint : 16;
+		unsigned reserved : 16;
+	} b;
+} hfir_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfnum_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frnum : 16;
+#define DWC_HFNUM_MAX_FRNUM 0x3FFF
+		unsigned frrem : 16;
+	} b;
+} hfnum_data_t;
+
+typedef union hptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned ptxfspcavail : 16;
+		unsigned ptxqspcavail : 8;
+		/** Top of the Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (last entry for the selected channel)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - Zero length
+		 *	  - 2'b01 - Ping
+		 *	  - 2'b10 - Disable
+		 *	- bits 30:27 - Channel Number
+		 *	- bit 31 - Odd/even microframe
+		 */
+		unsigned ptxqtop_terminate : 1;
+		unsigned ptxqtop_token : 2;
+		unsigned ptxqtop_chnum : 4;
+		unsigned ptxqtop_odd : 1;
+	} b;
+} hptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Port Control and Status
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hprt0 register.
+ */
+typedef union hprt0_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned prtconnsts : 1;
+		unsigned prtconndet : 1;
+		unsigned prtena : 1;
+		unsigned prtenchng : 1;
+		unsigned prtovrcurract : 1;
+		unsigned prtovrcurrchng : 1;
+		unsigned prtres : 1;
+		unsigned prtsusp : 1;
+		unsigned prtrst : 1;
+		unsigned reserved9 : 1;
+		unsigned prtlnsts : 2;
+		unsigned prtpwr : 1;
+		unsigned prttstctl : 4;
+		unsigned prtspd : 2;
+#define DWC_HPRT0_PRTSPD_HIGH_SPEED 0
+#define DWC_HPRT0_PRTSPD_FULL_SPEED 1
+#define DWC_HPRT0_PRTSPD_LOW_SPEED	2
+		unsigned reserved19_31 : 13;
+	} b;
+} hprt0_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haint_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haintmsk_data_t;
+
+/**
+ * Host Channel Specific Registers. <i>500h-5FCh</i>
+ */
+typedef struct dwc_otg_hc_regs
+{
+	/** Host Channel 0 Characteristic Register. <i>Offset: 500h + (chan_num * 20h) + 00h</i> */
+	volatile uint32_t hcchar;
+	/** Host Channel 0 Split Control Register. <i>Offset: 500h + (chan_num * 20h) + 04h</i> */
+	volatile uint32_t hcsplt;
+	/** Host Channel 0 Interrupt Register. <i>Offset: 500h + (chan_num * 20h) + 08h</i> */
+	volatile uint32_t hcint;
+	/** Host Channel 0 Interrupt Mask Register. <i>Offset: 500h + (chan_num * 20h) + 0Ch</i> */
+	volatile uint32_t hcintmsk;
+	/** Host Channel 0 Transfer Size Register. <i>Offset: 500h + (chan_num * 20h) + 10h</i> */
+	volatile uint32_t hctsiz;
+	/** Host Channel 0 DMA Address Register. <i>Offset: 500h + (chan_num * 20h) + 14h</i> */
+	volatile uint32_t hcdma;
+	/** Reserved.  <i>Offset: 500h + (chan_num * 20h) + 18h - 500h + (chan_num * 20h) + 1Ch</i> */
+	uint32_t reserved[2];
+} dwc_otg_hc_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Characteristics
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hcchar_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Maximum packet size in bytes */
+		unsigned mps : 11;
+
+		/** Endpoint number */
+		unsigned epnum : 4;
+
+		/** 0: OUT, 1: IN */
+		unsigned epdir : 1;
+
+		unsigned reserved : 1;
+
+		/** 0: Full/high speed device, 1: Low speed device */
+		unsigned lspddev : 1;
+
+		/** 0: Control, 1: Isoc, 2: Bulk, 3: Intr */
+		unsigned eptype : 2;
+
+		/** Packets per frame for periodic transfers. 0 is reserved. */
+		unsigned multicnt : 2;
+
+		/** Device address */
+		unsigned devaddr : 7;
+
+		/**
+		 * Frame to transmit periodic transaction.
+		 * 0: even, 1: odd
+		 */
+		unsigned oddfrm : 1;
+
+		/** Channel disable */
+		unsigned chdis : 1;
+
+		/** Channel enable */
+		unsigned chen : 1;
+	} b;
+} hcchar_data_t;
+
+typedef union hcsplt_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Port Address */
+		unsigned prtaddr : 7;
+
+		/** Hub Address */
+		unsigned hubaddr : 7;
+
+		/** Transaction Position */
+		unsigned xactpos : 2;
+#define DWC_HCSPLIT_XACTPOS_MID 0
+#define DWC_HCSPLIT_XACTPOS_END 1
+#define DWC_HCSPLIT_XACTPOS_BEGIN 2
+#define DWC_HCSPLIT_XACTPOS_ALL 3
+
+		/** Do Complete Split */
+		unsigned compsplt : 1;
+
+		/** Reserved */
+		unsigned reserved : 14;
+
+		/** Split Enble */
+		unsigned spltena : 1;
+	} b;
+} hcsplt_data_t;
+
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union hcint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer Complete */
+		unsigned xfercomp : 1;
+		/** Channel Halted */
+		unsigned chhltd : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** STALL Response Received */
+		unsigned stall : 1;
+		/** NAK Response Received */
+		unsigned nak : 1;
+		/** ACK Response Received */
+		unsigned ack : 1;
+		/** NYET Response Received */
+		unsigned nyet : 1;
+		/** Transaction Err */
+		unsigned xacterr : 1;
+		/** Babble Error */
+		unsigned bblerr : 1;
+		/** Frame Overrun */
+		unsigned frmovrun : 1;
+		/** Data Toggle Error */
+		unsigned datatglerr : 1;
+		/** Reserved */
+		unsigned reserved : 21;
+	} b;
+} hcint_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Transfer Size
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hctsiz_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Total transfer size in bytes */
+		unsigned xfersize : 19;
+
+		/** Data packets to transfer */
+		unsigned pktcnt : 10;
+
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control), SETUP (Control)
+		 */
+		unsigned pid : 2;
+#define DWC_HCTSIZ_DATA0 0
+#define DWC_HCTSIZ_DATA1 2
+#define DWC_HCTSIZ_DATA2 1
+#define DWC_HCTSIZ_MDATA 3
+#define DWC_HCTSIZ_SETUP 3
+
+		/** Do PING protocol when 1 */
+		unsigned dopng : 1;
+	} b;
+} hctsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Interrupt Mask
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcintmsk register.
+ */
+typedef union hcintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned xfercompl : 1;
+		unsigned chhltd : 1;
+		unsigned ahberr : 1;
+		unsigned stall : 1;
+		unsigned nak : 1;
+		unsigned ack : 1;
+		unsigned nyet : 1;
+		unsigned xacterr : 1;
+		unsigned bblerr : 1;
+		unsigned frmovrun : 1;
+		unsigned datatglerr : 1;
+		unsigned reserved : 21;
+	} b;
+} hcintmsk_data_t;
+
+/** OTG Host Interface Structure.
+ *
+ * The OTG Host Interface Structure structure contains information
+ * needed to manage the DWC_otg controller acting in host mode. It
+ * represents the programming view of the host-specific aspects of the
+ * controller.
+ */
+typedef struct dwc_otg_host_if
+{
+	/** Host Global Registers starting at offset 400h.*/
+	dwc_otg_host_global_regs_t *host_global_regs;
+#define DWC_OTG_HOST_GLOBAL_REG_OFFSET 0x400
+
+	/** Host Port 0 Control and Status Register */
+	volatile uint32_t *hprt0;
+#define DWC_OTG_HOST_PORT_REGS_OFFSET 0x440
+
+
+	/** Host Channel Specific Registers at offsets 500h-5FCh. */
+	dwc_otg_hc_regs_t *hc_regs[MAX_EPS_CHANNELS];
+#define DWC_OTG_HOST_CHAN_REGS_OFFSET 0x500
+#define DWC_OTG_CHAN_REGS_OFFSET 0x20
+
+
+	/* Host configuration information */
+	/** Number of Host Channels (range: 1-16) */
+	uint8_t	 num_host_channels;
+	/** Periodic EPs supported (0: no, 1: yes) */
+	uint8_t	 perio_eps_supported;
+	/** Periodic Tx FIFO Size (Only 1 host periodic Tx FIFO) */
+	uint16_t perio_tx_fifo_size;
+
+} dwc_otg_host_if_t;
+
+
+/**
+ * This union represents the bit fields in the Power and Clock Gating Control
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union pcgcctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Stop Pclk */
+		unsigned stoppclk : 1;
+		/** Gate Hclk */
+		unsigned gatehclk : 1;
+		/** Power Clamp */
+		unsigned pwrclmp : 1;
+		/** Reset Power Down Modules */
+		unsigned rstpdwnmodule : 1;
+		/** PHY Suspended */
+		unsigned physuspended : 1;
+
+		unsigned reserved : 27;
+	} b;
+} pcgcctl_data_t;
+
+#define DWC_OTG_EP_TYPE_CONTROL    0
+#define DWC_OTG_EP_TYPE_ISOC       1
+#define DWC_OTG_EP_TYPE_BULK       2
+#define DWC_OTG_EP_TYPE_INTR       3
+
+
+int dwc_core_init(void);
+
+static void dwc_otg_core_init(void);
+static int  dwc_otg_pcd_init(void);
+static void dwc_otg_core_reset(void);
+static void dwc_otg_enable_common_interrupts(void);
+static void dwc_otg_enable_device_interrupts(void);
+static void dwc_otg_enable_global_interrupts(void);
+static void dwc_otg_core_dev_init(void);
+static void dwc_otg_flush_tx_fifo( const int _num ) ;
+static void dwc_otg_flush_rx_fifo(void) ;
+int dwc_otg_ep_req_start(pcd_struct_t * _pcd,int ep_num);
+void dwc_otg_ep_start_transfer(dwc_ep_t *_ep);
+static void dwc_otg_bulk_ep_activate(dwc_ep_t *ep);
+void dwc_otg_power_off_phy(void);
+void dwc_otg_pullup(int is_on);
+int dwc_otg_bulk_ep_enable(int is_in);//Added by Sam
+
+#endif
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd_irq.c b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd_irq.c
new file mode 100644
index 0000000..da5d371
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd_irq.c
@@ -0,0 +1,1286 @@
+/* dwc controller pcd interrupt drivers  */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-30 @ Shanghai
+ *
+ */
+#include "platform.h"
+#include "usb_ch9.h"
+#include "dwc_pcd.h"
+#include "dwc_pcd_irq.h"
+//#define flush_cpu_cache()
+extern void do_gadget_setup( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl);
+extern void do_vendor_request( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl);
+extern void do_vendor_out_complete( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl);
+extern void do_bulk_complete( pcd_struct_t *_pcd);
+extern void do_modify_memory(u16 opcode,char * inbuff);
+
+static void ep0_out_start(void);
+static int32_t ep0_complete_request( pcd_struct_t * pcd);
+/**
+ * This function starts the Zero-Length Packet for the IN status phase
+ * of a 2 stage control transfer.
+ */
+static void do_setup_in_status_phase( pcd_struct_t *_pcd)
+{
+        dwc_ep_t *ep0 = &g_dwc_eps[0];
+        if (_pcd->ep0state == EP0_STALL) {
+                return;
+        }
+
+        _pcd->ep0state = EP0_STATUS;
+
+        DBG( "EP0 IN ZLP\n");
+        ep0->xfer_len = 0;
+        ep0->xfer_count = 0;
+        ep0->is_in = 1;
+
+        dwc_otg_ep_start_transfer( ep0 );
+
+        /* Prepare for more SETUP Packets */
+        ep0_out_start();
+
+}
+/**
+ * This function starts the Zero-Length Packet for the OUT status phase
+ * of a 2 stage control transfer.
+ */
+static void do_setup_out_status_phase( pcd_struct_t *_pcd)
+{
+        dwc_ep_t *ep0 = &g_dwc_eps[0];
+        if (_pcd->ep0state == EP0_STALL) {
+                return;
+        }
+        _pcd->ep0state = EP0_STATUS;
+
+        /* Prepare for more SETUP Packets */
+        //ep0_out_start( GET_CORE_IF(_pcd), _pcd );
+
+        DBG( "EP0 OUT ZLP\n");
+        ep0->xfer_len = 0;
+        ep0->xfer_count = 0;
+        ep0->is_in = 0;
+        dwc_otg_ep_start_transfer( ep0 );
+
+        /* Prepare for more SETUP Packets */
+        ep0_out_start( );
+
+}
+
+static void pcd_out_completed(pcd_struct_t *_pcd)
+{
+    if (_pcd->cmdtype.out_complete && _pcd->cmdtype.in_complete)
+    {
+        _pcd->cmdtype.setup_complete = _pcd->cmdtype.out_complete = _pcd->cmdtype.in_complete = 0;
+        do_vendor_out_complete(_pcd,(struct usb_ctrlrequest*)&_pcd->setup_pkt);
+    }
+}
+
+static void pcd_in_completed(pcd_struct_t *_pcd)
+{
+	do_vendor_in_complete(_pcd,(struct usb_ctrlrequest*)&_pcd->setup_pkt);
+}
+
+
+static void pcd_setup( pcd_struct_t *_pcd )
+{
+
+    struct usb_ctrlrequest	ctrl = _pcd->setup_pkt.req;
+    dwc_ep_t	*ep0 = &g_dwc_eps[0];
+    /*deptsiz0_data_t doeptsize0 = { 0};*/
+
+    if (_pcd->request_enable == 0)
+        return;
+
+    //	_pcd->setup_pkt.d32[0] = 0;
+    //	_pcd->setup_pkt.d32[1] = 0;
+    _pcd->status = 0;
+    _pcd->request_enable = 0;
+
+    /*doeptsize0.d32 = dwc_read_reg32( DWC_REG_OUT_EP_TSIZE(0));*/
+
+    if (ctrl.bRequestType & USB_DIR_IN) {
+        ep0->is_in = 1;
+        _pcd->ep0state = EP0_IN_DATA_PHASE;
+    } else {
+        ep0->is_in = 0;
+        _pcd->ep0state = EP0_OUT_DATA_PHASE;
+    }
+
+
+    if ((ctrl.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)
+    {
+        /* handle non-standard (class/vendor) requests in the gadget driver */
+        //do_gadget_setup(_pcd, &ctrl );
+        DBG("Vendor requset\n");
+        do_vendor_request(_pcd, &ctrl );
+        dwc_otg_ep_req_start(_pcd,0);
+        return;
+    }
+
+    /** @todo NGS: Handle bad setup packet? */
+
+    switch (ctrl.bRequest)
+    {
+        case USB_REQ_GET_STATUS:
+
+            _pcd->status = 0;
+            switch (ctrl.bRequestType & USB_RECIP_MASK) {
+
+                case USB_RECIP_DEVICE:
+                    _pcd->status = 0; /* Default Bus Powered, no Remote wakeup */
+                    //_pcd->status |= 0x1; /* Self powered */
+                    //_pcd->status |= 0x2;//_pcd->remote_wakeup_enable << 1;
+                    break;
+
+                case USB_RECIP_INTERFACE:
+                    _pcd->status = 0;
+                    break;
+            }
+            _pcd->buf = (char *)&_pcd->status;
+            _pcd->length = 2;
+            dwc_otg_ep_req_start(_pcd,0);
+            break;
+#if 0
+        case USB_RECIP_INTERFACE:
+            *status = 0;
+            break;
+
+        case USB_RECIP_ENDPOINT:
+            ep = get_ep_by_addr(_pcd, ctrl.wIndex);
+            if ( ep == 0 || ctrl.wLength > 2) {
+                ep0_do_stall(_pcd, -EOPNOTSUPP);
+                return;
+            }
+            /** @todo check for EP stall */
+            *status = ep->stopped;
+            break;
+            _pcd->ep0_pending = 1;
+
+            ep0->dwc_ep.start_xfer_buff = (uint8_t *)status;
+            ep0->dwc_ep.xfer_buff = (uint8_t *)status;
+            ep0->dwc_ep.dma_addr = _pcd->status_buf_dma_handle;
+            ep0->dwc_ep.xfer_len = 2;
+            ep0->dwc_ep.xfer_count = 0;
+            ep0->dwc_ep.total_len = ep0->dwc_ep.xfer_len;
+            dwc_otg_ep0_start_transfer( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+            break;
+
+        case USB_REQ_CLEAR_FEATURE:
+            do_clear_feature( _pcd );
+            break;
+
+        case USB_REQ_SET_FEATURE:
+            do_set_feature( _pcd );
+            break;
+#endif
+        case USB_REQ_SET_ADDRESS:
+            if (ctrl.bRequestType == USB_RECIP_DEVICE)
+            {
+                dcfg_data_t dcfg = { 0 };
+
+                printf("Set Addr %d\n",ctrl.wValue);
+                dcfg.b.devaddr = ctrl.wValue;
+                dwc_modify_reg32(DWC_REG_DCFG,0, dcfg.d32);
+                do_setup_in_status_phase( _pcd );
+                return;
+            }
+            break;
+
+        case USB_REQ_SET_INTERFACE:
+        case USB_REQ_SET_CONFIGURATION:
+            _pcd->request_config = 1;   /* Configuration changed */
+            do_gadget_setup(_pcd, &ctrl );
+            dwc_otg_ep_req_start(_pcd,0);
+            break;
+
+        default:
+            /* Call the Gadget Driver's setup functions */
+            do_gadget_setup(_pcd, &ctrl );
+            dwc_otg_ep_req_start(_pcd,0);
+            break;
+    }
+}
+
+/**
+ * This function handles EP0 Control transfers.
+ *
+ * The state of the control tranfers are tracked in
+ * <code>ep0state</code>.
+ * is_in : 1 -- IN Trans
+ * is_in : 0 -- OUT/SETUP Trans
+ */
+static void handle_ep0( int is_in )
+{
+	pcd_struct_t * _pcd = &this_pcd;//Oh, this_pcd
+	dwc_ep_t * ep0 = &g_dwc_eps[0];
+
+    switch (_pcd->ep0state)
+    {
+        case EP0_DISCONNECT:
+            DBG("EP0 DISCONNECT\n");
+            break;
+
+        case EP0_IDLE:
+            _pcd->request_config = 0;
+            DBG("Enter PCD Setup()\n");
+            pcd_setup( _pcd );
+            break;
+
+        case EP0_IN_DATA_PHASE:
+
+            if (ep0->xfer_count < ep0->total_len) {
+                DBG("FIX ME!! dwc_otg_ep0_continue_transfer!\n");
+                //dwc_otg_ep0_continue_transfer ( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+            }
+            else {
+                ep0_complete_request( _pcd );
+                pcd_in_completed(_pcd);/////////////
+            }
+            break;
+
+        case EP0_OUT_DATA_PHASE:
+            ep0_complete_request(_pcd );
+            _pcd->cmdtype.in_complete = 1;
+            pcd_out_completed(_pcd);
+            break;
+
+
+        case EP0_STATUS:
+
+            ep0_complete_request( _pcd );
+            _pcd->ep0state = EP0_IDLE;
+            ep0->stopped = 1;
+            ep0->is_in = 0;  /* OUT for next SETUP */
+
+            break;
+
+        case EP0_STALL:
+            ERR("EP0 STALLed, should not get here pcd_setup()\n");
+            break;
+        }
+
+    return ;
+}
+
+/**
+ * This function completes the request for the EP.  If there are
+ * additional requests for the EP in the queue they will be started.
+ */
+static void complete_ep( int ep_num,int is_in )
+{
+	deptsiz_data_t deptsiz;
+	pcd_struct_t *pcd = &this_pcd;
+	dwc_ep_t *ep = &g_dwc_eps[ep_num];
+
+	if (is_in)
+    {
+		pcd->xfer_len = ep->xfer_count;////////////////
+
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_IN_EP_TSIZE(ep_num));
+		if (deptsiz.b.xfersize == 0 && deptsiz.b.pktcnt == 0 &&
+                    ep->xfer_count == ep->xfer_len)
+        {
+
+			ep->start_xfer_buff = 0;
+			ep->xfer_buff = 0;
+			ep->xfer_len = 0;
+		}
+	}
+	else
+    {/* OUT Transfer */
+
+		deptsiz.d32 = dwc_read_reg32(DWC_REG_OUT_EP_TSIZE(ep_num));
+
+		pcd->xfer_len = ep->xfer_count;
+
+		ep->start_xfer_buff = 0;
+		ep->xfer_buff = 0;
+		ep->xfer_len = 0;
+	}
+
+	do_bulk_complete(pcd);
+}
+/**
+ * This function completes the ep0 control transfer.
+ */
+static int32_t ep0_complete_request( pcd_struct_t * pcd)
+{
+
+    deptsiz0_data_t deptsiz;
+    int is_last = 0;
+    dwc_ep_t* ep = &g_dwc_eps[0];
+
+    DBG("ep0_complete_request()\n");
+    if (pcd->ep0state == EP0_STATUS)
+    {
+        is_last = 1;
+    }
+    else if (ep->xfer_len == 0)
+    {
+        ep->xfer_len = 0;
+        ep->xfer_count = 0;
+        ep->sent_zlp = 1;
+        dwc_otg_ep_start_transfer( ep );
+        return 1;
+    }
+    else if (ep->is_in)
+    {
+        deptsiz.d32 = dwc_read_reg32(DWC_REG_IN_EP_TSIZE(0) );
+        if (deptsiz.b.xfersize == 0) {
+            /* Is a Zero Len Packet needed? */
+            do_setup_out_status_phase(pcd);
+        }
+    }
+    else {
+        /* ep0-OUT */
+        do_setup_in_status_phase(pcd);
+    }
+
+    /* Complete the request */
+    if (is_last) {
+        ep->start_xfer_buff = 0;
+        ep->xfer_buff = 0;
+        ep->xfer_len = 0;
+        return 1;
+    }
+    return 0;
+}
+
+/**
+ * This function reads a packet from the Rx FIFO into the destination
+ * buffer.  To read SETUP data use dwc_otg_read_setup_packet.
+ *
+ * @param _dest   Destination buffer for the packet.
+ * @param _bytes  Number of bytes to copy to the destination.
+ */
+static void dwc_otg_read_packet(uint8_t *_dest, uint16_t _bytes)	//Elvis Fool, add 'static'
+{
+	int i;
+    /*const char* str =   (char*)_dest;*/
+    uint32_t* pu32  = (uint32_t*)_dest;
+    const unsigned lenIn32  = (_bytes>>2);
+    const unsigned rest     = (_bytes & 3);
+
+	/**
+	 * @todo Account for the case where _dest is not dword aligned. This
+	 * requires reading data from the FIFO into a uint32_t temp buffer,
+	 * then moving it into the data buffer.
+	 */
+	//DBG("dwc_otg_read_packet() dest: %p, len: %d\n",_dest,_bytes);
+    for (i = 0; i < lenIn32; ++i)
+    {
+        *pu32++ = dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+    }
+    if (rest)
+    {
+        const unsigned fifoVal  = dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+        uint8_t*            pBufDst8    = (uint8_t*)pu32;
+        const uint8_t*      pBufSrc8    = (const uint8_t*)&fifoVal;
+        for (i = 0; i < rest; ++i)
+        {
+            *pBufDst8++ = *pBufSrc8++;
+        }
+    }
+
+    /*
+     *if(!strcmp("power", str))
+     *    printf("%d>", _bytes),printf(str),printf("\n");
+     */
+
+	return;
+}
+
+/**
+ * This function writes a packet into the Tx FIFO associated with the
+ * EP.  For non-periodic EPs the non-periodic Tx FIFO is written.  For
+ * periodic EPs the periodic Tx FIFO associated with the EP is written
+ * with all packets for the next micro-frame.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to write packet for.
+ * @param _dma Indicates if DMA is being used.
+ */
+void dwc_otg_ep_write_packet( dwc_ep_t *_ep)
+{
+	/**
+	 * The buffer is padded to DWORD on a per packet basis in
+	 * slave/dma mode if the MPS is not DWORD aligned.  The last
+	 * packet, if short, is also padded to a multiple of DWORD.
+	 *
+	 * ep->xfer_buff always starts DWORD aligned in memory and is a
+	 * multiple of DWORD in length
+	 *
+	 * ep->xfer_len can be any number of bytes
+	 *
+	 * ep->xfer_count is a multiple of ep->maxpacket until the last
+	 *  packet
+	 *
+	 * FIFO access is DWORD */
+
+	uint32_t i;
+	uint32_t byte_count;
+	uint32_t dword_count;
+	uint32_t fifo;
+    uint8_t *data_buff = _ep->xfer_buff;
+    uint32_t temp_data ;
+
+	//DBG("dwc_otg_ep_write_packet() : %d\n",_ep->xfer_len);
+        if (_ep->xfer_count >= _ep->xfer_len) {
+                //DWC_WARN("%s() No data for EP%d!!!\n", "dwc_otg_ep_write_packet", _ep->num);
+                return;
+        }
+
+	/* Find the byte length of the packet either short packet or MPS */
+	if ((_ep->xfer_len - _ep->xfer_count) < _ep->maxpacket) {
+		byte_count = _ep->xfer_len - _ep->xfer_count;
+	}
+	else {
+		byte_count = _ep->maxpacket;
+	}
+
+	/* Find the DWORD length, padded by extra bytes as neccessary if MPS
+	 * is not a multiple of DWORD */
+	dword_count =  (byte_count + 3) / 4;
+
+
+       //fifo = _core_if->data_fifo[_ep->num];
+     fifo = DWC_REG_DATA_FIFO(_ep->num);
+
+
+	for (i=0; i<dword_count; i++) {
+		temp_data =get_unaligned(data_buff);
+		dwc_write_reg32( fifo, temp_data );
+		data_buff += 4;
+	}
+
+
+	_ep->xfer_count += byte_count;
+    _ep->xfer_buff += byte_count;
+
+	flush_cpu_cache();
+
+}
+/**
+ * This function reads a setup packet from the Rx FIFO into the destination
+ * buffer.  This function is called from the Rx Status Queue Level (RxStsQLvl)
+ * Interrupt routine when a SETUP packet has been received in Slave mode.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _dest Destination buffer for packet data.
+ */
+void dwc_otg_read_setup_packet(uint32_t *_dest)
+{
+	/* Get the 8 bytes of a setup transaction data */
+
+	DBG("dwc_otg_read_setup_packet()\n");
+	/* Pop 2 DWORDS off the receive data FIFO into memory */
+	_dest[0] = dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+	_dest[1] = dwc_read_reg32(DWC_REG_DATA_FIFO_START);
+}
+
+
+
+/**
+ * handle the IN EP disable interrupt.
+ */
+static void handle_in_ep_disable_intr(uint32_t _epnum)
+{
+#if 0
+        deptsiz_data_t dieptsiz = { 0 };
+        dctl_data_t dctl = { 0 };
+        depctl_data_t diepctl = { 0 };
+        dwc_ep_t *ep = &g_dwc_eps[_epnum];
+
+        if (ep->stopped) {
+                /* Flush the Tx FIFO */
+                /** @todo NGS: This is not the correct FIFO */
+                dwc_otg_flush_tx_fifo( core_if, 0 );
+                /* Clear the Global IN NP NAK */
+                dctl.d32 = 0;
+                dctl.b.cgnpinnak = 1;
+                dwc_modify_reg32(&dev_if->in_ep_regs[_epnum]->diepctl,
+                                 diepctl.d32, diepctl.d32);
+                /* Restart the transaction */
+                if (dieptsiz.b.pktcnt != 0 ||
+                    dieptsiz.b.xfersize != 0) {
+                        restart_transfer( _pcd, _epnum );
+                }
+        }
+#endif
+}
+
+/**
+ * Handler for the IN EP timeout handshake interrupt.
+ */
+static void handle_in_ep_timeout_intr(uint32_t _epnum)
+{
+
+        dctl_data_t dctl = { 0 };
+        dwc_ep_t *ep = &g_dwc_eps[_epnum];
+
+        gintmsk_data_t intr_mask = {0};
+
+
+        /* Disable the NP Tx Fifo Empty Interrrupt */
+
+	intr_mask.b.nptxfempty = 1;
+	dwc_modify_reg32( DWC_REG_GINTMSK, intr_mask.d32, 0);
+        /** @todo NGS Check EP type.
+         * Implement for Periodic EPs */
+        /*
+         * Non-periodic EP
+         */
+        /* Enable the Global IN NAK Effective Interrupt */
+        intr_mask.b.ginnakeff = 1;
+        dwc_modify_reg32( DWC_REG_GINTMSK, 0, intr_mask.d32);
+
+        /* Set Global IN NAK */
+        dctl.b.sgnpinnak = 1;
+        dwc_modify_reg32( DWC_REG_DCTL,dctl.d32, dctl.d32);
+
+        ep->stopped = 1;
+
+}
+
+///////////////////////////////////////////////////////////////////////
+/**
+ * This function handles the Rx Status Queue Level Interrupt, which
+ * indicates that there is a least one packet in the Rx FIFO.  The
+ * packets are moved from the FIFO to memory, where they will be
+ * processed when the Endpoint Interrupt Register indicates Transfer
+ * Complete or SETUP Phase Done.
+ *
+ * Repeat the following until the Rx Status Queue is empty:
+ *   -#	Read the Receive Status Pop Register (GRXSTSP) to get Packet
+ *     	info
+ *   -#	If Receive FIFO is empty then skip to step Clear the interrupt
+ *     	and exit
+ *   -#	If SETUP Packet call dwc_otg_read_setup_packet to copy the
+ *   	SETUP data to the buffer
+ *   -#	If OUT Data Packet call dwc_otg_read_packet to copy the data
+ *     	to the destination buffer
+ */
+int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(void)
+{
+    gintmsk_data_t gintmask = { 0 };
+    device_grxsts_data_t status;
+    gintsts_data_t gintsts;
+    dwc_ep_t *ep;
+
+
+    DBG("dwc_otg_pcd_handle_rx_status_q_level_intr()\n");
+    /* Disable the Rx Status Queue Level interrupt */
+    gintmask.b.rxstsqlvl= 1;
+    dwc_modify_reg32( DWC_REG_GINTMSK, gintmask.d32, 0);
+
+    /* Get the Status from the top of the FIFO */
+    status.d32 = dwc_read_reg32( DWC_REG_GRXSTSP);
+
+    //DBG("rx status: ep%d, pktsts: %d\n",status.b.epnum,status.b.pktsts);
+
+    /* Get pointer to EP structure */
+    ep = &g_dwc_eps[status.b.epnum];
+
+    switch (status.b.pktsts)
+    {
+        case DWC_DSTS_GOUT_NAK:
+            DBG( "Global OUT NAK\n");
+            break;
+
+        case DWC_STS_DATA_UPDT:
+            DBG( "OUT Data Packet\n");
+            {
+                if (status.b.bcnt && ep->xfer_buff)
+                {
+                    /** @todo NGS Check for buffer overflow? */
+                    dwc_otg_read_packet( ep->xfer_buff,status.b.bcnt);
+                    ep->xfer_count += status.b.bcnt;
+                    ep->xfer_buff += status.b.bcnt;
+
+                    if (!status.b.epnum)
+                    {
+                        /*const char* p = ep->xfer_buff - status.b.bcnt;*/
+                        this_pcd.cmdtype.out_complete = 1;
+                        /*
+                         *if(!strcmp("power", p) || !strcmp("low_power", p)){
+                         *    printf("%s, bcnt %d, cnt %d, %d\n", p, status.b.bcnt, ep->xfer_count, this_pcd.cmdtype.in_complete);
+                         *}
+                         */
+                    }
+                }
+            }
+            break;
+
+        case DWC_STS_XFER_COMP:
+            DBG("OUT Complete\n");
+            break;
+
+        case DWC_DSTS_SETUP_COMP:
+            DBG("SETUP Complete\n");
+            break;
+
+        case DWC_DSTS_SETUP_UPDT:
+            DBG("SETUP update\n");
+            {
+                static int _is_first_setup_out_in_cmd = 1;
+
+                dwc_otg_read_setup_packet( this_pcd.setup_pkt.d32);
+                this_pcd.request_enable = 1;
+                ep->xfer_count += status.b.bcnt;
+
+                DBG("set %d, %d\n", status.b.bcnt, ep->xfer_count);
+                if (_is_first_setup_out_in_cmd) //first tplcmd/bulkcmd that in sequence 'setup + out + in'
+                {
+                    struct usb_ctrlrequest request = this_pcd.setup_pkt.req;
+                    if ( USB_TYPE_VENDOR == (request.bRequestType & USB_TYPE_MASK) )
+                    {
+                        unsigned bRequest = request.bRequest;
+
+                        if ((AM_REQ_WR_LARGE_MEM == bRequest) || (AM_REQ_RD_LARGE_MEM == bRequest)
+                                ||(AM_REQ_TPL_CMD == bRequest) || (AM_REQ_TPL_STAT == bRequest)
+                                || (AM_REQ_DOWNLOAD == bRequest) || (AM_REQ_BULKCMD == bRequest))
+                        {
+                            __udelay(20);//delay for first command that consisted of consecutive 'ep0 out', i.e. 'setup + out + in'
+                            _is_first_setup_out_in_cmd = 0;
+                        }
+                    }
+                }
+            }
+        break;
+
+        default:
+            //DBG( "Invalid Packet Status (0x%0x)\n", status.b.pktsts);
+            break;
+
+    }
+
+    /* Enable the Rx Status Queue Level interrupt */
+    dwc_modify_reg32( DWC_REG_GINTMSK, 0, gintmask.d32);
+    /* Clear interrupt */
+    gintsts.d32 = 0;
+    gintsts.b.rxstsqlvl = 1;
+    dwc_write_reg32 ( DWC_REG_GINTSTS, gintsts.d32);
+
+    return 1;
+}
+
+
+/**
+ * This interrupt occurs when the non-periodic Tx FIFO is half-empty.
+ * The active request is checked for the next packet to be loaded into
+ * the non-periodic Tx FIFO.
+ */
+int32_t dwc_otg_pcd_handle_np_tx_fifo_empty_intr(void)
+{
+        gnptxsts_data_t txstatus = {0};
+        gintsts_data_t gintsts;
+
+        int epnum = 0;
+        dwc_ep_t *ep = 0;
+        uint32_t len = 0;
+        int dwords;
+	 depctl_data_t depctl;
+
+	DBG("dwc_otg_pcd_handle_np_tx_fifo_empty_intr()\n");
+        /* Get the epnum from the IN Token Learning Queue. */
+	for (epnum=0; epnum < NUM_EP; epnum++)
+	{
+
+		ep = &g_dwc_eps[epnum];
+
+
+		/* IN endpoint ? */
+		if (epnum && !ep->is_in ) {
+			continue;
+	        }
+		depctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(epnum));
+	       if (depctl.b.epena != 1)
+			continue;
+
+		 if (ep->type == DWC_OTG_EP_TYPE_INTR && ep->xfer_len == 0)
+			continue;
+
+		 flush_cpu_cache();
+
+	        len = ep->xfer_len - ep->xfer_count;
+	        if (len > ep->maxpacket) {
+	                len = ep->maxpacket;
+	        }
+	        dwords = (len + 3)/4;
+
+		 //DBG("nptx: write data to fifo, ep%d , size %d\n",epnum,len);
+	        /* While there is space in the queue and space in the FIFO and
+	         * More data to tranfer, Write packets to the Tx FIFO */
+	        txstatus.d32 = dwc_read_reg32( DWC_REG_GNPTXSTS );
+	        while  (txstatus.b.nptxqspcavail > 0 &&
+	                txstatus.b.nptxfspcavail > dwords &&
+	                ep->xfer_count < ep->xfer_len) {
+
+			   flush_cpu_cache();
+
+			   /* Write the FIFO */
+	                dwc_otg_ep_write_packet( ep );
+
+	                len = ep->xfer_len - ep->xfer_count;
+	                if (len > ep->maxpacket) {
+	                        len = ep->maxpacket;
+	                }
+	                dwords = (len + 3)/4;
+			   flush_cpu_cache();
+			   //txstatus.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+#if 1
+			   /*
+				  TODO:  Remove these code.
+				  Because, if code break from "while"(Line427), an incomplete-in-trans will occour.
+				  Then the tansfer will break.
+			   */
+			   int retry = 50000;	//retry times
+			   while (retry--)
+			   {
+			       txstatus.d32 = dwc_read_reg32(DWC_REG_GNPTXSTS);
+				if(txstatus.b.nptxqspcavail > 0  || //txstatus.b.nptxfspcavail <= dwords ||
+					ep->xfer_count >= ep->xfer_len)
+					break;
+				else
+				{
+					flush_cpu_cache();
+				}
+
+			   }
+			   if (retry <= 0)
+			   {
+				//DWC_ERROR("TxFIFO FULL: Can't trans data to HOST !\n");
+			   }
+
+			   /* END todo */
+#endif
+	        }
+
+	}
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.nptxfempty = 1;
+	dwc_write_reg32 (DWC_REG_GINTSTS, gintsts.d32);
+
+        return 1;
+}
+/**
+ * Read the device status register and set the device speed in the
+ * data structure.
+ * Set up EP0 to receive SETUP packets by calling dwc_ep0_activate.
+ */
+int32_t dwc_otg_pcd_handle_enum_done_intr(void)
+{
+	gintsts_data_t gintsts;
+	gusbcfg_data_t gusbcfg;
+	/*dsts_data_t dsts;*/
+	depctl_data_t diepctl;
+	depctl_data_t doepctl;
+	dctl_data_t dctl ={0};
+
+	DBG("SPEED ENUM\n");
+
+	/* Read the Device Status and Endpoint 0 Control registers */
+	/*dsts.d32 = dwc_read_reg32(DWC_REG_DSTS);*/
+	diepctl.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(0) );
+	doepctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(0));
+
+	/* Set the MPS of the IN EP based on the enumeration speed */
+	diepctl.b.mps = DWC_DEP0CTL_MPS_64;
+	dwc_write_reg32(DWC_REG_IN_EP_REG(0) , diepctl.d32);
+
+	/* Enable OUT EP for receive */
+	doepctl.b.epena = 1;
+	dwc_write_reg32(DWC_REG_OUT_EP_REG(0), doepctl.d32);
+
+	dctl.b.cgnpinnak = 1;
+	dwc_modify_reg32(DWC_REG_DCTL, dctl.d32, dctl.d32);
+
+        if (this_pcd.ep0state == EP0_DISCONNECT) {
+                this_pcd.ep0state = EP0_IDLE;
+        } else if (this_pcd.ep0state == EP0_STALL) {
+                this_pcd.ep0state = EP0_IDLE;
+        }
+
+	 this_pcd.ep0state = EP0_IDLE;
+
+
+	/* Set USB turnaround time based on device speed and PHY interface. */
+	gusbcfg.d32 = dwc_read_reg32(DWC_REG_GUSBCFG);
+#if 0
+	if (_pcd->gadget.speed == USB_SPEED_HIGH) {
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_ULPI) {
+			/* ULPI interface */
+			gusbcfg.b.usbtrdtim = 9;
+		}
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_UTMI) {
+			/* UTMI+ interface */
+			if (GET_CORE_IF(_pcd)->core_params->phy_utmi_width == 16) {
+				gusbcfg.b.usbtrdtim = 5;
+			} else {
+				gusbcfg.b.usbtrdtim = 9;
+			}
+		}
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI) {
+			/* UTMI+  OR  ULPI interface */
+			if (gusbcfg.b.ulpi_utmi_sel == 1) {
+				/* ULPI interface */
+				gusbcfg.b.usbtrdtim = 9;
+			} else {
+				/* UTMI+ interface */
+				if (GET_CORE_IF(_pcd)->core_params->phy_utmi_width == 16) {
+					gusbcfg.b.usbtrdtim = 5;
+				} else {
+					gusbcfg.b.usbtrdtim = 9;
+				}
+			}
+		}
+	} else {
+		/* Full or low speed */
+		gusbcfg.b.usbtrdtim = 9;
+	}
+#else
+	/* Full or low speed */
+	gusbcfg.b.usbtrdtim = 5;
+#endif
+	dwc_write_reg32(DWC_REG_GUSBCFG, gusbcfg.d32);
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.enumdone = 1;
+	dwc_write_reg32(DWC_REG_GINTSTS,gintsts.d32 );
+	return 1;
+}
+///////////////////////////////////////////////////////////////////
+/**
+ * This interrupt indicates that an OUT EP has a pending Interrupt.
+ * The sequence for handling the OUT EP interrupt is shown below:
+ * -#	Read the Device All Endpoint Interrupt register
+ * -#	Repeat the following for each OUT EP interrupt bit set (from
+ *   	LSB to MSB).
+ * -#	Read the Device Endpoint Interrupt (DOEPINTn) register
+ * -#	If "Transfer Complete" call the request complete function
+ * -#	If "Endpoint Disabled" complete the EP disable procedure.
+ * -#	If "AHB Error Interrupt" log error
+ * -#	If "Setup Phase Done" process Setup Packet (See Standard USB
+ *   	Command Processing)
+ */
+static int32_t dwc_otg_pcd_handle_out_ep_intr(void)
+{
+#define CLEAR_OUT_EP_INTR(__epnum,__intr) \
+do { \
+        doepint_data_t doepint = { 0 }; \
+	doepint.b.__intr = 1; \
+	dwc_write_reg32(DWC_REG_OUT_EP_INTR(__epnum), \
+			doepint.d32); \
+} while (0)
+
+        uint32_t ep_intr;
+        doepint_data_t doepint = { 0 };
+        uint32_t epnum = 0;
+//	 uint32_t epnum_trans = 0;
+        gintsts_data_t gintsts;
+
+        DBG( "dwc_otg_pcd_handle_out_ep_intr()\n" );
+
+	/* Read in the device interrupt bits */
+        ep_intr = (dwc_read_reg32(DWC_REG_DAINT) &
+                dwc_read_reg32( DWC_REG_DAINTMSK));
+        ep_intr =( (ep_intr & 0xffff0000) >> 16);
+
+	/* Clear the OUTEPINT in GINTSTS */
+	gintsts.d32 = 0;
+	gintsts.b.outepintr = 1;
+	dwc_write_reg32 (DWC_REG_GINTSTS, gintsts.d32);
+	dwc_write_reg32(DWC_REG_DAINT, 0xFFFF0000 );
+
+        while ( ep_intr ) {
+            if (ep_intr&0x1) {
+                    doepint.d32 = (dwc_read_reg32( DWC_REG_OUT_EP_INTR(epnum)) &
+						dwc_read_reg32(DWC_REG_DOEPMSK));
+
+                    /* Transfer complete */
+			if ( doepint.b.xfercompl ) {
+				DBG("EP%d OUT Xfer Complete\n", epnum);
+
+				/* Clear the bit in DOEPINTn for this interrupt */
+				CLEAR_OUT_EP_INTR(epnum,xfercompl);
+
+				if (epnum == 0) {
+					handle_ep0( 0 );
+				} else {
+					complete_ep( epnum,0 );
+				}
+                    }
+                    /* Endpoint disable  */
+                    if ( doepint.b.epdisabled ) {
+                            DBG("EP%d OUT disabled\n", epnum);
+				/* Clear the bit in DOEPINTn for this interrupt */
+				CLEAR_OUT_EP_INTR(epnum,epdisabled);
+                    }
+                    /* AHB Error */
+                    if ( doepint.b.ahberr ) {
+                            DBG("EP%d OUT AHB Error\n", epnum);
+				CLEAR_OUT_EP_INTR(epnum,ahberr);
+                    }
+                    /* Setup Phase Done (contorl EPs) */
+                    if ( doepint.b.setup ) {
+                            handle_ep0( 0 );
+				CLEAR_OUT_EP_INTR(epnum,setup);
+                    }
+            }
+		epnum++;
+		ep_intr >>=1;
+        }
+
+        return 1;
+
+#undef CLEAR_OUT_EP_INTR
+}
+/**
+ * This interrupt indicates that an IN EP has a pending Interrupt.
+ * The sequence for handling the IN EP interrupt is shown below:
+ * -#	Read the Device All Endpoint Interrupt register
+ * -#	Repeat the following for each IN EP interrupt bit set (from
+ *   	LSB to MSB).
+ * -#	Read the Device Endpoint Interrupt (DIEPINTn) register
+ * -#	If "Transfer Complete" call the request complete function
+ * -#	If "Endpoint Disabled" complete the EP disable procedure.
+ * -#	If "AHB Error Interrupt" log error
+ * -#	If "Time-out Handshake" log error
+ * -#	If "IN Token Received when TxFIFO Empty" write packet to Tx
+ *   	FIFO.
+ * -#	If "IN Token EP Mismatch" (disable, this is handled by EP
+ *   	Mismatch Interrupt)
+ */
+static int32_t dwc_otg_pcd_handle_in_ep_intr(void)
+{
+#define CLEAR_IN_EP_INTR(__epnum,__intr) \
+do { \
+        diepint_data_t diepint = { 0 }; \
+	diepint.b.__intr = 1; \
+	dwc_write_reg32(DWC_REG_IN_EP_INTR(__epnum), \
+			diepint.d32); \
+} while (0)
+
+        diepint_data_t diepint = { 0 };
+//        depctl_data_t diepctl = { 0 };
+        uint32_t ep_intr;
+        uint32_t epnum = 0;
+        gintmsk_data_t intr_mask = {0};
+        gintsts_data_t gintsts;
+
+	 DBG( "dwc_otg_pcd_handle_in_ep_intr()\n" );
+
+	/* Read in the device interrupt bits */
+        ep_intr = (dwc_read_reg32(DWC_REG_DAINT) &
+                dwc_read_reg32( DWC_REG_DAINTMSK));
+        ep_intr =( (ep_intr & 0xffff) );
+
+
+	/* Clear the INEPINT in GINTSTS */
+	/* Clear all the interrupt bits for all IN endpoints in DAINT */
+	gintsts.d32 = 0;
+	gintsts.b.inepint = 1;
+	dwc_write_reg32 (DWC_REG_GINTSTS, gintsts.d32);
+	dwc_write_reg32(DWC_REG_DAINT, 0xFFFF );
+	flush_cpu_cache();
+
+	/* Service the Device IN interrupts for each endpoint */
+        while ( ep_intr ) {
+                if (ep_intr&0x1) {
+
+                        diepint.d32 = (dwc_read_reg32( DWC_REG_IN_EP_INTR(epnum)) &
+									dwc_read_reg32(DWC_REG_DAINTMSK));
+                        /* Transfer complete */
+                        if ( diepint.b.xfercompl ) {
+
+
+                                /* Disable the NP Tx FIFO Empty
+                                 * Interrrupt */
+                                intr_mask.b.nptxfempty = 1;
+                                dwc_modify_reg32( DWC_REG_GINTMSK, intr_mask.d32, 0);
+
+                                /* Clear the bit in DIEPINTn for this interrupt */
+                                CLEAR_IN_EP_INTR(epnum,xfercompl);
+
+                                /* Complete the transfer */
+					if (epnum == 0) {
+						handle_ep0( 0 );
+					} else {
+						complete_ep( epnum,1 );
+					}
+                        }
+                        /* Endpoint disable  */
+                        if ( diepint.b.epdisabled ) {
+                                handle_in_ep_disable_intr( epnum );
+
+                                /* Clear the bit in DIEPINTn for this interrupt */
+                                CLEAR_IN_EP_INTR(epnum,epdisabled);
+                        }
+                        /* AHB Error */
+                        if ( diepint.b.ahberr ) {
+				/* Clear the bit in DIEPINTn for this interrupt */
+				CLEAR_IN_EP_INTR(epnum,ahberr);
+                        }
+                        /* TimeOUT Handshake (non-ISOC IN EPs) */
+                        if ( diepint.b.timeout ) {
+                                handle_in_ep_timeout_intr( epnum );
+
+				CLEAR_IN_EP_INTR(epnum,timeout);
+                        }
+                        /** IN Token received with TxF Empty */
+                        if (diepint.b.intktxfemp) {
+#if 0
+                                if (!ep->stopped && epnum != 0) {
+                                        diepmsk_data_t diepmsk = { 0};
+                                        diepmsk.b.intktxfemp = 1;
+                                        dwc_modify_reg32( &dev_if->dev_global_regs->diepmsk, diepmsk.d32, 0 );
+                                        start_next_request(ep);
+                                }
+#endif
+				CLEAR_IN_EP_INTR(epnum,intktxfemp);
+                        }
+                        /** IN Token Received with EP mismatch */
+                        if (diepint.b.intknepmis) {
+				CLEAR_IN_EP_INTR(epnum,intknepmis);
+                        }
+                        /** IN Endpoint NAK Effective */
+                        if (diepint.b.inepnakeff) {
+				CLEAR_IN_EP_INTR(epnum,inepnakeff);
+                        }
+                }
+                epnum++;
+                ep_intr >>=1;
+        }
+
+        return 1;
+
+#undef CLEAR_IN_EP_INTR
+}
+/**
+ * This function configures EP0 to receive SETUP packets.
+ *
+ * @todo NGS: Update the comments from the HW FS.
+ *
+ *  -# Program the following fields in the endpoint specific registers
+ *  for Control OUT EP 0, in order to receive a setup packet
+ * 	- DOEPTSIZ0.Packet Count = 3 (To receive up to 3 back to back
+ * 	  setup packets)
+ *	- DOEPTSIZE0.Transfer Size = 24 Bytes (To receive up to 3 back
+ *	  to back setup packets)
+ *      - In DMA mode, DOEPDMA0 Register with a memory address to
+ *        store any setup packets received
+ *
+ */
+static void ep0_out_start(void)
+{
+	deptsiz0_data_t doeptsize0 = { 0};
+	depctl_data_t doepctl = { 0 };
+
+	doeptsize0.b.supcnt = 3;
+	doeptsize0.b.pktcnt = 1;
+	doeptsize0.b.xfersize = 8*3;
+
+	DBG("ep0_out_start()\n");
+	dwc_write_reg32( DWC_REG_OUT_EP_TSIZE(0),doeptsize0.d32 );
+
+
+	// EP enable
+	doepctl.d32 = dwc_read_reg32(DWC_REG_OUT_EP_REG(0));
+	doepctl.b.epena = 1;
+
+	doepctl.d32 = 0x80008000;
+	dwc_write_reg32(DWC_REG_OUT_EP_REG(0),doepctl.d32);
+
+	flush_cpu_cache();
+}
+/**
+ * This interrupt occurs when a USB Reset is detected.  When the USB
+ * Reset Interrupt occurs the device state is set to DEFAULT and the
+ * EP0 state is set to IDLE.
+ *  -#	Set the NAK bit for all OUT endpoints (DOEPCTLn.SNAK = 1)
+ *  -#	Unmask the following interrupt bits
+ *  	- DAINTMSK.INEP0 = 1 (Control 0 IN endpoint)
+ * 	- DAINTMSK.OUTEP0 = 1 (Control 0 OUT endpoint)
+ * 	- DOEPMSK.SETUP = 1
+ * 	- DOEPMSK.XferCompl = 1
+ * 	- DIEPMSK.XferCompl = 1
+ *	- DIEPMSK.TimeOut = 1
+ *  -# Program the following fields in the endpoint specific registers
+ *  for Control OUT EP 0, in order to receive a setup packet
+ * 	- DOEPTSIZ0.Packet Count = 3 (To receive up to 3 back to back
+ * 	  setup packets)
+ *	- DOEPTSIZE0.Transfer Size = 24 Bytes (To receive up to 3 back
+ *	  to back setup packets)
+ *      - In DMA mode, DOEPDMA0 Register with a memory address to
+ *        store any setup packets received
+ * At this point, all the required initialization, except for enabling
+ * the control 0 OUT endpoint is done, for receiving SETUP packets.
+ */
+int32_t dwc_otg_pcd_handle_usb_reset_intr(void)
+{
+
+        depctl_data_t doepctl = { 0};
+        daint_data_t daintmsk = { 0};
+        doepmsk_data_t doepmsk = { 0};
+        diepmsk_data_t diepmsk = { 0};
+        dcfg_data_t dcfg = { 0 };
+        depctl_data_t diepctl = { 0};
+        depctl_data_t diepctl_rd = { 0};
+        grstctl_t resetctl = { 0 };
+        dctl_data_t dctl = { 0 };
+        int i = 0;
+        gintsts_data_t gintsts;
+
+
+        DBG("\nUSB RESET\n");
+
+
+        /* Clear the Remote Wakeup Signalling */
+        dctl.b.rmtwkupsig = 1;
+        dwc_modify_reg32( DWC_REG_DCTL,dctl.d32, 0 );
+
+        /* Disable all active IN EPs */
+        diepctl.b.epdis = 1;
+        diepctl.b.snak = 1;
+        for (i=0; i < NUM_EP; i++) {
+                diepctl_rd.d32 = dwc_read_reg32(DWC_REG_IN_EP_REG(i));
+                if (diepctl_rd.b.epena) {
+                        dwc_write_reg32(DWC_REG_IN_EP_REG(i),diepctl.d32 );
+                }
+        }
+
+        /* Set NAK for all OUT EPs */
+        doepctl.b.snak = 1;
+        for (i=0; i < NUM_EP; i++) {
+                dwc_write_reg32(DWC_REG_OUT_EP_REG(i), doepctl.d32 );
+        }
+
+        /* Flush the NP Tx FIFO */
+        dwc_otg_flush_tx_fifo( 0 );
+        /* Flush the Learning Queue */
+        resetctl.b.intknqflsh = 1;
+        dwc_write_reg32( DWC_REG_GRSTCTL, resetctl.d32);
+
+        daintmsk.b.inep0 = 1;
+        daintmsk.b.outep0 = 1;
+        dwc_write_reg32( DWC_REG_DAINTMSK, daintmsk.d32 );
+
+        doepmsk.b.setup = 1;
+        doepmsk.b.xfercompl = 1;
+        doepmsk.b.ahberr = 1;
+        doepmsk.b.epdisabled = 1;
+        dwc_write_reg32( DWC_REG_DOEPMSK, doepmsk.d32 );
+
+        diepmsk.b.xfercompl = 1;
+        diepmsk.b.timeout = 1;
+        diepmsk.b.epdisabled = 1;
+        diepmsk.b.ahberr = 1;
+        dwc_write_reg32( DWC_REG_DIEPMSK, diepmsk.d32 );
+        /* Reset Device Address */
+        dcfg.d32 = dwc_read_reg32( DWC_REG_DCFG);
+        dcfg.b.devaddr = 0;
+        dwc_write_reg32( DWC_REG_DCFG, dcfg.d32);
+
+        /* setup EP0 to receive SETUP packets */
+        ep0_out_start();
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.usbreset = 1;
+	dwc_write_reg32 ( DWC_REG_GINTSTS, gintsts.d32);
+
+	flush_cpu_cache();
+        return 1;
+}
+
+
+///////////////////////////////////////////////////////////////////
+int dwc_common_irq(void)
+{
+	int ret = 0;
+	gotgint_data_t gotgint;
+
+	gotgint.d32 = dwc_read_reg32(DWC_REG_GOTGINT);
+	if (gotgint.d32 == 0)
+		return 0;
+	if (gotgint.b.sesreqsucstschng) {
+		ERR("Session Request Success Status Change\n");
+	}
+	if (gotgint.b.sesenddet) {
+		ERR("Session End Detected, Line Disconected\n");
+                cb_4_dis_connect_intr();
+	}
+
+	dwc_write_reg32(DWC_REG_GOTGINT,gotgint.d32); // clear intr
+
+	return ret;
+}
+
+int dwc_pcd_irq(void)
+{
+	gintsts_data_t  gintr_status;
+	gintsts_data_t  gintr_msk;
+
+	gintr_msk.d32 = dwc_read_reg32(DWC_REG_GINTMSK);
+	gintr_status.d32 = dwc_read_reg32(DWC_REG_GINTSTS);
+
+	if ((gintr_status.d32 & gintr_msk.d32)== 0)
+		return 0;
+
+	DBG("irq gintmsk:  0x%08x\n",gintr_msk.d32);
+	DBG("irq gintrsts: 0x%08x\n",gintr_status.d32);
+
+	gintr_status.d32 = gintr_status.d32 & gintr_msk.d32;
+	DBG("irq gintmsk & gintrsts = 0x%08x\n",gintr_status.d32);
+
+	if (gintr_status.b.rxstsqlvl) {
+	    dwc_otg_pcd_handle_rx_status_q_level_intr();
+        pcd_out_completed(&this_pcd);
+	}
+	if (gintr_status.b.nptxfempty) {
+	    dwc_otg_pcd_handle_np_tx_fifo_empty_intr( );
+	}
+
+	if (gintr_status.b.usbreset) {
+	   dwc_otg_pcd_handle_usb_reset_intr( );
+	}
+	if (gintr_status.b.enumdone) {
+	    dwc_otg_pcd_handle_enum_done_intr();
+	}
+	if (gintr_status.b.epmismatch) {
+	    //dwc_otg_pcd_handle_ep_mismatch_intr( core_if );
+	}
+	if (gintr_status.b.inepint) {
+	    dwc_otg_pcd_handle_in_ep_intr();
+	}
+	if (gintr_status.b.outepintr) {
+	    dwc_otg_pcd_handle_out_ep_intr( );
+	}
+
+#if 0
+    if (gintr_status.b.otgintr)
+    {
+        gotgint_data_t gotgint;
+
+        gotgint.d32 = dwc_read_reg32(DWC_REG_GOTGINT);
+        if (gotgint.b.sesenddet)
+        {
+            printf("dis-connect-intr\n");
+            cb_4_dis_connect_intr();
+        }
+    }
+#endif//#if 0
+
+    dwc_write_reg32(DWC_REG_GINTSTS,gintr_status.d32);
+    flush_cpu_cache();
+	return 0;
+}
+
+
+
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd_irq.h b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd_irq.h
new file mode 100644
index 0000000..48cc165
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/dwc_pcd_irq.h
@@ -0,0 +1,30 @@
+/* dwc driver irq header */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-30 @ Shanghai
+ *
+ */
+#ifndef __DWC_PCD_IRQ_H__
+#define __DWC_PCD_IRQ_H__
+
+int dwc_pcd_irq(void);
+int dwc_otg_irq(void);
+
+/**
+ * States of EP0.
+ */
+typedef enum ep0_state {
+	EP0_DISCONNECT,		/* no host */
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_STATUS,
+	EP0_STALL,
+} ep0state_e;
+
+extern int dwc_common_irq(void);
+
+extern int cb_4_dis_connect_intr(void);
+#endif
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/optimus_core.c b/drivers/usb/gadget/v2_burning/v2_usb_tool/optimus_core.c
new file mode 100644
index 0000000..0f90ef1
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/optimus_core.c
@@ -0,0 +1,65 @@
+#include <common.h>
+#include "platform.h"
+#include "usb_pcd.h"
+
+#include "usb_pcd.c"
+#include "platform.c"
+#include "dwc_pcd.c"
+#include "dwc_pcd_irq.c"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int v2_usbburning(unsigned timeout)
+{
+        int cfg = EXT_CLOCK;
+
+#if defined(CONFIG_SILENT_CONSOLE)
+        gd->flags &= ~GD_FLG_SILENT;
+#endif
+
+        printf("Enter USB burn\n");
+        set_usb_phy_config(cfg);
+
+        usb_parameter_init(timeout);
+
+        if (usb_pcd_init()) {
+                printf("Fail in usb_pcd_init\n");
+                return __LINE__;
+        }
+
+#if (MESON_CPU_TYPE_MESON8 <= MESON_CPU_TYPE)
+        //AML_WATCH_DOG_DISABLE(); //disable watchdog
+#endif// #if (MESON_CPU_TYPE_MESON8 <= MESON_CPU_TYPE)
+
+        while (1)
+        {
+                //watchdog_clear();		//Elvis Fool
+                if (usb_pcd_irq())
+                        break;
+        }
+        return 0;
+}
+
+int do_v2_usbtool (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int rc = 0;
+    unsigned timeout            = (2 <= argc) ? simple_strtoul(argv[1], NULL, 0) : 0;
+    //if get burning tool identify command in pcToolWaitTime, then auto jump into burning mode
+    unsigned pcToolWaitTime     = (3 <= argc) ? simple_strtoul(argv[2], NULL, 0) : 0;
+
+    optimus_work_mode_set(OPTIMUS_WORK_MODE_USB_UPDATE);
+    setenv(_ENV_TIME_OUT_TO_AUTO_BURN, pcToolWaitTime ? argv[2] : "");
+
+    rc = v2_usbburning(timeout);
+    /*close_usb_phy_clock(0);*/
+
+    return rc;
+}
+
+
+U_BOOT_CMD(
+	update,	3,	0,	do_v2_usbtool,
+	"Enter v2 usbburning mode",
+	"usbburning timeout"
+);
+
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/optimus_transform.c b/drivers/usb/gadget/v2_burning/v2_usb_tool/optimus_transform.c
new file mode 100644
index 0000000..5ea13b9
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/optimus_transform.c
@@ -0,0 +1,512 @@
+#include "../v2_burning_i.h"
+#include "usb_pcd.h"
+#include "platform.h"
+#include <partition_table.h>
+
+#define MYDBG(fmt ...) printf("OPT]"fmt)
+
+#ifdef CONFIG_CMD_AML
+#define USB_BURN_POWER_CONTROL  1
+#endif// #ifdef CONFIG_CMD_AML
+
+static inline int str2long(const char *p, unsigned long *num)
+{
+	char *endptr;
+	*num = simple_strtoul(p, &endptr, 0);
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static inline int str2longlong(char *p, unsigned long long *num)
+{
+	char *endptr;
+
+	*num = simple_strtoull(p, &endptr, 16);
+	if (*endptr != '\0')
+	{
+	    switch (*endptr)
+	    {
+	        case 'g':
+	        case 'G':
+	            *num<<=10;
+	        case 'm':
+	        case 'M':
+	            *num<<=10;
+	        case 'k':
+	        case 'K':
+	            *num<<=10;
+	            endptr++;
+	            break;
+	    }
+	}
+
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static int opimus_func_write_bootloader(unsigned long addr)
+{
+        int ret = 0;
+        loff_t size = 0;
+
+        size = 0x60000;//FIXME: 256K at most ??
+
+        ret = store_boot_write((u8*)addr, (loff_t)0, size);
+
+        return ret;
+}
+
+//[0]write_raw_img [1]part_name [2]address, [3]offset, [4]size
+int opimus_func_write_raw_img(int argc, char *argv[], char *info)
+{
+        int ret = 0;
+        u64 addr;
+        u64 off, size;
+        const char* partName = argv[1];
+
+        if (strcmp(partName, "bootloader") == 0)
+        {
+                addr = simple_strtoul(argv[2], NULL, 0);
+                return opimus_func_write_bootloader(addr);
+        }
+
+        addr = simple_strtoull(argv[2], NULL, 0);
+        off  = simple_strtoull(argv[3], NULL, 0);
+        size = simple_strtoul(argv[4], NULL, 0);
+
+        printf("write_raw_img part %s offset 0x%x, size 0x%x, addr 0x%llx\n", argv[1], (u32)off, (u32)size, addr);
+        ret = store_write_ops((u8*)partName, (u8*)addr, off, size);
+
+        return ret;
+}
+
+
+//read_raw_img partName memAddr partOffset readSzInBytes
+int opimus_func_read_raw_img(int argc, char *argv[], char *info)
+{
+        int ret = 0;
+        unsigned long addr;
+        u64 off, size;
+        unsigned char* partName = (unsigned char*)argv[1];
+
+        MYDBG("%s, %s, %s, %s\n", __func__, argv[0], argv[1], argv[2]);
+
+        if (!(str2long(argv[2], &addr)))
+        {
+                sprintf(info, "failed:'%s' is not a number\n", argv[2]);
+                return -1;
+        }
+        if (!(str2longlong(argv[3], &off)))
+        {
+                sprintf(info, "failed:'%s' is not a number\n", argv[3]);
+                return -1;
+        }
+        if (!(str2longlong(argv[4], &size)))
+        {
+                sprintf(info, "failed:'%s' is not a number\n", argv[4]);
+                return -1;
+        }
+
+        ret = store_read_ops(partName, (u8*)addr, off, size);
+
+        return ret;
+}
+
+int optimus_simg2part (int argc, char * const argv[], char *info)
+{
+        int ret = -1;
+        const char* partition_name = argv[1];
+        u8* simg_addr = (u8*)simple_strtoul(argv[2], NULL, 16);
+        u32 pktSz     = simple_strtoul(argv[3], NULL, 0);
+        const unsigned memAddrTop = OPTIMUS_DOWNLOAD_SPARSE_INFO_FOR_VERIFY;//this address backup the chunk info, don't overwrite it!
+
+        if (argc < 4) {
+                sprintf(info, "failed: used [%s partName memAddr, pktSz]\n", argv[0]);
+                DWN_ERR(info);
+                return __LINE__;
+        }
+        if (!pktSz || !simg_addr) {
+                sprintf(info, "simg_addr(%s) or pktSz(%s)error\n", argv[2], argv[3]);
+                DWN_ERR(info);
+                return __LINE__;
+        }
+
+        if ((unsigned long)simg_addr + pktSz > memAddrTop) {
+                sprintf(info, "failed:simg_addr(0x%p) + pktSz(0x%x) > memAddrTop(0x%x)\n", simg_addr, pktSz, memAddrTop);
+                DWN_ERR(info);
+                return __LINE__;
+        }
+
+#if  0
+        ret = simg_write_to_partition(partition_name, simg_addr);
+#else      /* -----  not 0  ----- */
+#if  0
+        ret = optimus_simg_probe(simg_addr, pktSz);
+        if (!ret) {
+                sprintf(info, "failed:format error, not a sparse image at addr %s\n", argv[2]);
+                DWN_ERR(info);
+                return __LINE__;
+        }
+#endif     /* -----  0  ----- */
+        ret = optimus_parse_img_download_info(partition_name, pktSz, "sparse", "store", 0);
+        if (ret) {
+                sprintf(info, "failed:init download info for part(%s)\n", partition_name);
+                DWN_ERR(info);
+                return __LINE__;
+        }
+        unsigned writeLen = optimus_download_img_data(simg_addr, pktSz, info);
+        if (writeLen != pktSz) {
+                DWN_ERR("failed when burn simg!, want(0x%x), write(0x%x)\n", pktSz, writeLen);
+                return __LINE__;
+        }
+#endif     /* -----  not 0  ----- */
+
+        return ret;
+}
+
+int optimus_sha1sum (int argc, char * const argv[], char *info)
+{
+        unsigned buffermax = 64<<20;
+        unsigned char* sha1_addr = (u8*)0x81000000;
+        int ret = -1;
+        char *partition_name;
+        unsigned long long Bits_need_read = 0,partition_offset = 0;
+        unsigned long long verify_len = 0;
+        u8 output[20];
+        char *sha1_verify = NULL;
+        char sha1_value[41];
+        int i = 1;
+
+        memset(sha1_value, 0, sizeof(sha1_value));
+
+        if (3 == argc) //test to sha1sum memory: sha1sum memAddr, length
+        {
+                unsigned verify_len = 0;
+                unsigned char* pBuf = NULL;
+
+                pBuf = (unsigned char*)simple_strtoul(argv[1], NULL, 0);
+                verify_len = simple_strtoul(argv[2], NULL, 0);
+
+                printf("Gen sha1sum: addr 0x%p, len 0x%x\n", pBuf, verify_len);
+                sha1_csum(pBuf, verify_len, output);
+
+                sprintf(sha1_value, "%02x", output[0]);
+                for (i = 1; i < 20; ++i)
+                {
+                        sprintf(sha1_value, "%02x", output[0]);
+                        for (; i < 20; ++i)
+                        {
+                                sprintf(sha1_value, "%s%02x", sha1_value, output[i]);
+                        }
+                        /*sprintf(sha1_value, "%s%02x", sha1_value, output[i]);*/
+                }
+                printf("gen sha1sum %s\n", sha1_value);
+                return 0;
+        }
+
+        if (argc != 4)//argv:cmd,partition_name,verify_len,sha1_verify
+        {
+                printf("bad args---sha1sum cmd need 3 args\n");
+                strcpy(info, "failed:need 3 args");
+                return -1;
+        }
+
+        partition_name = argv[1];
+
+        verify_len = simple_strtoull (argv[2], NULL, 10);
+        sha1_verify = argv[3];
+
+        //circularly verify 128M datas readed in memory 0x81000000
+        sha1_context ctx;
+        sha1_starts (&ctx);
+
+        Bits_need_read = verify_len;
+        partition_offset = 0;
+        while (Bits_need_read > buffermax)
+        {
+                ret = store_read_ops((unsigned char*)partition_name, (unsigned char *) sha1_addr, partition_offset, buffermax);
+                if (ret) {
+                        DWN_ERR("Fail to read data from %s at offset %llx size %x\n", partition_name, partition_offset, buffermax);
+                        return __LINE__;
+                }
+                sha1_update (&ctx, (unsigned char *) sha1_addr, buffermax);
+                Bits_need_read = Bits_need_read - buffermax;
+                partition_offset += buffermax;
+                printf("current Bits_need_read is 0x%llx, buffermax is : 0x%x\n",Bits_need_read,buffermax);
+                for (i = 0; i < 5; i++)sprintf(sha1_value,"%s%08x", sha1_value, (unsigned)ctx.state[i]) ;//5*8=40
+                printf("current sha1_value is  %s\n", sha1_value);
+        }
+
+        ret = store_read_ops((unsigned char*)partition_name, (unsigned char *) sha1_addr, partition_offset, Bits_need_read);
+        if (ret) {
+                DWN_ERR("Fail to read data from %s at offset %llx size %x\n", partition_name, partition_offset, buffermax);
+                return __LINE__;
+        }
+
+        sha1_update (&ctx, (unsigned char *) sha1_addr, Bits_need_read);
+        sha1_finish (&ctx, output);
+        //?????????????
+        printf("SHA1 for %s %p,verify_len:0x%llx ==>",partition_name, sha1_addr,verify_len);
+
+        for (i = 0; i < 20; i++)
+        {
+                printf("%02x", output[i]);
+                //sha1_value[i] = output[i];
+                sprintf(sha1_value,"%s%02x", sha1_value, output[i]);
+        }
+        //sha1_value[21] = '\0';
+        printf("\n");
+
+        printf("sha1_verify= %s\n", sha1_verify);
+        printf("sha1_value = %s\n", sha1_value);
+        if (strncmp(sha1_verify, sha1_value, 40) == 0)
+        {
+                ret = 0;
+                strcpy(info, "success");
+        }
+        else
+        {
+                ret = -1;
+                strcpy(info, "failed");
+        }
+
+        return ret;
+}
+
+
+int optimus_mem_md (int argc, char * const argv[], char *info)
+{
+	ulong	addr, length = 0x100;
+	int	size;
+	int rc = 0;
+
+	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
+		return 1;
+
+	/* Address is specified since argc > 1
+	*/
+	addr = simple_strtoul(argv[1], NULL, 16);
+
+	/* If another parameter, it is the length to display.
+	 * Length is the number of objects, not number of bytes.
+	 */
+	if (argc > 2)
+		length = simple_strtoul(argv[2], NULL, 16);
+
+	/* Print the lines. */
+	print_buffer(addr, (void*)addr, size, length, 16/size);
+	strcpy(info, "success");
+	return rc;
+}
+
+int set_low_power_for_usb_burn(int arg, char* buff)
+{
+    if (OPTIMUS_WORK_MODE_USB_PRODUCE == optimus_work_mode_get()) {
+        return 0;//just return ok as usb producing mode as LCD not initialized yet!
+    }
+
+#if defined(CONFIG_VIDEO_AMLLCD)
+    int ret1=0;
+    //axp to low power off LCD, no-charging
+    MYDBG("To close LCD\n");
+    ret1 = run_command("video dev disable", 0);
+    if (ret1) {
+        if (buff) sprintf(buff, "Fail to close back light") ;
+        printf("Fail to close back light\n");
+        /*return __LINE__;*/
+    }
+#endif// #if defined(CONFIG_VIDEO_AMLLCD)
+
+#if USB_BURN_POWER_CONTROL
+    int ret2=0;
+    //limit vbus curretn to 500mA, i.e, if hub is 4A, 8 devices at most, arg3 to not set_env as it's not inited yet!!
+    MYDBG("set_usbcur_limit 500 0\n");
+    ret2 = run_command("set_usbcur_limit 500 0", 0);
+    if (ret2) {
+        if (buff) sprintf(buff, "Fail to set_usb_cur_limit") ;
+        printf("Fail to set_usb_cur_limit\n");
+        return __LINE__;
+    }
+#endif//#if USB_BURN_POWER_CONTROL
+
+    return 0;
+}
+
+int cb_4_dis_connect_intr(void)
+{
+    if (optimus_burn_complete(OPTIMUS_BURN_COMPLETE__QUERY))
+    {
+        close_usb_phy_clock(0);//disconnect to avoid k200 platfrom which can't relally poweroff
+        DWN_MSG("User Want poweroff after disconnect\n");
+        optimus_poweroff();
+    }
+
+    return 0;
+}
+
+static int _cpu_temp_in_valid_range(int argc, char* argv[], char* errInfo)
+{
+        int ret = 0;
+        int minTemp = 0;
+        int maxTemp = 0;
+        int cpu_temp = 0;
+        char* env_cpu_temp = NULL;
+
+        if (3 > argc) {
+                sprintf(errInfo, "argc %d < 3 is invalid\n", argc);
+                return __LINE__;
+        }
+        minTemp = simple_strtol(argv[1], NULL, 0);
+        maxTemp = simple_strtol(argv[2], NULL, 0);
+        if (minTemp <=0 || maxTemp <= 0 || minTemp >= maxTemp) {
+                sprintf(errInfo, "Invalid:minTemp=%s, maxTemp=%s\n", argv[1], argv[2]);
+                return __LINE__;
+        }
+        ret = run_command("read_temp", 0);
+        if (ret < 0) {
+                sprintf(errInfo, "cmd[cpu_temp] failed\n");
+                return __LINE__;
+        }
+        env_cpu_temp = getenv("tempa");
+        if (!env_cpu_temp) {
+                sprintf(errInfo, "Can't get cpu_temp, cpu is not calibrated.\n");
+                return __LINE__;
+        }
+        cpu_temp = simple_strtol(env_cpu_temp, NULL, 0);
+        ret = (cpu_temp >= minTemp && cpu_temp <= maxTemp) ? 0 : __LINE__;
+        if (!ret) {
+                sprintf(errInfo, "%s", env_cpu_temp);
+        }
+        else{
+                sprintf(errInfo, "%s is out of temp range[%d, %d], errInfo[%s]\n", env_cpu_temp, minTemp, maxTemp, getenv("err_info_tempa"));
+        }
+
+        return ret;
+}
+
+int optimus_working (const char *cmd, char* buff)
+{
+        static char cmdBuf[CMD_BUFF_SIZE] = {0};
+        int ret = 0;
+        int argc = 33;
+        char *argv[CONFIG_SYS_MAXARGS + 1];	/* NULL terminated	*/
+        /*printf("reboot_mode [%8x, %8x]\n", P_AO_RTI_STATUS_REG1);*/
+        const char* optCmd = NULL;
+
+        memset(buff, 0, CMD_BUFF_SIZE);
+        memcpy(cmdBuf, cmd, CMD_BUFF_SIZE);
+        if ((argc = cli_simple_parse_line(cmdBuf, argv)) == 0)
+        {
+                strcpy(buff, "failed:no command at all");
+                printf("no command at all\n");
+                return -1;	/* no command at all */
+        }
+        optCmd = argv[0];
+
+        if (!strcmp("low_power", optCmd))
+        {
+                ret = set_low_power_for_usb_burn(1, buff);
+        }
+        else if(strcmp(optCmd, "disk_initial") == 0)
+        {
+                unsigned  erase = argc > 1 ? simple_strtoul(argv[1], NULL, 0) : 0;
+
+                ret = optimus_storage_init(erase);
+        }
+        else if(!strcmp(optCmd, "bootloader_is_old"))
+        {
+                ret = is_tpl_loaded_from_usb();
+                if (ret)sprintf(buff, "Failed, bootloader is new\n") ;
+        }
+        else if(!strcmp(optCmd, "erase_bootloader"))
+        {
+                ret = optimus_erase_bootloader("usb");
+
+                if (ret)sprintf(buff, "Failed to erase bootloader\n") ;
+        }
+        else if(strcmp(optCmd, "write_raw_img") == 0)
+        {
+                ret = opimus_func_write_raw_img(argc, argv, buff);
+        }
+        else if(strcmp(optCmd, "read_raw_img") == 0)
+        {
+                ret = opimus_func_read_raw_img(argc, argv, buff);
+        }
+        else if(strcmp(optCmd, "simg2part") == 0)
+        {
+                ret = optimus_simg2part(argc, argv, buff);
+        }
+        else if(strcmp(optCmd, "reset") == 0)
+        {
+                close_usb_phy_clock(0);
+                optimus_reset(OPTIMUS_BURN_COMPLETE__REBOOT_NORMAL);
+        }
+        else if(strcmp(optCmd, "poweroff") == 0)
+        {
+                optimus_poweroff();
+        }
+        else if(strncmp(optCmd, "md", 2) == 0)
+        {
+                ret = optimus_mem_md(argc, argv, buff);
+        }
+        else if(!strcmp(optCmd, "download") || !strcmp("upload", optCmd))
+        {
+                ret = optimus_parse_download_cmd(argc, argv);
+        }
+        else if(!strcmp("key", optCmd))
+        {
+                ret = v2_key_command(argc, argv, buff);
+        }
+        else if(!strcmp("verify", optCmd))
+        {
+                ret = optimus_media_download_verify(argc, argv, buff);
+        }
+        else if(!strcmp("save_setting", optCmd))
+        {
+                ret = optimus_set_burn_complete_flag();
+        }
+        else if(!strcmp("burn_complete", optCmd))
+        {
+                unsigned choice = simple_strtoul(argv[1], NULL, 0);//0 is poweroff, 1 is reset system
+
+                if (OPTIMUS_BURN_COMPLETE__POWEROFF_AFTER_DISCONNECT != choice) {//disconnect except OPTIMUS_BURN_COMPLETE__POWEROFF_AFTER_DISCONNECT
+                        close_usb_phy_clock(0);//some platform can't poweroff but dis-connect needed by pc
+                }
+                ret = optimus_burn_complete(choice);
+        }
+        else if(strncmp(cmd,"sha1sum",(sizeof("sha1sum")-1)) == 0)
+        {
+                ret = optimus_sha1sum(argc, argv, buff);
+        }
+        else if(!strcmp(optCmd, "support_tempcontrol"))
+        {
+#ifndef CONFIG_CMD_CPU_TEMP
+                ret = __LINE__;
+#else
+                ret = 0;
+#endif// #ifdef CONFIG_CMD_CPU_TEMP
+                sprintf(buff + 7, "cpu temp control cmd %s supported.\n", ret ? "NOT" : "DO");//7 == strlen("failed")
+        }
+        else if(!strcmp(optCmd, "tempcontrol"))
+        {
+                ret = _cpu_temp_in_valid_range(argc, argv, buff + 7);
+        }
+        else
+        {
+                int flag = 0;
+                ret = run_command(cmd, flag);
+                DWN_MSG("ret = %d\n", ret);
+                /*ret = ret < 0 ? ret : 0;*/
+        }
+
+        if (ret)
+        {
+                memcpy(buff, "failed:", strlen("failed:"));//use memcpy but not strcpy to not overwrite storage/key info
+        }
+        else
+        {
+                memcpy(buff, "success", strlen("success"));//use memcpy but not strcpy to not overwrite storage/key info
+        }
+
+        printf("[info]%s\n",buff);
+        return ret;
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/platform.c b/drivers/usb/gadget/v2_burning/v2_usb_tool/platform.c
new file mode 100644
index 0000000..8c4fc4b
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/platform.c
@@ -0,0 +1,161 @@
+/* platform dirver header */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-24 @ Shanghai
+ *
+ */
+ #include "platform.h"
+
+/*CONFIG_AML_MESON_8 include m8, m8baby, m8m2, etc... defined in cpu.h*/
+#if !( defined(CONFIG_AML_MESON_GX)  )
+#error "platform is not GX !!"
+#endif//#if
+
+/*
+   cfg = 0 : EXT clock
+   cfg = 1 : INT clock
+  */
+
+#if 1
+#define PREI_USB_PHY_A_REG_BASE       0xC0000000  //0x2100
+#define PREI_USB_PHY_B_REG_BASE       0xC1108420	//0X2108
+#else
+#define PREI_USB_PHY_A_REG_BASE       P_USB_ADDR0
+#define PREI_USB_PHY_B_REG_BASE       P_USB_ADDR1
+#endif//#if 0
+
+#ifdef __USE_PORT_B
+#define PREI_USB_PHY_REG_BASE   PREI_USB_PHY_B_REG_BASE
+#else
+#define PREI_USB_PHY_REG_BASE   PREI_USB_PHY_A_REG_BASE
+#endif
+//#define P_RESET1_REGISTER						   (volatile unsigned long *)0xc1104408
+#define P_RESET1_REGISTER_USB                           (volatile unsigned long *)0xc1104408
+
+#define USB_CLK_SEL_XTAL				0
+#define USB_CLK_SEL_XTAL_DIV_2	1
+#define USB_CLK_SEL_DDR_PLL			2
+#define USB_CLK_SEL_MPLL_OUT0		3
+#define USB_CLK_SEL_MPLL_OUT1		4
+#define USB_CLK_SEL_MPLL_OUT2		5
+#define USB_CLK_SEL_FCLK_DIV2		6
+#define USB_CLK_SEL_FCLK_DIV3		7
+
+typedef struct usb_aml_regs {
+    volatile uint32_t config;
+    volatile uint32_t ctrl;
+    volatile uint32_t endp_intr;
+    volatile uint32_t adp_bc;
+    volatile uint32_t dbg_uart;
+    volatile uint32_t test;
+    volatile uint32_t tune;
+} usb_aml_regs_t;
+
+typedef union usb_config_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned clk_en     :1;
+        unsigned clk_sel    :3;
+        unsigned clk_div    :7;
+        unsigned reserved0  :1;
+        unsigned clk_32k_alt_sel:1;
+        unsigned reserved1  :15;
+        unsigned test_trig  :1;
+    } b;
+} usb_config_data_t;
+
+typedef union usb_ctrl_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned soft_prst:1;
+        unsigned soft_hreset:1;
+        unsigned ss_scaledown_mode:2;
+        unsigned clk_det_rst:1;
+        unsigned intr_sel:1;
+        unsigned reserved:2;
+        unsigned clk_detected:1;
+        unsigned sof_sent_rcvd_tgl:1;
+        unsigned sof_toggle_out:1;
+        unsigned not_used:4;
+        unsigned por:1;
+        unsigned sleepm:1;
+        unsigned txbitstuffennh:1;
+        unsigned txbitstuffenn:1;
+        unsigned commononn:1;
+        unsigned refclksel:2;
+        unsigned fsel:3;
+        unsigned portreset:1;
+        unsigned thread_id:6;
+    } b;
+} usb_ctrl_data_t;
+
+void set_usb_phy_config(int cfg)
+{
+
+	const int time_dly = 5000;
+	usb_aml_regs_t * usb_aml_regs = (usb_aml_regs_t * )PREI_USB_PHY_REG_BASE;
+	usb_config_data_t config;
+	usb_ctrl_data_t control;
+
+	/*CLK_GATE_ON(USB0);*/
+	//if(!IS_CLK_GATE_ON(USB0)){
+	//	SET_CBUS_REG_MASK(GCLK_REG_USB0, GCLK_MASK_USB0);
+	//}
+	/*printf("%s %d\n", __func__, __LINE__);*/
+	cfg = cfg;//avoid compiler warning
+	/**P_RESET1_REGISTER = (1<<2);//usb reset*/
+	*P_RESET1_REGISTER_USB = (1<<2);//usb reset
+	udelay(time_dly);//by Sam: delay after reset
+
+	config.d32 = usb_aml_regs->config;
+
+//    config.b.clk_sel    = 0;
+//    config.b.clk_div    = 1;
+//    config.b.clk_32k_alt_sel = 1;
+	usb_aml_regs->config = config.d32;
+
+	control.d32 = usb_aml_regs->ctrl;
+	control.b.fsel = 5;
+	control.b.por = 1;
+	usb_aml_regs->ctrl = control.d32;
+	udelay(time_dly);
+
+	control.b.por = 0;
+	usb_aml_regs->ctrl = control.d32;
+	udelay(time_dly);//by Sam: delay 0.5s to wait usb clam down
+
+	control.d32 = usb_aml_regs->ctrl;
+	if (!control.b.clk_detected) {
+		printf("Error, usb phy clock not detected!\n");
+	}
+
+    return;
+}
+
+#if 0
+int chip_watchdog(void)
+{
+	watchdog_clear();
+	return 0;
+};
+#endif
+
+void close_usb_phy_clock(int cfg)
+{
+        cfg = cfg;//avoid compiler warning
+
+        dwc_otg_pullup(0);//disconnect
+        __udelay(20);
+        /*dwc_otg_power_off_phy();*///Don't call this as it may cause pull-down failed!!!!
+        run_command("sleep 1", 0);//sleep sometime to improve pc compatibility!!
+
+        return;
+}
+
+
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/platform.h b/drivers/usb/gadget/v2_burning/v2_usb_tool/platform.h
new file mode 100644
index 0000000..b8c9227
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/platform.h
@@ -0,0 +1,155 @@
+/* platform header */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-24 @ Shanghai
+ *
+ */
+
+#ifndef __PLATFORM_H__
+#define __PLATFORM_H__
+
+#include <asm/arch/register.h>
+
+//#include "romboot.h"
+//Elvis Fool
+//#pragma Offwarn(88)  /* disable "Expression has no side-effects" print debug info*/
+
+/* A3,CS2,M3 chip, PORT_A is OTG, work as ROM Boot port */
+#ifdef __USE_PORT_B
+#define PORT_REG_OFFSET   0x80000
+#else
+#define PORT_REG_OFFSET   0
+#endif
+
+
+#define DWC_REG_BASE  (0xC9000000 + PORT_REG_OFFSET)
+
+#define PERI_BASE_ADDR               0xc1100000
+#define ISABASE                      0x01000000
+
+#define PREI_USB_PHY_REG              0xc0000000 //0xC1108400
+
+#define PREI_USB_PHY_A_REG3           0xc0000000
+#define PREI_USB_PHY_B_REG4           0xc0000020
+
+#define PREI_USB_PHY_A_POR      (1 << 0)
+#define PREI_USB_PHY_B_POR      (1 << 1)
+#define PREI_USB_PHY_CLK_SEL    (7 << 5) // changed from A1H
+#define PREI_USB_PHY_CLK_GATE 	(1 << 8)
+#define PREI_USB_PHY_B_AHB_RSET     (1 << 11)
+#define PREI_USB_PHY_B_CLK_RSET     (1 << 12)
+#define PREI_USB_PHY_B_PLL_RSET     (1 << 13)
+#define PREI_USB_PHY_A_AHB_RSET     (1 << 17)
+#define PREI_USB_PHY_A_CLK_RSET     (1 << 18)
+#define PREI_USB_PHY_A_PLL_RSET     (1 << 19)
+#define PREI_USB_PHY_A_DRV_VBUS     (1 << 20)
+#define PREI_USB_PHY_B_DRV_VBUS			(1 << 21)
+#define PREI_USB_PHY_B_CLK_DETECT   (1 << 22)
+#define PREI_USB_PHY_CLK_DIV        (0x7f << 24)
+#define PREI_USB_PHY_A_CLK_DETECT   (1 << 31)
+
+#define PREI_USB_PHY_A_REG3_IDDIG_OVR	(1 << 23)
+#define PREI_USB_PHY_A_REG3_IDDIG_VAL	(1 << 24)
+
+#define PREI_USB_PHY_B_REG4_IDDIG_OVR	(1 << 23)
+#define PREI_USB_PHY_B_REG4_IDDIG_VAL	(1 << 24)
+
+
+
+/***********************************************/
+#define WRITE_PERI_REG(reg, val) *(volatile unsigned *)(PERI_BASE_ADDR + ((reg)<<2)) = (val)
+#define READ_PERI_REG(reg) (*(volatile unsigned *)(PERI_BASE_ADDR + ((reg)<<2)))
+
+#define CLEAR_PERIPHS_REG_BITS(reg, mask) WRITE_PERI_REG(reg, (READ_PERI_REG(reg)&(~(mask))))
+#define SET_PERIPHS_REG_BITS(reg, mask)   WRITE_PERI_REG(reg, (READ_PERI_REG(reg)|(mask)))
+
+#define WRITE_ISA_REG(reg, val) *(volatile unsigned *)(ISABASE + (reg)) = (val)
+#define READ_ISA_REG(reg) (*(volatile unsigned *)(ISABASE + (reg)))
+
+#define CLEAR_ISA_REG_MASK(reg, mask) WRITE_ISA_REG(reg, (READ_ISA_REG(reg)&(~mask)))
+#define SET_ISA_REG_MASK(reg, mask)   WRITE_ISA_REG(reg, (READ_ISA_REG(reg)|(mask)))
+/***********************************************/
+
+
+
+
+
+#define IREG_TIMER_E_COUNT            0x2655
+
+
+#define flush_cpu_cache()
+
+
+#define dwc_write_reg32(x, v) 	(*(volatile uint32_t *)(unsigned long)(x + DWC_REG_BASE))=v
+#define dwc_read_reg32(x) (*(volatile uint32_t*)(unsigned long)(x + DWC_REG_BASE))
+// void dwc_modify_reg32( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+#define dwc_modify_reg32(x, c, s) 	(*(volatile uint32_t *)(x + DWC_REG_BASE))=( ((dwc_read_reg32(x)) & (~c)) | (s))
+
+#define get_unaligned(ptr)				    (((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+#define get_unaligned_16(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8))
+#define get_unaligned_32(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+
+#if 0
+#define __constant_cpu_to_le16(x) (x)
+#define __constant_cpu_to_le32(x) (x)
+#define cpu_to_le16(x)      (x)
+#define  cpu_to_le32(x)     (x)
+#define le16_to_cpu(x)      (x)
+#define le32_to_cpu(x)      (x)
+
+#ifndef max
+#define max(a, b)	(((a) > (b))? (a): (b))
+#endif
+#ifndef min
+#define min(a, b)	(((a) < (b))? (a): (b))
+#endif
+
+#endif//#if 0
+
+#define EXT_CLOCK	0
+#define INT_CLOCK	1
+
+
+// 32 bit TimerE, 1us
+#define USB_ROM_CONN_TIMEOUT		5*1000*1000  //us (5s timeout,)
+
+
+/* Meet with spec */
+#define USB_ROM_VER_MAJOR	0
+#define USB_ROM_STAGE_MAJOR	0
+#define USB_ROM_STAGE_MINOR	16		// IPL = 0,	SPL = 8, TPL = 16
+
+#ifdef CONFIG_M6
+#define USB_ROM_VER_MINOR	8				// SPEC Version
+#else
+#define USB_ROM_VER_MINOR	7				// SPEC Version
+#endif
+
+#if 1
+#define PRINTF(x...)	do{}while(0)
+#else
+#define PRINTF(x...) printf(x)
+#endif
+
+#define ERR(x...)       printf(x)
+#define DBG(x...)       PRINTF(x)
+#define USB_ERR(x...)	printf("USBErr:%d", __LINE__),printf(x)
+#define USB_DBG(x...)   PRINTF(x)
+
+
+void set_usb_phy_config(int cfg);
+void close_usb_phy_clock(int cfg);
+void usb_parameter_init(int timeout);
+int chip_utimer_set(int val);
+int chip_watchdog(void);
+#define udelay __udelay
+#define wait_ms(a) udelay(a*1000);
+int update_utime(void);
+int get_utime(void);
+//int chip_watchdog(void);
+//#define usb_memcpy(dst,src,len) rom_memcpy((unsigned)src,(unsigned)dst,(unsigned)len)
+//#define usb_memcpy_32bits(dst,src,len) rom_memcpy((unsigned)src,(unsigned)dst,(unsigned)len)
+
+#endif
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_ch9.h b/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_ch9.h
new file mode 100644
index 0000000..9b52b67
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_ch9.h
@@ -0,0 +1,676 @@
+#ifndef __LINUX_USB_CH9_H
+#define __LINUX_USB_CH9_H
+
+/**
+ * @file usb_ch9.h
+ * @brief This file holds USB constants and structures that are needed for USB
+ * device APIs.  These are used by the USB device model, which is defined
+ * in chapter 9 of the USB 2.0 specification.  Linux has several APIs in C
+ * that need these:
+ *
+ * - the master/host side Linux-USB kernel driver API;
+ * - the "usbfs" user space API; and
+ * - the Linux "gadget" slave/device/peripheral side driver API.
+ *
+ * USB 2.0 adds an additional "On The Go" (OTG) mode, which lets systems
+ * act either as a USB master/host or as a USB slave/device.  That means
+ * the master and slave side APIs benefit from working well together.
+ *
+ * There's also "Wireless USB", using low power short range radios for
+ * peripheral interconnection but otherwise building on the USB framework.
+ *
+ * @addtogroup usb_core
+ */
+/*@{*/
+
+#include <linux/types.h>
+
+/*******************************************************
+* CONTROL REQUEST SUPPORT
+********************************************************/
+
+/// USB directions, to device
+/// This bit flag is used in endpoint descriptors' bEndpointAddress field.
+/// It's also one of three fields in control requests bRequestType.
+#define USB_DIR_OUT     0
+/// USB directions, to host
+/// This bit flag is used in endpoint descriptors' bEndpointAddress field.
+/// It's also one of three fields in control requests bRequestType.
+#define USB_DIR_IN      0x80
+
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_MASK       (0x03 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_STANDARD   (0x00 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_CLASS      (0x01 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_VENDOR     (0x02 << 5)
+/// USB types, the second of three bRequestType fields
+#define USB_TYPE_RESERVED   (0x03 << 5)
+
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_MASK        0x1f
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_DEVICE      0x00
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_INTERFACE   0x01
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_ENDPOINT    0x02
+/// USB recipients, the third of three bRequestType fields
+#define USB_RECIP_OTHER       0x03
+
+/*
+ * Standard requests, for the bRequest field of a SETUP packet.
+ *
+ * These are qualified by the bRequestType field, so that for example
+ * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved
+ * by a GET_STATUS request.
+ */
+#define USB_REQ_GET_STATUS    0x00
+#define USB_REQ_CLEAR_FEATURE   0x01
+#define USB_REQ_SET_FEATURE   0x03
+#define USB_REQ_SET_ADDRESS   0x05
+#define USB_REQ_GET_DESCRIPTOR    0x06
+#define USB_REQ_SET_DESCRIPTOR    0x07
+#define USB_REQ_GET_CONFIGURATION 0x08
+#define USB_REQ_SET_CONFIGURATION 0x09
+#define USB_REQ_GET_INTERFACE   0x0A
+#define USB_REQ_SET_INTERFACE   0x0B
+#define USB_REQ_SYNCH_FRAME   0x0C
+
+/// Wireless USB
+#define USB_REQ_SET_ENCRYPTION    0x0D/
+
+#define USB_REQ_GET_ENCRYPTION    0x0E
+#define USB_REQ_SET_HANDSHAKE   0x0F
+#define USB_REQ_GET_HANDSHAKE   0x10
+#define USB_REQ_SET_CONNECTION    0x11
+#define USB_REQ_SET_SECURITY_DATA 0x12
+#define USB_REQ_GET_SECURITY_DATA 0x13
+#define USB_REQ_SET_WUSB_DATA   0x14
+#define USB_REQ_LOOPBACK_DATA_WRITE 0x15
+#define USB_REQ_LOOPBACK_DATA_READ  0x16
+#define USB_REQ_SET_INTERFACE_DS  0x17
+
+/*
+ * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and
+ * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there
+ * are at most sixteen features of each type.)
+ */
+/// (read only)
+#define USB_DEVICE_SELF_POWERED   0
+
+/// dev may initiate wakeup
+#define USB_DEVICE_REMOTE_WAKEUP  1
+
+/// (wired high speed only)
+#define USB_DEVICE_TEST_MODE      2
+
+/// (wireless)
+#define USB_DEVICE_BATTERY        2
+
+/// (otg) dev may initiate HNP
+#define USB_DEVICE_B_HNP_ENABLE   3
+
+/// (wireless
+#define USB_DEVICE_WUSB_DEVICE    3
+
+/// (otg) RH port supports HNP
+#define USB_DEVICE_A_HNP_SUPPORT  4
+
+/// (otg) other RH port does
+#define USB_DEVICE_A_ALT_HNP_SUPPORT  5
+
+/// (special devices only)
+#define USB_DEVICE_DEBUG_MODE     6
+
+
+
+
+
+
+/// IN/OUT will STALL
+#define USB_ENDPOINT_HALT   0
+
+
+#define USB_SETUP_PACKET_SIZE 8
+
+/**
+ * SETUP data for a USB device control request
+ *
+ * This structure is used to send control requests to a USB device.  It matches
+ * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
+ * USB spec for a fuller description of the different fields, and what they are
+ * used for.
+ *
+ * Note that the driver for any interface can issue control requests.
+ * For most devices, interfaces don't coordinate with each other, so
+ * such requests may be made at any time.
+ */
+struct usb_ctrlrequest {
+        /// matches the USB bmRequestType field
+        __u8  bRequestType;
+
+        /// matches the USB bRequest field
+        __u8  bRequest;
+
+        /// matches the USB wValue field (le16 byte order)
+        __u16 wValue;
+
+        /// matches the USB wIndex field (le16 byte order)
+        __u16 wIndex;
+
+        /// matches the USB wLength field (le16 byte order)
+        __u16 wLength;
+}  __attribute__ ((packed));
+typedef struct usb_ctrlrequest usb_ctrlrequest_t;
+
+
+/*
+ * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or
+ * (rarely) accepted by SET_DESCRIPTOR.
+ *
+ * Note that all multi-byte values here are encoded in little endian
+ * byte order "on the wire".  But when exposed through Linux-USB APIs,
+ * they've been converted to cpu byte order.
+ */
+
+/*
+ * Descriptor types ... USB 2.0 spec table 9.5
+ */
+#define USB_DT_DEVICE     0x01
+#define USB_DT_CONFIG     0x02
+#define USB_DT_STRING     0x03
+#define USB_DT_INTERFACE    0x04
+#define USB_DT_ENDPOINT     0x05
+#define USB_DT_DEVICE_QUALIFIER   0x06
+#define USB_DT_OTHER_SPEED_CONFIG 0x07
+#define USB_DT_INTERFACE_POWER    0x08
+/* these are from a minor usb 2.0 revision (ECN) */
+#define USB_DT_OTG      0x09
+#define USB_DT_DEBUG      0x0a
+#define USB_DT_INTERFACE_ASSOCIATION  0x0b
+/* these are from the Wireless USB spec */
+#define USB_DT_SECURITY     0x0c
+#define USB_DT_KEY      0x0d
+#define USB_DT_ENCRYPTION_TYPE    0x0e
+#define USB_DT_BOS      0x0f
+#define USB_DT_DEVICE_CAPABILITY  0x10
+#define USB_DT_WIRELESS_ENDPOINT_COMP 0x11
+
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_DEVICE    0x21
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_CONFIG    0x22
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_STRING    0x23
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_INTERFACE   0x24
+/// conventional codes for class-specific descriptors
+#define USB_DT_CS_ENDPOINT    0x25
+
+/** All standard descriptors have these 2 fields at the beginning */
+struct usb_descriptor_header {
+        __u8  bLength;
+        __u8  bDescriptorType;
+} __attribute__ ((packed));
+typedef struct usb_descriptor_header usb_descriptor_header_t;
+
+
+
+/** USB_DT_DEVICE: Device descriptor */
+struct usb_device_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+        __u16 bcdUSB;
+        __u8  bDeviceClass;
+        __u8  bDeviceSubClass;
+        __u8  bDeviceProtocol;
+        __u8  bMaxPacketSize0;
+        __u16 idVendor;
+        __u16 idProduct;
+        __u16 bcdDevice;
+        __u8  iManufacturer;
+        __u8  iProduct;
+        __u8  iSerialNumber;
+        __u8  bNumConfigurations;
+} __attribute__ ((packed));
+typedef struct usb_device_descriptor usb_device_descriptor_t;
+
+#define USB_DT_DEVICE_SIZE    18
+
+
+/*
+ * Device and/or Interface Class codes
+ * as found in bDeviceClass or bInterfaceClass
+ * and defined by www.usb.org documents
+ */
+/// for DeviceClass
+#define USB_CLASS_PER_INTERFACE   0
+
+#define USB_CLASS_AUDIO     1
+#define USB_CLASS_COMM      2
+#define USB_CLASS_HID     3
+#define USB_CLASS_PHYSICAL    5
+#define USB_CLASS_STILL_IMAGE   6
+#define USB_CLASS_PRINTER   7
+#define USB_CLASS_MASS_STORAGE    8
+#define USB_CLASS_HUB     9
+#define USB_CLASS_CDC_DATA    0x0a
+
+/// chip+ smart card
+#define USB_CLASS_CSCID     0x0b
+
+/// content security
+#define USB_CLASS_CONTENT_SEC   0x0d
+
+#define USB_CLASS_VIDEO     0x0e
+#define USB_CLASS_WIRELESS_CONTROLLER 0xe0
+#define USB_CLASS_MISC			0xef
+#define USB_CLASS_APP_SPEC    0xfe
+#define USB_CLASS_VENDOR_SPEC   0xff
+
+
+/**
+ * USB_DT_CONFIG: Configuration descriptor information.
+ *
+ * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the
+ * descriptor type is different.  Highspeed-capable devices can look
+ * different depending on what speed they're currently running.  Only
+ * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG
+ * descriptors.
+ */
+struct usb_config_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+        __u16 wTotalLength;
+        __u8  bNumInterfaces;
+        __u8  bConfigurationValue;
+        __u8  iConfiguration;
+        __u8  bmAttributes;
+        __u8  bMaxPower;
+
+} __attribute__ ((packed));
+//typedef struct usb_config_descriptor usb_config_descriptor_t;
+
+#define USB_DT_CONFIG_SIZE    9
+
+/* from config descriptor bmAttributes */
+/// from config descriptor bmAttributes: must be set
+#define USB_CONFIG_ATT_ONE    (1 << 7)
+
+/// from config descriptor bmAttributes: self powered
+#define USB_CONFIG_ATT_SELFPOWER  (1 << 6)
+
+/// from config descriptor bmAttributes: can wakeup
+#define USB_CONFIG_ATT_WAKEUP   (1 << 5)
+
+/// from config descriptor bmAttributes: battery powered
+#define USB_CONFIG_ATT_BATTERY    (1 << 4)
+
+
+/** USB_DT_STRING: String descriptor */
+struct usb_string_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+
+        /// UTF-16LE encoded
+        __u16 wData[1];
+} __attribute__ ((packed));
+typedef struct usb_string_descriptor usb_string_descriptor_t;
+
+/*
+ * note that "string" zero is special, it holds language codes that
+ * the device supports, not Unicode characters.
+ */
+
+
+/** USB_DT_INTERFACE: Interface descriptor */
+struct usb_interface_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+        __u8  bInterfaceNumber;
+        __u8  bAlternateSetting;
+        __u8  bNumEndpoints;
+        __u8  bInterfaceClass;
+        __u8  bInterfaceSubClass;
+        __u8  bInterfaceProtocol;
+        __u8  iInterface;
+
+        struct usb_endpoint_descriptor *endpoint;
+
+        /// Extra descriptors
+        unsigned char *extra;
+
+        int extralen;
+} __attribute__ ((packed));
+typedef struct usb_interface_descriptor usb_interface_descriptor_t;
+
+#if 0
+typedef struct usb_interface {
+        struct usb_interface_descriptor *altsetting;
+
+        int act_altsetting;             /* active alternate setting */
+        int num_altsetting;             /* number of alternate settings */
+        int max_altsetting;             /* total memory allocated */
+
+        void *private_data;
+} usb_interface_t;
+#endif
+
+#define USB_DT_INTERFACE_SIZE   9
+
+
+/** USB_DT_ENDPOINT: Endpoint descriptor */
+struct usb_endpoint_descriptor {
+        __u8  bLength;
+        __u8  bDescriptorType;
+
+        __u8  bEndpointAddress;
+        __u8  bmAttributes;
+        __u16 wMaxPacketSize;
+        __u8  bInterval;
+
+        /// NOTE:  these two are _only_ in audio endpoints.
+        /// use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof.
+        __u8  bRefresh;
+        __u8  bSynchAddress;
+
+        /// Extra descriptors
+
+        unsigned char *extra;
+        int extralen;
+} __attribute__ ((packed));
+typedef struct usb_endpoint_descriptor usb_endpoint_descriptor_t;
+
+#define USB_DT_ENDPOINT_SIZE    7
+
+/// Audio extension
+#define USB_DT_ENDPOINT_AUDIO_SIZE  9
+
+
+/*
+ * Endpoints Macro
+ */
+/// in bEndpointAddress
+#define USB_ENDPOINT_NUMBER_MASK  0x0f
+
+#define USB_ENDPOINT_DIR_MASK   0x80
+
+/// in bmAttributes
+#define USB_ENDPOINT_XFERTYPE_MASK  0x03
+
+#define USB_ENDPOINT_XFER_CONTROL 0
+#define USB_ENDPOINT_XFER_ISOC    1
+#define USB_ENDPOINT_XFER_BULK    2
+#define USB_ENDPOINT_XFER_INT   3
+#define USB_ENDPOINT_MAX_ADJUSTABLE 0x80
+
+
+
+/** USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */
+struct usb_qualifier_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __le16 bcdUSB;
+  __u8  bDeviceClass;
+  __u8  bDeviceSubClass;
+  __u8  bDeviceProtocol;
+  __u8  bMaxPacketSize0;
+  __u8  bNumConfigurations;
+  __u8  bRESERVED;
+} __attribute__ ((packed));
+
+
+
+/** USB_DT_OTG (from OTG 1.0a supplement) */
+struct usb_otg_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  /// support for HNP, SRP, etc
+  __u8  bmAttributes;
+} __attribute__ ((packed));
+
+/// from usb_otg_descriptor.bmAttributes
+#define USB_OTG_SRP   (1 << 0)
+/// swap host/device roles
+#define USB_OTG_HNP   (1 << 1)
+
+
+/** USB_DT_DEBUG:  for special highspeed devices, replacing serial console */
+struct usb_debug_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  /// bulk endpoints with 8 byte maxpacket
+  __u8  bDebugInEndpoint;
+  __u8  bDebugOutEndpoint;
+};
+
+
+/** USB_DT_INTERFACE_ASSOCIATION: groups interfaces */
+struct usb_interface_assoc_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  bFirstInterface;
+  __u8  bInterfaceCount;
+  __u8  bFunctionClass;
+  __u8  bFunctionSubClass;
+  __u8  bFunctionProtocol;
+  __u8  iFunction;
+};
+
+
+
+/**
+ * USB_DT_SECURITY:  group of wireless security descriptors, including
+ * encryption types available for setting up a CC/association.
+ */
+struct usb_security_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __le16 wTotalLength;
+  __u8  bNumEncryptionTypes;
+};
+
+
+/**
+ * USB_DT_KEY:  used with {GET,SET}_SECURITY_DATA; only public keys
+ * may be retrieved.
+ */
+struct usb_key_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  tTKID[3];
+  __u8  bReserved;
+  __u8  bKeyData[0];
+};
+
+
+/** USB_DT_ENCRYPTION_TYPE:  bundled in DT_SECURITY groups */
+struct usb_encryption_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  bEncryptionType;
+#define USB_ENC_TYPE_UNSECURE   0
+
+/// non-wireless mode
+#define USB_ENC_TYPE_WIRED    1
+
+/// aes128/cbc session
+#define USB_ENC_TYPE_CCM_1    2
+
+/// rsa3072/sha1 auth
+#define USB_ENC_TYPE_RSA_1    3
+
+  /// use in SET_ENCRYPTION
+  __u8  bEncryptionValue;
+
+  __u8  bAuthKeyIndex;
+};
+
+
+
+/** USB_DT_BOS:  group of wireless capabilities */
+struct usb_bos_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __le16 wTotalLength;
+  __u8  bNumDeviceCaps;
+};
+
+
+/** USB_DT_DEVICE_CAPABILITY:  grouped with BOS */
+struct usb_dev_cap_header {
+  __u8  bLength;
+  __u8  bDescriptorType;
+  __u8  bDevCapabilityType;
+};
+
+#define USB_CAP_TYPE_WIRELESS_USB 1
+
+/** Ultra Wide Band */
+struct usb_wireless_cap_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+  __u8  bDevCapabilityType;
+
+  __u8  bmAttributes;
+#define USB_WIRELESS_P2P_DRD    (1 << 1)
+#define USB_WIRELESS_BEACON_MASK  (3 << 2)
+#define USB_WIRELESS_BEACON_SELF  (1 << 2)
+#define USB_WIRELESS_BEACON_DIRECTED  (2 << 2)
+#define USB_WIRELESS_BEACON_NONE  (3 << 2)
+
+  /// bit rates, Mbps
+  __le16 wPHYRates;
+
+/// always set
+#define USB_WIRELESS_PHY_53   (1 << 0)
+
+#define USB_WIRELESS_PHY_80   (1 << 1)
+
+/// always set
+#define USB_WIRELESS_PHY_107    (1 << 2)
+
+#define USB_WIRELESS_PHY_160    (1 << 3)
+
+/// always set
+#define USB_WIRELESS_PHY_200    (1 << 4)
+
+#define USB_WIRELESS_PHY_320    (1 << 5)
+#define USB_WIRELESS_PHY_400    (1 << 6)
+#define USB_WIRELESS_PHY_480    (1 << 7)
+
+  /// TFI power levels
+  __u8  bmTFITXPowerInfo;
+
+  /// FFI power levels
+  __u8  bmFFITXPowerInfo;
+
+  __le16 bmBandGroup;
+  __u8  bReserved;
+};
+
+
+/**
+ * USB_DT_WIRELESS_ENDPOINT_COMP:  companion descriptor associated with
+ * each endpoint descriptor for a wireless device
+ */
+struct usb_wireless_ep_comp_descriptor {
+  __u8  bLength;
+  __u8  bDescriptorType;
+
+  __u8  bMaxBurst;
+  __u8  bMaxSequence;
+  __le16 wMaxStreamDelay;
+  __le16 wOverTheAirPacketSize;
+  __u8  bOverTheAirInterval;
+  __u8  bmCompAttributes;
+
+/// in bmCompAttributes
+#define USB_ENDPOINT_SWITCH_MASK  0x03
+
+#define USB_ENDPOINT_SWITCH_NO    0
+#define USB_ENDPOINT_SWITCH_SWITCH  1
+#define USB_ENDPOINT_SWITCH_SCALE 2
+};
+
+
+/**
+ * USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless
+ * host and a device for connection set up, mutual authentication, and
+ * exchanging short lived session keys.  The handshake depends on a CC.
+ */
+struct usb_handshake {
+  __u8 bMessageNumber;
+  __u8 bStatus;
+  __u8 tTKID[3];
+  __u8 bReserved;
+  __u8 CDID[16];
+  __u8 nonce[16];
+  __u8 MIC[8];
+};
+
+
+/**
+ * USB_REQ_SET_CONNECTION modifies or revokes a connection context (CC).
+ * A CC may also be set up using non-wireless secure channels (including
+ * wired USB!), and some devices may support CCs with multiple hosts.
+ */
+struct usb_connection_context {
+  /// persistent host id
+  __u8 CHID[16];
+
+  /// device id (unique w/in host context)
+  __u8 CDID[16];
+
+  /// connection key
+  __u8 CK[16];
+};
+
+
+
+/** USB 2.0 defines three speeds, here's how Linux identifies them */
+
+enum usb_device_speed {
+  USB_SPEED_UNKNOWN = 0,      /** enumerating */
+  USB_SPEED_LOW, USB_SPEED_FULL,    /** usb 1.1 */
+  USB_SPEED_HIGH,       /** usb 2.0 */
+  USB_SPEED_VARIABLE,     /** wireless (usb 2.5) */
+};
+
+/**
+ * USB device state
+ */
+enum usb_device_state {
+  /** NOTATTACHED isn't in the USB spec, and this state acts
+   * the same as ATTACHED ... but it's clearer this way.
+   */
+  USB_STATE_NOTATTACHED = 0,
+
+  /** the chapter 9 device states */
+  USB_STATE_ATTACHED,
+  USB_STATE_POWERED,
+  USB_STATE_DEFAULT,     /** limited function */
+  USB_STATE_ADDRESS,
+  USB_STATE_CONFIGURED,  /** most functions */
+
+  USB_STATE_SUSPENDED    /** Note: there are actually four different SUSPENDED
+                             states, returning to POWERED, DEFAULT, ADDRESS, or
+                             CONFIGURED respectively when SOF tokens flow again.
+                         */
+};
+
+
+/*@}*/
+#endif  /* __LINUX_USB_CH9_H */
+
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_pcd.c b/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_pcd.c
new file mode 100644
index 0000000..abb21ae
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_pcd.c
@@ -0,0 +1,980 @@
+/* usb pcd driver */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-24 @ Shanghai
+ *
+ */
+#include "../v2_burning_i.h"
+#include "platform.h"
+#include "usb_ch9.h"
+#include "dwc_pcd.h"
+#include "dwc_pcd_irq.h"
+#include "usb_pcd.h"
+
+#define COMPILE_TYPE_CHK(expr, t)       typedef char t[(expr) ? 1 : -1]
+
+static int do_bulk_cmd(char* cmd);
+
+#define DWC_BLK_MAX_LEN         0X1000
+#define DWC_BLK_LEN(leftSz)     ((leftSz) >= DWC_BLK_MAX_LEN ? DWC_BLK_MAX_LEN : (leftSz >= BULK_EP_MPS ? BULK_EP_MPS : leftSz))//FIXME:block length 4K, can be 64K ???
+#define DWC_BLK_NUM(totalTransLen)  ( (totalTransLen/DWC_BLK_MAX_LEN) + ( (totalTransLen & (DWC_BLK_MAX_LEN - 1)) + (BULK_EP_MPS - 1) )/BULK_EP_MPS )
+
+#define DRIVER_VENDOR_ID	0x1B8E  //Amlogic's VerdorID
+#define DRIVER_PRODUCT_ID	0xC003
+#define DRIVER_VERSION       0x0100
+
+
+#define STRING_MANUFACTURER	1
+#define STRING_PRODUCT		2
+#define STRING_SERIAL		3
+#define STRING_CONFIG		4
+#define STRING_INTERFACE	5
+static const struct usb_device_descriptor
+device_desc = {
+	sizeof device_desc,		//__u8  bLength;
+        USB_DT_DEVICE,			//__u8  bDescriptorType;
+#ifdef USE_FULL_SPEED
+        __constant_cpu_to_le16(0x0110),	//__u16 bcdUSB;
+#else
+		__constant_cpu_to_le16(0x0200),	//__u16 bcdUSB;
+#endif
+        USB_CLASS_PER_INTERFACE,	//__u8  bDeviceClass;
+        0,				//__u8  bDeviceSubClass;
+        0,				//__u8  bDeviceProtocol;
+        64,				//__u8  bMaxPacketSize0;
+        __constant_cpu_to_le16(DRIVER_VENDOR_ID),	//__u16 idVendor;
+        __constant_cpu_to_le16(DRIVER_PRODUCT_ID),	//__u16 idProduct;
+        __constant_cpu_to_le16(0x0007),	//__u16 bcdDevice;
+        0/*STRING_MANUFACTURER*/,		//__u8  iManufacturer;
+        0/*STRING_PRODUCT*/,			//__u8  iProduct;
+        0/*STRING_SERIAL*/,			//__u8  iSerialNumber;
+        1				//__u8  bNumConfigurations;
+};
+
+#define INTF_CONFIG_DESC_LEN  23
+#define TOTAL_CONFIG_DESC_LEN	(INTF_CONFIG_DESC_LEN + USB_DT_CONFIG_SIZE)
+
+#pragma pack(push, 1)
+struct _ConfigDesTotal_s{
+    struct usb_config_descriptor    configDesc;
+    char                            intfDesc[INTF_CONFIG_DESC_LEN] ;
+};
+#pragma pack(pop)
+COMPILE_TYPE_CHK(TOTAL_CONFIG_DESC_LEN == sizeof(struct _ConfigDesTotal_s), a);
+
+static const struct _ConfigDesTotal_s _configDescTotal = {
+    .configDesc     =
+    {
+        USB_DT_CONFIG_SIZE,		//__u8  bLength;
+        USB_DT_CONFIG,			//__u8  bDescriptorType;
+        TOTAL_CONFIG_DESC_LEN,				//__u16 wTotalLength;
+        1,				//__u8  bNumInterfaces;
+        1,			//__u8  bConfigurationValue;
+        0,//STRING_CONFIG,			//__u8  iConfiguration;
+        USB_CONFIG_ATT_ONE |
+            USB_CONFIG_ATT_SELFPOWER,	//__u8  bmAttributes;
+        1				//__u8  MaxPower;
+    },
+
+    .intfDesc       =
+    {
+        0x09,// length
+        0x04,//USB_DT_INTERFACE
+        0x00,//bInterfaceNumber
+        0x00,//bAlternateSetting
+        0x02,//bNumEndpoints
+        0xFF,//bInterfaceClass, 0xFF =  USB_CLASS_VENDOR_SPEC
+        0x00,//bInterfaceSubClass
+        0x00,//bInterfaceProtocol
+        0x00,//iInterface
+
+        0x07,//Length
+        0x05,//USB_DT_ENDPOINT
+        0x80 | BULK_IN_EP_NUM,// 1 -- IN
+        0x02,// Bulk
+#ifndef USE_FULL_SPEED
+	0x00,//
+	0x02,// 64 bytes MPS
+#else
+	0x40,//
+	0x00,// 64 bytes MPS
+#endif
+	0x00,
+
+	0x07,//Length
+	0x05,//USB_DT_ENDPOINT
+	0x00 | BULK_OUT_EP_NUM,// 2 -- OUT
+	0x02,// Bulk
+#ifndef USE_FULL_SPEED
+	0x00,//
+	0x02,// 64 bytes MPS
+#else
+	0x40,//
+	0x00,// 64 bytes MPS
+#endif
+        0x00
+    }
+};
+
+/*static const struct usb_config_descriptor* config_desc = &_configDescTotal.configDesc;*/
+/*static const unsigned char* intf_desc = &_configDescTotal.intfDesc;*/
+
+#define DT_STRING_ID_LEN  4
+static const  char dt_string_id[DT_STRING_ID_LEN]={
+	DT_STRING_ID_LEN,
+	USB_DT_STRING,
+	0x09,
+	0x04,
+};
+#define DT_STRING_VID_LEN 16
+static const char dt_string_vid[DT_STRING_VID_LEN]=
+{
+	DT_STRING_VID_LEN,
+	USB_DT_STRING,
+	'A',
+	0,
+	'm',
+	0,
+	'l',
+	0,
+	'o',
+	0,
+	'g',
+	0,
+	'i',
+	0,
+	'c',
+	0
+};
+
+#define _PLATFORM_CHIP_INDEX    '8'
+
+#define DT_STRING_PID_LEN 16
+static const char dt_string_pid[DT_STRING_PID_LEN]=
+{
+	DT_STRING_PID_LEN,
+	USB_DT_STRING,
+	'M',
+	0,
+    _PLATFORM_CHIP_INDEX,
+	0,
+	'-',
+	0,
+	'C',
+	0,
+	'H',
+	0,
+	'I',
+	0,
+	'P',
+	0
+};
+
+#define DT_STRING_SERIAL_LEN	18
+static const char dt_string_serial[DT_STRING_SERIAL_LEN]=
+{
+	DT_STRING_SERIAL_LEN,
+	USB_DT_STRING,
+	'2',
+	0,
+	'0',
+	0,
+	'1',
+	0,
+	'1',
+	0,
+	'0',
+	0,
+	'4',
+	0,
+	'0',
+	0,
+	'6',
+	0
+};
+
+static char _resultInfo[AM_BULK_REPLY_LEN] = {0};
+/*static char _bulkCmdBuf[AM_BULK_REPLY_LEN] = {0};*/
+/*#define buff ((char*)PCD_BUFF)*/
+static volatile char _pcd_buff[512] ;
+#define buff _pcd_buff
+
+int usb_pcd_init(void)
+{
+    flush_cache((unsigned long)buff, 512);
+	return dwc_core_init();
+}
+
+static unsigned int need_check_timeout;
+static unsigned int time_out_val;
+static unsigned int _auto_burn_time_out_base = 0;
+
+void usb_parameter_init(int time_out)
+{
+	need_check_timeout = 0;
+	/* clear utimer */
+	need_check_timeout=get_timer(need_check_timeout)?get_timer(need_check_timeout):1;
+	if (time_out)
+	{
+		time_out_val = time_out; // wait PC GetDescriptor command for 1us changed by Elvis
+
+	}
+	else
+	{
+		time_out_val = USB_ROM_CONN_TIMEOUT; // wait PC GetDescriptor command
+	}
+    //printf("need_check_timeout %d, time_out_val %d, time_out %d\n", need_check_timeout, time_out_val, time_out);
+
+    //Added by Sam Wu
+    optimus_buf_manager_init(16*1024);
+    optimus_download_init();
+    return;
+}
+
+int usb_pcd_irq(void)
+{
+        if (need_check_timeout)
+        {
+                unsigned curTime = get_timer(need_check_timeout);
+                if (curTime > time_out_val) {
+                        dwc_otg_power_off_phy();
+                        ERR("Try connect time out %u, %u, %u\n", curTime, time_out_val, need_check_timeout);
+                        return 2;// return to other device boot
+                }
+        }
+        if (_auto_burn_time_out_base) {
+                unsigned waitIdentifyTime = get_timer(_auto_burn_time_out_base);
+                unsigned timeout = simple_strtoul(getenv(_ENV_TIME_OUT_TO_AUTO_BURN), NULL, 0);
+                if (waitIdentifyTime > timeout) {
+                        ERR("waitIdentifyTime(%u) > timeout(%u)\n", waitIdentifyTime, timeout);
+                        _auto_burn_time_out_base = 0;//clear it to allow enter burning next time
+                        return __LINE__;
+                }
+        }
+
+        return dwc_otg_irq();
+}
+
+void start_bulk_transfer(pcd_struct_t *_pcd)
+{
+	_pcd->bulk_lock = 1; // TODO : add lock code.
+	dwc_otg_ep_req_start(_pcd,_pcd->bulk_out?BULK_OUT_EP_NUM:BULK_IN_EP_NUM);
+}
+/**
+ * This functions delegates the setup command to the gadget driver.
+ */
+void do_gadget_setup( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl)
+{
+	int			value;
+	u16			w_index = ctrl->wIndex;
+	u16			w_value = ctrl->wValue;
+	u16			w_length = ctrl->wLength;
+
+	/* usually this just stores reply data in the pre-allocated ep0 buffer,
+	 * but config change events will also reconfigure hardware. */
+	switch (ctrl->bRequest)
+    {
+	  case USB_REQ_GET_DESCRIPTOR:
+          {
+              if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+                  break;
+              //time_out_val = USB_ROM_DRIVER_TIMEOUT;// Wait SetConfig (PC install driver OK)
+              /*need_check_timeout = 0;*/
+              switch (w_value >> 8)
+              {
+                  case USB_DT_DEVICE:
+                      DBG("get dev desc\n");
+                      value = min(w_length, (u16) sizeof device_desc);
+                      /*usb_memcpy(buff, (char*)&device_desc, value);*/
+                      /*
+                       *memcpy((void*)buff, &device_desc, value);
+                       *_pcd->buf = buff;
+                       */
+                      _pcd->buf = (volatile char*)&device_desc;
+                      _pcd->length = value;
+                      break;
+                  case USB_DT_DEVICE_QUALIFIER:
+                      DBG("get dev qual\n");
+                      break;
+                  case USB_DT_OTHER_SPEED_CONFIG:
+                      DBG("--get other speed configuration descriptor\n");
+                      DBG("--other speed configuration descriptor length :%d\n", value);
+                      break;
+                  case USB_DT_CONFIG:
+                      {
+                          USB_DBG("--get configuration descriptor: size %d\n",w_length);
+                          if (w_length > USB_DT_CONFIG_SIZE) {//request USB_DT_CONFIG_SIZE only
+                              value = TOTAL_CONFIG_DESC_LEN;
+                          }
+                          else{
+                              value = w_length;
+                          }
+                          _pcd->buf = (volatile char*)&_configDescTotal;
+                          _pcd->length = value;
+                          /*printf("--get configuration descriptor: size %d, ret length :%d\n\n", w_length, value);			*/
+                          printf("Get DT cfg\n");
+
+                      }
+                      break;
+
+                  case USB_DT_STRING:
+                      {
+                          const char* str = NULL;
+
+                          /*DBG("--get string Desc: id %d\n", w_value & 0xff);*/
+                          printf("Get str %x\n", w_value);
+                          switch (w_value & 0xff)
+                          {
+                              case 0: // IDs
+                                  /*usb_memcpy(buff,(void*)dt_string_id,DT_STRING_ID_LEN);*/
+                                  str = dt_string_id;
+                                  break;
+
+                              case 1: // STRING_MANUFACTURER
+                                  /*usb_memcpy(buff,(void*)dt_string_vid,DT_STRING_VID_LEN);*/
+                                  str = dt_string_vid;
+                                  break;
+
+                              case 2://STRING_PRODUCT
+                                  /*usb_memcpy(buff,(void*)dt_string_pid,DT_STRING_PID_LEN);*/
+                                  str = dt_string_pid;
+                                  break;
+
+                              case 3://STRING_SERIAL
+                                  /*usb_memcpy(buff,(void*)dt_string_serial,DT_STRING_SERIAL_LEN);*/
+                                  str = dt_string_serial;
+                                  break;
+
+                              default:
+                                  USB_ERR("Error string id!\n");
+                                  /*buff[0] = 0;*/
+                                  str = NULL;
+                                  break;
+                          }
+                          _pcd->buf = (char*)str;
+                          _pcd->length = str[0];
+                          /*printf("--get str DESC: id %d ,return length %d\n", (w_value & 0xff), _pcd->length);*/
+                      }
+                      break;
+
+              }
+
+          }
+          break;
+
+      case USB_REQ_SET_CONFIGURATION:
+          {
+              if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD |
+                          USB_RECIP_DEVICE))
+                  break;
+              printf("set CFG\n");
+              _pcd->buf = 0;
+              _pcd->length = 0;
+              _pcd->request_config = 1;   /* Configuration changed */
+              need_check_timeout = 0;
+              if (OPTIMUS_WORK_MODE_USB_UPDATE == optimus_work_mode_get()) {//not booting from usb
+                      if (getenv(_ENV_TIME_OUT_TO_AUTO_BURN))_auto_burn_time_out_base = get_timer(0) ;
+              }
+          }
+          break;
+
+	case USB_REQ_GET_CONFIGURATION:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+			break;
+		printf("get CFG\n");
+		buff[0] = 1;
+		_pcd->buf = buff;
+		_pcd->length = 1;
+		break;
+
+	default:
+		USB_ERR("--unknown control req %02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+	}
+
+	w_index = 0; //remove compile warning
+	return ;
+}
+
+/**
+ * This functions delegates vendor ctrl request.
+ */
+void do_vendor_request( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl)
+{
+	unsigned long	        value =0;
+	u16			w_index = ctrl->wIndex;
+	u16			w_value = ctrl->wValue;
+	u16			w_length = ctrl->wLength;
+
+	switch (ctrl->bRequest)
+    {
+	  case AM_REQ_WRITE_MEM:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		USB_DBG("--am req write memory\n");
+		value = (w_value << 16) + w_index;
+		USB_DBG("addr = 0x%08X, size = %d\n\n",value,w_length);
+		_pcd->buf = (char *)value; // copy to dst memory directly
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_READ_MEM:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		value = (w_value << 16) + w_index;
+
+		/*usb_memcpy((char *)buff,(char*)value,w_length);*/
+		memcpy((void*)buff,(void*)value,w_length);
+
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_READ_AUX:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		/*unsigned int data = 0;*/
+		value = (w_value << 16) + w_index;
+
+		//data = _lr(value);
+		/**(unsigned int *)(unsigned)buff = data;*/
+                memset((char*)buff, 0, sizeof(unsigned));
+
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_FILL_MEM:
+	  case AM_REQ_WRITE_AUX:
+	  case AM_REQ_MODIFY_MEM:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_RUN_IN_ADDR:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		value = (w_value << 16) + w_index;
+		USB_DBG("--am req run in addr %p\n\n",value);
+		_pcd->buf = buff;
+		_pcd->length = w_length;
+		break;
+
+	  case AM_REQ_WR_LARGE_MEM:
+		value = 1;
+	  case AM_REQ_RD_LARGE_MEM:
+		USB_DBG("--am req large %s mem \n\n",value?"write":"read");
+
+		_pcd->bulk_len = w_value;	// block length
+		_pcd->bulk_num = w_index; // number of block
+		_pcd->buf = buff;       //EP0 command data buffer
+		_pcd->length = w_length; //EP0 command data length
+         /*FIXME: cann't delay when writelargeMem, or it will fail??*/
+        /*
+         *printf("f(%s)L%d: bulk_len=0x%x, bulk_num=%d, bufAddr=0x%x, len=0x%x\n",
+         *        __func__, __LINE__, _pcd->bulk_len, _pcd->bulk_num, _pcd->buf, _pcd->length);
+         */
+		break;
+
+      case AM_REQ_DOWNLOAD:
+        {
+            value = 1;//is out
+            _pcd->bulk_len  = w_value;//block length
+            _pcd->bulk_num  = w_index;//how many times to transfer
+            _pcd->buf       = buff;
+            _pcd->length    = w_length;
+        }
+        break;
+
+      case AM_REQ_UPLOAD:
+        {
+            _pcd->buf       = _resultInfo;
+            _pcd->length    = w_length;//assert that lenght == 16 ????
+
+            optimus_buf_manager_get_command_data_for_upload_transfer((u8*)_resultInfo, w_length);
+        }
+        break;
+
+
+	  case AM_REQ_IDENTIFY_HOST:
+        {
+            static const char id[4] =
+            {
+                [0] = USB_ROM_VER_MAJOR,
+                [1] = USB_ROM_VER_MINOR,
+                [2] = USB_ROM_STAGE_MAJOR,
+                [3] = USB_ROM_STAGE_MINOR,
+            };
+
+            _pcd->buf = (char*)id;
+            _pcd->length = w_length;//FIXME:asset w_length == 4 ??
+            _auto_burn_time_out_base = 0;//get burning tool identify command, so clear the timeout flag
+            printf("\nID[%d]\n", _pcd->buf[3]);
+        }
+        break;
+
+      case AM_REQ_BULKCMD://Added by Sam
+        {
+            _pcd->bulk_len = w_value;	// block length
+            _pcd->bulk_num = w_index; // number of block
+            _pcd->buf      = buff;       //EP0 command data buffer, out buffer after set_up command
+            _pcd->length   = w_length; //EP0 command data length
+            /*printf("blkc:len %d\n", _pcd->length);*/
+            _pcd->cmdtype.setup_complete = 1;
+        }
+        break;
+
+	  case AM_REQ_TPL_CMD:
+        {
+            _pcd->buf = buff;
+            _pcd->length = w_length;
+        }
+        break;
+
+	  case AM_REQ_TPL_STAT:
+        {
+            _pcd->buf = _resultInfo;
+            _pcd->length = w_length;
+        }
+        break;
+
+	  default:
+		USB_ERR("--unknown vendor req %02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+		break;
+	}
+
+	return;
+}
+
+/*
+ * This function will be called after a whole SETUP-OUT-IN transfer.
+ */
+void do_vendor_out_complete( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl)
+{
+	unsigned long	        value = 0;
+	u16			w_index = ctrl->wIndex;
+	u16			w_value = ctrl->wValue;
+	u16			w_length = ctrl->wLength;
+	void (*fp)(void);
+	volatile char * buf;
+
+	//USB_DBG("do_vendor_out_complete(0x%x)\n", ctrl->bRequest);
+	switch (ctrl->bRequest)
+    {
+	  case AM_REQ_WRITE_MEM:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+			USB_DBG("--am req write memory completed\n\n");
+		break;
+
+	  case AM_REQ_FILL_MEM:
+		buf = (char*)_pcd->buf;
+		unsigned long addr,i;
+		for (i = 0; i < _pcd->length; i+=8) {
+			addr = *((unsigned int *)&buf[i]) ;
+			value = *((unsigned int *)&buf[i+4]) ;
+			*(unsigned int*)addr = value;
+		}
+		break;
+
+	  case AM_REQ_WRITE_AUX:
+		buf = _pcd->buf;
+		unsigned int data =0;
+
+		data = *((unsigned int *)&buf[0]) ; //reg value
+		value = (w_value << 16) + w_index; //aux reg
+
+                dwc_write_reg32(value, data);
+		break;
+
+	  case AM_REQ_MODIFY_MEM:
+		do_modify_memory(w_value,(char*)_pcd->buf);
+		break;
+
+	  case AM_REQ_RUN_IN_ADDR:
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_DEVICE))
+				break;
+		value = (w_value << 16) + w_index;
+		USB_DBG("run addr = 0x%08X\n",value);
+		fp = (void(*)(void))value;
+		dwc_otg_power_off_phy();
+		fp();
+		break;
+
+	  case AM_REQ_WR_LARGE_MEM:
+		value = 1; // is_out = 1
+      case AM_REQ_RD_LARGE_MEM:
+        {
+            const unsigned* intBuf = (unsigned*)buff;
+            _pcd->bulk_out = (char)value; // read or write
+            _pcd->bulk_buf = (char*)(u64)intBuf[0];
+            _pcd->bulk_data_len = intBuf[1]; // data length
+
+            //added by Sam.Wu
+            _pcd->bulk_xfer_len = 0;
+            _pcd->xferNeedReply = 0;
+
+            _pcd->bulk_len     = DWC_BLK_LEN(_pcd->bulk_data_len);
+            _pcd->bulk_num      = DWC_BLK_NUM(_pcd->bulk_data_len);
+            start_bulk_transfer(_pcd);
+        }
+        break;
+
+      case AM_REQ_DOWNLOAD:
+        value = 2;//2 to differ from write_large_mem
+        {
+            const unsigned* intBuf = (unsigned*)buff;
+            unsigned isPktResended   = intBuf[0];
+            unsigned sequenceNo = intBuf[2];
+            _pcd->bulk_out      = value;
+            _pcd->bulk_data_len = intBuf[1];
+            _pcd->bulk_xfer_len = 0;
+            _pcd->origiSum      = intBuf[3];
+            _pcd->isPktResended = isPktResended;
+
+            if (!isPktResended) //request next buffer slot only if transfer packet not re-sended packet
+            {
+                int ret = optimus_buf_manager_get_buf_for_bulk_transfer(&_pcd->bulk_buf, _pcd->bulk_data_len, sequenceNo, NULL);
+                if (ret) _pcd->bulk_data_len = _pcd->bulk_len = _pcd->bulk_num = 0;
+            }
+
+            _pcd->sequenceNo = sequenceNo;
+
+            _pcd->bulk_len     = DWC_BLK_LEN(_pcd->bulk_data_len);
+            _pcd->bulk_num     = DWC_BLK_NUM(_pcd->bulk_data_len);
+            _pcd->xferNeedReply= 1;///////
+            start_bulk_transfer(_pcd);
+        }
+        break;
+
+      case AM_REQ_UPLOAD:
+        {
+            //command foramt: [4-7]dataLen, other don't care now
+            const u8* cmdData       = (const u8*)_resultInfo;
+            const u32 sequenceNo    = *(unsigned*)(cmdData + 8);
+            const u32 leftDataLen   = *(unsigned*)(cmdData + 4);
+            int ret = 0;
+
+            _pcd->bulk_out      = 0;
+            _pcd->bulk_xfer_len = 0;
+            _pcd->bulk_data_len = leftDataLen;
+
+            _pcd->bulk_len     = DWC_BLK_LEN(leftDataLen);
+            _pcd->bulk_num      = DWC_BLK_NUM(leftDataLen);
+
+            ret = optimus_buf_manager_get_buf_for_bulk_transfer(&_pcd->bulk_buf, _pcd->bulk_data_len, sequenceNo, _resultInfo);
+            if (ret) _pcd->bulk_data_len = _pcd->bulk_len = _pcd->bulk_num = 0;//respond 0 byte data to stop transfer
+
+            DWN_DBG("up 0x:len %x, buf %p, bulk_num %d\n", _pcd->bulk_data_len, _pcd->bulk_buf, _pcd->bulk_num);
+            _pcd->xferNeedReply= 1;///////
+            start_bulk_transfer(_pcd);
+        }
+        break;
+
+
+	  case AM_REQ_TPL_CMD:
+		  /* this is an example for any command */
+		if (!w_index) {/* assume subcode is 0 */
+/*	???????????????????????????
+			char dev[16] = {0};
+			u64 offset = 0;
+			u64 tmp = 0;
+			u32 mem_addr = (*(unsigned int*)buff);
+			offset |= (*(unsigned int*)&buff[16]);
+			tmp = (*(unsigned int*)&buff[20]);
+			offset |= (tmp << 32);
+
+			u32 size = (*(unsigned int*)&buff[12]);
+			usb_memcpy(dev,&buff[32],16);
+			burn_board(dev, mem_addr, offset, size);
+*/
+		}
+		else if(w_index == 1){
+			char cmd[CMD_BUFF_SIZE];
+			memcpy(cmd, (void*)buff, CMD_BUFF_SIZE);
+			if (strncmp(cmd,"bootm",(sizeof("bootm")-1)) == 0) {
+				dwc_otg_pullup(0);//disconnect
+			}
+            printf("tplcmd[%s]\n", cmd);
+			optimus_working(cmd, _resultInfo);
+		}
+		break;
+
+      case AM_REQ_BULKCMD:
+        {
+            do_bulk_cmd((char*)buff);
+        }
+        break;
+
+	  default:
+		USB_ERR("--unknown vendor req comp %02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+	}
+	w_length = 0;//remove compile warning
+	return;
+}
+
+/*
+ * This function will be called after a whole SETUP-IN-OUT transfer.
+ */
+void do_vendor_in_complete( pcd_struct_t *_pcd, struct usb_ctrlrequest * ctrl)
+{
+	u16			w_index = ctrl->wIndex;
+	u16			w_value = ctrl->wValue;
+	u16			w_length = ctrl->wLength;
+
+	//USB_DBG("do_vendor_out_complete(0x%x)\n", ctrl->bRequest);
+	switch (ctrl->bRequest)
+    {
+	  case AM_REQ_IDENTIFY_HOST:
+	  case AM_REQ_TPL_STAT:
+          break;
+
+      case USB_REQ_GET_DESCRIPTOR:
+          break;
+
+      case AM_REQ_UPLOAD:
+        {
+            //command foramt: [4-7]dataLen, other don't care now
+            const u8* cmdData       = (const u8*)_resultInfo;
+            const u32 sequenceNo    = *(unsigned*)(cmdData + 8);
+            const u32 leftDataLen   = *(unsigned*)(cmdData + 4);
+            int ret = 0;
+
+            _pcd->bulk_out      = 0;
+            _pcd->bulk_xfer_len = 0;
+            _pcd->bulk_data_len = leftDataLen;
+
+            _pcd->bulk_len     = DWC_BLK_LEN(leftDataLen);
+            _pcd->bulk_num      = DWC_BLK_NUM(leftDataLen);
+
+            ret = optimus_buf_manager_get_buf_for_bulk_transfer(&_pcd->bulk_buf, _pcd->bulk_data_len, sequenceNo, _resultInfo);
+            if (ret) _pcd->bulk_data_len = _pcd->bulk_len = _pcd->bulk_num = 0;//respond 0 byte data to stop transfer
+
+            DWN_DBG("up 0x:len %x, buf %p, bulk_num %d\n", _pcd->bulk_data_len, _pcd->bulk_buf, _pcd->bulk_num);
+            _pcd->xferNeedReply= 1;///////
+            start_bulk_transfer(_pcd);
+        }
+        break;
+
+	  default:
+		USB_ERR("--unknown vendor req comp %02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+	}
+	w_length = 0;//remove compile warning
+	return;
+}
+
+
+int bulk_transfer_reply(const pcd_struct_t* _pcd)
+{
+    static int _mediaErr = 0;
+    static pcd_struct_t pcd;
+    char* replyBuf = _resultInfo;
+    const void* data    = _pcd->bulk_buf;
+    const unsigned len  = _pcd->bulk_xfer_len;
+    const unsigned sequenceNo = _pcd->sequenceNo;
+    int isOut           = !_pcd->bulk_out;//handshake direction is opposite
+    const u32 origiSum  = _pcd->origiSum;
+    unsigned genSum = 0;
+    int ret = 0;
+    const int isPktResended = _pcd->isPktResended;
+
+    dwc_otg_bulk_ep_enable(!isOut);//enable the bulk in ep first before optimus_working!!
+
+    if(0 == _pcd->sequenceNo
+            && !isPktResended)//media error can't resolved by reseneded, only memory(dram) error can
+    {
+        _mediaErr = 0;//set error none if download a new file
+    }
+
+    if (_mediaErr) {
+        sprintf(replyBuf, "media error %d at seq %d, resend %d\n", _mediaErr, sequenceNo, isPktResended);
+        DWN_ERR(replyBuf);
+        ret = __LINE__;
+    }
+    else
+    {
+        genSum = add_sum(data, len);
+
+        if (origiSum != genSum)
+        {
+            sprintf(replyBuf, "0x: genSum %x != org %x at seq %x, len %x, resend %d\n", genSum, origiSum, sequenceNo, len, isPktResended);
+            DWN_ERR(replyBuf);
+            ret = __LINE__;
+        }
+    }
+
+    if (!ret) //add-sum checked ok and no media error
+    {
+        _mediaErr = optimus_buf_manager_report_transfer_complete(_pcd->bulk_xfer_len, replyBuf);
+        if (_mediaErr) {
+            sprintf(replyBuf, "media error %d at seq %d\n", _mediaErr, sequenceNo);
+            DWN_ERR(replyBuf);
+            ret = __LINE__;
+        }
+    }
+
+    if (!ret)
+    {
+        memcpy(replyBuf, "OK!!", 4);
+    }
+
+    //PCD fields needed for reply
+    //see implementation of dwc_otg_ep_req_start
+    pcd.bulk_data_len = AM_BULK_REPLY_LEN;//total length <= 4k
+    pcd.bulk_len      = DWC_BLK_LEN(pcd.bulk_data_len);//total length <= 4k
+    pcd.bulk_num      = DWC_BLK_NUM(pcd.bulk_data_len);
+    pcd.bulk_buf      = replyBuf;
+    pcd.bulk_xfer_len = 0;
+
+    DWN_DBG("replyBuf %s\n", replyBuf);
+    dwc_otg_ep_req_start(&pcd,  isOut?BULK_OUT_EP_NUM:BULK_IN_EP_NUM);
+
+    return ret;
+}
+
+/*
+ * This function will be called after a whole bulk out transfer.
+ * Attention That All bulk transfer will reach here after completed!!
+ */
+void do_bulk_complete( pcd_struct_t *_pcd)
+{
+	_pcd->bulk_lock = 0;
+	_pcd->bulk_num--;
+	/*_pcd->bulk_data_len -= _pcd->xfer_len;*/
+    _pcd->bulk_xfer_len += _pcd->xfer_len;
+
+    //open this debug info if see if _pcd->bulk_num is 0 has been reponsed! i.e, all data transfrred ended
+    //if not bulk in tranferred, open in printf will let down the csw of mwrite(csw will be invalid transfer)
+    DWN_DBG("left blk %d, this len 0x%x, bulk_xfer_len 0x%x\n", _pcd->bulk_num, _pcd->xfer_len, _pcd->bulk_xfer_len);
+
+	if(_pcd->bulk_num > 0
+            && _pcd->bulk_len)//if earlier packet length is 0, no next xfer here!!
+	{
+        const u32 leftDataLen = _pcd->bulk_data_len - _pcd->bulk_xfer_len;
+
+        _pcd->bulk_len     = DWC_BLK_LEN(leftDataLen);
+
+		/*_pcd->bulk_buf += _pcd->bulk_len;*/
+		start_bulk_transfer(_pcd);
+
+        return;/////////////////
+	}
+
+    if (this_pcd.xferNeedReply) //get download command and is out
+    {
+        this_pcd.xferNeedReply = 0;////
+
+        if (2 == _pcd->bulk_out) //2 means download command 0x32, only this command need handshake??!!!!!
+        {
+            bulk_transfer_reply(_pcd);
+            return;////////
+        }
+
+        if (!_pcd->bulk_out)
+        {
+            optimus_buf_manager_report_transfer_complete(_pcd->bulk_xfer_len, NULL);
+        }
+    }
+}
+
+static int bulk_cmd_reply(const char* replyBuf)
+{
+    static pcd_struct_t pcd;
+
+    //PCD fields needed for reply
+    //see implementation of dwc_otg_ep_req_start
+    pcd.bulk_len      = AM_BULK_REPLY_LEN;
+    pcd.bulk_buf      = (char*)replyBuf;
+    pcd.bulk_xfer_len = 0;
+
+	this_pcd.bulk_out = 0;//////////////////////////////OH NO!!!! I don't like the common pcd, FIXME to use various PCD !!
+    this_pcd.xferNeedReply = 0;
+    dwc_otg_ep_req_start(&pcd,  BULK_IN_EP_NUM);//bulk in to reply result, it is ALWAYS IN
+
+    return 0;
+}
+
+static int do_bulk_cmd(char* cmd)
+{
+    int ret = 0;
+    const int is_in = 1;
+
+    ret = dwc_otg_bulk_ep_enable(is_in);//enable the bulk in ep first before optimus_working!!
+
+	printf("BULKcmd[%s]\n", cmd);
+    ret = optimus_working(cmd, _resultInfo);
+
+    ret = bulk_cmd_reply(_resultInfo);
+
+    return ret;
+}
+
+void do_modify_memory(u16 opcode, char *inbuff)
+{
+	unsigned int *mem,*mem2;
+	unsigned int data,mask;
+
+	mem = *(unsigned int**)&inbuff[0];
+	data = *(unsigned int*)&inbuff[4];
+	mask = *(unsigned int*)&inbuff[8];
+	mem2= *(unsigned int**)&inbuff[12];
+
+	switch (opcode) {
+	  case 0: //*mem = data
+		*mem = data;
+		break;
+
+	  case 1:// *mem = (data & mask)
+		*mem = data & mask;
+		break;
+
+	  case 2:// *mem =(*mem | mask)
+		*mem = *mem | mask;
+		break;
+
+	  case 3:// *mem = (data & (~mask))
+		*mem =  (data & (~mask));
+		break;
+
+	  case 4:// *mem = (data & mask) |(*mem & ~mask)
+		*mem = (data & mask) |(*mem & ~mask);
+		break;
+
+	  case 5:// *mem = *mem2
+		*mem = *mem2;
+		break;
+
+	  case 6:// *mem = (*mem2 & mask)
+		*mem = (*mem2 & mask);
+		break;
+
+	  case 7:// while(data--) {*mem++ = *mem2++}
+		while (data--) {
+			*mem++ = *mem2++;
+		}
+		break;
+
+	  default:
+		break;
+	}
+
+}
+
diff --git a/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_pcd.h b/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_pcd.h
new file mode 100644
index 0000000..d4f9827
--- /dev/null
+++ b/drivers/usb/gadget/v2_burning/v2_usb_tool/usb_pcd.h
@@ -0,0 +1,41 @@
+/* usb pcd driver header */
+/*
+ * (C) Copyright 2010 Amlogic, Inc
+ *
+ * Victor Wan, victor.wan@amlogic.com,
+ * 2010-03-24 @ Shanghai
+ *
+ */
+#ifndef __USB_PCD_H__
+#define __USB_PCD_H__
+#include <asm/types.h>
+
+#define CMD_BUFF_SIZE		512
+
+int usb_pcd_init(void);
+int usb_pcd_irq(void);
+extern int optimus_working (const char *cmd, char* buff);
+
+// Vendor request defines
+#define AM_REQ_WRITE_MEM	0x01
+#define AM_REQ_READ_MEM	0x02
+#define AM_REQ_FILL_MEM	0x03
+#define AM_REQ_MODIFY_MEM	0x04
+#define AM_REQ_RUN_IN_ADDR	0x05
+#define AM_REQ_WRITE_AUX	0x06
+#define AM_REQ_READ_AUX		0x07
+
+#define AM_REQ_WR_LARGE_MEM	0x11
+#define AM_REQ_RD_LARGE_MEM	0x12
+#define AM_REQ_IDENTIFY_HOST	0x20
+
+#define AM_REQ_TPL_CMD	0x30
+#define AM_REQ_TPL_STAT 0x31
+void do_modify_memory(u16 opcode, char *inbuff);
+
+#define AM_REQ_DOWNLOAD     0X32
+#define AM_REQ_UPLOAD       0X33
+#define AM_REQ_BULKCMD      0X34
+#define AM_BULK_REPLY_LEN   CMD_BUFF_SIZE
+
+#endif
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index c11b551..b094537 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -41,6 +41,11 @@ obj-$(CONFIG_USB_EHCI_UNIPHIER) += ehci-uniphier.o
 obj-$(CONFIG_USB_EHCI_VCT) += ehci-vct.o
 obj-$(CONFIG_USB_EHCI_RMOBILE) += ehci-rmobile.o
 obj-$(CONFIG_USB_EHCI_ZYNQ) += ehci-zynq.o
+ifdef CONFIG_USB_DWC_OTG_294
+obj-$(CONFIG_USB_DWC_OTG_HCD) += dwc_otg_hcd_294.o
+else
+obj-$(CONFIG_USB_DWC_OTG_HCD) += dwc_otg_hcd.o
+endif
 
 # xhci
 obj-$(CONFIG_USB_XHCI) += xhci.o xhci-mem.o xhci-ring.o
diff --git a/drivers/usb/host/dwc_otg_hcd.c b/drivers/usb/host/dwc_otg_hcd.c
new file mode 100644
index 0000000..e10b093
--- /dev/null
+++ b/drivers/usb/host/dwc_otg_hcd.c
@@ -0,0 +1,1738 @@
+
+/*
+ * drivers/usb/host/dwc_otg_hcd.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/usb.h>
+#include <usb.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <asm/cache.h>
+
+
+#include "dwc_otg_regs.h"
+#include "dwc_otg_hcd.h"
+
+#define kmalloc(x,y)			malloc(x)
+#define kfree(x)			    free(x)
+
+#define min_t(type,x,y)	\
+	({ type __x = (x); type __y = (y); __x < __y ? __x : __y; })
+
+#define flush_cpu_cache()  do{ dcache_flush();}while(0)//flush_cache //do{_invalidate_dcache();AV_AHB_bus_invalidate();}while(0)	//for porting
+
+/* ------------------------------------------------------- */
+#define get_unaligned_16(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8))
+#define get_unaligned_32(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+//#define get_unaligned(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+
+static dwc_otg_device_t dwc_otg_dev;
+static int dwc_otg_port_init(dwc_otg_core_if_t * _core_if);
+static int is_insert = 0;
+/* The bits respond the channel buy_state. */
+//static unsigned int chn_busy;
+/*
+void dwc_udelay(int dly)
+{
+	int i;
+	for (i = 0;i<4000;i++) ;
+}
+*/
+#define dwc_udelay(dly) udelay(dly)
+/*
+ * Host module config
+ */
+static dwc_otg_core_params_t dwc_otg_module_params_host = {
+    DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE,       /* otg_cap */
+    0,                          /* dma_enable */
+    -1,                         /* dma_burst_size */
+    DWC_SPEED_PARAM_HIGH,       /* speed */
+    0,                          /* host_support_fs_ls_low_power */
+    0,                          /* host_ls_low_power_phy_clk */
+    1,                          /* enable_dynamic_fifo */
+    -1,                         /* data_fifo_size */
+    0x100,                      /* dev_rx_fifo_size */
+    0x100,                      /* dev_nperio_tx_fifo_size */
+    {-1,                        /* dev_perio_tx_fifo_size *//* 0 */
+     -1,                        /* 1 */
+     -1,                        /* 2 */
+     -1,                        /* 3 */
+     -1,                        /* 4 */
+     -1,                        /* 5 */
+     -1,                        /* 6 */
+     -1,                        /* 7 */
+     -1,                        /* 8 */
+     -1,                        /* 9 */
+     -1,                        /* 10 */
+     -1,                        /* 11 */
+     -1,                        /* 12 */
+     -1,                        /* 13 */
+     -1},                       /* 14 */
+    320,                        /* host_rx_fifo_size */
+    256,                        /* host_nperio_tx_fifo_size */
+    -1,                         /* host_perio_tx_fifo_size */
+    65535,                      /* max_transfer_size */
+    128,                        /* max_packet_count */
+    6,                          /* host_channels */
+    2,                          /* dev_endpoints */
+    -1,                         /* phy_type */
+    -1,                         /* phy_utmi_width */
+    0,                          /* phy_ulpi_ddr */
+    0,                          /* i2c_enable */
+};
+
+/**
+ * This function disables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+static void
+dwc_otg_disable_global_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    ahbcfg.b.glblintrmsk = 0;   /* disable interrupts */
+    dwc_modify_reg32(&_core_if->core_global_regs->gahbcfg, ahbcfg.d32, 0);
+}
+/**
+ * This function enables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+extern void
+dwc_otg_enable_global_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    ahbcfg.b.glblintrmsk = 1;   /* Enable interrupts */
+    dwc_modify_reg32(&_core_if->core_global_regs->gahbcfg, 0, ahbcfg.d32);
+}
+
+static dwc_otg_core_if_t *
+dwc_otg_cil_init(const uint32_t * _reg_base_addr, dwc_otg_core_params_t * _core_params)
+{
+
+    dwc_otg_core_if_t *core_if = 0;
+    // dwc_otg_dev_if_t *dev_if = 0;
+    dwc_otg_host_if_t *host_if = 0;
+    uint8_t        *reg_base = (uint8_t *) _reg_base_addr;
+    int             i = 0;
+
+    DWC_DEBUGPL(DBG_CILV, "%s(%p,%p)\n", __func__, _reg_base_addr, _core_params);
+
+    core_if = (dwc_otg_core_if_t *) kmalloc(sizeof(dwc_otg_core_if_t), 0);
+
+    if (core_if == 0) {
+        DWC_DEBUGPL(DBG_CIL, "Allocation of dwc_otg_core_if_t failed\n");
+        return 0;
+    }
+
+    memset(core_if, 0, sizeof(dwc_otg_core_if_t));
+
+    core_if->core_params = _core_params;
+    core_if->core_global_regs = (dwc_otg_core_global_regs_t *) reg_base;
+
+    /*
+     * Allocate the Host Mode structures.
+     */
+    host_if = (dwc_otg_host_if_t *) kmalloc(sizeof(dwc_otg_host_if_t), 0);
+
+    if (host_if == 0) {
+        DWC_DEBUGPL(DBG_CIL, "Allocation of dwc_otg_host_if_t failed\n");
+        // kfree(dev_if);
+        kfree(core_if);
+        return 0;
+    }
+
+    host_if->host_global_regs = (dwc_otg_host_global_regs_t *)
+        (reg_base + DWC_OTG_HOST_GLOBAL_REG_OFFSET);
+
+    host_if->hprt0 = (uint32_t *) (reg_base + DWC_OTG_HOST_PORT_REGS_OFFSET);
+
+    for (i = 0; i < MAX_EPS_CHANNELS; i++) {
+        host_if->hc_regs[i] = (dwc_otg_hc_regs_t *)
+            (reg_base + DWC_OTG_HOST_CHAN_REGS_OFFSET + (i * DWC_OTG_CHAN_REGS_OFFSET));
+        DWC_DEBUGPL(DBG_CILV, "hc_reg[%d]->hcchar=%p\n", i, &host_if->hc_regs[i]->hcchar);
+    }
+
+    host_if->num_host_channels = MAX_EPS_CHANNELS;
+    core_if->host_if = host_if;
+
+    for (i = 0; i < MAX_EPS_CHANNELS; i++) {
+        core_if->data_fifo[i] =
+            (uint32_t *) (reg_base + DWC_OTG_DATA_FIFO_OFFSET + (i * DWC_OTG_DATA_FIFO_SIZE));
+        DWC_DEBUGPL(DBG_CILV, "data_fifo[%d]=0x%08x\n", i, (unsigned) core_if->data_fifo[i]);
+    }
+
+    core_if->pcgcctl = (uint32_t *) (reg_base + DWC_OTG_PCGCCTL_OFFSET);
+
+    /*
+     * Store the contents of the hardware configuration registers here for
+     * easy access later.
+     */
+    core_if->hwcfg1.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg1);
+    core_if->hwcfg2.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg2);
+    core_if->hwcfg3.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg3);
+    core_if->hwcfg4.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg4);
+
+    DWC_DEBUGPL(DBG_CILV, "hwcfg1=%08x\n", core_if->hwcfg1.d32);
+    DWC_DEBUGPL(DBG_CILV, "hwcfg2=%08x\n", core_if->hwcfg2.d32);
+    DWC_DEBUGPL(DBG_CILV, "hwcfg3=%08x\n", core_if->hwcfg3.d32);
+    DWC_DEBUGPL(DBG_CILV, "hwcfg4=%08x\n", core_if->hwcfg4.d32);
+
+    DWC_DEBUGPL(DBG_CILV, "op_mode=%0x\n", core_if->hwcfg2.b.op_mode);
+    DWC_DEBUGPL(DBG_CILV, "arch=%0x\n", core_if->hwcfg2.b.architecture);
+    DWC_DEBUGPL(DBG_CILV, "num_dev_ep=%d\n", core_if->hwcfg2.b.num_dev_ep);
+    DWC_DEBUGPL(DBG_CILV, "num_host_chan=%d\n", core_if->hwcfg2.b.num_host_chan);
+    DWC_DEBUGPL(DBG_CILV, "nonperio_tx_q_depth=0x%0x\n", core_if->hwcfg2.b.nonperio_tx_q_depth);
+    DWC_DEBUGPL(DBG_CILV, "host_perio_tx_q_depth=0x%0x\n", core_if->hwcfg2.b.host_perio_tx_q_depth);
+    DWC_DEBUGPL(DBG_CILV, "dev_token_q_depth=0x%0x\n", core_if->hwcfg2.b.dev_token_q_depth);
+
+    DWC_DEBUGPL(DBG_CILV, "Total FIFO SZ=%d\n", core_if->hwcfg3.b.dfifo_depth);
+    DWC_DEBUGPL(DBG_CILV, "xfer_size_cntr_width=%0x\n", core_if->hwcfg3.b.xfer_size_cntr_width);
+
+    /*
+     * Set the SRP sucess bit for FS-I2c
+     */
+    core_if->srp_success = 0;
+    core_if->srp_timer_started = 0;
+    core_if->temp_buffer = kmalloc(DWC_OTG_MAX_TRANSFER_SIZE, 0);
+    if (!core_if->temp_buffer) {
+        kfree(core_if->host_if);
+        kfree(core_if);
+        return 0;
+    }
+
+    return core_if;
+
+}
+/**
+ * This function initializes the commmon interrupts, used in both
+ * device and host modes.
+ *
+ * @param[in] _core_if Programming view of the DWC_otg controller
+ *
+ */
+static void
+dwc_otg_enable_common_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    gintmsk_data_t  intr_mask = {.d32 = 0 };
+
+    /*
+     * Clear any pending OTG Interrupts
+     */
+    dwc_write_reg32(&global_regs->gotgint, 0xFFFFFFFF);
+
+    /*
+     * Clear any pending interrupts
+     */
+    dwc_write_reg32(&global_regs->gintsts, 0xFFFFFFFF);
+
+    /*
+     * Enable the interrupts in the GINTMSK.
+     */
+    intr_mask.b.modemismatch = 1;
+    intr_mask.b.otgintr = 1;
+
+    if (!_core_if->dma_enable) {
+        intr_mask.b.rxstsqlvl = 1;
+    }
+
+    intr_mask.b.conidstschng = 1;
+    intr_mask.b.wkupintr = 1;
+    intr_mask.b.disconnect = 1;
+    intr_mask.b.usbsuspend = 1;
+    intr_mask.b.sessreqintr = 1;
+    dwc_write_reg32(&global_regs->gintmsk, intr_mask.d32);
+}
+/**
+ * Do core a soft reset of the core.  Be careful with this because it
+ * resets all the internal state machines of the core.
+ */
+void
+dwc_otg_core_reset(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    volatile grstctl_t greset = {.d32 = 0 };
+    int             count = 0;
+
+    DBG("%s\n", __func__);
+    /*
+     * Wait for AHB master IDLE state.
+     */
+    do {
+        dwc_udelay(10);
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 100000) {
+            DBG("%s() HANG! AHB Idle GRSTCTL=%0x\n", __func__, greset.d32);
+            return;
+        }
+    }
+    while (greset.b.ahbidle == 0);
+
+    /*
+     * Core Soft Reset
+     */
+    count = 0;
+    greset.b.csftrst = 1;
+    dwc_write_reg32(&global_regs->grstctl, greset.d32);
+    do {
+        dwc_udelay(10);
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 1000000) {
+            DBG("%s() HANG! Soft Reset GRSTCTL=%0x\n", __func__, greset.d32);
+            break;
+        }
+    }
+    while (greset.b.csftrst == 1);
+
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    wait_ms(100);
+}
+
+/**
+ * Initializes the FSLSPClkSel field of the HCFG register depending on the PHY
+ * type.
+ */
+static void
+init_fslspclksel(dwc_otg_core_if_t * _core_if)
+{
+    uint32_t        val;
+    hcfg_data_t     hcfg;
+
+    if (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS) {
+        /*
+         * Full speed PHY
+         */
+        val = DWC_HCFG_48_MHZ;
+    } else {
+        /*
+         * High speed PHY running at full speed or high speed
+         */
+        val = DWC_HCFG_30_60_MHZ;
+    }
+
+    DWC_DEBUGPL(DBG_CIL, "Initializing HCFG.FSLSPClkSel to 0x%1x\n", val);
+    hcfg.d32 = dwc_read_reg32(&_core_if->host_if->host_global_regs->hcfg);
+    hcfg.b.fslspclksel = val;
+    dwc_write_reg32(&_core_if->host_if->host_global_regs->hcfg, hcfg.d32);
+}
+
+/**
+ * Initializes the DevSpd field of the DCFG register depending on the PHY type
+ * and the enumeration speed of the device.
+ */
+static void
+init_devspd(dwc_otg_core_if_t * _core_if)
+{
+    uint32_t        val;
+    dcfg_data_t     dcfg;
+
+    if (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS) {
+        /*
+         * Full speed PHY
+         */
+        val = 0x3;
+    } else if (_core_if->core_params->speed == DWC_SPEED_PARAM_FULL) {
+        /*
+         * High speed PHY running at full speed
+         */
+        val = 0x1;
+    } else {
+        /*
+         * High speed PHY running at high speed
+         */
+        val = 0x0;
+    }
+
+    DWC_DEBUGPL(DBG_CIL, "Initializing DCFG.DevSpd to 0x%1x\n", val);
+    dcfg.d32 = dwc_read_reg32(&_core_if->dev_if->dev_global_regs->dcfg);
+    dcfg.b.devspd = val;
+    dwc_write_reg32(&_core_if->dev_if->dev_global_regs->dcfg, dcfg.d32);
+}
+
+/**
+ * This function initializes the DWC_otg controller registers and
+ * prepares the core for device mode or host mode operation.
+ *
+ * @param _core_if Programming view of the DWC_otg controller
+ *
+ */
+
+int
+dwc_otg_core_init(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    // dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    gusbcfg_data_t  usbcfg = {.d32 = 0 };
+    gi2cctl_data_t  i2cctl = {.d32 = 0 };
+
+    DWC_DEBUGPL(DBG_CILV, "dwc_otg_core_init(%p)\n", _core_if);
+
+    /*
+     * Reset the Controller
+     */
+    dwc_otg_core_reset(_core_if);
+
+    _core_if->total_fifo_size = _core_if->hwcfg3.b.dfifo_depth;
+    _core_if->rx_fifo_size = dwc_read_reg32(&global_regs->grxfsiz);
+    _core_if->nperio_tx_fifo_size = dwc_read_reg32(&global_regs->gnptxfsiz) >> 16;
+
+    DWC_DEBUGPL(DBG_CIL, "Total FIFO SZ=%d\n", _core_if->total_fifo_size);
+    DWC_DEBUGPL(DBG_CIL, "Rx FIFO SZ=%d\n", _core_if->rx_fifo_size);
+    DWC_DEBUGPL(DBG_CIL, "NP Tx FIFO SZ=%d\n", _core_if->nperio_tx_fifo_size);
+
+    /*
+     * This programming sequence needs to happen in FS mode before any other
+     * programming occurs
+     */
+    if ((_core_if->core_params->speed == DWC_SPEED_PARAM_FULL) &&
+        (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS)) {
+        /*
+         * If FS mode with FS PHY
+         */
+
+        /*
+         * core_init() is now called on every switch so only call the
+         * following for the first time through.
+         */
+        if (!_core_if->phy_init_done) {
+            _core_if->phy_init_done = 1;
+            DWC_DEBUGPL(DBG_CIL, "FS_PHY detected\n");
+            usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+            usbcfg.b.physel = 1;
+            dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+
+            /*
+             * Reset after a PHY select
+             */
+            dwc_otg_core_reset(_core_if);
+        }
+
+        /*
+         * Program DCFG.DevSpd or HCFG.FSLSPclkSel to 48Mhz in FS. Also do
+         * this on HNP Dev/Host mode switches (done in dev_init and
+         * host_init).
+         */
+        if (dwc_otg_is_host_mode(_core_if)) {
+            init_fslspclksel(_core_if);
+        } else {
+            init_devspd(_core_if);
+        }
+
+        if (_core_if->core_params->i2c_enable) {
+            DWC_DEBUGPL(DBG_CIL, "FS_PHY Enabling I2c\n");
+            /*
+             * Program GUSBCFG.OtgUtmifsSel to I2C
+             */
+            usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+            usbcfg.b.otgutmifssel = 1;
+            dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+
+            /*
+             * Program GI2CCTL.I2CEn
+             */
+            i2cctl.d32 = dwc_read_reg32(&global_regs->gi2cctl);
+            i2cctl.b.i2cdevaddr = 1;
+            i2cctl.b.i2cen = 0;
+            dwc_write_reg32(&global_regs->gi2cctl, i2cctl.d32);
+            i2cctl.b.i2cen = 1;
+            dwc_write_reg32(&global_regs->gi2cctl, i2cctl.d32);
+        }
+
+    }
+    /*
+     * endif speed == DWC_SPEED_PARAM_FULL
+     */
+    else {
+        /*
+         * High speed PHY.
+         */
+        if (!_core_if->phy_init_done) {
+            _core_if->phy_init_done = 1;
+            /*
+             * HS PHY parameters.  These parameters are preserved during soft
+             * reset so only program the first time.  Do a soft reset
+             * immediately after setting phyif.
+             */
+            usbcfg.b.ulpi_utmi_sel = _core_if->core_params->phy_type;
+            if (usbcfg.b.ulpi_utmi_sel == 1) {
+                /*
+                 * ULPI interface
+                 */
+                usbcfg.b.phyif = 0;
+                usbcfg.b.ddrsel = _core_if->core_params->phy_ulpi_ddr;
+            } else {
+                /*
+                 * UTMI+ interface
+                 */
+                if (_core_if->core_params->phy_utmi_width == 16) {
+                    usbcfg.b.phyif = 1;
+                } else {
+                    usbcfg.b.phyif = 0;
+                }
+            }
+
+            dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+
+            /*
+             * Reset after setting the PHY parameters
+             */
+            dwc_otg_core_reset(_core_if);
+        }
+    }
+
+    /*
+     * Program the GAHBCFG Register.
+     */
+    switch (_core_if->hwcfg2.b.architecture) {
+
+    case DWC_SLAVE_ONLY_ARCH:
+        DWC_DEBUGPL(DBG_CIL, "Slave Only Mode\n");
+        ahbcfg.b.nptxfemplvl_txfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY;
+        ahbcfg.b.ptxfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY;
+        _core_if->dma_enable = 0;
+        break;
+
+    case DWC_EXT_DMA_ARCH:
+        DWC_DEBUGPL(DBG_CIL, "External DMA Mode\n");
+        ahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR8;
+        _core_if->dma_enable = (_core_if->core_params->dma_enable != 0);
+        break;
+
+    case DWC_INT_DMA_ARCH:
+        DWC_DEBUGPL(DBG_CIL, "Internal DMA Mode\n");
+        // ahbcfg.b.hburstlen =
+        // _core_if->core_params->dma_burst_size;//config by out world
+        ahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR8;   // config by
+        // out world
+        _core_if->dma_enable = (_core_if->core_params->dma_enable != 0);
+        break;
+
+    }
+
+    ahbcfg.b.dmaenable = _core_if->dma_enable;
+    dwc_write_reg32(&global_regs->gahbcfg, ahbcfg.d32);
+
+    // _core_if->en_multiple_tx_fifo = _core_if->hwcfg4.b.ded_fifo_en;
+
+
+    /*
+     * Program the GUSBCFG register.
+     */
+    usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+
+    switch (_core_if->hwcfg2.b.op_mode) {
+    case DWC_MODE_HNP_SRP_CAPABLE:
+        usbcfg.b.hnpcap = (_core_if->core_params->otg_cap == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE);
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_SRP_ONLY_CAPABLE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_NO_HNP_SRP_CAPABLE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = 0;
+        break;
+
+    case DWC_MODE_SRP_CAPABLE_DEVICE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_NO_SRP_CAPABLE_DEVICE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = 0;
+        break;
+
+    case DWC_MODE_SRP_CAPABLE_HOST:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_NO_SRP_CAPABLE_HOST:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = 0;
+        break;
+    }
+
+    dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+
+    /*
+     * Enable common interrupts
+     */
+    dwc_otg_enable_common_interrupts(_core_if);
+
+    /*
+     * Do device or host intialization based on mode during PCD and HCD
+     * initialization
+     */
+    if (dwc_otg_is_host_mode(_core_if)) {
+        DWC_DEBUGPL(DBG_ANY, "Host Mode\n");
+        _core_if->op_state = A_HOST;
+    } else {
+        ERR("Device Mode\n");
+        _core_if->op_state = B_PERIPHERAL;
+#ifdef DWC_DEVICE_ONLY
+        dwc_otg_core_dev_init(_core_if);
+#endif
+    return -1;
+    }
+     return 0;
+
+}
+/**
+ * This function disables the Host Mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+void
+dwc_otg_disable_host_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+
+    DWC_DEBUGPL(DBG_CILV, "%s()\n", __func__);
+
+    dwc_write_reg32 (&global_regs->gintmsk, 0);
+    dwc_modify_reg32 (&global_regs->gahbcfg, 1, 0);
+
+}
+
+/**
+ * Halts the DWC_otg host mode operations in a clean manner. USB transfers are
+ * stopped.
+ */
+void
+dwc_otg_hcd_stop(dwc_otg_core_if_t * core_if)
+{
+    hprt0_data_t    hprt0 = {.d32 = 0 };
+    pcgcctl_data_t hcgcctl = {.d32 = 0};
+
+    if (core_if == 0)
+        return;
+
+    DBG("DWC OTG HCD STOP\n");
+
+    /*
+     * Turn off all host-specific interrupts.
+     */
+    dwc_otg_disable_host_interrupts(core_if);
+
+    /*
+     * The root hub should be disconnected before this function is called.
+     * The disconnect will clear the QTD lists (via ..._hcd_urb_dequeue)
+     * and the QH lists (via ..._hcd_endpoint_disable).
+     */
+
+    /*
+     * Turn off the vbus power
+     */
+    DBG("PortPower off\n");
+    hprt0.b.prtpwr = 0;
+    dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+
+    hcgcctl.b.stoppclk  = 1;
+    hcgcctl.b.gatehclk = 1;
+    hcgcctl.b.pwrclmp = 1;
+    //hcgcctl.b.rstpdwnmodule = 1;
+	//printf("core_if->pcgcctl  : 0x%x, & = 0x%x\n",core_if->pcgcctl,&core_if->pcgcctl );
+
+    dwc_write_reg32(core_if->pcgcctl,hcgcctl.d32);
+    return;
+}
+
+
+/*
+ * --- API functions ------------------------------------------------------
+ */
+int
+submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer, int len, int interval)
+{
+    DBG("dev=%p pipe=%#lx buf=%p size=%d int=%d", dev, pipe, buffer, len, interval);
+
+    return -1;
+}
+static inline int
+max_transfer_len(struct usb_device *dev, unsigned long pipe)
+{
+    unsigned        mpck = usb_maxpacket(dev, pipe);
+
+    /*
+     * One PTD can transfer 1023 bytes but try to always transfer multiples
+     * of endpoint buffer size
+     */
+    return 1023 / mpck * mpck;
+}
+
+/**
+ * Clears the transfer state for a host channel. This function is normally
+ * called after a transfer is done and the host channel is being released.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _hc Identifies the host channel to clean up.
+ */
+void
+dwc_otg_hc_cleanup(dwc_otg_core_if_t * _core_if, int hc_num)
+{
+    dwc_otg_hc_regs_t *hc_regs;
+
+    /*
+     * Clear channel interrupt enables and any unhandled channel interrupt
+     * conditions.
+     */
+    hc_regs = _core_if->host_if->hc_regs[hc_num];
+    dwc_write_reg32(&hc_regs->hcintmsk, 0);
+    dwc_write_reg32(&hc_regs->hcint, 0xFFFFFFFF);
+    dwc_write_reg32(&hc_regs->hctsiz, 0);
+    dwc_write_reg32(&hc_regs->hcdma, 0);
+    dwc_write_reg32(&hc_regs->hcchar, 0);
+
+    flush_cpu_cache();
+
+}
+
+void dwc_otg_read_packet(dwc_otg_core_if_t * core_if, uint8_t * _dest, uint16_t _bytes,int hcnum)
+{
+	int i;
+	int word_count = (_bytes + 3) / 4;
+	volatile uint32_t *fifo = core_if->data_fifo[hcnum];
+	uint32_t *data_buff = (uint32_t *) _dest;
+	for (i = 0; i < word_count; i++, data_buff++) {
+		*data_buff = dwc_read_reg32(fifo);
+	}
+	return;
+}
+
+static void dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_core_if_t * _core_if, int is_setup,int hcnum, void *buffer)
+{
+	host_grxsts_data_t grxsts;
+
+	grxsts.d32 = dwc_read_reg32(&_core_if->core_global_regs->grxstsp);
+	//printf("RxStsQ:ch%d,cnt=%d,pid=%d,PStatus=%d\n",grxsts.b.chnum,grxsts.b.bcnt,grxsts.b.dpid,grxsts.b.pktsts);
+
+	switch (grxsts.b.pktsts) {
+	case DWC_GRXSTS_PKTSTS_IN:
+		/* Read the data into the host buffer. */
+		if (grxsts.b.bcnt > 0) {
+			dwc_otg_read_packet(_core_if, buffer, grxsts.b.bcnt, hcnum);
+			/* Update the HC fields for the next packet received. */
+			buffer += grxsts.b.bcnt;
+		}
+	case DWC_GRXSTS_PKTSTS_IN_XFER_COMP:
+	case DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
+	case DWC_GRXSTS_PKTSTS_CH_HALTED:
+		/* Handled in interrupt, just ignore data */
+		break;
+	default:
+		ERR("RX_STS_Q Interrupt: Unknown status %d\n",
+			  grxsts.b.pktsts);
+		break;
+	}
+
+	return;
+}
+
+void dwc_otg_hc_write_packet(dwc_otg_core_if_t * _core_if, void *buffer,int len, int chn_num)
+{
+	uint32_t i;
+	uint32_t byte_count;
+	uint32_t dword_count;
+
+	uint32_t *data_buff = (uint32_t *)buffer;
+	uint32_t *data_fifo = _core_if->data_fifo[chn_num];//just used channel0
+
+	byte_count = len ;
+
+	dword_count = (byte_count + 3) / 4;
+
+	if ((((unsigned long)data_buff) & 0x3) == 0) {
+		/* xfer_buff is DWORD aligned. */
+		for (i = 0; i < dword_count; i++, data_buff++) {
+			dwc_write_reg32(data_fifo, *data_buff);
+		}
+	} else {
+		/* xfer_buff is not DWORD aligned. */
+
+		for (i = 0; i < dword_count; i++, data_buff++) {
+			dwc_write_reg32(data_fifo, get_unaligned(data_buff));
+		}
+	}
+	//printf("dwc_otg_hc_write_packet finished  %d  %d chn%d\n", dword_count, len,chn_num);
+}
+
+static void dwc_otg_hc_do_ping(dwc_otg_core_if_t *_core_if, int hc_num)
+{
+	hcchar_data_t hcchar;
+	hctsiz_data_t hctsiz;
+	dwc_otg_hc_regs_t *hc_regs = _core_if->host_if->hc_regs[hc_num];
+
+	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, hc_num);
+
+	hctsiz.d32 = 0;
+	hctsiz.b.dopng = 1;
+	hctsiz.b.pktcnt = 1;
+	dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.chen = 1;
+	hcchar.b.chdis = 0;
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+}
+
+static int
+dwc_otg_interrupt(dwc_otg_core_if_t * _core_if, int is_setup,int hcnum,void * buffer)
+{
+    gintsts_data_t  gintsts;
+    dwc_otg_hc_regs_t *hc_regs;
+    hctsiz_data_t   hctsiz;
+    hcint_data_t    hcint;
+    hcchar_data_t   hcchar;
+    hcintmsk_data_t hcintmsk;
+    // dwc_otg_host_if_t *host_if ;
+    int             handled;
+    dwc_otg_host_if_t *host_if = _core_if->host_if;
+
+  do {
+    gintsts.d32 = dwc_read_reg32(&_core_if->core_global_regs->gintsts);
+    hc_regs = host_if->hc_regs[hcnum];
+    hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+    handled = 0;
+
+    if (gintsts.b.rxstsqlvl && (!_core_if->dma_enable)) {
+	    dwc_otg_hcd_handle_rx_status_q_level_intr(_core_if,is_setup,hcnum,buffer);
+        DBG("rxstsqlvl interrupt!\n");
+        _core_if->host_if->do_ping = 0;
+        handled = 1;
+    }
+    if (gintsts.b.hcintr) {
+        //DBG("dwc_otg_interrupt: hcintr interrupt!\n");
+        if (hcint.b.xfercomp) {
+            hctsiz.d32 = dwc_read_reg32(&hc_regs->hctsiz);
+            dwc_otg_hc_cleanup(_core_if, hcnum);
+            if (is_setup)
+                return 8;
+            return (_core_if->transfer_size);// - hctsiz.b.xfersize);
+        }
+        if (hcint.b.ahberr) {
+            ERR("ahberr interrupt!\n");
+            hcintmsk.d32 = 0;
+            hcintmsk.b.chhltd = 1;
+            dwc_write_reg32(&hc_regs->hcintmsk, hcintmsk.d32);
+            dwc_write_reg32(&hc_regs->hcint, ~hcintmsk.d32);
+            hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+            if (hcchar.b.chen == 0)
+                return -1;
+            else {
+                hcchar.b.chen = 1;
+                hcchar.b.chdis = 1;
+                dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+            }
+
+            return -1;
+
+        }
+        if (hcint.b.nyet) {
+            DBG("nyet interrupt!\n");
+            _core_if->host_if->do_ping = 1;
+            //return -1;
+
+        }
+        if (hcint.b.ack) {
+            DBG("ack interrupt!\n");
+            _core_if->host_if->do_ping = 0;
+            //return -1;
+
+        }
+        if (hcint.b.xacterr) {
+            ERR("xacterr interrupt!\n");
+            return -1;
+
+        }
+        if (hcint.b.bblerr) {
+            ERR("bblerr interrupt!\n");
+            return -1;
+        }
+        if (hcint.b.datatglerr) {
+            ERR("datatglerr interrupt!\n");
+            return -1;
+        }
+
+    }
+    if (gintsts.b.portintr) {
+        ERR("hprt0:0x%08x\n",dwc_read_reg32(_core_if->host_if->hprt0));
+        dwc_otg_port_init(_core_if);
+        return -2;
+    }
+
+  }while(handled);
+
+    if (gintsts.b.ptxfempty) {
+        //DBG("ptxfempty interrupt!\n");
+        return -1;
+    }
+    return -1;
+
+}
+
+/*
+ * Do an USB transfer , dir = 0, out ;  dir = 1 , in
+ */
+
+static int
+dwc_otg_submit_job(struct usb_device *dev, unsigned long pipe, int dir, void *buffer, int len,
+                   int is_setup)
+{
+
+    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+    dwc_otg_hc_regs_t *hc_regs;
+    hcchar_data_t   hcchar;
+    hcsplt_data_t   hcsplt;
+    hctsiz_data_t   hctsiz;
+    int             devnum = usb_pipedevice(pipe);
+    int             epnum = usb_pipeendpoint(pipe);
+//    int             dir_in = usb_pipein(pipe);
+    int             toggle,chg_flag = 0;
+    static int             hcnum = 0;
+    hcintmsk_data_t hcintmsk;
+    dwc_otg_host_if_t *host_if = core_if->host_if;
+    int stat, timeout;
+    int allchannel_int_mask;
+    hcint_data_t    hcint;
+    dwc_otg_host_global_regs_t *host_global_regs = host_if->host_global_regs;
+
+//    printf("dwc_otg_submit_job: dev: %d ,dev->parent: %x, dev->speed: %d\n",
+//		dev->devnum,dev->parent,dev->speed);
+
+//	struct usb_device * hub1 = usb_get_dev_index(1);
+
+//	if(hub1)
+//	    printf("root_hub speed %d\n",hub1->speed);
+//	if(dev->parent != NULL) //not roothub
+//		if(dev->parent->speed ==2 && dev->speed != 2 )
+//			return -EOPNOTSUPP;
+
+    int             type = usb_pipetype(pipe);
+    if (len >= 4096) {
+        ERR("Too big job!\n");
+        dev->status = USB_ST_CRC_ERR;
+        return -E2BIG;
+    }
+
+    if (type == PIPE_ISOCHRONOUS) {
+        ERR("isochronous transfers not supported");
+        dev->status = USB_ST_CRC_ERR;
+        return -EOPNOTSUPP;
+    }
+
+    //hcnum++;
+    if (hcnum > 6) hcnum = 0;
+
+    hc_regs = host_if->hc_regs[hcnum];
+  /*
+	if (!is_insert && (!core_if->dma_enable)) {
+		wait_ms(10);
+		if (dwc_otg_interrupt(core_if, is_setup,hcnum,buffer) == -2)
+			is_insert = 1;
+		else{
+			DBG("wait insert failed");
+			return -1;
+		}
+
+	}	*/
+    //chn_busy = chn_busy | 1<<hcnum ;
+    /*
+     * init hc char (corresponding devaddr and epnum)
+     */
+    hcchar.d32 = 0;
+    hcchar.b.devaddr = devnum;
+    hcchar.b.epnum = epnum;
+    hcchar.b.epdir = dir;
+    hcchar.b.lspddev = 0;
+
+    /* set hc interrupt mask */
+    hcintmsk.d32 = dwc_read_reg32(&hc_regs->hcintmsk);
+    //hcintmsk.b.xfercompl = 1;
+    hcintmsk.d32 = 7;
+    dwc_write_reg32(&hc_regs->hcintmsk, hcintmsk.d32 );
+
+    /* clear int status*/
+    hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+
+    dwc_write_reg32(&hc_regs->hcint, hcint.d32 );
+
+    /* set all channel interrupt mask */
+    allchannel_int_mask = dwc_read_reg32(&host_global_regs->haintmsk);
+    allchannel_int_mask |= 1;
+    dwc_write_reg32(&host_global_regs->haintmsk, allchannel_int_mask);
+
+    switch (usb_pipetype(pipe)) {
+    case PIPE_CONTROL:
+        hcchar.b.eptype = DWC_OTG_EP_TYPE_CONTROL;
+        break;
+    case PIPE_BULK:
+        hcchar.b.eptype = DWC_OTG_EP_TYPE_BULK;
+        break;
+    case PIPE_INTERRUPT:
+    case PIPE_ISOCHRONOUS:
+        ERR("dwc_otg_submit_job: not support iso or interrupt transfer!\n");
+        return -1;
+    }
+
+    hcchar.b.mps = usb_maxpacket(dev, pipe);
+
+    dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+    hcsplt.d32 = 0;
+
+    dwc_write_reg32(&hc_regs->hcsplt, hcsplt.d32);
+    flush_cpu_cache();
+
+
+    hctsiz.d32 = 0;
+
+    hctsiz.b.pktcnt = (len  + usb_maxpacket(dev, pipe) - 1)/ usb_maxpacket(dev, pipe);
+    if (hctsiz.b.pktcnt < 1)
+        hctsiz.b.pktcnt = 1;
+    if (hctsiz.b.pktcnt & 0x1)
+        chg_flag = 1;
+    toggle = usb_gettoggle(dev, epnum, dir);
+    DBG("packet is :%d, max packet size = %d,toggle %d\n",
+		hctsiz.b.pktcnt, usb_maxpacket(dev, pipe), toggle);
+
+    switch (toggle) {
+    case 0:
+        hctsiz.b.pid = DWC_OTG_HC_PID_DATA0;
+        break;
+    case 1:
+        hctsiz.b.pid = DWC_OTG_HC_PID_DATA1;
+        break;
+    default:
+        ERR("error toggle!\n");
+        return -EPROTO;
+    }
+    if (is_setup)
+        hctsiz.b.pid = DWC_OTG_HC_PID_SETUP;
+
+    core_if->transfer_size = len;
+    hctsiz.b.xfersize = len;
+
+    if (!is_setup && dir == 0 && core_if->host_if->do_ping) {
+		if (!core_if->dma_enable) {
+		dwc_otg_hc_do_ping(core_if, 0);
+		return -10;//It's ping state,pls do it again!
+	}
+        hctsiz.b.dopng = 1;
+    }
+    else
+        hctsiz.b.dopng = 0;
+
+    DBG("ep%d packet is :%d, max packet size = %d = %d,b.len %d\n", hcchar.b.epnum,\
+		hctsiz.b.pktcnt, usb_maxpacket(dev, pipe), hcchar.b.mps,hctsiz.b.xfersize);
+
+    dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+
+    dwc_write_reg32(&hc_regs->hcdma, (uint32_t) buffer);
+    flush_cpu_cache();
+
+    hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+
+    hcchar.b.multicnt = 1;      // for no split transfer set this bit 1
+    hcchar.b.chen = 1;
+    hcchar.b.chdis = 0;
+
+    dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+
+    if (!core_if->dma_enable && !dir && len > 0) {
+        /* Load OUT packet into the appropriate Tx FIFO. */
+        dwc_otg_hc_write_packet(core_if, buffer,len,hcnum);
+    }
+    else
+        ;//printf("dmaable:%d, %s,len=%d\n",core_if->dma_enable,dir?"IN":"OUT",len);
+
+    if (usb_pipebulk(pipe))
+        timeout = 1000;
+    else
+        timeout = 100;
+    /*
+     * Wait for it to complete
+     */
+    while (1) {
+        udelay(20);
+        /*
+         * Check whether the controller is done
+         */
+        stat = dwc_otg_interrupt(core_if, is_setup,hcnum,buffer);
+
+        if (stat >= 0) {
+			if (chg_flag)
+			      usb_dotoggle(dev, epnum, dir);
+		      break;
+        }
+
+        /*
+         * Check the timeout
+         */
+        if (--timeout)
+			udelay(10);
+        else {
+	    hctsiz.d32 = dwc_read_reg32(&hc_regs->hctsiz);
+            DBG("TIMEOUT-%s-%d-%d-%d\n",dir?"IN":"OUT",len,hctsiz.b.pktcnt,usb_pipetype(pipe));
+            break;
+        }
+    }
+    return stat;
+}
+#define CTL_RETRY 5
+int
+submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+                   int len, struct devrequest *setup)
+{
+    int             epnum = usb_pipeendpoint(pipe);
+    int             dir_in = usb_pipein(pipe);
+    int             done;
+    int             ret,retry;
+    //char            *buffer;
+//    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+
+    /*
+     * Setup phase
+     */
+    retry = 0;
+SETUP_RETRY:
+    DBG("--- SETUP PHASE  --------------------try: %d\n",retry);
+    DBG("dev=%ld ep=%ld buf=%x size=%d %s req:%d",
+        usb_pipedevice(pipe), usb_pipeendpoint(pipe), buffer, len, (dir_in?"dir_in":"dir_out"),setup->request);
+
+    usb_settoggle(dev, epnum, 1, 0);
+    ret = dwc_otg_submit_job(dev, pipe, 0, setup, sizeof(struct devrequest), 1);
+    if (ret < 0) {
+       if (retry++ < CTL_RETRY)
+            goto SETUP_RETRY;
+    else{ is_insert = 0;
+           ERR("control setup phase error (ret = %d)", ret);
+           return -1;
+       }
+    }
+
+    /*
+     * Data phase
+     */
+    retry = 0;
+DATA_RETRY:
+    DBG("--- DATA PHASE   --------------------try: %d\n",retry);
+
+
+    done = 0;
+    usb_settoggle(dev, epnum, dir_in, 1);
+    if (done < len) {
+
+       dwc_udelay(100);
+
+        ret = dwc_otg_submit_job(dev, pipe,
+                                 dir_in,
+                                 (__u8 *) buffer, len, 0);
+
+        if (ret < 0) {
+                if (retry++ < CTL_RETRY)
+                        goto DATA_RETRY;
+                else{ is_insert = 0;
+                        ERR("control data phase error (ret = %d)", ret);
+                        return -1;
+                }
+        }
+        //if (!dir_in && ret < usb_maxpacket(dev, pipe))  /* short packet */
+        //    break;
+
+        done += ret;
+    }
+
+    /*
+     * Status phase
+     */
+    retry = 0;
+STATUS_RETRY:
+    DBG("--- STATUS PHASE -------------------try: %d\n",retry);
+    dwc_udelay(100);
+
+    usb_settoggle(dev, epnum, !dir_in, 1);
+    ret = dwc_otg_submit_job(dev, pipe, !dir_in, NULL, 0, 0);
+    if (ret < 0) {
+          if (retry++ < CTL_RETRY)
+               goto STATUS_RETRY;
+          else{ is_insert = 0;
+               ERR("control status phase error (ret = %d)", ret);
+               return -1;
+          }
+    }
+
+    dev->act_len = done;
+    DBG("return size = %d\n", done);
+    dev->status = 0;
+
+    return done;
+}
+
+
+int
+submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buf, int len)
+{
+    int             dir_out = usb_pipeout(pipe);
+    int             max = max_transfer_len(dev, pipe);
+//    int             epnum = usb_pipeendpoint(pipe);
+
+    int             done;
+    int             ret;
+//    int             toggle;
+    int             retry;
+    char            *buffer=NULL;
+    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+
+    DBG("--- BULK -----------------------------------------\n");
+    DBG("dev=%ld ep=%ld buf=%x size=%d %s",
+       usb_pipedevice(pipe), usb_pipeendpoint(pipe), buf, len, (dir_out?"dir_out":"dir_in"));
+    if (len == 31)
+		DBG("scsi cmd from CBW: 0x%X\n",*(((unsigned char*)buf)+15));
+
+    done = 0;
+    if (dir_out) {
+        memcpy(core_if->temp_buffer, buf, len);
+    }
+    buffer = core_if->temp_buffer;
+    retry = 5;
+    while (done < len) {
+RETRY:
+       dwc_udelay(100);
+
+        ret = dwc_otg_submit_job(dev, pipe,
+                                 !dir_out,
+                                 (__u8 *) buffer + done, max > len - done ? len - done : max, 0);
+        if (ret < 0 ) {
+            if (retry--) {
+                DBG("error on bulk message, retry: %d",retry);
+                goto RETRY;
+            }else{
+                is_insert = 0;
+                ERR("error on bulk message (ret = %d)", ret);
+                return -1;
+            }
+        }
+
+        done += ret;
+
+        //usb_dotoggle(dev, epnum, !dir_out);
+
+        if (!dir_out && ret < max)      /* short packet */
+            break;
+
+    }
+    DBG("return size = %d\n", done);
+    if (!dir_out) {
+        memcpy(buf, buffer, len);
+    }
+    dev->act_len = done;
+    dev->status = 0;
+
+    return 0;
+}
+/**
+ * Flush a Tx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _num Tx FIFO to flush.
+ */
+extern void
+dwc_otg_flush_tx_fifo(dwc_otg_core_if_t * _core_if, const int _num)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    grstctl_t       greset = { 0 };
+    int             count = 0;
+
+    DWC_DEBUGPL((DBG_CIL | DBG_PCDV), "Flush Tx FIFO %d\n", _num);
+
+    greset.b.txfflsh = 1;
+    greset.b.txfnum = _num;
+    dwc_write_reg32(&global_regs->grstctl, greset.d32);
+
+    do {
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 10000) {
+            WARN("%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
+                 "dwc_otg_flush_tx_fifo", greset.d32, dwc_read_reg32(&global_regs->gnptxsts));
+            break;
+        }
+
+    } while (greset.b.txfflsh == 1);
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    wait_ms(1);
+}
+
+/**
+ * Flush Rx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+extern void
+dwc_otg_flush_rx_fifo(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    volatile grstctl_t greset = { 0 };
+    int             count = 0;
+
+    DWC_DEBUGPL((DBG_CIL | DBG_PCDV), "%s\n", "dwc_otg_flush_rx_fifo");
+    /*
+     *
+     */
+    greset.b.rxfflsh = 1;
+    dwc_write_reg32(&global_regs->grstctl, greset.d32);
+
+    do {
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 10000) {
+            WARN("%s() HANG! GRSTCTL=%0x\n", "dwc_otg_flush_rx_fifo", greset.d32);
+            break;
+        }
+    } while (greset.b.rxfflsh == 1);
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    wait_ms(1);
+}
+static void
+dwc_otg_set_vbus_power(dwc_otg_core_if_t * _core_if, int is_power_on)
+{
+	if ( _core_if->set_vbus_power)
+		 _core_if->set_vbus_power(is_power_on);
+}
+/**
+ * This function Reads HPRT0 in preparation to modify.  It keeps the
+ * WC bits 0 so that if they are read as 1, they won't clear when you
+ * write it back
+ */
+static inline   uint32_t
+dwc_otg_read_hprt0(dwc_otg_core_if_t * _core_if)
+{
+    hprt0_data_t    hprt0;
+    hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+    hprt0.b.prtena = 0;
+    hprt0.b.prtconndet = 0;
+    hprt0.b.prtenchng = 0;
+    hprt0.b.prtovrcurrchng = 0;
+    return hprt0.d32;
+}
+/**
+ * This function enables the Host mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+void
+dwc_otg_enable_host_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    gintmsk_data_t  intr_mask = { 0 };
+
+    DWC_DEBUGPL(DBG_CIL, "%s()\n", "dwc_otg_enable_host_interrupts");
+
+    /*
+     * Disable all interrupts.
+     */
+    dwc_write_reg32(&global_regs->gintmsk, 0);
+
+    /*
+     * Clear any pending interrupts.
+     */
+    dwc_write_reg32(&global_regs->gintsts, 0xFFFFFFFF);
+
+    /*
+     * Enable the common interrupts
+     */
+    dwc_otg_enable_common_interrupts(_core_if);
+
+    /*
+     * Enable host mode interrupts without disturbing common
+     * interrupts.
+     */
+#ifndef NO_HOST_SOF
+    intr_mask.b.sofintr = 1;
+#endif
+    intr_mask.b.portintr = 1;//6.1.1
+    intr_mask.b.hcintr = 1;
+
+    dwc_modify_reg32(&global_regs->gintmsk, intr_mask.d32, intr_mask.d32);
+}
+
+/**
+ * This function initializes the DWC_otg controller registers for
+ * host mode.
+ *
+ * This function flushes the Tx and Rx FIFOs and it flushes any entries in the
+ * request queues. Host channels are reset to ensure that they are ready for
+ * performing transfers.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ *
+ */
+void
+dwc_otg_core_host_init(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    dwc_otg_host_if_t *host_if = _core_if->host_if;
+    dwc_otg_core_params_t *params = _core_if->core_params;
+    hprt0_data_t    hprt0 = { 0 };
+    fifosize_data_t nptxfifosize;
+    fifosize_data_t ptxfifosize;
+    int             i;
+    hcchar_data_t   hcchar;
+    hcfg_data_t     hcfg;
+    dwc_otg_hc_regs_t *hc_regs;
+    int             num_channels;
+    gotgctl_data_t  gotgctl = { 0 };
+
+    DWC_DEBUGPL(DBG_CILV, "%s(%p)\n", "dwc_otg_core_host_init", _core_if);
+
+    /*
+     * Restart the Phy Clock
+     */
+    dwc_write_reg32(_core_if->pcgcctl, 0);
+
+    /*
+     * Initialize Host Configuration Register
+     */
+    init_fslspclksel(_core_if);
+    if (_core_if->core_params->speed == DWC_SPEED_PARAM_FULL) {
+        hcfg.d32 = dwc_read_reg32(&host_if->host_global_regs->hcfg);
+        hcfg.b.fslssupp = 1;
+        dwc_write_reg32(&host_if->host_global_regs->hcfg, hcfg.d32);
+    }
+
+    /*
+     * Configure data FIFO sizes 6.1.1.11----6.1.1.13
+     */
+    if (_core_if->hwcfg2.b.dynamic_fifo && params->enable_dynamic_fifo) {
+        DWC_DEBUGPL(DBG_CIL, "Total FIFO Size=%d\n", _core_if->total_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "Rx FIFO Size=%d\n", params->host_rx_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "NP Tx FIFO Size=%d\n", params->host_nperio_tx_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "P Tx FIFO Size=%d\n", params->host_perio_tx_fifo_size);
+
+        /*
+         * Rx FIFO
+         */
+        DWC_DEBUGPL(DBG_CIL, "initial grxfsiz=%08x\n", dwc_read_reg32(&global_regs->grxfsiz));
+        dwc_write_reg32(&global_regs->grxfsiz, params->host_rx_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "new grxfsiz=%08x\n", dwc_read_reg32(&global_regs->grxfsiz));
+
+        /*
+         * Non-periodic Tx FIFO
+         */
+        DWC_DEBUGPL(DBG_CIL, "initial gnptxfsiz=%08x\n", dwc_read_reg32(&global_regs->gnptxfsiz));
+        nptxfifosize.b.depth = params->host_nperio_tx_fifo_size;
+        nptxfifosize.b.startaddr = params->host_rx_fifo_size;
+        dwc_write_reg32(&global_regs->gnptxfsiz, nptxfifosize.d32);
+        DWC_DEBUGPL(DBG_CIL, "new gnptxfsiz=%08x\n", dwc_read_reg32(&global_regs->gnptxfsiz));
+
+        /*
+         * Periodic Tx FIFO
+         */
+        DWC_DEBUGPL(DBG_CIL, "initial hptxfsiz=%08x\n", dwc_read_reg32(&global_regs->hptxfsiz));
+        ptxfifosize.b.depth = params->host_perio_tx_fifo_size;
+        ptxfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
+        dwc_write_reg32(&global_regs->hptxfsiz, ptxfifosize.d32);
+        DWC_DEBUGPL(DBG_CIL, "new hptxfsiz=%08x\n", dwc_read_reg32(&global_regs->hptxfsiz));
+    }
+
+    /*
+     * Clear Host Set HNP Enable in the OTG Control Register
+     */
+    gotgctl.b.hstsethnpen = 1;
+    dwc_modify_reg32(&global_regs->gotgctl, gotgctl.d32, 0);
+
+    /*
+     * Make sure the FIFOs are flushed.
+     */
+    dwc_otg_flush_tx_fifo(_core_if, 0x10 /* all Tx FIFOs */ );
+    dwc_otg_flush_rx_fifo(_core_if);
+
+    /*
+     * Flush out any leftover queued requests.
+     */
+    num_channels = _core_if->core_params->host_channels;
+    for (i = 0; i < num_channels; i++) {
+        hc_regs = _core_if->host_if->hc_regs[i];
+        hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+        hcchar.b.chen = 0;
+        hcchar.b.chdis = 1;
+        hcchar.b.epdir = 0;
+        dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+    }
+
+    /*
+     * Halt all channels to put them into a known state.
+     */
+    for (i = 0; i < num_channels; i++) {
+        int             count = 0;
+        hc_regs = _core_if->host_if->hc_regs[i];
+        hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+        hcchar.b.chen = 1;
+        hcchar.b.chdis = 1;
+        hcchar.b.epdir = 0;
+        dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+        DWC_DEBUGPL(DBG_HCDV, "%s: Halt channel %d\n", "dwc_otg_core_host_init", i);
+        do {
+            hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+            if (++count > 1000) {
+                ERR("%s: Unable to clear halt on channel %d\n", "dwc_otg_core_host_init", i);
+                break;
+            }
+        } while (hcchar.b.chen);
+    }
+
+    /*
+     * Turn on the vbus power.
+     */
+    DBG("Init: Port Power? op_state=%d\n", _core_if->op_state);
+    if (_core_if->op_state == A_HOST) {
+        hprt0.d32 = dwc_otg_read_hprt0(_core_if);
+        DBG("Init: Power Port (%d)\n", hprt0.b.prtpwr);
+        if (hprt0.b.prtpwr == 0) {
+            hprt0.b.prtpwr = 1;//6.1.1.3
+            dwc_write_reg32(host_if->hprt0, hprt0.d32);
+            /*
+             * pull gpio to switch power
+             */
+            dwc_otg_set_vbus_power(_core_if, 1);
+        }
+    } else {
+        dwc_otg_set_vbus_power(_core_if, 0);    // Power off VBus
+    }
+
+    dwc_otg_enable_host_interrupts(_core_if);
+}
+
+static int      dwc_otg_hcd_enable = 0;
+
+/* wait at least 10ms for the reset process to complete 6.1.1.6 */
+static void
+dwc_otg_reset_port(dwc_otg_core_if_t * _core_if)
+{
+    hprt0_data_t    hprt0;
+    hprt0.d32 = dwc_otg_read_hprt0(_core_if);
+    hprt0.b.prtrst = 1;
+    dwc_write_reg32(_core_if->host_if->hprt0, hprt0.d32);
+
+    wait_ms(60);
+
+    hprt0.b.prtrst = 0;
+    dwc_write_reg32(_core_if->host_if->hprt0, hprt0.d32);
+    wait_ms(20);
+
+}
+static int
+dwc_otg_port_init(dwc_otg_core_if_t * _core_if)
+{
+		int retry = 10;
+    hprt0_data_t    hprt0,hprt0_modify;
+    hprt0.d32 = 0;
+/*
+    hprt0.d32 = dwc_otg_read_hprt0(_core_if);
+
+    hprt0_data_t    hprt0_modify;
+
+    hprt0_modify.b.prtena = 0;
+    hprt0_modify.b.prtconndet = 0;
+    hprt0_modify.b.prtenchng = 0;
+    hprt0_modify.b.prtovrcurrchng = 0;
+
+    wait_ms(30);
+*/
+next:
+    hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+    DBG("%s port data is 0x%X", __func__, hprt0.d32);
+
+    hprt0_modify.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+
+    if (hprt0.b.prtconndet) {//wait prtconndet interrupt
+        /*
+         * clear detect intr
+         */
+        wait_ms(30);
+        dwc_write_reg32(_core_if->host_if->hprt0, hprt0_modify.d32);
+        wait_ms(30);
+        /*
+         * reset port  6.1.1.6
+         */
+        dwc_otg_reset_port(_core_if);
+        hprt0_modify.b.prtconndet = 1;
+
+    }else{
+		wait_ms(100);
+		if (retry--)
+			goto next;
+		INFO("No USB device found !");
+		return 0;
+    }
+    /*
+     * Determine if the connected device is a high/full/low speed device
+     */
+    hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+
+    if (hprt0.b.prtenchng) {//6.1.1.8
+        hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+
+        hprt0_modify.b.prtena = 0;
+        hprt0_modify.b.prtconndet = 0;
+        hprt0_modify.b.prtenchng = 0;
+        hprt0_modify.b.prtovrcurrchng = 0;
+        hprt0_modify.b.prtenchng = 1;
+        dwc_write_reg32(_core_if->host_if->hprt0, hprt0_modify.d32);
+
+    }
+
+//    _core_if->host_if->do_ping = 1; // init value
+    _core_if->host_if->do_ping = 0; // init value
+
+    if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_LOW_SPEED) {//6.1.1.9
+        INFO("Lowspeed device found !\n");
+    } else if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_FULL_SPEED) {
+        INFO("Fullspeed device found !\n");
+    } else if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_HIGH_SPEED) {
+        INFO("Highspeed device found !\n");
+    }
+
+		return 1;
+}
+/*
+ * --- Init functions ------------------------------------------------------
+ */
+int
+usb_lowlevel_init(int index,enum usb_init_type init, void **controller)
+{
+    dwc_otg_device_t *dwc_otg_device = &dwc_otg_dev;
+    int             retval = 0;
+    int32_t         snpsid;
+    int             i;
+    amlogic_usb_config_t * usb_config;
+
+    printf("dwc_usb driver version: %s\n",DWC_DRIVER_VERSION);
+
+    usb_config = board_usb_start(BOARD_USB_MODE_HOST,index);
+
+    if (!usb_config || !usb_config->base_addr) {
+		ERR("Bad usb config or base addr! Need call board_usb_init() in board init\n");
+		retval = -1;
+      goto fail;
+		}
+
+    memset(dwc_otg_device, 0, sizeof(dwc_otg_device_t));
+
+		ERR("base addr: 0x%x",usb_config->base_addr);
+    dwc_otg_device->base = (void *)usb_config->base_addr;
+
+		dwc_otg_device->index = index;
+    snpsid = dwc_read_reg32((uint32_t *) ((uint8_t *) dwc_otg_device->base + 0x40));
+
+    if ((snpsid & 0xFFFFF000) != 0x4F542000) {
+        ERR("Bad value for SNPSID: 0x%08x\n", snpsid);
+        retval = -1;
+        goto fail;
+    }
+    //dwc_otg_module_params_host.dma_enable = 1;
+
+    dwc_otg_device->core_if = dwc_otg_cil_init(dwc_otg_device->base, &dwc_otg_module_params_host);
+    if (dwc_otg_device->core_if == 0) {
+        ERR("CIL initialization failed!\n");
+        retval = -1;
+        goto fail;
+    }
+    dwc_otg_device->core_if->set_vbus_power = usb_config->set_vbus_power;
+
+    /*
+     * Disable the global interrupt until all the interrupt
+     * handlers are installed.
+     */
+    dwc_otg_disable_global_interrupts(dwc_otg_device->core_if);
+    /*
+     * Initialize the DWC_otg core.
+     */
+    if (dwc_otg_core_init(dwc_otg_device->core_if))
+	goto fail;
+    for (i = 0; i < 2; i++) {
+        dwc_otg_hc_cleanup(dwc_otg_device->core_if, i);
+    }
+
+    dwc_otg_core_host_init(dwc_otg_device->core_if);
+
+    /*
+     * Enable the global interrupt after all the interrupt
+     * handlers are installed.
+     */
+    dwc_otg_enable_global_interrupts(dwc_otg_device->core_if);
+
+    if (!dwc_otg_port_init(dwc_otg_device->core_if)) /* host initialization 6.1.1.3----6.1.1.9*/
+				goto fail;
+
+    dwc_otg_hcd_enable = 1;
+    dwc_otg_device->disabled = 0;
+    return 0;
+  fail:
+    return -1;
+}
+
+int
+usb_lowlevel_stop(int index)
+{
+    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+
+    DBG("%s\n", __func__);
+    if (!dwc_otg_hcd_enable)
+        return 0;
+#if 0
+    if (!core_if)
+        return 0;
+#endif
+
+    dwc_otg_hcd_stop(core_if);
+    board_usb_stop(BOARD_USB_MODE_HOST,dwc_otg_dev.index);
+#if 0
+    if (core_if->temp_buffer) {
+        kfree(core_if->temp_buffer);
+    }
+
+    if (core_if->host_if) {
+        kfree(core_if->host_if);
+    }
+
+    if (core_if) {
+        kfree(core_if);
+    }
+    dwc_otg_dev.core_if = 0;
+#endif
+
+    return 0;
+}
diff --git a/drivers/usb/host/dwc_otg_hcd.h b/drivers/usb/host/dwc_otg_hcd.h
new file mode 100644
index 0000000..f397ea9
--- /dev/null
+++ b/drivers/usb/host/dwc_otg_hcd.h
@@ -0,0 +1,712 @@
+
+/*
+ * drivers/usb/host/dwc_otg_hcd.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __DWC_OTG_HCD_H__
+#define __DWC_OTG_HCD_H__
+#include <asm/arch/io.h>
+
+#define DWC_DRIVER_VERSION	"2011-OCT-11"
+//#define DEBUG
+
+/** When debug level has the DBG_CIL bit set, display CIL Debug messages. */
+#define DBG_CIL		(0x2)
+/** When debug level has the DBG_CILV bit set, display CIL Verbose debug
+ * messages */
+#define DBG_CILV	(0x20)
+/**  When debug level has the DBG_PCD bit set, display PCD (Device) debug
+ *  messages */
+#define DBG_PCD		(0x4)
+/** When debug level has the DBG_PCDV set, display PCD (Device) Verbose debug
+ * messages */
+#define DBG_PCDV	(0x40)
+/** When debug level has the DBG_HCD bit set, display Host debug messages */
+#define DBG_HCD		(0x8)
+/** When debug level has the DBG_HCDV bit set, display Verbose Host debug
+ * messages */
+#define DBG_HCDV	(0x80)
+/** When debug level has the DBG_HCD_URB bit set, display enqueued URBs in host
+ *  mode. */
+#define DBG_HCD_URB	(0x800)
+
+/** When debug level has any bit set, display debug messages */
+#define DBG_ANY		(0xFF)
+
+/** All debug messages off */
+#define DBG_OFF		0
+//#define DEBUG
+#undef DEBUG
+#ifdef DEBUG
+#define DBG(fmt, args...)	\
+		printf("dwc_otg: %s: " fmt "\n" , __FUNCTION__ , ## args)
+
+# define DWC_DEBUGPL(lvl, x...) do{printf( x ); }while(0)
+
+#else
+#define DBG(fmt, args...)	do {} while (0)
+# define DWC_DEBUGPL(lvl, x...) do{}while(0)
+
+#endif
+
+#ifdef VERBOSE
+#    define VDBG		DBG
+#else
+#    define VDBG(fmt, args...)	do {} while (0)
+#endif
+
+#define ERR(fmt, args...)	\
+		printf("dwc_otg: %s: " fmt "\n" , __FUNCTION__ , ## args)
+#define WARN(fmt, args...)	\
+		printf("dwc_otg: %s: " fmt "\n" , __FUNCTION__ , ## args)
+#define INFO(fmt, args...)	\
+		printf("dwc_otg: " fmt "\n" , ## args)
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Reasons for halting a host channel.
+ */
+typedef enum dwc_otg_halt_status
+{
+	DWC_OTG_HC_XFER_NO_HALT_STATUS,
+	DWC_OTG_HC_XFER_COMPLETE,
+	DWC_OTG_HC_XFER_URB_COMPLETE,
+	DWC_OTG_HC_XFER_ACK,
+	DWC_OTG_HC_XFER_NAK,
+	DWC_OTG_HC_XFER_NYET,
+	DWC_OTG_HC_XFER_STALL,
+	DWC_OTG_HC_XFER_XACT_ERR,
+	DWC_OTG_HC_XFER_FRAME_OVERRUN,
+	DWC_OTG_HC_XFER_BABBLE_ERR,
+	DWC_OTG_HC_XFER_DATA_TOGGLE_ERR,
+	DWC_OTG_HC_XFER_AHB_ERR,
+	DWC_OTG_HC_XFER_PERIODIC_INCOMPLETE,
+	DWC_OTG_HC_XFER_URB_DEQUEUE
+} dwc_otg_halt_status_e;
+
+/**
+ * Host channel descriptor. This structure represents the state of a single
+ * host channel when acting in host mode. It contains the data items needed to
+ * transfer packets to an endpoint via a host channel.
+ */
+typedef struct dwc_hc
+{
+	/** Host channel number used for register address lookup */
+	uint8_t	 hc_num;
+
+	/** Device to access */
+	unsigned dev_addr : 7;
+
+	/** EP to access */
+	unsigned ep_num : 4;
+
+	/** EP direction. 0: OUT, 1: IN */
+	unsigned ep_is_in : 1;
+
+	/**
+	 * EP speed.
+	 * One of the following values:
+	 *	- DWC_OTG_EP_SPEED_LOW
+	 *	- DWC_OTG_EP_SPEED_FULL
+	 *	- DWC_OTG_EP_SPEED_HIGH
+	 */
+	unsigned speed : 2;
+#define DWC_OTG_EP_SPEED_LOW	0
+#define DWC_OTG_EP_SPEED_FULL	1
+#define DWC_OTG_EP_SPEED_HIGH	2
+
+	/**
+	 * Endpoint type.
+	 * One of the following values:
+	 *	- DWC_OTG_EP_TYPE_CONTROL: 0
+	 *	- DWC_OTG_EP_TYPE_ISOC: 1
+	 *	- DWC_OTG_EP_TYPE_BULK: 2
+	 *	- DWC_OTG_EP_TYPE_INTR: 3
+	 */
+	unsigned ep_type : 2;
+
+	/** Max packet size in bytes */
+	unsigned max_packet : 11;
+
+	/**
+	 * PID for initial transaction.
+	 * 0: DATA0,<br>
+	 * 1: DATA2,<br>
+	 * 2: DATA1,<br>
+	 * 3: MDATA (non-Control EP),
+	 *	  SETUP (Control EP)
+	 */
+	unsigned data_pid_start : 2;
+#define DWC_OTG_HC_PID_DATA0 0
+#define DWC_OTG_HC_PID_DATA2 1
+#define DWC_OTG_HC_PID_DATA1 2
+#define DWC_OTG_HC_PID_MDATA 3
+#define DWC_OTG_HC_PID_SETUP 3
+
+	/** Number of periodic transactions per (micro)frame */
+	unsigned multi_count: 2;
+
+	/** @name Transfer State */
+	/** @{ */
+
+	/** Pointer to the current transfer buffer position. */
+	uint8_t *xfer_buff;
+	/** Total number of bytes to transfer. */
+	uint32_t xfer_len;
+	/** Number of bytes transferred so far. */
+	uint32_t xfer_count;
+	/** Packet count at start of transfer.*/
+	uint16_t start_pkt_count;
+
+	/**
+	 * Flag to indicate whether the transfer has been started. Set to 1 if
+	 * it has been started, 0 otherwise.
+	 */
+	uint8_t xfer_started;
+
+	/**
+	 * Set to 1 to indicate that a PING request should be issued on this
+	 * channel. If 0, process normally.
+	 */
+	uint8_t do_ping;
+
+	/**
+	 * Set to 1 to indicate that the error count for this transaction is
+	 * non-zero. Set to 0 if the error count is 0.
+	 */
+	uint8_t error_state;
+
+	/**
+	 * Set to 1 to indicate that this channel should be halted the next
+	 * time a request is queued for the channel. This is necessary in
+	 * slave mode if no request queue space is available when an attempt
+	 * is made to halt the channel.
+	 */
+	uint8_t halt_on_queue;
+
+	/**
+	 * Set to 1 if the host channel has been halted, but the core is not
+	 * finished flushing queued requests. Otherwise 0.
+	 */
+	uint8_t halt_pending;
+
+	/**
+	 * Reason for halting the host channel.
+	 */
+	dwc_otg_halt_status_e	halt_status;
+
+	/*
+	 * Split settings for the host channel
+	 */
+	uint8_t do_split;		   /**< Enable split for the channel */
+	uint8_t complete_split;	   /**< Enable complete split */
+	uint8_t hub_addr;		   /**< Address of high speed hub */
+
+	uint8_t port_addr;		   /**< Port of the low/full speed device */
+	/** Split transaction position
+	 * One of the following values:
+	 *	  - DWC_HCSPLIT_XACTPOS_MID
+	 *	  - DWC_HCSPLIT_XACTPOS_BEGIN
+	 *	  - DWC_HCSPLIT_XACTPOS_END
+	 *	  - DWC_HCSPLIT_XACTPOS_ALL */
+	uint8_t xact_pos;
+
+	/** Set when the host channel does a short read. */
+	uint8_t short_read;
+
+	/**
+	 * Number of requests issued for this channel since it was assigned to
+	 * the current transfer (not counting PINGs).
+	 */
+	uint8_t requests;
+
+	/**
+	 * Queue Head for the transfer being processed by this channel.
+	 */
+	struct dwc_otg_qh *qh;
+
+	/** @} */
+
+	/** Entry in list of host channels. */
+	struct list_head	hc_list_entry;
+} dwc_hc_t;
+
+/**
+ * The following parameters may be specified when starting the module. These
+ * parameters define how the DWC_otg controller should be configured.
+ * Parameter values are passed to the CIL initialization function
+ * dwc_otg_cil_init.
+ */
+typedef struct dwc_otg_core_params_s
+{
+        /**
+	 * Specifies the OTG capabilities. The driver will automatically
+	 * detect the value for this parameter if none is specified.
+         * 0 - HNP and SRP capable (default)
+         * 1 - SRP Only capable
+         * 2 - No HNP/SRP capable
+         */
+        int32_t otg_cap;
+#define DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE 0
+#define DWC_OTG_CAP_PARAM_SRP_ONLY_CAPABLE 1
+#define DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE 2
+#define dwc_param_otg_cap_default DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE
+
+	/**
+         * Specifies whether to use slave or DMA mode for accessing the data
+         * FIFOs. The driver will automatically detect the value for this
+         * parameter if none is specified.
+         * 0 - Slave
+         * 1 - DMA (default, if available)
+         */
+	int32_t dma_enable;
+#define dwc_param_dma_enable_default 1
+
+	/** The DMA Burst size (applicable only for External DMA
+         * Mode). 1, 4, 8 16, 32, 64, 128, 256 (default 32)
+         */
+        int32_t dma_burst_size;  /* Translate this to GAHBCFG values */
+#define dwc_param_dma_burst_size_default 32
+
+	/**
+	 * Specifies the maximum speed of operation in host and device mode.
+	 * The actual speed depends on the speed of the attached device and
+	 * the value of phy_type. The actual speed depends on the speed of the
+	 * attached device.
+	 * 0 - High Speed (default)
+	 * 1 - Full Speed
+	 */
+        int32_t speed;
+#define dwc_param_speed_default 0
+#define DWC_SPEED_PARAM_HIGH 0
+#define DWC_SPEED_PARAM_FULL 1
+
+	/** Specifies whether low power mode is supported when attached
+	 *  to a Full Speed or Low Speed device in host mode.
+	 * 0 - Don't support low power mode (default)
+	 * 1 - Support low power mode
+	 */
+	int32_t host_support_fs_ls_low_power;
+#define dwc_param_host_support_fs_ls_low_power_default 0
+
+	/** Specifies the PHY clock rate in low power mode when connected to a
+	 * Low Speed device in host mode. This parameter is applicable only if
+	 * HOST_SUPPORT_FS_LS_LOW_POWER is enabled.  If PHY_TYPE is set to FS
+	 * then defaults to 6 MHZ otherwise 48 MHZ.
+	 *
+	 * 0 - 48 MHz
+	 * 1 - 6 MHz
+	 */
+	int32_t host_ls_low_power_phy_clk;
+#define dwc_param_host_ls_low_power_phy_clk_default 0
+#define DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ 0
+#define DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ 1
+
+	/**
+	 * 0 - Use cC FIFO size parameters
+	 * 1 - Allow dynamic FIFO sizing (default)
+	 */
+	int32_t enable_dynamic_fifo;
+#define dwc_param_enable_dynamic_fifo_default 1
+
+	/** Total number of 4-byte words in the data FIFO memory. This
+	 * memory includes the Rx FIFO, non-periodic Tx FIFO, and periodic
+	 * Tx FIFOs.
+	 * 32 to 32768 (default 8192)
+	 * Note: The total FIFO memory depth in the FPGA configuration is 8192.
+	 */
+	int32_t data_fifo_size;
+#define dwc_param_data_fifo_size_default 8192
+
+	/** Number of 4-byte words in the Rx FIFO in device mode when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1064)
+	 */
+	int32_t dev_rx_fifo_size;
+#define dwc_param_dev_rx_fifo_size_default 1064
+
+	/** Number of 4-byte words in the non-periodic Tx FIFO in device mode
+	 * when dynamic FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t dev_nperio_tx_fifo_size;
+#define dwc_param_dev_nperio_tx_fifo_size_default 1024
+
+	/** Number of 4-byte words in each of the periodic Tx FIFOs in device
+	 * mode when dynamic FIFO sizing is enabled.
+	 * 4 to 768 (default 256)
+	 */
+	uint32_t dev_perio_tx_fifo_size[MAX_PERIO_FIFOS];
+#define dwc_param_dev_perio_tx_fifo_size_default 256
+
+	/** Number of 4-byte words in the Rx FIFO in host mode when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_rx_fifo_size;
+#define dwc_param_host_rx_fifo_size_default 1024
+
+        /** Number of 4-byte words in the non-periodic Tx FIFO in host mode
+	 * when Dynamic FIFO sizing is enabled in the core.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_nperio_tx_fifo_size;
+#define dwc_param_host_nperio_tx_fifo_size_default 1024
+
+	/** Number of 4-byte words in the host periodic Tx FIFO when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_perio_tx_fifo_size;
+#define dwc_param_host_perio_tx_fifo_size_default 1024
+
+	/** The maximum transfer size supported in bytes.
+	 * 2047 to 65,535  (default 65,535)
+	 */
+	int32_t max_transfer_size;
+#define dwc_param_max_transfer_size_default 65535
+
+	/** The maximum number of packets in a transfer.
+	 * 15 to 511  (default 511)
+	 */
+	int32_t max_packet_count;
+#define dwc_param_max_packet_count_default 511
+
+	/** The number of host channel registers to use.
+	 * 1 to 16 (default 12)
+	 * Note: The FPGA configuration supports a maximum of 12 host channels.
+	 */
+	int32_t host_channels;
+#define dwc_param_host_channels_default 12
+
+	/** The number of endpoints in addition to EP0 available for device
+	 * mode operations.
+	 * 1 to 15 (default 6 IN and OUT)
+	 * Note: The FPGA configuration supports a maximum of 6 IN and OUT
+	 * endpoints in addition to EP0.
+	 */
+	int32_t dev_endpoints;
+#define dwc_param_dev_endpoints_default 6
+
+        /**
+         * Specifies the type of PHY interface to use. By default, the driver
+         * will automatically detect the phy_type.
+         *
+         * 0 - Full Speed PHY
+         * 1 - UTMI+ (default)
+         * 2 - ULPI
+         */
+	int32_t phy_type;
+#define DWC_PHY_TYPE_PARAM_FS 0
+#define DWC_PHY_TYPE_PARAM_UTMI 1
+#define DWC_PHY_TYPE_PARAM_ULPI 2
+#define dwc_param_phy_type_default DWC_PHY_TYPE_PARAM_UTMI
+
+	/**
+         * Specifies the UTMI+ Data Width.  This parameter is
+         * applicable for a PHY_TYPE of UTMI+ or ULPI. (For a ULPI
+         * PHY_TYPE, this parameter indicates the data width between
+         * the MAC and the ULPI Wrapper.) Also, this parameter is
+         * applicable only if the OTG_HSPHY_WIDTH cC parameter was set
+         * to "8 and 16 bits", meaning that the core has been
+         * configured to work at either data path width.
+         *
+         * 8 or 16 bits (default 16)
+         */
+        int32_t phy_utmi_width;
+#define dwc_param_phy_utmi_width_default 16
+
+        /**
+         * Specifies whether the ULPI operates at double or single
+         * data rate. This parameter is only applicable if PHY_TYPE is
+         * ULPI.
+         *
+         * 0 - single data rate ULPI interface with 8 bit wide data
+         * bus (default)
+         * 1 - double data rate ULPI interface with 4 bit wide data
+         * bus
+         */
+        int32_t phy_ulpi_ddr;
+#define dwc_param_phy_ulpi_ddr_default 0
+
+        /**
+	 * Specifies whether to use the I2Cinterface for full speed PHY. This
+	 * parameter is only applicable if PHY_TYPE is FS.
+         * 0 - No (default)
+         * 1 - Yes
+         */
+        int32_t i2c_enable;
+#define dwc_param_i2c_enable_default 0
+
+} dwc_otg_core_params_t;
+/**
+ * The <code>dwc_otg_core_if</code> structure contains information needed to manage
+ * the DWC_otg controller acting in either host or device mode. It
+ * represents the programming view of the controller as a whole.
+ */
+typedef struct dwc_otg_core_if
+{
+	/** Parameters that define how the core should be configured.*/
+	dwc_otg_core_params_t	   *core_params;
+
+	/** Core Global registers starting at offset 000h. */
+	dwc_otg_core_global_regs_t *core_global_regs;
+
+	/** Device-specific information */
+	dwc_otg_dev_if_t		   *dev_if;
+	/** Host-specific information */
+	dwc_otg_host_if_t		   *host_if;
+
+	/*
+	 * Set to 1 if the core PHY interface bits in USBCFG have been
+	 * initialized.
+	 */
+	uint8_t phy_init_done;
+
+	/*
+	 * SRP Success flag, set by srp success interrupt in FS I2C mode
+	 */
+	uint8_t srp_success;
+	uint8_t srp_timer_started;
+
+	/* Common configuration information */
+	/** Power and Clock Gating Control Register */
+	volatile uint32_t *pcgcctl;
+#define DWC_OTG_PCGCCTL_OFFSET 0xE00
+
+	/** Push/pop addresses for endpoints or host channels.*/
+	uint32_t *data_fifo[MAX_EPS_CHANNELS];
+#define DWC_OTG_DATA_FIFO_OFFSET 0x1000
+#define DWC_OTG_DATA_FIFO_SIZE 0x1000
+
+	/** Total RAM for FIFOs (Bytes) */
+	uint16_t total_fifo_size;
+	/** Size of Rx FIFO (Bytes) */
+	uint16_t rx_fifo_size;
+	/** Size of Non-periodic Tx FIFO (Bytes) */
+	uint16_t nperio_tx_fifo_size;
+
+
+	/** 1 if DMA is enabled, 0 otherwise. */
+	uint8_t dma_enable;
+
+	/** 1 if dedicated Tx FIFOs are enabled, 0 otherwise. */
+	uint8_t en_multiple_tx_fifo;
+
+	/** Set to 1 if multiple packets of a high-bandwidth transfer is in
+	 * process of being queued */
+	uint8_t queuing_high_bandwidth;
+
+	/** Hardware Configuration -- stored here for convenience.*/
+	hwcfg1_data_t hwcfg1;
+	hwcfg2_data_t hwcfg2;
+	hwcfg3_data_t hwcfg3;
+	hwcfg4_data_t hwcfg4;
+
+	/** The operational State, during transations
+	 * (a_host>>a_peripherial and b_device=>b_host) this may not
+	 * match the core but allows the software to determine
+	 * transitions.
+	 */
+	uint8_t op_state;
+
+	/**
+	 * Set to 1 if the HCD needs to be restarted on a session request
+	 * interrupt. This is required if no connector ID status change has
+	 * occurred since the HCD was last disconnected.
+	 */
+	uint8_t restart_hcd_on_session_req;
+
+	/** HCD callbacks */
+	/** A-Device is a_host */
+#define A_HOST		(1)
+	/** A-Device is a_suspend */
+#define A_SUSPEND	(2)
+	/** A-Device is a_peripherial */
+#define A_PERIPHERAL	(3)
+	/** B-Device is operating as a Peripheral. */
+#define B_PERIPHERAL	(4)
+	/** B-Device is operating as a Host. */
+#define B_HOST		(5)
+#define DWC_OTG_MAX_TRANSFER_SIZE  0x10000
+    char *temp_buffer;
+    int transfer_size;
+
+	/* Set VBus Power though GPIO */
+	 void (* set_vbus_power)(char is_power_on);
+
+#if 0
+	/** HCD callbacks */
+	struct dwc_otg_cil_callbacks *hcd_cb;
+	/** PCD callbacks */
+	struct dwc_otg_cil_callbacks *pcd_cb;
+#endif
+	/** Device mode Periodic Tx FIFO Mask */
+	uint32_t p_tx_msk;
+	/** Device mode Periodic Tx FIFO Mask */
+	uint32_t tx_msk;
+#if 0
+#ifdef DEBUG
+	uint32_t		start_hcchar_val[MAX_EPS_CHANNELS];
+
+	hc_xfer_info_t		hc_xfer_info[MAX_EPS_CHANNELS];
+	struct timer_list	hc_xfer_timer[MAX_EPS_CHANNELS];
+
+	uint32_t		hfnum_7_samples;
+	uint64_t		hfnum_7_frrem_accum;
+	uint32_t		hfnum_0_samples;
+	uint64_t		hfnum_0_frrem_accum;
+	uint32_t		hfnum_other_samples;
+	uint64_t		hfnum_other_frrem_accum;
+#endif
+#endif
+
+} dwc_otg_core_if_t;
+/**
+ * This structure is a wrapper that encapsulates the driver components used to
+ * manage a single DWC_otg controller.
+ */
+typedef struct dwc_otg_device
+{
+	/** Base address returned from ioremap() */
+	void *base;
+
+
+	/** Pointer to the core interface structure. */
+	dwc_otg_core_if_t *core_if;
+
+	/** Register offset for Diagnostic API.*/
+	uint32_t reg_offset;
+
+	/** Pointer to the HCD structure. */
+	struct dwc_otg_hcd *hcd;
+
+	/** Flag to indicate whether the common IRQ handler is installed. */
+	uint8_t common_irq_installed;
+
+  int disabled;
+	int index;
+} dwc_otg_device_t;
+/**
+ * Reads the content of a register.
+ *
+ * @param _reg address of register to read.
+ * @return contents of the register.
+ *
+
+ * Usage:<br>
+ * <code>uint32_t dev_ctl = dwc_read_reg32(&dev_regs->dctl);</code>
+ */
+static __inline__ uint32_t dwc_read_reg32( volatile uint32_t *_reg)
+{
+        return readl(_reg);
+};
+
+/**
+ * Writes a register with a 32 bit value.
+ *
+ * @param _reg address of register to read.
+ * @param _value to write to _reg.
+ *
+ * Usage:<br>
+ * <code>dwc_write_reg32(&dev_regs->dctl, 0); </code>
+ */
+static __inline__ void dwc_write_reg32( volatile uint32_t *_reg, const uint32_t _value)
+{
+        writel( _value, _reg );
+};
+static __inline__
+ void dwc_modify_reg32( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+{
+        writel( (readl(_reg) & ~_clear_mask) | _set_mask, _reg );
+};
+/**
+ * This function returns the mode of the operation, host or device.
+ *
+ * @return 0 - Device Mode, 1 - Host Mode
+ */
+static inline uint32_t dwc_otg_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_read_reg32( &_core_if->core_global_regs->gintsts ) & 0x1);
+}
+
+static inline uint8_t dwc_otg_is_device_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_otg_mode(_core_if) != DWC_HOST_MODE);
+}
+static inline uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_otg_mode(_core_if) == DWC_HOST_MODE);
+}
+
+
+/* --- USB HUB constants (not OHCI-specific; see hub.h) -------------------- */
+
+/* destination of request */
+#define RH_INTERFACE               0x01
+#define RH_ENDPOINT                0x02
+#define RH_OTHER                   0x03
+
+#define RH_CLASS                   0x20
+#define RH_VENDOR                  0x40
+
+/* Requests: bRequest << 8 | bmRequestType */
+#define RH_GET_STATUS           0x0080
+#define RH_CLEAR_FEATURE        0x0100
+#define RH_SET_FEATURE          0x0300
+#define RH_SET_ADDRESS          0x0500
+#define RH_GET_DESCRIPTOR       0x0680
+#define RH_SET_DESCRIPTOR       0x0700
+#define RH_GET_CONFIGURATION    0x0880
+#define RH_SET_CONFIGURATION    0x0900
+#define RH_GET_STATE            0x0280
+#define RH_GET_INTERFACE        0x0A80
+#define RH_SET_INTERFACE        0x0B00
+#define RH_SYNC_FRAME           0x0C80
+/* Our Vendor Specific Request */
+#define RH_SET_EP               0x2000
+
+/* Hub port features */
+#define RH_PORT_CONNECTION         0x00
+#define RH_PORT_ENABLE             0x01
+#define RH_PORT_SUSPEND            0x02
+#define RH_PORT_OVER_CURRENT       0x03
+#define RH_PORT_RESET              0x04
+#define RH_PORT_POWER              0x08
+#define RH_PORT_LOW_SPEED          0x09
+
+#define RH_C_PORT_CONNECTION       0x10
+#define RH_C_PORT_ENABLE           0x11
+#define RH_C_PORT_SUSPEND          0x12
+#define RH_C_PORT_OVER_CURRENT     0x13
+#define RH_C_PORT_RESET            0x14
+
+/* Hub features */
+#define RH_C_HUB_LOCAL_POWER       0x00
+#define RH_C_HUB_OVER_CURRENT      0x01
+
+#define RH_DEVICE_REMOTE_WAKEUP    0x00
+#define RH_ENDPOINT_STALL          0x01
+
+#define RH_ACK                     0x01
+#define RH_REQ_ERR                 -1
+#define RH_NACK                    0x00
+
+#endif
+
diff --git a/drivers/usb/host/dwc_otg_hcd_294.c b/drivers/usb/host/dwc_otg_hcd_294.c
new file mode 100644
index 0000000..3887735
--- /dev/null
+++ b/drivers/usb/host/dwc_otg_hcd_294.c
@@ -0,0 +1,1846 @@
+
+/*
+ * drivers/usb/host/dwc_otg_hcd_294.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/usb.h>
+#include <usb.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <asm/cache.h>
+#include <asm/arch/timer.h>
+#include <usb.h>
+
+
+#include "dwc_otg_regs_294.h"
+#include "dwc_otg_hcd_294.h"
+
+#define kmalloc(x,y)			malloc(x)
+#define kfree(x)			    free(x)
+
+//#define min_t(type,x,y)  ({ type __x = (x); type __y = (y); __x < __y ? __x : __y; })
+
+#define flush_cpu_cache()  do{ flush_dcache_all();}while(0)//flush_cache //do{_invalidate_dcache();AV_AHB_bus_invalidate();}while(0)	//for porting
+
+/* ------------------------------------------------------- */
+#define get_unaligned_16(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8))
+#define get_unaligned_32(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+//#define get_unaligned(ptr)				(((__u8 *)ptr)[0] | (((__u8 *)ptr)[1]<<8) | (((__u8 *)ptr)[2]<<16) | (((__u8 *)ptr)[3]<<24))
+
+static dwc_otg_device_t dwc_otg_dev;
+//extern void wait_ms(unsigned long ms);
+static int dwc_otg_port_init(dwc_otg_core_if_t * _core_if);
+static int is_insert = 0;
+/* The bits respond the channel buy_state. */
+//static unsigned int chn_busy;
+/*
+void dwc_udelay(int dly)
+{
+	int i;
+	for (i = 0;i<4000;i++) ;
+}
+*/
+#define dwc_udelay(dly) _udelay(dly)
+extern void _mdelay(unsigned long ms);
+/*
+ * Host module config
+ */
+
+static struct dwc_otg_core_params dwc_otg_module_params_host = {
+	.otg_cap = DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE,//NO HNP SRP
+	.dma_enable = 0,
+	.dma_desc_enable = 0,
+	.dma_burst_size = 3,//DWC_GAHBCFG_INT_DMA_BURST_INCR4;
+	.speed = DWC_SPEED_PARAM_HIGH,//0 Highspeed, 1 Fullspeed
+	.host_support_fs_ls_low_power = 0,
+	.host_ls_low_power_phy_clk = 0,
+	.enable_dynamic_fifo = 1,
+	.data_fifo_size = 1024,
+	.dev_endpoints = 6,
+	.en_multiple_tx_fifo = 0,
+	.dev_rx_fifo_size = 256,
+	.dev_nperio_tx_fifo_size = 256,
+	.dev_tx_fifo_size = {
+			     /* dev_tx_fifo_size */
+			     256,
+			     256,
+			     128,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1,
+			     -1
+			     /* 15 */
+			     },
+	.dev_perio_tx_fifo_size = {
+				   /* dev_perio_tx_fifo_size_1 */
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1,
+				   -1
+				   /* 15 */
+				   },
+	.host_rx_fifo_size = 512,
+	.host_nperio_tx_fifo_size = 500,
+	.host_perio_tx_fifo_size = 100,
+	.max_transfer_size = ((1 << 19) - 1),
+	.max_packet_count = ((1 << 10) - 1),
+	.host_channels = 15,
+	.phy_type = DWC_PHY_TYPE_PARAM_UTMI, //UTMI+
+	.phy_utmi_width = 16,
+	.phy_ulpi_ddr = 0,
+	.phy_ulpi_ext_vbus = 0,
+	.i2c_enable = 0,
+	.ulpi_fs_ls = 0,
+	.ts_dline = 0,
+	.thr_ctl = 0,
+	.tx_thr_length = 0,
+	.rx_thr_length = 0,
+	.pti_enable = 0,
+	.mpi_enable = 0,
+	.lpm_enable = 0,
+	.ic_usb_cap = 0,
+	.ahb_thr_ratio = 0,
+	.power_down = 0,
+	.reload_ctl = 0,
+	.dev_out_nak = 0,
+	.cont_on_bna = 0,
+	.ahb_single = 1,
+	.otg_ver = 1,
+};
+#define FORCE_ID_CLEAR	-1
+#define FORCE_ID_HOST	0
+#define FORCE_ID_SLAVE	1
+#define FORCE_ID_ERROR	2
+static void dwc_otg_set_force_id(dwc_otg_core_if_t *core_if,int mode)
+{
+	gusbcfg_data_t gusbcfg_data;
+
+	gusbcfg_data.d32 = dwc_read_reg32(&core_if->core_global_regs->gusbcfg);
+	switch (mode) {
+		case FORCE_ID_CLEAR:
+			printf("Force id mode: Hardware\n");
+			gusbcfg_data.b.force_host_mode = 0;
+			gusbcfg_data.b.force_dev_mode = 0;
+			break;
+		case FORCE_ID_HOST:
+			printf("Force id mode: Host\n");
+			gusbcfg_data.b.force_host_mode = 1;
+			gusbcfg_data.b.force_dev_mode = 0;
+			break;
+		case FORCE_ID_SLAVE:
+			printf("Force id mode: Slave\n");
+			gusbcfg_data.b.force_host_mode = 0;
+			gusbcfg_data.b.force_dev_mode = 1;
+			break;
+		default:
+			ERR("error id mode\n");
+			return;
+			break;
+	}
+	dwc_write_reg32(&core_if->core_global_regs->gusbcfg,gusbcfg_data.d32);
+
+	gusbcfg_data.d32 = dwc_read_reg32(&core_if->core_global_regs->gusbcfg);
+	DWC_DEBUGPL(DBG_CIL, "force_host: %d, force_device: %d\n",
+		gusbcfg_data.b.force_host_mode,gusbcfg_data.b.force_dev_mode);
+
+	return;
+}
+/**
+ * This function disables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+static void
+dwc_otg_disable_global_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    ahbcfg.b.glblintrmsk = 0;   /* disable interrupts */
+    dwc_modify_reg32(&_core_if->core_global_regs->gahbcfg, ahbcfg.d32, 0);
+}
+/**
+ * This function enables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+extern void
+dwc_otg_enable_global_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    ahbcfg.b.glblintrmsk = 1;   /* Enable interrupts */
+    dwc_modify_reg32(&_core_if->core_global_regs->gahbcfg, 0, ahbcfg.d32);
+}
+
+static dwc_otg_core_if_t *
+dwc_otg_cil_init(const uint32_t * _reg_base_addr, dwc_otg_core_params_t * _core_params)
+{
+
+    dwc_otg_core_if_t *core_if = 0;
+    // dwc_otg_dev_if_t *dev_if = 0;
+    dwc_otg_host_if_t *host_if = 0;
+    uint8_t        *reg_base = (uint8_t *) _reg_base_addr;
+    int             i = 0;
+
+    DWC_DEBUGPL(DBG_CILV, "%s(%p,%p)\n", __func__, _reg_base_addr, _core_params);
+
+    core_if = (dwc_otg_core_if_t *) kmalloc(sizeof(dwc_otg_core_if_t), 0);
+
+    if (core_if == 0) {
+        DWC_DEBUGPL(DBG_CIL, "Allocation of dwc_otg_core_if_t failed\n");
+        return 0;
+    }
+
+    memset(core_if, 0, sizeof(dwc_otg_core_if_t));
+
+    core_if->core_params = _core_params;
+    core_if->core_global_regs = (dwc_otg_core_global_regs_t *) reg_base;
+
+    /*
+     * Allocate the Host Mode structures.
+     */
+    host_if = (dwc_otg_host_if_t *) kmalloc(sizeof(dwc_otg_host_if_t), 0);
+
+    if (host_if == 0) {
+        DWC_DEBUGPL(DBG_CIL, "Allocation of dwc_otg_host_if_t failed\n");
+        // kfree(dev_if);
+        kfree(core_if);
+        return 0;
+    }
+
+    host_if->host_global_regs = (dwc_otg_host_global_regs_t *)
+        (reg_base + DWC_OTG_HOST_GLOBAL_REG_OFFSET);
+
+    host_if->hprt0 = (uint32_t *) (reg_base + DWC_OTG_HOST_PORT_REGS_OFFSET);
+
+    for (i = 0; i < MAX_EPS_CHANNELS; i++) {
+        host_if->hc_regs[i] = (dwc_otg_hc_regs_t *)
+            (reg_base + DWC_OTG_HOST_CHAN_REGS_OFFSET + (i * DWC_OTG_CHAN_REGS_OFFSET));
+        DWC_DEBUGPL(DBG_CILV, "hc_reg[%d]->hcchar=%p\n", i, &host_if->hc_regs[i]->hcchar);
+    }
+
+    host_if->num_host_channels = MAX_EPS_CHANNELS;
+    core_if->host_if = host_if;
+
+    for (i = 0; i < MAX_EPS_CHANNELS; i++) {
+        core_if->data_fifo[i] =
+            (uint32_t *) (reg_base + DWC_OTG_DATA_FIFO_OFFSET + (i * DWC_OTG_DATA_FIFO_SIZE));
+        DWC_DEBUGPL(DBG_CILV, "data_fifo[%d]=0x%08x\n", i, (unsigned) core_if->data_fifo[i]);
+    }
+
+    core_if->pcgcctl = (uint32_t *) (reg_base + DWC_OTG_PCGCCTL_OFFSET);
+
+    /*
+     * Store the contents of the hardware configuration registers here for
+     * easy access later.
+     */
+    core_if->hwcfg1.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg1);
+    core_if->hwcfg2.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg2);
+    core_if->hwcfg3.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg3);
+    core_if->hwcfg4.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg4);
+
+    DWC_DEBUGPL(DBG_CILV, "hwcfg1=%08x\n", core_if->hwcfg1.d32);
+    DWC_DEBUGPL(DBG_CILV, "hwcfg2=%08x\n", core_if->hwcfg2.d32);
+    DWC_DEBUGPL(DBG_CILV, "hwcfg3=%08x\n", core_if->hwcfg3.d32);
+    DWC_DEBUGPL(DBG_CILV, "hwcfg4=%08x\n", core_if->hwcfg4.d32);
+
+    DWC_DEBUGPL(DBG_CILV, "op_mode=%0x\n", core_if->hwcfg2.b.op_mode);
+    DWC_DEBUGPL(DBG_CILV, "arch=%0x\n", core_if->hwcfg2.b.architecture);
+    DWC_DEBUGPL(DBG_CILV, "num_dev_ep=%d\n", core_if->hwcfg2.b.num_dev_ep);
+    DWC_DEBUGPL(DBG_CILV, "num_host_chan=%d\n", core_if->hwcfg2.b.num_host_chan);
+    DWC_DEBUGPL(DBG_CILV, "nonperio_tx_q_depth=0x%0x\n", core_if->hwcfg2.b.nonperio_tx_q_depth);
+    DWC_DEBUGPL(DBG_CILV, "host_perio_tx_q_depth=0x%0x\n", core_if->hwcfg2.b.host_perio_tx_q_depth);
+    DWC_DEBUGPL(DBG_CILV, "dev_token_q_depth=0x%0x\n", core_if->hwcfg2.b.dev_token_q_depth);
+
+    DWC_DEBUGPL(DBG_CILV, "Total FIFO SZ=%d\n", core_if->hwcfg3.b.dfifo_depth);
+    DWC_DEBUGPL(DBG_CILV, "xfer_size_cntr_width=%0x\n", core_if->hwcfg3.b.xfer_size_cntr_width);
+
+    /*
+     * Set the SRP sucess bit for FS-I2c
+     */
+    core_if->srp_success = 0;
+    core_if->srp_timer_started = 0;
+    core_if->temp_buffer = kmalloc(DWC_OTG_MAX_TRANSFER_SIZE, 0);
+    if (!core_if->temp_buffer) {
+        kfree(core_if->host_if);
+        kfree(core_if);
+        return 0;
+    }
+
+    return core_if;
+
+}
+/**
+ * This function initializes the commmon interrupts, used in both
+ * device and host modes.
+ *
+ * @param[in] _core_if Programming view of the DWC_otg controller
+ *
+ */
+static void
+dwc_otg_enable_common_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    gintmsk_data_t  intr_mask = {.d32 = 0 };
+
+    /*
+     * Clear any pending OTG Interrupts
+     */
+    dwc_write_reg32(&global_regs->gotgint, 0xFFFFFFFF);
+
+    /*
+     * Clear any pending interrupts
+     */
+    dwc_write_reg32(&global_regs->gintsts, 0xFFFFFFFF);
+
+    /*
+     * Enable the interrupts in the GINTMSK.
+     */
+    intr_mask.b.modemismatch = 1;
+    intr_mask.b.otgintr = 1;
+
+    if (!_core_if->dma_enable) {
+        intr_mask.b.rxstsqlvl = 1;
+    }
+
+    intr_mask.b.conidstschng = 1;
+    intr_mask.b.wkupintr = 1;
+    intr_mask.b.disconnect = 1;
+    intr_mask.b.usbsuspend = 1;
+    intr_mask.b.sessreqintr = 1;
+    dwc_write_reg32(&global_regs->gintmsk, intr_mask.d32);
+}
+/**
+ * Do core a soft reset of the core.  Be careful with this because it
+ * resets all the internal state machines of the core.
+ */
+void
+dwc_otg_core_reset(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    volatile grstctl_t greset = {.d32 = 0 };
+    int             count = 0;
+
+     DWC_DEBUGPL(DBG_CILV,"%s(%p)\n", __func__,_core_if);
+    /*
+     * Wait for AHB master IDLE state.
+     */
+    do {
+        dwc_udelay(10);
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 100000) {
+            ERR("%s() HANG! AHB Idle GRSTCTL=%0x\n", __func__, greset.d32);
+            return;
+        }
+    }
+    while (greset.b.ahbidle == 0);
+
+    /*
+     * Core Soft Reset
+     */
+    count = 0;
+    greset.b.csftrst = 1;
+    dwc_write_reg32(&global_regs->grstctl, greset.d32);
+    do {
+        dwc_udelay(10);
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 1000000) {
+            ERR("%s() HANG! Soft Reset GRSTCTL=%0x\n", __func__, greset.d32);
+            break;
+        }
+    }
+    while (greset.b.csftrst == 1);
+
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    _mdelay(100);
+}
+
+/**
+ * Initializes the FSLSPClkSel field of the HCFG register depending on the PHY
+ * type.
+ */
+static void
+init_fslspclksel(dwc_otg_core_if_t * _core_if)
+{
+    uint32_t        val;
+    hcfg_data_t     hcfg;
+
+    if (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS) {
+        /*
+         * Full speed PHY
+         */
+        val = DWC_HCFG_48_MHZ;
+    } else {
+        /*
+         * High speed PHY running at full speed or high speed
+         */
+        val = DWC_HCFG_30_60_MHZ;
+    }
+
+    DWC_DEBUGPL(DBG_CIL, "Initializing HCFG.FSLSPClkSel to 0x%1x\n", val);
+    hcfg.d32 = dwc_read_reg32(&_core_if->host_if->host_global_regs->hcfg);
+    hcfg.b.fslspclksel = val;
+    dwc_write_reg32(&_core_if->host_if->host_global_regs->hcfg, hcfg.d32);
+}
+
+/**
+ * Initializes the DevSpd field of the DCFG register depending on the PHY type
+ * and the enumeration speed of the device.
+ */
+static void
+init_devspd(dwc_otg_core_if_t * _core_if)
+{
+    uint32_t        val;
+    dcfg_data_t     dcfg;
+
+    if (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS) {
+        /*
+         * Full speed PHY
+         */
+        val = 0x3;
+    } else if (_core_if->core_params->speed == DWC_SPEED_PARAM_FULL) {
+        /*
+         * High speed PHY running at full speed
+         */
+        val = 0x1;
+    } else {
+        /*
+         * High speed PHY running at high speed
+         */
+        val = 0x0;
+    }
+
+    DWC_DEBUGPL(DBG_CIL, "Initializing DCFG.DevSpd to 0x%1x\n", val);
+    dcfg.d32 = dwc_read_reg32(&_core_if->dev_if->dev_global_regs->dcfg);
+    dcfg.b.devspd = val;
+    dwc_write_reg32(&_core_if->dev_if->dev_global_regs->dcfg, dcfg.d32);
+}
+
+/**
+ * This function initializes the DWC_otg controller registers and
+ * prepares the core for device mode or host mode operation.
+ *
+ * @param _core_if Programming view of the DWC_otg controller
+ *
+ */
+
+int
+dwc_otg_core_init(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    // dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+    gahbcfg_data_t  ahbcfg = {.d32 = 0 };
+    gusbcfg_data_t  usbcfg = {.d32 = 0 };
+//	gi2cctl_data_t  i2cctl = {.d32 = 0 };
+    gotgctl_data_t gotgctl = {.d32 = 0 };
+
+    DWC_DEBUGPL(DBG_CILV, "dwc_otg_core_init(%p)\n", _core_if);
+
+    /*
+     * Reset the Controller
+     */
+    dwc_otg_core_reset(_core_if);
+
+    _core_if->total_fifo_size = _core_if->hwcfg3.b.dfifo_depth;
+    _core_if->rx_fifo_size = dwc_read_reg32(&global_regs->grxfsiz);
+    _core_if->nperio_tx_fifo_size = dwc_read_reg32(&global_regs->gnptxfsiz) >> 16;
+
+    DWC_DEBUGPL(DBG_CIL, "Total FIFO SZ=%d\n", _core_if->total_fifo_size);
+    DWC_DEBUGPL(DBG_CIL, "HW Rx FIFO SZ=%d\n", _core_if->rx_fifo_size);
+    DWC_DEBUGPL(DBG_CIL, "HW NP Tx FIFO SZ=%d\n", _core_if->nperio_tx_fifo_size);
+
+    /*
+     * This programming sequence needs to happen in FS mode before any other
+     * programming occurs
+     */
+    if ((_core_if->core_params->speed == DWC_SPEED_PARAM_FULL) &&
+        (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS)) {
+        /*
+         * If FS mode with FS PHY
+         */
+	 DWC_DEBUGPL(DBG_CIL,"core_params->speed == FULL\n");
+        /*
+         * core_init() is now called on every switch so only call the
+         * following for the first time through.
+         */
+        if (!_core_if->phy_init_done) {
+            _core_if->phy_init_done = 1;
+            DWC_DEBUGPL(DBG_CIL, "FS_PHY detected\n");
+            usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+            usbcfg.b.physel = 1;
+            dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+
+            /*
+             * Reset after a PHY select
+             */
+            dwc_otg_core_reset(_core_if);
+        }
+
+        /*
+         * Program DCFG.DevSpd or HCFG.FSLSPclkSel to 48Mhz in FS. Also do
+         * this on HNP Dev/Host mode switches (done in dev_init and
+         * host_init).
+         */
+        if (dwc_otg_is_host_mode(_core_if)) {
+            init_fslspclksel(_core_if);
+        } else {
+            init_devspd(_core_if);
+        }
+
+    }
+    /*
+     * endif speed == DWC_SPEED_PARAM_FULL
+     */
+    else {
+        /*
+         * High speed PHY.
+         */
+         DWC_DEBUGPL(DBG_CIL,"core_params->speed == HIGH\n");
+        if (!_core_if->phy_init_done) {
+            _core_if->phy_init_done = 1;
+		usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+            /*
+             * HS PHY parameters.  These parameters are preserved during soft
+             * reset so only program the first time.  Do a soft reset
+             * immediately after setting phyif.
+             */
+		if (_core_if->core_params->phy_type == 2) {
+			/* ULPI interface */
+			usbcfg.b.ulpi_utmi_sel = 1;
+			usbcfg.b.phyif = 0;
+			usbcfg.b.ddrsel =
+			_core_if->core_params->phy_ulpi_ddr;
+			DWC_DEBUGPL(DBG_CIL,"ULPI phy\n");
+		} else if (_core_if->core_params->phy_type == 1) {
+			/* UTMI+ interface */
+			usbcfg.b.ulpi_utmi_sel = 0;
+			if (_core_if->core_params->phy_utmi_width == 16) {
+				usbcfg.b.phyif = 1;
+				DWC_DEBUGPL(DBG_CIL,"UTMI+ 16 bit PHY\n");
+			} else {
+				usbcfg.b.phyif = 0;
+				DWC_DEBUGPL(DBG_CIL,"UTMI+ 8 bit PHY\n");
+			}
+		}
+
+            dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+
+            /*
+             * Reset after setting the PHY parameters
+             */
+            dwc_otg_core_reset(_core_if);
+        }
+    }
+
+    /*
+     * Program the GAHBCFG Register.
+     */
+    switch (_core_if->hwcfg2.b.architecture) {
+
+    case DWC_SLAVE_ONLY_ARCH:
+        DWC_DEBUGPL(DBG_CIL, "Slave Only Mode\n");
+        ahbcfg.b.nptxfemplvl_txfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY;
+        ahbcfg.b.ptxfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY;
+        _core_if->dma_enable = 0;
+        break;
+
+    case DWC_EXT_DMA_ARCH:
+        DWC_DEBUGPL(DBG_CIL, "External DMA Mode\n");
+        ahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR8;
+        _core_if->dma_enable = (_core_if->core_params->dma_enable != 0);
+        break;
+
+    case DWC_INT_DMA_ARCH:
+        DWC_DEBUGPL(DBG_CIL, "Internal DMA Mode\n");
+        ahbcfg.b.hburstlen =_core_if->core_params->dma_burst_size;//config by out world
+        //ahbcfg.b.hburstlen = 3;//DWC_GAHBCFG_INT_DMA_BURST_INCR4;
+        _core_if->dma_enable = (_core_if->core_params->dma_enable != 0);
+        break;
+
+    }
+
+    ahbcfg.b.dmaenable = _core_if->dma_enable;
+    dwc_write_reg32(&global_regs->gahbcfg, ahbcfg.d32);
+
+    // _core_if->en_multiple_tx_fifo = _core_if->hwcfg4.b.ded_fifo_en;
+
+
+	gotgctl.b.otgver = _core_if->core_params->otg_ver;
+	dwc_modify_reg32(&_core_if->core_global_regs->gotgctl, 0,
+			 gotgctl.d32);
+	/* Set OTG version supported */
+	_core_if->otg_ver = _core_if->core_params->otg_ver;
+	DWC_DEBUGPL(DBG_CIL,"OTG VER PARAM: %d, OTG VER FLAG: %d\n",
+		   _core_if->core_params->otg_ver, _core_if->otg_ver);
+
+    /*
+     * Program the GUSBCFG register.
+     */
+    usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+
+    switch (_core_if->hwcfg2.b.op_mode) {
+    case DWC_MODE_HNP_SRP_CAPABLE:
+        usbcfg.b.hnpcap = (_core_if->core_params->otg_cap == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE);
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_SRP_ONLY_CAPABLE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_NO_HNP_SRP_CAPABLE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = 0;
+        break;
+
+    case DWC_MODE_SRP_CAPABLE_DEVICE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_NO_SRP_CAPABLE_DEVICE:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = 0;
+        break;
+
+    case DWC_MODE_SRP_CAPABLE_HOST:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = (_core_if->core_params->otg_cap != DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+        break;
+
+    case DWC_MODE_NO_SRP_CAPABLE_HOST:
+        usbcfg.b.hnpcap = 0;
+        usbcfg.b.srpcap = 0;
+        break;
+    }
+
+    dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+
+    /*
+     * Enable common interrupts
+     */
+    dwc_otg_enable_common_interrupts(_core_if);
+
+    /*
+     * Do device or host intialization based on mode during PCD and HCD
+     * initialization
+     */
+    if (dwc_otg_is_host_mode(_core_if)) {
+        DWC_DEBUGPL(DBG_ANY, "Host Mode\n");
+        _core_if->op_state = A_HOST;
+    } else {
+	ERR("Device Mode\n");
+	_core_if->op_state = B_PERIPHERAL;
+
+	return -1;
+    }
+	return 0;
+
+}
+/**
+ * This function disables the Host Mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+void
+dwc_otg_disable_host_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+
+    DWC_DEBUGPL(DBG_CILV, "%s()\n", __func__);
+
+    dwc_write_reg32 (&global_regs->gintmsk, 0);
+    dwc_modify_reg32 (&global_regs->gahbcfg, 1, 0);
+
+}
+
+/**
+ * Halts the DWC_otg host mode operations in a clean manner. USB transfers are
+ * stopped.
+ */
+void
+dwc_otg_hcd_stop(dwc_otg_core_if_t * core_if)
+{
+    hprt0_data_t    hprt0 = {.d32 = 0 };
+    pcgcctl_data_t hcgcctl = {.d32 = 0};
+
+    if (core_if == 0)
+        return;
+
+    DBG("DWC OTG HCD STOP\n");
+
+    /*
+     * Turn off all host-specific interrupts.
+     */
+    dwc_otg_disable_host_interrupts(core_if);
+
+    /*
+     * The root hub should be disconnected before this function is called.
+     * The disconnect will clear the QTD lists (via ..._hcd_urb_dequeue)
+     * and the QH lists (via ..._hcd_endpoint_disable).
+     */
+
+    /*
+     * Turn off the vbus power
+     */
+    DBG("PortPower off\n");
+    hprt0.b.prtpwr = 0;
+    dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+
+    hcgcctl.b.stoppclk  = 1;
+    hcgcctl.b.gatehclk = 1;
+    hcgcctl.b.pwrclmp = 1;
+    //hcgcctl.b.rstpdwnmodule = 1;
+	//printf("core_if->pcgcctl  : 0x%x, & = 0x%x\n",core_if->pcgcctl,&core_if->pcgcctl );
+#ifndef CONFIG_M6TV
+    dwc_write_reg32(core_if->pcgcctl,hcgcctl.d32);
+#endif
+    return;
+}
+
+
+/*
+ * --- API functions ------------------------------------------------------
+ */
+int
+submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer, int len, int interval)
+{
+    DBG("dev=%p pipe=%#lx buf=%p size=%d int=%d", dev, pipe, buffer, len, interval);
+
+    return -1;
+}
+static inline int
+max_transfer_len(struct usb_device *dev, unsigned long pipe)
+{
+    unsigned        mpck = usb_maxpacket(dev, pipe);
+
+    /*
+     * One PTD can transfer 1023 bytes but try to always transfer multiples
+     * of endpoint buffer size
+     */
+    return 1023 / mpck * mpck;
+}
+
+/**
+ * Clears the transfer state for a host channel. This function is normally
+ * called after a transfer is done and the host channel is being released.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _hc Identifies the host channel to clean up.
+ */
+void
+dwc_otg_hc_cleanup(dwc_otg_core_if_t * _core_if, int hc_num)
+{
+    dwc_otg_hc_regs_t *hc_regs;
+
+    /*
+     * Clear channel interrupt enables and any unhandled channel interrupt
+     * conditions.
+     */
+    hc_regs = _core_if->host_if->hc_regs[hc_num];
+    dwc_write_reg32(&hc_regs->hcintmsk, 0);
+    dwc_write_reg32(&hc_regs->hcint, 0xFFFFFFFF);
+    dwc_write_reg32(&hc_regs->hctsiz, 0);
+    dwc_write_reg32(&hc_regs->hcdma, 0);
+    dwc_write_reg32(&hc_regs->hcchar, 0);
+
+    flush_cpu_cache();
+
+}
+
+void dwc_otg_read_packet(dwc_otg_core_if_t * core_if, uint8_t * _dest, uint16_t _bytes,int hcnum)
+{
+	int i;
+	int word_count = (_bytes + 3) / 4;
+	volatile uint32_t *fifo = core_if->data_fifo[hcnum];
+	uint32_t *data_buff = (uint32_t *) _dest;
+	for (i = 0; i < word_count; i++, data_buff++) {
+		*data_buff = dwc_read_reg32(fifo);
+	}
+	return;
+}
+
+static void dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_core_if_t * _core_if, int is_setup,int hcnum, void *buffer)
+{
+	host_grxsts_data_t grxsts;
+
+	grxsts.d32 = dwc_read_reg32(&_core_if->core_global_regs->grxstsp);
+	//printf("RxStsQ:ch%d,cnt=%d,pid=%d,PStatus=%d\n",grxsts.b.chnum,grxsts.b.bcnt,grxsts.b.dpid,grxsts.b.pktsts);
+
+	switch (grxsts.b.pktsts) {
+	case DWC_GRXSTS_PKTSTS_IN:
+		/* Read the data into the host buffer. */
+		if (grxsts.b.bcnt > 0) {
+			dwc_otg_read_packet(_core_if, buffer, grxsts.b.bcnt, hcnum);
+			/* Update the HC fields for the next packet received. */
+			buffer += grxsts.b.bcnt;
+		}
+	case DWC_GRXSTS_PKTSTS_IN_XFER_COMP:
+	case DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
+	case DWC_GRXSTS_PKTSTS_CH_HALTED:
+		/* Handled in interrupt, just ignore data */
+		break;
+	default:
+		ERR("RX_STS_Q Interrupt: Unknown status %d\n",
+			  grxsts.b.pktsts);
+		break;
+	}
+
+	return;
+}
+
+void dwc_otg_hc_write_packet(dwc_otg_core_if_t * _core_if, void *buffer,int len, int chn_num)
+{
+	uint32_t i;
+	uint32_t byte_count;
+	uint32_t dword_count;
+
+	uint32_t *data_buff = (uint32_t *)buffer;
+	uint32_t *data_fifo = _core_if->data_fifo[chn_num];//just used channel0
+
+	byte_count = len ;
+
+	dword_count = (byte_count + 3) / 4;
+
+	if ((((unsigned long)data_buff) & 0x3) == 0) {
+		/* xfer_buff is DWORD aligned. */
+		for (i = 0; i < dword_count; i++, data_buff++) {
+			dwc_write_reg32(data_fifo, *data_buff);
+		}
+	} else {
+		/* xfer_buff is not DWORD aligned. */
+
+		for (i = 0; i < dword_count; i++, data_buff++) {
+			dwc_write_reg32(data_fifo, get_unaligned(data_buff));
+		}
+	}
+	//printf("dwc_otg_hc_write_packet finished  %d  %d chn%d\n", dword_count, len,chn_num);
+}
+
+static void dwc_otg_hc_do_ping(dwc_otg_core_if_t *_core_if, int hc_num)
+{
+	hcchar_data_t hcchar;
+	hctsiz_data_t hctsiz;
+	dwc_otg_hc_regs_t *hc_regs = _core_if->host_if->hc_regs[hc_num];
+
+	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, hc_num);
+
+	hctsiz.d32 = 0;
+	hctsiz.b.dopng = 1;
+	hctsiz.b.pktcnt = 1;
+	dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.chen = 1;
+	hcchar.b.chdis = 0;
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+}
+
+static int
+dwc_otg_interrupt(dwc_otg_core_if_t * _core_if, int is_setup,int hcnum,void * buffer)
+{
+    gintsts_data_t  gintsts;
+    dwc_otg_hc_regs_t *hc_regs;
+    //hctsiz_data_t   hctsiz;
+    hcint_data_t    hcint;
+    hcchar_data_t   hcchar;
+    hcintmsk_data_t hcintmsk;
+    // dwc_otg_host_if_t *host_if ;
+    int             handled;
+    dwc_otg_host_if_t *host_if = _core_if->host_if;
+
+  do {
+    gintsts.d32 = dwc_read_reg32(&_core_if->core_global_regs->gintsts);
+    hc_regs = host_if->hc_regs[hcnum];
+    hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+    handled = 0;
+
+    if (gintsts.b.rxstsqlvl && (!_core_if->dma_enable)) {
+	    dwc_otg_hcd_handle_rx_status_q_level_intr(_core_if,is_setup,hcnum,buffer);
+        DBG("rxstsqlvl interrupt!\n");
+        _core_if->host_if->do_ping = 0;
+        handled = 1;
+    }
+    if (gintsts.b.hcintr) {
+        //DBG("dwc_otg_interrupt: hcintr interrupt!\n");
+        if (hcint.b.xfercomp) {
+            //hctsiz.d32 = dwc_read_reg32(&hc_regs->hctsiz);
+            dwc_otg_hc_cleanup(_core_if, hcnum);
+            if (is_setup)
+                return 8;
+            return (_core_if->transfer_size);// - hctsiz.b.xfersize);
+        }
+        if (hcint.b.ahberr) {
+            ERR("ahberr interrupt!\n");
+            hcintmsk.d32 = 0;
+            hcintmsk.b.chhltd = 1;
+            dwc_write_reg32(&hc_regs->hcintmsk, hcintmsk.d32);
+            dwc_write_reg32(&hc_regs->hcint, ~hcintmsk.d32);
+            hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+            if (hcchar.b.chen == 0)
+                return -1;
+            else {
+                hcchar.b.chen = 1;
+                hcchar.b.chdis = 1;
+                dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+            }
+
+            return -1;
+
+        }
+        if (hcint.b.nyet) {
+            DBG("nyet interrupt");
+            _core_if->host_if->do_ping = 1;
+            //return -1;
+
+        }
+        if (hcint.b.ack) {
+            DBG("ack interrupt!");
+            _core_if->host_if->do_ping = 0;
+            //return -1;
+
+        }
+        if (hcint.b.xacterr) {
+            ERR("xacterr interrupt!");
+            return -1;
+
+        }
+        if (hcint.b.bblerr) {
+            ERR("bblerr interrupt");
+            return -1;
+        }
+        if (hcint.b.datatglerr) {
+            ERR("datatglerr interrupt!");
+            return -1;
+        }
+
+    }
+    if (gintsts.b.portintr) {
+        ERR("port status changed: hprt0:0x%08x\n",dwc_read_reg32(_core_if->host_if->hprt0));
+        dwc_otg_port_init(_core_if);
+        return -2;
+    }
+
+  }while(handled);
+
+    if (gintsts.b.ptxfempty) {
+        //DBG("ptxfempty interrupt!\n");
+        return -1;
+    }
+    return -1;
+
+}
+
+/*
+ * Do an USB transfer , dir = 0, out ;  dir = 1 , in
+ */
+
+static int
+dwc_otg_submit_job(struct usb_device *dev, unsigned long pipe, int dir, void *buffer, int len,
+                   int is_setup)
+{
+
+    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+    dwc_otg_hc_regs_t *hc_regs;
+    hcchar_data_t   hcchar;
+    hcsplt_data_t   hcsplt;
+    hctsiz_data_t   hctsiz;
+    int             devnum = usb_pipedevice(pipe);
+    int             epnum = usb_pipeendpoint(pipe);
+//    int             dir_in = usb_pipein(pipe);
+    int             toggle,chg_flag = 0;
+    static int             hcnum = 0;
+    hcintmsk_data_t hcintmsk;
+    dwc_otg_host_if_t *host_if = core_if->host_if;
+    int stat, timeout, timeout_base;
+    int t2,t4,t8;
+    int allchannel_int_mask;
+    hcint_data_t    hcint;
+    dwc_otg_host_global_regs_t *host_global_regs = host_if->host_global_regs;
+
+//    printf("dwc_otg_submit_job: dev: %d ,dev->parent: %x, dev->speed: %d\n",
+//		dev->devnum,dev->parent,dev->speed);
+
+//	struct usb_device * hub1 = usb_get_dev_index(1);
+
+//	if(hub1)
+//	    printf("root_hub speed %d\n",hub1->speed);
+//	if(dev->parent != NULL) //not roothub
+//		if(dev->parent->speed ==2 && dev->speed != 2 )
+//			return -EOPNOTSUPP;
+
+    int             type = usb_pipetype(pipe);
+    if (len >= 4096) {
+        ERR("Too big job!\n");
+        dev->status = USB_ST_CRC_ERR;
+        return -E2BIG;
+    }
+
+    if (type == PIPE_ISOCHRONOUS) {
+        ERR("isochronous transfers not supported");
+        dev->status = USB_ST_CRC_ERR;
+        return -EOPNOTSUPP;
+    }
+
+    //hcnum++;
+    if (hcnum > 6) hcnum = 0;
+
+    hc_regs = host_if->hc_regs[hcnum];
+  /*
+	if (!is_insert && (!core_if->dma_enable)) {
+		_mdelay(10);
+		if (dwc_otg_interrupt(core_if, is_setup,hcnum,buffer) == -2)
+			is_insert = 1;
+		else{
+			DBG("wait insert failed");
+			return -1;
+		}
+
+	}	*/
+    //chn_busy = chn_busy | 1<<hcnum ;
+    /*
+     * init hc char (corresponding devaddr and epnum)
+     */
+    hcchar.d32 = 0;
+    hcchar.b.devaddr = devnum;
+    hcchar.b.epnum = epnum;
+    hcchar.b.epdir = dir;
+    hcchar.b.lspddev = 0;
+
+    /* set hc interrupt mask */
+    hcintmsk.d32 = dwc_read_reg32(&hc_regs->hcintmsk);
+    //hcintmsk.b.xfercompl = 1;
+    hcintmsk.d32 = 7;
+    dwc_write_reg32(&hc_regs->hcintmsk, hcintmsk.d32 );
+
+    /* clear int status*/
+    hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+
+    dwc_write_reg32(&hc_regs->hcint, hcint.d32 );
+
+    /* set all channel interrupt mask */
+    allchannel_int_mask = dwc_read_reg32(&host_global_regs->haintmsk);
+    allchannel_int_mask |= 1;
+    dwc_write_reg32(&host_global_regs->haintmsk, allchannel_int_mask);
+
+    switch (usb_pipetype(pipe)) {
+    case PIPE_CONTROL:
+        hcchar.b.eptype = DWC_OTG_EP_TYPE_CONTROL;
+        break;
+    case PIPE_BULK:
+        hcchar.b.eptype = DWC_OTG_EP_TYPE_BULK;
+        break;
+    case PIPE_INTERRUPT:
+    case PIPE_ISOCHRONOUS:
+        ERR("dwc_otg_submit_job: not support iso or interrupt transfer!\n");
+        return -1;
+    }
+
+    hcchar.b.mps = usb_maxpacket(dev, pipe);
+
+    dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+    hcsplt.d32 = 0;
+
+    dwc_write_reg32(&hc_regs->hcsplt, hcsplt.d32);
+    flush_cpu_cache();
+
+
+    hctsiz.d32 = 0;
+
+    hctsiz.b.pktcnt = (len  + usb_maxpacket(dev, pipe) - 1)/ usb_maxpacket(dev, pipe);
+    if (hctsiz.b.pktcnt < 1)
+        hctsiz.b.pktcnt = 1;
+    if (hctsiz.b.pktcnt & 0x1)
+        chg_flag = 1;
+    toggle = usb_gettoggle(dev, epnum, dir);
+    DBG("pktcnt:%d, mps = %d,toggle %d",
+		hctsiz.b.pktcnt, usb_maxpacket(dev, pipe), toggle);
+
+    switch (toggle) {
+    case 0:
+        hctsiz.b.pid = DWC_OTG_HC_PID_DATA0;
+        break;
+    case 1:
+        hctsiz.b.pid = DWC_OTG_HC_PID_DATA1;
+        break;
+    default:
+        ERR("error toggle!\n");
+        return -EPROTO;
+    }
+    if (is_setup)
+        hctsiz.b.pid = DWC_OTG_HC_PID_SETUP;
+
+    core_if->transfer_size = len;
+    hctsiz.b.xfersize = len;
+
+    if (!is_setup && dir == 0 && core_if->host_if->do_ping) {
+		if (!core_if->dma_enable) {
+		dwc_otg_hc_do_ping(core_if, 0);
+		return -10;//It's ping state,pls do it again!
+	}
+        hctsiz.b.dopng = 1;
+    }
+    else
+        hctsiz.b.dopng = 0;
+
+    DBG("ep%d pktcnt :%d, mps: %d hcchar.mps: %d, hctsiz.xfersize %d", hcchar.b.epnum,\
+		hctsiz.b.pktcnt, usb_maxpacket(dev, pipe), hcchar.b.mps,hctsiz.b.xfersize);
+
+    dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+
+    dwc_write_reg32(&hc_regs->hcdma, (uint32_t)(unsigned long long) buffer);
+    flush_cpu_cache();
+
+    hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+
+    hcchar.b.multicnt = 1;      // for no split transfer set this bit 1
+    hcchar.b.chen = 1;
+    hcchar.b.chdis = 0;
+
+    dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+
+    if (!core_if->dma_enable && !dir && len > 0) {
+        /* Load OUT packet into the appropriate Tx FIFO. */
+        dwc_otg_hc_write_packet(core_if, buffer,len,hcnum);
+    }
+    else
+        ;//printf("dmaable:%d, %s,len=%d\n",core_if->dma_enable,dir?"IN":"OUT",len);
+
+    if (usb_pipebulk(pipe))
+        timeout_base = 1000;
+    else
+        timeout_base = 100;
+
+    timeout = timeout_base;
+    t2 = timeout_base /2;
+    t4 = t2/2;
+    t8 = t2/2;
+    /*
+     * Wait for it to complete
+     */
+    while (1) {
+        //_udelay(20);
+        /*
+         * Check whether the controller is done
+         */
+        stat = dwc_otg_interrupt(core_if, is_setup,hcnum,buffer);
+
+        if (stat >= 0) {
+			if (chg_flag)
+			      usb_dotoggle(dev, epnum, dir);
+		      break;
+        }
+
+        /*
+         * Check the timeout
+         */
+        if (--timeout) {
+		   if (timeout - t8 < 0)
+				_udelay(10000);
+		   else if(timeout - t4 < 0)
+				_udelay(1000);
+		   else if(timeout - t2 < 0)
+				_udelay(100);
+		   else
+				_udelay(10);
+		}
+        else {
+	    hctsiz.d32 = dwc_read_reg32(&hc_regs->hctsiz);
+            DBG("TIMEOUT-%s-%d-%d-%ld\n",dir?"IN":"OUT",len,hctsiz.b.pktcnt,usb_pipetype(pipe));
+            break;
+        }
+    }
+    return stat;
+}
+#define CTL_RETRY 5
+int
+submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+                   int len, struct devrequest *setup)
+{
+    int             epnum = usb_pipeendpoint(pipe);
+    int             dir_in = usb_pipein(pipe);
+    int             done;
+    int             ret,retry;
+    //char            *buffer;
+//    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+
+    /*
+     * Setup phase
+     */
+    retry = 0;
+SETUP_RETRY:
+    DBG("--- SETUP PHASE  --------------------try: %d\n",retry);
+    DBG("dev=%ld ep=%ld buf=%p size=%d %s req:%d",
+        usb_pipedevice(pipe), usb_pipeendpoint(pipe), buffer, len, (dir_in?"dir_in":"dir_out"),setup->request);
+
+    usb_settoggle(dev, epnum, 1, 0);
+    ret = dwc_otg_submit_job(dev, pipe, 0, setup, sizeof(struct devrequest), 1);
+    if (ret < 0) {
+       if (retry++ < CTL_RETRY)
+            goto SETUP_RETRY;
+    else{ is_insert = 0;
+           ERR("control setup phase error (ret = %d)", ret);
+           return -1;
+       }
+    }
+
+    /*
+     * Data phase
+     */
+    retry = 0;
+DATA_RETRY:
+    DBG("--- DATA PHASE   --------------------try: %d\n",retry);
+
+
+    done = 0;
+    usb_settoggle(dev, epnum, dir_in, 1);
+    if (done < len) {
+
+       dwc_udelay(100);
+
+        ret = dwc_otg_submit_job(dev, pipe,
+                                 dir_in,
+                                 (__u8 *) buffer, len, 0);
+
+        if (ret < 0) {
+                if (retry++ < CTL_RETRY)
+                        goto DATA_RETRY;
+                else{ is_insert = 0;
+                        ERR("control data phase error (ret = %d)", ret);
+                        return -1;
+                }
+        }
+        //if (!dir_in && ret < usb_maxpacket(dev, pipe))  /* short packet */
+        //    break;
+
+        done += ret;
+    }
+
+    /*
+     * Status phase
+     */
+    retry = 0;
+STATUS_RETRY:
+    DBG("--- STATUS PHASE -------------------try: %d\n",retry);
+    dwc_udelay(100);
+
+    usb_settoggle(dev, epnum, !dir_in, 1);
+    ret = dwc_otg_submit_job(dev, pipe, !dir_in, NULL, 0, 0);
+    if (ret < 0) {
+          if (retry++ < CTL_RETRY)
+               goto STATUS_RETRY;
+          else{ is_insert = 0;
+               ERR("control status phase error (ret = %d)", ret);
+               return -1;
+          }
+    }
+
+    dev->act_len = done;
+    DBG("return size = %d\n", done);
+    dev->status = 0;
+
+    return done;
+}
+
+
+int
+submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buf, int len)
+{
+    int             dir_out = usb_pipeout(pipe);
+    int             max = max_transfer_len(dev, pipe);
+//    int             epnum = usb_pipeendpoint(pipe);
+
+    int             done;
+    int             ret;
+//    int             toggle;
+    int             retry;
+    char            *buffer=NULL;
+    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+
+    DBG("--- BULK -----------------------------------------\n");
+    DBG("dev=%ld ep=%ld buf=%p size=%d %s",
+       usb_pipedevice(pipe), usb_pipeendpoint(pipe), buf, len, (dir_out?"dir_out":"dir_in"));
+    if (len == 31)
+		DBG("scsi cmd from CBW: 0x%X\n",*(((unsigned char*)buf)+15));
+
+    done = 0;
+    if (dir_out) {
+        memcpy(core_if->temp_buffer, buf, len);
+    }
+    buffer = core_if->temp_buffer;
+    retry = 5;
+    while (done < len) {
+RETRY:
+       dwc_udelay(100);
+        ret = dwc_otg_submit_job(dev, pipe,
+                                 !dir_out,
+                                 (__u8 *) buffer + done, max > len - done ? len - done : max, 0);
+        if (ret < 0 ) {
+            if (retry--) {
+                DBG("error on bulk message, retry: %d",retry);
+                goto RETRY;
+            }else{
+                is_insert = 0;
+                ERR("error on bulk message (ret = %d)", ret);
+                return -1;
+            }
+        }
+
+        done += ret;
+        //usb_dotoggle(dev, epnum, !dir_out);
+
+        if (!dir_out && ret < max)      /* short packet */
+            break;
+
+    }
+    DBG("return size = %d\n", done);
+    if (!dir_out) {
+        memcpy(buf, buffer, len);
+    }
+    dev->act_len = done;
+    dev->status = 0;
+
+    return 0;
+}
+/**
+ * Flush a Tx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _num Tx FIFO to flush.
+ */
+extern void
+dwc_otg_flush_tx_fifo(dwc_otg_core_if_t * _core_if, const int _num)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    grstctl_t       greset = { 0 };
+    int             count = 0;
+
+    DWC_DEBUGPL((DBG_CIL | DBG_PCDV), "Flush Tx FIFO %d\n", _num);
+
+    greset.b.txfflsh = 1;
+    greset.b.txfnum = _num;
+    dwc_write_reg32(&global_regs->grstctl, greset.d32);
+
+    do {
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 10000) {
+            WARN("%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
+                 "dwc_otg_flush_tx_fifo", greset.d32, dwc_read_reg32(&global_regs->gnptxsts));
+            break;
+        }
+
+    } while (greset.b.txfflsh == 1);
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    _mdelay(1);
+}
+
+/**
+ * Flush Rx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+extern void
+dwc_otg_flush_rx_fifo(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    volatile grstctl_t greset = { 0 };
+    int             count = 0;
+
+    DWC_DEBUGPL((DBG_CIL | DBG_PCDV), "%s\n", "dwc_otg_flush_rx_fifo");
+    /*
+     *
+     */
+    greset.b.rxfflsh = 1;
+    dwc_write_reg32(&global_regs->grstctl, greset.d32);
+
+    do {
+        greset.d32 = dwc_read_reg32(&global_regs->grstctl);
+        if (++count > 10000) {
+            WARN("%s() HANG! GRSTCTL=%0x\n", "dwc_otg_flush_rx_fifo", greset.d32);
+            break;
+        }
+    } while (greset.b.rxfflsh == 1);
+    /*
+     * Wait for 3 PHY Clocks
+     */
+    _mdelay(1);
+}
+static void
+dwc_otg_set_vbus_power(dwc_otg_core_if_t * _core_if, int is_power_on)
+{
+	if ( _core_if->set_vbus_power)
+		 _core_if->set_vbus_power(is_power_on);
+}
+/**
+ * This function Reads HPRT0 in preparation to modify.  It keeps the
+ * WC bits 0 so that if they are read as 1, they won't clear when you
+ * write it back
+ */
+static inline   uint32_t
+dwc_otg_read_hprt0(dwc_otg_core_if_t * _core_if)
+{
+    hprt0_data_t    hprt0;
+    hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+    hprt0.b.prtena = 0;
+    hprt0.b.prtconndet = 0;
+    hprt0.b.prtenchng = 0;
+    hprt0.b.prtovrcurrchng = 0;
+    return hprt0.d32;
+}
+/**
+ * This function enables the Host mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+void
+dwc_otg_enable_host_interrupts(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    gintmsk_data_t  intr_mask = { 0 };
+
+    DWC_DEBUGPL(DBG_CIL, "%s()\n", "dwc_otg_enable_host_interrupts");
+
+    /*
+     * Disable all interrupts.
+     */
+    dwc_write_reg32(&global_regs->gintmsk, 0);
+
+    /*
+     * Clear any pending interrupts.
+     */
+    dwc_write_reg32(&global_regs->gintsts, 0xFFFFFFFF);
+
+    /*
+     * Enable the common interrupts
+     */
+    dwc_otg_enable_common_interrupts(_core_if);
+
+    /*
+     * Enable host mode interrupts without disturbing common
+     * interrupts.
+     */
+#ifndef NO_HOST_SOF
+    intr_mask.b.sofintr = 1;
+#endif
+    intr_mask.b.portintr = 1;//6.1.1
+    intr_mask.b.hcintr = 1;
+
+    dwc_modify_reg32(&global_regs->gintmsk, intr_mask.d32, intr_mask.d32);
+}
+
+/**
+ * This function initializes the DWC_otg controller registers for
+ * host mode.
+ *
+ * This function flushes the Tx and Rx FIFOs and it flushes any entries in the
+ * request queues. Host channels are reset to ensure that they are ready for
+ * performing transfers.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ *
+ */
+void
+dwc_otg_core_host_init(dwc_otg_core_if_t * _core_if)
+{
+    dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+    dwc_otg_host_if_t *host_if = _core_if->host_if;
+    dwc_otg_core_params_t *params = _core_if->core_params;
+    hprt0_data_t    hprt0 = { 0 };
+    fifosize_data_t nptxfifosize;
+    fifosize_data_t ptxfifosize;
+    int             i;
+    hcchar_data_t   hcchar;
+    hcfg_data_t     hcfg;
+    dwc_otg_hc_regs_t *hc_regs;
+    int             num_channels;
+    gotgctl_data_t  gotgctl = { 0 };
+
+    DWC_DEBUGPL(DBG_CILV, "%s(%p)\n", "dwc_otg_core_host_init", _core_if);
+
+    /*
+     * Restart the Phy Clock
+     */
+    dwc_write_reg32(_core_if->pcgcctl, 0);
+
+    /*
+     * Initialize Host Configuration Register
+     */
+    init_fslspclksel(_core_if);
+    if (_core_if->core_params->speed == DWC_SPEED_PARAM_FULL) {
+        hcfg.d32 = dwc_read_reg32(&host_if->host_global_regs->hcfg);
+        hcfg.b.fslssupp = 1;
+        dwc_write_reg32(&host_if->host_global_regs->hcfg, hcfg.d32);
+    }
+
+    /*
+     * Configure data FIFO sizes 6.1.1.11----6.1.1.13
+     */
+    if (_core_if->hwcfg2.b.dynamic_fifo && params->enable_dynamic_fifo) {
+        DWC_DEBUGPL(DBG_CIL, "Total FIFO Size=%d\n", _core_if->total_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "Rx FIFO Size=%d\n", params->host_rx_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "NP Tx FIFO Size=%d\n", params->host_nperio_tx_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "P Tx FIFO Size=%d\n", params->host_perio_tx_fifo_size);
+
+        /*
+         * Rx FIFO
+         */
+        DWC_DEBUGPL(DBG_CIL, "initial grxfsiz=%08x\n", dwc_read_reg32(&global_regs->grxfsiz));
+        dwc_write_reg32(&global_regs->grxfsiz, params->host_rx_fifo_size);
+        DWC_DEBUGPL(DBG_CIL, "new grxfsiz=%08x\n", dwc_read_reg32(&global_regs->grxfsiz));
+
+        /*
+         * Non-periodic Tx FIFO
+         */
+        DWC_DEBUGPL(DBG_CIL, "initial gnptxfsiz=%08x\n", dwc_read_reg32(&global_regs->gnptxfsiz));
+        nptxfifosize.b.depth = params->host_nperio_tx_fifo_size;
+        nptxfifosize.b.startaddr = params->host_rx_fifo_size;
+        dwc_write_reg32(&global_regs->gnptxfsiz, nptxfifosize.d32);
+        DWC_DEBUGPL(DBG_CIL, "new gnptxfsiz=%08x\n", dwc_read_reg32(&global_regs->gnptxfsiz));
+
+        /*
+         * Periodic Tx FIFO
+         */
+        DWC_DEBUGPL(DBG_CIL, "initial hptxfsiz=%08x\n", dwc_read_reg32(&global_regs->hptxfsiz));
+        ptxfifosize.b.depth = params->host_perio_tx_fifo_size;
+        ptxfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
+        dwc_write_reg32(&global_regs->hptxfsiz, ptxfifosize.d32);
+        DWC_DEBUGPL(DBG_CIL, "new hptxfsiz=%08x\n", dwc_read_reg32(&global_regs->hptxfsiz));
+    }
+
+    /*
+     * Clear Host Set HNP Enable in the OTG Control Register
+     */
+    gotgctl.b.hstsethnpen = 1;
+    dwc_modify_reg32(&global_regs->gotgctl, gotgctl.d32, 0);
+
+    /*
+     * Make sure the FIFOs are flushed.
+     */
+    dwc_otg_flush_tx_fifo(_core_if, 0x10 /* all Tx FIFOs */ );
+    dwc_otg_flush_rx_fifo(_core_if);
+
+    /*
+     * Flush out any leftover queued requests.
+     */
+    num_channels = _core_if->core_params->host_channels;
+    for (i = 0; i < num_channels; i++) {
+        hc_regs = _core_if->host_if->hc_regs[i];
+        hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+        hcchar.b.chen = 0;
+        hcchar.b.chdis = 1;
+        hcchar.b.epdir = 0;
+        dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+    }
+
+    /*
+     * Halt all channels to put them into a known state.
+     */
+    for (i = 0; i < num_channels; i++) {
+        int             count = 0;
+        hc_regs = _core_if->host_if->hc_regs[i];
+        hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+        hcchar.b.chen = 1;
+        hcchar.b.chdis = 1;
+        hcchar.b.epdir = 0;
+        dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+        DWC_DEBUGPL(DBG_HCDV, "%s: Halt channel %d\n", "dwc_otg_core_host_init", i);
+        do {
+            hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+            if (++count > 1000) {
+               // ERR("%s: Unable to clear halt on channel %d\n", "dwc_otg_core_host_init", i);
+                break;
+            }
+        } while (hcchar.b.chen);
+    }
+
+    /*
+     * Turn on the vbus power.
+     */
+    DBG("Init: Port Power? op_state=%d\n", _core_if->op_state);
+    if (_core_if->op_state == A_HOST) {
+        hprt0.d32 = dwc_otg_read_hprt0(_core_if);
+        DBG("Init: Power Port (%d)\n", hprt0.b.prtpwr);
+        if (hprt0.b.prtpwr == 0) {
+            hprt0.b.prtpwr = 1;//6.1.1.3
+            dwc_write_reg32(host_if->hprt0, hprt0.d32);
+            /*
+             * pull gpio to switch power
+             */
+            dwc_otg_set_vbus_power(_core_if, 1);
+        }
+    } else {
+        dwc_otg_set_vbus_power(_core_if, 0);    // Power off VBus
+    }
+
+    dwc_otg_enable_host_interrupts(_core_if);
+}
+
+static int      dwc_otg_hcd_enable = 0;
+
+/* wait at least 10ms for the reset process to complete 6.1.1.6 */
+static void
+dwc_otg_reset_port(dwc_otg_core_if_t * _core_if)
+{
+    hprt0_data_t    hprt0;
+    hprt0.d32 = dwc_otg_read_hprt0(_core_if);
+    hprt0.b.prtrst = 1;
+    dwc_write_reg32(_core_if->host_if->hprt0, hprt0.d32);
+
+    _mdelay(60);
+
+    hprt0.b.prtrst = 0;
+    dwc_write_reg32(_core_if->host_if->hprt0, hprt0.d32);
+    _mdelay(20);
+
+}
+static int
+dwc_otg_port_init(dwc_otg_core_if_t * _core_if)
+{
+		int retry = 10;
+    hprt0_data_t    hprt0,hprt0_modify;
+    hprt0.d32 = 0;
+/*
+    hprt0.d32 = dwc_otg_read_hprt0(_core_if);
+
+    hprt0_data_t    hprt0_modify;
+
+    hprt0_modify.b.prtena = 0;
+    hprt0_modify.b.prtconndet = 0;
+    hprt0_modify.b.prtenchng = 0;
+    hprt0_modify.b.prtovrcurrchng = 0;
+
+    _mdelay(30);
+*/
+next:
+    hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+    DBG("%s port data is 0x%X", __func__, hprt0.d32);
+
+    hprt0_modify.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+
+    if (hprt0.b.prtconndet) {//wait prtconndet interrupt
+        /*
+         * clear detect intr
+         */
+        _mdelay(30);
+        dwc_write_reg32(_core_if->host_if->hprt0, hprt0_modify.d32);
+        _mdelay(30);
+        /*
+         * reset port  6.1.1.6
+         */
+        dwc_otg_reset_port(_core_if);
+        hprt0_modify.b.prtconndet = 1;
+
+    }else{
+        _mdelay(100);
+		if (retry--)
+			goto next;
+		INFO("No USB device found !");
+		return 0;
+    }
+    /*
+     * Determine if the connected device is a high/full/low speed device
+     */
+    hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+
+    if (hprt0.b.prtenchng) {//6.1.1.8
+        hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+
+        hprt0_modify.b.prtena = 0;
+        hprt0_modify.b.prtconndet = 0;
+        hprt0_modify.b.prtenchng = 0;
+        hprt0_modify.b.prtovrcurrchng = 0;
+        hprt0_modify.b.prtenchng = 1;
+        dwc_write_reg32(_core_if->host_if->hprt0, hprt0_modify.d32);
+
+    }
+
+//    _core_if->host_if->do_ping = 1; // init value
+    _core_if->host_if->do_ping = 0; // init value
+
+    if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_LOW_SPEED) {//6.1.1.9
+        INFO("Lowspeed device found !\n");
+    } else if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_FULL_SPEED) {
+        INFO("Fullspeed device found !\n");
+    } else if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_HIGH_SPEED) {
+        INFO("Highspeed device found !\n");
+    }
+
+		return 1;
+}
+/*
+ * --- Init functions ------------------------------------------------------
+ */
+int
+usb_lowlevel_init(int index,enum usb_init_type init, void **controller)
+{
+    dwc_otg_device_t *dwc_otg_device = &dwc_otg_dev;
+    //int             retval = 0;
+    int32_t         snpsid;
+    int             i,id_mode,port_idx = 100;	//remove warning.
+    amlogic_usb_config_t * usb_config;
+
+    printf("dwc_usb driver version: %s\n",DWC_DRIVER_VERSION);
+
+    usb_config = amlogic_usb_start(BOARD_USB_MODE_HOST,index);
+
+    if (!usb_config || !usb_config->base_addr) {
+			ERR("Bad usb config or base addr! Need call board_usb_init() in board init\n");
+			//retval = -1;
+	      goto fail;
+	}
+
+    if ((usb_config->base_addr & USB_PHY_PORT_MSK) == USB_PHY_PORT_A)
+	    port_idx = 0;
+    else if((usb_config->base_addr & USB_PHY_PORT_MSK) == USB_PHY_PORT_B)
+	    port_idx = 1;
+#ifdef CONFIG_M6TV
+	else if((usb_config->base_addr & USB_PHY_PORT_MSK) == USB_PHY_PORT_C)
+		port_idx = 2;
+	else if((usb_config->base_addr & USB_PHY_PORT_MSK) == USB_PHY_PORT_D)
+		port_idx = 3;
+#endif
+    memset(dwc_otg_device, 0, sizeof(dwc_otg_device_t));
+
+    printf("USB (%d) base addr: 0x%x\n",port_idx,usb_config->base_addr);
+    dwc_otg_device->base = (void *)(unsigned long long)usb_config->base_addr;
+    dwc_otg_device->index = index;
+    snpsid = dwc_read_reg32((uint32_t *) ((uint8_t *) dwc_otg_device->base + 0x40));
+
+    if ((snpsid & 0xFFFF0000) != 0x4F540000) {
+        ERR("Bad value for SNPSID: 0x%08x\n", snpsid);
+        //retval = -1;
+        goto fail;
+    }
+    //dwc_otg_module_params_host.dma_enable = 1;
+
+    dwc_otg_device->core_if = dwc_otg_cil_init(dwc_otg_device->base, &dwc_otg_module_params_host);
+    if (dwc_otg_device->core_if == 0) {
+        ERR("CIL initialization failed!\n");
+        //retval = -1;
+        goto fail;
+    }
+    dwc_otg_device->core_if->set_vbus_power = usb_config->set_vbus_power;
+
+	switch (usb_config->id_mode) {
+	case USB_ID_MODE_HARDWARE:
+		id_mode = FORCE_ID_CLEAR;
+		break;
+	case USB_ID_MODE_SW_HOST:
+		id_mode = FORCE_ID_HOST;
+		break;
+	case USB_ID_MODE_SW_DEVICE:
+		id_mode = FORCE_ID_SLAVE;
+		break;
+	default:
+		id_mode = FORCE_ID_ERROR;
+		break;
+	}
+     dwc_otg_set_force_id(dwc_otg_device->core_if,id_mode);
+    /*
+     * Disable the global interrupt until all the interrupt
+     * handlers are installed.
+     */
+    dwc_otg_disable_global_interrupts(dwc_otg_device->core_if);
+    /*
+     * Initialize the DWC_otg core.
+     */
+    if (dwc_otg_core_init(dwc_otg_device->core_if))
+	goto fail;
+    for (i = 0; i < 2; i++) {
+        dwc_otg_hc_cleanup(dwc_otg_device->core_if, i);
+    }
+
+    dwc_otg_core_host_init(dwc_otg_device->core_if);
+
+    /*
+     * Enable the global interrupt after all the interrupt
+     * handlers are installed.
+     */
+    dwc_otg_enable_global_interrupts(dwc_otg_device->core_if);
+
+    if (!dwc_otg_port_init(dwc_otg_device->core_if)) /* host initialization 6.1.1.3----6.1.1.9*/
+				goto fail;
+
+    dwc_otg_hcd_enable = 1;
+    dwc_otg_device->disabled = 0;
+    return 0;
+  fail:
+    return -1;
+}
+
+int
+usb_lowlevel_stop(int index)
+{
+    dwc_otg_core_if_t *core_if = dwc_otg_dev.core_if;
+
+    DBG("%s\n", __func__);
+    if (!dwc_otg_hcd_enable)
+        return 0;
+#if 0
+    if (!core_if)
+        return 0;
+#endif
+
+    dwc_otg_hcd_stop(core_if);
+    amlogic_usb_stop(BOARD_USB_MODE_HOST,dwc_otg_dev.index);
+#if 0
+    if (core_if->temp_buffer) {
+        kfree(core_if->temp_buffer);
+    }
+
+    if (core_if->host_if) {
+        kfree(core_if->host_if);
+    }
+
+    if (core_if) {
+        kfree(core_if);
+    }
+    dwc_otg_dev.core_if = 0;
+#endif
+
+    return 0;
+}
diff --git a/drivers/usb/host/dwc_otg_hcd_294.h b/drivers/usb/host/dwc_otg_hcd_294.h
new file mode 100644
index 0000000..0ffda0c
--- /dev/null
+++ b/drivers/usb/host/dwc_otg_hcd_294.h
@@ -0,0 +1,819 @@
+
+/*
+ * drivers/usb/host/dwc_otg_hcd_294.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __DWC_OTG_HCD_H__
+#define __DWC_OTG_HCD_H__
+#include <asm/arch/io.h>
+
+#define DWC_DRIVER_VERSION	"2.94 6-June-2012"
+//#define DEBUG
+
+/** When debug level has the DBG_CIL bit set, display CIL Debug messages. */
+#define DBG_CIL		(0x2)
+/** When debug level has the DBG_CILV bit set, display CIL Verbose debug
+ * messages */
+#define DBG_CILV	(0x20)
+/**  When debug level has the DBG_PCD bit set, display PCD (Device) debug
+ *  messages */
+#define DBG_PCD		(0x4)
+/** When debug level has the DBG_PCDV set, display PCD (Device) Verbose debug
+ * messages */
+#define DBG_PCDV	(0x40)
+/** When debug level has the DBG_HCD bit set, display Host debug messages */
+#define DBG_HCD		(0x8)
+/** When debug level has the DBG_HCDV bit set, display Verbose Host debug
+ * messages */
+#define DBG_HCDV	(0x80)
+/** When debug level has the DBG_HCD_URB bit set, display enqueued URBs in host
+ *  mode. */
+#define DBG_HCD_URB	(0x800)
+
+/** When debug level has any bit set, display debug messages */
+#define DBG_ANY		(0xFF)
+
+/** All debug messages off */
+#define DBG_OFF		0
+//#define DEBUG
+#undef DEBUG
+#ifdef DEBUG
+#define DBG(fmt, args...)	\
+		printf("dwc_otg: %s: " fmt "\n" , __FUNCTION__ , ## args)
+
+# define DWC_DEBUGPL(lvl, x...) do{printf( x ); }while(0)
+
+#else
+#define DBG(fmt, args...)	do {} while (0)
+# define DWC_DEBUGPL(lvl, x...) do{}while(0)
+
+#endif
+
+#ifdef VERBOSE
+#    define VDBG		DBG
+#else
+#    define VDBG(fmt, args...)	do {} while (0)
+#endif
+
+#define ERR(fmt, args...)	\
+		printf("dwc_otg: %s: " fmt "\n" , __FUNCTION__ , ## args)
+#define WARN(fmt, args...)	\
+		printf("dwc_otg: %s: " fmt "\n" , __FUNCTION__ , ## args)
+#define INFO(fmt, args...)	\
+		printf("dwc_otg: " fmt "\n" , ## args)
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Reasons for halting a host channel.
+ */
+typedef enum dwc_otg_halt_status
+{
+	DWC_OTG_HC_XFER_NO_HALT_STATUS,
+	DWC_OTG_HC_XFER_COMPLETE,
+	DWC_OTG_HC_XFER_URB_COMPLETE,
+	DWC_OTG_HC_XFER_ACK,
+	DWC_OTG_HC_XFER_NAK,
+	DWC_OTG_HC_XFER_NYET,
+	DWC_OTG_HC_XFER_STALL,
+	DWC_OTG_HC_XFER_XACT_ERR,
+	DWC_OTG_HC_XFER_FRAME_OVERRUN,
+	DWC_OTG_HC_XFER_BABBLE_ERR,
+	DWC_OTG_HC_XFER_DATA_TOGGLE_ERR,
+	DWC_OTG_HC_XFER_AHB_ERR,
+	DWC_OTG_HC_XFER_PERIODIC_INCOMPLETE,
+	DWC_OTG_HC_XFER_URB_DEQUEUE
+} dwc_otg_halt_status_e;
+
+/**
+ * Host channel descriptor. This structure represents the state of a single
+ * host channel when acting in host mode. It contains the data items needed to
+ * transfer packets to an endpoint via a host channel.
+ */
+typedef struct dwc_hc
+{
+	/** Host channel number used for register address lookup */
+	uint8_t	 hc_num;
+
+	/** Device to access */
+	unsigned dev_addr : 7;
+
+	/** EP to access */
+	unsigned ep_num : 4;
+
+	/** EP direction. 0: OUT, 1: IN */
+	unsigned ep_is_in : 1;
+
+	/**
+	 * EP speed.
+	 * One of the following values:
+	 *	- DWC_OTG_EP_SPEED_LOW
+	 *	- DWC_OTG_EP_SPEED_FULL
+	 *	- DWC_OTG_EP_SPEED_HIGH
+	 */
+	unsigned speed : 2;
+#define DWC_OTG_EP_SPEED_LOW	0
+#define DWC_OTG_EP_SPEED_FULL	1
+#define DWC_OTG_EP_SPEED_HIGH	2
+
+	/**
+	 * Endpoint type.
+	 * One of the following values:
+	 *	- DWC_OTG_EP_TYPE_CONTROL: 0
+	 *	- DWC_OTG_EP_TYPE_ISOC: 1
+	 *	- DWC_OTG_EP_TYPE_BULK: 2
+	 *	- DWC_OTG_EP_TYPE_INTR: 3
+	 */
+	unsigned ep_type : 2;
+
+	/** Max packet size in bytes */
+	unsigned max_packet : 11;
+
+	/**
+	 * PID for initial transaction.
+	 * 0: DATA0,<br>
+	 * 1: DATA2,<br>
+	 * 2: DATA1,<br>
+	 * 3: MDATA (non-Control EP),
+	 *	  SETUP (Control EP)
+	 */
+	unsigned data_pid_start : 2;
+#define DWC_OTG_HC_PID_DATA0 0
+#define DWC_OTG_HC_PID_DATA2 1
+#define DWC_OTG_HC_PID_DATA1 2
+#define DWC_OTG_HC_PID_MDATA 3
+#define DWC_OTG_HC_PID_SETUP 3
+
+	/** Number of periodic transactions per (micro)frame */
+	unsigned multi_count: 2;
+
+	/** @name Transfer State */
+	/** @{ */
+
+	/** Pointer to the current transfer buffer position. */
+	uint8_t *xfer_buff;
+	/** Total number of bytes to transfer. */
+	uint32_t xfer_len;
+	/** Number of bytes transferred so far. */
+	uint32_t xfer_count;
+	/** Packet count at start of transfer.*/
+	uint16_t start_pkt_count;
+
+	/**
+	 * Flag to indicate whether the transfer has been started. Set to 1 if
+	 * it has been started, 0 otherwise.
+	 */
+	uint8_t xfer_started;
+
+	/**
+	 * Set to 1 to indicate that a PING request should be issued on this
+	 * channel. If 0, process normally.
+	 */
+	uint8_t do_ping;
+
+	/**
+	 * Set to 1 to indicate that the error count for this transaction is
+	 * non-zero. Set to 0 if the error count is 0.
+	 */
+	uint8_t error_state;
+
+	/**
+	 * Set to 1 to indicate that this channel should be halted the next
+	 * time a request is queued for the channel. This is necessary in
+	 * slave mode if no request queue space is available when an attempt
+	 * is made to halt the channel.
+	 */
+	uint8_t halt_on_queue;
+
+	/**
+	 * Set to 1 if the host channel has been halted, but the core is not
+	 * finished flushing queued requests. Otherwise 0.
+	 */
+	uint8_t halt_pending;
+
+	/**
+	 * Reason for halting the host channel.
+	 */
+	dwc_otg_halt_status_e	halt_status;
+
+	/*
+	 * Split settings for the host channel
+	 */
+	uint8_t do_split;		   /**< Enable split for the channel */
+	uint8_t complete_split;	   /**< Enable complete split */
+	uint8_t hub_addr;		   /**< Address of high speed hub */
+
+	uint8_t port_addr;		   /**< Port of the low/full speed device */
+	/** Split transaction position
+	 * One of the following values:
+	 *	  - DWC_HCSPLIT_XACTPOS_MID
+	 *	  - DWC_HCSPLIT_XACTPOS_BEGIN
+	 *	  - DWC_HCSPLIT_XACTPOS_END
+	 *	  - DWC_HCSPLIT_XACTPOS_ALL */
+	uint8_t xact_pos;
+
+	/** Set when the host channel does a short read. */
+	uint8_t short_read;
+
+	/**
+	 * Number of requests issued for this channel since it was assigned to
+	 * the current transfer (not counting PINGs).
+	 */
+	uint8_t requests;
+
+	/**
+	 * Queue Head for the transfer being processed by this channel.
+	 */
+	struct dwc_otg_qh *qh;
+
+	/** @} */
+
+	/** Entry in list of host channels. */
+	struct list_head	hc_list_entry;
+} dwc_hc_t;
+#define DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE 0
+#define DWC_OTG_CAP_PARAM_SRP_ONLY_CAPABLE 1
+#define DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE 2
+
+#define DWC_PHY_TYPE_PARAM_FS 0
+#define DWC_PHY_TYPE_PARAM_UTMI 1
+#define DWC_PHY_TYPE_PARAM_ULPI 2
+
+#define DWC_SPEED_PARAM_HIGH 0
+#define DWC_SPEED_PARAM_FULL 1
+/**
+ * The following parameters may be specified when starting the module. These
+ * parameters define how the DWC_otg controller should be configured.
+ */
+typedef struct dwc_otg_core_params {
+	int32_t opt;
+
+	/**
+	 * Specifies the OTG capabilities. The driver will automatically
+	 * detect the value for this parameter if none is specified.
+	 * 0 - HNP and SRP capable (default)
+	 * 1 - SRP Only capable
+	 * 2 - No HNP/SRP capable
+	 */
+	int32_t otg_cap;
+
+	/**
+	 * Specifies whether to use slave or DMA mode for accessing the data
+	 * FIFOs. The driver will automatically detect the value for this
+	 * parameter if none is specified.
+	 * 0 - Slave
+	 * 1 - DMA (default, if available)
+	 */
+	int32_t dma_enable;
+
+	/**
+	 * When DMA mode is enabled specifies whether to use address DMA or DMA
+	 * Descriptor mode for accessing the data FIFOs in device mode. The driver
+	 * will automatically detect the value for this if none is specified.
+	 * 0 - address DMA
+	 * 1 - DMA Descriptor(default, if available)
+	 */
+	int32_t dma_desc_enable;
+	/** The DMA Burst size (applicable only for External DMA
+	 * Mode). 1, 4, 8 16, 32, 64, 128, 256 (default 32)
+	 */
+	int32_t dma_burst_size;	/* Translate this to GAHBCFG values */
+
+	/**
+	 * Specifies the maximum speed of operation in host and device mode.
+	 * The actual speed depends on the speed of the attached device and
+	 * the value of phy_type. The actual speed depends on the speed of the
+	 * attached device.
+	 * 0 - High Speed (default)
+	 * 1 - Full Speed
+	 */
+	int32_t speed;
+	/** Specifies whether low power mode is supported when attached
+	 *	to a Full Speed or Low Speed device in host mode.
+	 * 0 - Don't support low power mode (default)
+	 * 1 - Support low power mode
+	 */
+	int32_t host_support_fs_ls_low_power;
+
+	/** Specifies the PHY clock rate in low power mode when connected to a
+	 * Low Speed device in host mode. This parameter is applicable only if
+	 * HOST_SUPPORT_FS_LS_LOW_POWER is enabled. If PHY_TYPE is set to FS
+	 * then defaults to 6 MHZ otherwise 48 MHZ.
+	 *
+	 * 0 - 48 MHz
+	 * 1 - 6 MHz
+	 */
+	int32_t host_ls_low_power_phy_clk;
+
+	/**
+	 * 0 - Use cC FIFO size parameters
+	 * 1 - Allow dynamic FIFO sizing (default)
+	 */
+	int32_t enable_dynamic_fifo;
+
+	/** Total number of 4-byte words in the data FIFO memory. This
+	 * memory includes the Rx FIFO, non-periodic Tx FIFO, and periodic
+	 * Tx FIFOs.
+	 * 32 to 32768 (default 8192)
+	 * Note: The total FIFO memory depth in the FPGA configuration is 8192.
+	 */
+	int32_t data_fifo_size;
+
+	/** Number of 4-byte words in the Rx FIFO in device mode when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1064)
+	 */
+	int32_t dev_rx_fifo_size;
+
+	/** Number of 4-byte words in the non-periodic Tx FIFO in device mode
+	 * when dynamic FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t dev_nperio_tx_fifo_size;
+
+	/** Number of 4-byte words in each of the periodic Tx FIFOs in device
+	 * mode when dynamic FIFO sizing is enabled.
+	 * 4 to 768 (default 256)
+	 */
+	uint32_t dev_perio_tx_fifo_size[MAX_PERIO_FIFOS];
+
+	/** Number of 4-byte words in the Rx FIFO in host mode when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_rx_fifo_size;
+
+	/** Number of 4-byte words in the non-periodic Tx FIFO in host mode
+	 * when Dynamic FIFO sizing is enabled in the core.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_nperio_tx_fifo_size;
+
+	/** Number of 4-byte words in the host periodic Tx FIFO when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_perio_tx_fifo_size;
+
+	/** The maximum transfer size supported in bytes.
+	 * 2047 to 65,535  (default 65,535)
+	 */
+	int32_t max_transfer_size;
+
+	/** The maximum number of packets in a transfer.
+	 * 15 to 511  (default 511)
+	 */
+	int32_t max_packet_count;
+
+	/** The number of host channel registers to use.
+	 * 1 to 16 (default 12)
+	 * Note: The FPGA configuration supports a maximum of 12 host channels.
+	 */
+	int32_t host_channels;
+
+	/** The number of endpoints in addition to EP0 available for device
+	 * mode operations.
+	 * 1 to 15 (default 6 IN and OUT)
+	 * Note: The FPGA configuration supports a maximum of 6 IN and OUT
+	 * endpoints in addition to EP0.
+	 */
+	int32_t dev_endpoints;
+
+		/**
+		 * Specifies the type of PHY interface to use. By default, the driver
+		 * will automatically detect the phy_type.
+		 *
+		 * 0 - Full Speed PHY
+		 * 1 - UTMI+ (default)
+		 * 2 - ULPI
+		 */
+	int32_t phy_type;
+
+	/**
+	 * Specifies the UTMI+ Data Width. This parameter is
+	 * applicable for a PHY_TYPE of UTMI+ or ULPI. (For a ULPI
+	 * PHY_TYPE, this parameter indicates the data width between
+	 * the MAC and the ULPI Wrapper.) Also, this parameter is
+	 * applicable only if the OTG_HSPHY_WIDTH cC parameter was set
+	 * to "8 and 16 bits", meaning that the core has been
+	 * configured to work at either data path width.
+	 *
+	 * 8 or 16 bits (default 16)
+	 */
+	int32_t phy_utmi_width;
+
+	/**
+	 * Specifies whether the ULPI operates at double or single
+	 * data rate. This parameter is only applicable if PHY_TYPE is
+	 * ULPI.
+	 *
+	 * 0 - single data rate ULPI interface with 8 bit wide data
+	 * bus (default)
+	 * 1 - double data rate ULPI interface with 4 bit wide data
+	 * bus
+	 */
+	int32_t phy_ulpi_ddr;
+
+	/**
+	 * Specifies whether to use the internal or external supply to
+	 * drive the vbus with a ULPI phy.
+	 */
+	int32_t phy_ulpi_ext_vbus;
+
+	/**
+	 * Specifies whether to use the I2Cinterface for full speed PHY. This
+	 * parameter is only applicable if PHY_TYPE is FS.
+	 * 0 - No (default)
+	 * 1 - Yes
+	 */
+	int32_t i2c_enable;
+
+	int32_t ulpi_fs_ls;
+
+	int32_t ts_dline;
+
+	/**
+	 * Specifies whether dedicated transmit FIFOs are
+	 * enabled for non periodic IN endpoints in device mode
+	 * 0 - No
+	 * 1 - Yes
+	 */
+	int32_t en_multiple_tx_fifo;
+
+	/** Number of 4-byte words in each of the Tx FIFOs in device
+	 * mode when dynamic FIFO sizing is enabled.
+	 * 4 to 768 (default 256)
+	 */
+	uint32_t dev_tx_fifo_size[MAX_TX_FIFOS];
+
+	/** Thresholding enable flag-
+	 * bit 0 - enable non-ISO Tx thresholding
+	 * bit 1 - enable ISO Tx thresholding
+	 * bit 2 - enable Rx thresholding
+	 */
+	uint32_t thr_ctl;
+
+	/** Thresholding length for Tx
+	 *	FIFOs in 32 bit DWORDs
+	 */
+	uint32_t tx_thr_length;
+
+	/** Thresholding length for Rx
+	 *	FIFOs in 32 bit DWORDs
+	 */
+	uint32_t rx_thr_length;
+
+	/**
+	 * Specifies whether LPM (Link Power Management) support is enabled
+	 */
+	int32_t lpm_enable;
+
+	/** Per Transfer Interrupt
+	 *	mode enable flag
+	 * 1 - Enabled
+	 * 0 - Disabled
+	 */
+	int32_t pti_enable;
+
+	/** Multi Processor Interrupt
+	 *	mode enable flag
+	 * 1 - Enabled
+	 * 0 - Disabled
+	 */
+	int32_t mpi_enable;
+
+	/** IS_USB Capability
+	 * 1 - Enabled
+	 * 0 - Disabled
+	 */
+	int32_t ic_usb_cap;
+
+	/** AHB Threshold Ratio
+	 * 2'b00 AHB Threshold = 	MAC Threshold
+	 * 2'b01 AHB Threshold = 1/2 	MAC Threshold
+	 * 2'b10 AHB Threshold = 1/4	MAC Threshold
+	 * 2'b11 AHB Threshold = 1/8	MAC Threshold
+	 */
+	int32_t ahb_thr_ratio;
+
+	/** ADP Support
+	 * 1 - Enabled
+	 * 0 - Disabled
+	 */
+	int32_t adp_supp_enable;
+
+	/** HFIR Reload Control
+	 * 0 - The HFIR cannot be reloaded dynamically.
+	 * 1 - Allow dynamic reloading of the HFIR register during runtime.
+	 */
+	int32_t reload_ctl;
+
+	/** DCFG: Enable device Out NAK
+	 * 0 - The core does not set NAK after Bulk Out transfer complete.
+	 * 1 - The core sets NAK after Bulk OUT transfer complete.
+	 */
+	int32_t dev_out_nak;
+
+	/** DCFG: Enable Continue on BNA
+	 * After receiving BNA interrupt the core disables the endpoint,when the
+	 * endpoint is re-enabled by the application the core starts processing
+	 * 0 - from the DOEPDMA descriptor
+	 * 1 - from the descriptor which received the BNA.
+	 */
+	int32_t cont_on_bna;
+
+	/** GAHBCFG: AHB Single Support
+	 * This bit when programmed supports SINGLE transfers for remainder
+	 * data in a transfer for DMA mode of operation.
+	 * 0 - in this case the remainder data will be sent using INCR burst size.
+	 * 1 - in this case the remainder data will be sent using SINGLE burst size.
+	 */
+	int32_t ahb_single;
+
+	/** Core Power down mode
+	 * 0 - No Power Down is enabled
+	 * 1 - Reserved
+	 * 2 - Complete Power Down (Hibernation)
+	 */
+	int32_t power_down;
+
+	/** OTG revision supported
+	 * 0 - OTG 1.3 revision
+	 * 1 - OTG 2.0 revision
+	 */
+	int32_t otg_ver;
+
+} dwc_otg_core_params_t;
+/**
+ * The <code>dwc_otg_core_if</code> structure contains information needed to manage
+ * the DWC_otg controller acting in either host or device mode. It
+ * represents the programming view of the controller as a whole.
+ */
+typedef struct dwc_otg_core_if
+{
+	/** Parameters that define how the core should be configured.*/
+	dwc_otg_core_params_t	   *core_params;
+
+	/** Core Global registers starting at offset 000h. */
+	dwc_otg_core_global_regs_t *core_global_regs;
+
+	/** Device-specific information */
+	dwc_otg_dev_if_t		   *dev_if;
+	/** Host-specific information */
+	dwc_otg_host_if_t		   *host_if;
+
+	/*
+	 * Set to 1 if the core PHY interface bits in USBCFG have been
+	 * initialized.
+	 */
+	uint8_t phy_init_done;
+
+	/*
+	 * SRP Success flag, set by srp success interrupt in FS I2C mode
+	 */
+	uint8_t srp_success;
+	uint8_t srp_timer_started;
+
+	/* Common configuration information */
+	/** Power and Clock Gating Control Register */
+	volatile uint32_t *pcgcctl;
+#define DWC_OTG_PCGCCTL_OFFSET 0xE00
+
+	/** Push/pop addresses for endpoints or host channels.*/
+	uint32_t *data_fifo[MAX_EPS_CHANNELS];
+#define DWC_OTG_DATA_FIFO_OFFSET 0x1000
+#define DWC_OTG_DATA_FIFO_SIZE 0x1000
+
+	/** Total RAM for FIFOs (Bytes) */
+	uint16_t total_fifo_size;
+	/** Size of Rx FIFO (Bytes) */
+	uint16_t rx_fifo_size;
+	/** Size of Non-periodic Tx FIFO (Bytes) */
+	uint16_t nperio_tx_fifo_size;
+
+
+	/** 1 if DMA is enabled, 0 otherwise. */
+	uint8_t dma_enable;
+
+	/** 1 if dedicated Tx FIFOs are enabled, 0 otherwise. */
+	uint8_t en_multiple_tx_fifo;
+
+	/** Set to 1 if multiple packets of a high-bandwidth transfer is in
+	 * process of being queued */
+	uint8_t queuing_high_bandwidth;
+
+	/** Hardware Configuration -- stored here for convenience.*/
+	hwcfg1_data_t hwcfg1;
+	hwcfg2_data_t hwcfg2;
+	hwcfg3_data_t hwcfg3;
+	hwcfg4_data_t hwcfg4;
+
+	/** The operational State, during transations
+	 * (a_host>>a_peripherial and b_device=>b_host) this may not
+	 * match the core but allows the software to determine
+	 * transitions.
+	 */
+	uint8_t op_state;
+
+	/**
+	 * Set to 1 if the HCD needs to be restarted on a session request
+	 * interrupt. This is required if no connector ID status change has
+	 * occurred since the HCD was last disconnected.
+	 */
+	uint8_t restart_hcd_on_session_req;
+
+	/** HCD callbacks */
+	/** A-Device is a_host */
+#define A_HOST		(1)
+	/** A-Device is a_suspend */
+#define A_SUSPEND	(2)
+	/** A-Device is a_peripherial */
+#define A_PERIPHERAL	(3)
+	/** B-Device is operating as a Peripheral. */
+#define B_PERIPHERAL	(4)
+	/** B-Device is operating as a Host. */
+#define B_HOST		(5)
+#define DWC_OTG_MAX_TRANSFER_SIZE  0x10000
+    char *temp_buffer;
+    int transfer_size;
+
+	/* Set VBus Power though GPIO */
+	 void (* set_vbus_power)(char is_power_on);
+
+#if 0
+	/** HCD callbacks */
+	struct dwc_otg_cil_callbacks *hcd_cb;
+	/** PCD callbacks */
+	struct dwc_otg_cil_callbacks *pcd_cb;
+#endif
+	/** Device mode Periodic Tx FIFO Mask */
+	uint32_t p_tx_msk;
+	/** Device mode Periodic Tx FIFO Mask */
+	uint32_t tx_msk;
+
+	uint32_t otg_ver;
+#if 0
+#ifdef DEBUG
+	uint32_t		start_hcchar_val[MAX_EPS_CHANNELS];
+
+	hc_xfer_info_t		hc_xfer_info[MAX_EPS_CHANNELS];
+	struct timer_list	hc_xfer_timer[MAX_EPS_CHANNELS];
+
+	uint32_t		hfnum_7_samples;
+	uint64_t		hfnum_7_frrem_accum;
+	uint32_t		hfnum_0_samples;
+	uint64_t		hfnum_0_frrem_accum;
+	uint32_t		hfnum_other_samples;
+	uint64_t		hfnum_other_frrem_accum;
+#endif
+#endif
+
+} dwc_otg_core_if_t;
+/**
+ * This structure is a wrapper that encapsulates the driver components used to
+ * manage a single DWC_otg controller.
+ */
+typedef struct dwc_otg_device
+{
+	/** Base address returned from ioremap() */
+	void *base;
+
+
+	/** Pointer to the core interface structure. */
+	dwc_otg_core_if_t *core_if;
+
+	/** Register offset for Diagnostic API.*/
+	uint32_t reg_offset;
+
+	/** Pointer to the HCD structure. */
+	struct dwc_otg_hcd *hcd;
+
+	/** Flag to indicate whether the common IRQ handler is installed. */
+	uint8_t common_irq_installed;
+
+  int disabled;
+
+	int index;
+} dwc_otg_device_t;
+/**
+ * Reads the content of a register.
+ *
+ * @param _reg address of register to read.
+ * @return contents of the register.
+ *
+
+ * Usage:<br>
+ * <code>uint32_t dev_ctl = dwc_read_reg32(&dev_regs->dctl);</code>
+ */
+static __inline__ uint32_t dwc_read_reg32( volatile uint32_t *_reg)
+{
+        return readl(_reg);
+};
+
+/**
+ * Writes a register with a 32 bit value.
+ *
+ * @param _reg address of register to read.
+ * @param _value to write to _reg.
+ *
+ * Usage:<br>
+ * <code>dwc_write_reg32(&dev_regs->dctl, 0); </code>
+ */
+static __inline__ void dwc_write_reg32( volatile uint32_t *_reg, const uint32_t _value)
+{
+        writel( _value, _reg );
+};
+static __inline__
+ void dwc_modify_reg32( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+{
+        writel( (readl(_reg) & ~_clear_mask) | _set_mask, _reg );
+};
+/**
+ * This function returns the mode of the operation, host or device.
+ *
+ * @return 0 - Device Mode, 1 - Host Mode
+ */
+static inline uint32_t dwc_otg_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_read_reg32( &_core_if->core_global_regs->gintsts ) & 0x1);
+}
+
+static inline uint8_t dwc_otg_is_device_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_otg_mode(_core_if) != DWC_HOST_MODE);
+}
+static inline uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_otg_mode(_core_if) == DWC_HOST_MODE);
+}
+
+
+/* --- USB HUB constants (not OHCI-specific; see hub.h) -------------------- */
+
+/* destination of request */
+#define RH_INTERFACE               0x01
+#define RH_ENDPOINT                0x02
+#define RH_OTHER                   0x03
+
+#define RH_CLASS                   0x20
+#define RH_VENDOR                  0x40
+
+/* Requests: bRequest << 8 | bmRequestType */
+#define RH_GET_STATUS           0x0080
+#define RH_CLEAR_FEATURE        0x0100
+#define RH_SET_FEATURE          0x0300
+#define RH_SET_ADDRESS          0x0500
+#define RH_GET_DESCRIPTOR       0x0680
+#define RH_SET_DESCRIPTOR       0x0700
+#define RH_GET_CONFIGURATION    0x0880
+#define RH_SET_CONFIGURATION    0x0900
+#define RH_GET_STATE            0x0280
+#define RH_GET_INTERFACE        0x0A80
+#define RH_SET_INTERFACE        0x0B00
+#define RH_SYNC_FRAME           0x0C80
+/* Our Vendor Specific Request */
+#define RH_SET_EP               0x2000
+
+/* Hub port features */
+#define RH_PORT_CONNECTION         0x00
+#define RH_PORT_ENABLE             0x01
+#define RH_PORT_SUSPEND            0x02
+#define RH_PORT_OVER_CURRENT       0x03
+#define RH_PORT_RESET              0x04
+#define RH_PORT_POWER              0x08
+#define RH_PORT_LOW_SPEED          0x09
+
+#define RH_C_PORT_CONNECTION       0x10
+#define RH_C_PORT_ENABLE           0x11
+#define RH_C_PORT_SUSPEND          0x12
+#define RH_C_PORT_OVER_CURRENT     0x13
+#define RH_C_PORT_RESET            0x14
+
+/* Hub features */
+#define RH_C_HUB_LOCAL_POWER       0x00
+#define RH_C_HUB_OVER_CURRENT      0x01
+
+#define RH_DEVICE_REMOTE_WAKEUP    0x00
+#define RH_ENDPOINT_STALL          0x01
+
+#define RH_ACK                     0x01
+#define RH_REQ_ERR                 -1
+#define RH_NACK                    0x00
+
+#endif
+
diff --git a/drivers/usb/host/dwc_otg_regs.h b/drivers/usb/host/dwc_otg_regs.h
new file mode 100644
index 0000000..ab1a352
--- /dev/null
+++ b/drivers/usb/host/dwc_otg_regs.h
@@ -0,0 +1,1920 @@
+
+/*
+ * drivers/usb/host/dwc_otg_regs.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_regs.h $
+ * $Revision: #8 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#ifndef __DWC_OTG_REGS_H__
+#define __DWC_OTG_REGS_H__
+//#define uint32_t u32
+
+#define		RH_A_NDP	(0x1 << 0)	/* # downstream ports */
+#define		RH_A_PSM	(1 << 8)	/* power switching mode */
+#define		RH_A_NPS	(1 << 9)	/* no power switching */
+#define		RH_A_DT		(1 << 10)	/* device type (mbz) */
+#define		RH_A_OCPM	(1 << 11)	/* overcurrent protection
+						   mode */
+#define		RH_A_NOCP	(1 << 12)	/* no overcurrent protection */
+#define		RH_A_POTPGT	(0xff << 24)	/* power on -> power good*/
+
+#define		RH_B_DR		(0xffff << 0)	/* device removable flags */
+
+
+/**
+ * @file
+ *
+ * This file contains the data structures for accessing the DWC_otg core registers.
+ *
+ * The application interfaces with the HS OTG core by reading from and
+ * writing to the Control and Status Register (CSR) space through the
+ * AHB Slave interface. These registers are 32 bits wide, and the
+ * addresses are 32-bit-block aligned.
+ * CSRs are classified as follows:
+ * - Core Global Registers
+ * - Device Mode Registers
+ * - Device Global Registers
+ * - Device Endpoint Specific Registers
+ * - Host Mode Registers
+ * - Host Global Registers
+ * - Host Port CSRs
+ * - Host Channel Specific Registers
+ *
+ * Only the Core Global registers can be accessed in both Device and
+ * Host modes. When the HS OTG core is operating in one mode, either
+ * Device or Host, the application must not access registers from the
+ * other mode. When the core switches from one mode to another, the
+ * registers in the new mode of operation must be reprogrammed as they
+ * would be after a power-on reset.
+ */
+
+/****************************************************************************/
+/** DWC_otg Core registers .
+ * The dwc_otg_core_global_regs structure defines the size
+ * and relative field offsets for the Core Global registers.
+ */
+typedef struct dwc_otg_core_global_regs
+{
+	/** OTG Control and Status Register.  <i>Offset: 000h</i> */
+	volatile uint32_t gotgctl;
+	/** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+	volatile uint32_t gotgint;
+	/**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+	volatile uint32_t gahbcfg;
+
+#define DWC_GLBINTRMASK		0x0001
+#define DWC_DMAENABLE		0x0020
+#define DWC_NPTXEMPTYLVL_EMPTY	0x0080
+#define DWC_NPTXEMPTYLVL_HALFEMPTY	0x0000
+#define DWC_PTXEMPTYLVL_EMPTY	0x0100
+#define DWC_PTXEMPTYLVL_HALFEMPTY	0x0000
+
+	/**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+	volatile uint32_t gusbcfg;
+	/**Core Reset Register.	 <i>Offset: 010h</i> */
+	volatile uint32_t grstctl;
+	/**Core Interrupt Register.	 <i>Offset: 014h</i> */
+	volatile uint32_t gintsts;
+	/**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+	volatile uint32_t gintmsk;
+	/**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+	volatile uint32_t grxstsr;
+	/**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+	volatile uint32_t grxstsp;
+	/**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+	volatile uint32_t grxfsiz;
+	/**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+	volatile uint32_t gnptxfsiz;
+	/**Non Periodic Transmit FIFO/Queue Status Register (Read
+	 * Only). <i>Offset: 02Ch</i> */
+	volatile uint32_t gnptxsts;
+	/**I2C Access Register.	 <i>Offset: 030h</i> */
+	volatile uint32_t gi2cctl;
+	/**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+	volatile uint32_t gpvndctl;
+	/**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+	volatile uint32_t ggpio;
+	/**User ID Register.  <i>Offset: 03Ch</i> */
+	volatile uint32_t guid;
+	/**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+	volatile uint32_t gsnpsid;
+	/**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+	volatile uint32_t ghwcfg1;
+	/**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+	volatile uint32_t ghwcfg2;
+#define DWC_SLAVE_ONLY_ARCH 0
+#define DWC_EXT_DMA_ARCH 1
+#define DWC_INT_DMA_ARCH 2
+
+#define DWC_MODE_HNP_SRP_CAPABLE	0
+#define DWC_MODE_SRP_ONLY_CAPABLE	1
+#define DWC_MODE_NO_HNP_SRP_CAPABLE		2
+#define DWC_MODE_SRP_CAPABLE_DEVICE		3
+#define DWC_MODE_NO_SRP_CAPABLE_DEVICE	4
+#define DWC_MODE_SRP_CAPABLE_HOST	5
+#define DWC_MODE_NO_SRP_CAPABLE_HOST	6
+
+	/**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+	volatile uint32_t ghwcfg3;
+	/**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+	volatile uint32_t ghwcfg4;
+	/** Reserved  <i>Offset: 054h-0FFh</i> */
+	uint32_t reserved[43];
+	/** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+	volatile uint32_t hptxfsiz;
+	/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled,
+		otherwise Device Transmit FIFO#n Register.
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+	volatile uint32_t dptxfsiz_dieptxf[15];
+} dwc_otg_core_global_regs_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Control
+ * and Status Register (GOTGCTL).  Set the bits using the bit
+ * fields then write the <i>d32</i> value to the register.
+ */
+typedef union gotgctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned sesreqscs : 1;
+		unsigned sesreq : 1;
+		unsigned reserved2_7 : 6;
+		unsigned hstnegscs : 1;
+		unsigned hnpreq : 1;
+		unsigned hstsethnpen : 1;
+		unsigned devhnpen : 1;
+		unsigned reserved12_15 : 4;
+		unsigned conidsts : 1;
+		unsigned reserved17 : 1;
+		unsigned asesvld : 1;
+		unsigned bsesvld : 1;
+		unsigned currmod : 1;
+		unsigned reserved21_31 : 11;
+	} b;
+} gotgctl_data_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Interrupt Register
+ * (GOTGINT).  Set/clear the bits using the bit fields then write the <i>d32</i>
+ * value to the register.
+ */
+typedef union gotgint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Current Mode */
+		unsigned reserved0_1 : 2;
+
+		/** Session End Detected */
+		unsigned sesenddet : 1;
+
+		unsigned reserved3_7 : 5;
+
+		/** Session Request Success Status Change */
+		unsigned sesreqsucstschng : 1;
+		/** Host Negotiation Success Status Change */
+		unsigned hstnegsucstschng : 1;
+
+		unsigned reserver10_16 : 7;
+
+		/** Host Negotiation Detected */
+		unsigned hstnegdet : 1;
+		/** A-Device Timeout Change */
+		unsigned adevtoutchng : 1;
+		/** Debounce Done */
+		unsigned debdone : 1;
+
+		unsigned reserved31_20 : 12;
+
+	} b;
+} gotgint_data_t;
+
+
+/**
+ * This union represents the bit fields of the Core AHB Configuration
+ * Register (GAHBCFG).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gahbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned glblintrmsk : 1;
+#define DWC_GAHBCFG_GLBINT_ENABLE		1
+
+		unsigned hburstlen : 4;
+#define DWC_GAHBCFG_INT_DMA_BURST_SINGLE	0
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR		1
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR4		3
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR8		5
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR16	7
+
+		unsigned dmaenable : 1;
+#define DWC_GAHBCFG_DMAENABLE			1
+		unsigned reserved : 1;
+		unsigned nptxfemplvl_txfemplvl : 1;
+		unsigned ptxfemplvl : 1;
+#define DWC_GAHBCFG_TXFEMPTYLVL_EMPTY		1
+#define DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY	0
+		unsigned reserved9_31 : 23;
+	} b;
+} gahbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core USB Configuration
+ * Register (GUSBCFG).	Set the bits using the bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union gusbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned toutcal : 3;
+		unsigned phyif : 1;
+		unsigned ulpi_utmi_sel : 1;
+		unsigned fsintf : 1;
+		unsigned physel : 1;
+		unsigned ddrsel : 1;
+		unsigned srpcap : 1;
+		unsigned hnpcap : 1;
+		unsigned usbtrdtim : 4;
+		unsigned nptxfrwnden : 1;
+		unsigned phylpwrclksel : 1;
+		unsigned otgutmifssel : 1;
+		unsigned ulpi_fsls : 1;
+		unsigned ulpi_auto_res : 1;
+		unsigned ulpi_clk_sus_m : 1;
+		unsigned ulpi_ext_vbus_drv : 1;
+		unsigned ulpi_int_vbus_indicator : 1;
+		unsigned term_sel_dl_pulse : 1;
+		unsigned reserved : 9;
+	} b;
+} gusbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core Reset Register
+ * (GRSTCTL).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union grstctl_data
+{
+	/** raw register data */
+	unsigned int d32;
+	/** register bits */
+	struct
+	{
+		/** Core Soft Reset (CSftRst) (Device and Host)
+		 *
+		 * The application can flush the control logic in the
+		 * entire core using this bit. This bit resets the
+		 * pipelines in the AHB Clock domain as well as the
+		 * PHY Clock domain.
+		 *
+		 * The state machines are reset to an IDLE state, the
+		 * control bits in the CSRs are cleared, all the
+		 * transmit FIFOs and the receive FIFO are flushed.
+		 *
+		 * The status mask bits that control the generation of
+		 * the interrupt, are cleared, to clear the
+		 * interrupt. The interrupt status bits are not
+		 * cleared, so the application can get the status of
+		 * any events that occurred in the core after it has
+		 * set this bit.
+		 *
+		 * Any transactions on the AHB are terminated as soon
+		 * as possible following the protocol. Any
+		 * transactions on the USB are terminated immediately.
+		 *
+		 * The configuration settings in the CSRs are
+		 * unchanged, so the software doesn't have to
+		 * reprogram these registers (Device
+		 * Configuration/Host Configuration/Core System
+		 * Configuration/Core PHY Configuration).
+		 *
+		 * The application can write to this bit, any time it
+		 * wants to reset the core. This is a self clearing
+		 * bit and the core clears this bit after all the
+		 * necessary logic is reset in the core, which may
+		 * take several clocks, depending on the current state
+		 * of the core.
+		 */
+		unsigned csftrst : 1;
+		/** Hclk Soft Reset
+		 *
+		 * The application uses this bit to reset the control logic in
+		 * the AHB clock domain. Only AHB clock domain pipelines are
+		 * reset.
+		 */
+		unsigned hsftrst : 1;
+		/** Host Frame Counter Reset (Host Only)<br>
+		 *
+		 * The application can reset the (micro)frame number
+		 * counter inside the core, using this bit. When the
+		 * (micro)frame counter is reset, the subsequent SOF
+		 * sent out by the core, will have a (micro)frame
+		 * number of 0.
+		 */
+		unsigned hstfrm : 1;
+		/** In Token Sequence Learning Queue Flush
+		 * (INTknQFlsh) (Device Only)
+		 */
+		unsigned intknqflsh : 1;
+		/** RxFIFO Flush (RxFFlsh) (Device and Host)
+		 *
+		 * The application can flush the entire Receive FIFO
+		 * using this bit.	<p>The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is reading from the RxFIFO nor the MAC
+		 * is writing the data in to the FIFO.	<p>The
+		 * application should wait until the bit is cleared
+		 * before performing any other operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned rxfflsh : 1;
+		/** TxFIFO Flush (TxFFlsh) (Device and Host).
+		 *
+		 * This bit is used to selectively flush a single or
+		 * all transmit FIFOs.	The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is writing into the TxFIFO nor the MAC
+		 * is reading the data out of the FIFO.	 <p>The
+		 * application should wait until the core clears this
+		 * bit, before performing any operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned txfflsh : 1;
+
+		/** TxFIFO Number (TxFNum) (Device and Host).
+		 *
+		 * This is the FIFO number which needs to be flushed,
+		 * using the TxFIFO Flush bit. This field should not
+		 * be changed until the TxFIFO Flush bit is cleared by
+		 * the core.
+		 *	 - 0x0 : Non Periodic TxFIFO Flush
+		 *	 - 0x1 : Periodic TxFIFO #1 Flush in device mode
+		 *	   or Periodic TxFIFO in host mode
+		 *	 - 0x2 : Periodic TxFIFO #2 Flush in device mode.
+		 *	 - ...
+		 *	 - 0xF : Periodic TxFIFO #15 Flush in device mode
+		 *	 - 0x10: Flush all the Transmit NonPeriodic and
+		 *	   Transmit Periodic FIFOs in the core
+		 */
+		unsigned txfnum : 5;
+		/** Reserved */
+		unsigned reserved11_29 : 19;
+		/** DMA Request Signal.	 Indicated DMA request is in
+		 * probress.  Used for debug purpose. */
+		unsigned dmareq : 1;
+		/** AHB Master Idle.  Indicates the AHB Master State
+		 * Machine is in IDLE condition. */
+		unsigned ahbidle : 1;
+	} b;
+} grstctl_t;
+
+
+/**
+ * This union represents the bit fields of the Core Interrupt Mask
+ * Register (GINTMSK).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned reserved0 : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned reserved16 : 1;
+		unsigned epmismatch : 1;
+		unsigned inepintr : 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintmsk_data_t;
+/**
+ * This union represents the bit fields of the Core Interrupt Register
+ * (GINTSTS).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union gintsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+#define DWC_SOF_INTR_MASK 0x0008
+	/** register bits */
+	struct
+	{
+#define DWC_HOST_MODE 1
+		unsigned curmode : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned intokenrx : 1;
+		unsigned epmismatch : 1;
+		unsigned inepint: 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union device_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned epnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+#define DWC_STS_DATA_UPDT		0x2				  // OUT Data Packet
+#define DWC_STS_XFER_COMP		0x3				  // OUT Data Transfer Complete
+
+#define DWC_DSTS_GOUT_NAK		0x1				  // Global OUT NAK
+#define DWC_DSTS_SETUP_COMP		0x4				  // Setup Phase Complete
+#define DWC_DSTS_SETUP_UPDT 0x6				  // SETUP Packet
+		unsigned pktsts : 4;
+		unsigned fn : 4;
+		unsigned reserved : 7;
+	} b;
+} device_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union host_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned chnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+		unsigned pktsts : 4;
+#define DWC_GRXSTS_PKTSTS_IN			  0x2
+#define DWC_GRXSTS_PKTSTS_IN_XFER_COMP	  0x3
+#define DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR 0x5
+#define DWC_GRXSTS_PKTSTS_CH_HALTED		  0x7
+
+		unsigned reserved : 11;
+	} b;
+} host_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the FIFO Size Registers (HPTXFSIZ,
+ * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element then
+ * read out the bits using the <i>b</i>it elements.
+ */
+typedef union fifosize_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned startaddr : 16;
+		unsigned depth : 16;
+	} b;
+} fifosize_data_t;
+
+/**
+ * This union represents the bit fields in the Non-Periodic Transmit
+ * FIFO/Queue Status Register (GNPTXSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union gnptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned nptxfspcavail : 16;
+		unsigned nptxqspcavail : 8;
+		/** Top of the Non-Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (Last entry for the selected
+		 *	  channel/EP)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - IN/OUT
+		 *	  - 2'b01 - Zero Length OUT
+		 *	  - 2'b10 - PING/Complete Split
+		 *	  - 2'b11 - Channel Halt
+		 *	- bits 30:27 - Channel/EP Number
+		 */
+		unsigned nptxqtop_terminate : 1;
+		unsigned nptxqtop_token : 2;
+		unsigned nptxqtop_chnep : 4;
+		unsigned reserved : 1;
+	} b;
+} gnptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Transmit
+ * FIFO Status Register (DTXFSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union dtxfsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned txfspcavail : 16;
+		unsigned reserved : 16;
+	} b;
+} dtxfsts_data_t;
+
+/**
+ * This union represents the bit fields in the I2C Control Register
+ * (I2CCTL). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gi2cctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned rwdata : 8;
+		unsigned regaddr : 8;
+		unsigned addr : 7;
+		unsigned i2cen : 1;
+		unsigned ack : 1;
+		unsigned i2csuspctl : 1;
+		unsigned i2cdevaddr : 2;
+		unsigned reserved : 2;
+		unsigned rw : 1;
+		unsigned bsydne : 1;
+	} b;
+} gi2cctl_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config1
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ep_dir0 : 2;
+		unsigned ep_dir1 : 2;
+		unsigned ep_dir2 : 2;
+		unsigned ep_dir3 : 2;
+		unsigned ep_dir4 : 2;
+		unsigned ep_dir5 : 2;
+		unsigned ep_dir6 : 2;
+		unsigned ep_dir7 : 2;
+		unsigned ep_dir8 : 2;
+		unsigned ep_dir9 : 2;
+		unsigned ep_dir10 : 2;
+		unsigned ep_dir11 : 2;
+		unsigned ep_dir12 : 2;
+		unsigned ep_dir13 : 2;
+		unsigned ep_dir14 : 2;
+		unsigned ep_dir15 : 2;
+	} b;
+} hwcfg1_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config2
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg2_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG2 */
+		unsigned op_mode : 3;
+#define DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG 0
+#define DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG 1
+#define DWC_HWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE_OTG 2
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE 3
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE 4
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST 5
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST 6
+
+		unsigned architecture : 2;
+		unsigned point2point : 1;
+		unsigned hs_phy_type : 2;
+#define DWC_HWCFG2_HS_PHY_TYPE_NOT_SUPPORTED 0
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI 1
+#define DWC_HWCFG2_HS_PHY_TYPE_ULPI 2
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI 3
+
+		unsigned fs_phy_type : 2;
+		unsigned num_dev_ep : 4;
+		unsigned num_host_chan : 4;
+		unsigned perio_ep_supported : 1;
+		unsigned dynamic_fifo : 1;
+		unsigned rx_status_q_depth : 2;
+		unsigned nonperio_tx_q_depth : 2;
+		unsigned host_perio_tx_q_depth : 2;
+		unsigned dev_token_q_depth : 5;
+		unsigned reserved31 : 1;
+	} b;
+} hwcfg2_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config3
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg3_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG3 */
+		unsigned xfer_size_cntr_width : 4;
+		unsigned packet_size_cntr_width : 3;
+		unsigned otg_func : 1;
+		unsigned i2c : 1;
+		unsigned vendor_ctrl_if : 1;
+		unsigned optional_features : 1;
+		unsigned synch_reset_type : 1;
+		unsigned ahb_phy_clock_synch : 1;
+		unsigned reserved15_13 : 3;
+		unsigned dfifo_depth : 16;
+	} b;
+} hwcfg3_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config4
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg4_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned num_dev_perio_in_ep : 4;
+		unsigned power_optimiz : 1;
+		unsigned min_ahb_freq : 9;
+		unsigned utmi_phy_data_width : 2;
+		unsigned num_dev_mode_ctrl_ep : 4;
+		unsigned iddig_filt_en : 1;
+		unsigned vbus_valid_filt_en : 1;
+		unsigned a_valid_filt_en : 1;
+		unsigned b_valid_filt_en : 1;
+		unsigned session_end_filt_en : 1;
+		unsigned ded_fifo_en : 1;
+		unsigned num_in_eps : 4;
+		unsigned reserved31_30 : 2;
+	} b;
+} hwcfg4_data_t;
+
+////////////////////////////////////////////
+// Device Registers
+/**
+ * Device Global Registers. <i>Offsets 800h-BFFh</i>
+ *
+ * The following structures define the size and relative field offsets
+ * for the Device Mode Registers.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_global_regs
+{
+	/** Device Configuration Register. <i>Offset 800h</i> */
+	volatile uint32_t dcfg;
+	/** Device Control Register. <i>Offset: 804h</i> */
+	volatile uint32_t dctl;
+	/** Device Status Register (Read Only). <i>Offset: 808h</i> */
+	volatile uint32_t dsts;
+	/** Reserved. <i>Offset: 80Ch</i> */
+	uint32_t unused;
+	/** Device IN Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 810h</i> */
+	volatile uint32_t diepmsk;
+	/** Device OUT Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 814h</i> */
+	volatile uint32_t doepmsk;
+	/** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+	volatile uint32_t daint;
+	/** Device All Endpoints Interrupt Mask Register.  <i>Offset:
+	 * 81Ch</i> */
+	volatile uint32_t daintmsk;
+	/** Device IN Token Queue Read Register-1 (Read Only).
+	 * <i>Offset: 820h</i> */
+	volatile uint32_t dtknqr1;
+	/** Device IN Token Queue Read Register-2 (Read Only).
+	 * <i>Offset: 824h</i> */
+	volatile uint32_t dtknqr2;
+	/** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+	volatile uint32_t dvbusdis;
+	/** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+	volatile uint32_t dvbuspulse;
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */
+	volatile uint32_t dtknqr3_dthrctl;
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */
+	volatile uint32_t dtknqr4_fifoemptymsk;
+} dwc_otg_device_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Device Configuration
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.  Write the
+ * <i>d32</i> member to the dcfg register.
+ */
+typedef union dcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Device Speed */
+		unsigned devspd : 2;
+		/** Non Zero Length Status OUT Handshake */
+		unsigned nzstsouthshk : 1;
+#define DWC_DCFG_SEND_STALL 1
+
+		unsigned reserved3 : 1;
+		/** Device Addresses */
+		unsigned devaddr : 7;
+		/** Periodic Frame Interval */
+		unsigned perfrint : 2;
+#define DWC_DCFG_FRAME_INTERVAL_80 0
+#define DWC_DCFG_FRAME_INTERVAL_85 1
+#define DWC_DCFG_FRAME_INTERVAL_90 2
+#define DWC_DCFG_FRAME_INTERVAL_95 3
+
+		unsigned reserved13_17 : 5;
+		/** In Endpoint Mis-match count */
+		unsigned epmscnt : 4;
+	} b;
+} dcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Device Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Remote Wakeup */
+		unsigned rmtwkupsig : 1;
+		/** Soft Disconnect */
+		unsigned sftdiscon : 1;
+		/** Global Non-Periodic IN NAK Status */
+		unsigned gnpinnaksts : 1;
+		/** Global OUT NAK Status */
+		unsigned goutnaksts : 1;
+		/** Test Control */
+		unsigned tstctl : 3;
+		/** Set Global Non-Periodic IN NAK */
+		unsigned sgnpinnak : 1;
+		/** Clear Global Non-Periodic IN NAK */
+		unsigned cgnpinnak : 1;
+		/** Set Global OUT NAK */
+		unsigned sgoutnak : 1;
+		/** Clear Global OUT NAK */
+		unsigned cgoutnak : 1;
+
+		unsigned reserved : 21;
+	} b;
+} dctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device Status
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Suspend Status */
+		unsigned suspsts : 1;
+		/** Enumerated Speed */
+		unsigned enumspd : 2;
+#define DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ 0
+#define DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ 1
+#define DWC_DSTS_ENUMSPD_LS_PHY_6MHZ		   2
+#define DWC_DSTS_ENUMSPD_FS_PHY_48MHZ		   3
+		/** Erratic Error */
+		unsigned errticerr : 1;
+		unsigned reserved4_7: 4;
+		/** Frame or Microframe Number of the received SOF */
+		unsigned soffn : 14;
+		unsigned reserved22_31 : 10;
+	} b;
+} dsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device IN EP Interrupt
+ * Register and the Device IN EP Common Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union diepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete mask */
+		unsigned xfercompl : 1;
+		/** Endpoint disable mask */
+		unsigned epdisabled : 1;
+		/** AHB Error mask */
+		unsigned ahberr : 1;
+		/** TimeOUT Handshake mask (non-ISOC EPs) */
+		unsigned timeout : 1;
+		/** IN Token received with TxF Empty mask */
+		unsigned intktxfemp : 1;
+		/** IN Token Received with EP mismatch mask */
+		unsigned intknepmis : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned inepnakeff : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned emptyintr : 1;
+
+		unsigned txfifoundrn : 1;
+
+		unsigned reserved08_31 : 23;
+		} b;
+} diepint_data_t;
+/**
+ * This union represents the bit fields in the Device IN EP Common
+ * Interrupt Mask Register.
+ */
+typedef union diepint_data diepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP Interrupt
+ * Registerand Device OUT EP Common Interrupt Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union doepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete */
+		unsigned xfercompl : 1;
+		/** Endpoint disable  */
+		unsigned epdisabled : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** Setup Phase Done (contorl EPs) */
+		unsigned setup : 1;
+		unsigned reserved04_31 : 28;
+	} b;
+} doepint_data_t;
+/**
+ * This union represents the bit fields in the Device OUT EP Common
+ * Interrupt Mask Register.
+ */
+typedef union doepint_data doepmsk_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device All EP Interrupt
+ * and Mask Registers.
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union daint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned in : 16;
+		/** OUT Endpoint bits */
+		unsigned out : 16;
+	} ep;
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned inep0	: 1;
+		unsigned inep1	: 1;
+		unsigned inep2	: 1;
+		unsigned inep3	: 1;
+		unsigned inep4	: 1;
+		unsigned inep5	: 1;
+		unsigned inep6	: 1;
+		unsigned inep7	: 1;
+		unsigned inep8	: 1;
+		unsigned inep9	: 1;
+		unsigned inep10 : 1;
+		unsigned inep11 : 1;
+		unsigned inep12 : 1;
+		unsigned inep13 : 1;
+		unsigned inep14 : 1;
+		unsigned inep15 : 1;
+		/** OUT Endpoint bits */
+		unsigned outep0	 : 1;
+		unsigned outep1	 : 1;
+		unsigned outep2	 : 1;
+		unsigned outep3	 : 1;
+		unsigned outep4	 : 1;
+		unsigned outep5	 : 1;
+		unsigned outep6	 : 1;
+		unsigned outep7	 : 1;
+		unsigned outep8	 : 1;
+		unsigned outep9	 : 1;
+		unsigned outep10 : 1;
+		unsigned outep11 : 1;
+		unsigned outep12 : 1;
+		unsigned outep13 : 1;
+		unsigned outep14 : 1;
+		unsigned outep15 : 1;
+	} b;
+} daint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN Token Queue
+ * Read Registers.
+ * - Read the register into the <i>d32</i> member.
+ * - READ-ONLY Register
+ */
+typedef union dtknq1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** In Token Queue Write Pointer */
+		unsigned intknwptr : 5;
+		/** Reserved */
+		unsigned reserved05_06 : 2;
+		/** write pointer has wrapped. */
+		unsigned wrap_bit : 1;
+		/** EP Numbers of IN Tokens 0 ... 4 */
+		unsigned epnums0_5 : 24;
+	}b;
+} dtknq1_data_t;
+
+/**
+ * This union represents Threshold control Register
+ * - Read and write the register into the <i>d32</i> member.
+ * - READ-WRITABLE Register
+ */
+typedef union dthrctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** non ISO Tx Thr. Enable */
+		unsigned non_iso_thr_en : 1;
+		/** ISO Tx Thr. Enable */
+		unsigned iso_thr_en : 1;
+		/** Tx Thr. Length */
+		unsigned tx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved11_15 : 5;
+		/** Rx Thr. Enable */
+		unsigned rx_thr_en : 1;
+		/** Rx Thr. Length */
+		unsigned rx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved26_31 : 6;
+	}b;
+} dthrctl_data_t;
+
+
+/**
+ * Device Logical IN Endpoint-Specific Registers. <i>Offsets
+ * 900h-AFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_in_ep_regs
+{
+	/** Device IN Endpoint Control Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t diepctl;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 04h</i> */
+	uint32_t reserved04;
+	/** Device IN Endpoint Interrupt Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t diepint;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device IN Endpoint Transfer Size
+	 * Register. <i>Offset:900h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t dieptsiz;
+	/** Device IN Endpoint DMA Address Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 14h</i> */
+	volatile uint32_t diepdma;
+	/** Device IN Endpoint Transmit FIFO Status Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 18h</i> */
+	volatile uint32_t dtxfsts;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 1Ch - 900h +
+	 * (ep_num * 20h) + 1Ch</i>*/
+	uint32_t reserved18;
+} dwc_otg_dev_in_ep_regs_t;
+
+/**
+ * Device Logical OUT Endpoint-Specific Registers. <i>Offsets:
+ * B00h-CFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_out_ep_regs
+{
+	/** Device OUT Endpoint Control Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t doepctl;
+	/** Device OUT Endpoint Frame number Register.	<i>Offset:
+	 * B00h + (ep_num * 20h) + 04h</i> */
+	volatile uint32_t doepfn;
+	/** Device OUT Endpoint Interrupt Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t doepint;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device OUT Endpoint Transfer Size Register. <i>Offset:
+	 * B00h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t doeptsiz;
+	/** Device OUT Endpoint DMA Address Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 14h</i> */
+	volatile uint32_t doepdma;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 18h - B00h +
+	 * (ep_num * 20h) + 1Ch</i> */
+	uint32_t unused[2];
+} dwc_otg_dev_out_ep_regs_t;
+
+/**
+ * This union represents the bit fields in the Device EP Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union depctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Maximum Packet Size
+		 * IN/OUT EPn
+		 * IN/OUT EP0 - 2 bits
+		 *	 2'b00: 64 Bytes
+		 *	 2'b01: 32
+		 *	 2'b10: 16
+		 *	 2'b11: 8 */
+		unsigned mps : 11;
+#define DWC_DEP0CTL_MPS_64	 0
+#define DWC_DEP0CTL_MPS_32	 1
+#define DWC_DEP0CTL_MPS_16	 2
+#define DWC_DEP0CTL_MPS_8	 3
+
+		/** Next Endpoint
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned nextep : 4;
+
+		/** USB Active Endpoint */
+		unsigned usbactep : 1;
+
+		/** Endpoint DPID (INTR/Bulk IN and OUT endpoints)
+		 * This field contains the PID of the packet going to
+		 * be received or transmitted on this endpoint. The
+		 * application should program the PID of the first
+		 * packet going to be received or transmitted on this
+		 * endpoint , after the endpoint is
+		 * activated. Application use the SetD1PID and
+		 * SetD0PID fields of this register to program either
+		 * D0 or D1 PID.
+		 *
+		 * The encoding for this field is
+		 *	 - 0: D0
+		 *	 - 1: D1
+		 */
+		unsigned dpid : 1;
+
+		/** NAK Status */
+		unsigned naksts : 1;
+
+		/** Endpoint Type
+		 *	2'b00: Control
+		 *	2'b01: Isochronous
+		 *	2'b10: Bulk
+		 *	2'b11: Interrupt */
+		unsigned eptype : 2;
+
+		/** Snoop Mode
+		 * OUT EPn/OUT EP0
+		 * IN EPn/IN EP0 - reserved */
+		unsigned snp : 1;
+
+		/** Stall Handshake */
+		unsigned stall : 1;
+
+		/** Tx Fifo Number
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned txfnum : 4;
+
+		/** Clear NAK */
+		unsigned cnak : 1;
+		/** Set NAK */
+		unsigned snak : 1;
+		/** Set DATA0 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA0. Set Even
+		 * (micro)frame (SetEvenFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to even (micro)
+		 * frame.
+		 */
+		unsigned setd0pid : 1;
+		/** Set DATA1 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA1 Set Odd
+		 * (micro)frame (SetOddFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to odd (micro) frame.
+		 */
+		unsigned setd1pid : 1;
+
+		/** Endpoint Disable */
+		unsigned epdis : 1;
+		/** Endpoint Enable */
+		unsigned epena : 1;
+		} b;
+} depctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 19;
+		/** Packet Count */
+		unsigned pktcnt : 10;
+		/** Multi Count - Periodic IN endpoints */
+		unsigned mc : 2;
+		unsigned reserved : 1;
+		} b;
+} deptsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP 0 Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz0_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 7;
+				/** Reserved */
+				unsigned reserved7_18 : 12;
+		/** Packet Count */
+		unsigned pktcnt : 1;
+				/** Reserved */
+		unsigned reserved20_28 : 9;
+				/**Setup Packet Count (DOEPTSIZ0 Only) */
+				unsigned supcnt : 2;
+				unsigned reserved31;
+		} b;
+} deptsiz0_data_t;
+
+
+/** Maximum number of Periodic FIFOs */
+#define MAX_PERIO_FIFOS 15
+/** Maximum number of Periodic FIFOs */
+#define MAX_TX_FIFOS 15
+
+/** Maximum number of Endpoints/HostChannels */
+#define MAX_EPS_CHANNELS 16
+
+/**
+ * The dwc_otg_dev_if structure contains information needed to manage
+ * the DWC_otg controller acting in device mode. It represents the
+ * programming view of the device-specific aspects of the controller.
+ */
+typedef struct dwc_otg_dev_if
+{
+	/** Pointer to device Global registers.
+	 * Device Global Registers starting at offset 800h
+	 */
+	dwc_otg_device_global_regs_t *dev_global_regs;
+#define DWC_DEV_GLOBAL_REG_OFFSET 0x800
+
+	/**
+	 * Device Logical IN Endpoint-Specific Registers 900h-AFCh
+	 */
+	dwc_otg_dev_in_ep_regs_t	 *in_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_IN_EP_REG_OFFSET 0x900
+#define DWC_EP_REG_OFFSET 0x20
+
+	/** Device Logical OUT Endpoint-Specific Registers B00h-CFCh */
+	dwc_otg_dev_out_ep_regs_t	 *out_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_OUT_EP_REG_OFFSET 0xB00
+
+	/* Device configuration information*/
+	uint8_t	 speed;				 /**< Device Speed	0: Unknown, 1: LS, 2:FS, 3: HS */
+	uint8_t	 num_in_eps;		 /**< Number # of Tx EP range: 0-15 exept ep0 */
+	uint8_t	 num_out_eps;		 /**< Number # of Rx EP range: 0-15 exept ep 0*/
+
+	/** Size of periodic FIFOs (Bytes) */
+	uint16_t perio_tx_fifo_size[MAX_PERIO_FIFOS];
+
+	/** Size of Tx FIFOs (Bytes) */
+	uint16_t tx_fifo_size[MAX_TX_FIFOS];
+
+	/** Thresholding enable flags and length varaiables **/
+	uint16_t rx_thr_en;
+	uint16_t iso_tx_thr_en;
+	uint16_t non_iso_tx_thr_en;
+
+	uint16_t rx_thr_length;
+	uint16_t tx_thr_length;
+
+} dwc_otg_dev_if_t;
+
+
+
+
+/////////////////////////////////////////////////
+// Host Mode Register Structures
+//
+/**
+ * The Host Global Registers structure defines the size and relative
+ * field offsets for the Host Mode Global Registers.  Host Global
+ * Registers offsets 400h-7FFh.
+*/
+typedef struct dwc_otg_host_global_regs
+{
+	/** Host Configuration Register.   <i>Offset: 400h</i> */
+	volatile uint32_t hcfg;
+	/** Host Frame Interval Register.	<i>Offset: 404h</i> */
+	volatile uint32_t hfir;
+	/** Host Frame Number / Frame Remaining Register. <i>Offset: 408h</i> */
+	volatile uint32_t hfnum;
+	/** Reserved.	<i>Offset: 40Ch</i> */
+	uint32_t reserved40C;
+	/** Host Periodic Transmit FIFO/ Queue Status Register. <i>Offset: 410h</i> */
+	volatile uint32_t hptxsts;
+	/** Host All Channels Interrupt Register. <i>Offset: 414h</i> */
+	volatile uint32_t haint;
+	/** Host All Channels Interrupt Mask Register. <i>Offset: 418h</i> */
+	volatile uint32_t haintmsk;
+} dwc_otg_host_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Configuration Register.
+ * Read the register into the <i>d32</i> member then set/clear the bits using
+ * the <i>b</i>it elements. Write the <i>d32</i> member to the hcfg register.
+ */
+typedef union hcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** FS/LS Phy Clock Select */
+		unsigned fslspclksel : 2;
+#define DWC_HCFG_30_60_MHZ 0
+#define DWC_HCFG_48_MHZ	   1
+#define DWC_HCFG_6_MHZ	   2
+
+		/** FS/LS Only Support */
+		unsigned fslssupp : 1;
+		} b;
+} hcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfir_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frint : 16;
+		unsigned reserved : 16;
+	} b;
+} hfir_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfnum_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frnum : 16;
+#define DWC_HFNUM_MAX_FRNUM 0x3FFF
+		unsigned frrem : 16;
+	} b;
+} hfnum_data_t;
+
+typedef union hptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned ptxfspcavail : 16;
+		unsigned ptxqspcavail : 8;
+		/** Top of the Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (last entry for the selected channel)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - Zero length
+		 *	  - 2'b01 - Ping
+		 *	  - 2'b10 - Disable
+		 *	- bits 30:27 - Channel Number
+		 *	- bit 31 - Odd/even microframe
+		 */
+		unsigned ptxqtop_terminate : 1;
+		unsigned ptxqtop_token : 2;
+		unsigned ptxqtop_chnum : 4;
+		unsigned ptxqtop_odd : 1;
+	} b;
+} hptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Port Control and Status
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hprt0 register.
+ */
+typedef union hprt0_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned prtconnsts : 1;
+		unsigned prtconndet : 1;
+		unsigned prtena : 1;
+		unsigned prtenchng : 1;
+		unsigned prtovrcurract : 1;
+		unsigned prtovrcurrchng : 1;
+		unsigned prtres : 1;
+		unsigned prtsusp : 1;
+		unsigned prtrst : 1;
+		unsigned reserved9 : 1;
+		unsigned prtlnsts : 2;
+		unsigned prtpwr : 1;
+		unsigned prttstctl : 4;
+		unsigned prtspd : 2;
+#define DWC_HPRT0_PRTSPD_HIGH_SPEED 0
+#define DWC_HPRT0_PRTSPD_FULL_SPEED 1
+#define DWC_HPRT0_PRTSPD_LOW_SPEED	2
+		unsigned reserved19_31 : 13;
+	} b;
+} hprt0_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haint_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haintmsk_data_t;
+
+/**
+ * Host Channel Specific Registers. <i>500h-5FCh</i>
+ */
+typedef struct dwc_otg_hc_regs
+{
+	/** Host Channel 0 Characteristic Register. <i>Offset: 500h + (chan_num * 20h) + 00h</i> */
+	volatile uint32_t hcchar;
+	/** Host Channel 0 Split Control Register. <i>Offset: 500h + (chan_num * 20h) + 04h</i> */
+	volatile uint32_t hcsplt;
+	/** Host Channel 0 Interrupt Register. <i>Offset: 500h + (chan_num * 20h) + 08h</i> */
+	volatile uint32_t hcint;
+	/** Host Channel 0 Interrupt Mask Register. <i>Offset: 500h + (chan_num * 20h) + 0Ch</i> */
+	volatile uint32_t hcintmsk;
+	/** Host Channel 0 Transfer Size Register. <i>Offset: 500h + (chan_num * 20h) + 10h</i> */
+	volatile uint32_t hctsiz;
+	/** Host Channel 0 DMA Address Register. <i>Offset: 500h + (chan_num * 20h) + 14h</i> */
+	volatile uint32_t hcdma;
+	/** Reserved.  <i>Offset: 500h + (chan_num * 20h) + 18h - 500h + (chan_num * 20h) + 1Ch</i> */
+	uint32_t reserved[2];
+} dwc_otg_hc_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Characteristics
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hcchar_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Maximum packet size in bytes */
+		unsigned mps : 11;
+
+		/** Endpoint number */
+		unsigned epnum : 4;
+
+		/** 0: OUT, 1: IN */
+		unsigned epdir : 1;
+
+		unsigned reserved : 1;
+
+		/** 0: Full/high speed device, 1: Low speed device */
+		unsigned lspddev : 1;
+
+		/** 0: Control, 1: Isoc, 2: Bulk, 3: Intr */
+		unsigned eptype : 2;
+
+		/** Packets per frame for periodic transfers. 0 is reserved. */
+		unsigned multicnt : 2;
+
+		/** Device address */
+		unsigned devaddr : 7;
+
+		/**
+		 * Frame to transmit periodic transaction.
+		 * 0: even, 1: odd
+		 */
+		unsigned oddfrm : 1;
+
+		/** Channel disable */
+		unsigned chdis : 1;
+
+		/** Channel enable */
+		unsigned chen : 1;
+	} b;
+} hcchar_data_t;
+
+typedef union hcsplt_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Port Address */
+		unsigned prtaddr : 7;
+
+		/** Hub Address */
+		unsigned hubaddr : 7;
+
+		/** Transaction Position */
+		unsigned xactpos : 2;
+#define DWC_HCSPLIT_XACTPOS_MID 0
+#define DWC_HCSPLIT_XACTPOS_END 1
+#define DWC_HCSPLIT_XACTPOS_BEGIN 2
+#define DWC_HCSPLIT_XACTPOS_ALL 3
+
+		/** Do Complete Split */
+		unsigned compsplt : 1;
+
+		/** Reserved */
+		unsigned reserved : 14;
+
+		/** Split Enble */
+		unsigned spltena : 1;
+	} b;
+} hcsplt_data_t;
+
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union hcint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer Complete */
+		unsigned xfercomp : 1;
+		/** Channel Halted */
+		unsigned chhltd : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** STALL Response Received */
+		unsigned stall : 1;
+		/** NAK Response Received */
+		unsigned nak : 1;
+		/** ACK Response Received */
+		unsigned ack : 1;
+		/** NYET Response Received */
+		unsigned nyet : 1;
+		/** Transaction Err */
+		unsigned xacterr : 1;
+		/** Babble Error */
+		unsigned bblerr : 1;
+		/** Frame Overrun */
+		unsigned frmovrun : 1;
+		/** Data Toggle Error */
+		unsigned datatglerr : 1;
+		/** Reserved */
+		unsigned reserved : 21;
+	} b;
+} hcint_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Transfer Size
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hctsiz_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Total transfer size in bytes */
+		unsigned xfersize : 19;
+
+		/** Data packets to transfer */
+		unsigned pktcnt : 10;
+
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control), SETUP (Control)
+		 */
+		unsigned pid : 2;
+#define DWC_HCTSIZ_DATA0 0
+#define DWC_HCTSIZ_DATA1 2
+#define DWC_HCTSIZ_DATA2 1
+#define DWC_HCTSIZ_MDATA 3
+#define DWC_HCTSIZ_SETUP 3
+
+		/** Do PING protocol when 1 */
+		unsigned dopng : 1;
+	} b;
+} hctsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Interrupt Mask
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcintmsk register.
+ */
+typedef union hcintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned xfercompl : 1;
+		unsigned chhltd : 1;
+		unsigned ahberr : 1;
+		unsigned stall : 1;
+		unsigned nak : 1;
+		unsigned ack : 1;
+		unsigned nyet : 1;
+		unsigned xacterr : 1;
+		unsigned bblerr : 1;
+		unsigned frmovrun : 1;
+		unsigned datatglerr : 1;
+		unsigned reserved : 21;
+	} b;
+} hcintmsk_data_t;
+
+/** OTG Host Interface Structure.
+ *
+ * The OTG Host Interface Structure structure contains information
+ * needed to manage the DWC_otg controller acting in host mode. It
+ * represents the programming view of the host-specific aspects of the
+ * controller.
+ */
+typedef struct dwc_otg_host_if
+{
+	/** Host Global Registers starting at offset 400h.*/
+	dwc_otg_host_global_regs_t *host_global_regs;
+#define DWC_OTG_HOST_GLOBAL_REG_OFFSET 0x400
+
+	/** Host Port 0 Control and Status Register */
+	volatile uint32_t *hprt0;
+#define DWC_OTG_HOST_PORT_REGS_OFFSET 0x440
+
+
+	/** Host Channel Specific Registers at offsets 500h-5FCh. */
+	dwc_otg_hc_regs_t *hc_regs[MAX_EPS_CHANNELS];
+#define DWC_OTG_HOST_CHAN_REGS_OFFSET 0x500
+#define DWC_OTG_CHAN_REGS_OFFSET 0x20
+
+
+	/* Host configuration information */
+	/** Number of Host Channels (range: 1-16) */
+	uint8_t	 num_host_channels;
+	/** Periodic EPs supported (0: no, 1: yes) */
+	uint8_t	 perio_eps_supported;
+	/** Periodic Tx FIFO Size (Only 1 host periodic Tx FIFO) */
+	uint16_t perio_tx_fifo_size;
+
+	uint8_t	do_ping;
+
+} dwc_otg_host_if_t;
+
+
+/**
+ * This union represents the bit fields in the Power and Clock Gating Control
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union pcgcctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Stop Pclk */
+		unsigned stoppclk : 1;
+		/** Gate Hclk */
+		unsigned gatehclk : 1;
+		/** Power Clamp */
+		unsigned pwrclmp : 1;
+		/** Reset Power Down Modules */
+		unsigned rstpdwnmodule : 1;
+		/** PHY Suspended */
+		unsigned physuspended : 1;
+
+		unsigned reserved : 27;
+	} b;
+} pcgcctl_data_t;
+
+#define DWC_OTG_EP_TYPE_CONTROL    0
+#define DWC_OTG_EP_TYPE_ISOC       1
+#define DWC_OTG_EP_TYPE_BULK       2
+#define DWC_OTG_EP_TYPE_INTR       3
+
+#endif
diff --git a/drivers/usb/host/dwc_otg_regs_294.h b/drivers/usb/host/dwc_otg_regs_294.h
new file mode 100644
index 0000000..8bfe9d6
--- /dev/null
+++ b/drivers/usb/host/dwc_otg_regs_294.h
@@ -0,0 +1,2581 @@
+
+/*
+ * drivers/usb/host/dwc_otg_regs_294.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg/linux/drivers/dwc_otg_regs.h $
+ * $Revision: #97 $
+ * $Date: 2011/10/24 $
+ * $Change: 1871160 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#ifndef __DWC_OTG_REGS_294_H__
+#define __DWC_OTG_REGS_294_H__
+
+/** Maximum number of Periodic FIFOs */
+#define MAX_PERIO_FIFOS 15
+/** Maximum number of Periodic FIFOs */
+#define MAX_TX_FIFOS 15
+
+/** Maximum number of Endpoints/HostChannels */
+#define MAX_EPS_CHANNELS 16
+//#include "dwc_otg_core_if.h"
+
+/**
+ * @file
+ *
+ * This file contains the data structures for accessing the DWC_otg core registers.
+ *
+ * The application interfaces with the HS OTG core by reading from and
+ * writing to the Control and Status Register (CSR) space through the
+ * AHB Slave interface. These registers are 32 bits wide, and the
+ * addresses are 32-bit-block aligned.
+ * CSRs are classified as follows:
+ * - Core Global Registers
+ * - Device Mode Registers
+ * - Device Global Registers
+ * - Device Endpoint Specific Registers
+ * - Host Mode Registers
+ * - Host Global Registers
+ * - Host Port CSRs
+ * - Host Channel Specific Registers
+ *
+ * Only the Core Global registers can be accessed in both Device and
+ * Host modes. When the HS OTG core is operating in one mode, either
+ * Device or Host, the application must not access registers from the
+ * other mode. When the core switches from one mode to another, the
+ * registers in the new mode of operation must be reprogrammed as they
+ * would be after a power-on reset.
+ */
+
+/****************************************************************************/
+/** DWC_otg Core registers .
+ * The dwc_otg_core_global_regs structure defines the size
+ * and relative field offsets for the Core Global registers.
+ */
+typedef struct dwc_otg_core_global_regs {
+	/** OTG Control and Status Register.  <i>Offset: 000h</i> */
+	volatile uint32_t gotgctl;
+	/** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+	volatile uint32_t gotgint;
+	/**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+	volatile uint32_t gahbcfg;
+
+#define DWC_GLBINTRMASK		0x0001
+#define DWC_DMAENABLE		0x0020
+#define DWC_NPTXEMPTYLVL_EMPTY	0x0080
+#define DWC_NPTXEMPTYLVL_HALFEMPTY	0x0000
+#define DWC_PTXEMPTYLVL_EMPTY	0x0100
+#define DWC_PTXEMPTYLVL_HALFEMPTY	0x0000
+
+	/**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+	volatile uint32_t gusbcfg;
+	/**Core Reset Register.	 <i>Offset: 010h</i> */
+	volatile uint32_t grstctl;
+	/**Core Interrupt Register.	 <i>Offset: 014h</i> */
+	volatile uint32_t gintsts;
+	/**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+	volatile uint32_t gintmsk;
+	/**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+	volatile uint32_t grxstsr;
+	/**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+	volatile uint32_t grxstsp;
+	/**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+	volatile uint32_t grxfsiz;
+	/**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+	volatile uint32_t gnptxfsiz;
+	/**Non Periodic Transmit FIFO/Queue Status Register (Read
+	 * Only). <i>Offset: 02Ch</i> */
+	volatile uint32_t gnptxsts;
+	/**I2C Access Register.	 <i>Offset: 030h</i> */
+	volatile uint32_t gi2cctl;
+	/**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+	volatile uint32_t gpvndctl;
+	/**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+	volatile uint32_t ggpio;
+	/**User ID Register.  <i>Offset: 03Ch</i> */
+	volatile uint32_t guid;
+	/**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+	volatile uint32_t gsnpsid;
+	/**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+	volatile uint32_t ghwcfg1;
+	/**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+	volatile uint32_t ghwcfg2;
+#define DWC_SLAVE_ONLY_ARCH 0
+#define DWC_EXT_DMA_ARCH 1
+#define DWC_INT_DMA_ARCH 2
+
+#define DWC_MODE_HNP_SRP_CAPABLE	0
+#define DWC_MODE_SRP_ONLY_CAPABLE	1
+#define DWC_MODE_NO_HNP_SRP_CAPABLE		2
+#define DWC_MODE_SRP_CAPABLE_DEVICE		3
+#define DWC_MODE_NO_SRP_CAPABLE_DEVICE	4
+#define DWC_MODE_SRP_CAPABLE_HOST	5
+#define DWC_MODE_NO_SRP_CAPABLE_HOST	6
+
+	/**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+	volatile uint32_t ghwcfg3;
+	/**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+	volatile uint32_t ghwcfg4;
+	/** Core LPM Configuration register <i>Offset: 054h</i>*/
+	volatile uint32_t glpmcfg;
+	/** Global PowerDn Register <i>Offset: 058h</i> */
+	volatile uint32_t gpwrdn;
+	/** Global DFIFO SW Config Register  <i>Offset: 05Ch</i> */
+	volatile uint32_t gdfifocfg;
+	/** ADP Control Register  <i>Offset: 060h</i> */
+	volatile uint32_t adpctl;
+	/** Reserved  <i>Offset: 064h-0FFh</i> */
+	volatile uint32_t reserved39[39];
+	/** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+	volatile uint32_t hptxfsiz;
+	/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled,
+		otherwise Device Transmit FIFO#n Register.
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+	volatile uint32_t dtxfsiz[15];
+} dwc_otg_core_global_regs_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Control
+ * and Status Register (GOTGCTL).  Set the bits using the bit
+ * fields then write the <i>d32</i> value to the register.
+ */
+typedef union gotgctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned sesreqscs:1;
+		unsigned sesreq:1;
+		unsigned vbvalidoven:1;
+		unsigned vbvalidovval:1;
+		unsigned avalidoven:1;
+		unsigned avalidovval:1;
+		unsigned bvalidoven:1;
+		unsigned bvalidovval:1;
+		unsigned hstnegscs:1;
+		unsigned hnpreq:1;
+		unsigned hstsethnpen:1;
+		unsigned devhnpen:1;
+		unsigned reserved12_15:4;
+		unsigned conidsts:1;
+		unsigned dbnctime:1;
+		unsigned asesvld:1;
+		unsigned bsesvld:1;
+		unsigned otgver:1;
+		unsigned reserved1:1;
+		unsigned multvalidbc:5;
+		unsigned chirpen:1;
+		unsigned reserved28_31:4;
+	} b;
+} gotgctl_data_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Interrupt Register
+ * (GOTGINT).  Set/clear the bits using the bit fields then write the <i>d32</i>
+ * value to the register.
+ */
+typedef union gotgint_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Current Mode */
+		unsigned reserved0_1:2;
+
+		/** Session End Detected */
+		unsigned sesenddet:1;
+
+		unsigned reserved3_7:5;
+
+		/** Session Request Success Status Change */
+		unsigned sesreqsucstschng:1;
+		/** Host Negotiation Success Status Change */
+		unsigned hstnegsucstschng:1;
+
+		unsigned reserved10_16:7;
+
+		/** Host Negotiation Detected */
+		unsigned hstnegdet:1;
+		/** A-Device Timeout Change */
+		unsigned adevtoutchng:1;
+		/** Debounce Done */
+		unsigned debdone:1;
+		/** Multi-Valued input changed */
+		unsigned mvic:1;
+
+		unsigned reserved31_21:11;
+
+	} b;
+} gotgint_data_t;
+
+/**
+ * This union represents the bit fields of the Core AHB Configuration
+ * Register (GAHBCFG). Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gahbcfg_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned glblintrmsk:1;
+#define DWC_GAHBCFG_GLBINT_ENABLE		1
+
+		unsigned hburstlen:4;
+#define DWC_GAHBCFG_INT_DMA_BURST_SINGLE	0
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR		1
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR4		3
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR8		5
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR16	7
+
+		unsigned dmaenable:1;
+#define DWC_GAHBCFG_DMAENABLE			1
+		unsigned reserved:1;
+		unsigned nptxfemplvl_txfemplvl:1;
+		unsigned ptxfemplvl:1;
+#define DWC_GAHBCFG_TXFEMPTYLVL_EMPTY		1
+#define DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY	0
+		unsigned reserved9_20:12;
+		unsigned remmemsupp:1;
+		unsigned notialldmawrit:1;
+		unsigned ahbsingle:1;
+		unsigned reserved24_31:8;
+	} b;
+} gahbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core USB Configuration
+ * Register (GUSBCFG). Set the bits using the bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union gusbcfg_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned toutcal:3;
+		unsigned phyif:1;
+		unsigned ulpi_utmi_sel:1;
+		unsigned fsintf:1;
+		unsigned physel:1;
+		unsigned ddrsel:1;
+		unsigned srpcap:1;
+		unsigned hnpcap:1;
+		unsigned usbtrdtim:4;
+		unsigned reserved1:1;
+		unsigned phylpwrclksel:1;
+		unsigned otgutmifssel:1;
+		unsigned ulpi_fsls:1;
+		unsigned ulpi_auto_res:1;
+		unsigned ulpi_clk_sus_m:1;
+		unsigned ulpi_ext_vbus_drv:1;
+		unsigned ulpi_int_vbus_indicator:1;
+		unsigned term_sel_dl_pulse:1;
+		unsigned indicator_complement:1;
+		unsigned indicator_pass_through:1;
+		unsigned ulpi_int_prot_dis:1;
+		unsigned ic_usb_cap:1;
+		unsigned ic_traffic_pull_remove:1;
+		unsigned tx_end_delay:1;
+		unsigned force_host_mode:1;
+		unsigned force_dev_mode:1;
+		unsigned reserved31:1;
+	} b;
+} gusbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core Reset Register
+ * (GRSTCTL).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union grstctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Core Soft Reset (CSftRst) (Device and Host)
+		 *
+		 * The application can flush the control logic in the
+		 * entire core using this bit. This bit resets the
+		 * pipelines in the AHB Clock domain as well as the
+		 * PHY Clock domain.
+		 *
+		 * The state machines are reset to an IDLE state, the
+		 * control bits in the CSRs are cleared, all the
+		 * transmit FIFOs and the receive FIFO are flushed.
+		 *
+		 * The status mask bits that control the generation of
+		 * the interrupt, are cleared, to clear the
+		 * interrupt. The interrupt status bits are not
+		 * cleared, so the application can get the status of
+		 * any events that occurred in the core after it has
+		 * set this bit.
+		 *
+		 * Any transactions on the AHB are terminated as soon
+		 * as possible following the protocol. Any
+		 * transactions on the USB are terminated immediately.
+		 *
+		 * The configuration settings in the CSRs are
+		 * unchanged, so the software doesn't have to
+		 * reprogram these registers (Device
+		 * Configuration/Host Configuration/Core System
+		 * Configuration/Core PHY Configuration).
+		 *
+		 * The application can write to this bit, any time it
+		 * wants to reset the core. This is a self clearing
+		 * bit and the core clears this bit after all the
+		 * necessary logic is reset in the core, which may
+		 * take several clocks, depending on the current state
+		 * of the core.
+		 */
+		unsigned csftrst:1;
+		/** Hclk Soft Reset
+		 *
+		 * The application uses this bit to reset the control logic in
+		 * the AHB clock domain. Only AHB clock domain pipelines are
+		 * reset.
+		 */
+		unsigned hsftrst:1;
+		/** Host Frame Counter Reset (Host Only)<br>
+		 *
+		 * The application can reset the (micro)frame number
+		 * counter inside the core, using this bit. When the
+		 * (micro)frame counter is reset, the subsequent SOF
+		 * sent out by the core, will have a (micro)frame
+		 * number of 0.
+		 */
+		unsigned hstfrm:1;
+		/** In Token Sequence Learning Queue Flush
+		 * (INTknQFlsh) (Device Only)
+		 */
+		unsigned intknqflsh:1;
+		/** RxFIFO Flush (RxFFlsh) (Device and Host)
+		 *
+		 * The application can flush the entire Receive FIFO
+		 * using this bit. The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction. The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is reading from the RxFIFO nor the MAC
+		 * is writing the data in to the FIFO. The
+		 * application should wait until the bit is cleared
+		 * before performing any other operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned rxfflsh:1;
+		/** TxFIFO Flush (TxFFlsh) (Device and Host).
+		 *
+		 * This bit is used to selectively flush a single or
+		 * all transmit FIFOs. The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction. The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is writing into the TxFIFO nor the MAC
+		 * is reading the data out of the FIFO. The
+		 * application should wait until the core clears this
+		 * bit, before performing any operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned txfflsh:1;
+
+		/** TxFIFO Number (TxFNum) (Device and Host).
+		 *
+		 * This is the FIFO number which needs to be flushed,
+		 * using the TxFIFO Flush bit. This field should not
+		 * be changed until the TxFIFO Flush bit is cleared by
+		 * the core.
+		 *	 - 0x0 : Non Periodic TxFIFO Flush
+		 *	 - 0x1 : Periodic TxFIFO #1 Flush in device mode
+		 *	   or Periodic TxFIFO in host mode
+		 *	 - 0x2 : Periodic TxFIFO #2 Flush in device mode.
+		 *	 - ...
+		 *	 - 0xF : Periodic TxFIFO #15 Flush in device mode
+		 *	 - 0x10: Flush all the Transmit NonPeriodic and
+		 *	   Transmit Periodic FIFOs in the core
+		 */
+		unsigned txfnum:5;
+		/** Reserved */
+		unsigned reserved11_29:19;
+		/** DMA Request Signal.	 Indicated DMA request is in
+		 * probress. Used for debug purpose. */
+		unsigned dmareq:1;
+		/** AHB Master Idle.  Indicates the AHB Master State
+		 * Machine is in IDLE condition. */
+		unsigned ahbidle:1;
+	} b;
+} grstctl_t;
+
+/**
+ * This union represents the bit fields of the Core Interrupt Mask
+ * Register (GINTMSK). Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gintmsk_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned reserved0:1;
+		unsigned modemismatch:1;
+		unsigned otgintr:1;
+		unsigned sofintr:1;
+		unsigned rxstsqlvl:1;
+		unsigned nptxfempty:1;
+		unsigned ginnakeff:1;
+		unsigned goutnakeff:1;
+		unsigned ulpickint:1;
+		unsigned i2cintr:1;
+		unsigned erlysuspend:1;
+		unsigned usbsuspend:1;
+		unsigned usbreset:1;
+		unsigned enumdone:1;
+		unsigned isooutdrop:1;
+		unsigned eopframe:1;
+		unsigned restoredone:1;
+		unsigned epmismatch:1;
+		unsigned inepintr:1;
+		unsigned outepintr:1;
+		unsigned incomplisoin:1;
+		unsigned incomplisoout:1;
+		unsigned fetsusp:1;
+		unsigned resetdet:1;
+		unsigned portintr:1;
+		unsigned hcintr:1;
+		unsigned ptxfempty:1;
+		unsigned lpmtranrcvd:1;
+		unsigned conidstschng:1;
+		unsigned disconnect:1;
+		unsigned sessreqintr:1;
+		unsigned wkupintr:1;
+	} b;
+} gintmsk_data_t;
+/**
+ * This union represents the bit fields of the Core Interrupt Register
+ * (GINTSTS).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union gintsts_data {
+	/** raw register data */
+	uint32_t d32;
+#define DWC_SOF_INTR_MASK 0x0008
+	/** register bits */
+	struct {
+#define DWC_HOST_MODE 1
+		unsigned curmode:1;
+		unsigned modemismatch:1;
+		unsigned otgintr:1;
+		unsigned sofintr:1;
+		unsigned rxstsqlvl:1;
+		unsigned nptxfempty:1;
+		unsigned ginnakeff:1;
+		unsigned goutnakeff:1;
+		unsigned ulpickint:1;
+		unsigned i2cintr:1;
+		unsigned erlysuspend:1;
+		unsigned usbsuspend:1;
+		unsigned usbreset:1;
+		unsigned enumdone:1;
+		unsigned isooutdrop:1;
+		unsigned eopframe:1;
+		unsigned restoredone:1;
+		unsigned epmismatch:1;
+		unsigned inepint:1;
+		unsigned outepintr:1;
+		unsigned incomplisoin:1;
+		unsigned incomplisoout:1;
+		unsigned fetsusp:1;
+		unsigned resetdet:1;
+		unsigned portintr:1;
+		unsigned hcintr:1;
+		unsigned ptxfempty:1;
+		unsigned lpmtranrcvd:1;
+		unsigned conidstschng:1;
+		unsigned disconnect:1;
+		unsigned sessreqintr:1;
+		unsigned wkupintr:1;
+	} b;
+} gintsts_data_t;
+
+/**
+ * This union represents the bit fields in the Device Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union device_grxsts_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned epnum:4;
+		unsigned bcnt:11;
+		unsigned dpid:2;
+
+#define DWC_STS_DATA_UPDT		0x2	// OUT Data Packet
+#define DWC_STS_XFER_COMP		0x3	// OUT Data Transfer Complete
+
+#define DWC_DSTS_GOUT_NAK		0x1	// Global OUT NAK
+#define DWC_DSTS_SETUP_COMP		0x4	// Setup Phase Complete
+#define DWC_DSTS_SETUP_UPDT 0x6	// SETUP Packet
+		unsigned pktsts:4;
+		unsigned fn:4;
+		unsigned reserved25_31:7;
+	} b;
+} device_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union host_grxsts_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned chnum:4;
+		unsigned bcnt:11;
+		unsigned dpid:2;
+
+		unsigned pktsts:4;
+#define DWC_GRXSTS_PKTSTS_IN			  0x2
+#define DWC_GRXSTS_PKTSTS_IN_XFER_COMP	  0x3
+#define DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR 0x5
+#define DWC_GRXSTS_PKTSTS_CH_HALTED		  0x7
+
+		unsigned reserved21_31:11;
+	} b;
+} host_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the FIFO Size Registers (HPTXFSIZ,
+ * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element
+ * then read out the bits using the <i>b</i>it elements.
+ */
+typedef union fifosize_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned startaddr:16;
+		unsigned depth:16;
+	} b;
+} fifosize_data_t;
+
+/**
+ * This union represents the bit fields in the Non-Periodic Transmit
+ * FIFO/Queue Status Register (GNPTXSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union gnptxsts_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned nptxfspcavail:16;
+		unsigned nptxqspcavail:8;
+		/** Top of the Non-Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (Last entry for the selected
+		 *	  channel/EP)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - IN/OUT
+		 *	  - 2'b01 - Zero Length OUT
+		 *	  - 2'b10 - PING/Complete Split
+		 *	  - 2'b11 - Channel Halt
+		 *	- bits 30:27 - Channel/EP Number
+		 */
+		unsigned nptxqtop_terminate:1;
+		unsigned nptxqtop_token:2;
+		unsigned nptxqtop_chnep:4;
+		unsigned reserved:1;
+	} b;
+} gnptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Transmit
+ * FIFO Status Register (DTXFSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union dtxfsts_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned txfspcavail:16;
+		unsigned reserved:16;
+	} b;
+} dtxfsts_data_t;
+
+/**
+ * This union represents the bit fields in the I2C Control Register
+ * (I2CCTL). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gi2cctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned rwdata:8;
+		unsigned regaddr:8;
+		unsigned addr:7;
+		unsigned i2cen:1;
+		unsigned ack:1;
+		unsigned i2csuspctl:1;
+		unsigned i2cdevaddr:2;
+		unsigned i2cdatse0:1;
+		unsigned reserved:1;
+		unsigned rw:1;
+		unsigned bsydne:1;
+	} b;
+} gi2cctl_data_t;
+
+/**
+ * This union represents the bit fields in the PHY Vendor Control Register
+ * (GPVNDCTL). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gpvndctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned regdata:8;
+		unsigned vctrl:8;
+		unsigned regaddr16_21:6;
+		unsigned regwr:1;
+		unsigned reserved23_24:2;
+		unsigned newregreq:1;
+		unsigned vstsbsy:1;
+		unsigned vstsdone:1;
+		unsigned reserved28_30:3;
+		unsigned disulpidrvr:1;
+	} b;
+} gpvndctl_data_t;
+
+/**
+ * This union represents the bit fields in the General Purpose
+ * Input/Output Register (GGPIO).
+ * Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union ggpio_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned gpi:16;
+		unsigned gpo:16;
+	} b;
+} ggpio_data_t;
+
+/**
+ * This union represents the bit fields in the User ID Register
+ * (GUID). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union guid_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned rwdata:32;
+	} b;
+} guid_data_t;
+
+/**
+ * This union represents the bit fields in the Synopsys ID Register
+ * (GSNPSID). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gsnpsid_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned rwdata:32;
+	} b;
+} gsnpsid_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config1
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg1_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned ep_dir0:2;
+		unsigned ep_dir1:2;
+		unsigned ep_dir2:2;
+		unsigned ep_dir3:2;
+		unsigned ep_dir4:2;
+		unsigned ep_dir5:2;
+		unsigned ep_dir6:2;
+		unsigned ep_dir7:2;
+		unsigned ep_dir8:2;
+		unsigned ep_dir9:2;
+		unsigned ep_dir10:2;
+		unsigned ep_dir11:2;
+		unsigned ep_dir12:2;
+		unsigned ep_dir13:2;
+		unsigned ep_dir14:2;
+		unsigned ep_dir15:2;
+	} b;
+} hwcfg1_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config2
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg2_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/* GHWCFG2 */
+		unsigned op_mode:3;
+#define DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG 0
+#define DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG 1
+#define DWC_HWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE_OTG 2
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE 3
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE 4
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST 5
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST 6
+
+		unsigned architecture:2;
+		unsigned point2point:1;
+		unsigned hs_phy_type:2;
+#define DWC_HWCFG2_HS_PHY_TYPE_NOT_SUPPORTED 0
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI 1
+#define DWC_HWCFG2_HS_PHY_TYPE_ULPI 2
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI 3
+
+		unsigned fs_phy_type:2;
+		unsigned num_dev_ep:4;
+		unsigned num_host_chan:4;
+		unsigned perio_ep_supported:1;
+		unsigned dynamic_fifo:1;
+		unsigned multi_proc_int:1;
+		unsigned reserved21:1;
+		unsigned nonperio_tx_q_depth:2;
+		unsigned host_perio_tx_q_depth:2;
+		unsigned dev_token_q_depth:5;
+		unsigned otg_enable_ic_usb:1;
+	} b;
+} hwcfg2_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config3
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg3_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/* GHWCFG3 */
+		unsigned xfer_size_cntr_width:4;
+		unsigned packet_size_cntr_width:3;
+		unsigned otg_func:1;
+		unsigned i2c:1;
+		unsigned vendor_ctrl_if:1;
+		unsigned optional_features:1;
+		unsigned synch_reset_type:1;
+		unsigned adp_supp:1;
+		unsigned otg_enable_hsic:1;
+		unsigned bc_support:1;
+		unsigned otg_lpm_en:1;
+		unsigned dfifo_depth:16;
+	} b;
+} hwcfg3_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config4
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg4_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned num_dev_perio_in_ep:4;
+		unsigned power_optimiz:1;
+		unsigned min_ahb_freq:1;
+		unsigned part_power_down:1;
+		unsigned reserved:7;
+		unsigned utmi_phy_data_width:2;
+		unsigned num_dev_mode_ctrl_ep:4;
+		unsigned iddig_filt_en:1;
+		unsigned vbus_valid_filt_en:1;
+		unsigned a_valid_filt_en:1;
+		unsigned b_valid_filt_en:1;
+		unsigned session_end_filt_en:1;
+		unsigned ded_fifo_en:1;
+		unsigned num_in_eps:4;
+		unsigned desc_dma:1;
+		unsigned desc_dma_dyn:1;
+	} b;
+} hwcfg4_data_t;
+
+/**
+ * This union represents the bit fields of the Core LPM Configuration
+ * Register (GLPMCFG). Set the bits using bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union glpmctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** LPM-Capable (LPMCap) (Device and Host)
+		 * The application uses this bit to control
+		 * the DWC_otg core LPM capabilities.
+		 */
+		unsigned lpm_cap_en:1;
+		/** LPM response programmed by application (AppL1Res) (Device)
+		 * Handshake response to LPM token pre-programmed
+		 * by device application software.
+		 */
+		unsigned appl_resp:1;
+		/** Host Initiated Resume Duration (HIRD) (Device and Host)
+		 * In Host mode this field indicates the value of HIRD
+		 * to be sent in an LPM transaction.
+		 * In Device mode this field is updated with the
+		 * Received LPM Token HIRD bmAttribute
+		 * when an ACK/NYET/STALL response is sent
+		 * to an LPM transaction.
+		 */
+		unsigned hird:4;
+		/** RemoteWakeEnable (bRemoteWake) (Device and Host)
+		 * In Host mode this bit indicates the value of remote
+		 * wake up to be sent in wIndex field of LPM transaction.
+		 * In Device mode this field is updated with the
+		 * Received LPM Token bRemoteWake bmAttribute
+		 * when an ACK/NYET/STALL response is sent
+		 * to an LPM transaction.
+		 */
+		unsigned rem_wkup_en:1;
+		/** Enable utmi_sleep_n (EnblSlpM) (Device and Host)
+		 * The application uses this bit to control
+		 * the utmi_sleep_n assertion to the PHY when in L1 state.
+		 */
+		unsigned en_utmi_sleep:1;
+		/** HIRD Threshold (HIRD_Thres) (Device and Host)
+		 */
+		unsigned hird_thres:5;
+		/** LPM Response (CoreL1Res) (Device and Host)
+		 * In Host mode this bit contains handsake response to
+		 * LPM transaction.
+		 * In Device mode the response of the core to
+		 * LPM transaction received is reflected in these two bits.
+			- 0x0 : ERROR (No handshake response)
+			- 0x1 : STALL
+			- 0x2 : NYET
+			- 0x3 : ACK
+		 */
+		unsigned lpm_resp:2;
+		/** Port Sleep Status (SlpSts) (Device and Host)
+		 * This bit is set as long as a Sleep condition
+		 * is present on the USB bus.
+		 */
+		unsigned prt_sleep_sts:1;
+		/** Sleep State Resume OK (L1ResumeOK) (Device and Host)
+		 * Indicates that the application or host
+		 * can start resume from Sleep state.
+		 */
+		unsigned sleep_state_resumeok:1;
+		/** LPM channel Index (LPM_Chnl_Indx) (Host)
+		 * The channel number on which the LPM transaction
+		 * has to be applied while sending
+		 * an LPM transaction to the local device.
+		 */
+		unsigned lpm_chan_index:4;
+		/** LPM Retry Count (LPM_Retry_Cnt) (Host)
+		 * Number host retries that would be performed
+		 * if the device response was not valid response.
+		 */
+		unsigned retry_count:3;
+		/** Send LPM Transaction (SndLPM) (Host)
+		 * When set by application software,
+		 * an LPM transaction containing two tokens
+		 * is sent.
+		 */
+		unsigned send_lpm:1;
+		/** LPM Retry status (LPM_RetryCnt_Sts) (Host)
+		 * Number of LPM Host Retries still remaining
+		 * to be transmitted for the current LPM sequence
+		 */
+		unsigned retry_count_sts:3;
+		unsigned reserved28_29:2;
+		/** In host mode once this bit is set, the host
+		 * configures to drive the HSIC Idle state on the bus.
+		 * It then waits for the  device to initiate the Connect sequence.
+		 * In device mode once this bit is set, the device waits for
+		 * the HSIC Idle line state on the bus. Upon receving the Idle
+		 * line state, it initiates the HSIC Connect sequence.
+		 */
+		unsigned hsic_connect:1;
+		/** This bit overrides and functionally inverts
+		 * the if_select_hsic input port signal.
+		 */
+		unsigned inv_sel_hsic:1;
+	} b;
+} glpmcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core ADP Timer, Control and
+ * Status Register (ADPTIMCTLSTS). Set the bits using bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union adpctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Probe Discharge (PRB_DSCHG)
+		 *  These bits set the times for TADP_DSCHG.
+		 *  These bits are defined as follows:
+		 *  2'b00 - 4 msec
+		 *  2'b01 - 8 msec
+		 *  2'b10 - 16 msec
+		 *  2'b11 - 32 msec
+		 */
+		unsigned prb_dschg:2;
+		/** Probe Delta (PRB_DELTA)
+		 *  These bits set the resolution for RTIM   value.
+		 *  The bits are defined in units of 32 kHz clock cycles as follows:
+		 *  2'b00  -  1 cycles
+		 *  2'b01  -  2 cycles
+		 *  2'b10 -  3 cycles
+		 *  2'b11 - 4 cycles
+		 *  For example if this value is chosen to 2'b01, it means that RTIM
+		 *  increments for every 3(three) 32Khz clock cycles.
+		 */
+		unsigned prb_delta:2;
+		/** Probe Period (PRB_PER)
+		 *  These bits sets the TADP_PRD as shown in Figure 4 as follows:
+		 *  2'b00  -  0.625 to 0.925 sec (typical 0.775 sec)
+		 *  2'b01  -  1.25 to 1.85 sec (typical 1.55 sec)
+		 *  2'b10  -  1.9 to 2.6 sec (typical 2.275 sec)
+		 *  2'b11  -  Reserved
+		 */
+		unsigned prb_per:2;
+		/** These bits capture the latest time it took for VBUS to ramp from
+		 *  VADP_SINK to VADP_PRB.
+		 *  0x000  -  1 cycles
+		 *  0x001  -  2 cycles
+		 *  0x002  -  3 cycles
+		 *  etc
+		 *  0x7FF  -  2048 cycles
+		 *  A time of 1024 cycles at 32 kHz corresponds to a time of 32 msec.
+		*/
+		unsigned rtim:11;
+		/** Enable Probe (EnaPrb)
+		 *  When programmed to 1'b1, the core performs a probe operation.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned enaprb:1;
+		/** Enable Sense (EnaSns)
+		 *  When programmed to 1'b1, the core performs a Sense operation.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned enasns:1;
+		/** ADP Reset (ADPRes)
+		 *  When set, ADP controller is reset.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		*/
+		unsigned adpres:1;
+		/** ADP Enable (ADPEn)
+		 *  When set, the core performs either ADP probing or sensing
+		 *  based on EnaPrb or EnaSns.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned adpen:1;
+		/** ADP Probe Interrupt (ADP_PRB_INT)
+		 *  When this bit is set, it means that the VBUS
+		 *  voltage is greater than VADP_PRB or VADP_PRB is reached.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned adp_prb_int:1;
+		/**
+		 *  ADP Sense Interrupt (ADP_SNS_INT)
+		 *  When this bit is set, it means that the VBUS voltage is greater than
+		 *  VADP_SNS value or VADP_SNS is reached.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned adp_sns_int:1;
+		/** ADP Tomeout Interrupt (ADP_TMOUT_INT)
+		 *  This bit is relevant only for an ADP probe.
+		 *  When this bit is set, it means that the ramp time has
+		 *  completed ie ADPCTL.RTIM has reached its terminal value
+		 *  of 0x7FF.  This is a debug feature that allows software
+		 *  to read the ramp time after each cycle.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned adp_tmout_int:1;
+		/** ADP Probe Interrupt Mask (ADP_PRB_INT_MSK)
+		 *  When this bit is set, it unmasks the interrupt due to ADP_PRB_INT.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned adp_prb_int_msk:1;
+		/** ADP Sense Interrupt Mask (ADP_SNS_INT_MSK)
+		 *  When this bit is set, it unmasks the interrupt due to ADP_SNS_INT.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned adp_sns_int_msk:1;
+		/** ADP Timoeout Interrupt Mask (ADP_TMOUT_MSK)
+		 *  When this bit is set, it unmasks the interrupt due to ADP_TMOUT_INT.
+		 *  This bit is valid only if OTG_Ver = 1'b1.
+		 */
+		unsigned adp_tmout_int_msk:1;
+		/** Access Request
+		 * 2'b00 - Read/Write Valid (updated by the core)
+		 * 2'b01 - Read
+		 * 2'b00 - Write
+		 * 2'b00 - Reserved
+		 */
+		unsigned ar:2;
+		 /** Reserved */
+		unsigned reserved29_31:3;
+	} b;
+} adpctl_data_t;
+
+////////////////////////////////////////////
+// Device Registers
+/**
+ * Device Global Registers. <i>Offsets 800h-BFFh</i>
+ *
+ * The following structures define the size and relative field offsets
+ * for the Device Mode Registers.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_global_regs {
+	/** Device Configuration Register. <i>Offset 800h</i> */
+	volatile uint32_t dcfg;
+	/** Device Control Register. <i>Offset: 804h</i> */
+	volatile uint32_t dctl;
+	/** Device Status Register (Read Only). <i>Offset: 808h</i> */
+	volatile uint32_t dsts;
+	/** Reserved. <i>Offset: 80Ch</i> */
+	uint32_t unused;
+	/** Device IN Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 810h</i> */
+	volatile uint32_t diepmsk;
+	/** Device OUT Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 814h</i> */
+	volatile uint32_t doepmsk;
+	/** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+	volatile uint32_t daint;
+	/** Device All Endpoints Interrupt Mask Register.  <i>Offset:
+	 * 81Ch</i> */
+	volatile uint32_t daintmsk;
+	/** Device IN Token Queue Read Register-1 (Read Only).
+	 * <i>Offset: 820h</i> */
+	volatile uint32_t dtknqr1;
+	/** Device IN Token Queue Read Register-2 (Read Only).
+	 * <i>Offset: 824h</i> */
+	volatile uint32_t dtknqr2;
+	/** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+	volatile uint32_t dvbusdis;
+	/** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+	volatile uint32_t dvbuspulse;
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */
+	volatile uint32_t dtknqr3_dthrctl;
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */
+	volatile uint32_t dtknqr4_fifoemptymsk;
+	/** Device Each Endpoint Interrupt Register (Read Only). /
+	 * <i>Offset: 838h</i> */
+	volatile uint32_t deachint;
+	/** Device Each Endpoint Interrupt mask Register (Read/Write). /
+	 * <i>Offset: 83Ch</i> */
+	volatile uint32_t deachintmsk;
+	/** Device Each In Endpoint Interrupt mask Register (Read/Write). /
+	 * <i>Offset: 840h</i> */
+	volatile uint32_t diepeachintmsk[MAX_EPS_CHANNELS];
+	/** Device Each Out Endpoint Interrupt mask Register (Read/Write). /
+	 * <i>Offset: 880h</i> */
+	volatile uint32_t doepeachintmsk[MAX_EPS_CHANNELS];
+} dwc_otg_device_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Device Configuration
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.  Write the
+ * <i>d32</i> member to the dcfg register.
+ */
+typedef union dcfg_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Device Speed */
+		unsigned devspd:2;
+		/** Non Zero Length Status OUT Handshake */
+		unsigned nzstsouthshk:1;
+#define DWC_DCFG_SEND_STALL 1
+
+		unsigned ena32khzs:1;
+		/** Device Addresses */
+		unsigned devaddr:7;
+		/** Periodic Frame Interval */
+		unsigned perfrint:2;
+#define DWC_DCFG_FRAME_INTERVAL_80 0
+#define DWC_DCFG_FRAME_INTERVAL_85 1
+#define DWC_DCFG_FRAME_INTERVAL_90 2
+#define DWC_DCFG_FRAME_INTERVAL_95 3
+
+		/** Enable Device OUT NAK for bulk in DDMA mode */
+		unsigned endevoutnak:1;
+
+		unsigned reserved14_17:4;
+		/** In Endpoint Mis-match count */
+		unsigned epmscnt:5;
+		/** Enable Descriptor DMA in Device mode */
+		unsigned descdma:1;
+		unsigned perschintvl:2;
+		unsigned resvalid:6;
+	} b;
+} dcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Device Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Remote Wakeup */
+		unsigned rmtwkupsig:1;
+		/** Soft Disconnect */
+		unsigned sftdiscon:1;
+		/** Global Non-Periodic IN NAK Status */
+		unsigned gnpinnaksts:1;
+		/** Global OUT NAK Status */
+		unsigned goutnaksts:1;
+		/** Test Control */
+		unsigned tstctl:3;
+		/** Set Global Non-Periodic IN NAK */
+		unsigned sgnpinnak:1;
+		/** Clear Global Non-Periodic IN NAK */
+		unsigned cgnpinnak:1;
+		/** Set Global OUT NAK */
+		unsigned sgoutnak:1;
+		/** Clear Global OUT NAK */
+		unsigned cgoutnak:1;
+
+		/** Power-On Programming Done */
+		unsigned pwronprgdone:1;
+		/** Reserved */
+		unsigned reserved:1;
+		/** Global Multi Count */
+		unsigned gmc:2;
+		/** Ignore Frame Number for ISOC EPs */
+		unsigned ifrmnum:1;
+		/** NAK on Babble */
+		unsigned nakonbble:1;
+		/** Enable Continue on BNA */
+		unsigned encontonbna:1;
+
+		unsigned reserved18_31:14;
+	} b;
+} dctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device Status
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dsts_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Suspend Status */
+		unsigned suspsts:1;
+		/** Enumerated Speed */
+		unsigned enumspd:2;
+#define DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ 0
+#define DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ 1
+#define DWC_DSTS_ENUMSPD_LS_PHY_6MHZ		   2
+#define DWC_DSTS_ENUMSPD_FS_PHY_48MHZ		   3
+		/** Erratic Error */
+		unsigned errticerr:1;
+		unsigned reserved4_7:4;
+		/** Frame or Microframe Number of the received SOF */
+		unsigned soffn:14;
+		unsigned reserved22_31:10;
+	} b;
+} dsts_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN EP Interrupt
+ * Register and the Device IN EP Common Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union diepint_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Transfer complete mask */
+		unsigned xfercompl:1;
+		/** Endpoint disable mask */
+		unsigned epdisabled:1;
+		/** AHB Error mask */
+		unsigned ahberr:1;
+		/** TimeOUT Handshake mask (non-ISOC EPs) */
+		unsigned timeout:1;
+		/** IN Token received with TxF Empty mask */
+		unsigned intktxfemp:1;
+		/** IN Token Received with EP mismatch mask */
+		unsigned intknepmis:1;
+		/** IN Endpoint NAK Effective mask */
+		unsigned inepnakeff:1;
+		/** Reserved */
+		unsigned emptyintr:1;
+
+		unsigned txfifoundrn:1;
+
+		/** BNA Interrupt mask */
+		unsigned bna:1;
+
+		unsigned reserved10_12:3;
+		/** BNA Interrupt mask */
+		unsigned nak:1;
+
+		unsigned reserved14_31:18;
+	} b;
+} diepint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN EP
+ * Common/Dedicated Interrupt Mask Register.
+ */
+typedef union diepint_data diepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP Interrupt
+ * Registerand Device OUT EP Common Interrupt Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union doepint_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Transfer complete */
+		unsigned xfercompl:1;
+		/** Endpoint disable  */
+		unsigned epdisabled:1;
+		/** AHB Error */
+		unsigned ahberr:1;
+		/** Setup Phase Done (contorl EPs) */
+		unsigned setup:1;
+		/** OUT Token Received when Endpoint Disabled */
+		unsigned outtknepdis:1;
+
+		unsigned stsphsercvd:1;
+		/** Back-to-Back SETUP Packets Received */
+		unsigned back2backsetup:1;
+
+		unsigned reserved7:1;
+		/** OUT packet Error */
+		unsigned outpkterr:1;
+		/** BNA Interrupt */
+		unsigned bna:1;
+
+		unsigned reserved10:1;
+		/** Packet Drop Status */
+		unsigned pktdrpsts:1;
+		/** Babble Interrupt */
+		unsigned babble:1;
+		/** NAK Interrupt */
+		unsigned nak:1;
+		/** NYET Interrupt */
+		unsigned nyet:1;
+
+		unsigned reserved15_31:17;
+	} b;
+} doepint_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP
+ * Common/Dedicated Interrupt Mask Register.
+ */
+typedef union doepint_data doepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device All EP Interrupt
+ * and Mask Registers.
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union daint_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** IN Endpoint bits */
+		unsigned in:16;
+		/** OUT Endpoint bits */
+		unsigned out:16;
+	} ep;
+	struct {
+		/** IN Endpoint bits */
+		unsigned inep0:1;
+		unsigned inep1:1;
+		unsigned inep2:1;
+		unsigned inep3:1;
+		unsigned inep4:1;
+		unsigned inep5:1;
+		unsigned inep6:1;
+		unsigned inep7:1;
+		unsigned inep8:1;
+		unsigned inep9:1;
+		unsigned inep10:1;
+		unsigned inep11:1;
+		unsigned inep12:1;
+		unsigned inep13:1;
+		unsigned inep14:1;
+		unsigned inep15:1;
+		/** OUT Endpoint bits */
+		unsigned outep0:1;
+		unsigned outep1:1;
+		unsigned outep2:1;
+		unsigned outep3:1;
+		unsigned outep4:1;
+		unsigned outep5:1;
+		unsigned outep6:1;
+		unsigned outep7:1;
+		unsigned outep8:1;
+		unsigned outep9:1;
+		unsigned outep10:1;
+		unsigned outep11:1;
+		unsigned outep12:1;
+		unsigned outep13:1;
+		unsigned outep14:1;
+		unsigned outep15:1;
+	} b;
+} daint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN Token Queue
+ * Read Registers.
+ * - Read the register into the <i>d32</i> member.
+ * - READ-ONLY Register
+ */
+typedef union dtknq1_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** In Token Queue Write Pointer */
+		unsigned intknwptr:5;
+		/** Reserved */
+		unsigned reserved05_06:2;
+		/** write pointer has wrapped. */
+		unsigned wrap_bit:1;
+		/** EP Numbers of IN Tokens 0 ... 4 */
+		unsigned epnums0_5:24;
+	} b;
+} dtknq1_data_t;
+
+/**
+ * This union represents Threshold control Register
+ * - Read and write the register into the <i>d32</i> member.
+ * - READ-WRITABLE Register
+ */
+typedef union dthrctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** non ISO Tx Thr. Enable */
+		unsigned non_iso_thr_en:1;
+		/** ISO Tx Thr. Enable */
+		unsigned iso_thr_en:1;
+		/** Tx Thr. Length */
+		unsigned tx_thr_len:9;
+		/** AHB Threshold ratio */
+		unsigned ahb_thr_ratio:2;
+		/** Reserved */
+		unsigned reserved13_15:3;
+		/** Rx Thr. Enable */
+		unsigned rx_thr_en:1;
+		/** Rx Thr. Length */
+		unsigned rx_thr_len:9;
+		unsigned reserved26:1;
+		/** Arbiter Parking Enable*/
+		unsigned arbprken:1;
+		/** Reserved */
+		unsigned reserved28_31:4;
+	} b;
+} dthrctl_data_t;
+
+/**
+ * Device Logical IN Endpoint-Specific Registers. <i>Offsets
+ * 900h-AFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_in_ep_regs {
+	/** Device IN Endpoint Control Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t diepctl;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 04h</i> */
+	uint32_t reserved04;
+	/** Device IN Endpoint Interrupt Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t diepint;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device IN Endpoint Transfer Size
+	 * Register. <i>Offset:900h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t dieptsiz;
+	/** Device IN Endpoint DMA Address Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 14h</i> */
+	volatile uint32_t diepdma;
+	/** Device IN Endpoint Transmit FIFO Status Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 18h</i> */
+	volatile uint32_t dtxfsts;
+	/** Device IN Endpoint DMA Buffer Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 1Ch</i> */
+	volatile uint32_t diepdmab;
+} dwc_otg_dev_in_ep_regs_t;
+
+/**
+ * Device Logical OUT Endpoint-Specific Registers. <i>Offsets:
+ * B00h-CFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_out_ep_regs {
+	/** Device OUT Endpoint Control Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t doepctl;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 04h</i> */
+	uint32_t reserved04;
+	/** Device OUT Endpoint Interrupt Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t doepint;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device OUT Endpoint Transfer Size Register. <i>Offset:
+	 * B00h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t doeptsiz;
+	/** Device OUT Endpoint DMA Address Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 14h</i> */
+	volatile uint32_t doepdma;
+	/** Reserved. <i>Offset:B00h + 	 * (ep_num * 20h) + 18h</i> */
+	uint32_t unused;
+	/** Device OUT Endpoint DMA Buffer Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 1Ch</i> */
+	uint32_t doepdmab;
+} dwc_otg_dev_out_ep_regs_t;
+
+/**
+ * This union represents the bit fields in the Device EP Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union depctl_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Maximum Packet Size
+		 * IN/OUT EPn
+		 * IN/OUT EP0 - 2 bits
+		 *	 2'b00: 64 Bytes
+		 *	 2'b01: 32
+		 *	 2'b10: 16
+		 *	 2'b11: 8 */
+		unsigned mps:11;
+#define DWC_DEP0CTL_MPS_64	 0
+#define DWC_DEP0CTL_MPS_32	 1
+#define DWC_DEP0CTL_MPS_16	 2
+#define DWC_DEP0CTL_MPS_8	 3
+
+		/** Next Endpoint
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned nextep:4;
+
+		/** USB Active Endpoint */
+		unsigned usbactep:1;
+
+		/** Endpoint DPID (INTR/Bulk IN and OUT endpoints)
+		 * This field contains the PID of the packet going to
+		 * be received or transmitted on this endpoint. The
+		 * application should program the PID of the first
+		 * packet going to be received or transmitted on this
+		 * endpoint , after the endpoint is
+		 * activated. Application use the SetD1PID and
+		 * SetD0PID fields of this register to program either
+		 * D0 or D1 PID.
+		 *
+		 * The encoding for this field is
+		 *	 - 0: D0
+		 *	 - 1: D1
+		 */
+		unsigned dpid:1;
+
+		/** NAK Status */
+		unsigned naksts:1;
+
+		/** Endpoint Type
+		 *	2'b00: Control
+		 *	2'b01: Isochronous
+		 *	2'b10: Bulk
+		 *	2'b11: Interrupt */
+		unsigned eptype:2;
+
+		/** Snoop Mode
+		 * OUT EPn/OUT EP0
+		 * IN EPn/IN EP0 - reserved */
+		unsigned snp:1;
+
+		/** Stall Handshake */
+		unsigned stall:1;
+
+		/** Tx Fifo Number
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned txfnum:4;
+
+		/** Clear NAK */
+		unsigned cnak:1;
+		/** Set NAK */
+		unsigned snak:1;
+		/** Set DATA0 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA0. Set Even
+		 * (micro)frame (SetEvenFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to even (micro)
+		 * frame.
+		 */
+		unsigned setd0pid:1;
+		/** Set DATA1 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA1 Set Odd
+		 * (micro)frame (SetOddFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to odd (micro) frame.
+		 */
+		unsigned setd1pid:1;
+
+		/** Endpoint Disable */
+		unsigned epdis:1;
+		/** Endpoint Enable */
+		unsigned epena:1;
+	} b;
+} depctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz_data {
+		/** raw register data */
+	uint32_t d32;
+		/** register bits */
+	struct {
+		/** Transfer size */
+		unsigned xfersize:19;
+/** Max packet count for EP (pow(2,10)-1) */
+#define MAX_PKT_CNT 1023
+		/** Packet Count */
+		unsigned pktcnt:10;
+		/** Multi Count - Periodic IN endpoints */
+		unsigned mc:2;
+		unsigned reserved:1;
+	} b;
+} deptsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP 0 Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz0_data {
+		/** raw register data */
+	uint32_t d32;
+		/** register bits */
+	struct {
+		/** Transfer size */
+		unsigned xfersize:7;
+				/** Reserved */
+		unsigned reserved7_18:12;
+		/** Packet Count */
+		unsigned pktcnt:2;
+				/** Reserved */
+		unsigned reserved21_28:8;
+				/**Setup Packet Count (DOEPTSIZ0 Only) */
+		unsigned supcnt:2;
+		unsigned reserved31;
+	} b;
+} deptsiz0_data_t;
+
+/////////////////////////////////////////////////
+// DMA Descriptor Specific Structures
+//
+
+/** Buffer status definitions */
+
+#define BS_HOST_READY	0x0
+#define BS_DMA_BUSY		0x1
+#define BS_DMA_DONE		0x2
+#define BS_HOST_BUSY	0x3
+
+/** Receive/Transmit status definitions */
+
+#define RTS_SUCCESS		0x0
+#define RTS_BUFFLUSH	0x1
+#define RTS_RESERVED	0x2
+#define RTS_BUFERR		0x3
+
+/**
+ * This union represents the bit fields in the DMA Descriptor
+ * status quadlet. Read the quadlet into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it, <i>b_iso_out</i> and
+ * <i>b_iso_in</i> elements.
+ */
+typedef union dev_dma_desc_sts {
+		/** raw register data */
+	uint32_t d32;
+		/** quadlet bits */
+	struct {
+		/** Received number of bytes */
+		unsigned bytes:16;
+		/** NAK bit - only for OUT EPs */
+		unsigned nak:1;
+		unsigned reserved17_22:6;
+		/** Multiple Transfer - only for OUT EPs */
+		unsigned mtrf:1;
+		/** Setup Packet received - only for OUT EPs */
+		unsigned sr:1;
+		/** Interrupt On Complete */
+		unsigned ioc:1;
+		/** Short Packet */
+		unsigned sp:1;
+		/** Last */
+		unsigned l:1;
+		/** Receive Status */
+		unsigned sts:2;
+		/** Buffer Status */
+		unsigned bs:2;
+	} b;
+
+//#ifdef DWC_EN_ISOC
+		/** iso out quadlet bits */
+	struct {
+		/** Received number of bytes */
+		unsigned rxbytes:11;
+
+		unsigned reserved11:1;
+		/** Frame Number */
+		unsigned framenum:11;
+		/** Received ISO Data PID */
+		unsigned pid:2;
+		/** Interrupt On Complete */
+		unsigned ioc:1;
+		/** Short Packet */
+		unsigned sp:1;
+		/** Last */
+		unsigned l:1;
+		/** Receive Status */
+		unsigned rxsts:2;
+		/** Buffer Status */
+		unsigned bs:2;
+	} b_iso_out;
+
+		/** iso in quadlet bits */
+	struct {
+		/** Transmited number of bytes */
+		unsigned txbytes:12;
+		/** Frame Number */
+		unsigned framenum:11;
+		/** Transmited ISO Data PID */
+		unsigned pid:2;
+		/** Interrupt On Complete */
+		unsigned ioc:1;
+		/** Short Packet */
+		unsigned sp:1;
+		/** Last */
+		unsigned l:1;
+		/** Transmit Status */
+		unsigned txsts:2;
+		/** Buffer Status */
+		unsigned bs:2;
+	} b_iso_in;
+//#endif                                /* DWC_EN_ISOC */
+} dev_dma_desc_sts_t;
+
+/**
+ * DMA Descriptor structure
+ *
+ * DMA Descriptor structure contains two quadlets:
+ * Status quadlet and Data buffer pointer.
+ */
+typedef struct dwc_otg_dev_dma_desc {
+	/** DMA Descriptor status quadlet */
+	dev_dma_desc_sts_t status;
+	/** DMA Descriptor data buffer pointer */
+	uint32_t buf;
+} dwc_otg_dev_dma_desc_t;
+
+
+/**
+ * The dwc_otg_dev_if structure contains information needed to manage
+ * the DWC_otg controller acting in device mode. It represents the
+ * programming view of the device-specific aspects of the controller.
+ */
+typedef struct dwc_otg_dev_if {
+	/** Pointer to device Global registers.
+	 * Device Global Registers starting at offset 800h
+	 */
+	dwc_otg_device_global_regs_t *dev_global_regs;
+#define DWC_DEV_GLOBAL_REG_OFFSET 0x800
+
+	/**
+	 * Device Logical IN Endpoint-Specific Registers 900h-AFCh
+	 */
+	dwc_otg_dev_in_ep_regs_t *in_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_IN_EP_REG_OFFSET 0x900
+#define DWC_EP_REG_OFFSET 0x20
+
+	/** Device Logical OUT Endpoint-Specific Registers B00h-CFCh */
+	dwc_otg_dev_out_ep_regs_t *out_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_OUT_EP_REG_OFFSET 0xB00
+
+	/* Device configuration information */
+	uint8_t speed;				 /**< Device Speed	0: Unknown, 1: LS, 2:FS, 3: HS */
+	uint8_t num_in_eps;		 /**< Number # of Tx EP range: 0-15 exept ep0 */
+	uint8_t num_out_eps;		 /**< Number # of Rx EP range: 0-15 exept ep 0*/
+
+	/** Size of periodic FIFOs (Bytes) */
+	uint16_t perio_tx_fifo_size[MAX_PERIO_FIFOS];
+
+	/** Size of Tx FIFOs (Bytes) */
+	uint16_t tx_fifo_size[MAX_TX_FIFOS];
+
+	/** Thresholding enable flags and length varaiables **/
+	uint16_t rx_thr_en;
+	uint16_t iso_tx_thr_en;
+	uint16_t non_iso_tx_thr_en;
+
+	uint16_t rx_thr_length;
+	uint16_t tx_thr_length;
+
+	/**
+	 * Pointers to the DMA Descriptors for EP0 Control
+	 * transfers (virtual and physical)
+	 */
+
+	/** 2 descriptors for SETUP packets */
+	void* dma_setup_desc_addr[2];
+	dwc_otg_dev_dma_desc_t *setup_desc_addr[2];
+
+	/** Pointer to Descriptor with latest SETUP packet */
+	dwc_otg_dev_dma_desc_t *psetup;
+
+	/** Index of current SETUP handler descriptor */
+	uint32_t setup_desc_index;
+
+	/** Descriptor for Data In or Status In phases */
+	void* dma_in_desc_addr;
+	dwc_otg_dev_dma_desc_t *in_desc_addr;
+
+	/** Descriptor for Data Out or Status Out phases */
+	void* dma_out_desc_addr;
+	dwc_otg_dev_dma_desc_t *out_desc_addr;
+
+	/** Setup Packet Detected - if set clear NAK when queueing */
+	uint32_t spd;
+	/** Isoc ep pointer on which incomplete happens */
+	void *isoc_ep;
+
+} dwc_otg_dev_if_t;
+
+/////////////////////////////////////////////////
+// Host Mode Register Structures
+//
+/**
+ * The Host Global Registers structure defines the size and relative
+ * field offsets for the Host Mode Global Registers.  Host Global
+ * Registers offsets 400h-7FFh.
+*/
+typedef struct dwc_otg_host_global_regs {
+	/** Host Configuration Register.   <i>Offset: 400h</i> */
+	volatile uint32_t hcfg;
+	/** Host Frame Interval Register.	<i>Offset: 404h</i> */
+	volatile uint32_t hfir;
+	/** Host Frame Number / Frame Remaining Register. <i>Offset: 408h</i> */
+	volatile uint32_t hfnum;
+	/** Reserved.	<i>Offset: 40Ch</i> */
+	uint32_t reserved40C;
+	/** Host Periodic Transmit FIFO/ Queue Status Register. <i>Offset: 410h</i> */
+	volatile uint32_t hptxsts;
+	/** Host All Channels Interrupt Register. <i>Offset: 414h</i> */
+	volatile uint32_t haint;
+	/** Host All Channels Interrupt Mask Register. <i>Offset: 418h</i> */
+	volatile uint32_t haintmsk;
+	/** Host Frame List Base Address Register . <i>Offset: 41Ch</i> */
+	volatile uint32_t hflbaddr;
+} dwc_otg_host_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Configuration Register.
+ * Read the register into the <i>d32</i> member then set/clear the bits using
+ * the <i>b</i>it elements. Write the <i>d32</i> member to the hcfg register.
+ */
+typedef union hcfg_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		/** FS/LS Phy Clock Select */
+		unsigned fslspclksel:2;
+#define DWC_HCFG_30_60_MHZ 0
+#define DWC_HCFG_48_MHZ	   1
+#define DWC_HCFG_6_MHZ	   2
+
+		/** FS/LS Only Support */
+		unsigned fslssupp:1;
+		unsigned reserved3_6:4;
+		/** Enable 32-KHz Suspend Mode */
+		unsigned ena32khzs:1;
+		/** Resume Validation Periiod */
+		unsigned resvalid:8;
+		unsigned reserved16_22:7;
+		/** Enable Scatter/gather DMA in Host mode */
+		unsigned descdma:1;
+		/** Frame List Entries */
+		unsigned frlisten:2;
+		/** Enable Periodic Scheduling */
+		unsigned perschedena:1;
+		unsigned reserved27_30:4;
+		unsigned modechtimen:1;
+	} b;
+} hcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfir_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		unsigned frint:16;
+		unsigned hfirrldctrl:1;
+		unsigned reserved:15;
+	} b;
+} hfir_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfnum_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		unsigned frnum:16;
+#define DWC_HFNUM_MAX_FRNUM 0x3FFF
+		unsigned frrem:16;
+	} b;
+} hfnum_data_t;
+
+typedef union hptxsts_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		unsigned ptxfspcavail:16;
+		unsigned ptxqspcavail:8;
+		/** Top of the Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (last entry for the selected channel)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - Zero length
+		 *	  - 2'b01 - Ping
+		 *	  - 2'b10 - Disable
+		 *	- bits 30:27 - Channel Number
+		 *	- bit 31 - Odd/even microframe
+		 */
+		unsigned ptxqtop_terminate:1;
+		unsigned ptxqtop_token:2;
+		unsigned ptxqtop_chnum:4;
+		unsigned ptxqtop_odd:1;
+	} b;
+} hptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Port Control and Status
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hprt0 register.
+ */
+typedef union hprt0_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned prtconnsts:1;
+		unsigned prtconndet:1;
+		unsigned prtena:1;
+		unsigned prtenchng:1;
+		unsigned prtovrcurract:1;
+		unsigned prtovrcurrchng:1;
+		unsigned prtres:1;
+		unsigned prtsusp:1;
+		unsigned prtrst:1;
+		unsigned reserved9:1;
+		unsigned prtlnsts:2;
+		unsigned prtpwr:1;
+		unsigned prttstctl:4;
+		unsigned prtspd:2;
+#define DWC_HPRT0_PRTSPD_HIGH_SPEED 0
+#define DWC_HPRT0_PRTSPD_FULL_SPEED 1
+#define DWC_HPRT0_PRTSPD_LOW_SPEED	2
+		unsigned reserved19_31:13;
+	} b;
+} hprt0_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haint_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned ch0:1;
+		unsigned ch1:1;
+		unsigned ch2:1;
+		unsigned ch3:1;
+		unsigned ch4:1;
+		unsigned ch5:1;
+		unsigned ch6:1;
+		unsigned ch7:1;
+		unsigned ch8:1;
+		unsigned ch9:1;
+		unsigned ch10:1;
+		unsigned ch11:1;
+		unsigned ch12:1;
+		unsigned ch13:1;
+		unsigned ch14:1;
+		unsigned ch15:1;
+		unsigned reserved:16;
+	} b;
+
+	struct {
+		unsigned chint:16;
+		unsigned reserved:16;
+	} b2;
+} haint_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haintmsk_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned ch0:1;
+		unsigned ch1:1;
+		unsigned ch2:1;
+		unsigned ch3:1;
+		unsigned ch4:1;
+		unsigned ch5:1;
+		unsigned ch6:1;
+		unsigned ch7:1;
+		unsigned ch8:1;
+		unsigned ch9:1;
+		unsigned ch10:1;
+		unsigned ch11:1;
+		unsigned ch12:1;
+		unsigned ch13:1;
+		unsigned ch14:1;
+		unsigned ch15:1;
+		unsigned reserved:16;
+	} b;
+
+	struct {
+		unsigned chint:16;
+		unsigned reserved:16;
+	} b2;
+} haintmsk_data_t;
+
+/**
+ * Host Channel Specific Registers. <i>500h-5FCh</i>
+ */
+typedef struct dwc_otg_hc_regs {
+	/** Host Channel 0 Characteristic Register. <i>Offset: 500h + (chan_num * 20h) + 00h</i> */
+	volatile uint32_t hcchar;
+	/** Host Channel 0 Split Control Register. <i>Offset: 500h + (chan_num * 20h) + 04h</i> */
+	volatile uint32_t hcsplt;
+	/** Host Channel 0 Interrupt Register. <i>Offset: 500h + (chan_num * 20h) + 08h</i> */
+	volatile uint32_t hcint;
+	/** Host Channel 0 Interrupt Mask Register. <i>Offset: 500h + (chan_num * 20h) + 0Ch</i> */
+	volatile uint32_t hcintmsk;
+	/** Host Channel 0 Transfer Size Register. <i>Offset: 500h + (chan_num * 20h) + 10h</i> */
+	volatile uint32_t hctsiz;
+	/** Host Channel 0 DMA Address Register. <i>Offset: 500h + (chan_num * 20h) + 14h</i> */
+	volatile uint32_t hcdma;
+	volatile uint32_t reserved;
+	/** Host Channel 0 DMA Buffer Address Register. <i>Offset: 500h + (chan_num * 20h) + 1Ch</i> */
+	volatile uint32_t hcdmab;
+} dwc_otg_hc_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Characteristics
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hcchar_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		/** Maximum packet size in bytes */
+		unsigned mps:11;
+
+		/** Endpoint number */
+		unsigned epnum:4;
+
+		/** 0: OUT, 1: IN */
+		unsigned epdir:1;
+
+		unsigned reserved:1;
+
+		/** 0: Full/high speed device, 1: Low speed device */
+		unsigned lspddev:1;
+
+		/** 0: Control, 1: Isoc, 2: Bulk, 3: Intr */
+		unsigned eptype:2;
+
+		/** Packets per frame for periodic transfers. 0 is reserved. */
+		unsigned multicnt:2;
+
+		/** Device address */
+		unsigned devaddr:7;
+
+		/**
+		 * Frame to transmit periodic transaction.
+		 * 0: even, 1: odd
+		 */
+		unsigned oddfrm:1;
+
+		/** Channel disable */
+		unsigned chdis:1;
+
+		/** Channel enable */
+		unsigned chen:1;
+	} b;
+} hcchar_data_t;
+
+typedef union hcsplt_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		/** Port Address */
+		unsigned prtaddr:7;
+
+		/** Hub Address */
+		unsigned hubaddr:7;
+
+		/** Transaction Position */
+		unsigned xactpos:2;
+#define DWC_HCSPLIT_XACTPOS_MID 0
+#define DWC_HCSPLIT_XACTPOS_END 1
+#define DWC_HCSPLIT_XACTPOS_BEGIN 2
+#define DWC_HCSPLIT_XACTPOS_ALL 3
+
+		/** Do Complete Split */
+		unsigned compsplt:1;
+
+		/** Reserved */
+		unsigned reserved:14;
+
+		/** Split Enble */
+		unsigned spltena:1;
+	} b;
+} hcsplt_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union hcint_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Transfer Complete */
+		unsigned xfercomp:1;
+		/** Channel Halted */
+		unsigned chhltd:1;
+		/** AHB Error */
+		unsigned ahberr:1;
+		/** STALL Response Received */
+		unsigned stall:1;
+		/** NAK Response Received */
+		unsigned nak:1;
+		/** ACK Response Received */
+		unsigned ack:1;
+		/** NYET Response Received */
+		unsigned nyet:1;
+		/** Transaction Err */
+		unsigned xacterr:1;
+		/** Babble Error */
+		unsigned bblerr:1;
+		/** Frame Overrun */
+		unsigned frmovrun:1;
+		/** Data Toggle Error */
+		unsigned datatglerr:1;
+		/** Buffer Not Available (only for DDMA mode) */
+		unsigned bna:1;
+		/** Exessive transaction error (only for DDMA mode) */
+		unsigned xcs_xact:1;
+		/** Frame List Rollover interrupt */
+		unsigned frm_list_roll:1;
+		/** Reserved */
+		unsigned reserved14_31:18;
+	} b;
+} hcint_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Interrupt Mask
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcintmsk register.
+ */
+typedef union hcintmsk_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		unsigned xfercompl:1;
+		unsigned chhltd:1;
+		unsigned ahberr:1;
+		unsigned stall:1;
+		unsigned nak:1;
+		unsigned ack:1;
+		unsigned nyet:1;
+		unsigned xacterr:1;
+		unsigned bblerr:1;
+		unsigned frmovrun:1;
+		unsigned datatglerr:1;
+		unsigned bna:1;
+		unsigned xcs_xact:1;
+		unsigned frm_list_roll:1;
+		unsigned reserved14_31:18;
+	} b;
+} hcintmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Transfer Size
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+
+typedef union hctsiz_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		/** Total transfer size in bytes */
+		unsigned xfersize:19;
+
+		/** Data packets to transfer */
+		unsigned pktcnt:10;
+
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control), SETUP (Control)
+		 */
+		unsigned pid:2;
+#define DWC_HCTSIZ_DATA0 0
+#define DWC_HCTSIZ_DATA1 2
+#define DWC_HCTSIZ_DATA2 1
+#define DWC_HCTSIZ_MDATA 3
+#define DWC_HCTSIZ_SETUP 3
+
+		/** Do PING protocol when 1 */
+		unsigned dopng:1;
+	} b;
+
+	/** register bits */
+	struct {
+		/** Scheduling information */
+		unsigned schinfo:8;
+
+		/** Number of transfer descriptors.
+		 * Max value:
+		 * 64 in general,
+		 * 256 only for HS isochronous endpoint.
+		 */
+		unsigned ntd:8;
+
+		/** Data packets to transfer */
+		unsigned reserved16_28:13;
+
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control)
+		 */
+		unsigned pid:2;
+
+		/** Do PING protocol when 1 */
+		unsigned dopng:1;
+	} b_ddma;
+} hctsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Host DMA Address
+ * Register used in Descriptor DMA mode.
+ */
+typedef union hcdma_data {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned reserved0_2:3;
+		/** Current Transfer Descriptor. Not used for ISOC */
+		unsigned ctd:8;
+		/** Start Address of Descriptor List */
+		unsigned dma_addr:21;
+	} b;
+} hcdma_data_t;
+
+/**
+ * This union represents the bit fields in the DMA Descriptor
+ * status quadlet for host mode. Read the quadlet into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union host_dma_desc_sts {
+	/** raw register data */
+	uint32_t d32;
+	/** quadlet bits */
+
+	/* for non-isochronous  */
+	struct {
+		/** Number of bytes */
+		unsigned n_bytes:17;
+		/** QTD offset to jump when Short Packet received - only for IN EPs */
+		unsigned qtd_offset:6;
+		/**
+		 * Set to request the core to jump to alternate QTD if
+		 * Short Packet received - only for IN EPs
+		 */
+		unsigned a_qtd:1;
+		 /**
+		  * Setup Packet bit. When set indicates that buffer contains
+		  * setup packet.
+		  */
+		unsigned sup:1;
+		/** Interrupt On Complete */
+		unsigned ioc:1;
+		/** End of List */
+		unsigned eol:1;
+		unsigned reserved27:1;
+		/** Rx/Tx Status */
+		unsigned sts:2;
+#define DMA_DESC_STS_PKTERR	1
+		unsigned reserved30:1;
+		/** Active Bit */
+		unsigned a:1;
+	} b;
+	/* for isochronous */
+	struct {
+		/** Number of bytes */
+		unsigned n_bytes:12;
+		unsigned reserved12_24:13;
+		/** Interrupt On Complete */
+		unsigned ioc:1;
+		unsigned reserved26_27:2;
+		/** Rx/Tx Status */
+		unsigned sts:2;
+		unsigned reserved30:1;
+		/** Active Bit */
+		unsigned a:1;
+	} b_isoc;
+} host_dma_desc_sts_t;
+
+#define	MAX_DMA_DESC_SIZE		131071
+#define MAX_DMA_DESC_NUM_GENERIC	64
+#define MAX_DMA_DESC_NUM_HS_ISOC	256
+#define MAX_FRLIST_EN_NUM		64
+/**
+ * Host-mode DMA Descriptor structure
+ *
+ * DMA Descriptor structure contains two quadlets:
+ * Status quadlet and Data buffer pointer.
+ */
+typedef struct dwc_otg_host_dma_desc {
+	/** DMA Descriptor status quadlet */
+	host_dma_desc_sts_t status;
+	/** DMA Descriptor data buffer pointer */
+	uint32_t buf;
+} dwc_otg_host_dma_desc_t;
+
+/** OTG Host Interface Structure.
+ *
+ * The OTG Host Interface Structure structure contains information
+ * needed to manage the DWC_otg controller acting in host mode. It
+ * represents the programming view of the host-specific aspects of the
+ * controller.
+ */
+typedef struct dwc_otg_host_if {
+	/** Host Global Registers starting at offset 400h.*/
+	dwc_otg_host_global_regs_t *host_global_regs;
+#define DWC_OTG_HOST_GLOBAL_REG_OFFSET 0x400
+
+	/** Host Port 0 Control and Status Register */
+	volatile uint32_t *hprt0;
+#define DWC_OTG_HOST_PORT_REGS_OFFSET 0x440
+
+	/** Host Channel Specific Registers at offsets 500h-5FCh. */
+	dwc_otg_hc_regs_t *hc_regs[MAX_EPS_CHANNELS];
+#define DWC_OTG_HOST_CHAN_REGS_OFFSET 0x500
+#define DWC_OTG_CHAN_REGS_OFFSET 0x20
+
+	/* Host configuration information */
+	/** Number of Host Channels (range: 1-16) */
+	uint8_t num_host_channels;
+	/** Periodic EPs supported (0: no, 1: yes) */
+	uint8_t perio_eps_supported;
+	/** Periodic Tx FIFO Size (Only 1 host periodic Tx FIFO) */
+	uint16_t perio_tx_fifo_size;
+
+	uint8_t	do_ping;
+} dwc_otg_host_if_t;
+
+/**
+ * This union represents the bit fields in the Power and Clock Gating Control
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union pcgcctl_data {
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		/** Stop Pclk */
+		unsigned stoppclk:1;
+		/** Gate Hclk */
+		unsigned gatehclk:1;
+		/** Power Clamp */
+		unsigned pwrclmp:1;
+		/** Reset Power Down Modules */
+		unsigned rstpdwnmodule:1;
+		/** Reserved */
+		unsigned reserved:1;
+		/** Enable Sleep Clock Gating (Enbl_L1Gating) */
+		unsigned enbl_sleep_gating:1;
+		/** PHY In Sleep (PhySleep) */
+		unsigned phy_in_sleep:1;
+		/** Deep Sleep*/
+		unsigned deep_sleep:1;
+		unsigned resetaftsusp:1;
+		unsigned restoremode:1;
+		unsigned reserved10_12:3;
+		unsigned ess_reg_restored:1;
+		unsigned prt_clk_sel:2;
+		unsigned port_power:1;
+		unsigned max_xcvrselect:2;
+		unsigned max_termsel:1;
+		unsigned mac_dev_addr:7;
+		unsigned p2hd_dev_enum_spd:2;
+		unsigned p2hd_prt_spd:2;
+		unsigned if_dev_mode:1;
+	} b;
+} pcgcctl_data_t;
+
+/**
+ * This union represents the bit fields in the Global Data FIFO Software
+ * Configuration Register. Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union gdfifocfg_data {
+	/* raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** OTG Data FIFO depth */
+		unsigned gdfifocfg:16;
+		/** Start address of EP info controller */
+		unsigned epinfobase:16;
+	} b;
+} gdfifocfg_data_t;
+
+/**
+ * This union represents the bit fields in the Global Power Down Register
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gpwrdn_data {
+	/* raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct {
+		/** PMU Interrupt Select */
+		unsigned pmuintsel:1;
+		/** PMU Active */
+		unsigned pmuactv:1;
+		/** Restore */
+		unsigned restore:1;
+		/** Power Down Clamp */
+		unsigned pwrdnclmp:1;
+		/** Power Down Reset */
+		unsigned pwrdnrstn:1;
+		/** Power Down Switch */
+		unsigned pwrdnswtch:1;
+		/** Disable VBUS */
+		unsigned dis_vbus:1;
+		/** Line State Change */
+		unsigned lnstschng:1;
+		/** Line state change mask */
+		unsigned lnstchng_msk:1;
+		/** Reset Detected */
+		unsigned rst_det:1;
+		/** Reset Detect mask */
+		unsigned rst_det_msk:1;
+		/** Disconnect Detected */
+		unsigned disconn_det:1;
+		/** Disconnect Detect mask */
+		unsigned disconn_det_msk:1;
+		/** Connect Detected*/
+		unsigned connect_det:1;
+		/** Connect Detected Mask*/
+		unsigned connect_det_msk:1;
+		/** SRP Detected */
+		unsigned srp_det:1;
+		/** SRP Detect mask */
+		unsigned srp_det_msk:1;
+		/** Status Change Interrupt */
+		unsigned sts_chngint:1;
+		/** Status Change Interrupt Mask */
+		unsigned sts_chngint_msk:1;
+		/** Line State */
+		unsigned linestate:2;
+		/** Indicates current mode(status of IDDIG signal) */
+		unsigned idsts:1;
+		/** B Session Valid signal status*/
+		unsigned bsessvld:1;
+		/** ADP Event Detected */
+		unsigned adp_int:1;
+		/** Multi Valued ID pin */
+		unsigned mult_val_id_bc:5;
+		/** Reserved 24_31 */
+		unsigned reserved29_31:3;
+	} b;
+} gpwrdn_data_t;
+
+#define DWC_OTG_EP_TYPE_CONTROL    0
+#define DWC_OTG_EP_TYPE_ISOC       1
+#define DWC_OTG_EP_TYPE_BULK       2
+#define DWC_OTG_EP_TYPE_INTR       3
+#endif
+
diff --git a/drivers/vpu/Kconfig b/drivers/vpu/Kconfig
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/vpu/Makefile b/drivers/vpu/Makefile
new file mode 100644
index 0000000..6fa6bfa
--- /dev/null
+++ b/drivers/vpu/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_AML_VPU) += aml_vpu.o
+
diff --git a/drivers/vpu/aml_vpu.c b/drivers/vpu/aml_vpu.c
new file mode 100644
index 0000000..69226e9
--- /dev/null
+++ b/drivers/vpu/aml_vpu.c
@@ -0,0 +1,663 @@
+
+/*
+ * drivers/vpu/aml_vpu.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#ifdef CONFIG_OF_LIBFDT
+#include <libfdt.h>
+#endif
+#include <vpu.h>
+#include "aml_vpu_reg.h"
+#include "aml_vpu.h"
+
+#define VPU_VERION	"v02"
+/* #define VPU_VCBUS_TEST */
+
+static char *dt_addr;
+static int dts_ready = 0;
+
+static struct VPU_Conf_t vpu_conf = {
+	.chip_type = VPU_CHIP_MAX,
+	.clk_level_dft = 0,
+	.clk_level_max = 1,
+	.clk_level = 0,
+	.fclk_type = 0,
+};
+
+static unsigned int get_vpu_clk_level(unsigned int video_clk)
+{
+	unsigned int video_bw;
+	unsigned clk_level;
+	int i;
+
+	video_bw = video_clk + 1000000;
+
+	for (i = 0; i < vpu_conf.clk_level_max; i++) {
+		if (video_bw <= vpu_clk_table[vpu_conf.fclk_type][i][0])
+			break;
+	}
+	clk_level = i;
+
+	return clk_level;
+}
+
+static unsigned int get_vpu_clk(void)
+{
+	unsigned int reg;
+	unsigned int clk_freq;
+	unsigned int fclk, clk_source;
+	unsigned int mux, div;
+
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		reg = HHI_VPU_CLK_CNTL_GX;
+	else
+		reg = HHI_VPU_CLK_CNTL;
+
+	fclk = fclk_table[vpu_conf.fclk_type] * 100; /* 0.01M resolution */
+	mux = vpu_hiu_getb(reg, 9, 3);
+	switch (mux) {
+	case 0: /* fclk_div4 */
+	case 1: /* fclk_div3 */
+	case 2: /* fclk_div5 */
+	case 3: /* fclk_div7, m8m2 gp_pll = fclk_div7 */
+		clk_source = fclk / fclk_div_table[mux];
+		break;
+	case 7:
+		if (vpu_chip_type == VPU_CHIP_G9TV)
+			clk_source = 696 * 100; /* 0.01MHz */
+		else
+			clk_source = 0;
+		break;
+	default:
+		clk_source = 0;
+		break;
+	}
+
+	div = vpu_hiu_getb(reg, 0, 7) + 1;
+	clk_freq = (clk_source / div) * 10 * 1000; /* change to Hz */
+
+	return clk_freq;
+}
+
+static int switch_gp_pll_m8m2(int flag)
+{
+	int cnt = 100;
+	int ret = 0;
+
+	if (flag) { /* enable gp_pll */
+		/* M=182, N=3, OD=2. gp_pll=24*M/N/2^OD=364M */
+		/* set gp_pll frequency fixed to 364M */
+		vpu_cbus_write(HHI_GP_PLL_CNTL, 0x206b6);
+		vpu_cbus_setb(HHI_GP_PLL_CNTL, 1, 30, 1); /* enable */
+		do {
+			udelay(10);
+			vpu_cbus_setb(HHI_GP_PLL_CNTL, 1, 29, 1); /* reset */
+			udelay(50);
+			/* release reset */
+			vpu_cbus_setb(HHI_GP_PLL_CNTL, 0, 29, 1);
+			udelay(50);
+			cnt--;
+			if (cnt == 0)
+				break;
+		} while (vpu_cbus_getb(HHI_GP_PLL_CNTL, 31, 1) == 0);
+		if (cnt == 0) {
+			ret = 1;
+			vpu_cbus_setb(HHI_GP_PLL_CNTL, 0, 30, 1);
+			printf("[error]: GP_PLL lock failed, can't use the clk source!\n");
+		}
+	} else { /* disable gp_pll */
+		vpu_cbus_setb(HHI_GP_PLL_CNTL, 0, 30, 1);
+	}
+
+	return ret;
+}
+
+static int switch_gp1_pll_g9tv(int flag)
+{
+	int cnt = 100;
+	int ret = 0;
+
+	if (flag) { /* enable gp1_pll */
+		/* GP1 DPLL 696MHz output*/
+		vpu_cbus_write(HHI_GP1_PLL_CNTL, 0x6a01023a);
+		vpu_cbus_write(HHI_GP1_PLL_CNTL2, 0x69c80000);
+		vpu_cbus_write(HHI_GP1_PLL_CNTL3, 0x0a5590c4);
+		vpu_cbus_write(HHI_GP1_PLL_CNTL4, 0x0000500d);
+		vpu_cbus_write(HHI_GP1_PLL_CNTL, 0x4a01023a);
+		do {
+			udelay(10);
+			vpu_cbus_setb(HHI_GP1_PLL_CNTL, 1, 29, 1); /* reset */
+			udelay(50);
+			/* release reset */
+			vpu_cbus_setb(HHI_GP1_PLL_CNTL, 0, 29, 1);
+			udelay(50);
+			cnt--;
+			if (cnt == 0)
+				break;
+		} while (vpu_cbus_getb(HHI_GP1_PLL_CNTL, 31, 1) == 0);
+		if (cnt == 0) {
+			ret = 1;
+			vpu_cbus_setb(HHI_GP1_PLL_CNTL, 0, 30, 1);
+			printf("[error]: GP_PLL lock failed, can't use the clk source!\n");
+		}
+	} else { /* disable gp1_pll */
+		vpu_cbus_setb(HHI_GP1_PLL_CNTL, 0, 30, 1);
+	}
+
+	return ret;
+}
+
+static int adjust_vpu_clk_m8_g9(unsigned int clk_level)
+{
+	unsigned int mux, div;
+	int ret = 0;
+
+	switch (vpu_chip_type) {
+	case VPU_CHIP_M8M2:
+		if (clk_level == (CLK_LEVEL_MAX_M8M2 - 1)) {
+			ret = switch_gp_pll_m8m2(1);
+			if (ret)
+				clk_level = CLK_LEVEL_MAX_M8M2 - 2;
+		} else {
+			ret = switch_gp_pll_m8m2(0);
+		}
+		break;
+	case VPU_CHIP_G9TV:
+		if (clk_level == (CLK_LEVEL_MAX_G9TV - 1)) {
+			ret = switch_gp1_pll_g9tv(1);
+			if (ret)
+				clk_level = CLK_LEVEL_MAX_G9TV - 2;
+		} else {
+			ret = switch_gp1_pll_g9tv(0);
+		}
+		break;
+	default:
+		break;
+	}
+	vpu_conf.clk_level = clk_level;
+
+	mux = vpu_clk_table[vpu_conf.fclk_type][clk_level][1];
+	div = vpu_clk_table[vpu_conf.fclk_type][clk_level][2];
+	vpu_hiu_write(HHI_VPU_CLK_CNTL, ((mux << 9) | (div << 0) | (1<<8)));
+
+	printf("set vpu clk: %uHz, readback: %uHz(0x%x)\n",
+		vpu_clk_table[vpu_conf.fclk_type][clk_level][0],
+		get_vpu_clk(), (vpu_hiu_read(HHI_VPU_CLK_CNTL)));
+	return ret;
+}
+
+/* unit: MHz */
+#define VPU_CLKB_MAX    350
+static int adjust_vpu_clk_gx(unsigned int clk_level)
+{
+	unsigned int vpu_clk;
+	unsigned int mux, div;
+	int ret = 0;
+
+	vpu_conf.clk_level = clk_level;
+	vpu_clk = vpu_clk_table[vpu_conf.fclk_type][clk_level][0];
+	mux = vpu_clk_table[vpu_conf.fclk_type][clk_level][1];
+	div = vpu_clk_table[vpu_conf.fclk_type][clk_level][2];
+
+	vpu_hiu_write(HHI_VPU_CLK_CNTL_GX, ((mux << 9) | (div << 0)));
+	vpu_hiu_setb(HHI_VPU_CLK_CNTL_GX, 1, 8, 1);
+
+	if (vpu_clk >= (VPU_CLKB_MAX * 1000000))
+		vpu_hiu_write(HHI_VPU_CLKB_CNTL_GX, ((1 << 8) | (1 << 0)));
+	else
+		vpu_hiu_write(HHI_VPU_CLKB_CNTL_GX, ((1 << 8) | (0 << 0)));
+
+	vpu_hiu_write(HHI_VAPBCLK_CNTL_GX, (1 << 30) | /* turn on ge2d clock */
+			(0 << 9)    |   /* clk_sel    //250Mhz */
+			(1 << 0));      /* clk_div */
+	vpu_hiu_setb(HHI_VAPBCLK_CNTL_GX, 1, 8, 1);
+
+	printf("set vpu clk: %uHz, readback: %uHz(0x%x)\n",
+		vpu_clk, get_vpu_clk(), (vpu_hiu_read(HHI_VPU_CLK_CNTL_GX)));
+	return ret;
+}
+
+static int set_vpu_clk(unsigned int vclk)
+{
+	int ret = 0;
+	unsigned int clk_level;
+
+	if (vclk >= 100) /* regard as vpu_clk */
+		clk_level = get_vpu_clk_level(vclk);
+	else /* regard as clk_level */
+		clk_level = vclk;
+
+	if (clk_level >= vpu_conf.clk_level_max) {
+		ret = 1;
+		clk_level = vpu_conf.clk_level_dft;
+		printf("vpu clk out of supported range, set to default\n");
+	}
+
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		ret = adjust_vpu_clk_gx(clk_level);
+	else
+		ret = adjust_vpu_clk_m8_g9(clk_level);
+
+	return ret;
+}
+
+static void vpu_power_on_m8_g9(void)
+{
+	unsigned int i;
+
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 0, 8, 1); /* [8] power on */
+	udelay(20);
+
+	/* power up memories */
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG0, 0, i, 2);
+		udelay(5);
+	}
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG1, 0, i, 2);
+		udelay(5);
+	}
+	for (i = 8; i < 16; i++) {
+		vpu_hiu_setb(HHI_MEM_PD_REG0, 0, i, 1);
+		udelay(5);
+	}
+	udelay(20);
+
+	/* Reset VIU + VENC */
+	/* Reset VENCI + VENCP + VADC + VENCL */
+	/* Reset HDMI-APB + HDMI-SYS + HDMI-TX + HDMI-CEC */
+	vpu_cbus_clr_mask(RESET0_MASK, ((1 << 5) | (1<<10)));
+	vpu_cbus_clr_mask(RESET4_MASK, ((1 << 6) | (1<<7) | (1<<9) | (1<<13)));
+	vpu_cbus_clr_mask(RESET2_MASK, ((1 << 2) | (1<<3) | (1<<11) | (1<<15)));
+	vpu_cbus_write(RESET2_REGISTER, ((1 << 2) | (1<<3) | (1<<11) | (1<<15)));
+	/* reset this will cause VBUS reg to 0 */
+	vpu_cbus_write(RESET4_REGISTER, ((1 << 6) | (1<<7) | (1<<9) | (1<<13)));
+	vpu_cbus_write(RESET0_REGISTER, ((1 << 5) | (1<<10)));
+	vpu_cbus_write(RESET4_REGISTER, ((1 << 6) | (1<<7) | (1<<9) | (1<<13)));
+	vpu_cbus_write(RESET2_REGISTER, ((1 << 2) | (1<<3) | (1<<11) | (1<<15)));
+	vpu_cbus_set_mask(RESET0_MASK, ((1 << 5) | (1<<10)));
+	vpu_cbus_set_mask(RESET4_MASK, ((1 << 6) | (1<<7) | (1<<9) | (1<<13)));
+	vpu_cbus_set_mask(RESET2_MASK, ((1 << 2) | (1<<3) | (1<<11) | (1<<15)));
+
+	/* Remove VPU_HDMI ISO */
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 0, 9, 1); /* [9] VPU_HDMI */
+}
+
+static void vpu_power_on_gx(void)
+{
+	unsigned int i;
+
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 0, 8, 1); /* [8] power on */
+	udelay(20);
+
+	/* power up memories */
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG0_GX, 0, i, 2);
+		udelay(5);
+	}
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG1_GX, 0, i, 2);
+		udelay(5);
+	}
+	for (i = 8; i < 16; i++) {
+		vpu_hiu_setb(HHI_MEM_PD_REG0_GX, 0, i, 1);
+		udelay(5);
+	}
+	udelay(20);
+
+	/* Reset VIU + VENC */
+	/* Reset VENCI + VENCP + VADC + VENCL */
+	/* Reset HDMI-APB + HDMI-SYS + HDMI-TX + HDMI-CEC */
+	vpu_cbus_clr_mask(RESET0_LEVEL, ((1<<5) | (1<<10) | (1<<19) | (1<<13)));
+	vpu_cbus_clr_mask(RESET1_LEVEL, (1<<5));
+	vpu_cbus_clr_mask(RESET2_LEVEL, (1<<15));
+	vpu_cbus_clr_mask(RESET4_LEVEL, ((1<<6) | (1<<7) | (1<<13) | (1<<5) | (1<<9) | (1<<4) | (1<<12)));
+	vpu_cbus_clr_mask(RESET7_LEVEL, (1<<7));
+
+	/* Remove VPU_HDMI ISO */
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 0, 9, 1); /* [9] VPU_HDMI */
+
+	/* release Reset */
+	vpu_cbus_set_mask(RESET0_LEVEL, ((1 << 5) | (1<<10) | (1<<19) | (1<<13)));
+	vpu_cbus_set_mask(RESET1_LEVEL, (1<<5));
+	vpu_cbus_set_mask(RESET2_LEVEL, (1<<15));
+	vpu_cbus_set_mask(RESET4_LEVEL, ((1<<6) | (1<<7) | (1<<13) | (1<<5) | (1<<9) | (1<<4) | (1<<12)));
+	vpu_cbus_set_mask(RESET7_LEVEL, (1<<7));
+}
+
+static void vpu_power_off_m8_g9(void)
+{
+	unsigned int i;
+
+	/* Power down VPU_HDMI */
+	/* Enable Isolation */
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 1, 9, 1); /* ISO */
+	udelay(20);
+
+	/* power down memories */
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG0, 0x3, i, 2);
+		udelay(5);
+	}
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG1, 0x3, i, 2);
+		udelay(5);
+	}
+	for (i = 8; i < 16; i++) {
+		vpu_hiu_setb(HHI_MEM_PD_REG0, 0x1, i, 1);
+		udelay(5);
+	}
+	udelay(20);
+
+	/* Power down VPU domain */
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 1, 8, 1); /* PDN */
+
+	vpu_hiu_setb(HHI_VPU_CLK_CNTL, 0, 8, 1);
+}
+
+static void vpu_power_off_gx(void)
+{
+	unsigned int i;
+
+	/* Power down VPU_HDMI */
+	/* Enable Isolation */
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 1, 9, 1); /* ISO */
+	udelay(20);
+
+	/* power down memories */
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG0_GX, 0x3, i, 2);
+		udelay(5);
+	}
+	for (i = 0; i < 32; i+=2) {
+		vpu_hiu_setb(HHI_VPU_MEM_PD_REG1_GX, 0x3, i, 2);
+		udelay(5);
+	}
+	for (i = 8; i < 16; i++) {
+		vpu_hiu_setb(HHI_MEM_PD_REG0_GX, 0x1, i, 1);
+		udelay(5);
+	}
+	udelay(20);
+
+	/* Power down VPU domain */
+	vpu_ao_setb(AO_RTI_GEN_PWR_SLEEP0, 1, 8, 1); /* PDN */
+
+	vpu_hiu_setb(HHI_VAPBCLK_CNTL_GX, 0, 8, 1);
+	vpu_hiu_setb(HHI_VPU_CLKB_CNTL_GX, 0, 8, 1);
+	vpu_hiu_setb(HHI_VPU_CLK_CNTL_GX, 0, 8, 1);
+}
+
+static void vpu_power_on(void)
+{
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		vpu_power_on_gx();
+	else
+		vpu_power_on_m8_g9();
+}
+
+static void vpu_power_off(void)
+{
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		vpu_power_off_gx();
+	else
+		vpu_power_off_m8_g9();
+}
+
+static void detect_vpu_chip(void)
+{
+/* for gxbb bring up */
+#if 0
+	unsigned int cpu_type;
+
+	cpu_type = get_cpu_type();
+	switch (cpu_type) {
+	case MESON_CPU_MAJOR_ID_M8:
+		vpu_chip_type = VPU_CHIP_M8;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_M8;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_M8;
+		vpu_conf.fclk_type = FCLK_TYPE_M8;
+		break;
+	case MESON_CPU_MAJOR_ID_M8B:
+		vpu_chip_type = VPU_CHIP_M8B;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_M8B;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_M8B;
+		vpu_conf.fclk_type = FCLK_TYPE_M8B;
+		break;
+	case MESON_CPU_MAJOR_ID_M8M2:
+		vpu_chip_type = VPU_CHIP_M8M2;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_M8M2;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_M8M2;
+		vpu_conf.fclk_type = FCLK_TYPE_M8M2;
+		break;
+	case MESON_CPU_MAJOR_ID_MG9TV:
+		vpu_chip_type = VPU_CHIP_G9TV;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_G9TV;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_G9TV;
+		vpu_conf.fclk_type = FCLK_TYPE_G9TV;
+		break;
+	/* case MESON_CPU_MAJOR_ID_MG9BB:
+		vpu_chip_type = VPU_CHIP_G9BB;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_G9BB;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_G9BB;
+		vpu_conf.fclk_type = FCLK_TYPE_G9BB;
+		break; */
+	case MESON_CPU_MAJOR_ID_GXBB:
+		vpu_chip_type = VPU_CHIP_GXBB;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_GXBB;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_GXBB;
+		vpu_conf.fclk_type = FCLK_TYPE_GXBB;
+		break;
+	default:
+		vpu_chip_type = VPU_CHIP_MAX;
+		vpu_conf.clk_level_dft = 0;
+		vpu_conf.clk_level_max = 1;
+	}
+#else
+	vpu_chip_type = VPU_CHIP_GXBB;
+	vpu_conf.clk_level_dft = CLK_LEVEL_DFT_GXBB;
+	vpu_conf.clk_level_max = CLK_LEVEL_MAX_GXBB;
+	vpu_conf.fclk_type = FCLK_TYPE_GXBB;
+#endif
+
+	printf("vpu detect type: %d\n", vpu_chip_type);
+}
+
+#define VCBUS_TEST_NUM    4
+static unsigned int vcbus_reg[] = {
+	0x1d00, /* VPP_DUMMY_DATA */
+	0x1702, /* DI_POST_SIZE */
+	0x1c30, /* ENCP_DVI_HSO_BEGIN */
+	0x1b78, /* VENC_VDAC_DACSEL0 */
+};
+void vcbus_test(void)
+{
+	unsigned int val;
+	unsigned int temp;
+	int i,j;
+
+	printf("vcbus test\n");
+	for (i = 0; i < VCBUS_TEST_NUM; i++) {
+		for (j = 0; j < 24; j++) {
+			val = vpu_vcbus_read(vcbus_reg[i]);
+			printf("%02d read 0x%04x=0x%08x\n", j, vcbus_reg[i], val);
+		}
+		printf("\n");
+	}
+	temp = 0x5a5a5a5a;
+	for (i = 0; i < VCBUS_TEST_NUM; i++) {
+		vpu_vcbus_write(vcbus_reg[i], temp);
+		val = vpu_vcbus_read(vcbus_reg[i]);
+		printf("write 0x%04x=0x%08x, readback: 0x%08x\n", vcbus_reg[i], temp, val);
+	}
+	for (i = 0; i < VCBUS_TEST_NUM; i++) {
+		for (j = 0; j < 24; j++) {
+			val = vpu_vcbus_read(vcbus_reg[i]);
+			printf("%02d read 0x%04x=0x%08x\n", j, vcbus_reg[i], val);
+		}
+		printf("\n");
+	}
+}
+
+static int get_vpu_config(void)
+{
+	int ret = 0;
+	int nodeoffset;
+	char * propdata;
+
+#ifdef CONFIG_OF_LIBFDT
+	if (dts_ready == 1) {
+		nodeoffset = fdt_path_offset(dt_addr, "/vpu");
+		if (nodeoffset < 0) {
+			printf("vpu preset: not find /vpu node in dts %s.\n",fdt_strerror(nodeoffset));
+			return -1;
+		}
+
+		propdata = (char *)fdt_getprop(dt_addr, nodeoffset, "clk_level", NULL);
+		if (propdata == NULL) {
+			vpu_conf.clk_level = vpu_conf.clk_level_dft;
+			printf("don't find to match clk_level in dts, use default setting.\n");
+		} else {
+			vpu_conf.clk_level = (unsigned short)(be32_to_cpup((u32*)propdata));
+			printf("vpu clk_level in dts: %u\n", vpu_conf.clk_level);
+		}
+		return 0;
+	}
+#endif
+	vpu_conf.clk_level = vpu_conf.clk_level_dft;
+	printf("vpu clk_level = %u\n", vpu_conf.clk_level);
+	return ret;
+}
+
+int vpu_probe(void)
+{
+	int ret;
+
+	dts_ready = 0;
+#ifdef CONFIG_OF_LIBFDT
+#ifdef CONFIG_DT_PRELOAD
+#ifdef CONFIG_DTB_LOAD_ADDR
+	dt_addr = (char *)CONFIG_DTB_LOAD_ADDR;
+#else
+	dt_addr = (char *)0x0f000000;
+#endif
+	ret = fdt_check_header((const void *)dt_addr);
+	if (ret < 0) {
+		printf("check dts: %s, load default vpu parameters\n",
+			fdt_strerror(ret));
+	} else {
+		dts_ready = 1;
+	}
+#endif
+#endif
+
+	detect_vpu_chip();
+	ret = get_vpu_config();
+	vpu_power_on();
+	set_vpu_clk(vpu_conf.clk_level);
+	//vpu_power_on();
+#ifdef VPU_VCBUS_TEST
+	vcbus_test();
+#endif
+	return ret;
+}
+
+int vpu_remove(void)
+{
+	printf("vpu remove\n");
+	vpu_power_off();
+	return 0;
+}
+
+int vpu_clk_change(int level)
+{
+	unsigned int vpu_clk;
+	unsigned int mux, div;
+	unsigned int reg;
+
+	if (level >= 100) /* regard as vpu_clk */
+		level = get_vpu_clk_level(level);
+
+	if (level >= vpu_conf.clk_level_max) {
+		printf("vpu clk out of supported range\n");
+		printf("vpu clk max level: %u(&uHz)\n",
+			vpu_conf.clk_level_max,
+			vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level_max][0]);
+		return -1;
+	}
+
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		reg = HHI_VPU_CLK_CNTL_GX;
+	else
+		reg = HHI_VPU_CLK_CNTL;
+
+	vpu_conf.clk_level = level;
+	vpu_clk = vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level][0];
+	if (vpu_chip_type == VPU_CHIP_M8) {
+		mux = vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level][1];
+		div = vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level][2];
+		vpu_hiu_write(reg, ((mux << 9) | (div << 0) | (1<<8)));
+	} else {
+		/* switch to second vpu clk patch */
+		mux = vpu_clk_table[vpu_conf.fclk_type][0][1];
+		vpu_hiu_setb(reg, mux, 25, 3);
+		div = vpu_clk_table[vpu_conf.fclk_type][0][2];
+		vpu_hiu_setb(reg, div, 16, 7);
+		vpu_hiu_setb(reg, 1, 24, 1);
+		vpu_hiu_setb(reg, 1, 31, 1);
+		udelay(10);
+		/* adjust first vpu clk frequency */
+		vpu_hiu_setb(reg, 0, 8, 1);
+		mux = vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level][1];
+		vpu_hiu_setb(reg, mux, 9, 3);
+		div = vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level][2];
+		vpu_hiu_setb(reg, div, 0, 7);
+		vpu_hiu_setb(reg, 1, 8, 1);
+		udelay(20);
+		/* switch back to first vpu clk patch */
+		vpu_hiu_setb(reg, 0, 31, 1);
+		vpu_hiu_setb(reg, 0, 24, 1);
+	}
+	if (vpu_chip_type == VPU_CHIP_GXBB) {
+		if (vpu_clk >= (VPU_CLKB_MAX * 1000000))
+			div = 2;
+		else
+			div = 1;
+		vpu_hiu_setb(HHI_VPU_CLKB_CNTL_GX, (div - 1), 0, 8);
+	}
+
+	printf("set vpu clk: %uHz, readback: %uHz(0x%x)\n",
+		vpu_clk, get_vpu_clk(), (vpu_hiu_read(HHI_VPU_CLK_CNTL_GX)));
+	return 0;
+}
+
+void vpu_clk_get(void)
+{
+	unsigned int reg;
+
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		reg = HHI_VPU_CLK_CNTL_GX;
+	else
+		reg = HHI_VPU_CLK_CNTL;
+
+	printf("vpu clk_level: %u, clk: %uHz, reg: 0x%x\n",
+		vpu_conf.clk_level,
+		get_vpu_clk(),
+		vpu_hiu_read(reg));
+}
diff --git a/drivers/vpu/aml_vpu.h b/drivers/vpu/aml_vpu.h
new file mode 100644
index 0000000..cb4bf16
--- /dev/null
+++ b/drivers/vpu/aml_vpu.h
@@ -0,0 +1,158 @@
+
+/*
+ * drivers/vpu/aml_vpu.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __VPU_PARA_H__
+#define __VPU_PARA_H__
+
+enum VPU_Chip_e {
+	VPU_CHIP_M8 = 0,
+	VPU_CHIP_M8B,
+	VPU_CHIP_M8M2,
+	VPU_CHIP_G9TV,
+	VPU_CHIP_G9BB,
+	VPU_CHIP_GXBB,
+	VPU_CHIP_MAX,
+};
+
+/*
+static char *vpu_chip_name[] = {
+	"m8",
+	"m8baby",
+	"m8m2",
+	"g9tv",
+	"g9baby",
+	"gxbaby",
+	"invalid",
+};
+*/
+
+struct VPU_Conf_t {
+	enum VPU_Chip_e  chip_type;
+	unsigned int     clk_level_dft;
+	unsigned int     clk_level_max;
+	unsigned int     clk_level;
+	unsigned int     fclk_type;
+};
+
+/* #define LIMIT_VPU_CLK_LOW */
+
+/* ************************************************ */
+/* VPU frequency table, important. DO NOT modify!! */
+/* ************************************************ */
+/* fixed pll frequency */
+enum fclk_type_e {
+	FCLK_2550M = 0,
+	FCLK_2000M,
+	FCLK_MAX,
+};
+static unsigned int fclk_table[] = { /* unit: MHz */
+	2550,
+	2000,
+};
+
+/* M8: */
+/* freq Max=364M, default=255M */
+#define CLK_LEVEL_DFT_M8       3
+#define CLK_LEVEL_MAX_M8       5
+#define FCLK_TYPE_M8           FCLK_2550M
+/* M8M2: */
+/* freq Max=364M, default=255M */
+#define CLK_LEVEL_DFT_M8M2     3
+#define CLK_LEVEL_MAX_M8M2     5
+#define FCLK_TYPE_M8M2         FCLK_2550M
+/* M8baby */
+/* freq max=212MHz, default=212MHz. */
+#define CLK_LEVEL_DFT_M8B      2
+#define CLK_LEVEL_MAX_M8B      3
+#define FCLK_TYPE_M8B          FCLK_2550M
+/* G9TV */
+/* freq max=696M, default=637M */
+#define CLK_LEVEL_DFT_G9TV     7
+#define CLK_LEVEL_MAX_G9TV     9
+#define FCLK_TYPE_G9TV         FCLK_2550M
+/* G9BB */
+/* freq max=212M, default=212M */
+#define CLK_LEVEL_DFT_G9BB     2
+#define CLK_LEVEL_MAX_G9BB     3
+#define FCLK_TYPE_G9BB         FCLK_2550M
+/* GXBB */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_GXBB     7
+#define CLK_LEVEL_MAX_GXBB     8
+#define FCLK_TYPE_GXBB         FCLK_2000M
+
+/* vpu clk setting */
+enum VPU_mux_e {
+	FCLK_DIV4 = 0,
+	FCLK_DIV3,
+	FCLK_DIV5,
+	FCLK_DIV7,
+	MPLL_CLK1,
+	VID_PLL_CLK,
+	VID2_PLL_CLK,
+	GPLL_CLK,
+};
+
+static unsigned int fclk_div_table[] = {
+	4, /* mux 0 */
+	3, /* mux 1 */
+	5, /* mux 2 */
+	7, /* mux 3 */
+	2, /* invalid */
+};
+
+static unsigned int vpu_clk_table[2][12][3] = {/* compatible for all chip */
+	{ /* m8, m8m2, g9tv, g9bb, fpll=2550M */
+		/* frequency   clk_mux       div */
+		{106250000,    FCLK_DIV3,    7}, /* 0 */
+		{159375000,    FCLK_DIV4,    3}, /* 1 */
+		{212500000,    FCLK_DIV3,    3}, /* 2 */
+		{255000000,    FCLK_DIV5,    1}, /* 3 */
+		{364300000,    FCLK_DIV7,    0}, /* 4 */ /* M8M2 use gp_pll */
+		{425000000,    FCLK_DIV3,    1}, /* 5 */
+		{510000000,    FCLK_DIV5,    0}, /* 6 */
+		{637500000,    FCLK_DIV4,    0}, /* 7 */
+		{696000000,    GPLL_CLK,     0}, /* 8 */ /* G9TV use gp1_pll */
+		{850000000,    FCLK_DIV3,    0}, /* 9 */
+	},
+	{ /* gxbb, fpll=2000M */
+		/* frequency   clk_mux       div */
+		{100000000,    FCLK_DIV5,    3}, /* 0 */
+		{166667000,    FCLK_DIV3,    3}, /* 1 */
+		{200000000,    FCLK_DIV5,    1}, /* 2 */
+		{250000000,    FCLK_DIV4,    1}, /* 3 */
+		{333333000,    FCLK_DIV3,    1}, /* 4 */
+		{400000000,    FCLK_DIV5,    0}, /* 5 */
+		{500000000,    FCLK_DIV4,    0}, /* 6 */
+		{666667000,    FCLK_DIV3,    0}, /* 7 */
+		{696000000,    GPLL_CLK,     0}, /* 8 */ /* invalid */
+		{850000000,    GPLL_CLK,     0}, /* 9 */ /* invalid */
+	},
+};
+
+/* ************************************************ */
+/* extern function */
+/* ************************************************ */
+extern void udelay(unsigned long usec);
+extern int printf(const char *fmt, ...);
+/* ************************************************ */
+
+#endif
diff --git a/drivers/vpu/aml_vpu_reg.h b/drivers/vpu/aml_vpu_reg.h
new file mode 100644
index 0000000..e02093d
--- /dev/null
+++ b/drivers/vpu/aml_vpu_reg.h
@@ -0,0 +1,231 @@
+
+/*
+ * drivers/vpu/aml_vpu_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __VPU_REG_H__
+#define __VPU_REG_H__
+#include <asm/arch/io.h>
+#include "aml_vpu.h"
+
+/* ********************************
+ * register define
+ * ********************************* */
+/* base & offset */
+#define REG_BASE_AOBUS                  (0xc8100000L)
+#define REG_BASE_CBUS                   (0xc1100000L)
+#define REG_BASE_HIU                    (0xc883c000L)
+#define REG_BASE_VCBUS                  (0xd0100000L)
+#define REG_OFFSET_AOBUS(reg)           ((reg))
+#define REG_OFFSET_CBUS(reg)            ((reg << 2))
+#define REG_OFFSET_HIU(reg)             ((reg << 2))
+#define REG_OFFSET_VCBUS(reg)           ((reg << 2))
+
+/* offset address */
+#define AO_RTI_GEN_PWR_SLEEP0           ((0x00 << 10) | (0x3a << 2))
+
+/* M8M2 register */
+#define HHI_GP_PLL_CNTL                 0x1010
+/* G9TV register */
+#define HHI_GP1_PLL_CNTL                0x1016
+#define HHI_GP1_PLL_CNTL2               0x1017
+#define HHI_GP1_PLL_CNTL3               0x1018
+#define HHI_GP1_PLL_CNTL4               0x1019
+
+#define HHI_MEM_PD_REG0                 0x1040
+#define HHI_VPU_MEM_PD_REG0             0x1041
+#define HHI_VPU_MEM_PD_REG1             0x1042
+/* GX register */
+#define HHI_MEM_PD_REG0_GX              0x40
+#define HHI_VPU_MEM_PD_REG0_GX          0x41
+#define HHI_VPU_MEM_PD_REG1_GX          0x42
+
+#define HHI_VPU_CLK_CNTL                0x106f
+/* GX register */
+#define HHI_VPU_CLK_CNTL_GX             0x6f
+#define HHI_VPU_CLKB_CNTL_GX            0x83
+#define HHI_VAPBCLK_CNTL_GX             0x7d
+
+#define RESET0_REGISTER                 0x1101
+#define RESET1_REGISTER                 0x1102
+#define RESET2_REGISTER                 0x1103
+#define RESET3_REGISTER                 0x1104
+#define RESET4_REGISTER                 0x1105
+#define RESET5_REGISTER                 0x1106
+#define RESET6_REGISTER                 0x1107
+#define RESET7_REGISTER                 0x1108
+#define RESET0_MASK                     0x1110
+#define RESET1_MASK                     0x1111
+#define RESET2_MASK                     0x1112
+#define RESET3_MASK                     0x1113
+#define RESET4_MASK                     0x1114
+#define RESET5_MASK                     0x1115
+#define RESET6_MASK                     0x1116
+#define RESET7_MASK                     0x1118
+#define RESET0_LEVEL                    0x1120
+#define RESET1_LEVEL                    0x1121
+#define RESET2_LEVEL                    0x1122
+#define RESET3_LEVEL                    0x1123
+#define RESET4_LEVEL                    0x1124
+#define RESET5_LEVEL                    0x1125
+#define RESET6_LEVEL                    0x1126
+#define RESET7_LEVEL                    0x1127
+/* GX register */
+#define RESET0_REGISTER_GX              0x01
+#define RESET1_REGISTER_GX              0x02
+#define RESET2_REGISTER_GX              0x03
+#define RESET3_REGISTER_GX              0x04
+#define RESET4_REGISTER_GX              0x05
+#define RESET0_MASK_GX                  0x10
+#define RESET1_MASK_GX                  0x11
+#define RESET2_MASK_GX                  0x12
+#define RESET3_MASK_GX                  0x13
+#define RESET4_MASK_GX                  0x14
+#define VPU_RST_REG_GX(addr)            (addr)//(addr & 0xff)
+
+/* memory mapping */
+#define REG_ADDR_AOBUS(reg)             (REG_BASE_AOBUS + REG_OFFSET_AOBUS(reg))
+#define REG_ADDR_CBUS(reg)              (REG_BASE_CBUS + REG_OFFSET_CBUS(reg))
+#define REG_ADDR_HIU(reg)               (REG_BASE_HIU + REG_OFFSET_HIU(reg))
+#define REG_ADDR_RST(reg)               (REG_BASE_RST + REG_OFFSET_RST(reg))
+#define REG_ADDR_VCBUS(reg)             (REG_BASE_VCBUS + REG_OFFSET_VCBUS(reg))
+
+/* ********************************
+ * register access api
+ * ********************************* */
+enum VPU_Chip_e vpu_chip_type;
+
+/* use offset address */
+static inline unsigned int vpu_hiu_read(unsigned int _reg)
+{
+	//return __raw_readl(REG_ADDR_CBUS(_reg));
+	//printf("read reg=0x%x\n", REG_ADDR_HIU(_reg));
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		return *(volatile unsigned int *)(REG_ADDR_HIU(_reg));
+	else
+		return *(volatile unsigned int *)(REG_ADDR_CBUS(_reg));
+};
+
+static inline void vpu_hiu_write(unsigned int _reg, unsigned int _value)
+{
+	//__raw_writel(_value, REG_ADDR_CBUS(_reg));
+	//printf("write reg=%u\n", REG_ADDR_HIU(_reg));
+	if (vpu_chip_type == VPU_CHIP_GXBB)
+		*(volatile unsigned int *)REG_ADDR_HIU(_reg) = (_value);
+	else
+		*(volatile unsigned int *)REG_ADDR_CBUS(_reg) = (_value);
+};
+
+static inline void vpu_hiu_setb(unsigned int _reg,
+		unsigned int _value,
+		unsigned int _start,
+		unsigned int _len)
+{
+	vpu_hiu_write(_reg, ((vpu_hiu_read(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+static inline unsigned int vpu_hiu_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len)
+{
+	return (vpu_hiu_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
+}
+
+static inline void vpu_hiu_set_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_hiu_write(_reg, (vpu_hiu_read(_reg) | (_mask)));
+}
+
+static inline void vpu_hiu_clr_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_hiu_write(_reg, (vpu_hiu_read(_reg) & (~(_mask))));
+}
+
+static inline unsigned int vpu_cbus_read(unsigned int _reg)
+{
+	//return __raw_readl(REG_ADDR_CBUS(_reg));
+	return (*(volatile unsigned int *)REG_ADDR_CBUS(_reg));
+};
+
+static inline void vpu_cbus_write(unsigned int _reg, unsigned int _value)
+{
+	//__raw_writel(_value, REG_ADDR_CBUS(_reg));
+	*(volatile unsigned int *)REG_ADDR_CBUS(_reg) = (_value);
+};
+
+static inline void vpu_cbus_setb(unsigned int _reg,
+		unsigned int _value,
+		unsigned int _start,
+		unsigned int _len)
+{
+	vpu_cbus_write(_reg, ((vpu_cbus_read(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+static inline unsigned int vpu_cbus_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len)
+{
+	return (vpu_cbus_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
+}
+
+static inline void vpu_cbus_set_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_cbus_write(_reg, (vpu_cbus_read(_reg) | (_mask)));
+}
+
+static inline void vpu_cbus_clr_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_cbus_write(_reg, (vpu_cbus_read(_reg) & (~(_mask))));
+}
+
+static inline unsigned int vpu_aobus_read(unsigned int _reg)
+{
+	//return readl(REG_ADDR_AOBUS(_reg));
+	return (*(volatile unsigned int *)REG_ADDR_AOBUS(_reg));
+};
+
+static inline void vpu_aobus_write(unsigned int _reg, unsigned int _value)
+{
+	//writel(_value, REG_ADDR_AOBUS(_reg));
+	*(volatile unsigned int *)REG_ADDR_AOBUS(_reg) = (_value);
+};
+
+static inline void vpu_ao_setb(unsigned int _reg,
+		unsigned int _value,
+		unsigned int _start,
+		unsigned int _len)
+{
+	vpu_aobus_write(_reg, ((vpu_aobus_read(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+static inline unsigned int vpu_vcbus_read(unsigned int _reg)
+{
+	return (*(volatile unsigned int *)REG_ADDR_VCBUS(_reg));
+};
+
+static inline void vpu_vcbus_write(unsigned int _reg, unsigned int _value)
+{
+	*(volatile unsigned int *)REG_ADDR_VCBUS(_reg) = (_value);
+};
+
+#endif
diff --git a/fip/acs_tool.pyc b/fip/acs_tool.pyc
new file mode 100755
index 0000000..413a4c1
Binary files /dev/null and b/fip/acs_tool.pyc differ
diff --git a/fip/bl2_fix.sh b/fip/bl2_fix.sh
new file mode 100755
index 0000000..107d1ed
--- /dev/null
+++ b/fip/bl2_fix.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+declare -i bl2_size=`du -b $1 | awk '{print int($1)}'`
+
+declare -i zero_size=49152-$bl2_size
+
+dd if=/dev/zero of=$2 bs=1 count=$zero_size
+
+cat $1 $2 > $3
+
+rm $2
diff --git a/fip/fip_create b/fip/fip_create
new file mode 100755
index 0000000..2c6518a
Binary files /dev/null and b/fip/fip_create differ
diff --git a/fip/gxb/aml_encrypt_gxb b/fip/gxb/aml_encrypt_gxb
new file mode 100755
index 0000000..ebb7603
Binary files /dev/null and b/fip/gxb/aml_encrypt_gxb differ
diff --git a/fip/gxb/bl2.package b/fip/gxb/bl2.package
new file mode 100644
index 0000000..23925f4
Binary files /dev/null and b/fip/gxb/bl2.package differ
diff --git a/fip/gxb/bl30.bin b/fip/gxb/bl30.bin
new file mode 100755
index 0000000..faed8b0
Binary files /dev/null and b/fip/gxb/bl30.bin differ
diff --git a/fip/gxb/bl301.bin b/fip/gxb/bl301.bin
new file mode 100755
index 0000000..19ca2f1
Binary files /dev/null and b/fip/gxb/bl301.bin differ
diff --git a/fip/gxb/bl31.bin b/fip/gxb/bl31.bin
new file mode 100755
index 0000000..3e9d82d
Binary files /dev/null and b/fip/gxb/bl31.bin differ
diff --git a/fs/fs.c b/fs/fs.c
index ddd751c..a0a5266 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -398,6 +398,8 @@ int do_load(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 	if (ret < 0)
 		return 1;
 
+	flush_dcache_range((unsigned long )addr, (unsigned long )addr+len_read);
+
 	printf("%llu bytes read in %lu ms", len_read, time);
 	if (time > 0) {
 		puts(" (");
diff --git a/include/aml_gpio.h b/include/aml_gpio.h
new file mode 100644
index 0000000..1765f47
--- /dev/null
+++ b/include/aml_gpio.h
@@ -0,0 +1,54 @@
+#ifndef __AML_GPIO__
+#define __AML_GPIO__
+#include <asm/io.h>
+/**
+ * struct meson_reg_desc - a register descriptor
+ *
+ * @reg:	register offset in the regmap
+ * @bit:	bit index in register
+ *
+ * The structure describes the information needed to control pull,
+ * pull-enable, direction, etc. for a single pin
+ */
+struct meson_reg_desc {
+	unsigned int reg;
+	unsigned int bit;
+};
+
+/**
+ * enum meson_reg_type - type of registers encoded in @meson_reg_desc
+ */
+enum meson_reg_type {
+	REG_PULLEN,
+	REG_PULL,
+	REG_DIR,
+	REG_OUT,
+	REG_IN,
+	NUM_REG,
+};
+
+
+
+
+struct meson_bank {
+	const char *name;
+	unsigned int first;
+	unsigned int last;
+	struct meson_reg_desc regs[NUM_REG];
+};
+#define GPIO_REG_BIT(reg, bit) ((reg<<5)|bit)
+#define GPIO_REG(value) ((value>>5))
+#define GPIO_BIT(value) ((value&0x1F))
+#define BIT(bit)    (1<<bit)
+static inline void regmap_update_bits(unsigned long reg,unsigned mask,unsigned val)
+{
+
+	unsigned int tmp, orig;
+	orig = readl(reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	writel(tmp,reg);
+	return;
+}
+
+#endif
diff --git a/include/aml_i2c.h b/include/aml_i2c.h
new file mode 100644
index 0000000..94aa2cc
--- /dev/null
+++ b/include/aml_i2c.h
@@ -0,0 +1,289 @@
+
+/*
+ * include/aml_i2c.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __AML_I2C_H__
+#define __AML_I2C_H__
+
+#include <common.h>
+#include <linux/compiler.h>
+#include <asm/arch/i2c.h>
+
+#define AML_I2C_MAX_TOKENS		8
+
+/*I2C_CONTROL_REG	0x2140/0x2148*/
+struct aml_i2c_reg_ctrl {
+	unsigned int start:1;		/*[0] Set to 1 to start list processing*/
+	/*Setting this bit to 0 while the list processor is operating causes the list
+		processor to abort the current I2C operation and generate an I2C STOP
+		command on the I2C bus.   Normally this bit is set to 1 and left high
+		until processing is complete.  To re-start the list processor with a
+		new list (after a previous list has been exhausted), simply set this
+		bit to zero then to one.*/
+	unsigned int ack_ignore:1;	/*[1] Set to 1 to disable I2C ACK detection.*/
+	/*The I2C bus uses an ACK signal after every byte transfer to detect
+		problems during the transfer.  Current Software implementations of the
+		I2C bus ignore this ACK.  This bit is for compatibility with the current
+		Amlogic software.   This bit should be set to 0 to allow NACK
+		operations to abort I2C bus transactions.  If a NACK occurs, the ERROR
+		bit above will be set. */
+	unsigned int status:1;		/*[2] the status of the List processor*/
+	#define 	I2C_IDLE		0
+	#define 	I2C_RUNNING	1
+	/*	0:	IDLE
+		1: 	Running.  The list processor will enter this state on the clock cycle
+		after the START bit is set.  The software can poll the status register to
+		determine when processing is complete.
+	*/
+	unsigned int error:1;		/*[3] */
+	/*This read only bit is set if the I2C device generates a NACK during writing.
+		This bit is cleared at on the clock cycle after the START bit is set to 1
+		indicating the start of list processing.  Errors can be ignored by setting
+		the ACK_IGNORE bit below.  Errors will be generated on Writes to
+		devices that return NACK instead of ACK.  A NACK is returned by a
+		device if it is unable to accept any more data (for example because it
+		is processing some other real-time function).  In the event of an
+		ERROR, the I2C module will automatically generate a STOP condition
+		on the bus.*/
+	unsigned int cur_token:4;	/*[7:4] the current token being processed*/
+	unsigned int rd_data_cnt:4;/*[11:8] number of bytes READ over the I2C bus*/
+	/*If this value is zero, then no data has been read.  If this value is 1, then
+		bits [7:0] in TOKEN_RDATA_REG0 contains valid data.  The software can
+		read this register after an I2C transaction to get the number of bytes to
+		read from the I2C device*/
+	unsigned int clk_delay:10;	/*[21:12] Quarter clock delay*/
+	/*This value corresponds to period of the SCL clock divided by 4
+		Quarter Clock Delay = * System Clock Frequency
+		For example, if the system clock is 133Mhz, and the I2C clock period
+		is 10uS (100khz), then
+		Quarter Clock Delay = * 133 Mhz = 332
+	*/
+	unsigned int manual_en:1;	/*[22] enable manual mode. */
+	/*Manual I2C mode is controlled by bits 12,13,14 and 15 above.*/
+	unsigned int wrscl:1;		/*[23] Sets the level of the SCL line */
+	/*if manual mode is enabled.  If this bit is '0', then the SCL line is
+		pulled low.  If this bit is '1' then the SCL line is tri-stated.*/
+	unsigned int wrsda:1; 		/*[24] Sets the level of the SDA line */
+	/*if manual mode is enabled.  If this bit is '0', 	then the SDA line is
+		pulled low.  If this bit is '1' then the SDA line is tri-stated.*/
+	unsigned int rdscl:1; 		/*[25] Read back level of the SCL line*/
+	unsigned int rdsda:1; 		/*[26] Read back level of the SDA line*/
+#if 1
+	unsigned int unused:1; 	/*[27]*/
+	unsigned int clk_delay_ext:2; 	/*[29:28]*/
+	unsigned int unused2:2; 	/*[31:30]*/
+#else
+	unsigned int unused:5; 	/*[31:27]*/
+#endif
+};
+
+struct aml_i2c_reg_slave_addr {
+	unsigned int slave_addr:8;	/*[7:0] SLAVE ADDRESS.*/
+	/*This is a 7-bit value for a 7-bit I2C device, or (0xF0 | {A9,A8}) for a
+		10 bit I2C device.  By convention, the slave address is typically
+		stored in by first left shifting it so that it's MSB is D7 (The I2C bus
+		assumes the 7-bit address is left shifted one).  Additionally, since
+		the SLAVE address is always an 7-bit value, D0 is always 0.
+
+		NOTE:  The I2C always transfers 8-bits even for address.  The I2C
+		hardware will use D0 to dictate the direction of the bus.  Therefore,
+		D0 should always be '0' when this register is set.
+	*/
+	unsigned int sda_filter:3;	/*[10:8] SDA FILTER*/
+	/*A filter was added in the SCL input path to allow for filtering of slow
+		rise times.  0 = no filtering, 7 = max filtering*/
+	unsigned int scl_filter:3;	/*[13:11] SCL FILTER*/
+	/*A filter was added in the SCL input path to allow for filtering of slow
+		rise times.  0 = no filtering, 7 = max filtering*/
+#if 1
+	unsigned int unused:2;	/*[15:14]*/
+	unsigned int clk_low_delay:12;	/*[27:16]*/
+	unsigned int clk_low_delay_en:1;	/*[28]*/
+	unsigned int unused2:3;	/*[31:29]*/
+#else
+	unsigned int unused:18;	/*[31:14]*/
+#endif
+};
+
+/*Write data associated with the DATA token should be placed into the
+	I2C_TOKEN_WDATA_REG0 or I2C_TOKEN_WDATA_REG1 registers.
+	Read data associated with the DATA or DATA-LAST token can be read from
+	the I2C_TOKEN_RDATA_REG0 or I2C_TOKEN_RDATA_REG1 registers*/
+
+enum aml_i2c_token {
+	TOKEN_END,
+	TOKEN_START,
+	TOKEN_SLAVE_ADDR_WRITE,
+	TOKEN_SLAVE_ADDR_READ,
+	TOKEN_DATA,
+	TOKEN_DATA_LAST,
+	TOKEN_STOP
+};
+
+struct aml_i2c_reg_master {
+	volatile unsigned int i2c_ctrl;
+	volatile unsigned int i2c_slave_addr;
+	volatile unsigned int i2c_token_list_0;
+	volatile unsigned int i2c_token_list_1;
+	volatile unsigned int i2c_token_wdata_0;
+	volatile unsigned int i2c_token_wdata_1;
+	volatile unsigned int i2c_token_rdata_0;
+	volatile unsigned int i2c_token_rdata_1;
+};
+
+
+struct aml_i2c_reg_slave_ctrl {
+	unsigned int samp_rate:7;	/*[6:0] sampling rate*/
+	/*Defined as MPEG system clock / (value + 1).  The SDA and SCL inputs into
+		the slave module are sampled as a way of filtering the inputs.   A
+		rising or falling edge is determined by when 3 successive samples are
+		either high or low respectively*/
+	unsigned int enable:1;		/*[7] A '1' enables the I2C slave state machine*/
+	unsigned int hold_time:8;	/*[15:8]*/
+	/*Data hold time after the falling edge of SCL.
+		Hold time = (MPEG system clock period) * (value + 1).
+	*/
+	unsigned int slave_addr:8;	/*[23-16]*/
+	/*Bits [7:1] are used to identify the device.
+		Bit [0] is ignored since this corresponds to the R/W bit.*/
+	unsigned int ack_always:1;	/*[24]*/
+	/*Typically the ACK of a slave I2C device is dependent upon the
+		availability of data (if reading) and room to store data (when we are
+		being written).  Our I2C module has a status register that can be read
+		continuously.  This bit can be set if the I2C master wants to
+		continually read the status register. */
+	unsigned int irq_en:1;		/*[25]*/
+	/*If this bit is set, then an interrupt will be sent to the ARC whenever 4
+		bytes have been read or 4 bytes have been written to the I2C slave
+		module.*/
+	unsigned int busy:1;		/*[26] */
+	/*Read only status bit.  '1' indicates that the I2C slave module is sending
+		or receiving data.*/
+	unsigned int rx_rdy:1;		/*[27] */
+	/*This bit is set to '1' by the ARC to indicate to the slave machine that
+		the I2C slave module is ready to receive data.  This bit is cleared by
+		the I2C module when it has received 4 bytes from the I2C master.
+		This bit is also available in the status register that can be read by
+		the I2C master.   The I2C master can read the status register to see
+		when the I2C slave module is ready to receive data.*/
+	unsigned int tx_rdy:1;		/*[28] */
+	/*This bit is set to '1' by the ARC to indicate to the slave machine that
+		the I2C slave module is ready to send data.  This bit is cleared by
+		the I2C module when it has sent 4 bytes to the I2C master.  This bit
+		is also available in the status register that can be read by the I2C
+		master.   The I2C master can read the status register to see when the
+		I2C slave module has data to send.*/
+	unsigned int reg_ptr:3;		/*[31:29] */
+	/*There are 5 internal registers inside the I2C slave module.  The I2C
+		Master sets this value using the byte that follows the address byte
+		in the I2C data stream.  Register 4 (numbered 0,1,4) is the
+		status register.*/
+};
+
+struct aml_i2c_reg_slave{
+	unsigned int i2c_slave_ctrl;
+	unsigned int i2c_slave_tx_data;
+	unsigned int i2c_slave_rx_data;
+};
+
+struct aml_i2c {
+	unsigned int 		i2c_debug;
+	unsigned int		cur_slave_addr;
+	unsigned int 		wait_count;
+	unsigned int 		wait_ack_interval;
+	unsigned int 		wait_read_interval;
+	unsigned int 		wait_xfer_interval;
+	unsigned int 		master_no;/*master a:0 master b:1*/
+	#define				I2C_MASTER_AO		0
+	#define 			I2C_MASTER_A		1
+	#define				I2C_MASTER_B		2
+	#define				I2C_MASTER_C		3
+	#define				I2C_MASTER_D		4
+	unsigned char		token_tag[AML_I2C_MAX_TOKENS];
+	unsigned int 		msg_flags;
+
+	struct aml_i2c_ops* ops;
+
+	struct aml_i2c_reg_master __iomem* master_regs;
+
+//#ifdef CONFIG_I2C_AML_SLAVE
+	struct aml_i2c_reg_slave __iomem* slave_regs;
+
+	struct aml_pinmux_reg_bit	slave_pinmux;
+	unsigned int		slave_dev_addr;
+//#endif
+
+	void __iomem		*reg_base;
+
+	struct aml_pinmux_reg_bit	master_pinmux;
+
+	int			irq;
+	unsigned int		use_pio;/*0: hardware i2c, 1: pio i2c*/
+	unsigned int		master_i2c_speed;
+};
+
+struct aml_i2c_ops {
+     void (*xfer_prepare)(struct aml_i2c *i2c);
+	 int  (*do_address)(struct aml_i2c *i2c, unsigned int addr);
+	 ssize_t  (*read)(struct aml_i2c *i2c, unsigned char *buf, size_t len);
+	 ssize_t  (*write)(struct aml_i2c *i2c, unsigned char *buf, size_t len);
+	 void (*stop)(struct aml_i2c *i2c);
+};
+
+int aml_i2c_init(void);
+int aml_i2c_xfer(struct i2c_msg *msgs, int num);
+
+enum aml_i2c_id{
+	SOFT_I2C = 0,
+	HARD_I2C,
+};
+
+struct i2c_board_info {
+	char type[64];
+	int i2c_id;
+	unsigned short	addr;
+	void (*device_init)(void);
+	void (*device_uninit)(void);
+};
+
+#define I2C_BOARD_INFO(dev_type, dev_addr) \
+	.type = dev_type, .addr = (dev_addr)
+
+struct aml_i2c_device {
+	struct i2c_borad_info *aml_i2c_boards;
+	unsigned dev_num;
+};
+
+#ifdef AML_MESON_BOARD_8726M_2010_11_18_V11
+//Please refer board schematic for detail pin connection
+//@AML8726-M_ARM_DEV_BOARD_2DDR_V1R1.pdf
+//port27-> Red	 (0x7F)
+//port26-> Green (0xBF)
+//port25-> Blue    (0xDF)
+#define I2C_LED_RED       (0x7F)
+#define I2C_LED_GREEN     (0xBF)
+#define I2C_LED_BLUE      (0xDF)
+
+//To set onboard LEDs  on/off
+void board_i2c_led_set(unsigned char byLED, unsigned char byOn);
+
+#endif //AML_MESON_BOARD_8726M_2010_11_18_V11
+
+#endif //__AML_I2C_H__
diff --git a/include/amlogic/aml_v2_burning.h b/include/amlogic/aml_v2_burning.h
new file mode 100644
index 0000000..1ecdad6
--- /dev/null
+++ b/include/amlogic/aml_v2_burning.h
@@ -0,0 +1,31 @@
+/*
+ * \file        aml_v2_burning.h
+ * \brief       common interfaces for version burning
+ *
+ * \version     1.0.0
+ * \date        09/15/2013
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+
+//is the uboot loaded from usb otg
+int is_tpl_loaded_from_usb(void);
+
+//is the uboot loaded from sdcard mmc 0
+//note only sdmmc supported by romcode when external device boot
+int is_tpl_loaded_from_ext_sdmmc(void);
+
+//Check if uboot loaded from external sdmmc or usb otg
+int aml_burn_check_uboot_loaded_for_burn(int flag);
+
+int aml_burn_factory_producing(int flag, bd_t* bis);
+
+//usb producing mode, if tpl loaded from usb pc tool and auto enter producing mode
+int aml_try_factory_usb_burning(int flag, bd_t* bis);
+
+//Auto enter sdcard burning if booted from sdcard and aml_sdc_burn.ini existed
+int aml_try_factory_sdcard_burning(int flag, bd_t* bis);
+
+
diff --git a/include/amlogic/amlkey_if.h b/include/amlogic/amlkey_if.h
new file mode 100644
index 0000000..12cfa34
--- /dev/null
+++ b/include/amlogic/amlkey_if.h
@@ -0,0 +1,34 @@
+/*
+ * \file        amlkey_if.h
+ * \brief       APIs of secure key for users
+ *
+ * \version     1.0.0
+ * \date        15/07/10
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __AMLKEY_IF_H__
+#define __AMLKEY_IF_H__
+
+#define AMLKEY_NAME_LEN_MAX     (80)
+//1.init
+	int32_t amlkey_init(uint8_t *seed, uint32_t len);	//confirm
+//2. query if the key already programmed
+	int32_t amlkey_isexsit(const uint8_t * name);	//exsit 1, non 0
+//3. query if the prgrammed key is secure
+	int32_t amlkey_issecure(const uint8_t * name);	//secure 1, non 0
+//4. actual bytes of key value
+	ssize_t amlkey_size(const uint8_t *name);	//actully size
+//5. read non-secure key in bytes, return byets readback actully.
+	ssize_t amlkey_read(const uint8_t *name, uint8_t *buffer, uint32_t len)	;
+
+//6.write secure/non-secure key in bytes , return byets readback actully
+	ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t secure);	//
+
+//7. get the hash value of programmed secure key | 32bytes length, sha256
+	int32_t amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash);
+
+#endif// #ifndef __AMLKEY_IF_H__
+
diff --git a/include/amlogic/canvas.h b/include/amlogic/canvas.h
new file mode 100644
index 0000000..c960b06
--- /dev/null
+++ b/include/amlogic/canvas.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CANVAS_H
+#define CANVAS_H
+
+#define DMC_REG_BASE            0xc8838000
+#define DC_CAV_LUT_DATAL        (0x12 << 2)
+#define DC_CAV_LUT_DATAH        (0x13 << 2)
+#define DC_CAV_LUT_ADDR         (0x14 << 2)
+#define DC_CAV_LUT_RDATAL       (0x15 << 2)
+#define DC_CAV_LUT_RDATAH       (0x16 << 2)
+
+#define CANVAS_ADDR_LMASK       0x1fffffff
+#define CANVAS_WIDTH_LMASK      0x7
+#define CANVAS_WIDTH_LWID       3
+#define CANVAS_WIDTH_LBIT       29
+
+#define CANVAS_WIDTH_HMASK      0x1ff
+#define CANVAS_WIDTH_HBIT       0
+#define CANVAS_HEIGHT_MASK      0x1fff
+#define CANVAS_HEIGHT_BIT       9
+#define CANVAS_YWRAP            (1<<23)
+#define CANVAS_XWRAP            (1<<22)
+#define CANVAS_ADDR_NOWRAP      0x00
+#define CANVAS_ADDR_WRAPX       0x01
+#define CANVAS_ADDR_WRAPY       0x02
+#define CANVAS_BLKMODE_MASK     3
+#define CANVAS_BLKMODE_BIT      24
+#define CANVAS_BLKMODE_LINEAR   0x00
+#define CANVAS_BLKMODE_32X32    0x01
+#define CANVAS_BLKMODE_64X32    0x02
+
+#define CANVAS_LUT_INDEX_BIT    0
+#define CANVAS_LUT_INDEX_MASK   0x7
+#define CANVAS_LUT_WR_EN        (0x2 << 8)
+#define CANVAS_LUT_RD_EN        (0x1 << 8)
+
+typedef struct {
+	ulong addr;
+	u32 width;
+	u32 height;
+	u32 wrap;
+	u32 blkmode;
+} canvas_t;
+
+#define OSD1_CANVAS_INDEX 0x40
+#define OSD2_CANVAS_INDEX 0x43
+
+extern void canvas_config(u32 index, ulong addr, u32 width,
+			  u32 height, u32 wrap, u32 blkmode);
+
+extern void canvas_read(u32 index, canvas_t *p);
+
+extern void canvas_copy(unsigned src, unsigned dst);
+
+extern void canvas_update_addr(u32 index, u32 addr);
+
+extern unsigned int canvas_get_addr(u32 index);
+
+#endif /* CANVAS_H */
diff --git a/include/amlogic/color.h b/include/amlogic/color.h
new file mode 100644
index 0000000..9839d11
--- /dev/null
+++ b/include/amlogic/color.h
@@ -0,0 +1,51 @@
+/*
+ * include/linux/amlogic/vout/color.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _COLOR_H_
+#define _COLOR_H_
+
+enum color_index_e {
+	COLOR_INDEX_NULL = 0,
+	COLOR_INDEX_02_PAL4 = 2,
+	COLOR_INDEX_04_PAL16 = 4,
+	COLOR_INDEX_08_PAL256 = 8,
+	COLOR_INDEX_16_655 = 9,
+	COLOR_INDEX_16_844 = 10,
+	COLOR_INDEX_16_6442 = 11 ,
+	COLOR_INDEX_16_4444_R = 12,
+	COLOR_INDEX_16_4642_R = 13,
+	COLOR_INDEX_16_1555_A = 14,
+	COLOR_INDEX_16_4444_A = 15,
+	COLOR_INDEX_16_565 = 16,
+
+	COLOR_INDEX_24_6666_A = 19,
+	COLOR_INDEX_24_6666_R = 20,
+	COLOR_INDEX_24_8565 = 21,
+	COLOR_INDEX_24_5658 = 22,
+	COLOR_INDEX_24_888_B = 23,
+	COLOR_INDEX_24_RGB = 24,
+
+	COLOR_INDEX_32_BGRA = 29,
+	COLOR_INDEX_32_ABGR = 30,
+	COLOR_INDEX_32_RGBA = 31,
+	COLOR_INDEX_32_ARGB = 32,
+
+	COLOR_INDEX_YUV_422 = 33,
+};
+
+#endif
diff --git a/include/amlogic/cvbs.h b/include/amlogic/cvbs.h
new file mode 100644
index 0000000..af93551
--- /dev/null
+++ b/include/amlogic/cvbs.h
@@ -0,0 +1,11 @@
+#ifndef __CVBS_H__
+#define __CVBS_H__
+
+void cvbs_show_valid_vmode(void);
+int cvbs_set_vmode(char* vmode_name);
+int cvbs_set_bist(char* bist_mode);
+int cvbs_set_vdac(int status);
+int cvbs_reg_debug(int argc, char* const argv[]);
+
+#endif
+
diff --git a/include/amlogic/enc_clk_config.h b/include/amlogic/enc_clk_config.h
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/include/amlogic/enc_clk_config.h
@@ -0,0 +1 @@
+
diff --git a/include/amlogic/fb.h b/include/amlogic/fb.h
new file mode 100644
index 0000000..ff324d7
--- /dev/null
+++ b/include/amlogic/fb.h
@@ -0,0 +1,392 @@
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#ifdef __KERNEL__
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor_user)
+#else
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+#endif
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	__u32 smem_len;			/* Length of frame buffer mem */
+	__u32 type;			/* see FB_TYPE_*		*/
+	__u32 type_aux;			/* Interleave for interleaved Planes */
+	__u32 visual;			/* see FB_VISUAL_*		*/
+	__u16 xpanstep;			/* zero if no hardware panning  */
+	__u16 ypanstep;			/* zero if no hardware panning  */
+	__u16 ywrapstep;		/* zero if no hardware ywrap    */
+	__u32 line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	__u32 mmio_len;			/* Length of Memory Mapped I/O  */
+	__u32 accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	__u16 reserved[3];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the pallette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	__u32 offset;			/* beginning of bitfield	*/
+	__u32 length;			/* length of bitfield		*/
+	__u32 msb_right;		/* != 0 : Most significant bit is */
+					/* right */
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	__u32 xres;			/* visible resolution		*/
+	__u32 yres;
+	__u32 xres_virtual;		/* virtual resolution		*/
+	__u32 yres_virtual;
+	__u32 xoffset;			/* offset from virtual to visible */
+	__u32 yoffset;			/* resolution			*/
+
+	__u32 bits_per_pixel;		/* guess what			*/
+	__u32 grayscale;		/* != 0 Graylevels instead of colors */
+
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/
+
+	__u32 nonstd;			/* != 0 Non standard pixel format */
+
+	__u32 activate;			/* see FB_ACTIVATE_*		*/
+
+	__u32 height;			/* height of picture in mm    */
+	__u32 width;			/* width of picture in mm     */
+
+	__u32 accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	__u32 pixclock;			/* pixel clock in ps (pico seconds) */
+	__u32 left_margin;		/* time from sync to picture	*/
+	__u32 right_margin;		/* time from picture to sync	*/
+	__u32 upper_margin;		/* time from sync to picture	*/
+	__u32 lower_margin;
+	__u32 hsync_len;		/* length of horizontal sync	*/
+	__u32 vsync_len;		/* length of vertical sync	*/
+	__u32 sync;			/* see FB_SYNC_*		*/
+	__u32 vmode;			/* see FB_VMODE_*		*/
+	__u32 rotate;			/* angle we rotate counter clockwise */
+	__u32 reserved[5];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	__u32 start;			/* First entry	*/
+	__u32 len;			/* Number of entries */
+	__u16 *red;			/* Red values	*/
+	__u16 *green;
+	__u16 *blue;
+	__u16 *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	__u32 console;
+	__u32 framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	__u32 flags;			/* FB_VBLANK flags */
+	__u32 count;			/* counter of retraces since boot */
+	__u32 vcount;			/* current scanline position */
+	__u32 hcount;			/* current scandot position */
+	__u32 reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	__u32 dx;
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 sx;
+	__u32 sy;
+};
+
+struct fb_fillrect {
+	__u32 dx;	/* screen-relative */
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 color;
+	__u32 rop;
+};
+
+struct fb_image {
+	__u32 dx;		/* Where to place image */
+	__u32 dy;
+	__u32 width;		/* Size of image */
+	__u32 height;
+	__u32 fg_color;		/* Only used when a mono bitmap */
+	__u32 bg_color;
+	__u8  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	__u16 x, y;
+};
+
+struct fb_cursor {
+	__u16 set;		/* what to set */
+	__u16 enable;		/* cursor on/off */
+	__u16 rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+#ifdef CONFIG_FB_BACKLIGHT
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+#endif
+
+#endif /* _LINUX_FB_H */
diff --git a/include/amlogic/hdmi.h b/include/amlogic/hdmi.h
new file mode 100644
index 0000000..5ed925a
--- /dev/null
+++ b/include/amlogic/hdmi.h
@@ -0,0 +1,252 @@
+#ifndef __HDMI_H__
+#define __HDMI_H__
+
+/* Little-Endian format */
+enum scdc_addr {
+	SINK_VER = 0x01,
+	SOURCE_VER, /* RW */
+	UPDATE_0 = 0x10, /* RW */
+	UPDATE_1, /* RW */
+	TMDS_CFG = 0x20, /* RW */
+	SCRAMBLER_ST,
+	CONFIG_0 = 0x30, /* RW */
+	STATUS_FLAGS_0 = 0x40,
+	STATUS_FLAGS_1,
+	ERR_DET_0_L = 0x50,
+	ERR_DET_0_H,
+	ERR_DET_1_L,
+	ERR_DET_1_H,
+	ERR_DET_2_L,
+	ERR_DET_2_H,
+	ERR_DET_CHKSUM,
+	TEST_CONFIG_0 = 0xC0, /* RW */
+	MANUFACT_IEEE_OUI_2 = 0xD0,
+	MANUFACT_IEEE_OUI_1,
+	MANUFACT_IEEE_OUI_0,
+	DEVICE_ID = 0xD3, /* 0xD3 ~ 0xDD */
+	/* RW   0xDE ~ 0xFF */
+	MANUFACT_SPECIFIC = 0xDE,
+};
+
+/* HDMI VIC definitions */
+enum hdmi_vic {
+	/* Refer to CEA 861-D */
+	HDMI_unkown = 0,
+	HDMI_640x480p60_4x3 = 1,
+	HDMI_720x480p60_4x3 = 2,
+	HDMI_720x480p60_16x9 = 3,
+	HDMI_1280x720p60_16x9 = 4,
+	HDMI_1920x1080i60_16x9 = 5,
+	HDMI_720x480i60_4x3 = 6,
+	HDMI_720x480i60_16x9 = 7,
+	HDMI_720x240p60_4x3 = 8,
+	HDMI_720x240p60_16x9 = 9,
+	HDMI_2880x480i60_4x3 = 10,
+	HDMI_2880x480i60_16x9 = 11,
+	HDMI_2880x240p60_4x3 = 12,
+	HDMI_2880x240p60_16x9 = 13,
+	HDMI_1440x480p60_4x3 = 14,
+	HDMI_1440x480p60_16x9 = 15,
+	HDMI_1920x1080p60_16x9 = 16,
+	HDMI_720x576p50_4x3 = 17,
+	HDMI_720x576p50_16x9 = 18,
+	HDMI_1280x720p50_16x9 = 19,
+	HDMI_1920x1080i50_16x9 = 20,
+	HDMI_720x576i50_4x3 = 21,
+	HDMI_720x576i50_16x9 = 22,
+	HDMI_720x288p_4x3 = 23,
+	HDMI_720x288p_16x9 = 24,
+	HDMI_2880x576i50_4x3 = 25,
+	HDMI_2880x576i50_16x9 = 26,
+	HDMI_2880x288p50_4x3 = 27,
+	HDMI_2880x288p50_16x9 = 28,
+	HDMI_1440x576p_4x3 = 29,
+	HDMI_1440x576p_16x9 = 30,
+	HDMI_1920x1080p50_16x9 = 31,
+	HDMI_1920x1080p24_16x9 = 32,
+	HDMI_1920x1080p25_16x9 = 33,
+	HDMI_1920x1080p30_16x9 = 34,
+	HDMI_2880x480p60_4x3 = 35,
+	HDMI_2880x480p60_16x9 = 36,
+	HDMI_2880x576p50_4x3 = 37,
+	HDMI_2880x576p50_16x9 = 38,
+	HDMI_1920x1080i_t1250_50_16x9 = 39,
+	HDMI_1920x1080i100_16x9 = 40,
+	HDMI_1280x720p100_16x9 = 41,
+	HDMI_720x576p100_4x3 = 42,
+	HDMI_720x576p100_16x9 = 43,
+	HDMI_720x576i100_4x3 = 44,
+	HDMI_720x576i100_16x9 = 45,
+	HDMI_1920x1080i120_16x9 = 46,
+	HDMI_1280x720p120_16x9 = 47,
+	HDMI_720x480p120_4x3 = 48,
+	HDMI_720x480p120_16x9 = 49,
+	HDMI_720x480i120_4x3 = 50,
+	HDMI_720x480i120_16x9 = 51,
+	HDMI_720x576p200_4x3 = 52,
+	HDMI_720x576p200_16x9 = 53,
+	HDMI_720x576i200_4x3 = 54,
+	HDMI_720x576i200_16x9 = 55,
+	HDMI_720x480p240_4x3 = 56,
+	HDMI_720x480p240_16x9 = 57,
+	HDMI_720x480i240_4x3 = 58,
+	HDMI_720x480i240_16x9 = 59,
+	/* Refet to CEA 861-F */
+	HDMI_1280x720p24_16x9 = 60,
+	HDMI_1280x720p25_16x9 = 61,
+	HDMI_1280x720p30_16x9 = 62,
+	HDMI_1920x1080p120_16x9 = 63,
+	HDMI_1920x1080p100_16x9 = 64,
+	HDMI_1280x720p24_64x27 = 65,
+	HDMI_1280x720p25_64x27 = 66,
+	HDMI_1280x720p30_64x27 = 67,
+	HDMI_1280x720p50_64x27 = 68,
+	HDMI_1280x720p60_64x27 = 69,
+	HDMI_1280x720p100_64x27 = 70,
+	HDMI_1280x720p120_64x27 = 71,
+	HDMI_1920x1080p24_64x27 = 72,
+	HDMI_1920x1080p25_64x27 = 73,
+	HDMI_1920x1080p30_64x27 = 74,
+	HDMI_1920x1080p50_64x27 = 75,
+	HDMI_1920x1080p60_64x27 = 76,
+	HDMI_1920x1080p100_64x27 = 77,
+	HDMI_1920x1080p120_64x27 = 78,
+	HDMI_1680x720p24_64x27 = 79,
+	HDMI_1680x720p25_64x27 = 80,
+	HDMI_1680x720p30_64x27 = 81,
+	HDMI_1680x720p50_64x27 = 82,
+	HDMI_1680x720p60_64x27 = 83,
+	HDMI_1680x720p100_64x27 = 84,
+	HDMI_1680x720p120_64x27 = 85,
+	HDMI_2560x1080p24_64x27 = 86,
+	HDMI_2560x1080p25_64x27 = 87,
+	HDMI_2560x1080p30_64x27 = 88,
+	HDMI_2560x1080p50_64x27 = 89,
+	HDMI_2560x1080p60_64x27 = 90,
+	HDMI_2560x1080p100_64x27 = 91,
+	HDMI_2560x1080p120_64x27 = 92,
+	HDMI_3840x2160p24_16x9 = 93,
+	HDMI_3840x2160p25_16x9 = 94,
+	HDMI_3840x2160p30_16x9 = 95,
+	HDMI_3840x2160p50_16x9 = 96,
+	HDMI_3840x2160p60_16x9 = 97,
+	HDMI_4096x2160p24_256x135 = 98,
+	HDMI_4096x2160p25_256x135 = 99,
+	HDMI_4096x2160p30_256x135 = 100,
+	HDMI_4096x2160p50_256x135 = 101,
+	HDMI_4096x2160p60_256x135 = 102,
+	HDMI_3840x2160p24_64x27 = 103,
+	HDMI_3840x2160p25_64x27 = 104,
+	HDMI_3840x2160p30_64x27 = 105,
+	HDMI_3840x2160p50_64x27 = 106,
+	HDMI_3840x2160p60_64x27 = 107,
+	HDMI_RESERVED = 108,
+};
+
+/* CEA TIMING STRUCT DEFINITION */
+struct hdmi_cea_timing {
+	unsigned int pixel_freq; /* Unit: 1000 */
+	unsigned int h_freq; /* Unit: Hz */
+	unsigned int v_freq; /* Unit: 0.001 Hz */
+	unsigned int vsync_polarity:1; /* 1: positive  0: negative */
+	unsigned int hsync_polarity:1;
+	unsigned short h_active;
+	unsigned short h_total;
+	unsigned short h_blank;
+	unsigned short h_front;
+	unsigned short h_sync;
+	unsigned short h_back;
+	unsigned short v_active;
+	unsigned short v_total;
+	unsigned short v_blank;
+	unsigned short v_front;
+	unsigned short v_sync;
+	unsigned short v_back;
+	unsigned short v_sync_ln;
+};
+
+enum hdmi_color_depth {
+	HDMI_COLOR_DEPTH_24B = 4,
+	HDMI_COLOR_DEPTH_30B = 5,
+	HDMI_COLOR_DEPTH_36B = 6,
+	HDMI_COLOR_DEPTH_48B = 7,
+};
+
+enum hdmi_color_format {
+	HDMI_COLOR_FORMAT_RGB,
+	HDMI_COLOR_FORMAT_444,
+	HDMI_COLOR_FORMAT_422,
+	HDMI_COLOR_FORMAT_420,
+};
+
+enum hdmi_color_range {
+	HDMI_COLOR_RANGE_LIM,
+	HDMI_COLOR_RANGE_FUL,
+};
+
+enum hdmi_audio_packet {
+	HDMI_AUDIO_PACKET_SMP = 0x02,
+	HDMI_AUDIO_PACKET_1BT = 0x07,
+	HDMI_AUDIO_PACKET_DST = 0x08,
+	HDMI_AUDIO_PACKET_HBR = 0x09,
+};
+
+/* get hdmi cea timing
+ * t: struct hdmi_cea_timing *
+ */
+#define GET_TIMING(name) (t->name)
+
+struct hdmi_format_para {
+	enum hdmi_vic vic;
+	char *name; /* full name, 1280x720p60hz */
+	char *sname; /* short name, 1280x720p60hz -> 720p60hz */
+	unsigned int pixel_repetition_factor;
+	unsigned int progress_mode:1; /* 0: Interlace  1: Progressive */
+	unsigned int scrambler_en:1;
+	unsigned int tmds_clk_div40:1;
+	unsigned int tmds_clk; /* Unit: 1000 */
+	struct hdmi_cea_timing timing;
+};
+
+struct hdmi_support_mode {
+	enum hdmi_vic vic;
+	char *sname;
+	char y420;
+};
+
+struct hdmitx_dev {
+	unsigned char rx_edid[512]; /* some RX may exceeds 256Bytes */
+	struct {
+		int (*get_hpd_state)(void);
+		int (*read_edid)(unsigned char *buf, unsigned char addr,
+				 unsigned char len);
+		void (*turn_off)(void);
+		void (*list_support_modes)(void);
+		void (*dump_regs)(void);
+		void (*test_bist)(unsigned int mode);
+	} HWOp;
+	enum hdmi_vic vic;
+	unsigned int mode420;
+	unsigned int dc30;
+};
+
+struct hdmi_format_para *hdmi_get_fmt_paras(enum hdmi_vic vic);
+enum hdmi_vic hdmi_get_fmt_vic(char const *name);
+void hdmi_tx_set(struct hdmitx_dev *hdev);
+/*
+ * Must be called at uboot
+ */
+void hdmi_tx_init(void);
+
+extern struct hdmitx_dev hdmitx_device;
+
+#ifndef printk
+#define printk printf
+#endif
+#ifndef pr_info
+#define pr_info printf
+#endif
+
+#define hdmitx_debug() /* printf("hd: %s[%d]\n", __func__, __LINE__) */
+
+#endif
diff --git a/include/amlogic/instaboot.h b/include/amlogic/instaboot.h
new file mode 100644
index 0000000..cfcae9e
--- /dev/null
+++ b/include/amlogic/instaboot.h
@@ -0,0 +1,24 @@
+#ifndef __INSTABOOT_H_
+#define __INSTABOOT_H_
+
+#define __NEW_UTS_LEN 64
+
+struct new_utsname {
+	char sysname[__NEW_UTS_LEN + 1];
+	char nodename[__NEW_UTS_LEN + 1];
+	char release[__NEW_UTS_LEN + 1];
+	char version[__NEW_UTS_LEN + 1];
+	char machine[__NEW_UTS_LEN + 1];
+	char domainname[__NEW_UTS_LEN + 1];
+};
+
+struct instaboot_info {
+	struct new_utsname uts;
+	unsigned int version_code;
+};
+#define INSTABOOT_SIG	"INSTABOOT"
+
+extern int get_instaboot_header(struct instaboot_info* ib_info);
+extern int fdt_instaboot(void *fdt);
+
+#endif /* __INSTABOOT_H_ */
diff --git a/include/amlogic/keyunify.h b/include/amlogic/keyunify.h
new file mode 100644
index 0000000..c89865f
--- /dev/null
+++ b/include/amlogic/keyunify.h
@@ -0,0 +1,56 @@
+/*
+ * \file        keymanage.h
+ * \brief       API from drivers/keymange
+ *
+ * \version     1.0.0
+ * \date        15/07/7
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __KEYUNIFY_H__
+#define __KEYUNIFY_H__
+
+//APIs of key_unify*: unify interfaces for nandkeys/emmckeys/efuse keys
+
+int key_unify_init(const char* seednum, const char* dtbaddr);
+
+int key_unify_uninit(void);
+
+//keyType: user type to define how to parse/check the key value before burn to target
+int key_unify_write(const char* keyname, const void* keydata, const unsigned datalen);
+
+int key_unify_read(const char* keyname, void* keydata, const unsigned bufLen);
+
+int key_unify_query_size(const char* keyname, ssize_t* keysize);
+
+int key_unify_query_exist(const char* keyname, int* exist);
+
+int key_unify_query_secure(const char* keyname, int* isSecure);
+
+int key_unify_query_canOverWrite(const char* keyname, int* canOverWrite);
+
+//Does the key configured in dts
+int key_unify_query_key_has_configure(const char* keyname);
+
+//Another APIs with APP concers, like special flower hdcp2
+//These APIs are based on key_unify_*
+//
+int key_manage_init(const char* seednum, const char* dtbaddr);
+int key_manage_exit(void);
+
+int key_manage_write(const char* keyname, const void* keydata, const unsigned datalen);
+
+int key_manage_read(const char* keyname, void* keydata, const unsigned bufLen);
+
+int key_manage_query_size(const char* keyname, ssize_t* keysize);
+
+int key_manage_query_exist(const char* keyname, int* exist);
+
+int key_manage_query_secure(const char* keyname, int* isSecure);
+
+int key_manage_query_canOverWrite(const char* keyname, int* canOverWrite);
+
+#endif// #ifndef __KEYUNIFY_H__
+
diff --git a/include/amlogic/secure_storage.h b/include/amlogic/secure_storage.h
new file mode 100644
index 0000000..3c567ed
--- /dev/null
+++ b/include/amlogic/secure_storage.h
@@ -0,0 +1,37 @@
+#ifndef __SECURE_STORAGE_H__
+#define __SECURE_STORAGE_H__
+
+/* return value*/
+#define RET_OK		0
+#define RET_EFAIL	1
+#define RET_EINVAL	2
+#define RET_EMEM	3
+
+/* Attribute*/
+#define OBJ_ATTR_SECURE	(1<<0)
+
+#ifdef CONFIG_SECURE_STORAGE
+/* funtion name: secure_storage_write
+ * keyname : key name is ascii string
+ * keybuf : key buf
+ * keylen : key buf len
+ * keyattr: Secure/Normal, ...
+ *
+ * return  0: ok, 0x1fe: no space, other fail
+ * */
+int32_t secure_storage_write(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t keyattr);
+int32_t secure_storage_read(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t *reallen);
+int32_t secure_storage_query(uint8_t *keyname, uint32_t *retval);
+int32_t secure_storage_tell(uint8_t *keyname, uint32_t *retval);
+int32_t secure_storage_verify(uint8_t *keyname, uint8_t *hashbuf);
+int32_t secure_storage_status(uint8_t *keyname, uint32_t *retval);
+void *secure_storage_getbuffer(uint32_t *size);
+void secure_storage_notifier(void);
+int32_t secure_storage_list(uint8_t *listbuf, uint32_t buflen,
+				uint32_t *readlen);
+int32_t secure_storage_remove(uint8_t *keyname);
+#endif
+
+#endif
diff --git a/include/amlogic/storage_if.h b/include/amlogic/storage_if.h
new file mode 100644
index 0000000..68bc7f3
--- /dev/null
+++ b/include/amlogic/storage_if.h
@@ -0,0 +1,73 @@
+/*
+ * \file        storage_if.h
+ * \brief       interfaces declarations for storage operations
+ *
+ * \version     1.0.0
+ * \date        2013-7-16
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __STOARGE_IF_H__
+#define __STOARGE_IF_H__
+
+
+/***
+upgrade_read_ops:
+
+partition_name: env / logo / recovery /boot / system /cache /media
+
+***/
+int store_read_ops(unsigned char *partition_name,unsigned char * buf, uint64_t off, uint64_t size);
+
+
+/***
+upgrade_write_ops:
+
+partition_name: env / logo / recovery /boot / system /cache /media
+
+***/
+int store_write_ops(unsigned char *partition_name,unsigned char * buf,uint64_t off, uint64_t size);
+
+
+/***
+upgrade_write_ops:
+
+partition_name: env / logo / recovery /boot / system /cache /media
+
+***/
+int store_get_partititon_size(unsigned char *partition_name, uint64_t *size);
+
+
+/***
+upgrade_erase_ops:
+
+partition_name: boot / data
+
+flag = 0; indicate erase partition ;
+flag = 1; indicate scurb whole nand;
+
+***/
+int store_erase_ops(unsigned char *par_name, uint64_t off, uint64_t size, unsigned char flag);
+
+/***
+bootloader:
+***/
+int store_boot_read(unsigned char * buf, uint64_t off, uint64_t size);
+
+int store_boot_write(unsigned char * buf,uint64_t off, uint64_t size);
+
+int store_init(unsigned  flag);
+
+int store_exit(void);
+
+//dtb read/write
+int store_dtb_rw(void* buf, unsigned dtbSz, int isWrite);
+
+//key read/write
+int store_key_read(uint8_t * buffer,  uint32_t length);
+int store_key_write(uint8_t * buffer,  uint32_t length);
+
+#endif//ifndef __STOARGE_IF_H__
+
diff --git a/include/amlogic/storagekey.h b/include/amlogic/storagekey.h
new file mode 100644
index 0000000..f258b82
--- /dev/null
+++ b/include/amlogic/storagekey.h
@@ -0,0 +1,57 @@
+#ifndef __STORAGEKEY_H__
+#define __STORAGEKEY_H__
+
+
+/* storage key interface */
+/**
+ *1.amlkey_init: init storage key
+ * return ok 0, fail not 0
+ */
+extern int32_t amlkey_init(uint8_t *seed, uint32_t len);
+
+/**
+ *2. amlkey_isexsit: query key, already programmed ?
+ * return: exsit 1, non 0
+ */
+extern int32_t amlkey_isexsit(const uint8_t * name);
+
+/**
+ * 3. query if the key is secure
+ * return secure 1, non 0;
+ */
+extern int32_t amlkey_issecure(const uint8_t * name);
+
+/**
+ * 4. amlkey_size: actual bytes of key value
+ *  return actual size.
+ */
+extern ssize_t amlkey_size(const uint8_t *name);
+
+/**
+ *5. amlkey_read: read non-secure key in bytes.
+ * return actual size read back; 0 means read failed!
+ */
+extern ssize_t amlkey_read(const uint8_t *name,
+				uint8_t *buffer, uint32_t len);
+
+/**
+ * 6. amlkey_write: write secure/non-secure key in bytes.
+ * return actual size write down. 0 means write failed!
+ */
+extern ssize_t amlkey_write(const uint8_t *name,
+				uint8_t *buffer, uint32_t len, uint32_t secure);
+
+/**
+ * 7. get the hash value of programmed secure key | 32bytes length, sha256
+ * return success 0, fail -1
+ */
+extern int32_t amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash);
+
+/**
+ * 8. amlkey_del: del key by name
+ * return success 0, fail non-0.
+ */
+extern int32_t amlkey_del(const uint8_t * name);
+
+
+#endif /* __STORAGEKEY_H__ */
diff --git a/include/amlogic/vinfo.h b/include/amlogic/vinfo.h
new file mode 100644
index 0000000..9855e26
--- /dev/null
+++ b/include/amlogic/vinfo.h
@@ -0,0 +1,150 @@
+#ifndef __VINFO_H_
+#define __VINFO_H_
+
+typedef struct vidinfo {
+	ushort	vl_col;		/* Number of columns (i.e. 160) */
+	ushort	vl_row;		/* Number of rows (i.e. 100) */
+	u_char	vl_bpix;		/* Bits per pixel, 0 = 1 */
+
+	void		*vd_base;	/* Start of framebuffer memory	*/
+
+	void		*vd_console_address;	/* Start of console buffer	*/
+	short 	console_col;
+	short 	console_row;
+
+	int 		vd_color_fg;
+	int 		vd_color_bg;
+
+	int		max_bl_level;
+
+	ushort	*cmap;		/* Pointer to the colormap */
+	void	*priv;			/* Pointer to driver-specific data */
+
+} vidinfo_t;
+
+
+/************************************************************************/
+/* ** BITMAP DISPLAY SUPPORT						*/
+/************************************************************************/
+#if defined(CONFIG_CMD_BMP) || defined(CONFIG_SPLASH_SCREEN)
+# include <bmp_layout.h>
+# include <asm/byteorder.h>
+#endif
+
+/*
+ *  Information about displays we are using. This is for configuring
+ *  the LCD controller and memory allocation. Someone has to know what
+ *  is connected, as we can't autodetect anything.
+ */
+#define CONFIG_SYS_HIGH	0	/* Pins are active high			*/
+#define CONFIG_SYS_LOW		1	/* Pins are active low			*/
+
+#define LCD_COLOR2	2
+#define LCD_COLOR4	4
+#define LCD_COLOR8	8
+#define LCD_COLOR16	16
+#define LCD_COLOR24	24
+#define LCD_COLOR32	32
+
+
+/*----------------------------------------------------------------------*/
+#if defined(CONFIG_LCD_INFO_BELOW_LOGO)
+# define LCD_INFO_X		0
+# define LCD_INFO_Y		(BMP_LOGO_HEIGHT + VIDEO_FONT_HEIGHT)
+#elif defined(CONFIG_LCD_LOGO)
+# define LCD_INFO_X		(BMP_LOGO_WIDTH + 4 * VIDEO_FONT_WIDTH)
+# define LCD_INFO_Y		(VIDEO_FONT_HEIGHT)
+#else
+# define LCD_INFO_X		(VIDEO_FONT_WIDTH)
+# define LCD_INFO_Y		(VIDEO_FONT_HEIGHT)
+#endif
+
+/* Calculate nr. of bits per pixel  and nr. of colors */
+#define NBITS(bit_code)		(bit_code)
+#define NCOLORS(bit_code)	(1 << NBITS(bit_code))
+
+/************************************************************************/
+/* ** CONSOLE CONSTANTS							*/
+/************************************************************************/
+#if LCD_BPP == LCD_MONOCHROME
+
+/*
+ * Simple black/white definitions
+ */
+# define CONSOLE_COLOR_BLACK	0
+# define CONSOLE_COLOR_WHITE	1	/* Must remain last / highest	*/
+
+#elif LCD_BPP == LCD_COLOR8
+
+/*
+ * 8bpp color definitions
+ */
+# define CONSOLE_COLOR_BLACK	0
+# define CONSOLE_COLOR_RED	1
+# define CONSOLE_COLOR_GREEN	2
+# define CONSOLE_COLOR_YELLOW	3
+# define CONSOLE_COLOR_BLUE	4
+# define CONSOLE_COLOR_MAGENTA	5
+# define CONSOLE_COLOR_CYAN	6
+# define CONSOLE_COLOR_GREY	14
+# define CONSOLE_COLOR_WHITE	15	/* Must remain last / highest	*/
+
+#elif LCD_BPP == LCD_COLOR24
+/*
+ * 24bpp color definitions
+ */
+# define CONSOLE_COLOR_BLACK	 0
+# define CONSOLE_COLOR_RED 	0x0000ff
+# define CONSOLE_COLOR_GREEN	0x00ff00
+# define CONSOLE_COLOR_YELLOW	0x00ffff
+# define CONSOLE_COLOR_BLUE	0xff0000
+# define CONSOLE_COLOR_MAGENTA	0xff00ff
+# define CONSOLE_COLOR_CYAN	0xffff00
+# define CONSOLE_COLOR_GREY	0x808080
+# define CONSOLE_COLOR_WHITE	0xffffff	/* Must remain last / highest	*/
+
+#else
+
+/*
+ * 16bpp color definitions
+ */
+# define CONSOLE_COLOR_BLACK	0x0000
+# define CONSOLE_COLOR_RED 		0xf800
+# define CONSOLE_COLOR_GREEN	0x07e0
+# define CONSOLE_COLOR_YELLOW	0xffe0
+# define CONSOLE_COLOR_BLUE		0x001f
+# define CONSOLE_COLOR_MAGENTA	0xf81f
+# define CONSOLE_COLOR_CYAN		0x07ff
+# define CONSOLE_COLOR_WHITE	0xffff	/* Must remain last / highest	*/
+
+#endif /* color definitions */
+
+/************************************************************************/
+#ifndef PAGE_SIZE
+# define PAGE_SIZE	4096
+#endif
+
+/************************************************************************/
+/* ** CONSOLE DEFINITIONS & FUNCTIONS					*/
+/************************************************************************/
+#if defined(CONFIG_LCD_LOGO) && !defined(CONFIG_LCD_INFO_BELOW_LOGO)
+# define CONSOLE_ROWS		((info->vl_row-BMP_LOGO_HEIGHT) \
+					/ VIDEO_FONT_HEIGHT)
+#else
+# define CONSOLE_ROWS		(info->vl_row / VIDEO_FONT_HEIGHT)
+#endif
+
+#define CONSOLE_COLS		(panel_info.vl_col / VIDEO_FONT_WIDTH)
+#define CONSOLE_ROW_SIZE	(VIDEO_FONT_HEIGHT * lcd_line_length)
+#define CONSOLE_ROW_FIRST	(info->vd_console_address)
+#define CONSOLE_ROW_SECOND	(info->vd_console_address + CONSOLE_ROW_SIZE)
+#define CONSOLE_ROW_LAST	(info->vd_console_address + CONSOLE_SIZE \
+					- CONSOLE_ROW_SIZE)
+#define CONSOLE_SIZE		(CONSOLE_ROW_SIZE * CONSOLE_ROWS)
+#define CONSOLE_SCROLL_SIZE	(CONSOLE_SIZE - CONSOLE_ROW_SIZE)
+
+# define COLOR_MASK(c)		(c)
+
+/************************************************************************/
+
+#endif
diff --git a/include/amlogic/vmode.h b/include/amlogic/vmode.h
new file mode 100644
index 0000000..88a3596
--- /dev/null
+++ b/include/amlogic/vmode.h
@@ -0,0 +1,57 @@
+
+#ifndef VMODE_H
+#define VMODE_H
+
+typedef enum vmode_e {
+	VMODE_480I = 0,
+	VMODE_480I_RPT,
+	VMODE_480CVBS,
+	VMODE_480P,
+	VMODE_480P_RPT,
+	VMODE_576I,
+	VMODE_576I_RPT,
+	VMODE_576CVBS,
+	VMODE_576P,
+	VMODE_576P_RPT,
+	VMODE_720P,
+	VMODE_1080I,
+	VMODE_1080P,
+	VMODE_720P_50HZ,
+	VMODE_1080I_50HZ,
+	VMODE_1080P_50HZ,
+	VMODE_1080P_24HZ,
+	VMODE_4K2K_30HZ,
+	VMODE_4K2K_25HZ,
+	VMODE_4K2K_24HZ,
+	VMODE_4K2K_SMPTE,
+	VMODE_4K2K_FAKE_5G,
+	VMODE_4K2K_60HZ,
+	VMODE_4K2K_60HZ_Y420,
+	VMODE_4K2K_50HZ,
+	VMODE_4K2K_50HZ_Y420,
+	VMODE_4K2K_5G,
+	VMODE_4K1K_120HZ,
+	VMODE_4K1K_120HZ_Y420,
+	VMODE_4K1K_100HZ,
+	VMODE_4K1K_100HZ_Y420,
+	VMODE_4K05K_240HZ,
+	VMODE_4K05K_240HZ_Y420,
+	VMODE_4K05K_200HZ,
+	VMODE_4K05K_200HZ_Y420,
+	VMODE_VGA,
+	VMODE_SVGA,
+	VMODE_XGA,
+	VMODE_SXGA,
+	VMODE_WSXGA,
+	VMODE_FHDVGA,
+	VMODE_LCD,
+	VMODE_LVDS_1080P,
+	VMODE_LVDS_1080P_50HZ,
+	VMODE_LVDS_768P,
+	VMODE_VX1_4K2K_60HZ,
+	VMODE_MAX,
+	VMODE_INIT_NULL,
+	VMODE_MASK = 0xFF,
+} vmode_t;
+
+#endif
diff --git a/include/amlogic/vout.h b/include/amlogic/vout.h
new file mode 100644
index 0000000..fb4a32d
--- /dev/null
+++ b/include/amlogic/vout.h
@@ -0,0 +1,14 @@
+#ifndef VOUT_H
+#define VOUT_H
+
+#include <amlogic/vinfo.h>
+
+void vout_init(void);
+void vout_vinfo_dump(void);
+int vout_get_current_vmode(void);
+int vout_get_current_axis(int *axis);
+void vout_set_current_vmode(int mode);
+vidinfo_t *vout_get_current_vinfo(void);
+
+#endif
+
diff --git a/include/configs/gxb_p200_v1.h b/include/configs/gxb_p200_v1.h
new file mode 100644
index 0000000..695b06b
--- /dev/null
+++ b/include/configs/gxb_p200_v1.h
@@ -0,0 +1,397 @@
+
+/*
+ * include/configs/gxb_p200_v1.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __GXB_P200_V1_H__
+#define __GXB_P200_V1_H__
+
+#ifndef __SUSPEND_FIRMWARE__
+#include <asm/arch/cpu.h>
+#endif		/* for compile problem of A53 and m3 */
+
+#define CONFIG_SYS_GENERIC_BOARD  1
+#ifndef __SUSPEND_FIRMWARE__
+#ifndef CONFIG_AML_MESON
+#warning "include warning"
+#endif
+#endif		/* for compile problem of A53 and m3 */
+
+/*
+ * platform power init config
+ */
+#define CONFIG_PLATFORM_POWER_INIT
+#define CONFIG_VCCK_INIT_VOLTAGE	1100
+#define CONFIG_VDDEE_INIT_VOLTAGE	1000		// voltage for power up
+#define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
+
+/* configs for CEC */
+#define CONFIG_CEC_OSD_NAME		"Mbox"
+#define CONFIG_CEC_WAKEUP
+
+/* bt wake up */
+#define CONFIG_BT_WAKEUP
+/* wifi wake up */
+#define CONFIG_WIFI_WAKEUP
+
+#define CONFIG_INSTABOOT
+
+/* SMP Definitinos */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* Serial config */
+#define CONFIG_CONS_INDEX 2
+#define CONFIG_BAUDRATE  115200
+#define CONFIG_AML_MESON_SERIAL   1
+#define CONFIG_SERIAL_MULTI		1
+//for detect remote key
+#define CONFIG_IR_REMOTE  1
+
+/* args/envs */
+#define CONFIG_SYS_MAXARGS  64
+#define CONFIG_EXTRA_ENV_SETTINGS \
+        "firstboot=1\0"\
+        "upgrade_step=0\0"\
+        "loadaddr=1080000\0"\
+        "outputmode=1080p60hz\0" \
+        "hdmimode=1080p60hz\0" \
+        "cvbsmode=576cvbs\0" \
+        "display_width=1920\0" \
+        "display_height=1080\0" \
+        "display_bpp=16\0" \
+        "display_color_index=16\0" \
+        "display_layer=osd1\0" \
+        "display_color_fg=0xffff\0" \
+        "display_color_bg=0\0" \
+        "dtb_mem_addr=0x1000000\0" \
+        "fb_addr=0x3f800000\0" \
+        "fb_width=1920\0" \
+        "fb_height=1080\0" \
+        "usb_burning=update 1000\0" \
+        "fdt_high=0x20000000\0"\
+        "try_auto_burn=update 700 750;\0"\
+        "sdcburncfg=aml_sdc_burn.ini\0"\
+        "sdc_burning=sdc_burn ${sdcburncfg}\0"\
+        "wipe_data=successful\0"\
+        "wipe_cache=successful\0"\
+        "initargs="\
+            "rootfstype=ramfs init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 ramoops.mem_address=0x20000000 ramoops.mem_size=0x100000 ramoops.record_size=0x8000 ramoops.console_size=0x4000 androidboot.selinux=permissive"\
+            "\0"\
+        "upgrade_check="\
+            "echo upgrade_step=${upgrade_step}; "\
+            "if itest ${upgrade_step} == 3; then "\
+                "run init_display; run storeargs; run update;"\
+            "else if itest ${upgrade_step} == 1; then "\
+                "defenv_reserv; setenv upgrade_step 2; saveenv;"\
+            "fi;fi;"\
+            "\0"\
+	    "bootmode_check="\
+            "get_rebootmode; echo reboot_mode=${reboot_mode};"\
+            "if test ${reboot_mode} = factory_reset; then "\
+                "defenv_reserv aml_dt;setenv upgrade_step 2; save;"\
+            "fi;"\
+            "\0" \
+        "storeargs="\
+            "setenv bootargs ${initargs} logo=${display_layer},loaded,${fb_addr},${outputmode} hdmimode=${hdmimode} cvbsmode=${cvbsmode} hdmitx=${cecconfig} androidboot.firstboot=${firstboot}; "\
+            "run cmdline_keys;"\
+            "\0"\
+        "switch_bootmode="\
+            "get_rebootmode;"\
+            "if test ${reboot_mode} = factory_reset; then "\
+                    "run recovery_from_flash;"\
+            "else if test ${reboot_mode} = update; then "\
+                    "run update;"\
+            "else if test ${reboot_mode} = cold_boot; then "\
+                "run try_auto_burn; "\
+            "fi;fi;fi;"\
+            "\0" \
+        "storeboot="\
+            "if imgread kernel boot ${loadaddr}; then store dtb read $dtb_mem_addr; bootm ${loadaddr}; fi;"\
+            "run update;"\
+            "\0"\
+        "factory_reset_poweroff_protect="\
+            "echo wipe_data=${wipe_data}; echo wipe_cache=${wipe_cache};"\
+            "if test ${wipe_data} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; "\
+            "if test ${wipe_cache} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; \0" \
+         "update="\
+            /*first usb burning, second sdc_burn, third ext-sd autoscr/recovery, last udisk autoscr/recovery*/\
+            "run usb_burning; "\
+            "run sdc_burning; "\
+            "if mmcinfo; then "\
+                "run recovery_from_sdcard;"\
+            "fi;"\
+            "if usb start 0; then "\
+                "run recovery_from_udisk;"\
+            "fi;"\
+            "run recovery_from_flash;"\
+            "\0"\
+        "recovery_from_sdcard="\
+            "if fatload mmc 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload mmc 0 ${loadaddr} recovery.img; then "\
+                    "if fatload mmc 0 ${dtb_mem_addr} dtb.img; then echo sd dtb.img loaded; fi;"\
+                    "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_udisk="\
+            "if fatload usb 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload usb 0 ${loadaddr} recovery.img; then "\
+                "if fatload usb 0 ${dtb_mem_addr} dtb.img; then echo udisk dtb.img loaded; fi;"\
+                "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_flash="\
+            "if imgread kernel recovery ${loadaddr}; then bootm ${loadaddr}; fi"\
+            "\0"\
+        "init_display="\
+            "hdmitx hpd;osd open;osd clear;vout output ${outputmode};imgread pic logo bootup $loadaddr;bmp display $bootup_offset;bmp scale"\
+            "\0"\
+        "cmdline_keys="\
+            "if keyman init 0x1234; then "\
+                "if keyman read usid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.serialno=${usid};"\
+                "fi;"\
+                "if keyman read mac ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} mac=${mac} androidboot.mac=${mac};"\
+                "fi;"\
+                "if keyman read deviceid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.deviceid=${deviceid};"\
+                "fi;"\
+            "fi;"\
+            "\0"\
+        "upgrade_key="\
+            "if gpio input GPIOAO_3; then "\
+                "echo detect upgrade key; run update;"\
+            "fi;"\
+            "\0"\
+	"irremote_update="\
+		"if irkey 0xe31cfb04 0xb748fb04 2500000; then "\
+			"echo read irkey ok!; " \
+		"if itest ${irkey_value} == 0xe31cfb04; then " \
+			"run update;" \
+		"else if itest ${irkey_value} == 0xb748fb04; then " \
+			"run update;\n" \
+			"fi;fi;" \
+		"fi;\0" \
+
+
+#define CONFIG_PREBOOT  \
+            "run factory_reset_poweroff_protect;"\
+            "run upgrade_check;"\
+            "run bootmode_check;"\
+            "run init_display;"\
+            "run storeargs;"\
+            "run upgrade_key;" \
+            "run switch_bootmode;"
+#define CONFIG_BOOTCOMMAND "run storeboot"
+
+//#define CONFIG_ENV_IS_NOWHERE  1
+#define CONFIG_ENV_SIZE   (64*1024)
+#define CONFIG_FIT 1
+#define CONFIG_OF_LIBFDT 1
+#define CONFIG_ANDROID_BOOT_IMAGE 1
+#define CONFIG_ANDROID_IMG 1
+#define CONFIG_SYS_BOOTM_LEN (64<<20) /* Increase max gunzip size*/
+
+/* cpu */
+#define CONFIG_CPU_CLK					1536 //MHz. Range: 600-1800, should be multiple of 24
+
+/* ddr */
+#define CONFIG_DDR_SIZE					1024 //MB
+#define CONFIG_DDR_CLK					912  //MHz, Range: 384-1200, should be multiple of 24
+#define CONFIG_DDR_TYPE					CONFIG_DDR_TYPE_DDR3
+/* DDR channel setting, please refer hardware design.
+ *    CONFIG_DDR0_RANK0_ONLY   : one channel
+ *    CONFIG_DDR0_RANK01_SAME  : one channel use two rank with same setting
+ *    CONFIG_DDR0_RANK01_DIFF  : one channel use two rank with diff setting
+ *    CONFIG_DDR01_SHARE_AC    : two channels  */
+#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK01_SAME
+#define CONFIG_DDR_FULL_TEST			0 //1 for ddr full test
+#define CONFIG_NR_DRAM_BANKS			1
+/* ddr power saving */
+#define CONFIG_DDR_ZQ_POWER_DOWN
+#define CONFIG_DDR_POWER_DOWN_PHY_VREF
+/* ddr detection */
+#define CONFIG_DDR_SIZE_AUTO_DETECT		1
+
+/* storage: emmc/nand/sd */
+#define	CONFIG_STORE_COMPATIBLE 1
+#define CONFIG_AML_NAND	1
+/* env */
+#define 	CONFIG_ENV_OVERWRITE
+#define 	CONFIG_CMD_SAVEENV
+/* fixme, need fix*/
+
+#if (defined(CONFIG_ENV_IS_IN_AMLNAND) || defined(CONFIG_ENV_IS_IN_MMC)) && defined(CONFIG_STORE_COMPATIBLE)
+#error env in amlnand/mmc already be compatible;
+#endif
+
+#define CONFIG_AML_SD_EMMC 1
+#ifdef	CONFIG_AML_SD_EMMC
+	#define CONFIG_GENERIC_MMC 1
+	#define CONFIG_CMD_MMC 1
+	#define	CONFIG_SYS_MMC_ENV_DEV 1
+#endif
+
+#define	CONFIG_PARTITIONS 1
+#define CONFIG_SYS_NO_FLASH  1
+
+/* vpu */
+#define CONFIG_AML_VPU 1
+#ifdef CONFIG_AML_VPU
+#define CONFIG_VPU_PRESET 1
+#endif
+
+/* DISPLAY & HDMITX */
+#define CONFIG_AML_HDMITX20 1
+#define CONFIG_AML_CANVAS 1
+#define CONFIG_AML_VOUT 1
+#define CONFIG_AML_OSD 1
+#define CONFIG_OSD_SCALE_ENABLE 1
+#define CONFIG_CMD_BMP 1
+
+#if defined(CONFIG_AML_VOUT)
+#define CONFIG_AML_CVBS 1
+#endif
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+/* #define CONFIG_MUSB_UDC		1 */
+#define CONFIG_CMD_USB 1
+#if defined(CONFIG_CMD_USB)
+	#define CONFIG_M8_USBPORT_BASE_A	0xC9000000
+	#define CONFIG_M8_USBPORT_BASE_B	0xC9100000
+	#define CONFIG_USB_STORAGE      1
+	#define CONFIG_USB_DWC_OTG_HCD  1
+	#define CONFIG_USB_DWC_OTG_294	1
+#endif //#if defined(CONFIG_CMD_USB)
+
+//UBOOT Facotry usb/sdcard burning config
+#define CONFIG_AML_V2_FACTORY_BURN              1
+#define CONFIG_AML_FACTORY_BURN_LOCAL_UPGRADE   1       //support factory sdcard burning
+#define CONFIG_POWER_KEY_NOT_SUPPORTED_FOR_BURN 1       //There isn't power-key for factory sdcard burning
+#define CONFIG_SD_BURNING_SUPPORT_UI            1       //Displaying upgrading progress bar when sdcard/udisk burning
+
+#define CONFIG_AML_SECURITY_KEY                 1
+#define CONFIG_UNIFY_KEY_MANAGE                 1
+
+/* net */
+#define CONFIG_CMD_NET   1
+#if defined(CONFIG_CMD_NET)
+	#define CONFIG_AML_ETHERNET 1
+	#define CONFIG_NET_MULTI 1
+	#define CONFIG_CMD_PING 1
+	#define CONFIG_CMD_DHCP 1
+	#define CONFIG_CMD_RARP 1
+	//#define CONFIG_NET_RGMII
+	//	//#define CONFIG_NET_RMII_CLK_EXTERNAL //use external 50MHz clock source
+	#define CONFIG_AML_ETHERNET    1                   /*to link /driver/net/aml_ethernet.c*/
+	#define IP101PHY    1                   /*to link /driver/net/aml_ethernet.c*/
+	#define CONFIG_HOSTNAME        arm_gxbb
+	#define CONFIG_ETHADDR         00:15:18:01:81:31   /* Ethernet address */
+	#define CONFIG_IPADDR          10.18.9.97          /* Our ip address */
+	#define CONFIG_GATEWAYIP       10.18.9.1           /* Our getway ip address */
+	#define CONFIG_SERVERIP        10.18.9.113         /* Tftp server ip address */
+	#define CONFIG_NETMASK         255.255.255.0
+#endif /* (CONFIG_CMD_NET) */
+
+/* other devices */
+#define CONFIG_EFUSE 1
+#define CONFIG_SYS_I2C_AML 1
+#define CONFIG_SYS_I2C_SPEED     400000
+
+/* commands */
+#define CONFIG_CMD_CACHE 1
+#define CONFIG_CMD_BOOTI 1
+#define CONFIG_CMD_EFUSE 1
+#define CONFIG_CMD_I2C 1
+#define CONFIG_CMD_MEMORY 1
+#define CONFIG_CMD_FAT 1
+#define CONFIG_CMD_GPIO 1
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_REBOOT 1
+#define CONFIG_CMD_ECHO 1
+#define CONFIG_CMD_JTAG	1
+#define CONFIG_CMD_AUTOSCRIPT 1
+
+/*file system*/
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_MMC 1
+#define CONFIG_FS_FAT 1
+#define CONFIG_FS_EXT4 1
+#define CONFIG_LZO 1
+
+/* Cache Definitions */
+//#define CONFIG_SYS_DCACHE_OFF
+//#define CONFIG_SYS_ICACHE_OFF
+
+/* other functions */
+#define CONFIG_NEED_BL301	1
+#define CONFIG_BOOTDELAY	1 //delay 1s
+#define CONFIG_SYS_LONGHELP 1
+#define CONFIG_CMD_MISC     1
+#define CONFIG_CMD_ITEST    1
+#define CONFIG_CMD_CPU_TEMP 1
+#define CONFIG_SYS_MEM_TOP_HIDE 0x08000000 //hide 128MB for kernel reserve
+#define CONFIG_MULTI_DTB    1
+
+//support secure boot
+#define CONFIG_AML_SECURE_UBOOT   1
+
+#if defined(CONFIG_AML_SECURE_UBOOT)
+
+//for GXBB SRAM size limitation just disable NAND
+//as the socket board default has no NAND
+//#undef CONFIG_AML_NAND
+
+//unify build for generate encrypted bootloader "u-boot.bin.encrypt"
+#define CONFIG_AML_CRYPTO_UBOOT   1
+
+//unify build for generate encrypted kernel image
+//SRC : "board/amlogic/gxb_skt_v1/boot.img"
+//DST : "fip/boot.img.encrypt"
+//#define CONFIG_AML_CRYPTO_IMG       1
+
+#endif //CONFIG_AML_SECURE_UBOOT
+
+
+#define CONFIG_SECURE_STORAGE 1
+
+//build with uboot auto test
+//#define CONFIG_AML_UBOOT_AUTO_TEST 1
+
+#endif
+
diff --git a/include/configs/gxb_p201_v1.h b/include/configs/gxb_p201_v1.h
new file mode 100644
index 0000000..4dcc74e
--- /dev/null
+++ b/include/configs/gxb_p201_v1.h
@@ -0,0 +1,378 @@
+
+/*
+ * include/configs/gxb_p201_v1.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __GXB_P201_V1_H__
+#define __GXB_P201_V1_H__
+
+#ifndef __SUSPEND_FIRMWARE__
+#include <asm/arch/cpu.h>
+#endif		/* for compile problem of A53 and m3 */
+
+#define CONFIG_SYS_GENERIC_BOARD  1
+#ifndef __SUSPEND_FIRMWARE__
+#ifndef CONFIG_AML_MESON
+#warning "include warning"
+#endif
+#endif		/* for compile problem of A53 and m3 */
+
+/*
+ * platform power init config
+ */
+#define CONFIG_PLATFORM_POWER_INIT
+#define CONFIG_VCCK_INIT_VOLTAGE	1100
+#define CONFIG_VDDEE_INIT_VOLTAGE	1000		// voltage for power up
+#define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
+
+/* configs for CEC */
+#define CONFIG_CEC_OSD_NAME		"Mbox"
+#define CONFIG_CEC_WAKEUP
+
+#define CONFIG_INSTABOOT
+
+/* SMP Definitinos */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* Serial config */
+#define CONFIG_CONS_INDEX 2
+#define CONFIG_BAUDRATE  115200
+#define CONFIG_AML_MESON_SERIAL   1
+#define CONFIG_SERIAL_MULTI		1
+
+/* args/envs */
+#define CONFIG_SYS_MAXARGS  64
+#define CONFIG_EXTRA_ENV_SETTINGS \
+        "firstboot=1\0"\
+        "upgrade_step=0\0"\
+        "loadaddr=1080000\0"\
+        "outputmode=1080p60hz\0" \
+        "hdmimode=1080p60hz\0" \
+        "cvbsmode=576cvbs\0" \
+        "display_width=1920\0" \
+        "display_height=1080\0" \
+        "display_bpp=16\0" \
+        "display_color_index=16\0" \
+        "display_layer=osd1\0" \
+        "display_color_fg=0xffff\0" \
+        "display_color_bg=0\0" \
+        "dtb_mem_addr=0x1000000\0" \
+        "fb_addr=0x3f800000\0" \
+        "fb_width=1920\0" \
+        "fb_height=1080\0" \
+        "usb_burning=update 1000\0" \
+        "fdt_high=0x20000000\0"\
+        "try_auto_burn=update 700 750;\0"\
+        "sdcburncfg=aml_sdc_burn.ini\0"\
+        "sdc_burning=sdc_burn ${sdcburncfg}\0"\
+        "wipe_data=successful\0"\
+        "wipe_cache=successful\0"\
+        "initargs="\
+            "rootfstype=ramfs init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 ramoops.mem_address=0x20000000 ramoops.mem_size=0x100000 ramoops.record_size=0x8000 ramoops.console_size=0x4000 androidboot.selinux=permissive"\
+            "\0"\
+        "upgrade_check="\
+            "echo upgrade_step=${upgrade_step}; "\
+            "if itest ${upgrade_step} == 3; then "\
+                "run init_display; run storeargs; run update;"\
+            "else if itest ${upgrade_step} == 1; then "\
+                "defenv_reserv; setenv upgrade_step 2; saveenv;"\
+            "fi;fi;"\
+            "\0"\
+	    "bootmode_check="\
+            "get_rebootmode; echo reboot_mode=${reboot_mode};"\
+            "if test ${reboot_mode} = factory_reset; then "\
+                "defenv_reserv aml_dt;setenv upgrade_step 2; save;"\
+            "fi;"\
+            "\0" \
+        "storeargs="\
+            "setenv bootargs ${initargs} logo=${display_layer},loaded,${fb_addr},${outputmode} hdmimode=${hdmimode} cvbsmode=${cvbsmode} hdmitx=${cecconfig} androidboot.firstboot=${firstboot}; "\
+            "run cmdline_keys;"\
+            "\0"\
+        "switch_bootmode="\
+            "get_rebootmode;"\
+            "if test ${reboot_mode} = factory_reset; then "\
+                    "run recovery_from_flash;"\
+            "else if test ${reboot_mode} = update; then "\
+                    "run update;"\
+            "else if test ${reboot_mode} = cold_boot; then "\
+                "run try_auto_burn; "\
+            "fi;fi;fi;"\
+            "\0" \
+        "storeboot="\
+            "if imgread kernel boot ${loadaddr}; then store dtb read $dtb_mem_addr; bootm ${loadaddr}; fi;"\
+            "run update;"\
+            "\0"\
+        "factory_reset_poweroff_protect="\
+            "echo wipe_data=${wipe_data}; echo wipe_cache=${wipe_cache};"\
+            "if test ${wipe_data} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; "\
+            "if test ${wipe_cache} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; \0" \
+         "update="\
+            /*first usb burning, second sdc_burn, third ext-sd autoscr/recovery, last udisk autoscr/recovery*/\
+            "run usb_burning; "\
+            "run sdc_burning; "\
+            "if mmcinfo; then "\
+                "run recovery_from_sdcard;"\
+            "fi;"\
+            "if usb start 0; then "\
+                "run recovery_from_udisk;"\
+            "fi;"\
+            "run recovery_from_flash;"\
+            "\0"\
+        "recovery_from_sdcard="\
+            "if fatload mmc 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload mmc 0 ${loadaddr} recovery.img; then "\
+                    "if fatload mmc 0 ${dtb_mem_addr} dtb.img; then echo sd dtb.img loaded; fi;"\
+                    "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_udisk="\
+            "if fatload usb 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload usb 0 ${loadaddr} recovery.img; then "\
+                "if fatload usb 0 ${dtb_mem_addr} dtb.img; then echo udisk dtb.img loaded; fi;"\
+                "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_flash="\
+            "if imgread kernel recovery ${loadaddr}; then bootm ${loadaddr}; fi"\
+            "\0"\
+        "init_display="\
+            "hdmitx hpd;osd open;osd clear;vout output ${outputmode};imgread pic logo bootup $loadaddr;bmp display $bootup_offset;bmp scale"\
+            "\0"\
+        "cmdline_keys="\
+            "if keyman init 0x1234; then "\
+                "if keyman read usid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.serialno=${usid};"\
+                "fi;"\
+                "if keyman read mac ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} mac=${mac} androidboot.mac=${mac};"\
+                "fi;"\
+                "if keyman read deviceid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.deviceid=${deviceid};"\
+                "fi;"\
+            "fi;"\
+            "\0"\
+        "upgrade_key="\
+            "if gpio input GPIOAO_3; then "\
+                "echo detect upgrade key; sleep 5; run update;"\
+            "fi;"\
+            "\0"\
+
+#define CONFIG_PREBOOT  \
+            "run factory_reset_poweroff_protect;"\
+            "run upgrade_check;"\
+            "run bootmode_check;"\
+            "run init_display;"\
+            "run storeargs;"\
+            "run upgrade_key;" \
+            "run switch_bootmode;"
+#define CONFIG_BOOTCOMMAND "run storeboot"
+
+//#define CONFIG_ENV_IS_NOWHERE  1
+#define CONFIG_ENV_SIZE   (64*1024)
+#define CONFIG_FIT 1
+#define CONFIG_OF_LIBFDT 1
+#define CONFIG_ANDROID_BOOT_IMAGE 1
+#define CONFIG_ANDROID_IMG 1
+#define CONFIG_SYS_BOOTM_LEN (64<<20) /* Increase max gunzip size*/
+
+/* cpu */
+#define CONFIG_CPU_CLK					1536 //MHz. Range: 600-1800, should be multiple of 24
+
+/* ddr */
+#define CONFIG_DDR_SIZE					1024 //MB
+#define CONFIG_DDR_CLK					912  //MHz, Range: 384-1200, should be multiple of 24
+#define CONFIG_DDR_TYPE					CONFIG_DDR_TYPE_DDR3
+/* DDR channel setting, please refer hardware design.
+ *    CONFIG_DDR0_RANK0_ONLY   : one channel
+ *    CONFIG_DDR0_RANK01_SAME  : one channel use two rank with same setting
+ *    CONFIG_DDR0_RANK01_DIFF  : one channel use two rank with diff setting
+ *    CONFIG_DDR01_SHARE_AC    : two channels  */
+#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK01_SAME
+#define CONFIG_DDR_FULL_TEST			0 //1 for ddr full test
+#define CONFIG_NR_DRAM_BANKS			1
+/* ddr power saving */
+#define CONFIG_DDR_ZQ_POWER_DOWN
+#define CONFIG_DDR_POWER_DOWN_PHY_VREF
+/* ddr detection */
+#define CONFIG_DDR_SIZE_AUTO_DETECT		0
+
+/* storage: emmc/nand/sd */
+#define	CONFIG_STORE_COMPATIBLE 1
+#define CONFIG_AML_NAND	1
+/* env */
+#define 	CONFIG_ENV_OVERWRITE
+#define 	CONFIG_CMD_SAVEENV
+/* fixme, need fix*/
+
+#if (defined(CONFIG_ENV_IS_IN_AMLNAND) || defined(CONFIG_ENV_IS_IN_MMC)) && defined(CONFIG_STORE_COMPATIBLE)
+#error env in amlnand/mmc already be compatible;
+#endif
+#define CONFIG_AML_SD_EMMC 1
+#ifdef	CONFIG_AML_SD_EMMC
+	#define CONFIG_GENERIC_MMC 1
+	#define CONFIG_CMD_MMC 1
+	#define	CONFIG_SYS_MMC_ENV_DEV 1
+#endif
+
+#define	CONFIG_PARTITIONS 1
+#define CONFIG_SYS_NO_FLASH  1
+
+/* vpu */
+#define CONFIG_AML_VPU 1
+#ifdef CONFIG_AML_VPU
+#define CONFIG_VPU_PRESET 1
+#endif
+
+/* DISPLAY & HDMITX */
+#define CONFIG_AML_HDMITX20 1
+#define CONFIG_AML_CANVAS 1
+#define CONFIG_AML_VOUT 1
+#define CONFIG_AML_OSD 1
+#define CONFIG_OSD_SCALE_ENABLE 1
+#define CONFIG_CMD_BMP 1
+
+#if defined(CONFIG_AML_VOUT)
+#define CONFIG_AML_CVBS 1
+#endif
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+/* #define CONFIG_MUSB_UDC		1 */
+#define CONFIG_CMD_USB 1
+#if defined(CONFIG_CMD_USB)
+	#define CONFIG_M8_USBPORT_BASE_A	0xC9000000
+	#define CONFIG_M8_USBPORT_BASE_B	0xC9100000
+	#define CONFIG_USB_STORAGE      1
+	#define CONFIG_USB_DWC_OTG_HCD  1
+	#define CONFIG_USB_DWC_OTG_294	1
+#endif //#if defined(CONFIG_CMD_USB)
+
+//UBOOT Facotry usb/sdcard burning config
+#define CONFIG_AML_V2_FACTORY_BURN              1       //support facotry usb burning
+#define CONFIG_AML_FACTORY_BURN_LOCAL_UPGRADE   1       //support factory sdcard burning
+#define CONFIG_POWER_KEY_NOT_SUPPORTED_FOR_BURN 1       //There isn't power-key for factory sdcard burning
+#define CONFIG_SD_BURNING_SUPPORT_UI            1       //Displaying upgrading progress bar when sdcard/udisk burning
+
+#define CONFIG_AML_SECURITY_KEY                 1
+#define CONFIG_UNIFY_KEY_MANAGE                 1
+
+/* net */
+#define CONFIG_CMD_NET   1
+#if defined(CONFIG_CMD_NET)
+	#define CONFIG_AML_ETHERNET 1
+	#define CONFIG_NET_MULTI 1
+	#define CONFIG_CMD_PING 1
+	#define CONFIG_CMD_DHCP 1
+	#define CONFIG_CMD_RARP 1
+	//#define CONFIG_NET_RGMII
+	//	//#define CONFIG_NET_RMII_CLK_EXTERNAL //use external 50MHz clock source
+	#define CONFIG_AML_ETHERNET    1                   /*to link /driver/net/aml_ethernet.c*/
+	#define IP101PHY    1                   /*to link /driver/net/aml_ethernet.c*/
+	#define CONFIG_HOSTNAME        arm_gxbb
+	#define CONFIG_ETHADDR         00:15:18:01:81:31   /* Ethernet address */
+	#define CONFIG_IPADDR          10.18.9.97          /* Our ip address */
+	#define CONFIG_GATEWAYIP       10.18.9.1           /* Our getway ip address */
+	#define CONFIG_SERVERIP        10.18.9.113         /* Tftp server ip address */
+	#define CONFIG_NETMASK         255.255.255.0
+#endif /* (CONFIG_CMD_NET) */
+
+/* other devices */
+#define CONFIG_EFUSE 1
+#define CONFIG_SYS_I2C_AML 1
+#define CONFIG_SYS_I2C_SPEED     400000
+
+/* commands */
+#define CONFIG_CMD_CACHE 1
+#define CONFIG_CMD_BOOTI 1
+#define CONFIG_CMD_EFUSE 1
+#define CONFIG_CMD_I2C 1
+#define CONFIG_CMD_MEMORY 1
+#define CONFIG_CMD_FAT 1
+#define CONFIG_CMD_GPIO 1
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_REBOOT 1
+#define CONFIG_CMD_ECHO 1
+#define CONFIG_CMD_JTAG	1
+#define CONFIG_CMD_AUTOSCRIPT 1
+#define CONFIG_CMD_MISC 1
+
+/*file system*/
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_MMC 1
+#define CONFIG_FS_FAT 1
+#define CONFIG_FS_EXT4 1
+#define CONFIG_LZO 1
+
+/* Cache Definitions */
+//#define CONFIG_SYS_DCACHE_OFF
+//#define CONFIG_SYS_ICACHE_OFF
+
+/* other functions */
+#define CONFIG_NEED_BL301	1
+#define CONFIG_BOOTDELAY	1 //delay 1s
+#define CONFIG_SYS_LONGHELP 1
+#define CONFIG_CMD_MISC     1
+#define CONFIG_CMD_ITEST    1
+#define CONFIG_CMD_CPU_TEMP 1
+#define CONFIG_SYS_MEM_TOP_HIDE 0x08000000 //hide 128MB for kernel reserve
+
+//support secure boot
+#define CONFIG_AML_SECURE_UBOOT   1
+
+#if defined(CONFIG_AML_SECURE_UBOOT)
+
+//for GXBB SRAM size limitation just disable NAND
+//as the socket board default has no NAND
+//#undef CONFIG_AML_NAND
+
+//unify build for generate encrypted bootloader "u-boot.bin.encrypt"
+#define CONFIG_AML_CRYPTO_UBOOT   1
+
+//unify build for generate encrypted kernel image
+//SRC : "board/amlogic/gxb_skt_v1/boot.img"
+//DST : "fip/boot.img.encrypt"
+//#define CONFIG_AML_CRYPTO_IMG       1
+
+#endif //CONFIG_AML_SECURE_UBOOT
+
+#define CONFIG_SECURE_STORAGE 1
+
+//build with uboot auto test
+//#define CONFIG_AML_UBOOT_AUTO_TEST 1
+
+#endif
+
diff --git a/include/configs/gxb_skt_v1.h b/include/configs/gxb_skt_v1.h
new file mode 100644
index 0000000..3c05eae
--- /dev/null
+++ b/include/configs/gxb_skt_v1.h
@@ -0,0 +1,255 @@
+
+/*
+ * include/configs/gxb_skt_v1.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __GXB_SKT_V1_H__
+#define __GXB_SKT_V1_H__
+
+#include <asm/arch/cpu.h>
+
+#define CONFIG_SYS_GENERIC_BOARD  1
+#ifndef CONFIG_AML_MESON
+#warning "include warning"
+#endif
+
+/* configs for CEC */
+#define CONFIG_CEC_OSD_NAME		"Mbox"
+#define CONFIG_CEC_WAKEUP
+
+/* SMP Definitinos */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* Serial config */
+#define CONFIG_CONS_INDEX 2
+#define CONFIG_BAUDRATE  115200
+#define CONFIG_AML_MESON_SERIAL   1
+#define CONFIG_SERIAL_MULTI		1
+
+/* args/envs */
+#define CONFIG_SYS_MAXARGS  64
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"storeboot=\0"
+#define CONFIG_BOOTARGS "init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 ramoops.mem_address=0x20000000 ramoops.mem_size=0x100000 ramoops.record_size=0x8000 ramoops.console_size=0x4000"
+#define CONFIG_BOOTCOMMAND "run storeboot"
+
+//#define CONFIG_ENV_IS_NOWHERE  1
+#define CONFIG_ENV_SIZE   (64*1024)
+#define CONFIG_FIT 1
+#define CONFIG_OF_LIBFDT 1
+#define CONFIG_ANDROID_BOOT_IMAGE 1
+#define CONFIG_ANDROID_IMG 1
+#define CONFIG_SYS_BOOTM_LEN (64<<20) /* Increase max gunzip size*/
+
+/* cpu */
+#define CONFIG_CPU_CLK					1536 //MHz. Range: 600-1800, should be multiple of 24
+
+/* ddr */
+#define CONFIG_DDR_SIZE					1024 //MB
+#define CONFIG_DDR_CLK					912  //MHz, Range: 384-1200, should be multiple of 24
+#define CONFIG_DDR_TYPE					CONFIG_DDR_TYPE_DDR3
+/* DDR channel setting, please refer hardware design.
+ *    CONFIG_DDR0_RANK0_ONLY   : one channel
+ *    CONFIG_DDR0_RANK01_SAME  : one channel use two rank with same setting
+ *    CONFIG_DDR0_RANK01_DIFF  : one channel use two rank with diff setting
+ *    CONFIG_DDR01_SHARE_AC    : two channels  */
+#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK01_SAME
+#define CONFIG_DDR_FULL_TEST			0 //1 for ddr full test
+#define CONFIG_NR_DRAM_BANKS			1
+/* ddr power saving */
+#define CONFIG_DDR_ZQ_POWER_DOWN
+#define CONFIG_DDR_POWER_DOWN_PHY_VREF
+/* ddr detection */
+#define CONFIG_DDR_SIZE_AUTO_DETECT		0
+
+/* storage: emmc/nand/sd */
+#define		CONFIG_STORE_COMPATIBLE 1
+#define CONFIG_AML_NAND	1
+#define 	CONFIG_ENV_OVERWRITE
+#define 	CONFIG_CMD_SAVEENV
+/* fixme, need fix*/
+
+#if (defined(CONFIG_ENV_IS_IN_AMLNAND) || defined(CONFIG_ENV_IS_IN_MMC)) && defined(CONFIG_STORE_COMPATIBLE)
+#error env in amlnand/mmc already be compatible;
+#endif
+#define		CONFIG_AML_SD_EMMC 1
+#ifdef		CONFIG_AML_SD_EMMC
+	#define 	CONFIG_GENERIC_MMC 1
+	#define 	CONFIG_CMD_MMC 1
+	#define	CONFIG_SYS_MMC_ENV_DEV 1
+#endif
+#define		CONFIG_PARTITIONS 1
+#define 	CONFIG_SYS_NO_FLASH  1
+
+/*SPI*/
+#define CONFIG_AMLOGIC_SPI_FLASH 1
+#ifdef 		CONFIG_AMLOGIC_SPI_FLASH
+#undef 		CONFIG_ENV_IS_NOWHERE
+//#define		CONFIG_SPI_BOOT 1
+#define 	CONFIG_SPI_FLASH_ATMEL
+#define 	CONFIG_SPI_FLASH_EON
+#define 	CONFIG_SPI_FLASH_MACRONIX
+#define 	CONFIG_SPI_FLASH_SPANSION
+#define 	CONFIG_SPI_FLASH_SST
+#define 	CONFIG_SPI_FLASH_STMICRO
+#define 	CONFIG_SPI_FLASH_WINBOND
+#define		CONFIG_SPI_FRAM_RAMTRON
+#define		CONFIG_SPI_M95XXX
+//#define		CONFIG_SPI_FLASH_GIGADEVICE
+//#define		CONFIG_SPI_FLASH_PMDEVICE
+//#define		CONFIG_SPI_NOR_SECURE_STORAGE
+#define		CONFIG_SPI_FLASH_ESMT
+#define		CONFIG_SPI_FLASH 1
+#define 	CONFIG_CMD_SF 1
+#ifdef CONFIG_SPI_BOOT
+	#define CONFIG_ENV_OVERWRITE
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_CMD_SAVEENV
+	#define CONFIG_ENV_SECT_SIZE		0x10000
+	#define CONFIG_ENV_OFFSET           0x1f0000
+#endif
+#endif
+
+
+/* vpu */
+#define CONFIG_AML_VPU 1
+#ifdef CONFIG_AML_VPU
+#define CONFIG_VPU_PRESET 1
+#endif
+
+/* DISPLAY & HDMITX */
+#define CONFIG_AML_HDMITX20 1
+#define CONFIG_AML_CANVAS 1
+#define CONFIG_AML_VOUT 1
+#define CONFIG_AML_OSD 1
+#define CONFIG_OSD_SCALE_ENABLE 1
+#define CONFIG_CMD_BMP 1
+
+#if defined(CONFIG_AML_VOUT)
+#define CONFIG_AML_CVBS 1
+#endif
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+/* #define CONFIG_MUSB_UDC		1 */
+#define CONFIG_CMD_USB 1
+#if defined(CONFIG_CMD_USB)
+	#define CONFIG_M8_USBPORT_BASE_A	0xC9000000
+	#define CONFIG_M8_USBPORT_BASE_B	0xC9100000
+	#define CONFIG_USB_STORAGE      1
+	#define CONFIG_USB_DWC_OTG_HCD  1
+	#define CONFIG_USB_DWC_OTG_294	1
+#endif //#if defined(CONFIG_CMD_USB)
+//#define CONFIG_AML_TINY_USBTOOL 1
+#define CONFIG_AML_V2_FACTORY_BURN   1
+
+/* net */
+#define CONFIG_CMD_NET   1
+#if defined(CONFIG_CMD_NET)
+	#define CONFIG_AML_ETHERNET 1
+	#define CONFIG_NET_MULTI 1
+	#define CONFIG_CMD_PING 1
+	#define CONFIG_CMD_DHCP 1
+	#define CONFIG_CMD_RARP 1
+	//#define CONFIG_NET_RGMII
+	//	//#define CONFIG_NET_RMII_CLK_EXTERNAL //use external 50MHz clock source
+	#define CONFIG_AML_ETHERNET    1                   /*to link /driver/net/aml_ethernet.c*/
+	#define IP101PHY    1                   /*to link /driver/net/aml_ethernet.c*/
+	#define CONFIG_HOSTNAME        arm_gxbb
+	#define CONFIG_ETHADDR         00:15:18:01:81:31   /* Ethernet address */
+	#define CONFIG_IPADDR          10.18.9.97          /* Our ip address */
+	#define CONFIG_GATEWAYIP       10.18.9.1           /* Our getway ip address */
+	#define CONFIG_SERVERIP        10.18.9.113         /* Tftp server ip address */
+	#define CONFIG_NETMASK         255.255.255.0
+#endif /* (CONFIG_CMD_NET) */
+
+/* other devices */
+#define CONFIG_EFUSE 1
+#define CONFIG_SYS_I2C_AML 1
+#define CONFIG_SYS_I2C_SPEED     400000
+
+/* commands */
+#define CONFIG_CMD_CACHE 1
+#define CONFIG_CMD_BOOTI 1
+#define CONFIG_CMD_EFUSE 1
+#define CONFIG_CMD_I2C 1
+#define CONFIG_CMD_MEMORY 1
+#define CONFIG_CMD_FAT 1
+#define CONFIG_CMD_GPIO 1
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_REBOOT 1
+#define CONFIG_CMD_JTAG	1
+
+/*file system*/
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_MMC 1
+#define CONFIG_FS_FAT 1
+#define CONFIG_FS_EXT4 1
+#define CONFIG_LZO 1
+
+/* Cache Definitions */
+//#define CONFIG_SYS_DCACHE_OFF
+//#define CONFIG_SYS_ICACHE_OFF
+
+/* other functions */
+#define CONFIG_NEED_BL301	1
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_SYS_LONGHELP 1
+#define CONFIG_CMD_MISC         1
+#define CONFIG_CMD_CPU_TEMP 1
+#define CONFIG_SYS_MEM_TOP_HIDE 0x08000000 //hide 128MB for kernel reserve
+
+/* ddr dump function defines */
+//#define CONFIG_SPL_DDR_DUMP 1
+#ifdef CONFIG_SPL_DDR_DUMP
+	#define CONFIG_SPL_DDR_DUMP_ADDR 			0x01000000
+	#define CONFIG_SPL_DDR_DUMP_SIZE			0x00200000
+	#define CONFIG_SPL_DDR_DUMP_DEV_TYPE		0x4 //device type, 1:emmc, 4:sd
+	#define CONFIG_SPL_DDR_DUMP_DEV_OFFSET		0x40000000 //offset of store device
+	#define CONFIG_SPL_DDR_DUMP_FLAG			0x1 //flag write in sticky reg
+#endif
+
+//support secure boot
+#define CONFIG_AML_SECURE_UBOOT   1
+
+#if defined(CONFIG_AML_SECURE_UBOOT)
+
+//for GXBB SRAM size limitation just disable NAND
+//as the socket board default has no NAND
+//#undef CONFIG_AML_NAND
+
+//unify build for generate encrypted bootloader "u-boot.bin.encrypt"
+#define CONFIG_AML_CRYPTO_UBOOT   1
+
+//unify build for generate encrypted kernel image
+//SRC : "board/amlogic/gxb_skt_v1/boot.img"
+//DST : "fip/boot.img.encrypt"
+//#define CONFIG_AML_CRYPTO_IMG       1
+
+#endif //CONFIG_AML_SECURE_UBOOT
+
+#define CONFIG_SECURE_STORAGE 1
+
+//build with uboot auto test
+//#define CONFIG_AML_UBOOT_AUTO_TEST 1
+
+#endif
+
diff --git a/include/configs/odroidc2.h b/include/configs/odroidc2.h
new file mode 100644
index 0000000..c1140b4
--- /dev/null
+++ b/include/configs/odroidc2.h
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * Configuration settings for ODROID-C2 (AMLogic S905) board,
+ * cloned from include/configs/gxb_p200_v1.h
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ODROID_C2_H__
+#define __ODROID_C2_H__
+
+#include <linux/sizes.h>
+
+#define CONFIG_MACH_ODROIDC2		1
+
+#ifndef __SUSPEND_FIRMWARE__
+#include <asm/arch/cpu.h>
+#endif	/* for compile problem of A53 and m3 */
+
+#define CONFIG_SYS_GENERIC_BOARD	1
+#ifndef __SUSPEND_FIRMWARE__
+#ifndef CONFIG_AML_MESON
+#warning "include warning"
+#endif
+#endif		/* for compile problem of A53 and m3 */
+
+/* CPU */
+/* Clock rnage : 600~1800MHz, should be multiple of 24 */
+#define CONFIG_CPU_CLK			1536
+
+/* SMP Definitinos */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* DDR */
+#define CONFIG_DDR_SIZE			(1024 + 512)	// MB
+
+/* Clock range : 384~1200MHz, should be multiple of 24 */
+#define CONFIG_DDR_CLK			912
+#define CONFIG_DDR_TYPE			CONFIG_DDR_TYPE_DDR3
+
+/* DDR channel setting, please refer hardware design.
+ * CONFIG_DDR0_RANK0_ONLY   : one channel
+ * CONFIG_DDR0_RANK01_SAME  : one channel use two rank with same setting
+ * CONFIG_DDR01_SHARE_AC    : two channels
+ */
+#define CONFIG_DDR_CHANNEL_SET		CONFIG_DDR0_RANK01_SAME
+#define CONFIG_DDR_FULL_TEST		0 // 1 for ddr full test
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* DDR power saving */
+#define CONFIG_DDR_ZQ_POWER_DOWN	1
+#define CONFIG_DDR_POWER_DOWN_PHY_VREF	1
+
+/* DDR detection */
+#define CONFIG_DDR_SIZE_AUTO_DETECT	1
+
+/* Platform power init config */
+#define CONFIG_PLATFORM_POWER_INIT
+#define CONFIG_VCCK_INIT_VOLTAGE	1100
+#define CONFIG_VDDEE_INIT_VOLTAGE	1050	// voltage for power up
+#define CONFIG_VDDEE_SLEEP_VOLTAGE	850	// voltage for suspend
+
+/* CEC */
+#define CONFIG_CEC_OSD_NAME		"ODROID-C2"
+#define CONFIG_CEC_WAKEUP
+
+/* Serial config */
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_AML_MESON_SERIAL		1
+#define CONFIG_SERIAL_MULTI		1
+
+#define CONFIG_BOOTDELAY		1	// Seconds
+
+/* args/envs */
+#define CONFIG_SYS_MAXARGS		64
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"boardname=ODROIDC2\0"		\
+	"loadaddr=0x20000000\0"		\
+	"dtbaddr=0x1000000\0"		\
+	"fdt_high=0x20000000\0"		\
+	"hdmimode=720p60hz\0"		\
+	"bootargs=root=/dev/mmcblk0p2 rw init=/init rootwait "	\
+		"console=ttyS0,115200 "				\
+		"hdmimode=720p60hz hdmitx=cecf "		\
+		"logo=osd1,loaded,0x3f800000,720p60hz "		\
+		"androidboot.hardware=odroidc2 androidboot.serialno=${fbt_id#} "	\
+		"androidboot.selinux=disabled  \0"		\
+	"bootcmd=cfgload; showlogo ${hdmimode}; movi read dtb 0 ${dtbaddr}; movi read boot 0 ${loadaddr}; booti ${loadaddr} - ${dtbaddr}\0"
+
+#define CONFIG_PREBOOT
+#define CONFIG_BOOTCOMMAND
+
+//#define CONFIG_ENV_IS_NOWHERE  1
+#define CONFIG_ENV_SIZE			(32 * SZ_1K)	/* 32kB */
+#define CONFIG_ENV_OFFSET		(720 * SZ_1K)	/* FIXME: should be
+							   close to U-boot image
+							   size to save space */
+#define CONFIG_FIT			1
+#define CONFIG_OF_LIBFDT		1
+#define CONFIG_ANDROID_BOOT_IMAGE	1
+#define CONFIG_ANDROID_IMG		1
+#define CONFIG_SYS_BOOTM_LEN		(64 << 20) /* Increase max gunzip size*/
+
+/* Support commands */
+#define CONFIG_CMD_SAVEENV		1
+#define CONFIG_CMD_CACHE		1
+#define CONFIG_CMD_BOOTI		1
+#define CONFIG_CMD_EFUSE		1
+//#define CONFIG_CMD_I2C			1
+#define CONFIG_CMD_MEMORY		1
+#define CONFIG_CMD_FAT			1
+#define CONFIG_CMD_EXT4			1
+#define CONFIG_CMD_GPIO			1
+#define CONFIG_CMD_RUN			1
+#define CONFIG_CMD_REBOOT		1
+#define CONFIG_CMD_ECHO			1
+#define CONFIG_CMD_JTAG			1
+#define CONFIG_CMD_AUTOSCRIPT		1
+#define CONFIG_CMD_BMP			1
+#define CONFIG_CMD_USB			1
+#define CONFIG_CMD_NET			1
+#define CONFIG_CMD_MISC			1
+#define CONFIG_CMD_ITEST		1
+#define CONFIG_CMD_CPU_TEMP		1
+#define CONFIG_CMD_MEMTEST		1
+#define CONFIG_CMD_USB_MASS_STORAGE	1
+#define CONFIG_CMD_FASTBOOT		1
+#define CONFIG_CMD_INI			1
+
+#if defined(CONFIG_CMD_USB_MASS_STORAGE)
+#define CONFIG_USB_GADGET		1
+#define CONFIG_USB_GADGET_MASS_STORAGE	1
+#define CONFIG_USBDOWNLOAD_GADGET	1
+#endif
+
+#if defined(CONFIG_USB_GADGET)
+#define CONFIG_USB_GADGET_DUALSPEED	1
+#define CONFIG_USB_GADGET_S3C_UDC_OTG	1
+#define CONFIG_USB_GADGET_VBUS_DRAW	0
+#define CONFIG_SYS_CACHELINE_SIZE	64
+#endif
+
+#if defined(CONFIG_USBDOWNLOAD_GADGET)
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0002
+#define CONFIG_G_DNL_MANUFACTURER	"Hardkernel Co., Ltd"
+#endif
+
+#if defined(CONFIG_CMD_FASTBOOT)
+#define CONFIG_USB_FASTBOOT_BUF_ADDR	CONFIG_SYS_LOAD_ADDR
+#define CONFIG_USB_FASTBOOT_BUF_SIZE	SZ_512M
+#define CONFIG_FASTBOOT_FLASH		1
+#if defined(CONFIG_FASTBOOT_FLASH)
+#define CONFIG_FASTBOOT_FLASH_MMC_DEV	0
+#endif
+#endif
+
+#if defined(CONFIG_CMD_MEMTEST)
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_LOAD_ADDR
+#define CONFIG_SYS_MEMTEST_END		\
+	(PHYS_SDRAM_1_SIZE - CONFIG_SYS_MEMTEST_START)
+#define CONFIG_SYS_ALT_MEMTEST	1
+#endif
+
+/* File systems */
+#define CONFIG_DOS_PARTITION		1
+#define CONFIG_MMC			1
+#define CONFIG_FS_FAT			1
+#define CONFIG_FS_EXT4			1
+#define CONFIG_LZO			1
+
+/* storage: emmc/nand/sd */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_IS_IN_MMC		1
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_AML_SD_EMMC		1
+
+#if defined(CONFIG_AML_SD_EMMC)
+#define CONFIG_GENERIC_MMC		1
+#define CONFIG_CMD_MMC			1
+#endif
+
+#define	CONFIG_PARTITIONS		1
+#define CONFIG_SYS_NO_FLASH		1
+
+/* VPU */
+#define CONFIG_AML_VPU			1
+
+#if defined(CONFIG_AML_VPU)
+#define CONFIG_VPU_PRESET		1
+#endif
+
+/* DISPLAY & HDMITX */
+#define CONFIG_AML_HDMITX20		1
+#define CONFIG_AML_CANVAS		1
+#define CONFIG_AML_VOUT			1
+#define CONFIG_AML_OSD			1
+#define CONFIG_OSD_SCALE_ENABLE		1
+
+#if defined(CONFIG_AML_VOUT)
+#define CONFIG_AML_CVBS			1
+#endif
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+/* #define CONFIG_MUSB_UDC		1 */
+
+#if defined(CONFIG_CMD_USB)
+#define CONFIG_M8_USBPORT_BASE_A	0xc9000000
+#define CONFIG_M8_USBPORT_BASE_B	0xc9100000
+#define CONFIG_USB_STORAGE		1
+#define CONFIG_USB_DWC_OTG_HCD		1
+#define CONFIG_USB_DWC_OTG_294		1
+#endif
+
+/* NETWORK */
+#if defined(CONFIG_CMD_NET)
+#define CONFIG_AML_ETHERNET		1
+#define CONFIG_NET_MULTI		1
+#define CONFIG_CMD_PING			1
+#define CONFIG_CMD_DHCP			1
+#define CONFIG_CMD_RARP			1
+#if 0
+#define CONFIG_NET_RGMII		1
+#define CONFIG_NET_RMII_CLK_EXTERNAL	1	// Use external 50MHz
+#endif
+
+#define IP101PHY			1
+#define CONFIG_HOSTNAME			odroidc2
+#define CONFIG_ETHADDR			00:15:18:01:81:31	/* MAC address */
+#define CONFIG_GATEWAYIP		192.168.0.1	/* Gateway */
+#define CONFIG_IPADDR			192.168.0.2	/* IP */
+#define CONFIG_NETMASK			255.255.255.0	/* Netmask */
+#define CONFIG_SERVERIP			192.168.0.10	/* TFTP server */
+#endif
+
+/* I2C */
+#if defined(CONFIG_CMD_I2C)
+#define CONFIG_SYS_I2C_AML		1
+#define CONFIG_SYS_I2C_SPEED		400000	// kHz
+#endif
+
+/* MISC */
+#define CONFIG_EFUSE			1
+#define CONFIG_NEED_BL301		1
+#define CONFIG_SYS_LONGHELP		1
+#define CONFIG_SYS_MEM_TOP_HIDE		0x08000000	/* Hide 128MB for
+							   kernel reserve */
+#define CONFIG_DISPLAY_LOGO		1
+#ifdef CONFIG_DISPLAY_LOGO
+#define CONFIG_VIDEO_BMP_GZIP		1
+#define CONFIG_SYS_VIDEO_LOGO_MAX_SIZE	(3 << 20) /* for decompressed img */
+#endif
+
+/* ODROID reboot reasons */
+#define ODROID_REBOOT_CMD_UNKNOWN	-1
+#define ODROID_REBOOT_CMD_COLD		0x0
+#define ODROID_REBOOT_CMD_NORMAL	0x1
+#define ODROID_REBOOT_CMD_FASTBOOT	0x5
+#define ODROID_REBOOT_CMD_RECOVERY	0x6
+
+#endif
diff --git a/include/emmc_partitions.h b/include/emmc_partitions.h
new file mode 100644
index 0000000..aa2e7f0
--- /dev/null
+++ b/include/emmc_partitions.h
@@ -0,0 +1,101 @@
+#ifndef _AML_MMC_H
+#define _AML_MMC_H
+
+#include <asm/io.h>
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <mmc.h>
+#include <part.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <mmc.h>
+#include <div64.h>
+#include <environment.h>
+#include <malloc.h>
+#include <asm/cache.h>
+#include <asm/arch/clock.h>
+#include<partition_table.h>
+#include <storage.h>
+
+#define     AML_MMC_DBG
+
+#define     MAX_DEVICE_NUM                  16
+#define     MAX_DEVICE_NAME_LEN             16
+#define     MAX_MMC_PART_NUM                16
+#define     MAX_MMC_PART_NAME_LEN           16
+
+#define		SZ_1M							0x100000
+#define     PARTITION_RESERVED              (8*SZ_1M)  // 8MB
+#define     MMC_BOOT_PARTITION_RESERVED     (32*SZ_1M) // 32MB
+
+#define     MMC_BOOT_NAME                   "bootloader"
+#define     MMC_BOOT_DEVICE_SIZE            (0x4*SZ_1M)
+
+#define     MMC_RESERVED_NAME               "reserved"
+#define     MMC_RESERVED_SIZE               (64*SZ_1M)
+
+#define     MMC_CACHE_NAME                  "cache"
+// #define     MMC_CACHE_SIZE                  (512*SZ_1M) // this is not used and should be get from spl
+
+#define     MMC_ENV_NAME                    "env"
+#define     MMC_ENV_SIZE                    (8*SZ_1M)
+
+// #define     MMC_KEY_NAME                    "key"
+#define     MMC_KEY_SIZE                    (256*1024)
+#define     EMMCKEY_RESERVE_OFFSET           (0x4000)
+#define     MMC_RESERVED_OFFSET              (36*SZ_1M)
+#define     MMC_BLOCK_SIZE                   (512)
+// #define     MMC_SECURE_NAME                 "secure"
+// #define     MMC_SECURE_SIZE                 (0x1*SZ_1M)
+
+#define     MMC_UBOOT_VERSION               "01.00.00"
+
+#define     MMC_PARTITIONS_MAGIC            "MPT" // MMC Partition Table
+#define     MMC_CARD_PARTITION_NAME         "card"
+
+#ifdef AML_MMC_DBG
+#define aml_mmc_dbg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+                  __func__, __LINE__, ##__VA_ARGS__)
+
+#define aml_mmc_msg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+                  __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define aml_mmc_dbg(fmt, ...)
+#define aml_mmc_msg(fmt, ...) printk( fmt "\n",  ##__VA_ARGS__)
+#endif
+
+struct mmc_partitions_fmt {
+    char magic[4];
+    unsigned char version[12];
+    int part_num;
+    int checksum;
+    struct partitions partitions[MAX_MMC_PART_NUM];
+};
+
+struct mmc_partition_config{
+    unsigned char version[12];
+    int part_num;
+    struct partitions partitions[MAX_MMC_PART_NUM];
+    unsigned option;
+    void * private_data;
+};
+
+/*
+struct _mmc_device{
+    char name[MAX_DEVICE_NAME_LEN];
+    uint64_t  offset;
+    uint64_t  size;
+    void * private_data;
+    struct list_head list;
+};
+*/
+
+extern bool is_partition_checked;
+
+struct partitions* find_mmc_partition_by_name (char *name);
+bool aml_is_emmc_tsd (struct mmc *mmc);
+int mmc_device_init (struct mmc *mmc);
+
+#endif
+
diff --git a/include/image.h b/include/image.h
index af30d60..7425b14 100644
--- a/include/image.h
+++ b/include/image.h
@@ -1080,6 +1080,8 @@ int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
 			      ulong *rd_data, ulong *rd_len);
 ulong android_image_get_end(const struct andr_img_hdr *hdr);
 ulong android_image_get_kload(const struct andr_img_hdr *hdr);
+ulong android_image_get_comp(const struct andr_img_hdr *hdr);
+int android_image_need_move(ulong *img_addr,const struct andr_img_hdr *hdr);
 
 #endif /* CONFIG_ANDROID_BOOT_IMAGE */
 
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8438490..b717292 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -65,7 +65,7 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
  * adjust this accordingly.
  */
 #define NAND_MAX_OOBSIZE       744
-#define NAND_MAX_PAGESIZE      8192
+//#define NAND_MAX_PAGESIZE      8192
 #endif
 
 /*
@@ -561,10 +561,10 @@ struct nand_buffers {
 	uint8_t *ecccalc;
 	uint8_t *ecccode;
 	uint8_t *databuf;
-#else
-	uint8_t	ecccalc[ALIGN(NAND_MAX_OOBSIZE, ARCH_DMA_MINALIGN)];
-	uint8_t	ecccode[ALIGN(NAND_MAX_OOBSIZE, ARCH_DMA_MINALIGN)];
-	uint8_t databuf[ALIGN(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE,
+//#else
+//	uint8_t	ecccalc[ALIGN(NAND_MAX_OOBSIZE, ARCH_DMA_MINALIGN)];
+//	uint8_t	ecccode[ALIGN(NAND_MAX_OOBSIZE, ARCH_DMA_MINALIGN)];
+//	uint8_t databuf[ALIGN(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE,
 			      ARCH_DMA_MINALIGN)];
 #endif
 };
@@ -1009,8 +1009,9 @@ static inline int nand_opcode_8bits(unsigned int command)
 /* return the supported JEDEC features. */
 static inline int jedec_feature(struct nand_chip *chip)
 {
-	return chip->jedec_version ? le16_to_cpu(chip->jedec_params.features)
-		: 0;
+	//return chip->jedec_version ? le16_to_cpu(chip->jedec_params.features)
+	//	: 0;
+	return 0;
 }
 
 #ifdef __UBOOT__
diff --git a/include/mmc.h b/include/mmc.h
index 7ec255d..a5c0bcb 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -313,6 +313,7 @@ struct mmc {
 	u64 capacity_boot;
 	u64 capacity_rpmb;
 	u64 capacity_gp[4];
+	u64 boot_size;
 	block_dev_desc_t block_dev;
 	char op_cond_pending;	/* 1 if we are waiting on an op_cond command */
 	char init_in_progress;	/* 1 if we have done mmc_start_init() */
@@ -354,6 +355,8 @@ int mmc_rpmb_read(struct mmc *mmc, void *addr, unsigned short blk,
 		  unsigned short cnt, unsigned char *key);
 int mmc_rpmb_write(struct mmc *mmc, void *addr, unsigned short blk,
 		   unsigned short cnt, unsigned char *key);
+
+int mmc_switch_partition(struct mmc* mmc, unsigned int part);
 /**
  * Start device initialization and return immediately; it does not block on
  * polling OCR (operation condition register) status.  Then you should call
diff --git a/include/partition_table.h b/include/partition_table.h
new file mode 100644
index 0000000..5e6b151
--- /dev/null
+++ b/include/partition_table.h
@@ -0,0 +1,65 @@
+#ifndef _PARTITION_TABLE_H
+#define _PARTITION_TABLE_H
+// #ifdef CONFIG_STORE_COMPATIBLE
+#include <storage.h>
+// #endif
+//#include <asm/arch/nand.h>
+//#include <asm/arch/poc.h>
+
+
+//#define STORE_DBG
+#ifdef STORE_DBG
+#define store_dbg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+				  __func__, __LINE__, ##__VA_ARGS__)
+
+#define store_msg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+				  __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define store_dbg(fmt, ...)
+#define store_msg(fmt, ...) printk( fmt "\n",  ##__VA_ARGS__)
+#endif
+
+//boot_flag
+//#define R_BOOT_DEVICE_FLAG  READ_CBUS_REG(ASSIST_POR_CONFIG)
+
+//#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+//#define POR_BOOT_VALUE 	((((R_BOOT_DEVICE_FLAG>>9)&1)<<2)|((R_BOOT_DEVICE_FLAG>>6)&3))
+//#else
+//#define POR_BOOT_VALUE 	(R_BOOT_DEVICE_FLAG & 7)
+//#endif
+
+//#if 1 /*defined in poc.h*/
+//#define POR_NAND_BOOT()	 ((POR_BOOT_VALUE == 7) || (POR_BOOT_VALUE == 6))
+//#define POR_SPI_BOOT()  		((POR_BOOT_VALUE == 5) || (POR_BOOT_VALUE == 4))
+//#define POR_EMMC_BOOT()	((IS_MESON_M8M2_CPU | IS_MESON_M8BABY_CPU)?((POR_BOOT_VALUE == 3) || ((POR_BOOT_VALUE == 1))):(POR_BOOT_VALUE == 3))
+//#define POR_CARD_BOOT() 	(POR_BOOT_VALUE == 0)
+//#endif
+
+#define SPI_BOOT_FLAG 			0
+#define NAND_BOOT_FLAG 		1
+#define EMMC_BOOT_FLAG 		2
+#define CARD_BOOT_FLAG 		3
+#define SPI_NAND_FLAG			4
+#define SPI_EMMC_FLAG			5
+
+#define _AML_DEVICE_BOOT_FLAG_DEFAULT   (0XFFFFFFFF)
+extern unsigned  device_boot_flag;
+
+#define START_ADDR 			0xd9000200
+#define TABLE_MAGIC_NAME  		"part"
+#define STORE_MAGIC_NAME  		"stor"
+#define ACS_SET_LEN 			 128
+
+extern int info_disprotect;
+
+#define DISPROTECT_KEY    		1
+#define DISPROTECT_SECURE		1<<1
+#define DISPROTECT_FBBT		1<<2
+#define DISPROTECT_HYNIX		1<<3
+
+extern int get_partition_from_dts(unsigned char * buffer);
+
+extern int get_partitions_table(struct partitions **table);
+
+#endif// #ifndef _PARTITION_TABLE_H
+
diff --git a/include/storage.h b/include/storage.h
new file mode 100644
index 0000000..5a9caf4
--- /dev/null
+++ b/include/storage.h
@@ -0,0 +1,68 @@
+/***********************************************
+*****Storage config of board, for ACS use.*****
+***********************************************/
+
+#ifndef __STORAGE_H
+#define __STORAGE_H
+
+#include <linux/types.h>
+#include <asm/arch/romboot.h>
+#ifndef __ASSEMBLY__
+
+//Partition table defines
+#define NAND_PART_SIZE_FULL		-1
+#define MAX_PART_NUM			16
+#define	 MAX_PART_NAME_LEN		16
+//#define 	SZ_1M 					0x100000
+
+#define STORE_CODE		1
+#define	STORE_CACHE		(1<<1)
+#define STORE_DATA		(1<<2)
+
+#define SPI_BOOT_FLAG		0
+#define NAND_BOOT_FLAG 		1
+#define EMMC_BOOT_FLAG 		2
+#define CARD_BOOT_FLAG 		3
+#define SPI_NAND_FLAG		4
+#define SPI_EMMC_FLAG		5
+
+#define CARD_TYPE_SHIFT		4
+#define CARD_TYPE_MASK		0xf
+#define CARD_TYPE_UNKNOWN	0        /* unknown */
+//#define CARD_TYPE_MMC		1        /* MMC card */
+//#define CARD_TYPE_SD		2        /* SD card */
+#define CARD_TYPE_SDIO		3        /* SDIO card */
+#define CARD_TYPE_SD_COMBO	4        /* SD combo (IO+mem) card */
+#define CARD_TYPE_NON_SDIO	5        /* NON sdio device (means SD/MMC card) */
+
+#define AML_GET_CARD_TYPE(val, port)    ((val >> (port * CARD_TYPE_SHIFT)) & CARD_TYPE_MASK)
+#define AML_SET_CARD_TYPE(val, port, type)   \
+    (val |= ((type & CARD_TYPE_MASK) << (port * CARD_TYPE_SHIFT)))
+
+struct partitions {
+	char name[MAX_PART_NAME_LEN];			/* identifier string */
+	uint64_t size;			/* partition size */
+	uint64_t offset;		/* offset within the master space */
+	unsigned mask_flags;		/* master flags to mask out for this partition */
+};
+
+struct config_nand {
+	unsigned enable_slc;
+	unsigned order_ce;
+	unsigned reserved[2];
+};
+
+struct config_mmc {
+	unsigned type;
+	unsigned port;
+	unsigned reserved[2];
+};
+
+struct store_config {
+	unsigned  store_device_flag;			// indicate storage devices on each board
+	struct config_nand  nand_configs;			// specital config for nand
+	struct config_mmc  mmc_configs;			// specital config for mmc
+};
+
+#endif
+#endif
diff --git a/include/usb.h b/include/usb.h
index d3c7415..a5349f1 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -13,6 +13,7 @@
 #include <linux/usb/ch9.h>
 #include <asm/cache.h>
 #include <part.h>
+#include <asm/arch/timer.h>
 
 /*
  * The EHCI spec says that we must align to at least 32 bytes.  However,
@@ -157,6 +158,9 @@ enum usb_init_type {
 	defined(CONFIG_USB_MUSB_OMAP2PLUS) || defined(CONFIG_USB_XHCI) || \
 	defined(CONFIG_USB_DWC2)
 
+//void wait_ms(unsigned long ms);
+void _mdelay(unsigned long ms);
+
 int usb_lowlevel_init(int index, enum usb_init_type init, void **controller);
 int usb_lowlevel_stop(int index);
 
diff --git a/include/usb/fastboot.h b/include/usb/fastboot.h
new file mode 100644
index 0000000..2d87b45
--- /dev/null
+++ b/include/usb/fastboot.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef FASTBOOT_H
+#define FASTBOOT_H
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+#ifdef CONFIG_CMD_FASTBOOT
+
+typedef struct fastboot_ptentry fastboot_ptentry;
+
+/*
+ * fastboot partitions entry
+ */
+struct fastboot_ptentry {
+	char name[16];		/* partitin name, null terminated */
+	unsigned int start;	/* start of partition, must be multiple of block
+				   size */
+	unsigned int length;	/* length of partiton, must be multiple of block
+				   size in bytes */
+	unsigned int flags;	/* partition details for control */
+};
+
+/* Lower byte shows if the read/write/erase operation in
+   repeated.  The base address is incremented.
+   Either 0 or 1 is ok for a default */
+
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK(n)		(n & 0x0f)
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT_4			0x00000004
+
+/* Writes happen a block at a time.
+   If the write fails, go to next block
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK	0x00000010
+
+/* Find a contiguous block big enough for a the whole file
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK	0x00000020
+
+/* Sets the ECC to software before writing
+   HW and SW ECC should not both be set. */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_SW_ECC		0x00000040
+
+/* Sets the ECC to hardware before writing
+   HW and SW ECC should not both be set. */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_HW_ECC		0x00000080
+
+/* Sets the ECC to hardware before writing
+   HW and SW ECC should not both be set. */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_HW_BCH4_ECC	0x00000100
+
+/* Sets the ECC to hardware before writing
+   HW and SW ECC should not both be set. */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_HW_BCH8_ECC	0x00000200
+
+/* Sets the ECC to hardware before writing
+   HW and SW ECC should not both be set. */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_HW_BCH16_ECC	0x00000400
+
+/* Write the file with write.i */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_I			0x00000800
+
+/* Write the file with write.jffs2 */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_JFFS2		0x00001000
+
+/* Write the file as a series of variable/value pairs
+   using the setenv and saveenv commands */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_ENV		0x00002000
+
+/*
+ * Fastboot tool functions
+ */
+void fastboot_flash_reset_ptn(void);
+void fastboot_flash_add_ptn(fastboot_ptentry *ptn);
+void fastboot_flash_dump_ptn(void);
+unsigned int fastboot_flash_get_ptn_count(void);
+fastboot_ptentry *fastboot_flash_find_ptn(const char *name);
+fastboot_ptentry *fastboot_flash_get_ptn(unsigned n);
+int fastboot_load_dos_partition(void);
+
+int do_format(void);
+
+int board_partition_init(void);
+char *board_dos_partition_name(int part, char* name);
+lbaint_t board_dos_partition_start(void);
+lbaint_t board_dos_partition_next(int *part, u8* type);
+__weak int board_fastboot_pre_flash(block_dev_desc_t *dev_desc, lbaint_t start,
+		void *buffer);
+
+#endif
+#endif
diff --git a/include/usb/s3c_udc.h b/include/usb/s3c_udc.h
index 7f49a4e..cc7928e 100644
--- a/include/usb/s3c_udc.h
+++ b/include/usb/s3c_udc.h
@@ -20,7 +20,7 @@
 
 /*-------------------------------------------------------------------------*/
 /* DMA bounce buffer size, 16K is enough even for mass storage */
-#define DMA_BUFFER_SIZE	(16*SZ_1K)
+#define DMA_BUFFER_SIZE	(4096*4)
 
 #define EP0_FIFO_SIZE		64
 #define EP_FIFO_SIZE		512
@@ -82,6 +82,9 @@ struct s3c_udc {
 
 	struct s3c_plat_otg_data *pdata;
 
+	void *dma_buf[S3C_MAX_ENDPOINTS+1];
+	dma_addr_t dma_addr[S3C_MAX_ENDPOINTS+1];
+
 	int ep0state;
 	struct s3c_ep ep[S3C_MAX_ENDPOINTS];
 
diff --git a/include/video_fb.h b/include/video_fb.h
index 55ec24d..2f8a894 100644
--- a/include/video_fb.h
+++ b/include/video_fb.h
@@ -48,6 +48,8 @@ typedef struct graphic_device {
     unsigned int cprBase;
     unsigned int frameAdrs;
     unsigned int memSize;
+    unsigned int fb_width;
+    unsigned int fb_height;
     unsigned int mode;
     unsigned int gdfIndex;
     unsigned int gdfBytesPP;
diff --git a/include/vpu.h b/include/vpu.h
new file mode 100644
index 0000000..d642191
--- /dev/null
+++ b/include/vpu.h
@@ -0,0 +1,12 @@
+#ifndef _VPU_INC_H_
+#define _VPU_INC_H_
+
+#ifdef CONFIG_AML_VPU
+extern void vcbus_test(void);
+extern int vpu_probe(void);
+extern int vpu_remove(void);
+extern int vpu_clk_change(int level);
+extern void vpu_clk_get(void);
+#endif
+
+#endif
diff --git a/mk b/mk
new file mode 100644
index 0000000..aa78fbe
--- /dev/null
+++ b/mk
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+make SOC=gxb distclean
+make $1'_config'
+make -j
+
diff --git a/scripts/Makefile.autoconf b/scripts/Makefile.autoconf
old mode 100644
new mode 100755
index 8e9d71f..2dafb3a
--- a/scripts/Makefile.autoconf
+++ b/scripts/Makefile.autoconf
@@ -78,7 +78,8 @@ define filechk_config_h
 	echo \#include \<configs/$(CONFIG_SYS_CONFIG_NAME).h\>;		\
 	echo \#include \<asm/config.h\>;				\
 	echo \#include \<config_fallbacks.h\>;				\
-	echo \#include \<config_uncmd_spl.h\>; )
+	echo \#include \<config_uncmd_spl.h\>; \
+	echo \#define SYS_PROMPT \"$(BOARD)\#\"; )
 endef
 
 include/config.h: scripts/Makefile.autoconf create_symlink FORCE
@@ -91,6 +92,9 @@ ifneq ($(KBUILD_SRC),)
 	$(Q)mkdir -p include/asm
 	$(Q)ln -fsn $(KBUILD_SRC)/arch/$(ARCH)/include/asm/arch-$(if $(SOC),$(SOC),$(CPU)) \
 		include/asm/arch
+	$(Q)mkdir -p include2
+	$(Q)ln -fsn $(KBUILD_SRC)/arch/$(ARCH)/include/asm \
+		include2/asm
 else
 	$(Q)ln -fsn arch-$(if $(SOC),$(SOC),$(CPU)) \
 		arch/$(ARCH)/include/asm/arch
diff --git a/scripts/amlogic/coding_style/auto_fix.py b/scripts/amlogic/coding_style/auto_fix.py
new file mode 100644
index 0000000..498cfae
--- /dev/null
+++ b/scripts/amlogic/coding_style/auto_fix.py
@@ -0,0 +1,255 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+# Amlogic gerrit code auto-fix script
+# Author: xiaobo.gu@amlogic.com
+# Init version: 2015.05.01
+
+import sys, os
+import json
+
+MESSAGE_INFO_1 = "trailing spaces"
+MESSAGE_INFO_2 = "spacing around parenthesis"
+MESSAGE_INFO_3 = "spacing around =="
+MESSAGE_INFO_4 = "spacing around !="
+MESSAGE_INFO_5 = "do {"
+MESSAGE_INFO_6 = "file should not be executable"
+MESSAGE_INFO_7 = "possibly incorrect mixed spaces then tabs indentation"
+MESSAGE_INFO_8 = "file should not have carriage returns"
+MESSAGE_INFO_9 = "make sure indent style matches rest of file"
+MESSAGE_INFO_10 = "spacing around &&"
+MESSAGE_INFO_11 = "spacing around ||"
+MESSAGE_INFO_12 = "spacing around >="
+MESSAGE_INFO_13 = "spacing around <="
+
+class fixer(object):
+	def __init__(self, filename):
+		self.filename = filename
+		self.info_review = None
+		self.info_comment = None
+		self.info_labels = None
+		self.cur_file_name = ""
+		self.cur_file_lines = 0
+		self.cur_file_content = ""
+		self.cur_line_content = ""
+		self.cur_line = 0
+		self.cur_message = ""
+		self.verified = -1
+
+	def read_log(self):
+		self.file_handle = open(self.filename)
+		self.info_str = self.file_handle.read()
+		self.file_handle.close()
+		self.info_review = json.loads(self.info_str)
+		self.info_comment = self.info_review.get("comments")
+		self.info_labels = self.info_review.get("labels")
+
+	def fix(self):
+		self.verified = self.info_labels.get("Verified")
+		if(1 == self.verified):
+			print "Verified +1, Quit..."
+			return
+		for file_info in self.info_comment:
+			print file_info
+			#print self.cur_file_content
+			#for line in self.cur_file_content:
+			#	print line,
+			# start fix for each warning line
+			for message_info in self.info_comment[file_info]:
+				self.cur_file_name = file_info
+				self.cur_message = message_info.get("message")
+				self.cur_line = (int)(message_info.get("line")) - 1 # index-1
+
+				if (self.cur_line >= 0):
+					# <0 always means line0 error,
+					# that means file format error etc..
+					# it's no need open the file
+					cur_file = open(file_info) # open current file
+					self.cur_file_content = cur_file.readlines() # get all content of current file, and split info lines
+					cur_file.close() # close current file
+					self.cur_file_lines = len(self.cur_file_content)
+					self.cur_line_content = str(self.cur_file_content[self.cur_line])
+				self.message_handler()
+				if (self.cur_line >= 0):
+					# <0 always means line0 error,
+					# that means file format error etc..
+					# it's no need write back current line
+					self.cur_file_content[self.cur_line] = self.cur_line_content
+					cur_file = open(file_info, 'w') # open current file
+					cur_file.writelines(self.cur_file_content) # save file
+					cur_file.close() # close current file
+
+	def message_handler(self):
+		if (self.cur_message.find(MESSAGE_INFO_1) >= 0):
+			self.message_1()
+		if (self.cur_message.find(MESSAGE_INFO_2) >= 0):
+			self.message_2()
+		if (self.cur_message.find(MESSAGE_INFO_3) >= 0):
+			self.message_3()
+		if (self.cur_message.find(MESSAGE_INFO_4) >= 0):
+			self.message_4()
+		if (self.cur_message.find(MESSAGE_INFO_5) >= 0):
+			self.message_5()
+		if (self.cur_message.find(MESSAGE_INFO_6) >= 0):
+			self.message_6()
+		if (self.cur_message.find(MESSAGE_INFO_7) >= 0):
+			self.message_7()
+		if (self.cur_message.find(MESSAGE_INFO_8) >= 0):
+			self.message_8()
+		if (self.cur_message.find(MESSAGE_INFO_9) >= 0):
+			self.message_9()
+		if (self.cur_message.find(MESSAGE_INFO_10) >= 0):
+			self.message_10()
+		if (self.cur_message.find(MESSAGE_INFO_11) >= 0):
+			self.message_11()
+		if (self.cur_message.find(MESSAGE_INFO_12) >= 0):
+			self.message_12()
+		if (self.cur_message.find(MESSAGE_INFO_13) >= 0):
+			self.message_13()
+
+	def message_1(self):
+		# acknowledge bug: can not fix last line with last blank character
+		'''MESSAGE_INFO_1 start'''
+		#print "		-", self.cur_line, self.cur_line_content,
+		cur_line_length = len(self.cur_line_content)
+		#print "cur_line_length", cur_line_length
+		#print self.cur_line_content
+		for cur_length in range(cur_line_length-1):
+			#print cur_length
+			cur_char_pos = cur_line_length-2-cur_length
+			#print cur_char_pos
+			#print self.cur_line_content[cur_char_pos]
+			#print self.cur_line_content
+			#print self.cur_line_content[0:cur_char_pos], "test"
+			if (self.cur_line_content[cur_char_pos] == ' ') or \
+				(self.cur_line_content[cur_char_pos] == '	') :
+				self.cur_line_content = self.cur_line_content[0:cur_char_pos] + '\n'
+				#print self.cur_line_content
+			else:
+				break
+		'''MESSAGE_INFO_1 end'''
+
+	def message_2(self):
+		'''MESSAGE_INFO_2 start'''
+		cur_line_length = len(self.cur_line_content)
+		# search parenthesis from left
+		pare_pos_left = self.cur_line_content.find('(')
+		#print "self.cur_line_content[pare_pos_left]:", self.cur_line_content[pare_pos_left-1]
+		#print self.cur_line_content
+		# insert blank char if doesn't have one
+		if (pare_pos_left > 0) and (' ' != self.cur_line_content[pare_pos_left-1]):
+			self.cur_line_content = self.cur_line_content[0:pare_pos_left] + ' ' + self.cur_line_content[pare_pos_left:cur_line_length]
+		#print self.cur_line_content
+		# re-calculate cur line length, maybe previous operations changed it's content
+		cur_line_length = len(self.cur_line_content)
+		# search parenthesis from right
+		pare_pos_right = self.cur_line_content.rfind(')')
+		if ((pare_pos_right+1) <= cur_line_length):
+			#print "self.cur_line_content[pare_pos_right]:", self.cur_line_content[pare_pos_right+1]
+			#print self.cur_line_content
+			if (pare_pos_right > 0) and (' ' != self.cur_line_content[pare_pos_right+1]) and \
+				('\n' != self.cur_line_content[pare_pos_right+1]):
+				self.cur_line_content = self.cur_line_content[0:pare_pos_right+1] + ' ' + self.cur_line_content[pare_pos_right+1:cur_line_length]
+			#print self.cur_line_content
+		'''MESSAGE_INFO_2 end'''
+
+	def message_3(self):
+		self.message_space_around("==")
+
+	def message_4(self):
+		self.message_space_around("!=")
+
+	def message_5(self):
+		cur_line_length = len(self.cur_line_content)
+		msg_pos = self.cur_line_content.find("do")
+		#print "self.cur_line_content[msg_pos+2]", self.cur_line_content[msg_pos+2]
+		if (' ' != self.cur_line_content[msg_pos+2]):
+			self.cur_line_content = self.cur_line_content[0:msg_pos+2] + ' ' + self.cur_line_content[msg_pos+2:cur_line_length]
+
+	def message_6(self):
+		shell_cmd = "chmod -x " + self.cur_file_name
+		os.system(shell_cmd)
+
+	def message_7(self):
+		cur_line_length = len(self.cur_line_content)
+		cur_line_first_noblank_pos = 0
+		# find out first non-blank(' '&'	') char
+		for cur_char_pos in range(cur_line_length):
+			if (' ' != self.cur_line_content[cur_char_pos]) and \
+				('	' != self.cur_line_content[cur_char_pos]):
+				cur_line_first_noblank_pos = cur_char_pos
+				break
+		#print self.cur_line_content
+		# replace these 4' 's with tab, 1,2,3 blanks will be deleted
+		no_blank_str = self.cur_line_content[0:cur_line_first_noblank_pos]
+		no_blank_str = no_blank_str.replace("    ", "	")
+		no_blank_str = no_blank_str.replace("   ", "")
+		no_blank_str = no_blank_str.replace("  ", "")
+		no_blank_str = no_blank_str.replace(" ", "")
+		self.cur_line_content = no_blank_str + self.cur_line_content[cur_line_first_noblank_pos:cur_line_length]
+
+	def message_8(self):
+		shell_cmd = "dos2unix -o -f " + self.cur_file_name
+		os.system(shell_cmd)
+
+	def message_9(self):
+		cur_line_length = len(self.cur_line_content)
+		cur_line_first_noblank_pos = 0
+		# find out first non-blank(' '&'	') char
+		for cur_char_pos in range(cur_line_length):
+			if (' ' != self.cur_line_content[cur_char_pos]) and \
+				('	' != self.cur_line_content[cur_char_pos]):
+				cur_line_first_noblank_pos = cur_char_pos
+				break
+		no_blank_str = self.cur_line_content[0:cur_line_first_noblank_pos]
+		no_blank_str_tmp = no_blank_str.replace("    ", "	")
+		if (no_blank_str_tmp == no_blank_str):
+			no_blank_str = no_blank_str.replace("	", "    ")
+		else:
+			no_blank_str = no_blank_str_tmp
+		#print self.cur_line_content
+		self.cur_line_content = no_blank_str + self.cur_line_content[cur_line_first_noblank_pos:cur_line_length]
+		#print self.cur_line_content
+
+	def message_10(self):
+		self.message_space_around("&&")
+
+	def message_11(self):
+		self.message_space_around("||")
+
+	def message_12(self):
+		self.message_space_around(">=")
+
+	def message_13(self):
+		self.message_space_around("<=")
+
+	def message_space_around(self, symbol):
+		replace_symbol = []
+		replace_symbol.append(' ' + symbol + ' ')
+		replace_symbol.append(' ' + symbol)
+		replace_symbol.append(symbol + ' ')
+		#print self.cur_line_content
+		for rep in range(len(replace_symbol)):
+			self.cur_line_content = self.cur_line_content.replace(replace_symbol[rep], symbol)
+		self.cur_line_content = self.cur_line_content.replace(symbol, replace_symbol[0])
+		#print self.cur_line_content
+
+	def printf(self):
+		#print "comment: ", self.info_comment
+		#print "labels: ", self.info_labels
+		for file_info in self.info_comment:
+			print file_info
+			for message_info in self.info_comment[file_info]:
+				print "		", message_info
+
+	def run(self):
+		self.read_log()
+		#self.printf()
+		self.fix()
+
+if __name__=='__main__':
+	if len(sys.argv) != 2:
+		print 'auto_fix.py [review_log_file]'
+		exit(1)
+	fixer = fixer(sys.argv[1])
+	fixer.run()
diff --git a/scripts/amlogic/coding_style/checkpatch.py b/scripts/amlogic/coding_style/checkpatch.py
new file mode 100644
index 0000000..15e94ab
--- /dev/null
+++ b/scripts/amlogic/coding_style/checkpatch.py
@@ -0,0 +1,346 @@
+#!/usr/bin/env python2
+
+import json
+import logging
+import os.path
+import re
+import pprint
+import sys
+
+__author__ = 'lawrence'
+
+MAX_TRAILING_SPACES_MSGS_PER_FILE = 1000
+MAX_MIXED_TABS_MSGS_PER_FILE = 1000
+MAX_SPACING_MSGS_PER_FILE = 1000
+MAX_INDENT_MSGS_PER_FILE = 1000
+
+INDENT_UNKNOWN = 0
+INDENT_SPACES = 1
+INDENT_TABS = 2
+
+class ChangedFile:
+    SOURCE_EXT = ['.c', '.cpp', '.cc', '.h', '.java', '.mk', '.xml']
+    C_JAVA_EXT = ['.c', '.cpp', '.java']
+    TEXT_RESOURCE_EXT = ['.rc', '.prop', '.te', '.kl', '.cfg', '.conf', '.dtd']
+    BINARY_RESOURCE_EXT = ['.txt', '.so', '.ko', '.apk', '.png', '.jpg', '.jpeg', '.gif']
+
+    def __init__(self, filename=None, is_new=False, mode=None):
+        self.filename = filename
+        self.file_ext = None
+        if filename:
+            self.on_update_filename()
+        self.is_new = is_new
+        self.mode = mode
+        self.formattable_carriage_returns = False
+        self.comments = {}
+
+    def on_update_filename(self):
+        if not self.filename:
+            logging.error("couldn't get filename")
+            return
+        self.file_ext = os.path.splitext(self.filename)[1].lower()
+
+    def is_source(self):
+        #if self.file_ext in self.SOURCE_EXT:
+        #    return True
+        return True # return true directly, doesn't check file type
+        if self.filename:
+            b = os.path.basename(self.filename)
+            if (b and (
+                    b.startswith("Kconfig") or
+                    b == "Makefile")):
+                return True
+        return False
+
+    def is_binary_resource(self):
+        if self.file_ext in self.BINARY_RESOURCE_EXT:
+            return True
+        return False
+
+    def is_text_resource(self):
+        if self.file_ext in self.TEXT_RESOURCE_EXT:
+            return True
+        return False
+
+    def has_errors(self):
+        if self.comments:
+            return True
+        # same as add_file_comments:
+        if self.mode == 755 and self.should_not_be_executable():
+            return True
+        if self.formattable_carriage_returns and self.should_not_have_carriage_return():
+            return True
+        return False
+
+    def should_check_line_diff(self):
+        if self.is_source() or self.is_text_resource():
+            return True
+        return False
+
+    def should_not_be_executable(self):
+        return self.is_source() or self.is_text_resource() or self.is_binary_resource()
+
+    def should_not_have_carriage_return(self):
+        if self.is_new:
+            if self.is_source() or self.is_text_resource():
+                return True
+        return False
+
+    def should_check_statement_spacing(self):
+        if self.file_ext in self.C_JAVA_EXT:
+            return True
+        return False
+
+    def should_check_indent(self):
+        if self.file_ext in self.C_JAVA_EXT:
+            return True
+        return False
+
+    def add_file_comments(self):
+        if self.mode == 755 and self.should_not_be_executable():
+            self.append_comment(0, "{} file should not be executable".format(self.file_ext))
+        if self.formattable_carriage_returns and self.should_not_have_carriage_return():
+            self.append_comment(0, "{} file should not have carriage returns (DOS line endings)".format(self.file_ext))
+
+    def append_comment(self, line, msg):
+        if line in self.comments:
+            self.comments[line] += "\n\n"
+            self.comments[line] += msg
+        else:
+            self.comments[line] = msg
+
+
+    # types of files/checks
+    # source/resource:
+    #       should be non-executable            (new/changed source + .ko, etc)
+    #   source:
+    #       should not have carriage return     (new source + text resources)
+    #   text resource:
+    #       should not have trailing spaces     (source + text resources)
+    #       should not have mixed spaces/tabs   (source + text resources)
+    #   source + syntax
+    #       should have space in if statements  (source c/java)
+    #       added line indent should match context
+    # *could be imported code - warn only..?
+
+
+def check(filename):
+    """
+    Checks unified diff.
+    :param filename: diff file to check
+    :return: 0 on patch errors, 1 on no patch errors, < 0 on other errors
+    """
+    if not filename:
+        return -1
+
+    try:
+        with open(filename) as fp:
+            return check_fp(fp)
+    except OSError:
+        logging.error(" failed to open? OSError %s", filename)
+        return -2
+    except IOError:
+        logging.error(" failed to open? IOError %s", filename)
+        return -3
+    return -4
+
+
+# TODO split checks into separate functions
+def check_fp(fp):
+    file_sections = []
+    f = None
+    check_lines = False
+    check_statement_spacing = False
+    trailing_sp_msg_count = 0
+    mixed_tabs_msg_count = 0
+    spacing_msg_count = 0
+    in_line_diff = False
+    section_line_start = 0
+    section_line_start_err = False
+    cur_line = 0
+    for line in fp:
+        if line.startswith("diff"):
+            if f and f.has_errors():
+                f.add_file_comments()
+                file_sections.append(f)
+            # start of new file
+            f = ChangedFile()
+            check_lines = False
+            trailing_sp_msg_count = 0
+            mixed_tabs_msg_count = 0
+            spacing_msg_count = 0
+            indent_msg_count = 0
+            context_indent = INDENT_UNKNOWN
+            in_line_diff = False
+
+            # get filename
+            # might fail on paths like "dir b/file.txt"
+            m = re.match(r"^diff --git a/(.*) b/.*", line)
+            if m:
+                f.filename = m.group(1)
+                f.on_update_filename()
+                check_lines = f.should_check_line_diff()
+                check_statement_spacing = f.should_check_statement_spacing()
+                check_indent = f.should_check_indent()
+        elif line.startswith("new file mode "):
+            f.is_new = True
+            if line.startswith("100755", len("new file mode ")):
+                f.mode = 755
+        elif line.startswith("new mode 100755"):
+            f.mode = 755
+        elif f and not f.filename and line.startswith("+++ b/"):
+            # get filename if previously failed for some reason
+            f.filename = line[len("+++ b/"):].rstrip('\r\n ')
+            f.on_update_filename()
+            check_lines = f.should_check_line_diff()
+            check_statement_spacing = f.should_check_statement_spacing()
+            check_indent = f.should_check_indent()
+        else:
+            if not check_lines:
+                continue
+            if line.startswith("@@ "):
+                # keep track of line numbers
+                # @@ -584,7 +681,7 @@
+                m = re.match(r"^@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)?\ @@", line)
+                try:
+                    section_line_start = int(m.group(1))
+                except ValueError:
+                    logging.error("failed to parse section line start")
+                    section_line_start_err = True
+                in_line_diff = True
+                cur_line = section_line_start - 1  # next line is the start
+                continue
+            if in_line_diff:
+                # keep track of line numbers
+                if line[0] in ' +':
+                    cur_line += 1
+                # get last context line's indent
+                if line[0] == " ":
+                    if line.startswith("    ", 1):
+                        context_indent = INDENT_SPACES
+                    elif line.startswith("\t", 1):
+                        context_indent = INDENT_TABS
+            if line[0] == '+' and line[1] != '+':
+                if check_lines and not section_line_start_err:
+                    if (f.is_new and
+                            not f.formattable_carriage_returns and
+                                line[-2] == '\r'):
+                        f.formattable_carriage_returns = True
+
+                    if trailing_sp_msg_count < MAX_TRAILING_SPACES_MSGS_PER_FILE:
+                        if (line.endswith(" \n") or
+                                line.endswith(" \r\n") or
+                                line.endswith("\t\n") or
+                                line.endswith("\t\r\n")):
+                            f.append_comment(cur_line, "trailing spaces")
+                            trailing_sp_msg_count += 1
+
+                    if mixed_tabs_msg_count < MAX_MIXED_TABS_MSGS_PER_FILE:
+                        if re.match(r" +\t", line[1:]) or re.match(r"\t+ +\t", line[1:]):
+                            # tab space can be correct, but not space tab and tab space tab
+                            f.append_comment(cur_line, "possibly incorrect mixed spaces then tabs indentation")
+                            mixed_tabs_msg_count += 1
+
+                    if check_statement_spacing and spacing_msg_count < MAX_SPACING_MSGS_PER_FILE:
+                        m = re.match(r"\s*(if|while|for|switch)", line[1:])
+                        if (m):
+                            # line starts with if|while|for|switch
+                            keyword = m.group(1)
+                            # check parenthesis/brace spacing. if( -> if (    or    ){ -> ) {
+                            m = re.match(r"\s*(?:if|while|for|switch)( ?)\(.*\)( ?)(\{?)", line[1:])
+                            if (m):
+                                keyword_sp, brace_space, brace = m.groups()
+                                if keyword_sp != ' ' or (
+                                                brace == '{' and brace_space != ' '):
+                                    f.append_comment(cur_line,
+                                                     "%s (...) %s  // spacing around parenthesis" % (keyword, brace))
+                                    spacing_msg_count += 1
+
+                            # check binary operator spacing on if|while line
+                            # cpplint.py: match = Search(r'[^<>=!\s](==|!=|<=|>=|\|\|)[^<>=!\s,;\)]', line
+                            if keyword in ['if', 'while']:
+                                m = re.search(r"[^<>=!\s](==|!=|<=|>=|\|\||&&)[^<>=!\s,;\)]", line[1:])
+                                if (m):
+                                    f.append_comment(cur_line, "spacing around %s" % m.group(1))
+                                    spacing_msg_count += 1
+                            continue
+                        # do{ -> do {
+                        elif re.match(r"\s*do\{", line[1:]):
+                            f.append_comment(cur_line, 'do {')
+                            spacing_msg_count += 1
+
+                    if check_indent and indent_msg_count < MAX_INDENT_MSGS_PER_FILE:
+                        if ((context_indent == INDENT_SPACES and line.startswith("\t", 1)) or
+                                (context_indent == INDENT_TABS and line.startswith("    ", 1))):
+                            f.append_comment(cur_line, "make sure indent style matches rest of file")
+                            indent_msg_count += 1
+
+    if f and f.has_errors():
+        f.add_file_comments()
+        file_sections.append(f)
+
+    if False:
+        for f in file_sections:
+            assert isinstance(f, ChangedFile)
+            if f.comments:
+                print f.filename
+                pprint.pprint(f.comments)
+                print "---"
+    json_ret = file_comments_to_review(file_sections)
+    if json_ret:
+        print json_ret
+        return 0
+    else:
+        return 1
+
+REPLY_MSG = "This is an automated message.\n\nIf you think these comments are incorrect, they can be ignored."
+POSITIVE_REPLY_MSG = "This is an automated message.\n\nNo problems found."
+
+def file_comments_to_array(changed_file):
+    """
+    Return a list of comments for a CommentInput entry from a ChangedFile
+    :param changed_file: a ChangedFile object
+    :return: a list of comments for CommentInput
+    """
+    ret = []
+    assert isinstance(changed_file, ChangedFile)
+    for line, msg in changed_file.comments.iteritems():
+        ret.append({"line": line,
+                    "message": msg})
+    return ret
+
+def file_comments_to_review(changed_files):
+    """
+    Create a JSON ReviewInput from a list of ChangedFiles
+    :param changed_files: list of ChangedFiles
+    :return: JSON ReviewInput string
+    """
+    review = {}
+    review['comments'] = {}
+    for f in changed_files:
+        if f.filename and f.comments:
+
+            c = file_comments_to_array(f)
+            if not c:
+                logging.error("no comments for file")
+            review['comments'][f.filename] = c
+    if review['comments']:
+        review['message'] = REPLY_MSG
+        review['labels'] = {'Verified': -1}
+        review['notify'] = 'OWNER'
+    else:
+        del review['comments']
+        review['message'] = POSITIVE_REPLY_MSG
+        review['labels'] = {'Verified': +1}
+        review['notify'] = 'OWNER'
+    #return json.dumps(review, indent=2)
+    return json.dumps(review)
+
+if __name__ == '__main__':
+    if len(sys.argv) == 2:
+        r = check(sys.argv[1])
+        sys.exit(r)
+    else:
+        sys.stderr.write("%s <patch filename>\n" % sys.argv[0])
+    sys.exit(0)
+
diff --git a/scripts/amlogic/coding_style/fix_code.sh b/scripts/amlogic/coding_style/fix_code.sh
new file mode 100644
index 0000000..b34f0a9
--- /dev/null
+++ b/scripts/amlogic/coding_style/fix_code.sh
@@ -0,0 +1,32 @@
+#!/bin/bash
+
+# Amlogic gerrit code auto-fix script
+# Author: xiaobo.gu@amlogic.com
+# Init version: 2015.05.01
+
+# get current dir
+CUR_P=$(dirname $0)
+CUR_P=${CUR_P/\./$(pwd)}
+#echo $CUR_P
+
+# prepare variables
+REVIEW_OUTPUT=$CUR_P/review.txt
+PATCH_FILE_NAME=$CUR_P/patch_name
+#CUR_P=`abspath $pwd`
+#echo $CUR_P
+
+# get latest patch
+git format-patch -s -1 -o $CUR_P > $PATCH_FILE_NAME
+PATCH_NAME=`cat $PATCH_FILE_NAME`
+#echo $PATCH_NAME
+
+# check patch and generate review summary
+python $CUR_P/checkpatch.py $PATCH_NAME > $REVIEW_OUTPUT
+
+# fix files by review summary
+python $CUR_P/auto_fix.py $REVIEW_OUTPUT
+
+# cleanup
+rm $PATCH_FILE_NAME
+rm $REVIEW_OUTPUT
+rm $PATCH_NAME
\ No newline at end of file
diff --git a/sd_fuse/bl1.bin.hardkernel b/sd_fuse/bl1.bin.hardkernel
new file mode 100644
index 0000000..571fc46
Binary files /dev/null and b/sd_fuse/bl1.bin.hardkernel differ
diff --git a/sd_fuse/sd_fusing.sh b/sd_fuse/sd_fusing.sh
new file mode 100755
index 0000000..538185b
--- /dev/null
+++ b/sd_fuse/sd_fusing.sh
@@ -0,0 +1,34 @@
+#!/bin/sh
+#
+# Copyright (C) 2015 Hardkernel Co,. Ltd
+# Dongjin Kim <tobetter@gmail.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+BL1=bl1.bin.hardkernel
+UBOOT=u-boot.bin
+
+if [ -z $1 ]; then
+        echo "Usage ./sd_fusing.sh <SD card reader's device>"
+        exit 1
+fi
+
+if [ ! -f $BL1 ]; then
+        echo "error: $BL1 is not exist"
+        exit 1
+fi
+
+if [ ! -f $UBOOT ]; then
+        echo "error: $UBOOT is not exist"
+        exit 1
+fi
+
+sudo dd if=$BL1 of=$1 conv=fsync bs=1 count=442
+sudo dd if=$BL1 of=$1 conv=fsync bs=512 skip=1 seek=1
+sudo dd if=$UBOOT of=$1 conv=fsync bs=512 seek=97
+
+sync
+
+sudo eject $1
+echo Finished.
